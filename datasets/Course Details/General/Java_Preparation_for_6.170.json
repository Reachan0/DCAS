{
  "course_name": "Java Preparation for 6.170",
  "course_description": "This course focuses on introducing the language, libraries, tools and concepts of Javaᵀᴹ. The course is specifically targeted at students who intend to take 6.170 in the following term and feel they would struggle because they lack the necessary background. Topics include: Object-oriented programming, primitives, arrays, objects, inheritance, interfaces, polymorphism, hashing, data structures, collections, nested classes, floating point precision, defensive programming, and depth-first search algorithm.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering"
  ],
  "syllabus_content": "Course Meetings\n\n6.092 is a week-long (Monday through Friday) course, meeting three hours each day. A second week of additional lab and project work is also offered, but optional.\n\nCourse Description\n\nStudents who complete 6.092 will learn JavaTM fundamentals in preparation for taking 6.170 in the Spring. We'll cover the JavaTM language plus libraries and concepts useful to 6.170. Each of the five sessions consist of two hours of lecture and one hour of assisted lab work. Daily assignments are designed to take one hour, and can be turned in at the end of lab or before 6 PM, when solutions will be provided.\n\nA second week, which was optional, consisted of daily two hour lab sessions in which students worked on a single final project (instant message client that interfaces with AOL\n(r)\nAIM\nTM\nmessaging software). During this week, there were no lectures, and the final project was not graded; however the two hours were staffed by lab assistants to answer questions and provide feedback.\n\nAssignments\n\nSince the class is focused on preparing students for 6.170, the assignments given during the course were modified from 6.170 assignments while still concentrating on important concepts.\n\nRecommended Reading\n\nFlanagan, David.\nJavaTM in a Nutshell.\n5th ed. Cambridge, MA: O'Reilly, 2005. ISBN: 0596007736.\n\nFlanagan, David, and Brett McLaughlin.\nJavaTM 1.5 Tiger: A Developer's Notebook\n. Cambridge, MA: O'Reilly, 2004. ISBN: 0596007388.\n\nGrading\n\nThis was a P/D/F course and was graded on a three-part scale: check, check-plus, check-plus-plus. The top grade, signifying excellent Java\nTM\nprogramming, abbreviates to C++, another programming language (which is no coincidence). Everyone who participated in all 4 labs passed the course.",
  "files": [
    {
      "category": "Lecture Notes",
      "title": "lecture1a.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/35389e5815c6be386befb7bd00974735_lecture1a.pdf",
      "content": "6.092: Java for 6.170\nLucy Mendel\nMIT EECS\nMIT 6.092\nIAP 2006\n\nCourse Staff\nz Lucy Mendel\nz Corey McCaffrey\nz Rob Toscano\nz Justin Mazzola Paluska\nz Scott Osler\nz Ray He\nAsk us for help!\nMIT 6.092\nIAP 2006\n\nClass Goals\nz Learn to program in Java\nz Java\nz Programming (OOP)\nz 6.170 problem sets are not supposed to take\nyou 20 hours!\nz Tools, concepts, thinking\nMIT 6.092\nIAP 2006\n\nLogistics\nz 5 days long, optional second week\nz 2 hrs lecture, 1 hr lab\nz End of week might be 1 hr lecture, 2 hr lab\nz Breaks!\nz Labs\nz Work on homework with staff assistance (like LA\nhours in 6.170)\nz Mandatory even for listeners\nz Each is expected to take ~1-2 hrs\nMIT 6.092\nIAP 2006\n\nObject Oriented Programming\nz Objects have state\nz A person is an object and has a name, age, SS#,\nmother, &e.\nz Programmers call methods on objects to\ncompute over and potentially modify that\nstate\nz programmer: How old are you?\nz object: I am 22.\nz programmer: Today is your birthday!\nz object: I have incremented my age by 1.\nMIT 6.092\nIAP 2006\n\nJava Program\npackage hello;\nimport java.util.System;\nclass HelloWorld {\nString myString;\nvoid shout() {\nmyString = new String(\"Hello, World!\");\nSystem.out.println(myString);\n}\npublic static void main(String[] args) {\nHelloWorld myHelloWorld = new HelloWorld();\nmyHelloWorld.shout();\n}\nMIT 6.092\nIAP 2006\n}\n\nClass\nz Template for making objects\nz Java is about objects Æ everything is in a\nclass\nclass HelloWorld {\n// classname\n... <everything> ...\n}\nMIT 6.092\nIAP 2006\n\nField\nz Object state\nclass Human {\nint age;\n}\n<class type> <variable name>;\nMIT 6.092\nIAP 2006\n\nMaking objects\nHuman lucy = new Human();\nz All object creation requires a \"new\"\nz objects = instances (of classes)\nz lucy is a pointer to the object\nz We assign the constructed object to lucy\n<type> <variable name> = <new object>;\nMIT 6.092\nIAP 2006\n\nUsing Objects\nHuman lucy = new Human();\nlucy.age = 22;\n// use '.' to access fields\nHuman david = new Human();\ndavid.age = 19;\nSystem.out.println(lucy.age);\n// prints 22\nSystem.out.println(david.age);\n// prints 19\nMIT 6.092\nIAP 2006\n\nz Why did we not have to write\nlucy.age = new int(22);\n??\nMIT 6.092\nIAP 2006\n\nPrimitives\nz Not everything is an object\nz Some things are too simple and too\nfrequently used to be bothered with objects:\nz boolean, byte, short, int, long, double, float, char\nMIT 6.092\nIAP 2006\n\nField myString\nclass HelloWorld {\nString myString;\nvoid shout() {\nmyString = new String(\"Hello, World!\");\nSystem.out.println(myString);\n}\npublic static void main(String[] args) {\nHelloWorld myHelloWorld = new HelloWorld();\nmyHelloWorld.shout();\n}\n}\nMIT 6.092\nIAP 2006\n\nMethods\nz Process object state\n<return type> <method name>(<parameters>) {\n<method body>\n}\nmyHelloWorld.shout();\n// use '.' to access methods\nMIT 6.092\nIAP 2006\n\nConstructors\nz Constructors are special methods\nz no return type\nz use them to initialize fields\nz take parameters, normal method body (but no\nreturn)\nMIT 6.092\nIAP 2006\n\nMethod Body\nString firstname(String fullname) {\nint space = fullname.indexOf(\" \");\nString word = fullname.substring(0, space);\nreturn word;\n}\nz Any number of parameters\nz declare local variables\nz return one thing (void = return nothing)\nMIT 6.092\nIAP 2006\n\nControl Flow\nif (lucy.age < 21) {\n// don't do stuff\n} else if (lucy.hasCard()) {\n// do other stuff\n} else {\n// doh\n}\nif (<predicate1>) {\n...\n} else if (<predicate2>) {\n...\n} else if (<predicate3>) {\n....\n} else if (<predicateN>) {\n...\n} else { ... }\nMIT 6.092\nIAP 2006\n\nPredicates\nz predicate = true or false (boolean)\nz <, >, ==, <=, >=, !\nbox.isEmpty()\nbox.numberBooks() == 0\n!(box.numberBook() > 1)\nbox.numberBooks != MAX_NUMBER_BOOKS\nMIT 6.092\nIAP 2006\n\nFor Loop\nfor (int i = 0; i < 3; i++) {\nSystem.out.println(i);\n// prints 0 1 2\n}\nfor (<initialize> ; <predicate> ; <increment>) {\nexecute once\nevery time\nStop when predicate is false\nMIT 6.092\nIAP 2006\n\nWhile Loop\nint i = 0;\nwhile (i < 3) {\nSystem.out.println(i);\n// prints 0 1 2\n}\nwhile (<predicate>) {\n...\n}\nMIT 6.092\nIAP 2006\n\nCombining Predicates\nz && = logical and\nz || = logical or\na. lucy.age >= 21 && lucy.hasCard\nb. !someone.name.equals(\"Lucy\"))\nc. (!true || false) && true\nMIT 6.092\nIAP 2006\n\nArrays\nz Objects, but special like primitives\nString[] pets = new String[2];\npets[0] = new String(\"Fluffy\");\npets[1] = \"Muffy\";\n// String syntactic sugar\nString[] pets = new String[] {\"Fluffy\", \"Muffy\"};\nSystem.out.println(pets.length); // print 2\nMIT 6.092\nIAP 2006\n\nWhoa, how many types are\nthere?\nz primitives\nz int a = 3 + 5;\nz Objects\nz Integer a = new Integer(3);\nz Integer sum = a.add(5);\nz Arrays\nMIT 6.092\nIAP 2006\n\nObjects Cause Trouble!!\nz pets[3] >> halt program, throw\nArrayOutOfBoundsException\nz String[] str;\nz str.length >> halt, throw NullPointerExceptoin\nz Integer a = new Integer(3);\n// aÆ[3]\nz a.add(5);\n// aÆ[3]\nz a = a.add(5);\n// aÆ[8]\nMIT 6.092\nIAP 2006\n\nBreak (10 min)\nz When we get back, more on Objects from\nCorey\nMIT 6.092\nIAP 2006"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture1b.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/f74cb0369547c5c3c01447427ee2a64a_lecture1b.pdf",
      "content": "Day 1\nJava Objects\n6.092 Lecture 1 Part 2\nCorey McCaffrey\n\nMIT 6.092\nIAP 2006\nReview of references\nz References point to objects\nz A reference points to an instance of a\nparticular class\nz Declare a reference\nInteger x;\n\nMIT 6.092\nIAP 2006\nReview of objects\nz Classes define objects\nz An object is an instance of a particular class\nz Invoke a constructor to create an object:\nnew Integer(3);\n\nMIT 6.092\nIAP 2006\nReview of assignment\npublic class AssignmentReview {\npublic static void main(String[] args) {\nInteger num;\nnum = new Integer(3);\nInteger x = num;\nInteger y = new Integer(3);\nInteger z;\n}\n}\n\nMIT 6.092\nIAP 2006\nIntroducing the Java Heap\nThe Java Heap shows what references and objects exist at\nruntime:\nnum\nx\nInteger:\ny\nInteger:\nz\nnull\n\nMIT 6.092\nIAP 2006\nNull references\nz Unassigned references point to null\nz null is not an object (no fields, no methods)\nz z.intValue() results in an error\nz (a NullPointerException, to be exact)\n\nMIT 6.092\nIAP 2006\nAssignment versus mutation\nz Use \"=\" to assign an object to a reference\nz Some methods mutate their objects\nz References may share objects, so beware of\nside effects\n\nMIT 6.092\nIAP 2006\nMutation of shared object\npublic class MutationExample {\npublic static void main(String[] args) {\nList<String> a = new ArrayList<String>();\nList<String> b = a; // b & a share the List\na.add(\"Hello, world!\");\nSystem.out.println(b);\n// Prints \"Hello, world!\"\n}\n}\n\nMIT 6.092\nIAP 2006\nMutation of shared object\nJava Heap:\na\nb\nList<String>:\n[\"Hello, world!\"]\n\nMIT 6.092\nIAP 2006\nStatic versus non-static\nz Fields and methods may be declared \"static\"\nz Static members belong to the class\nz Non-static members belong to instances of\nthe class\n\nMIT 6.092\nIAP 2006\nNon-static fields\npublic class Bean {\npublic int beanCounter = 0;\npublic Bean() {\nbeanCounter++;\n}\npublic static void main(String[] args) {\nnew Bean(); new Bean();\nBean bean = new Bean();\nSystem.out.println(bean.beanCounter);\n// Prints \"1\"\n}\n}\n\nMIT 6.092\nIAP 2006\nStatic fields\npublic class Bean {\npublic static int beanCounter = 0;\npublic Bean() {\nbeanCounter++;\n}\npublic static void main(String[] args) {\nnew Bean(); new Bean(); new Bean();\nSystem.out.println(Bean.beanCounter);\n// Prints \"3\"\n}\n}\n\nMIT 6.092\nIAP 2006\nNon-static methods\npublic class Bean {\nprivate boolean planted = false;\npublic void plantBean() {\nplanted = true;\n}\npublic static void main(String[] args) {\nBean bean = new Bean();\nbean.plantBean();\n// Invoked on instance\n}\n}\n\nMIT 6.092\nIAP 2006\nStatic methods\npublic class Bean {\nprivate boolean planted = false;\npublic static void plantBean(Bean bean) {\nbean.planted = true;\n}\npublic static void main(String[] args) {\nBean bean = new Bean();\nBean.plantBean(bean); // Invoked on class\n// \"bean.plantBean(bean);\" legal but inadvisable!\n}\n}\n\nMIT 6.092\nIAP 2006\nObjects passed by reference\npublic static <T> void removeFirst(List<T> list) {\nlist.remove(0);\n}\npublic static void main(String[] args) {\nList<String> myList = new ArrayList<String>();\nmyList.add(\"Cat\"); myList.add(\"Dog\");\nremoveFirst(myList);\nSystem.out.println(myList); // Prints \"[Dog]\"\n}\n\nMIT 6.092\nIAP 2006\nObjects passed by reference\nJava Heap:\nmyList\nlist\nList<String>:\n[\"Cat\", \"Dog\"]\n\nMIT 6.092\nIAP 2006\nReferences have scope\nz Curly braces {...} define regions of scope\nz References exist from the time they are\ndeclared until they \"go out of scope\"\nz Fields may be referenced throughout class\nz Parameters may be referenced throughout\nmethod\n\nMIT 6.092\nIAP 2006\nExamples of scope\npublic class ScopeExample {\nprivate int globalField;\npublic int method(int parameter) {\nint localVar1;\nif (globalField > 0) {\nint x;\n}\nint localVar2;\n}\n}\n\nMIT 6.092\nIAP 2006\nMore examples of scope\npublic class ScopeExample {\nprivate int globalField;\npublic int method(int parameter) {\nint globalField; // Legal, but hides field!\nint localVar;\nif (this.globalField > 0) { // Accesses field\nint x;\n}\nint localVar; // Illegal: same scope\n}\n}\n\nMIT 6.092\nIAP 2006\nQuick Morals\nz Assignment: References merely point to objects;\nbeware of null pointers\nz Static: Don't invoke static methods on instances\nz Pass by Reference: Make a defensive copy to avoid\naccidental mutation\nz Scope: Minimize the scope of references as much\nas possible (e.g. don't make everything global)"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture2a.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/2db153242ca1c747fd6cd7c2b497162a_lecture2a.pdf",
      "content": "Classes &\nInterfaces\nJava's Object Oriented System\nJustin Mazzola Paluska\n\nKeywords\nz Class - a template of a data object\nz Interface - a specification\nz Instance - an instantiation of a Class or Interface\nphysically represented in memory\nz Method - a set sequence of instructions\nz Instance Field - variable associated with a\nparticular instance.\nz Static Field - variable shared among all instances\nof a Class\nclass members\n\nData Types\nz There are two types in Java\nz Primitive types\nz Reference types\nz Most of your time is spent using Reference\ntypes.\n\nReference Types\nz Also known as Objects\nz To create an instance of a reference type,\nuse the new keyword in Java\nz The new keyword:\n1. Makes space for the new object in memory\n2. Calls the constructor you specify\n3. Returns a reference to the new object\n\nExample Instantiation of a Class\nBankAccount account = new BankAccount();\nClass\nName\nInstance\nVariable\nName\nClass\nConstructor\n\nUse of instances\nz Call methods off of instances:\nz account.withdraw(amount);\nz account.deposit(amount);\nz Access its instance variables:\nz account.id\nz account.balance\nz When we're done with an object, we just stop\nusing it.\nz Java will garbage collect the object when there\nare no more references to it.\n\nDefining a Class\nz The template for a class definition follows:\n[access] [abstract/final] class className\n[extends superClassName]\n[implements interfaceNames...] {\n//constructors\n//member functions\n//member variables\n}\n\nSimple Example\npublic class BankAccount {\n...\n}\n\nClass Members\nz In class definitions we can define the\nfollowing members:\nz Constructors\nz Instance and static methods\nz Instance and static fields\nz Nested classes\n\nConstructors\nz Must have the same name of the Class that\nthey are in\nz Can have multiple constructors per Class\nz Handles initialization of your class\nz Template:\n[access] className ([arguments...]) {\n//constructor body\n}\n\nExample:\nSingle Constructor\npublic class BankAccount {\npublic BankAccount () {\n...\n}\n}\nNotice that the name of\nthe constructor is the\nsame as the class\n\nExample:\nMultiple Constructors\npublic class BankAccount {\npublic BankAccount () {\n...\n}\npublic BankAccount (int initialAmount) {\n...\n}\n}\nThese are different\nconstructors because they\ntake in different arguments\n\nMethods\nz Methods perform functions\nz Methods work on the state of the class\nz Like Scheme, methods can take in multiple\narguments, and return up to one value\nz If no value is to be returned, use the keyword void\nz A class can have as many methods as needed\nz Template:\n[access] returnType methodName ([arguments...]) {\n//method body\n}\n\nExample Methods\npublic class BankAccount {\npublic void withdraw (int amount) {\n...\n}\npublic int getAmount () {\n...\n}\n}\n\nMethod Overloading\nz A class can have two functions with the same\nname in a class as long as their arguments\ndiffer.\nz Example:\nz void foo () {...}\nz void foo (int bar) {...}\nz Java knows which method to call based on\nthe method signature\nz Example: myClass.foo(7) //calls 2nd method\n\nFields\nz A field is like a variable, it stores state\nz A field has a associated data type which\ndetermines the type of data that this field will\nhold\nz Template:\n[access] dataType fieldName [= value];\n\nExample Fields\npublic class BankAccount {\npublic int balance;\npublic Date lastWithdrawal;\npublic List transactions;\n}\n\nBringing It Together\npublic class BankAccount {\nprivate int balance;\npublic BankAccount () {\nbalance = 0;\n}\npublic void withdraw (int amount) {\nbalance = balance - amount;\n}\npublic void deposit (int amount) {\nbalance = balance + amount;\n}\n}\nField\nConstructor\nMethods\n\nAccessors\nz Before we saw the placeholder [access].\nz There are 4 types of access keywords to\ndescribe which classes have access:\nz public - any other class in any package\nz protected - any subclass has access\nz (default) - only classes within the same package\nz private - only accessible from within a class\nz Good for keeping data abstraction intact\n\nInheritance\nz Allows classes to inherit functionality from\nother classes\nz Allows data and procedural abstraction\nz Decreases complexity of large software\nsystems\n\nChecking and Savings\nz Two separate ideas with different behaviors,\nbut there exists overlap of functionality\nBankAccount\nCheckingAccount\nSavingsAccount\n\nInterfaces\nz An interface is a specification of a Class\nz Declares methods but does not define them\nz Interfaces do not have constructors\nz Template:\n[access] interface interfaceName\n[extends interfaceNameList...] {\n//method declarations\n}\n\nExample Interface\npublic interface BankAccount {\npublic void withdraw (int amount);\npublic void deposit (int amount);\npublic int getBalance ();\n}\nNotice that for method\ndeclarations, the method\nbody is not defined.\n\nHow do we use the Interface?\nz We make classes or other interface\nimplement or extend the interface.\nz If a class implements an interface, that class\nmust provide an implementation (a method\nbody) for every method specified by the\ninterface\nz If a class implements multiple interfaces, it must\nimplement all methods of every interface it\nchooses to implement\n\nExample Interface Use\npublic class CheckingAccount implements BankAccount {\nprivate int balance;\npublic CheckingAccount (int initial) {\nbalance = initial;\n}\n//implemented methods from BankAccount\npublic void withdraw (int amount) {\nbalance = balance - amount;\n}\npublic void deposit (int amount) {\nbalance = balance + amount;\n}\npublic int getBalance () {\nreturn balance;\n}\n}\nSince\nCheckingAccount\nimplements\nBankAccount, it\nmust provide\nimplementations\nfor these methods\n\nAbstract Classes\nz Abstract classes are a mix between\ninterfaces and classes\nz can have defined method bodies\nz can have fields\nz Helps to capture the idea of state as well as\nfunctionality\nz Template:\nSee Class template (use keyword abstract)\n\nAdvantage of Abstract Classes\nz For our BankAccount example we can\nchoose to provide implementations for\nmethods we know is common, and\ndeclarations for methods that might differ\nz Let's build an abstract class for BankAccount\n\nExample:\nAbstract Class\npublic abstract class BankAccount {\nprotected int balance;\npublic int getBalance () {\nreturn balance;\n}\npublic void deposit (int amount) {\nbalance = balance + amount;\n}\npublic void withdraw (int amount);\n}\n\nExample:\nClass Extension\npublic class CheckingAccount extends BankAccount {\npublic CheckingAccount () {\nbalance = 0;\n}\npublic void withdraw (int amount) {\nbalance = balance - amount;\n}\n}\n\nExample:\nClass Extension\npublic class SavingsAccount extends BankAccount {\nprivate int numberOfWithdrawals;\npublic SavingsAccount () {\nbalance = 0;\nnumberOfWithdrawals = 0;\n}\npublic void withdraw (int amount) {\nif (numberOfWithdrawals > 5) {\nthrow new RuntimeException (\"Cannot make >5 withdrawals a month\");\n} else {\nbalance = balance - amount;\nnumberOfWithdrawals++;\n}\n}\npublic void resetNumOfWithdrawals () {...}\n}\n\nBreak"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture2b.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/99c448c786f17c927be8e4fc1eb14eec_lecture2b.pdf",
      "content": "Polymorphism\nA deeper look into Java's\nprogramming model\nRobert Toscano\n\nMIT 6.092\nIAP 2006\nPolymorphism\nz Ability of objects belonging to different types\nto respond to methods of the same name\nz Ability to override functionality from extended\nsuper class\nz Java handles which overridden versions of\nmethods are to be executed\nz Lets have a look at some examples\n\nMIT 6.092\nIAP 2006\nThe Object Class\nz Every root class, that is a class that does not\nextend another class, implicitly extends the\njava.lang.Object class\nz java.lang.Object contains methods that all\nclasses inherit\nz These include:\nz clone, equals, finalize, getClass, hashCode,\nnotify, notifyAll, toString, and wait\n\nMIT 6.092\nIAP 2006\nOverriding Methods\nz Superclass\nz If class A extends class B, then class B is the\nsuperclass of A\nz Consequently, class A is a subclass of class B\nz If class B contains a method with the\nsignature:\nz public void foo (int arg)\nz Then class A can override the method by\nproviding a method with the same signature\nDifferent than\nMethod Overloading\n\nMIT 6.092\nIAP 2006\nThe equals method\nz public boolean equals (Object o);\nz All classes inherit this method from the\nObject class\nz Performs reference equality (checks whether\ntwo references refer to the same object in\nmemory)\nz You must override this method if your class\nneeds to have an idea of equality among\ninstances\n\nMIT 6.092\nIAP 2006\nUsing Object.equals method\nz Two CheckingAccounts are equal if they\nhave the same account balance\nz CheckingAccount c1 = new\nCheckingAccount(100);\nCheckingAccount c2 = new\nCheckingAccount(100);\nz c1.equals(c1);\nz c2.equals(c2);\nz c1.equals(c2);\n//== true\n//== true\n//== false\n\nMIT 6.092\nIAP 2006\nOur Own equals Method\npublic class CheckingAccount extends BankAccount {\n...\npublic boolean equals (Object o) {\nif (o instanceof CheckingAccount) {\nCheckingAccount c = (CheckingAccount)o;\nreturn balance == c.balance;\n} else {\nreturn false;\n}\n}\n...\n}\n\nMIT 6.092\nIAP 2006\nUsing your equals method\nz CheckingAccount c1 = new\nCheckingAccount(100);\nCheckingAccount c2 = new\nCheckingAccount(100);\nz c1.equals(c1);\nz c2.equals(c2);\nz c1.equals(c2);\n//== true\n//== true\n//== true\n\nMIT 6.092\nIAP 2006\nSomething Stranger\nz Object o1 = new CheckingAccount(100);\nObject o2 = new CheckingAccount(100);\nz o1.equals(o1);\nz o2.equals(o2);\nz o1.equals(o2);\nCompile-time Type\nRun-time Type\n//== true\n//== true\n//== true\n\nMIT 6.092\nIAP 2006\nCompile-time V.S. Run-time\nz Compile-time type\nz Type known ahead of time, at time of writing the\ncode--at compile time\nz During the lifetime of the program, the compile\ntime type never changes for a given instance\nz Run-time type\nz The compiler doesn't have a way of knowing what\nthe runtime type of an object is\n\nMIT 6.092\nIAP 2006\nMethod Dispatch\nz Even though our objects were of compile-\ntime type Object, the equals method of the\nCheckingAccount class was called\nz This occurs because Java chooses to call the\nmethod of the instance's run-time type and\nnot the compile-time type\nz Let's look at another example of method\ndispatch\n\nMIT 6.092\nIAP 2006\nExample: BankAccount\npublic abstract class BankAccount {\n...\npublic void withdraw (int amount) {...}\n...\n}\nz Now, CheckingAccount and SavingsAccount\nare overriding the withdraw method\n\nMIT 6.092\nIAP 2006\nExample: BankAccount\nBankAccount b1 = new CheckingAccount(10);\nBankAccount b2 = new SavingsAccount(10);\nb1.withdraw(5);\n//calls CheckingAccount.withdraw(int)\nb2.withdraw(5);\n//calls SavingsAccount.withdraw(int)\n\nMIT 6.092\nIAP 2006\nExample: Function Arguments\n...\npublic static boolean deleteAccount (BankAccount accnt) {\n...\n}\n...\nz Can pass a CheckingAccount or\nSavingsAccount, the compiler cannot know\ncachedBrain.addTextChannel(\"Messages\");\ncachedBrain.addTextChannel(\"Messages\");\n\nMIT 6.092\nIAP 2006\nAdvantages Of Using General\nTypes\nz Can change the underlying implementation\nlater\nz Don't have to change code because only use\nmethods from more general type\nz Example: Collection v.s. LinkedList and\nArrayList\n\nMad Libs\nMadLib\nTemplate\nMadLib\nTemplate\nMadLib\nTemplate\nMadLib\nTemplate\nMadLib\nTemplate\nis a\nis a\ncontains"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture3.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/050457e9d4f48a612421484aa1ee573c_lecture3.pdf",
      "content": "Day 3\nHashing, Collections,\nand Comparators\nWed. January 25th 2006\nScott Ostler\n\nHashing\nYesterday we overrode .equals()\nToday we override .hashCode()\nGoal: understand why we need to, and how\nto do it\n\nWhat is a Hash?\nAn integer that \"stands in\" for an object\nQuick way to check for inequality, construct\ngroupings\nEqual things (should) have equal hashs\n\nWhat is .hashCode()\nWell known method name that returns int\nIs defined in java.lang.Object to return a\nvalue mostly unique to that instance\nAll classes either inherit it, or override it\n\nhashCode Object Contract\nAn object's hashcode cannot change until it\nis no longer equal to what it was\nTwo equal objects must have an equal\nhashCode\nIt is good if two unequal objects have distinct\nhashes\n\nHashcode Examples\nString scott = \"Scotty\";\nString scott2 = \"Scotty\";\nString corey = \"Corey\";\nSystem.out.println(scott.hashCode());\nSystem.out.println(scott2.hashCode());\nSystem.out.println(corey.hashCode());\n=> -1823897190, -1823897190, 65295514\nInteger int1 = 123456789;\nInteger int2 = 123456789;\nSystem.out.println(int1.hashCode());\nSystem.out.println(int2.hashCode());\n=> 123456789, 123456789\n\nA Name Class with equals()\npublic class Name {\npublic String first;\npublic String last;\npublic Name(String first, String last) {\nthis.first = first;\nthis.last = last;\n}\npublic String toString() {\nreturn first + \" \" + last;\n}\npublic boolean equals(Object o) {\nreturn (o instanceof Name &&\n((Name) o).first.equals(this.first) &&\n((Name) o).last.equals(this.last));\n}}\n\nDo our Names work?\nName kyle = new Name(\"Kyle\", \"MacLaughlin\");\nName jack = new Name(\"Jack\", \"Nance\");\nName jack2 = new Name(\"Jack\", \"Nance\");\nSystem.out.println(kyle.equals(jack));\nSystem.out.println(jack.equals(jack2));\nSystem.out.println(kyle.hashCode());\nSystem.out.println(jack.hashCode());\nSystem.out.println(jack2.hashCode());\n⇒ false, true, 6718604, 7122755, 14718739\n* Objects are equal, hashCodes aren't\n\nWho cares about hashCode?\nName code seems to work\nIs this really a problem?\nIf we don't use hashCode(), why bother\nwriting it?\n\nANSWER: JAVA CARES!\nWe have violated the Object contract\nWe have embarked upon a path filled with\nBad, Strange Things\n\nBad, Strange Thing #1\nSet<String> strings = new HashSet<String>();\nSet<Name> names = new HashSet<Name>()\nstrings.add(\"jack\");\nnames.add(new Name(\"Jack\", \"Nance\"));\nSystem.out.println(strings.contains(\"jack\"));\nSystem.out.println(names.contains(\nnew Name(\"Jack\", \"Nance\"));\n=> true, false\n\nSolution? make .hashCode()\nRemember our requirements:\nhashCode() must obey equality\nhashCode() must be consistent\nhashCode() must generate int\nhashCode() should recognize inequality\n\nPossible Implementation\npublic class Name {\n...\npublic int hashCode() {\nreturn first.hashCode()\n+ last.hashCode();\n}\n}\nDoes this work?\n\nGood, Normal Thing #1\nSet<Name> names = new HashSet<Name>()\nnames.add(jack);\nSystem.out.println(names.contains(\nnew Name(\"Jack\", \"Nance\"));\n⇒ true\n* Could it be better?\n\nA Better Implementation\npublic class Name {\n...\npublic int hashCode() {\nreturn first.hashCode() * 37\n+ last.hashCode();\n}\n}\nWhy is it better? (remember contract)\n\nhashCode Object Contract\nAn object's hashcode cannot change until it\nis no longer equal to what it was\nTwo equal objects must have an equal\nhashCode\nIt is good if two unequal objects have distinct\nhashes\nEx: Jack Nance will be different from Nance Jack\n\nBefore We Switch Topics\nAny questions about hashCode, please ask!\nIt will be an important point later today\nIt will cause bizarre problems if you don't\nunderstand it\n\nWhat Collections Do\n\"Framework\" of Interfaces and Classes to\nhandle:\nCollecting objects\nStoring objects\nSorting objects\nRetrieving objects\nProvides common syntax across variety of\ndifferent Collection implementations\n\nHow to use Collections\nadd import java.util.*; to the top of every java\nfile\npackage lab2;\nimport java.util.*;\npublic class CollectionUser {\nList<String> list = new ArrayList<String>();\n... //rest of class\n}\n\nBasic Collection<Foo> Syntax\nboolean add(Foo o);\nboolean contains(Object o);\nboolean remove(Foo o);\nint size();\n\nExample Usage\nList<Name> iapjava = new ArrayList<Name>();\niapjava.add(new Name(\"Laura\", \"Dern\");\niapjava.add(new Name(\"Toby\", \"Keeler\");\nSystem.out.println(iapjava.size()); => 2\niapjava.remove(new Name(\"Toby\", \"Keeler\");\nSystem.out.println(iapjava.size()); => 1\nList<Name> iapruby = new ArrayList<Name>();\nIapruby.add(new Name(\"Scott\", \"Ostler\"));\niapjava.addAll(iapruby);\nSystem.out.println(iapjava.size()); => 2\n\nGeneric Collections\nWe can specify the type of object that a\ncollection will hold\nEx: List<String> strings\nWe are reasonably sure that strings contains\nonly String objects\nIs optional, but very useful\n\nWhy Use Generics?\nList untyped = new ArrayList();\nList<String> typed = new ArrayList<String>();\nObject obj = untyped.get(0);\nString sillyString = (String) obj;\nString smartString = typed.get(0);\n\nRetrieving objects\nGiven Collection<Foo> coll\nIterator:\nIterator<Foo> it = coll.iterator();\nwhile (it.hasNext) {\nFoo obj = it.next();\n// do something with obj\n}\nFor each:\nfor (Foo obj : coll) {\n// do something with obj\n}\n\nObject Removing Caveat\nCan't remove objects from a Collection while\niterating over it\nfor (Foo obj : coll)\ncoll.remove(obj) // ConcurrentModificationException\n}\nOnly the Iterator can remove an object it's iterating over\nIterator<Foo> it = coll.iterator();\nwhile (it.hasNext) {\nFoo obj = it.next();\nit.remove(Obj); // NOT coll.remove(Obj);\n}\nNote that iter.remove is optional, and not all Iterator objects\nwill support it\n\nGeneral Collection Types\nList\nArrayList\nSet\nHashSet\nTreeSet\nMap\nHashMap\n\nList Overview\nOrdered list of objects, similar to Array\nUnlike Array, no set size\nList order generally equals insert order\nList<String> strings = new ArrayList<String>();\nstrings.add(\"one\");\nstrings.add(\"two\");\nstrings.add(\"three\");\n// strings = [ \"one\", \"two\", \"three\"]\n\nOther Ways\nInsert at an index\nList<String> strings = new ArrayList<String>();\nstrings.add(\"one\");\nstrings.add(\"three\");\nstrings.add(1, \"two\");\n// strings = [ \"one\", \"two\", \"three\"]\nRetrieve objects with an index:\ns.o.print(strings.get(0))\n// => \"one\"\ns.o.print(strings.indexOf(\"one\"))\n// => 0\n\nSet Overview\nNo set size, no set order\nNo duplicate objects allowed!\nSet<Name> names = new HashSet<Name>();\nnames.add(new Name(\"Jack\", \"Nance\"));\nnames.add(new Name(\"Jack\", \"Nance\"));\nSystem.out.println(names.size()); => 1\n\nSet Contract\nA set element cannot be changed in a way\nthat affects its equality\nThis is a danger of object mutability\nIf you don't obey the contract, prepare for\nBad, Strange Things\n\nBad, Strange Thing #2\nSet<Name> names = new HashSet<Name>();\nName jack = new Name(\"Jack\", \"Nance\");\nnames.add(jack);\nSystem.out.println(names.size());\nSystem.out.println(names.contains(jack)); => true;\njack.last = \"Vance\";\nSystem.out.println(names.contains(jack)); => false\nSystem.out.println(names.size()); => 1\n\nSolutions to the Problem?\nNone.\nSo don't do it.\nIf at all possible, use immutable set elements\nOtherwise, be careful\n\nMap Overview\nMapping between a set of \"Key-Value Pairs\"\nThat is, for every Key object, there is a Value\nobject\nEssentially a \"lookup service\"\nKeys must be unique, but values don't have\nto be\n\nNote: Map is not a Collection\nMap doesn't support:\nboolean add(Foo obj);\nboolean contains(Object obj);\nRather, it supports:\nboolean put(Foo key, Bar value);\nboolean containsKey(Foo key);\nboolean containsValue(Bar value);\n\nSample Map Usage\nMap<String, String> dns = new HashMap<String, String>();\ndns.put(\"scotty.mit.edu\", \"18.227.0.87\");\nSystem.out.println(dns.get(\"scotty.mit.edu\"));\nSystem.out.println(dns.containsKey(\"scotty.mit.edu\"));\nSystem.out.println(dns.containsValue(\"18.227.0.87\"));\ndns.remove(\"scotty.mit.edu\");\nSystem.out.println(dns.containsValue(\"18.227.0.87\"));\n// => \"18.227.0.87\", true, true, false\n\nOther Useful Methods\nkeySet() - returns a Set of all the keys\nvalues() - returns a Collection of all the values\nentrySet() - returns a Set of Key,Value Pairs\nEach pair is a Map.Entry object\nMap.Entry supports getKey, getValue, setValue\n\nDangers of Key Mutability\nA key must always be equal to what it was\nThis is a restatement of the Set discussion\nIf a key chanages, it and its value will be\n\"lost\"\n\nBad, Strange Thing #3\nName isabella = new Name(\"Isabella\", \"Rosellini\")\nMap<Name, String> directory = new HashMap<Name, String>();\ndirectory.put(isabella, \"123-456-7890\");\nSystem.out.println(directory.get(isabella));\nisabella.first = \"Dennis\";\nSystem.out.println(directory.get(isabella));\ndirectory.put(new Name(\"Isabella\", \"Rosellini\"), \"555-555-1234\")\nisabella.first = \"Isabella\";\nSystem.out.println(directory.get(isabella));\nWhat happens?\n\nTwo Answers\nRight Answer:\n// => 123-456-7890, null, 555-555-1234\nRighter Answer:\nDoesn't matter because we shouldn't be doing\nit\nUnspecified behavior\n\nHow to Fix Mutable Keys?\nWe want to be able to use any object to\nstand in for another\nBut mutable objects are dangerous\n\nCopy the Key\nName dennis = new Name(\"Dennis\", \"Hopper\");\nName copy = new Name(dennis.first, dennis.last);\nmap.put(copy, \"555-555-1234\");\nNow changes to dennis don't mess up map\nBut the keys themselves can still be changed\nFor (Name name : map.keySet()) {\nname.first = \"u r wrecked\"; // uh oh\n}\n\nMake Immutable Keys\npublic class Name {\npublic final String first;\npublic final String last;\npublic Name(String first, String last) {\nthis.first = first;\nthis.last = last;\n}\npublic boolean equals(Object o) {\nreturn (o instanceof Name &&\n((Name) o).first.equals(this.first) &&\n((Name) o).last.equals(this.last));\n}}\n\nImmutable Proxy for Keys\nMap<String, String> dir = new HashMap<String, String>();\nName naomi = new Name(\"Naomi\", \"Watts\");\nString key = naomi.first + \",\" + naomi.last;\ndir.put(key, \"888-444-1212\");\nStrings are immutable, so our Maps will be safe\n\n\"Freeze\" Keys\npublic class Name {\nprivate String first;\nprivate String last;\nprivate boolean frozen = false;\n...\npublic void setFirst(String s) {\nif (!frozen) first = s;\n}\n... // do same with setLast\npublic void freeze() {\nfrozen = true;\n}\n}\n\nSummary: Mutable Keys\nEach approach has tradeoffs\nBut where appropriate, choose the simplest,\nstrongest solution\nIf a key cannot ever be changed, there will\nnever be problems\n\"Put and Pray\" only as a lost resort\n\nCollection Wrap-up\nCommon problems\nSharing obects between Collections\nTrying to remove an Object during iteration\nMutable Keys, Sets\nAny questions?\n\nComparing and Sorting\nUsed to decide, between two objects, if one\nis bigger or they are equal\n(a.compareTo(b)) should result in:\n< 0 if a < b\n= 0 if a = b\n> 0 if a > b\n\nComparison Example\nInteger one = 1;\nSystem.out.println(one.compareTo(3));\nSystem.out.println(one.compareTo(-50));\nString frank = \"Frank\";\nSystem.out.println(frank.compareTo(\"Booth\"));\nSystem.out.println(frank.compareTo(\"Hopper\"));\n// => -1 , 1, 4, -2\n\nSorting a List Alphabetically\nList<String> names = new ArrayList<String>();\nnames.add(\"Sailor\");\nnames.add(\"Lula\");\nnames.add(\"Bobby\");\nnames.add(\"Santos\");\nnames.add(\"Dell\");\nCollections.sort(names);\n// names => [ \"Bobby\", \"Dell\", \"Lula\", \"Sailor\",\n\"Santos\" ]\n\nComparable Interface\nWe can sort Strings because they implement\nComparable\nThat is, they have a \"Natural Ordering\".\nTo make Foo class Comparable, we have to\nimplement:\nint compareTo(Foo obj);\n\nA Sortable Name\npublic class Name implements Comparable<Name> {\n...\npublic int compareTo(Name o) {\nint compare = this.last.compareTo(o.last)\nif (compare != 0)\nreturn compare;\nelse return this.first.compareTo(o.first);\n}\n}\n\nSorting Names in Action\nList<Name> names = new ArrayList<Name>();\nnames.add(new Name(\"Nicolas\", \"Cage\"));\nnames.add(new Name(\"Laura\", \"Dern\"));\nnames.add(new Name(\"Harry\", \"Stanton\"));\nnames.add(new Name(\"Diane\", \"Ladd\"));\nnames.add(new Name(\"William\", \"Morgan\"));\nnames.add(new Name(\"Dirty\", \"Glover\"));\nnames.add(new Name(\"Johnny\", \"Cage\"));\nnames.add(new Name(\"Metal\", \"Cage\"));\nSystem.out.println(names);\nCollections.sort(names);\nSystem.out.println(names);\n// => [Johnny Cage, Metal Cage, Nicolas Cage, Laura Dern, Crispin Glover,\nDiane Ladd, William Morgan, Harry Stanton]\n\nComparator Objects\nTo create multiple sortings for a given Type,\nwe can define Comparator classes\nA Comparator takes in two objects, and\ndetermines which is bigger\nFor type Foo, a Comparator<Foo> has:\nint compare(Foo o1, Foo o2);\n\nA First-Name-First Comparator\npublic class FirstNameFirst implements\nComparator<Name> {\npublic int compare(Name n1, Name n2) {\nint ret = n1.first.compareTo(n2.first);\nif (ret != 0)\nreturn ret;\nelse return n1.last.compareTo(n2.last);\n}\n}\nThis goes in a separate file, FirstNameFirst.java\n\nDoes it Work?\nList<Name> names = new ArrayList<Name>();\n..\nComparator<Name> first = new FirstNameFirst();\nCollections.sort(names, first);\nSystem.out.println(names);\n// => [Crispin Glover, Diane Ladd, Harry Stanton, Johnny\nCage, Laura Dern, Metal Cage, Nicolas Cage, William\nMorgan]\nIt works!\n\nComparison Contract\nOnce again, there are rules that we must\nfollow\nSpecifically, be careful when\n(compare(e1, e2)==0) != e1.equals(e2)\nWith such a sorting, using SortedSet or\nSortedMap will cause Bad, Strange Things\n\nAnother Way of Sorting\nUse a TreeSet - automatically kept sorted!\nEither the Objects in TreeSet must implement Comparable\nOr give a Comparator Object when making the TreeSet\nSortedSet<Name> names = new TreeSet<Name>(new\nFirstNameFirst());\nnames.add(new Name(\"Laura\", \"Dern\"));\nnames.add(new Name(\"Harry\", \"Stanton\"));\nnames.add(new Name(\"Diane\", \"Ladd\"));\nSystem.out.println(names);\n// => [Diane Ladd, Harry Stanton, Laura Dern]\n\nDay 3 Wrap-Up\nAsk questions!\nThere was more here than anyone could get\nor remember\nThink of what you want your code to do, and\nthe best way to express that\nRead Sun's Java Documentation:\nhttp://java.sun.com/j2se/1.5.0/docs/api\nNo one can keep Java in their head\nEverytime you code, have this page open"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture4.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/3f3161bffccbbbc2376e56def7119d7a_lecture4.pdf",
      "content": "6.092: Thursday\nLecture\nLucy Mendel\nMIT EECS\nMIT 6.092\nIAP 2006\n\nTopics\nz Interfaces, abstract classes\nz Exceptions\nz Inner classes\nMIT 6.092\nIAP 2006\n\nAbstract Classes\nz Use when subclasses have some code in common\nabstract class Person {\nprivate String name = \"\";\npublic String getName() { return name; }\npublic void setName(String n) { name=n; }\nabstract public String sayGreeting();\n}\nclass EnglishPerson extends Person {\npublic String sayGreeting() { return \"Hello\"; }\n}\nMIT 6.092\nIAP 2006\n\nInterfaces\nz Use to make distinct or unknown or unspecified\ncomponents plug-and-play\npublic interface Dragable {\npublic void drag();\n}\npublic class Icon implements Dragable {\npublic void drag() { ... }\n}\nPublic class Chair implements Dragable {\npublic void drag() { ... }\n}\nMIT 6.092\nIAP 2006\n\nAnother reason to use\nInterfaces\nPublic abstract class Cowboy {\n/*kill something*/\npublic void draw() {...}\n}\nPublic abstract class Curtain {\n/*let in sunshine*/\npublic void draw() {...}\n}\nMIT 6.092\nIAP 2006\n\nCowboy Curtain\npublic class CowboyCurtain extends\nCowboy, Curtain {\n...\n}\nCowboyCurtain cowboy = new CowboyCurtain();\nCowboy.draw();\n// does it get brighter or does something die?\nMIT 6.092\nIAP 2006\n\nMultiple implements, single\nextends\ninterface Drawable {\npublic void draw();\nclass Icon implements\n}\nDrawable, Clickable, Draggable {\ninterface Clickable {\npublic void draw() {\npublic void click();\nSOP(\"drawing...\"); }\n}\npublic void click() {\nSOP(\"clicking...\"); }\ninterface Draggable {\npublic void drag() {\npublic void drag();\nSOP(\"dragging...\"); }\n}\n}\nMIT 6.092\nIAP 2006\n\nSubtyping\nclass Square {\nShould:\npublic int width;\nSquare extend Rectangle?\n}\nRectangle extend Square?\nclass Rectangle {\npublic int width,height;\n}\n...\nint calculateArea (Square x) {\nreturn (x.width)*(x.width); }\nint calculateCircumference (Rectangle x) {\nreturn 2*(x.width+x.height); }\nMIT 6.092\nIAP 2006\n\nRectangle extends Square\nclass Square {\npublic int width;\nSquare( int x ) { width = x; }\n}\nclass Rectangle extends Square {\npublic int height;\nRectangle( int width, int height ) {\nsuper(width);\nthis.height = height; }\n}\n...\nRectangle rect = new Rectangle( 2, 3 );\ncalculateArea( rect ) ;\n// returns 4, not 6 !\nMIT 6.092\nIAP 2006\n\nSquare extends Rectangle\nclass Rectangle {\npublic int width, height;\n}\nclass Square extends Rectangle {\npublic int side;\n}\n...\nSquare square = new Square( 3 );\ncalculateCircumference( sq ) ; // w.t.f. no height!\nMIT 6.092\nIAP 2006\n\nSquare extends Rectangle\nclass Rectangle {\npublic int width, height;\nRectangle( int width, int height ) {\nthis.width = width; this.height = height; }\n}\nclass Square extends Rectangle {\nSquare( int x ) { super( x, x ); }\n}\n...\nSquare square = new Square( 3 );\ncalculateCircumference( sq ) ; // 12, ok\nMIT 6.092\nIAP 2006\n\nTrue Subtyping\nz Inheritance (extending classes) re-uses code\nz A true subtype will behave the right way when used\nby code expecting its supertype.\nclass B {\nBicycle myMethod(Bicycle arg) {...}\n}\nclass A {\nRacingBicycle myMethod(Vehicle arg) {...}\n}\nMIT 6.092\nIAP 2006\n\nComposite\nz Contain a class, rather than extend it\nclass ListSet { // might want to implement Set\nprivate List myList = new ArrayList();\nvoid add(Object o) {\nif (!myList.contains(o)) myList.add(o);\n}\n...\nMIT 6.092\nIAP 2006\n\nExceptions\nz Goal: help programmers report and handle errors\nz What happens when an exception is thrown?\nz Normal program control flow halts\nz Runtime environment searches for handler:\ntry {\nstatement(s) that might throw exception\n} catch (exceptiontypeA name) {\nhandle or report exceptiontypeA\n} catch (exceptiontypeB name) {\nhandle or report exceptiontypeB\n} finally {\nclean-up statement(s)\n}\nMIT 6.092\nIAP 2006\n\nExceptions\nMIT 6.092\nIAP 2006\n\nException Catching\nclass Editor {\npublic boolean openFile( String filename ) {\ntry {\nboolean fileOpen = true;\nFile f = new File(filename);\n// do stuff with f\nreturn true;\n} catch (FileNotFoundException e) {\ne.printStackTrace();\nreturn false;\n} finally {\nfileOpen = false;\n}\nSystem.out.println(\" bar \");\n}\n}\nMIT 6.092\nIAP 2006\n\nException Throwing\npublic class File {\npublic File(String filename) throws\nFileNotFoundException {\n...\nif ( can't find file ) {\nthrow new FileNotFoundException();\n}\n}\n}\nMIT 6.092\nIAP 2006\n\nNested (or Inner) Classes\nclass EnclosingClass {\n...\nclass ANestedClass {\n...\n}\nWhy use nested\nclasses?\n...\n}\nMIT 6.092\nIAP 2006\n\nNested Classes\nMIT 6.092\nIAP 2006\n\nNested Class Properties\nz Have access to all members of the enclosing class,\neven private members\nz can be declared static (and final, abstract)\nz Non-static (or instance) nested classes are called\ninner classes\nclass EnclosingClass {\nstatic class StaticNestedClass { ... }\nclass InnerClass { ... }\n}\nMIT 6.092\nIAP 2006\n\nIAP 2006\nInner Classes\n(non-static nested classes)\nz Associated with an instance of the enclosing\nclass\nz Cannot declare static members\nz Can only be instantiated within context of\nenclosing class\nMIT 6.092\n\nLocal Anonymous Inner Class\npublic class Stack {\nprivate ArrayList items;\npublic Iterator iterator() {\nprivate class StackIterator implements Iterator {\nint currentItem = items.size() - 1;\npublic boolean hasNext() { ... }\npublic ArrayList<Object> next() { ... }\npublic void remove() { ... }\n}\nreturn new StackIterator();\n}\n/* or declare here */\n}\nMIT 6.092\nIAP 2006\n\nAnonymous Inner Class\npublic class Stack {\nprivate ArrayList items;\npublic Iterator iterator() {\nreturn new Iterator() {\nint currentItem = items.size() - 1;\npublic boolean hasNext() { ... }\npublic ArrayList<Object> next() { ... }\npublic void remove() { ... }\n} ;\n}\n}\nMIT 6.092\nIAP 2006\n\nFloating Point Precision\nSystem.out.println(1.00 - .42);\n// 0.6100000000000000001\nSystem.out.println(1.00 - 9*.10) ;\n// 0.0999999999999999995\nz BigDecimal\nz Pain of using Objects\nz int or long\nz keep track of decimal yourself, eg, put money in terms of\npennies\nMIT 6.092\nIAP 2006\n\nDefensive Programming\nMIT 6.092\nIAP 2006\n\npublic class Man {\nprivate Wallet myWallet;\npublic Money payPaperboy() {\nreturn myWallet.money;\n}\n}\npublic class Paperboy {\npublic Money payment;\npublic void getPaid( Man m ) {\npayment += m.payPaperboy();\n}\n}\nMIT 6.092\nIAP 2006\n\nMinimize Accessibility\npublic class Man {\npublic Wallet myWallet;\n}\npublic class Paperboy {\npublic Money payment;\npublic void getPaid( Man m ) {\npayment += m.myWallet.money;\n}\n}\nMIT 6.092\nIAP 2006\n\nKeep field references unique\nz Copy parameters before assigning them to fields\nz Copy fields before returning them\npublic final class Period {\nprivate final Date start;\nprivate final Date end;\npublic Period(Date satrt, Date end) {\nif (start.compareTo(end) > 0)\nthrow new IllegalArgumentException(start\n+ \" after \" + end);\nthis.start = start;\nthis.end = end;\n}\npublic Date start() { return start; }\npublic Date end() { return end; }\n}\nMIT 6.092\nIAP 2006"
    },
    {
      "category": "Resource",
      "title": "aim_messenger.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/4bb68663f2f22dd5b2c5354a56042db5_aim_messenger.pdf",
      "content": "Roll your own AIM Client!\nRoll your own AIM Client!\nFor the rest of this week, we're going to be working on aspects of an AOL Instant Messager client. By the end of the week, you should be\nable to exchange IMs with your friends using a client that you wrote yourself!\nOverview\nAIM uses two protocols: OSCAR and TOC. OSCAR is the protocol that most AIM clients use, be it AOL's own client, GAIM, or Trillian.\nUnfortunately, OSCAR is a binary protocol--so it requires manipulating bytes rather than Strings in order to do anything--and, even worse,\nundocumented. TOC, on the other hand has fewer features, but is text based and documented. We're going to use TOC and have provided the\ndocumentation for it on our homepage.\nAs a historical note, there are two versions of TOC: TOC and TOC2. TOC is no longer supported by AOL and no AOL servers recognize it.\nWe're going to be using TOC2, which fixes some of the bugs in the TOC protocol and adds new features.\nThe TOC protocol is pretty simple. After an initial song and dance to get a connection, you send text messages to the server when you want to\nsend an IM and the server sends text messages back to you. If there is an error, the server will either send you an error message or drop the\nconnection. (This is a simple behavior, but pretty annoying to debug.) To do simple IMMing you only need to support the following\nmessages.\n● (Server to Client): SIGN_ON, IM_IN2, ERROR\n● (Client to Server): toc_signon, toc_init_done, toc2_send_im\nThe TOC messages themselves are wrapped in FLAP packets. We suggest that you read through all of the TOC documentation to get an idea\nwhat is going on with the protocol and exactly what each of the protocol messages do.\nSupport Code\nWe've provided a bunch of support code and for building your AIM client. The functionality is broken into three main layers, with each layer\nrepresented by a Java class and a set of TOCMessage sub-classes that provide Java object representations of TOC protocol messages.\n● edu.mit.tbp.se.chat.ui.TextUI -- a simple text-based user-front end. The one main command it provides is sendim\nbuddyname message.... Try IMming people once you get the >>> prompt.\nThe TextUI class communicates with lower-level classes using TOCMessage objects. Each message to or from the server is\nrepresented as a TOCMessage.\n● edu.mit.tbp.se.chat.message.MessageLayer -- lower-level code that deals with sending and receiving TOC protocol\nmessages to and from the server.\nThe MessageLayer class relies on the individual TOCMessage sub-classes to convert themselves into the protocol strings that the\nTOC protocol expects. You're going to spend most of your time today writing code at this level.\n● edu.mit.tbp.se.chat.connection.FLAPConnection -- very low level code that deals with sending and receiving bytes\nfrom the server using the FLAP framing protocol.\n\nRoll your own AIM Client!\nAs the figure above illustrates, there are two main paths through these classes. The message sending path starts when the TextUI calls\nsendMessage() in the MessageLayer. MessageLayer.sendMessage() in turn turns the TOCMessage into a string and calls on\nFLAPConnection.writeMessage(). FLAPConnection.writeMessage() finally converts the TOC protocol string into a bunch\nof bytes and sends them across the internet to the TOC server.\nThe message receive path also starts at the TextUI. To get the next message, the TextUI calls MessageLayer.receiveMessage(),\nwhich calls FLAPConnection.readMessage(). FLAPConnection.readMessage() waits until it has a complete message from\nthe TOC server. When it does, readMessage() returns it as a string, which the MessageLayer turns into a TOCMessage , which\nfinally gets delivered to the TextUI The MessageLayer class converts Strings into TOCMessage objects that the user interface can use.\nWe've provided, on our homepage, a jar of our implementation so you can get a feel of what we're going to be doing before you write yours.\nTo run our implementation, download our jar file and type:\njava -jar saim.jar username password\nto start the client. You should get a command prompt. Type help to see what options are available to you. If start the client with no options,\nit will give you a command-line usage statement. It's probably useful to play with the --log option. Our code outputs protocol messages at\nlogging level FINER and byte-level output at logging level FINEST.\nAssignment\nWe're going to implement the MessageLayer class and a few TOCMessages to make using the class easier. Before you get started, read\nthe TOC protocol documentation and read through the documentation for our classes on the website. In particular, pay attention to the\nspecification for each method and the different kinds and try to relate their function to parts of the TOC protocol.\nThere are three main methods that you need to implement in the MessageLayer: login, sendMessage, and receiveMessage.\nlogin should use the other two methods, so it's probably a good idea to implement them first and test them using the login method.\nYou'll also need to implement a TOCMessage sub-class for each kind of message you'll need to send--more or less the list we presented in\nthe TOC introduction. To support sign-in, you need to be able to respond to the SIGN_ON message as well as send the toc_signon, and\ntoc_init_done messages. To support really basic IMming, you need to be able to send toc2_send_im messages and receive IM_IN2 messages.\nThe TextUI knows how to handle the ServerIMIn2Message and Toc2SendIMMessage classes, but you must provide\nimplementations for them. Finally, we've provided code that handles the ERROR message from the server and turns them into checked\nexceptions.\nWe've provided specifications and starter code for most of the classes you need to implement. Feel free to eschew our system entirely, but\nyou'll probably get further working with our code.\nHelp\nDon't forget to ask for help. This is a non-trivial assignment and we're here to help you get through it.\nLogging\nOur code uses the java.util.logging API to control how much debugging output you get. If you give our code a --log=LEVEL on the\n\nRoll your own AIM Client!\ncommand line, you can get more debugging information. To see what protocol-level options are being sent, set it to the FINER level.\nTo use the logger in your code, read the Logger class's API and mirror the usage in our code.\nMore Stuff\nIf you get your client working, there's more you can do. If you want to do more low-level code, try your hand at implementing the\nFLAPConnection class. In doing so, you will learn how to use network sockets and the joy of manipulating byte streams to do your\nbidding. If that's not your cup of tea, try building your own UI, maybe using a GUI. Finally, TOC2 has a bunch of useful commands for\nmanipulating buddy lists and block lists, so an easy extension might be to add buddy list capabilities.\nIn any case, find a staff member and go over what you want to do so we can help."
    },
    {
      "category": "Resource",
      "title": "javadoc.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-java-preparation-for-6-170-january-iap-2006/d9a4b4c7e90404b7c6d100c65ecd7322_javadoc.pdf",
      "content": "Generated Documentation (Untitled)\nOverview\nTree Deprecated Index Help\nPREV NEXT\nFRAMES\nNO FRAMES\nPackage Class\nAll Classes\nPackages\nedu.mit.tbp.se.chat\nedu.mit.tbp.se.chat.\nconnection\nedu.mit.tbp.se.chat.message\nedu.mit.tbp.se.chat.ui\nPackages\nedu.mit.tbp.\nse.chat\nedu.mit.tbp.\nse.chat.\nconnection\nedu.mit.tbp.\nse.chat.\nmessage\nedu.mit.tbp.\nse.chat.ui\nAll Classes\nAIMErrorException\nConnectionObserver\nFLAPConnection\nMessageLayer\nServerIMIn2Message\nServerSignOnMessage\nSignOnException\nTextUI\nToc2SendIMMessage\nToc2SignonMessage\nToc2SignonMessageTests\nTocInitDoneMessage\nTOCMessage\nTocMessageTests\nTocUserMessage\nOverview\nTree Deprecated Index Help\nPREV NEXT\nFRAMES\nNO FRAMES\nPackage Class"
    }
  ]
}