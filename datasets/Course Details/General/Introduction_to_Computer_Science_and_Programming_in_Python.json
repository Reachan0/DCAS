{
  "course_name": "Introduction to Computer Science and Programming in Python",
  "course_description": "6.0001 Introduction to Computer Science and Programming in Python is intended for students with little or no programming experience. It aims to provide students with an understanding of the role computation can play in solving problems and to help students, regardless of their major, feel justifiably confident of their ability to write small programs that allow them to accomplish useful goals. The class uses the Python 3.5 programming language.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Algorithms and Data Structures",
    "Programming Languages",
    "Engineering",
    "Computer Science",
    "Algorithms and Data Structures",
    "Programming Languages"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1 hour / session\n\nRecitations: 1 sessions / week, 1 hour / session\n\nCourse Information\n\n6.0001 Introduction to Computer Science and Programming in Python\nis intended for students with little or no programming experience. It aims to provide students with an understanding of the role computation can play in solving problems and to help students, regardless of their major, feel justifiably confident of their ability to write small programs that allow them to accomplish useful goals. The class will use the Python 3.5 programming language.\n\nThis is a half-semester course. Students who successfully complete 6.0001 may continue into\n6.0002 Introduction to Computational Thinking and Data Science\n, which is taught in the second half of the semester.\n\nGoals\n\nProvide an understanding of the role computation can play in solving problems.\n\nHelp students, including those who do not plan to major in Computer Science and Electrical Engineering, feel confident of their ability to write small programs that allow them to accomplish useful goals.\n\nPosition students so that they can compete for research projects and excel in subjects with programming components.\n\nTextbook\n\nThe textbook is\nGuttag, John.\nIntroduction to Computation and Programming Using Python: With Application to Understanding Data Second Edition\n. MIT Press, 2016. ISBN: 9780262529624. The book and the course lectures parallel each other, though there is more detail in the book about some topics. It is available both in hard copy and as an e-book.\n\nLecture and Recitation Attendance\n\nA significant portion of the material for this course will presented only in lecture, so students are expected to regularly attend lectures.\n\nRecitations give students a chance to ask questions about the lecture material or the problem set for the given week. Sometimes, new material may be covered in recitation. Recitation attendance is encouraged but not required.\n\nProblem Sets and Quizzes\n\nEach problem set will involve programming in Python. There will be 6 problem sets in the course. There will be two quizzes. All quizzes will be closed-book, though you will be allowed to bring one page of notes to the first quiz and two pages of notes to the second quiz. Pages must be letter-sized, double-sided, either handwritten or typed.\n\nGrading Policy\n\nGrades will be roughly computed as follows:\n\nACTIVITIES\n\nPERCENTAGES\n\nProblem sets\n\n30%\n\nCompletion of mandatory finger exercises\n\n10%\n\nMidterm Quiz\n\n20%\n\nFinal Quiz\n\n40%\n\nProblem sets will be graded out of 10 points. Submissions that do not run will receive at most 20% of the points. Please contact your Teaching Assistant if you have a problem understanding your problem set grade.\n\nNote: Quizzes and finger exercises are not available on OpenCourseWare.\n\nExtension and Dropping Problem Sets Policy\n\nWe do not grant any extensions. Instead, we offer late days and the option of rolling at most 2 problem set grades into the final quiz score.\n\nLate Days\n\nAt the beginning of the term, students are given two late days that they can use on problem sets. Starting with Problem Set 1, additional late days can be accumulated for each assignment, one late day for each day the assignment is turned in ahead of the deadline. Up to three late days may be accumulated in this fashion in this course, i.e you can only have a maximum of 3 late days at any point in time. Late days are discrete (a student cannot use half a late day). The staff will keep track of late days and feedback for each problem set will include the number of late days the student has remaining. Any additional late work beyond these late days will not be accepted. To avoid surprises, we suggest that after you submit your problem set, you double check to make sure the submission was uploaded correctly.\n\nRolling Over Problem Sets\n\nBefore the final quiz, we will send out an announcement in which you can choose at most 2 problem sets that you can drop. If dropped, the percent that the problem sets are worth will be rolled into the final quiz score. We strongly urge you to see the late days and dropping the problem sets as backup in case of an emergency. Your best strategy is to do the problem sets early before work starts to pile up.\n\nCalendar\n\nSES #\n\nTOPICS\n\nASSIGNMENTS\n\nWhat is computation?\n\nPset 0 released\n\nBranching and Iteration\n\nPset 1 released\n\nString Manipulation, Guess and Check, Approximations, Bisection\n\nPset 0 due\n\nDecomposition, Abstractions, Functions\n\nPset 2 released\n\nTuples, Lists, Aliasing, Mutability, Cloning\n\nPset 1 due\n\nRecursion, Dictionaries\n\nPset 3 released\n\nTesting, Debugging, Exceptions, Assertions\n\nPset 2 due; Quiz 1\n\nObject Oriented Programming\n\nPython Classes and Inheritance\n\nPset 3 due; Pset 4 released\n\nUnderstanding Program Efficiency, Part 1\n\nPset 4 due; Pset 5 released\n\nUnderstanding Program Efficiency, Part 2\n\nSearching and Sorting\n\nPset 5 due; Final Quiz",
  "files": [
    {
      "category": "Resource",
      "title": "Additional Python Resources",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/5dbf3131e472f4f013b1896c05b9f7a3_MIT6_0001F16_additional.pdf",
      "content": "Additional Python Resources\nIf you're having trouble with a particular concept or simply want to have access to more\ninformation, try one of the following links.\n\nDOCUMENTATION\n-\nOfficial Python 3 Documentation - \"official\"/technical explanation of what a particular function/operator\ndoes, examples of correct syntax, what the various libraries are, etc.\n\nTEXTBOOKS/TUTORIALS\n-\nDive Into Python - another survey of Python syntax, datatypes, etc.\n-\nThink Python by Allen Downey - a good general overview of the Python language. Includes exercises.\n-\nThe Official Python Tutorial - self-explanatory\n-\nLearn Python the Hard Way - (note: for Python 2) another free online text\n-\nReserved Keywords in Python - don't use these as variable names\n-\nPEP 8 - Style Guide for Python Code - learn what is good and bad style in Python\n-\nCheckIO - learn Python by exploring a game world\n-\nInvent with Python - develop your Python skills by making games or hacking ciphers\n-\nCodecademy - (note: for Python 2) learn Python by building web apps and manipulating data; interactive\ntutorial sequence\n-\nPython Tutor - interactive tutorial sequence of exercises\n\nDEBUGGING\n-\nPython Tutor - an excellent way to actually visualize how the interpreter actually reads and executes\nyour code\n-\nDiffChecker - compares two sets of text and shows you which lines are different\n-\nDebugging in Python - steps you can take to try to debug your program\n\nSOFTWARE\n-\nPython Tools for Visual Studio - Visual Studio plug-in enabling Python programming\n\nOTHER Q&A\n-\nStack Overflow - a large Q&A forum for programming concepts (not just Python). Try searching here\nbefore you post on the edX forum, and you may find that someone has already answered your question.\n\nMORE PRACTICE PROBLEMS\n-\nPython Challenge - a series of puzzles you can try to test your Python abilities\n-\nProject Euler - additional programming challenges you can try once your Python knowledge becomes\nstronger; problems are sorted by increasing difficulty\n-\nCoding Bat - problems you can solve within an online interpreter\n-\nCodewars - improve your skills by training on real code challenges\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Style Guide",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/f79b87104b0a0f787f6a43413e8eafd0_MIT6_0001F16_StyleGuide.pdf",
      "content": "Table of Contents:\n1. Integers and floats\n2. for vs. while loops\n3. Checking boolean conditions with if/else\n4. Docstrings\n5. Changing collections while iterating over them\n6. Directly Accessing Instance Variables\n7. Calling a superclass constructor from a subclass\n8. Pitfalls of storing custom objects in data structures\n9. Which data structure should I use?\n1. Integers and floats\nBe careful when deciding whether to represent data as integers or floats, and be sure that you\nconsider all possible behaviors in computation.\nFor a detailed explanation of how Python represents floats, read Section 3.4 (pp. 29-31) of\nyour textbook. In short, floats are represented as factors of powers of two, and many decimal\nnumbers cannot be exactly represented in this manner. The most common problem you'll find\nis trying to check for equality with a floating point number that you are changing. Say that you\nhave a while loop that increments a float by 0.1, and you want this whole loop to continue until\na control variable equals 0.3. You might find that setting up your loop in the following manner\nproduces an infinite loop:\nvariable = 0.0\nwhile variable != 0.3:\nvariable += 0.1\nThat's because 0.1+0.1+0.1 is not equal to 0.3. 0.1 cannot be precisely represented as a\nfloating point number, so 0.1+0.1+0.1 = 0.30000000000000004. When you are trying to take\nsimple counts of elements, always use integers to avoid this type of problem.\nAdditionally, make sure that you typecast between floats and integers at the appropriate time.\nIf you want to do integer division of 3 over 5, writing float(3/5) won't produce the desired result.\nRemember that Python evaluates inner expressions first, so your code will actually do integer\ndivision of 3/5, then cast the result to a float. Instead, you should cast one (or both) of the\nintegers to a float before doing the division - in this case, float(3)/5 or 3/float(5). You'll usually\nrun into this problem when taking averages or calculating percentages.\n2. for vs. while loops\nChoosing the right loop type makes your code more legible and can also help prevent bugs.\nEverything that can be written with a for loop can be written with a while loop, but while loops\ncan solve some problems that for loops don't address easily. You should usually write for loops\n\nwhen possible.\nIn general, use for loops when you know the number of iterations you need to do - e.g., 500\ntrials, one operation per character in a string, or an action on every element in a list. If you can\ndescribe the problem you're trying to solve in terms of each or every element in an iterable\nobject, aim for a for loop. Using a for loop when possible will decrease the risk of writing an\ninfinite loop and will generally prevent you from running into errors with incrementing counter\nvariables.\nExample (print \"hello\" 500 times):\nfor i in xrange(500):\nprint 'hello'\nExample (add 1 to every element in the list):\nmy_list = [5, 2, 7, -4, 0]\nfor i in xrange(len(my_list)):\nmy_list[i] += 1\nIf you're instead iterating for a certain condition to be satisfied, you want to use a while loop.\nWhile loops are useful when you can define the number of iterations in terms of a boolean\nvariable. If you are waiting for a user to enter an input correctly or are waiting for a randomly\ngenerated value to exceed a certain amount, you'll want to use a while loop. Problems that can\nbe described using \"until\" should use while loops.\nExample (loop until the user enters a positive number):\nnum = float(raw_input('Enter a positive number: '))\nwhile num <= 0.0:\nnum = float(raw_input('Enter a POSITIVE number: '))\nExample (loop until the randomly generated number is greater than 0.5):\nimport random\nnum = random.random()\nwhile num <= 0.5:\nnum = random.random()\nTo improve the average-case performance of your code, you can sometimes exit out of loops as\nsoon as you find your answer; you'll find many loops that are used to find True/False answers\nfollow this pattern. For example, say you want to check whether any value in a list is great than\n5:\nmy_list = [1,2,3,4,5,6,7,8]\ngreater_than_five = False\nfor elem in my_list:\nif elem > 5:\n\ngreater_than_five = True\nbreak\n3. Checking boolean conditions with if/else\nOften, people have a tendency to be overly verbose. Observe the following example:\nif my_function() == True: # my_function returns True or False\nreturn True\nelse:\nreturn False\nWhen Python evaluates my_function(), the code is reduced to the following (let's pretend it\nreturned True):\nif True == True: # my_function returns True or False\nreturn True\nelse:\nreturn False\nThis seems repetitive, doesn't it? We know that True is equal to True, and False is not. So,\ninstead of keeping that == True around, we could just have the function call inside the if\nstatement:\n\nif my_function(): # my_function returns True or False\nreturn True\nelse:\nreturn False\nThere is an important point to note here. Since my_function() is going to be a boolean,\nand we're effectively returning the value of that boolean, there's no reason not to just return the\nboolean itself:\nreturn my_function() # my_function returns True or False\nThis is nice and concise, but what if we want to return True if my_function returns False,\nand False when it returns True? There's a Python keyword for that! So, imagine our code\nstarts as:\nif my_function() == True: # my_function returns True or False\nreturn False\nelse:\nreturn True\n\nWe can use not to write this as:\nreturn not my_function() # my_function returns True or False\n4. Docstrings\nWhen writing new classes and functions, it is important to document your intent by using\ndocstrings. For instance, in pset 5, since there were a lot of new classes to implement, adding a\ndocstring explaining the purpose of each class is a good idea.\nEven something as simple as:\nclass TitleTrigger(WordTrigger):\n\"\"\"\nSubclass of WordTrigger that represents a Trigger which checks\nif the story's title matches a given word.\n\"\"\"\netc.\nIncluding a docstring means the specification you've written can be accessed by those who try\nto create an instance of your class. For example, if you change your TitleTrigger class definition\nto the above, run the file, then type the following at the interpreter:\n>>> TitleTrigger(\nYou will see your docstring pop up. :)\n5. Changing collections while iterating over them\nWe've mentioned that it's poor practice to modify a collection while iterating over it. This is\nbecause the behavior resulting from modification during iteration is ambiguous. The for\nstatement maintains an internal index, which is incremented for each loop iteration. If you\nmodify the list you're looping over, the indices will get out of sync, and you may end up skipping\nover items or processing the same item multiple times.\nLet's look at a couple of examples:\nelems = ['a', 'b', 'c']\nfor e in elems:\nprint e\nelems.remove(e)\nThis prints:\na\nc\nMeanwhile, if we look at what elems now contains, we see the following:\n>>> elems\n['b']\n\nWhy does this happen? Let's look at this code rewritten using a while loop.\nelems = ['a', 'b', 'c']\ni = 0\nwhile i < len(elems):\ne = elems[i]\nprint e\nelems.remove(e)\ni += 1\nThis code has the same result. Now it's clear what's happening: when you remove the 'a' from\nelems, the remaining elements slide down the list. The list is now ['b', 'c']. Now 'b' is at index 0,\nand 'c' is at index 1. Since the next iteration is going to look at index 1 (which is the 'c' element),\nthe 'b' gets skipped entirely! This is not what the programmer intended at all!\nLet's take a look at another example. Instead of removing from the list, we are now adding\nelements to it. What happens in the following piece of code?\nfor e in elems:\nprint e\nelems.append(e)\nWe might expect the list elems to be ['a', 'b', 'c', 'a', 'b', 'c'] at the end of\nexecution. However, instead, we get an infinite loop as we keep adding new items to the elems\nlist while iterating. Oops!\nTo work around this kind of issue, you can loop over a copy of the list. For instance, in the\nfollowing code snippets, we wish to retain all the elements of the list the meet some condition.\nelems_copy = elems[:]\nfor item in elems_copy:\nif not condition:\nelems.remove(item)\nelems will contain the desired items.\nAlternatively, you can create a new list, and append to it:\nelems_copy = []\nfor item in elems:\nif condition:\nelems_copy.append(object)\nelems_copy will now contain the desired items.\nNote that the same rule applies to the set and dict types; however, mutating a set or dictionary\nwhile iterating over it will actually raise a RuntimeError -- in this way, Python explicitly prevents\nthis.\n6. Directly Accessing Instance Variables\n\nThis can be a problem because it breaks the interface your class provides to the Abstract\nData Type. Here is an example of this, as a line of code you might write for something like\nTitleTrigger.evaluate in pset 5:\ntitle = story.title # evil\nThis is bad because it means that the instance variable for the title in NewsStory had to\nbe stored as self.title for this to work. However, the programmer writing NewsStory\n(yes, that's you, too) might not have stored it as self.title, because maybe he/she/\nyou preferred self.t, or self.my_story_title, or maybe the 1st element of the\nlist self.story_attributes, or anything else. In fact, the only promise made about\nNewsStory is that there is a constructor that takes in some elements of a story (guid, title, etc.),\nand there is a getter method for each of these properties.\nSo, the safer way to do this? Use getter methods!\ntitle = story.get_title() # much better!\n7. Calling a superclass constructor from a subclass\nFor a subclass that extends the functionality of a superclass (e.g. ResistantVirus and\nSimpleVirus in pset 7), always reuse the functionality of the superclass instead of rewriting it.\nThis goes back to the concept that we should avoid repeated code.\nSay we have the following constructor for the SimpleVirus class:\nclass SimpleVirus(object):\ndef __init__(self, maxBirthProb, clearProb):\nself.maxBirthProb = maxBirthProb\nself.clearProb = clearProb\n...\nWhen we define the ResistantVirus class, we could just repeat the two lines of code contained\nin the constructor as in the below code snippet:\n# Method 1\nclass ResistantVirus(SimpleVirus):\ndef __init__(self, maxBirthProb, clearProb, resistances, mutProb):\nself.maxBirthProb = maxBirthProb\nself.clearProb = clearProb\nself.resistances = resistances\nself.mutProb = mutProb\n...\n\nAlternatively, we could make use of inheritance and call the superclass constructor on the first\ntwo parameters since this would have the same effect.\n# Method 2\nclass ResistantVirus(SimpleVirus):\ndef __init__(self, maxBirthProb, clearProb, resistances, mutProb):\n# Always call the superclass constructor as the first line of\n# the subclass constructor.\nSimpleVirus.__init__(self, maxBirthProb, clearProb)\nself.resistances = resistances\nself.mutProb = mutProb\n...\nMethod 2 is superior to Method 1 in that we prevent ourselves from repeating the code\nthat initializes the variables self.maxBirthProb and self.clearProb. Why is this so\nimportant?\nSay for some reason, while implementing Method 1, we decided to call the maximum\nbirth probability in the ResistantVirus class self.maximumBirthProb instead of\nself.maxBirthProb. In Python, the superclass constructor is not automatically\ncalled when constructing a subclass instance. Now, in all of the superclass methods\nthat reference self.maxBirthProb, we will get an error because it only exists as\nself.maximumBirthProb.\nAnother reason to use Method 2 is that the superclass constructor may do some other, more\ncomplicated initialization and we want to ensure that it is executed.\n8. Pitfalls of storing custom objects in data structures\nSome people tried to store Position objects in their data structure of clean tiles, writing code\nsuch as the following:\ndef isTileCleaned(self, m, n):\nnewPosition = Position(m, n)\nreturn newPosition in self.cleanTileList\nThis code will always return False, even if the tile at (m, n) is clean. The reason why this is\nproblematic gets into the internals of how objects are compared for equality in Python.\nHow does Python compare objects for equality? Well, for primitives like integers, it's pretty\nsimple -- just see if the two numbers have the same value. Similarly, for strings, check if the\ncharacters at each position in the string are the same.\nWhenever we create a new class from scratch in Python, what is the default way to check for\nequality?\n\nThe answer is that for objects, the default way Python checks if they are equal is to check\nthe location where that object is stored in memory. Because this code creates a new Position\nobject, newPosition, it makes sense that this particular instance being created is not stored\nin the same location as any other Position object in the list of clean tiles! Therefore, of course it\nwon't be found when Python checks to see if it's in the list.\nThere are a couple of ways to avoid this issue. Our recommended way for the purposes of this\ncourse involves changing what is being stored in the data structure. Representing a set of x, y\ncoordinates as a tuple would make testing for equality much simpler.\nThere are other, better ways to solve this problem that are more complicated. If you'd like to get\nmore information, please come to office hours and ask a TA or LA. :)\n9. Which data structure should I use?\nIn problem set 6, we asked you to store the state of cleanliness for w * h tiles in a rectangular\nroom. We saw different solutions to this, and we want to discuss the pros and cons of different\napproaches.\nList\nMost people chose to store a list of tuples (x, y) for every clean tile. While this works, there are a\nfew things that make this implementation difficult to work with.\nThe first is that whenever a tile is \"cleaned\", we must iterate through the entire list (an\nO(len(cleanTileList) operation) to see if the tile is not yet considered \"clean\" before adding the\ntile's coordinates to the clean tile list. The necessity of this check can lead to bugs and reduces\nefficiency.\nAnother issue with this representation is that by including only those tiles that are clean in the\nlist, we are storing a boolean value for each tile implicitly (i.e., if tile is present, it is clean). Here,\nsince what we are doing is storing both the tile's coordinates and something about the tile,\nexpressing it explicitly would be clearer (see dictionary-based solution). For instance, what if we\nchanged the possible states of the room to be one of \"clean\", \"dirty\", and \"just a little messy\"?\nThis representation would not be flexible enough to accommodate that.\nSet\nAnother solution involved storing coordinates as a set of tuples in the set if the tile was clean,\ne.g.,\nset((x, y),...)\nThis solution is superior to the solution using lists, since adding a tuple to the set that already\nexists will not ever yield a duplicate, so this is less likely to run into bugs. Additionally, set\noperations like lookup and removal are O(1), so it is very efficient. However, it has the same\nproblem as the list representation in that we are implicitly storing a boolean, and we should try\n\nto make that more explicit.\nList of lists\nSome people used a list of lists to implement a sort of matrix, with a boolean representing\nwhether or not the room was clean. The list of lists would be indexed twice, corresponding to the\nx and y coordinates of the tile, to see if that tile is clean.\ne.g.,\n[[True, True, True, True, True, True, True, True],\n[True, True, True, True, True, True, True, True],\n...\n[True, True, True, True, True, True, True, True]]\nThis solution avoids the problem of implicit boolean storage, but it is less efficient in that\nupdating an entry requires indexing two lists. It can also be confusing -- knowing which\ndimension to index first can be tricky.\nDictionary\nA more natural way to represent this problem is using a dictionary, where the key is a tuple (x,\ny) of the tile's position, and the value is a boolean that is True if the tile is clean.\nThis is more flexible in that if we were asked to accommodate the states \"clean\", \"dirty\", and\n\"just a little messy\", we could switch the value stored in the dictionary to be, say, an integer in\nthe set {0, 1, 2}, or even the strings themselves.\nUpdating the cleanliness status of a tile would be a constant time operation (O(1)), and for every\ntile, we are storing its coordinates and cleanliness status in the same dictionary entry, which is\nclearer than the other representations.\nTakeaway\nIn this course, we are trying to teach you to use the data structure most appropriate for the\nproblem at hand. For future problems, think about how best to store your data before just\npicking the data structure that you happen to be most familiar with. :)\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 1",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/8cf75481d7047180c386de3e485bd050_MIT6_0001F16_ps1.pdf",
      "content": "Problem Set 1\nHanded out: Monday, September 12, 2016.\nDue: 11:59 PM, Tuesday, September 20, 2016\n\nThis problem set will introduce you to using control flow in Python and formulating a computational\nsolution to a problem. It will also give you a chance to explore bisection search. This problem set has\nthree problems. You should save your code for the first problem as ps1a.py, the second problem as\nps1b.py and the third problem as ps1c.py, and make sure to hand in all three files. Don't forget to\ninclude comments to help us understand your code!\nCollaboration\nYou may work with other students; however, each student should write up and hand in his or her\nassignment separately. Be sure to indicate with whom you have worked in a comment at the start of\neach file.\nBefore You Start: Read the Style Guide\n\nRead the style guide sections 1, 2, and 3.\nPart A: House Hunting\n\nYou have graduated from MIT and now have a great job! You move to the San Francisco Bay Area and\ndecide that you want to start saving to buy a house. As housing prices are very high in the Bay Area,\nyou realize you are going to have to save for several years before you can afford to make the down\npayment on a house. In Part A, we are going to determine how long it will take you to save enough\nmoney to make the down payment given the following assumptions:\n\n1. Call the cost of your dream home total_cost.\n2. Call the portion of the cost needed for a down payment portion_down_payment. For\nsimplicity, assume that portion_down_payment = 0.25 (25%).\n3. Call the amount that you have saved thus far current_savings. You start with a current\nsavings of $0.\n4. Assume that you invest your current savings wisely, with an annual return of r (in other words,\nat the end of each month, you receive an additional current_savings*r/12 funds to put into\nyour savings - the 12 is because r is an annual rate). Assume that your investments earn a\nreturn of r = 0.04 (4%).\n5. Assume your annual salary is annual_salary.\n6. Assume you are going to dedicate a certain amount of your salary each month to saving for\nthe down payment. Call that portion_saved. This variable should be in decimal form (i.e. 0.1\nfor 10%).\n7. At the end of each month, your savings will be increased by the return on your investment,\nplus a percentage of your monthly salary (annual salary / 12).\n\nWrite a program to calculate how many months it will take you to save up enough money for a down\npayment. You will want your main variables to be floats, so you should cast user inputs to floats.\n\nYour program should ask the user to enter the following variables:\n1. The starting annual salary (annual_salary)\n2. The portion of salary to be saved (portion_saved)\n3. The cost of your dream home (total_cost)\n\nHints\n\nTo help you get started, here is a rough outline of the stages you should probably follow in writing your\ncode:\n●\nRetrieve user input. Look at input() if you need help with getting user input. For this problem set,\nyou can assume that users will enter valid input (e.g. they won't enter a string when you expect\nan int)\n●\nInitialize some state variables. You should decide what information you need. Be careful about\nvalues that represent annual amounts and those that represent monthly amounts.\nTry different inputs and see how long it takes to save for a down payment. Please make your\nprogram print results in the format shown in the test cases below.\n\nTest Case 1\n>>>\nEnter your annual salary: 120000\nEnter the percent of your salary to save, as a decimal: . 10\nEnter the cost of your dream home: 1000000\nNumber of months: 183\n>>>\n\nTest Case 2\n>>>\nEnter your annual salary: 80000\nEnter the percent of your salary to save, as a decimal: . 15\nEnter the cost of your dream home: 500000\nNumber of months: 105\n>>>\n\nPart B: Saving, with a raise\n\nBackground\n\nIn Part A, we unrealistically assumed that your salary didn't change. But you are an MIT graduate, and\nclearly you are going to be worth more to your company over time! So we are going to build on your\nsolution to Part A by factoring in a raise every six months.\n\nIn ps1b.py, copy your solution to Part A (as we are going to reuse much of that machinery). Modify\nyour program to include the following\n1.\nHave the user input a semi-annual salary raise semi_annual_raise (as a decimal percentage)\n2.\nAfter the 6th month, increase your salary by that percentage. Do the same after the 12\nth\nth\nmonth, the 18\nmonth, and so on.\n\nWrite a program to calculate how many months it will take you save up enough money for a down\npayment. LIke before, assume that your investments earn a return of r = 0.04 (or 4%) and the\nrequired down payment percentage is 0.25 (or 25%). Have the user enter the following variables:\n1. The starting annual salary (annual_salary)\n\n2. The percentage of salary to be saved (portion_saved)\n3. The cost of your dream home (total_cost)\n4. The semiannual salary raise (semi_annual_raise)\nHints\n\nTo help you get started, here is a rough outline of the stages you should probably follow in writing your\ncode:\n●\nRetrieve user input.\n●\nInitialize some state variables. You should decide what information you need. Be sure to be\ncareful about values that represent annual amounts and those that represent monthly amounts.\n●\nBe careful about when you increase your salary - this should only happen after the 6th, 12th\n, 18th\nmonth, and so on.\nTry different inputs and see how quickly or slowly you can save enough for a down payment. P lease\nmake your program print results in the format shown in the test cases below.\n\nTest Case 1\n>>>\nEnter your starting annual salary: 120000\nEnter the percent of your salary to save, as a decimal: . 05\nEnter the cost of your dream home: 500000\nEnter the semiannual raise, as a decimal: .03\nNumber of months: 142\n>>>\n\nTest Case 2\n>>>\nEnter your starting annual salary: 80000\nEnter the percent of your salary to save, as a decimal: . 1\nEnter the cost of your dream home: 800000\nEnter the semiannual raise, as a decimal: .03\nNumber of months: 159\n>>>\n\nTest Case 3\n>>>\nEnter your starting annual salary: 75000\nEnter the percent of your salary to save, as a decimal: . 05\nEnter the cost of your dream home: 1500000\nEnter the semiannual raise, as a decimal: .05\nNumber of months: 261\n>>>\n\nPart C: Finding the right amount to save away\n\nIn Part B, you had a chance to explore how both the percentage of your salary that you save each month\nand your annual raise affect how long it takes you to save for a down payment. This is nice, but\nsuppose you want to set a particular goal, e.g. to be able to afford the down payment in three years.\nHow much should you save each month to achieve this? In this problem, you are going to write a\nprogram to answer that question. To simplify things, assume:\n\n1. Your semiannual raise is .07 (7%)\n2. Your investments have an annual return of 0.04 (4%)\n3. The down payment is 0.25 (25%) of the cost of the house\n4. The cost of the house that you are saving for is $1M.\n\nYou are now going to try to find the best rate of savings to achieve a down payment on a $1M house in\n36 months. Since hitting this exactly is a challenge, we simply want your savings to be within $100 of\nthe required down payment.\n\nIn ps1c.py, write a program to calculate the best savings rate, as a function of your starting salary.\nYou should use bisection search to help you do this efficiently. You should keep track of the number of\nsteps it takes your bisections search to finish. You should be able to reuse some of the code you wrote\nfor part B in this problem.\n\nBecause we are searching for a value that is in principle a float, we are going to limit ourselves to two\ndecimals of accuracy (i.e., we may want to save at 7.04% or 0.0704 in decimal - but we are not\ngoing to worry about the difference between 7.041% and 7.039%). This means we can search for an\ninteger between 0 and 10000 (using integer division), and then convert it to a decimal percentage\n(using float division) to use when we are calculating the current_savings after 36 months. By using\nthis range, there are only a finite number of numbers that we are searching over, as opposed to the\ninfinite number of decimals between 0 and 1. This range will help prevent infinite loops. The reason we\nuse 0 to 10000 is to account for two additional decimal places in the range 0% to 100%. Your code\nshould print out a decimal (e.g. 0.0704 for 7.04%).\n\nTry different inputs for your starting salary, and see how the percentage you need to save changes to\nreach your desired down payment. Also keep in mind it may not be possible for to save a down\npayment in a year and a half for some salaries. In this case your function should notify the user that it\nis not possible to save for the down payment in 36 months with a print statement. P lease make your\nprogram print results in the format shown in the test cases below.\n\nNote: There are multiple right ways to implement bisection search/number of steps so your\nresults may not perfectly match those of the test case.\nHints\n\n●\nThere may be multiple savings rates that yield a savings amount that is within $100 of the\nrequired down payment on a $1M house. In this case, you can just return any of the possible\nvalues.\n●\nDepending on your stopping condition and how you compute a trial value for bisection search,\nyour number of steps may vary slightly from the example test cases.\n●\nWatch out for integer division when calculating if a percentage saved is appropriate and when\ncalculating final decimal percentage savings rate.\n●\nRemember to reset the appropriate variable(s) to their initial values for each iteration of bisection\nsearch.\nTest Case 1\n>>>\nEnter the starting salary: 150000\nBest savings rate: 0.4411\nSteps in bisection search: 12\n>>>\n\nTest Case 2\n>>>\nEnter the starting salary: 300000\nBest savings rate: 0.2206\nSteps in bisection search: 9\n>>>\n\nTest Case 3\n>>>\nEnter the starting salary: 10000\nIt is not possible to pay the down payment in three years.\n>>>\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Code",
      "title": "Lecture 1 Code",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/920cc911b6eb5747f2ccd431bbc4306b_lec1.py",
      "content": "pi = 3.14159\nradius = 2.2\n# area of circle equation <- this is a comment\narea = pi*(radius**2)\nprint(area)\n\n# change values of radius <- another comment\n# use comments to help others understand what you are doing in code\nradius = radius + 1\nprint(area) # area doesn't change\narea = pi*(radius**2)\nprint(area)\n\n#############################\n#### COMMENTING LINES #######\n#############################\n# to comment MANY lines at a time, highlight all of them then CTRL+1\n# do CTRL+1 again to uncomment them\n# try it on the next few lines below!\n\n#area = pi*(radius**2)\n#print(area)\n#radius = radius + 1\n#area = pi*(radius**2)\n#print(area)\n\n#############################\n#### AUTOCOMPLETE #######\n#############################\n# Spyder can autocomplete names for you\n# start typing a variable name defined in your program and hit tab\n# before you finish typing -- try it below\n\n# define a variable\na_very_long_variable_name_dont_name_them_this_long_pls = 0\n\n# below, start typing a_ve then hit tab... cool, right!\n# use autocomplete to change the value of that variable to 1\n\n# use autocomplete to write a line that prints the value of that long variable\n# notice that Spyder also automatically adds the closed parentheses for you!"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 1: Welcome",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/e921a690079369751bcce3e34da6c6ee_MIT6_0001F16_Lec1.pdf",
      "content": "WELCOME!\n(download slides and .py files and follow along!)\n6.0001 LECTURE 1\n6.0001 LECTURE 1\n\nTODAY\n*course info\n*what is computation\n*python basics\n*mathematical operations\n*python variables and types\n*NOTE: slides and code files up before each lecture\no highly encourage you to download them before lecture\no take notes and run code files when I do\no bring computers to answer in-class practice exercises!\n6.0001 LECTURE 1\n\nCOURSE INFO\n*Grading\n*approx. 20% Quiz\n*approx. 40% Final\n*approx. 30% Problem Sets\n*approx. 10% MITx Finger Exercises\n6.0001 LECTURE 1\n\nCOURSE POLICIES\n*Collaboration\n*may collaborate with anyone\n*required to write code independently and write names of\nall collaborators on submission\n*we will be running a code similarity program on all psets\n*Extensions\n*no extensions\n*late days, see course website for details\n*drop and roll weight of max two psets in final exam grade\n*should be EMERGENCY use only\n6.0001 LECTURE 1\n\nRECITATIONS\n*not mandatory\n*two flavors\n1) Lecture review: review lecture material\no if you missed lecture\no if you need a different take on the same concepts\n2) Problem solving: teach you how to solve programming\nproblems\no useful if you don't know how to set up pseudocode from pset words\no we show a couple of harder questions\no walk you through how to approach solving the problem\no brainstorm code solution along with the recitation instructor\no will post solutions after\n6.0001 LECTURE 1\n\nFAST PACED COURSE\n*Position yourself to succeed!\n*read psets when they come out and come back to them later\n*use late days in emergency situations\n*New to programming? PRACTICE. PRACTICE? PRACTICE!\n*can't passively absorb programming as a skill\n*download code before lecture and follow along\n*do MITx finger exercises\n*don't be afraid to try out Python commands!\n6.0001 LECTURE 1\n\nPRACTICE\n6.0001 LECTURE 1\nPROBLEM\nSOLVING\nPROGRAMMING\nSKILL\nKNOWLEDGE\nOF CONCEPTS\n\nTOPICS\n*represent knowledge with data structures\n*iteration and recursion as computational metaphors\n*abstraction of procedures and data types\n*organize and modularize systems using object classes\nand methods\n*different classes of algorithms, searching and sorting\n*complexity of algorithms\n6.0001 LECTURE 1\n\nWHAT DOES A COMPUTER DO\n*Fundamentally:\n*performs calculations\na billion calculations per second!\n*remembers results\n100s of gigabytes of storage!\n*What kinds of calculations?\n*built-in to the language\n*ones that you define as the programmer\n*computers only know what you tell them\n6.0001 LECTURE 1\n\nTYPES OF KNOWLEDGE\n*declarative knowledge is statements of fact.\n*someone will win a Google\nCardboard before class ends\n*imperative knowledge is a recipe or \"how-to\".\n1) Students sign up for raffle\n2) Ana opens her IDE\n3) Ana chooses a random number between 1st and nth responder\n4) Ana finds the number in the responders sheet. Winner!\n6.0001 LECTURE 1\n\nA NUMERICAL EXAMPLE\n*square root of a number x is y such that y*y = x\n*recipe for deducing square root of a number x (16)\n1) Start with a guess, g\n2) If g*g is close enough to x, stop and say g is the\nanswer\n3) Otherwise make a new guess by averaging g and x/g\n4) Using the new guess, repeat process until close enough\n6.0001 LECTURE 1\ng\ng*g\nx/g\n(g+x/g)/2\n16/3\n4.17\n4.17\n17.36\n3.837\n4.0035\n4.0035\n16.0277\n3.997\n4.000002\n\nWHAT IS A RECIPE\n1)\nsequence of simple steps\n2)\nflow of control process that specifies when each\nstep is executed\n3)\na means of determining when to stop\n1+2+3 = an algorithm!\n6.0001 LECTURE 1\n\nCOMPUTERS ARE MACHINES\n*how to capture a recipe in a mechanical process\n*fixed program computer\n*calculator\n*stored program computer\n*machine stores and executes instructions\n6.0001 LECTURE 1\n\nBASIC MACHINE ARCHITECTURE\n6.0001 LECTURE 1\nMEMORY\nCONTROL\nUNIT\nARITHMETIC\nLOGIC UNIT\nINPUT\nOUTPUT\nprogram counter\ndo primitive ops\n\nSTORED PROGRAM COMPUTER\n*sequence of instructions stored inside computer\n*built from predefined set of primitive instructions\n1)\narithmetic and logic\n2)\nsimple tests\n3)\nmoving data\n*special program (interpreter) executes each\ninstruction in order\n*use tests to change flow of control through sequence\n*stop when done\n6.0001 LECTURE 1\n\nBASIC PRIMITIVES\n*Turing showed that you can compute anything using 6\nprimitives\n*modern programming languages have more\nconvenient set of primitives\n*can abstract methods to create new primitives\n*anything computable in one language is computable in\nany other programming language\n6.0001 LECTURE 1\n\nCREATING RECIPES\n*a programming language provides a set of primitive\noperations\n*expressions are complex but legal combinations of\nprimitives in a programming language\n*expressions and computations have values and\nmeanings in a programming language\n6.0001 LECTURE 1\n\nASPECTS OF LANGUAGES\n*primitive constructs\n*English: words\n*programming language: numbers, strings, simple\noperators\n6.0001 LECTURE 1\n18A word cloud of common english language words.A word cloud of common words in Python.\nWord Cloud copyright Michael Twardos, All Right Reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\nWord Cloud copyright unknown, All Right Reserved.\nThis content is excluded from our Creative\nCommons license. For more information, see\nhttps://ocw.mit.edu/help/faq-fair-use/.\n\nASPECTS OF LANGUAGES\n*syntax\n*English: \"cat dog boy\" not syntactically valid\n\"cat hugs boy\" syntactically valid\n*programming language: \"hi\"5 not syntactically valid\n3.2*5 syntactically valid\n6.0001 LECTURE 1\n\nASPECTS OF LANGUAGES\n*static semantics is which syntactically valid strings\nhave meaning\n*English: \"I are hungry\" syntactically valid\nbut static semantic error\n*programming language: 3.2*5\nsyntactically valid\n3+\"hi\" static semantic error\n6.0001 LECTURE 1\n\nASPECTS OF LANGUAGES\n*semantics is the meaning associated with a\nsyntactically correct string of symbols with no static\nsemantic errors\n*English: can have many meanings \"Flying planes\ncan be dangerous\"\n*programming languages: have only one meaning but may\nnot be what programmer intended\n6.0001 LECTURE 1\n\nWHERE THINGS GO WRONG\n*syntactic errors\n*common and easily caught\n*static semantic errors\n*some languages check for these before running program\n*can cause unpredictable behavior\n*no semantic errors but different meaning than what\nprogrammer intended\n*program crashes, stops running\n*program runs forever\n*program gives an answer but different than expected\n6.0001 LECTURE 1\n\nPYTHON PROGRAMS\n*a program is a sequence of definitions and commands\n*definitions evaluated\n*commands executed by Python interpreter in a shell\n*commands (statements) instruct interpreter to do\nsomething\n*can be typed directly in a shell or stored in a file that\nis read into the shell and evaluated\n*Problem Set 0 will introduce you to these in Anaconda\n6.0001 LECTURE 1\n\nOBJECTS\n*programs manipulate data objects\n*objects have a type that defines the kinds of things\nprograms can do to them\n*Ana is a human so she can walk, speak English, etc.\n*Chewbacca is a wookie so he can walk, \"mwaaarhrhh\", etc.\n*objects are\n*scalar (cannot be subdivided)\n*non-scalar (have internal structure that can be accessed)\n6.0001 LECTURE 1\n\nSCALAR OBJECTS\n*int - represent integers, ex. 5\n*float - represent real numbers, ex. 3.27\n*bool - represent Boolean values True and False\n*NoneType - special and has one value, None\n*can use type() to see the type of an object\n>>> type(5)\nint\n>>> type(3.0)\nfloat\n6.0001 LECTURE 1\n25what you write into the Python shellwhat shows after hitting enter\n\nTYPE CONVERSIONS (CAST)\n*can convert object of one type to another\n*float(3) converts integer 3 to float 3.0\n*int(3.9) truncates float 3.9 to integer 3\n6.0001 LECTURE 1\n\nPRINTING TO CONSOLE\n*to show output from code to a user, use print\ncommand\nIn [11]: 3+2\nOut[11]: 5\nIn [12]: print(3+2)\n6.0001 LECTURE 1\n27\"Out\" tells you it's an interaction within the shell onlyNo \"Out\" means it is actually shown to a user, apparent when you edit/run files\n\nEXPRESSIONS\n*combine objects and operators to form expressions\n*an expression has a value, which has a type\n*syntax for a simple expression\n<object> <operator> <object>\n6.0001 LECTURE 1\n\nOPERATORS ON ints and floats\n*i+j\nthe sum\n*i-j\nthe difference\n*i*j\nthe product\n*i/j\ndivision\n*i%j\nthe remainder when i is divided by j\n*i**j i to the power of j\n6.0001 LECTURE 1\nif both are ints, result is int\nif either or both are floats, result is float\nresult is float\n\nSIMPLE OPERATIONS\n*parentheses used to tell Python to do these\noperations first\n*operator precedence without parentheses\n***\n**\n*/\n*+ and - executed left to right, as appear in expression\n6.0001 LECTURE 1\n\nBINDING VARIABLES AND\nVALUES\n*equal sign is an assignment of a value to a variable\nname\npi = 3.14159\npi_approx = 22/7\n*value stored in computer memory\n*an assignment binds name to value\n*retrieve value associated with name or variable by\ninvoking the name, by typing pi\n6.0001 LECTURE 1\n31value variable\n\nABSTRACTING EXPRESSIONS\n*why give names to values of expressions?\n*to reuse names instead of values\n*easier to change code later\npi = 3.14159\nradius = 2.2\narea = pi*(radius**2)\n6.0001 LECTURE 1\n\nPROGRAMMING vs MATH\n*in programming, you do not \"solve for x\"\npi = 3.14159\nradius = 2.2\n# area of circle\narea = pi*(radius**2)\nradius = radius+1\n6.0001 LECTURE 1\n33an assignment* expression on the right, evaluated to a value* variable name on the left*equivalent expression to radius = radius + 1 is radius += 1\n\nCHANGING BINDINGS\n*can re-bind variable names using new assignment\nstatements\n*previous value may still stored in memory but lost the\nhandle for it\n*value for area does not change until you tell the\ncomputer to do the calculation again\n6.0001 LECTURE 1\npi\nradius\narea\n3.14\n2.2\n15.1976\n3.2\npi = 3.14\nradius = 2.2\narea = pi*(radius**2)\nradius = radius+1\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Code",
      "title": "Lecture 2 Code",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/d6ee838ee4c85ace93a4e170cfd83c03_lec2_branch_loops.py",
      "content": "###################\n## EXAMPLE: strings\n###################\n#hi = \"hello there\"\n#name = \"ana\"\n#greet = hi + name\n#print(greet)\n#greeting = hi + \" \" + name\n#print(greeting)\n#silly = hi + (\" \" + name)*3\n#print(silly)\n\n####################\n## EXAMPLE: output\n####################\n#x = 1\n#print(x)\n#x_str = str(x)\n#print(\"my fav number is\", x, \".\", \"x=\", x)\n#print(\"my fav number is\", x_str + \".\" + \"x=\" + x_str)\n#print(\"my fav number is\" + x_str + \".\" + \"x=\" + x_str)\n\n####################\n## EXAMPLE: input\n####################\n#text = input(\"Type anything... \")\n#print(5*text)\n#num = int(input(\"Type a number... \"))\n#print(5*num)\n\n####################\n## EXAMPLE: conditionals/branching\n####################\n#x = float(input(\"Enter a number for x: \"))\n#y = float(input(\"Enter a number for y: \"))\n#if x == y:\n# print(\"x and y are equal\")\n# if y != 0:\n# print(\"therefore, x / y is\", x/y)\n#elif x < y:\n# print(\"x is smaller\")\n#elif x > y:\n# print(\"y is smaller\")\n#print(\"thanks!\")\n\n####################\n## EXAMPLE: remainder\n####################\n#num = int(input(\"Enter a number: \"))\n#if num % 2 == 0:\n# print(\"number is even\")\n#else:\n# print(\"number is odd\")\n\n####################\n## EXAMPLE: while loops\n## Try expanding this code to show a sad face if you go right\n## twice and flip the table any more times than that.\n## Hint: use a counter\n####################\n#n = input(\"You are in the Lost Forest\\n****************\\n****************\\n :)\\n****************\\n****************\\nGo left or right? \")\n#while n == \"right\" or n == \"Right\":\n# n = input(\"You are in the Lost Forest\\n****************\\n****** ***\\n (╯°□°)╯( ┻━┻\\n****************\\n****************\\nGo left or right? \")\n#print(\"\\nYou got out of the Lost Forest!\\n\\o/\")\n\n#n = 0\n#while n < 5:\n# print(n)\n# n = n+1\n\n####################\n## EXAMPLE: for loops\n####################\n#for n in range(5):\n# print(n)\n#\n#mysum = 0\n#for i in range(10):\n# mysum += i\n#print(mysum)\n#\n#mysum = 0\n#for i in range(7, 10):\n# mysum += i\n#print(mysum)\n#\n#mysum = 0\n#for i in range(5, 11, 2):\n# mysum += i\n# if mysum == 5:\n# break\n# mysum += 1\n#print(mysum)\n\n####################\n## EXAMPLE: perfect squares\n####################\n#ans = 0\n#neg_flag = False\n#x = int(input(\"Enter an integer: \"))\n#if x < 0:\n# neg_flag = True\n#while ans**2 < x:\n# ans = ans + 1\n#if ans**2 == x:\n# print(\"Square root of\", x, \"is\", ans)\n#else:\n# print(x, \"is not a perfect square\")\n# if neg_flag:\n# print(\"Just checking... did you mean\", -x, \"?\")\n\n####################\n## TEST YOURSELF!\n## Modify the perfect squares example to print\n## imaginary perfect sqrts if given a negative num.\n####################"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 2: Branching, Iteration",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/ba2947b25b1580e4a84df0ec5dbe5cdd_MIT6_0001F16_Lec2.pdf",
      "content": "BRANCHING,\nITERATION\n(download slides and .py files AYE follow along!)\n6.0001 LECTURE 2\n6.0001 LECTURE 2\n\nLAST TIME\n*syntax and semantics\n*scalar objects\n*simple operations\n*expressions, variables and values\n6.0001 LECTURE 2\n\nTODAY\n*string object type\n*branching and conditionals\n*indentation\n*iteration and loops\n6.0001 LECTURE 2\n\nSTRINGS\n*letters, special characters, spaces, digits\n*enclose in quotation marks or single quotes\nhi = \"hello there\"\n*concatenate strings\nname = \"ana\"\ngreet = hi + name\ngreeting = hi + \" \" + name\n*do some operations on a string as defined in Python docs\nsilly = hi + \" \" + name * 3\n6.0001 LECTURE 2\n\nINPUT/OUTPUT: print\n*used to output stuff to console\n*keyword is print\nx = 1\nprint(x)\nx_str = str(x)\nprint(\"my fav num is\", x, \".\", \"x =\", x)\nprint(\"my fav num is \" + x_str + \". \" + \"x = \" + x_str)\n6.0001 LECTURE 2\n\nINPUT/OUTPUT: input(\"\")\n*prints whatever is in the quotes\n*user types in something and hits enter\n*binds that value to a variable\ntext = input(\"Type anything... \")\nprint(5*text)\n*input gives you a string so must cast if working\nwith numbers\nnum = int(input(\"Type a number... \"))\nprint(5*num)\n6.0001 LECTURE 2\n\nCOMPARISON OPERATORS ON\nint, float, string\n*i and j are variable names\n*comparisons below evaluate to a Boolean\ni > j\ni >= j\ni < j\ni <= j\ni == j equality test, True if i is the same as j\ni != j inequality test, True if i not the same as j\n6.0001 LECTURE 2\n\nLOGIC OPERATORS ON bools\n*a and b are variable names (with Boolean values)\nnot a\nTrue if a is False\nFalse if a is True\na and b True if both are True\na or b\nTrue if either or both are True\n6.0001 LECTURE 2\nA\nB\nA and B\nA or B\nTrue\nTrue\nTrue\nTrue\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nFalse\nFalse\nFalse\n\nCOMPARISON EXAMPLE\npset_time = 15\nsleep_time = 8\nprint(sleep_time > pset_time)\nderive = True\ndrink = False\nboth = drink and derive\nprint(both)\n6.0001 LECTURE 2\n\nIf right clear,\ngo right\nIf right blocked,\ngo forward\nIf right and\nfront blocked,\ngo left\nIf right , front,\nleft blocked,\ngo back\n6.0001 LECTURE 2\n\nCONTROL FLOW - BRANCHING\nif <condition>:\n<expression>\n<expression>\n...\nif <condition>:\n<expression>\n<expression>\n...\nelse:\n<expression>\n<expression>\n...\nif <condition>:\n<expression>\n<expression>\n...\nelif <condition>:\n<expression>\n<expression>\n...\nelse:\n<expression>\n<expression>\n...\n*<condition> has a value True or False\n*evaluate expressions in that block if <condition> is True\n6.0001 LECTURE 2\n\nINDENTATION\n*matters in Python\n*how you denote blocks of code\nx = float(input(\"Enter a number for x: \"))\ny = float(input(\"Enter a number for y: \"))\nif x == y:\nprint(\"x and y are equal\")\nif y != 0:\nprint(\"therefore, x / y is\", x/y)\nelif x < y:\nprint(\"x is smaller\")\nelse:\nprint(\"y is smaller\")\nprint(\"thanks!\")\nprint(\"x and y are equal\")\nif y != 0:\nprint(\"therefore, x / y is\", x/y)\nprint(\"x is smaller\")\nprint(\"y is smaller\")\n6.0001 LECTURE 2\n\n= vs ==\nx = float(input(\"Enter a number for x: \"))\ny = float(input(\"Enter a number for y: \"))\nif x == y:\nprint(\"x and y are equal\")\nif y != 0:\nprint(\"therefore, x / y is\", x/y)\nelif x < y:\nprint(\"x is smaller\")\nelse:\nprint(\"y is smaller\")\nprint(\"thanks!\")What if x = y here?get a SyntaxError\n6.0001 LECTURE 2\n\n*Legend of Zelda -\nLost Woods\n*keep going right,\ntakes you back to this\nsame screen, stuck in\na loop\nif <exit right>:\n<set background to woods_background>\nif <exit right>:\n<set background to woods_background>\nif <exit right>:\n<set background to woods_background>\nand so on and on and on...\nelse:\n<set background to exit_background>\nelse:\n<set background to exit_background>\nelse:\n<set background to exit_background>A screenshot from a video game of a figure in green moving through a forest of trees.\n<set background to woods_background>\nif <exit right>:\nelse:\n<set background to exit_background>\n<set background to woods_background>\nif <exit right>:\nelse:\n<set background to exit_background>\n<set background to woods_background>\nand so on and on and on...\n<set background to exit_background>\n6.0001 LECTURE 2\nImage Courtesy Nintendo, All Rights Reserved. This content is excluded from our Creative\nCommons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.\n\nwhile <exit right>:\n<set background to woods_background>\n<set background to exit_background>A screenshot from a video game of a figure in green moving through a forest of trees.\n*Legend of Zelda -\nLost Woods\n*keep going right,\ntakes you back to this\nsame screen, stuck in\na loop\n6.0001 LECTURE 2\n<set background to woods_background>\nWord Cloud copyright unknown, All Right Reserved. This content is excluded from our Creative\nCommons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.\n\nCONTROL FLOW:\nwhile LOOPS\nwhile <condition>:\n<expression>\n<expression>\n...\n*<condition> evaluates to a Boolean\n*if <condition> is True, do all the steps inside the\nwhile code block\n*check <condition> again\n*repeat until <condition> is False\n6.0001 LECTURE 2\n\nwhile LOOP EXAMPLE\nYou are in the Lost Forest.\n************\n************\n\n************\n************\nGo left or right?\nPROGRAM:\nn = input(\"You're in the Lost Forest. Go left or right? \")\nwhile n == \"right\":\nn = input(\"You're in the Lost Forest. Go left or right? \")\nprint(\"You got out of the Lost Forest!\")\n6.0001 LECTURE 2\n\nCONTROL FLOW:\nwhile and for LOOPS\n*iterate through numbers in a sequence\n# more complicated with while loop\nn = 0\nwhile n < 5:\nprint(n)\nn = n+1\n# shortcut with for loop\nfor n in range(5):\nprint(n)\n6.0001 LECTURE 2\n\nCONTROL FLOW: for LOOPS\nfor <variable> in range(<some_num>):\n<expression>\n<expression>\n...\n*each time through the loop, <variable> takes a value\n*first time, <variable> starts at the smallest value\n*next time, <variable> gets the prev value + 1\n*etc.\n6.0001 LECTURE 2\n\nrange(start,stop,step)\n*default values are start = 0 and step = 1 and optional\n*loop until value is stop - 1\nmysum = 0\nfor i in range(7, 10):\nmysum += i\nprint(mysum)\nmysum = 0\nfor i in range(5, 11, 2):\nmysum += i\nprint(mysum)\n6.0001 LECTURE 2\n\nbreak STATEMENT\n*immediately exits whatever loop it is in\n*skips remaining expressions in code block\n*exits only innermost loop!\nwhile <condition_1>:\nwhile <condition_2>:\n<expression_a>\nbreak\n<expression_b>\n<expression_c>\n6.0001 LECTURE 2\n\nbreak STATEMENT\nmysum = 0\nfor i in range(5, 11, 2):\nmysum += i\nif mysum == 5:\nbreak\nmysum += 1\nprint(mysum)\n*what happens in this program?\nmysum += i\nif mysum == 5:\nbreak\n6.0001 LECTURE 2\n\nfor\nVS while LOOPS\nfor loops\n*know number of\niterations\n*can end early via\nbreak\n*uses a counter\n*can rewrite a for loop\nusing a while loop\nwhile loops\n*unbounded number of\niterations\n*can end early via break\n*can use a counter but\nmust initialize before loop\nand increment it inside loop\n*may not be able to\nrewrite a while loop using\na for loop\n6.0001 LECTURE 2\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Code",
      "title": "Lecture 3 Code",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/88de925a1fb925e46a08bc5f34d029bd_lec3_strings_algos.py",
      "content": "####################\n## EXAMPLE: for loops over strings\n####################\n#s = \"demo loops\"\n#for index in range(len(s)):\n# if s[index] == 'i' or s[index] == 'u':\n# print(\"There is an i or u\")\n#\n#for char in s:\n# if char == 'i' or char == 'u':\n# print(\"There is an i or u\")\n\n####################\n## EXAMPLE: while loops and strings\n## CHALLENGE: rewrite while loop with a for loop\n####################\n#an_letters = \"aefhilmnorsxAEFHILMNORSX\"\n#word = input(\"I will cheer for you! Enter a word: \")\n#times = int(input(\"Enthusiasm level (1-10): \"))\n#\n#i = 0\n#while i < len(word):\n# char = word[i]\n# if char in an_letters:\n# print(\"Give me an \" + char + \"! \" + char)\n# else:\n# print(\"Give me a \" + char + \"! \" + char)\n# i += 1\n#print(\"What does that spell?\")\n#for i in range(times):\n# print(word, \"!!!\")\n\n####################\n## EXAMPLE: perfect cube\n####################\n#cube = 27\n##cube = 8120601\n#for guess in range(cube+1):\n# if guess**3 == cube:\n# print(\"Cube root of\", cube, \"is\", guess)\n# # loops keeps going even after found the cube root\n\n####################\n## EXAMPLE: guess and check cube root\n####################\n#cube = 27\n##cube = 8120601\n#for guess in range(abs(cube)+1):\n# # passed all potential cube roots\n# if guess**3 >= abs(cube):\n# # no need to keep searching\n# break\n#if guess**3 != abs(cube):\n# print(cube, 'is not a perfect cube')\n#else:\n# if cube < 0:\n# guess = -guess\n# print('Cube root of ' + str(cube) + ' is ' + str(guess))\n\n####################\n## EXAMPLE: approximate cube root\n####################\n#cube = 27\n##cube = 8120601\n##cube = 10000\n#epsilon = 0.1\n#guess = 0.0\n#increment = 0.01\n#num_guesses = 0\n## look for close enough answer and make sure\n## didn't accidentally skip the close enough bound\n#while abs(guess**3 - cube) >= epsilon and guess <= cube:\n# guess += increment\n# num_guesses += 1\n#print('num_guesses =', num_guesses)\n#if abs(guess**3 - cube) >= epsilon:\n# print('Failed on cube root of', cube, \"with these parameters.\")\n#else:\n# print(guess, 'is close to the cube root of', cube)\n\n####################\n## EXAMPLE: bisection cube root (only positive cubes!)\n####################\n#cube = 27\n##cube = 8120601\n## won't work with x < 1 because initial upper bound is less than ans\n##cube = 0.25\n#epsilon = 0.01\n#num_guesses = 0\n#low = 0\n#high = cube\n#guess = (high + low)/2.0\n#while abs(guess**3 - cube) >= epsilon:\n# if guess**3 < cube:\n# # look only in upper half search space\n# low = guess\n# else:\n# # look only in lower half search space\n# high = guess\n# # next guess is halfway in search space\n# guess = (high + low)/2.0\n# num_guesses += 1\n#print('num_guesses =', num_guesses)\n#print(guess, 'is close to the cube root of', cube)"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 3: String Manipulation, Guess-and-Check, Approximations, Bisection",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/b9b9a82a29e8746db1facfbd30c07940_MIT6_0001F16_Lec3.pdf",
      "content": "STRING MANIPULATION,\nGUESS-and-CHECK,\nAPPROXIMATIONS,\nBISECTION\n(download slides and .py files AYE follow along!)\n6.0001 LECTURE 3\n6.0001 LECTURE 3\n\nLAST TIME\n*strings\n*branching - if/elif/else\n*while loops\n*for loops\n6.0001 LECTURE 3\n\nTODAY\n*string manipulation\n*guess and check algorithms\n*approximate solutions\n*bisection method\n6.0001 LECTURE 3\n\nSTRINGS\n*think of as a sequence of case sensitive characters\n*can compare strings with ==, >, < etc.\n*len() is a function used to retrieve the length of the\nstring in the parentheses\ns = \"abc\"\nlen(s) evaluates to 3\n6.0001 LECTURE 3\n\nSTRINGS\n*square brackets used to perform indexing into a string\nto get the value at a certain index/position\ns = \"abc\"\ns[0]\nevaluates to \"a\"\ns[1]\nevaluates to \"b\"\ns[2]\nevaluates to \"c\"\ns[3]\ntrying to index out of bounds, error\ns[-1] evaluates to \"c\"\ns[-2] evaluates to \"b\"\ns[-3] evaluates to \"a\"\n6.0001 LECTURE 3\nindex:\n0 1 2 indexing always starts at 0\nindex:\n-3 -2 -1 last element always at index -1\n\nSTRINGS\n*can slice strings using [start:stop:step]\n*if give two numbers, [start:stop], step=1 by default\n*you can also omit numbers and leave just colons\n6.0001 LECTURE 3\n6If unsure what some command does, try it out in your console!\ns = \"abcdefgh\"\ns[3:6]\nevaluates to \"def\", same as s[3:6:1]\ns[3:6:2] evaluates to \"df\"\ns[::]\nevaluates to \"abcdefgh\", same as s[0:len(s):1]\ns[::-1]\nevaluates to \"hgfedbca\", same as s[-1:-(len(s)+1):-1]\ns[4:1:-2]evaluates to \"ec\"\n\nSTRINGS\n*strings are \"immutable\" - cannot be modified\ns = \"hello\"\ns[0] = 'y'\ngives an error\ns = 'y'+s[1:len(s)]\nis allowed,\ns bound to new object\n6.0001 LECTURE 3\ns\n\"hello\"\n\"yello\"\n\nfor LOOPS RECAP\n*for loops have a loop variable that iterates over a set of\nvalues\nfor var in range(4): var iterates over values 0,1,2,3\n<expressions>\nexpressions inside loop executed\nwith each value for var\nfor var in range(4,6): var iterates over values 4,5\n<expressions>\n*range is a way to iterate over numbers, but a for loop\nvariable can iterate over any set of values, not just numbers!\n6.0001 LECTURE 3\n\nSTRINGS AND LOOPS\n*these two code snippets do the same thing\n*bottom one is more \"pythonic\"\ns = \"abcdefgh\"\nfor index in range(len(s)):\nif s[index] == 'i' or s[index] == 'u':\nprint(\"There is an i or u\")\nfor char in s:\nif char == 'i' or char == 'u':\nprint(\"There is an i or u\")\n6.0001 LECTURE 3\n\nCODE EXAMPLE:\nROBOT CHEERLEADERS\nan_letters = \"aefhilmnorsxAEFHILMNORSX\"\nword = input(\"I will cheer for you! Enter a word: \")\ntimes = int(input(\"Enthusiasm level (1-10): \"))\ni = 0\nwhile i < len(word):\nchar = word[i]\nif char in an_letters:\nprint(\"Give me an \" + char + \"! \" + char)\nelse:\nprint(\"Give me a \" + char + \"! \" + char)\ni += 1\nprint(\"What does that spell?\")\nfor i in range(times):\nprint(word, \"!!!\")\n6.0001 LECTURE 3\nfor char in word:\n\nEXERCISE\ns1 = \"mit u rock\"\ns2 = \"i rule mit\"\nif len(s1) == len(s2):\nfor char1 in s1:\nfor char2 in s2:\nif char1 == char2:\nprint(\"common letter\")\nbreak\n6.0001 LECTURE 3\n\nGUESS-AND-CHECK\n*the process below also called exhaustive enumeration\n*given a problem...\n*you are able to guess a value for solution\n*you are able to check if the solution is correct\n*keep guessing until find solution or guessed all values\n6.0001 LECTURE 3\n\nGUESS-AND-CHECK\n- cube root\ncube = 8\nfor guess in range(cube+1):\nif guess**3 == cube:\nprint(\"Cube root of\", cube, \"is\", guess)\n6.0001 LECTURE 3\n\nGUESS-AND-CHECK\n- cube root\ncube = 8\nfor guess in range(abs(cube)+1):\nif guess**3 >= abs(cube):\nbreak\nif guess**3 != abs(cube):\nprint(cube, 'is not a perfect cube')\nelse:\nif cube < 0:\nguess = -guess\nprint('Cube root of '+str(cube)+' is '+str(guess))\n6.0001 LECTURE 3\n\nAPPROXIMATE SOLUTIONS\n*good enough solution\n*start with a guess and increment by some small value\n*keep guessing if |guess3-cube| >= epsilon\nfor some small epsilon\n*decreasing increment size slower program\n*increasing epsilon\nless accurate answer\n6.0001 LECTURE 3\n\nAPPROXIMATE SOLUTION\n- cube root\ncube = 27\nepsilon = 0.01\nguess = 0.0\nincrement = 0.0001\nnum_guesses = 0\nwhile abs(guess**3 - cube) >= epsilon:\nguess += increment\nnum_guesses += 1\nprint('num_guesses =', num_guesses)\nif abs(guess**3 - cube) >= epsilon:\nprint('Failed on cube root of', cube)\nelse:\nprint(guess, 'is close to the cube root of', cube)\nand guess <= cube :\n6.0001 LECTURE 3\n\nBISECTION SEARCH\n*half interval each iteration\n*new guess is halfway in between\n*to illustrate, let's play a game!\n6.0001 LECTURE 3\nGUESS\nGUESS\nGUESS\n\nBISECTION SEARCH\n- cube root\ncube = 27\nepsilon = 0.01\nnum_guesses = 0\nlow = 0\nhigh = cube\nguess = (high + low)/2.0\nwhile abs(guess**3 - cube) >= epsilon:\nif guess**3 < cube :\nlow = guess\nelse:\nhigh = guess\nguess = (high + low)/2.0\nnum_guesses += 1\nprint 'num_guesses =', num_guesses\nprint guess, 'is close to the cube root of', cube\n6.0001 LECTURE 3\n\nBISECTION SEARCH\nCONVERGENCE\n*search space\n*first guess:\nN/2\n*second guess:\nN/4\n*kth guess:\nN/2k\n*guess converges on the order of log2N steps\n*bisection search works when value of function varies\nmonotonically with input\n*code as shown only works for positive cubes > 1 - why?\n*challenges modify to work with negative cubes!\nmodify to work with x < 1!\n6.0001 LECTURE 3\n\nx < 1\n*if x < 1, search space is 0 to x but cube root is greater\nthan x and less than 1\n*modify the code to choose the search space\ndepending on value of x\n6.0001 LECTURE 3\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Code",
      "title": "Lecture 4 Code",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/9e8439a27af18817e046ac37333d03f6_lec4_functions.py",
      "content": "#########################\n## EXAMPLE: combinations of print and return\n## Python Tutor link: http://www.pythontutor.com/visualize.html#code=def%20is_even_with_return(%20i%20%29%3A%0A%20%20%20%20%22%22%22%20%0A%20%20%20%20Input%3A%20i,%20a%20positive%20int%0A%20%20%20%20Returns%20True%20if%20i%20is%20even,%20otherwise%20False%0A%20%20%20%20%22%22%22%0A%20%20%20%20print('with%20return'%29%0A%20%20%20%20remainder%20%3D%20i%20%25%202%0A%20%20%20%20return%20remainder%20%3D%3D%200%0A%0Ais_even_with_return(3%29%20%0Aprint(is_even_with_return(3%29%20%29%0A%0Adef%20is_even_without_return(%20i%20%29%3A%0A%20%20%20%20%22%22%22%20%0A%20%20%20%20Input%3A%20i,%20a%20positive%20int%0A%20%20%20%20Does%20not%20return%20anything%0A%20%20%20%20%22%22%22%0A%20%20%20%20print('without%20return'%29%0A%0Ais_even_without_return(3%29%0Aprint(is_even_without_return(3%29%20%29%0A&cumulative=false&curInstr=0&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\n#########################\ndef is_even_with_return( i ):\n\"\"\"\nInput: i, a positive int\nReturns True if i is even, otherwise False\n\"\"\"\nprint('with return')\nremainder = i % 2\nreturn remainder == 0\n\nis_even_with_return(3)\nprint(is_even_with_return(3) )\n\ndef is_even_without_return( i ):\n\"\"\"\nInput: i, a positive int\nDoes not return anything\n\"\"\"\nprint('without return')\nremainder = i % 2\n\nis_even_without_return(3)\nprint(is_even_without_return(3) )\n\n# Simple is_even function definition\ndef is_even( i ):\n\"\"\"\nInput: i, a positive int\nReturns True if i is even, otherwise False\n\"\"\"\nremainder = i % 2\nreturn remainder == 0\n\n# Use the is_even function later on in the code\nprint(\"All numbers between 0 and 20: even or not\")\nfor i in range(20):\nif is_even(i):\nprint(i, \"even\")\nelse:\nprint(i, \"odd\")\n\n#########################\n## EXAMPLE: applying functions to repeat same task many times\n#########################\ndef bisection_cuberoot_approx(x, epsilon):\n\"\"\"\nInput: x, an integer\nUses bisection to approximate the cube root of x to within epsilon\nReturns: a float approximating the cube root of x\n\"\"\"\nlow = 0.0\nhigh = x\nguess = (high + low)/2.0\nwhile abs(guess**3 - x) >= epsilon:\nif guess**3 < x:\nlow = guess\nelse:\nhigh = guess\nguess = (high + low)/2.0\nreturn guess\n\nx = 1\nwhile x <= 10000:\napprox = bisection_cuberoot_approx(x, 0.01)\nprint(approx, \"is close to cube root of\", x)\nx *= 10\n\n#########################\n## EXAMPLE: functions as arguments\n## Python Tutor link: http://www.pythontutor.com/visualize.html#code=def%20func_a(%29%3A%0A%20%20%20%20print('inside%20func_a'%29%0A%0Adef%20func_b(y%29%3A%0A%20%20%20%20print('inside%20func_b'%29%0A%20%20%20%20return%20y%0A%0Adef%20func_c(z%29%3A%0A%20%20%20%20print('inside%20func_c'%29%0A%20%20%20%20return%20z(%29%0A%0Aprint(func_a(%29%29%0Aprint(5%2Bfunc_b(2%29%29%0Aprint(func_c(func_a%29%29%0A&cumulative=false&curInstr=0&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\n#########################\ndef func_a():\nprint('inside func_a')\n\ndef func_b(y):\nprint('inside func_b')\nreturn y\n\ndef func_c(z):\nprint('inside func_c')\nreturn z()\n\nprint(func_a())\nprint(5+func_b(2))\nprint(func_c(func_a))\n\n#########################\n## EXAMPLE: returning function objects\n## Python Tutor link: http://www.pythontutor.com/visualize.html#code=def%20f(%29%3A%0A%20%20%20%20def%20x(a,%20b%29%3A%0A%20%20%20%20%20%20%20%20return%20a%2Bb%0A%20%20%20%20return%20x%0A%20%20%20%20%0Aval%20%3D%20f(%29(3,4%29%0Aprint(val%29%0A&cumulative=false&curInstr=0&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\n#########################\ndef f():\ndef x(a, b):\nreturn a+b\nreturn x\n\n# the first part, f(), returns a function object\n# then apply that function with parameters 3 and 4\nval = f()(3,4)\nprint(val)\n\n#########################\n## EXAMPLE: shows accessing variables outside scope\n#########################\ndef f(y):\nx = 1\nx += 1\nprint(x)\nx = 5\nf(x)\nprint(x)\n\ndef g(y):\nprint(x)\nprint(x+1)\nx = 5\ng(x)\nprint(x)\n\ndef h(y):\npass\n#x += 1 #leads to an error without line `global x` inside h\nx = 5\nh(x)\nprint(x)\n\n#########################\n## EXAMPLE: hader scope example from slides\n## Python Tutor link: http://www.pythontutor.com/visualize.html#code=def%20g(x%29%3A%0A%20%20%20%20def%20h(%29%3A%0A%20%20%20%20%20%20%20%20x%20%3D%20'abc'%0A%20%20%20%20x%20%3D%20x%20%2B%201%0A%20%20%20%20print('in%20g(x%29%3A%20x%20%3D',%20x%29%0A%20%20%20%20h(%29%0A%20%20%20%20return%20x%0A%0Ax%20%3D%203%0Az%20%3D%20g(x%29&cumulative=false&curInstr=0&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\n#########################\ndef g(x):\ndef h():\nx = 'abc'\nx = x + 1\nprint('in g(x): x =', x)\nh()\nreturn x\n\nx = 3\nz = g(x)\n\n#########################\n## EXAMPLE: complicated scope, test yourself!\n## Python Tutor link: http://www.pythontutor.com/visualize.html#code=def%20f(x%29%3A%0A%20%20%20x%20%3D%20x%20%2B%201%0A%20%20%20print('in%20f(x%29%3A%20x%20%3D',%20x%29%0A%20%20%20return%20x%0A%0Ax%20%3D%203%0Az%20%3D%20f(x%29%0Aprint('in%20main%20program%20scope%3A%20z%20%3D',%20z%29%0Aprint('in%20main%20program%20scope%3A%20x%20%3D',%20x%29%0A%0Adef%20g(x%29%3A%0A%20%20%20%20def%20h(x%29%3A%0A%20%20%20%20%20%20%20%20x%20%3D%20x%2B1%0A%20%20%20%20%20%20%20%20print(%22in%20h(x%29%3A%20x%20%3D%20%22,%20x%29%0A%20%20%20%20x%20%3D%20x%20%2B%201%0A%20%20%20%20print('in%20g(x%29%3A%20x%20%3D%20',%20x%29%0A%20%20%20%20h(x%29%0A%20%20%20%20return%20x%0A%0Ax%20%3D%203%0Az%20%3D%20g(x%29%0Aprint('in%20main%20program%20scope%3A%20x%20%3D%20',%20x%29%0Aprint('in%20main%20program%20scope%3A%20z%20%3D%20',%20z%29%0A&cumulative=false&curInstr=0&heapPrimitives=false&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\n#########################\ndef f(x):\nx = x + 1\nprint('in f(x): x =', x)\nreturn x\n\nx = 3\nz = f(x)\nprint('in main program scope: z =', z)\nprint('in main program scope: x =', x)\n\ndef g(x):\ndef h(x):\nx = x+1\nprint(\"in h(x): x = \", x)\nx = x + 1\nprint('in g(x): x = ', x)\nh(x)\nreturn x\n\nx = 3\nz = g(x)\nprint('in main program scope: x = ', x)\nprint('in main program scope: z = ', z)"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 4: Decomposition, Abstraction, Functions",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/6ba59859535f1566dd57a7279aeba5d1_MIT6_0001F16_Lec4.pdf",
      "content": "DECOMPOSITION,\nABSTRACTION,\nFUNCTIONS\n(download slides and .py files AYE follow along!)\n6.0001 LECTURE 4\n6.0001 LECTURE 4\n\nLAST TIME\n*while loops vs for loops\n*should know how to write both kinds\n*should know when to use them\n*guess-and-check and approximation methods\n*bisection method to speed up programs\n6.0001 LECTURE 4\n\nTODAY\n*structuring programs and hiding details\n*functions\n*specifications\n*keywords: return vs print\n*scope\n6.0001 LECTURE 4\n\nHOW DO WE WRITE CODE?\n*so far...\n- covered language mechanisms\n- know how to write different files for each computation\n- each file is some piece of code\n- each code is a sequence of instructions\n*problems with this approach\n- easy for small-scale problems\n- messy for larger problems\n- hard to keep track of details\n- how do you know the right info is supplied to the right\npart of code\n6.0001 LECTURE 4\n\nGOOD PROGRAMMING\n*more code not necessarily a good thing\n*measure good programmers by the amount of\nfunctionality\n*introduce functions\n*mechanism to achieve decomposition and abstraction\n6.0001 LECTURE 4\n\nEXAMPLE - PROJECTOR\n*a projector is a black box\n*don't know how it works\n*know the interface: input/output\n*connect any electronic to it that can communicate\nwith that input\n*black box somehow converts image from input source\nto a wall, magnifying it\n*ABSTRACTION IDEA: do not need to know how\nprojector works to use it\n6.0001 LECTURE 4\n\nEXAMPLE - PROJECTOR\n*projecting large image for Olympics decomposed into\nseparate tasks for separate projectors\n*each projector takes input and produces separate\noutput\n*all projectors work together to produce larger image\n*DECOMPOSITION IDEA: different devices work\ntogether to achieve an end goal\n6.0001 LECTURE 4\n\nAPPLY THESE CONCEPTS\n6.0001 LECTURE 4\nTO PROGRAMMING!\n\nCREATE STRUCTURE with\nDECOMPOSITION\n6.0001 LECTURE 4\n*in projector example, separate devices\n*in programming, divide code into modules\n- are self-contained\n- used to break up code\n- intended to be reusable\n- keep code organized\n- keep code coherent\n*this lecture, achieve decomposition with functions\n*in a few weeks, achieve decomposition with classes\n\nSUPRESS DETAILS with\nABSTRACTION\n6.0001 LECTURE 4\n*in projector example, instructions for how to use it are\nsufficient, no need to know how to build one\n*in programming, think of a piece of code as a black box\n- cannot see details\n- do not need to see details\n- do not want to see details\n- hide tedious coding details\n*achieve abstraction with function specifications or\ndocstrings\n\nFUNCTIONS\n*write reusable pieces/chunks of code, called functions\n*functions are not run in a program until they are\n\"called\" or \"invoked\" in a program\n*function characteristics:\n- has a name\n- has parameters (0 or more)\n- has a docstring (optional but recommended)\n- has a body\n- returns something\n6.0001 LECTURE 4\n\ndef is_even( i ):\n\"\"\"\nInput: i, a positive int\nReturns True if i is even, otherwise False\n\"\"\"\nprint(\"inside is_even\")\nreturn i%2 == 0\nis_even(3)\nHOW TO WRITE and\nCALL/INVOKE A FUNCTIONnameparameters or argumentsbodykeywordspecification, docstringlater in the code, you call the function using its name and values for parameters\n6.0001 LECTURE 4\n\ndef is_even( i ):\n\"\"\"\nInput: i, a positive int\nReturns True if i is even, otherwise False\n\"\"\"\nprint(\"inside is_even\")\nreturn i%2 == 0\nIN THE FUNCTION BODYkeywordexpression to evaluate and return\n6.0001 LECTURE 4\n13run some commands\n\ndef f( x ):\nx = x + 1\nprint('in f(x): x =', x)\nreturn x\nx = 3\nz = f( x )\n*formal parameter gets bound to the value of\nactual parameter when function is called\n*new scope/frame/environment created when enter a function\n*scope is mapping of names to objects\nVARIABLE SCOPEformal parameteractual parameter\n6.0001 LECTURE 4\n14Function definitionMain program code* initializes a variable x* makes a function call f(x)* assigns return of function to variable z\n\ndef f( x ):\nx = x + 1\nprint('in f(x): x =', x)\nreturn x\nx = 3\nz = f( x )\nVARIABLE SCOPE\n6.0001 LECTURE 4\nGlobal scope\nf\nx\nz\nSome\ncode\nf scope\nx\n\nVARIABLE SCOPE\n6.0001 LECTURE 4\nGlobal scope\nf\nx\nz\nSome\ncode\nf scope\nx\ndef f( x ):\nx = x + 1\nprint('in f(x): x =', x)\nreturn x\nx = 3\nz = f( x )\n\nVARIABLE SCOPE\n6.0001 LECTURE 4\nGlobal scope\nf\nx\nz\nSome\ncode\nf scope\nx\ndef f( x ):\nx = x + 1\nprint('in f(x): x =', x)\nreturn x\nx = 3\nz = f( x )\nreturns 4\n\nVARIABLE SCOPE\n6.0001 LECTURE 4\nGlobal scope\nf\nx\nz\nSome\ncode\ndef f( x ):\nx = x + 1\nprint('in f(x): x =', x)\nreturn x\nx = 3\nz = f( x )\n\nONE WARNING IF NO\nreturn STATEMENT\ndef is_even( i ):\n\"\"\"\nInput: i, a positive int\nDoes not return anything\n\"\"\"\ni%2 == 0\n*Python returns the value None, if no return given\n*represents the absence of a valuewithout a return statement\n6.0001 LECTURE 4\n\nreturn\nvs. print\n*return only has meaning\ninside a function\n*only one return executed\ninside a function\n*code inside function but\nafter return statement not\nexecuted\n*has a value associated\nwith it, given to function\ncaller\n*print can be used outside\nfunctions\n*can execute many print\nstatements inside a function\n*code inside function can be\nexecuted after a print\nstatement\n*has a value associated with\nit, outputted to the console\n6.0001 LECTURE 4\n\nFUNCTIONS AS ARGUMENTS\n*arguments can take on any type, even functions\n6.0001 LECTURE 4\n21call func_a, takes no parameterscall func_b, takes one parametercall func_c, takes one parameter, another function\ndef func_a():\nprint 'inside func_a'\ndef func_b(y):\nprint 'inside func_b'\nreturn y\ndef func_c(z):\nprint 'inside func_c'\nreturn z()\nprint func_a()\nprint 5 + func_b(2)\nprint func_c(func_a)\n\nFUNCTIONS AS ARGUMENTS\n6.0001 LECTURE 4\ndef func_a():\nprint 'inside func_a'\ndef func_b(y):\nprint 'inside func_b'\nreturn y\ndef func_c(z):\nprint 'inside func_c'\nreturn z()\nprint func_a()\nprint 5 + func_b(2)\nprint func_c(func_a)\nGlobal scope\nfunc_a\nfunc_b\nfunc_c\nSome\ncode\nSome\ncode\nSome\ncode\nfunc_a scope\nreturns None\nNone\n\nGlobal scope\nfunc_a\nfunc_b\nfunc_c\nFUNCTIONS AS ARGUMENTS\n6.0001 LECTURE 4\ndef func_a():\nprint 'inside func_a'\ndef func_b(y):\nprint 'inside func_b'\nreturn y\ndef func_c(z):\nprint 'inside func_c'\nreturn z()\nprint func_a()\nprint 5 + func_b(2)\nprint func_c(func_a)\nSome\ncode\nSome\ncode\nSome\ncode\nfunc_b scope\ny\nreturns 2\nNone\n\nGlobal scope\nfunc_a\nfunc_b\nfunc_c\nFUNCTIONS AS ARGUMENTS\ndef func_a():\nprint 'inside func_a'\ndef func_b(y):\nprint 'inside func_b'\nreturn y\ndef func_c(z):\nprint 'inside func_c'\nreturn z()\nprint func_a()\nprint 5 + func_b(2)\nprint func_c(func_a)\nSome\ncode\nSome\ncode\nSome\ncode\nfunc_c scope\nz\nfunc_a\nfunc_a scope\nreturns None\nreturns None\nNone\n6.0001 LECTURE 4\nNone\n\n*inside a function, can access a variable defined outside\n*inside a function, cannot modify a variable defined\noutside -- can using global variables, but frowned upon\nSCOPE EXAMPLE\n6.0001 LECTURE 4\ndef g(y):\nprint(x)\nprint(x + 1)\nx = 5\ng(x)\nprint(x)\ndef h(y):\nx += 1\nx = 5\nh(x)\nprint(x)xinside gis picked up from scope that called function gUnboundLocalError: local variable 'x' referenced before assignment\ndef f(y):\nx = 1\nx += 1\nprint(x)\nx = 5\nf(x)\nprint(x)xis re-defined in scope of fdifferent xobjectsxfrom outside g\n\n*inside a function, can access a variable defined outside\n*inside a function, cannot modify a variable defined\noutside -- can using global variables, but frowned upon\nSCOPE EXAMPLE\n6.0001 LECTURE 4\ndef g(y):\nprint(x)\nx = 5\ng(x)\nprint(x)\ndef h(y):\nx += 1\nx = 5\nh(x)\nprint(x)\ndef f(y):\nx = 1\nx += 1\nprint(x)\nx = 5\nf(x)\nprint(x)xfrom global/main program scope\n\nHARDER SCOPE EXAMPLE\nPython Tutor is your best friend to\nhelp sort this out!\nhttp://www.pythontutor.com/\nIMPORTANT\nand\nTRICKY!\n6.0001 LECTURE 4\n\ndef g(x):\ndef h():\nx = 'abc'\nx = x + 1\nprint('g: x =', x)\nh()\nreturn x\nx = 3\nz = g(x)\nSCOPE DETAILS\nGlobal scope\ng\nx\nz\nSome\ncode\n3Some code\n6.0001 LECTURE 4\n\nSCOPE DETAILS\ng scope\nx\nh\nSome\ncode\n6.0001 LECTURE 4\nGlobal scope\ng\nx\nz\nSome\ncode\ndef g(x):\ndef h():\nx = 'abc'\nx = x + 1\nprint('g: x =', x)\nh()\nreturn x\nx = 3\nz = g(x)\n\nSCOPE DETAILS\ng scope\nx\nh\nSome\ncode\n6.0001 LECTURE 4\nGlobal scope\ng\nx\nz\nSome\ncode\ndef g(x):\ndef h():\nx = 'abc'\nx = x + 1\nprint('g: x =', x)\nh()\nreturn x\nx = 3\nz = g(x)\n\nSCOPE DETAILS\nGlobal scope\ng\nx\nz\nSome\ncode\ng scope\nx\nh\nSome\ncode\nh scope\nx\n\"abc\"\n6.0001 LECTURE 4\ndef g(x):\ndef h():\nx = 'abc'\nx = x + 1\nprint('g: x =', x)\nh()\nreturn x\nx = 3\nz = g(x)\nreturns None\n\nSCOPE DETAILS\ng scope\nx\nh\nSome\ncode\nNone\n6.0001 LECTURE 4\nGlobal scope\ng\nx\nz\nSome\ncode\ndef g(x):\ndef h():\nx = 'abc'\nx = x + 1\nprint('g: x =', x)\nh()\nreturn x\nx = 3\nz = g(x)\nreturns 4\n\nSCOPE DETAILS\n6.0001 LECTURE 4\nGlobal scope\ng\nx\nz\nSome\ncode\ndef g(x):\ndef h():\nx = 'abc'\nx = x + 1\nprint('g: x =', x)\nh()\nreturn x\nx = 3\nz = g(x)\n\nDECOMPOSITION &\nABSTRACTION\n*powerful together\n*code can be used many times but only has to be\ndebugged once!\n6.0001 LECTURE 4\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Code",
      "title": "Lecture 5 Code",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/cdf5f8e7f109952655f4d253ed955555_lec5_tuples_lists.py",
      "content": "#########################\n## EXAMPLE: returning a tuple\n#########################\ndef quotient_and_remainder(x, y):\nq = x // y\nr = x % y\nreturn (q, r)\n\n(quot, rem) = quotient_and_remainder(5,3)\nprint(quot)\nprint(rem)\n\n#########################\n## EXAMPLE: iterating over tuples\n#########################\ndef get_data(aTuple):\n\"\"\"\naTuple, tuple of tuples (int, string)\nExtracts all integers from aTuple and sets\nthem as elements in a new tuple.\nExtracts all unique strings from from aTuple\nand sets them as elements in a new tuple.\nReturns a tuple of the minimum integer, the\nmaximum integer, and the number of unique strings\n\"\"\"\nnums = () # empty tuple\nwords = ()\nfor t in aTuple:\n# concatenating with a singleton tuple\nnums = nums + (t[0],)\n# only add words haven't added before\nif t[1] not in words:\nwords = words + (t[1],)\nmin_n = min(nums)\nmax_n = max(nums)\nunique_words = len(words)\nreturn (min_n, max_n, unique_words)\n\ntest = ((1,\"a\"),(2, \"b\"),\n(1,\"a\"),(7,\"b\"))\n(a, b, c) = get_data(test)\nprint(\"a:\",a,\"b:\",b,\"c:\",c)\n\n# apply to any data you want!\ntswift = ((2014,\"Katy\"),\n(2014, \"Harry\"),\n(2012,\"Jake\"),\n(2010,\"Taylor\"),\n(2008,\"Joe\"))\n(min_year, max_year, num_people) = get_data(tswift)\nprint(\"From\", min_year, \"to\", max_year, \\\n\"Taylor Swift wrote songs about\", num_people, \"people!\")\n\n#########################\n## EXAMPLE: sum of elements in a list\n#########################\ndef sum_elem_method1(L):\ntotal = 0\nfor i in range(len(L)):\ntotal += L[i]\nreturn total\n\ndef sum_elem_method2(L):\ntotal = 0\nfor i in L:\ntotal += i\nreturn total\n\nprint(sum_elem_method1([1,2,3,4]))\nprint(sum_elem_method2([1,2,3,4]))\n\n#########################\n## EXAMPLE: various list operations\n## put print(L) at different locations to see how it gets mutated\n#########################\nL1 = [2,1,3]\nL2 = [4,5,6]\nL3 = L1 + L2\nL1.extend([0,6])\n\nL = [2,1,3,6,3,7,0]\nL.remove(2)\nL.remove(3)\ndel(L[1])\nprint(L.pop())\n\ns = \"I<3 cs\"\nprint(list(s))\nprint(s.split('<'))\nL = ['a', 'b', 'c']\nprint(''.join(L))\nprint('_'.join(L))\n\nL=[9,6,0,3]\nprint(sorted(L))\nL.sort()\nL.reverse()\n\n#########################\n## EXAMPLE: aliasing\n#########################\na = 1\nb = a\nprint(a)\nprint(b)\n\nwarm = ['red', 'yellow', 'orange']\nhot = warm\nhot.append('pink')\nprint(hot)\nprint(warm)\n\n#########################\n## EXAMPLE: cloning\n#########################\ncool = ['blue', 'green', 'grey']\nchill = cool[:]\nchill.append('black')\nprint(chill)\nprint(cool)\n\n#########################\n## EXAMPLE: sorting with/without mutation\n#########################\nwarm = ['red', 'yellow', 'orange']\nsortedwarm = warm.sort()\nprint(warm)\nprint(sortedwarm)\n\ncool = ['grey', 'green', 'blue']\nsortedcool = sorted(cool)\nprint(cool)\nprint(sortedcool)\n\n#########################\n## EXAMPLE: lists of lists of lists...\n#########################\nwarm = ['yellow', 'orange']\nhot = ['red']\nbrightcolors = [warm]\nbrightcolors.append(hot)\nprint(brightcolors)\nhot.append('pink')\nprint(hot)\nprint(brightcolors)\n\n###############################\n## EXAMPLE: mutating a list while iterating over it\n###############################\ndef remove_dups(L1, L2):\nfor e in L1:\nif e in L2:\nL1.remove(e)\n\ndef remove_dups_new(L1, L2):\nL1_copy = L1[:]\nfor e in L1_copy:\nif e in L2:\nL1.remove(e)\n\nL1 = [1, 2, 3, 4]\nL2 = [1, 2, 5, 6]\nremove_dups(L1, L2)\nprint(L1, L2)\n\nL1 = [1, 2, 3, 4]\nL2 = [1, 2, 5, 6]\nremove_dups_new(L1, L2)\nprint(L1, L2)\n\n###############################\n## EXERCISE: Test yourself by predicting what the output is and\n## what gets mutated then check with the Python Tutor\n###############################\ncool = ['blue', 'green']\nwarm = ['red', 'yellow', 'orange']\nprint(cool)\nprint(warm)\n\ncolors1 = [cool]\nprint(colors1)\ncolors1.append(warm)\nprint('colors1 = ', colors1)\n\ncolors2 = [['blue', 'green'],\n['red', 'yellow', 'orange']]\nprint('colors2 =', colors2)\n\nwarm.remove('red')\nprint('colors1 = ', colors1)\nprint('colors2 =', colors2)\n\nfor e in colors1:\nprint('e =', e)\n\nfor e in colors1:\nif type(e) == list:\nfor e1 in e:\nprint(e1)\nelse:\nprint(e)\n\nflat = cool + warm\nprint('flat =', flat)\n\nprint(flat.sort())\nprint('flat =', flat)\n\nnew_flat = sorted(flat, reverse = True)\nprint('flat =', flat)\nprint('new_flat =', new_flat)\n\ncool[1] = 'black'\nprint(cool)\nprint(colors1)"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 5: Tuples, Lists, Aliasing, Mutability, Cloning",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/1776670e271578eeb99fc25975f20586_MIT6_0001F16_Lec5.pdf",
      "content": "TUPLES, LISTS,\nALIASING,\nMUTABILITY, CLONING\n(download slides and .py files and follow along!)\n6.0001 LECTURE 5\n6.0001 LECTURE 5\n\nLAST TIME\n*functions\n*decomposition - create structure\n*abstraction - suppress details\n*from now on will be using functions a lot\n6.0001 LECTURE 5\n\nTODAY\n*have seen variable types: int, float, bool,string\n*introduce new compound data types\n- tuples\n- lists\n*idea of aliasing\n*idea of mutability\n*idea of cloning\n6.0001 LECTURE 5\n\nTUPLES\n*an ordered sequence of elements, can mix element types\n*cannot change element values, immutable\n*represented with parentheses\nte = ()\nt = (2,\"mit\",3)\nt[0]\nevaluates to 2\n(2,\"mit\",3) + (5,6)\nevaluates to (2,\"mit\",3,5,6)\nt[1:2]\nslice tuple, evaluates to (\"mit\",)\nt[1:3]\nslice tuple, evaluates to (\"mit\",3)\nlen(t)\nevaluates to 3\nt[1] = 4 gives error, can't modify object\n6.0001 LECTURE 5\n4extra comma means a tuple with one elementremember strings?empty tuple\n\nTUPLES\n*conveniently used to swap variable values\nx = y\ntemp = x\n(x, y) = (y, x)\ny = x\nx = y\ny = temp\n*used to return more than one value from a function\ndef quotient_and_remainder(x, y):\nq = x // y\nr = x % y\nreturn (q, r)\n(quot, rem) = quotient_and_remainder(4,5)\n6.0001 LECTURE 5\n5integer division\n\nMANIPULATING TUPLES\n*can iterate over tuples\ndef get_data(aTuple):\nnums = ()\nwords = ()\nfor t in aTuple:\nnums = nums + (t[0],)\nif t[1] not in words:\nwords = words + (t[1],)\nmin_n = min(nums)\nmax_n = max(nums)\nunique_words = len(words)\nreturn (min_n, max_n, unique_words)\n6.0001 LECTURE 5\n6empty tuplesingleton tuple\naTuple:(( ),( ),( ))\nnums( )\nwords( )\nif not already in words\ni.e. unique strings from aTuple\n?\n?\n?\n\nLISTS\n*ordered sequence of information, accessible by index\n*a list is denoted by square brackets, []\n*a list contains elements\n- usually homogeneous (ie, all integers)\n- can contain mixed types (not common)\n*list elements can be changed so a list is mutable\n6.0001 LECTURE 5\n\nINDICES AND ORDERING\na_list = []\nL = [2, 'a', 4, [1,2]]\nlen(L) evaluates to 4\nL[0]\nevaluates to 2\nL[2]+1 evaluates to 5\nL[3]\nevaluates to [1,2], another list!\nL[4]\ngives an error\ni = 2\nL[i-1] evaluates to 'a' since L[1]='a' aboveempty list\n6.0001 LECTURE 5\n\nCHANGING ELEMENTS\n*lists are mutable!\n*assigning to an element at an index changes the value\nL = [2, 1, 3]\nL[1] = 5\n*L is now [2, 5, 3], note this is the same object L\n6.0001 LECTURE 5\nL\n[2,1,3]\n[2,5,3]\n\nITERATING OVER A LIST\n*compute the sum of elements of a list\n*common pattern, iterate over list elements\n*notice\n- list elements are indexed 0 to len(L)-1\n- range(n) goes from 0 to n-1\n6.0001 LECTURE 5\ntotal = 0\nfor i in range(len(L)):\ntotal += L[i]\nprint total\ntotal = 0\nfor i in L:\ntotal += i\nprint totallike strings, can iterate over list elements directly\n\nOPERATIONS ON LISTS - ADD\n*add elements to end of list with L.append(element)\n*mutates the list!\nL = [2,1,3]\nL.append(5)\nL is now [2,1,3,5]\n*what is the dot?\n- lists are Python objects, everything in Python is an object\n- objects have data\n- objects have methods and functions\n- access this information by object_name.do_something()\n- will learn more about these later\n6.0001 LECTURE 5\n\nOPERATIONS ON LISTS - ADD\n*to combine lists together use concatenation, + operator,\nto give you a new list\n*mutate list with L.extend(some_list)\nL1 = [2,1,3]\nL2 = [4,5,6]\nL3 = L1 + L2\nL3 is [2,1,3,4,5,6]\nL1, L2 unchanged\nL1.extend([0,6])\nmutated L1 to [2,1,3,0,6]\n6.0001 LECTURE 5\n\nOPERATIONS ON LISTS -\nREMOVE\n*delete element at a specific index with del(L[index])\n*remove element at end of list with L.pop(), returns the\nremoved element\n*remove a specific element with L.remove(element)\n- looks for the element and removes it\n- if element occurs multiple times, removes first occurrence\n- if element not in list, gives an error\nL = [2,1,3,6,3,7,0] # do below in order\nL.remove(2) mutates L = [1,3,6,3,7,0]\nL.remove(3) mutates L = [1,6,3,7,0]\ndel(L[1]) mutates L = [1,3,7,0]\nL.pop()\nreturns 0 and mutates L = [1,3,7]\n6.0001 LECTURE 5\n13all these operations mutate the list\n\nCONVERT LISTS TO STRINGS\nAND BACK\n*convert string to list with list(s), returns a list with every\ncharacter from s an element in L\n*can use s.split(), to split a string on a character parameter,\nsplits on spaces if called without a parameter\n*use ''.join(L) to turn a list of characters into a string, can\ngive a character in quotes to add char between every element\n6.0001 LECTURE 5\ns = \"I<3 cs\"\ns is a string\nlist(s)\nreturns ['I','<','3',' ','c','s']\ns.split('<')\nreturns ['I', '3 cs']\nL = ['a','b','c']\nL is a list\n''.join(L)\nreturns \"abc\"\n'_'.join(L)\nreturns \"a_b_c\"\n\nOTHER LIST OPERATIONS\n*sort() and sorted()\n*reverse()\n*and many more!\nhttps://docs.python.org/3/tutorial/datastructures.html\nL=[9,6,0,3]\nsorted(L)\nreturns sorted list, does not mutate L\nL.sort()\nmutates L=[0,3,6,9]\nL.reverse()\nmutates L=[9,6,3,0]\n6.0001 LECTURE 5\n\nMUTATION, ALIASING, CLONING\nAgain, Python Tutor is your best friend\nto help sort this out!\nhttp://www.pythontutor.com/\nIMPORTANT\nand\nTRICKY!\n6.0001 LECTURE 5\n\nLISTS IN MEMORY\n*lists are mutable\n*behave differently than immutable types\n*is an object in memory\n*variable name points to object\n*any variable pointing to that object is affected\n*key phrase to keep in mind when working with lists is\nside effects\n6.0001 LECTURE 5\n\nAN ANALOGY\n*attributes of a person\n*singer, rich\n*he is known by many names\n*all nicknames point to the same person\n- add new attribute to one nickname ...\n- ... all his nicknames refer to old attributes AND all new ones\n6.0001 LECTURE 5\nJustin Bieber\nsinger\nrich\ntroublemaker\nThe Bieb\nsinger\nrich\ntroublemaker\nJBeebs\nsinger\nrich\ntroublemaker\n\nALIASES\n*hot is an alias for warm - changing one changes the\nother!\n*append() has a side effect\n6.0001 LECTURE 5\n\nCLONING A LIST\n*create a new list and copy every element using\nchill = cool[:]\n6.0001 LECTURE 5\n\nSORTING LISTS\n*calling sort() mutates the list, returns nothing\n*calling sorted()\ndoes not mutate\nlist, must assign\nresult to a variable\n6.0001 LECTURE 5\n\nLISTS OF LISTS OF LISTS OF....\n*can have nested lists\n*side effects still\npossible after mutation\n6.0001 LECTURE 5\n\nMUTATION AND ITERATION\nTry this in Python Tutor!\n*avoid mutating a list as you are iterating over it\ndef remove_dups(L1, L2):\nfor e in L1:\nif e in L2:\nL1.remove(e)\nL1 = [1, 2, 3, 4]\nL2 = [1, 2, 5, 6]\nremove_dups(L1, L2)\n*L1 is [2,3,4] not [3,4] Why?\n- Python uses an internal counter to keep track of index it is in the loop\n- mutating changes the list length but Python doesn't update the counter\n- loop never sees element 2\n6.0001 LECTURE 5\ndef remove_dups(L1, L2):\nL1_copy = L1[:]\nfor e in L1_copy:\nif e in L2:\nL1.remove(e)clone list first, note that L1_copy = L1does NOT clone\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0001 Introduction to Computer Science and Programming in Python\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    }
  ]
}