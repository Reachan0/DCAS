{
  "course_name": "Programming Languages",
  "course_description": "6.821 teaches the principles of functional, imperative, and logic programming languages. Topics covered include: meta-circular interpreters, semantics (operational and denotational), type systems (polymorphism, inference, and abstract types), object oriented programming, modules, and multiprocessing. The course involves substantial programming assignments and problem sets as well as a significant amount of reading. The course uses the Scheme+ programming language for all of its assignments.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Engineering",
    "Computer Science",
    "Programming Languages"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1.5 hours / session\n\nRecitations: 1 session/ week, 1 hour / session\n\nStaff\n\nLecturer: Michael Ernst\n\nPrerequisites\n\nIn order to take this course, you should have fairly extensive programming experience, some background in language implementation, and a mathematical repertoire including sets, functions, and proofs. The course will be intensive, involving substantial programming assignments and problem sets as well as a significant amount of reading.\n\nWe will be using SCHEME+, Scheme with added datatype and pattern matching facilities, for all the programming assignments. Those who know Scheme should have no trouble picking up the new features. Those students not versed in Scheme should be prepared to spend additional time learning the language during the first few weeks of the course. We will be offering a tutorial on SCHEME+ to help bring people up to speed.\n\nThis course is intended primarily for Computer Science graduate students. Computer science undergraduates and graduate students from other departments are welcome to take the course as enrollment permits. However, be aware that the course is substantially more challenging than an undergraduate course.\n\nRecitation Sections\n\nEach recitation instructor leads one one-hour recitation. This is an interactive forum for answering your questions and going over examples of current material. Please come prepared and bring questions!\n\nOffice Hours\n\nProfessor Ernst will be available after class and by appointment. The recitation instructor is available during designated office hours. At times other than those listed above, you may call or visit your recitation instructor in his office. However, please keep in mind that your instructor may not always have the time to talk to you in such situations. In order to guarantee that the instructor will have time to see you, it's a better idea to set up an appointment with him ahead of time via electronic mail.\n\nReading Material\n\nThere is no required text for this course. The reading material will instead consist of course notes and handouts given out during lectures.\n\nThe course notes include the chapters of a book in progress.\n\nThe handouts consist of occasional copies of classic papers from the programming languages area.\n\nIf you have any comments on the material in the handouts or course notes, especially the draft chapters of the book, please talk to us.\n\nAll students are encouraged to acquaint themselves with:\n\nAbelson, Harold, and Gerald Jay Sussman with Julie Sussman.\nStructure and Interpretation of Computer Programs\n. 2nd ed. MIT Press, 1996. ISBN: 0262011530.\n\nThis excellent text (hereafter referred to as SICP) is used as the basis of the introductory course in computation (6.001). It is outstanding for its high-level view of computer science (emphasizing controlling the complexity of large systems and the use of computer languages as a means of expression) as well as the density of wonderful examples that can be found between its covers (a symbolic mathematics package, a constraint system, a digital logic simulator, a logic language interpreter,a compiler, etc.) SICP, as well as several other books we will reference during the course.\n\nProblem Sets\n\nYou will be given weekly problem sets throughout the term. Problem sets will typically have both pencil-and-paper problems and programming problems. Be forewarned that many of the problems, especially the programming assignments, are challenging and may take a significant amount of time. Plan your time accordingly. Don't wait until the last minute to start your problem sets!\n\nYou may write up the non-programming problems in any reasonable (but legible) format. Problem sets are graded on content, not form. In particular, it is not necessary to typeset your problem sets. We discourage you from wasting your time with a text formatter unless you find it convenient to do so. Some guidelines for the programming assignments are included in the last section of this handout.\n\nIf you do not think you will be able to complete a problem set on time, you may request an extension from your recitation instructor. The more advanced the notice you give your instructor, the more likely you are to be granted an extension. Extensions requested on the due date will be denied. And note that, usually, problem sets are handed out on Tuesday and are due the following Tuesday, and solutions may be discussed in the Friday recitations. Problem sets will not be accepted after solutions have been handed out.\n\nThis policy implies that you must be realistic in scheduling your time and should begin working on your problem sets well in advance of the due date.\n\nExams\n\nThere will be two exams in the course:\n\na. A 1.5 hour in-class midterm. This exam will cover the course material up to and including the lecture on Control II.\n\nb. A 3 hour exam during finals week. This exam will cover all of the material from the course.\n\nGrades\n\nYour grade will be computed based upon your final exam, your midterm quiz, your problem set grades, and your recitation instructor's recommendations. The last time this course was taught, the weighting on these factors was 40%, 30%, and 30%, for the final, midterm, and problem sets respectively, with the instructor's recommendations coming into play in borderline cases. (This is just to give you a sense for the relative weighting; we do not guarantee that the weighting will be the same this year.) Your recitation instructor's opinion of your understanding of the material is formed primarily by the quality and clarity of your problem set solutions as well as your classroom participation.\n\nFinding Help\n\nThere are many people who can answer your questions or help you better understand the course material. Your recitation instructor leads an hour-long recitation once each week, holds office hours, and also grades your papers. Make good use of your instructors! Feel free to talk with them after class and during office hours; make appointments to see them at other times. You can always send them electronic mail.\n\nWhen looking for help, don't overlook other students -- not only those who have taken the course in the past, but your classmates as well. Your classmates are a valuable resource; don't forget about them! In fact, we suggest that other students be your first \"line of defense\" when you have a question about course material. When possible, you should first pose your question to at least one classmate before bringing it to an instructor.\n\nCollaboration Policy\n\nIn 6.821 you are likely to learn just as much (if not more) from other students as you are from your classroom experiences. Since we believe that collaboration fosters a healthy and enjoyable educational environment,we encourage you to talk with other students about the course and to form study groups. We especially encourage collaboration between students who were (or are) MIT Course 6 undergraduates and students from other departments and institutions.\n\nUnless otherwise instructed, feel free to discuss problem sets with other students and exchange ideas about how to solve them. However, there is a thin line between collaboration and plagiarizing the work of others. Therefore, we require that you write up your own solution to each problem set. In keeping with the standards of the scientific community, we also require that you give credit where credit is due. If you make use of an idea that was developed by (or jointly with) others, please reference them appropriately in your work. For example, if person X gets a key idea for solving a problem from person Y , X's solution should begin with a note that says \"I worked with Y on this problem.\" and should say 'The main idea (due to Y ) is : : :' in the appropriate places.\n\nWhen working on problem set problems, it is perfectly reasonable to consult public literature (books, articles, etc.) for hints, techniques, and even solutions. However, you must reference any sources that contribute to your solution.\n\nProblem sets and solutions from previous terms of 6.821 are not considered to be part of the 'public' literature. We require you to refrain from looking at any problem set solutions from previous terms of 6.821 (unless, of course, we explicitly tell you to do so). It is our policy that consulting previous problem set solutions constitutes cheating.\n\nGuidelines for Programming Assignments\n\nMost of your programming assignments will involve extending or modifying code that we provide. You should turn in all the code that you write. If you make substantive modifications, you should turn in the entire program with your changes clearly marked. If you only make minor changes or they are limited to a few procedures, it is only necessary to turn in those procedures with a note indicating how your modifications interact with the unchanged code.\n\nTo convince your graders that your program correctly implements the desired functions, you should\n\na. provide an English language description of each function and the role it plays and\n\nb. demonstrate the correctness of your program on a sufficient test suite.\n\nYou should provide both of these pieces of information -- they are not mutually exclusive.",
  "files": [
    {
      "category": "Resource",
      "title": "closurize.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/7518939a7b50586a74a2142553250523_closurize.pdf",
      "content": "1. ;;;----------------------------------------------------------------------------\n2. ;;; CLOSURIZE.SCM\n3. ;;;\n4. ;;; A closure converter that makes flat closures for all LAMBDAs and FUNRECs.\n5. ;;; Writing CLOSURIZE-FUNREC is left as an exercise.\n6. ;;;\n7. ;;;----------------------------------------------------------------------------\n8. (define (closurize node)\n9. (cond ((application-node? node) (closurize-application node))\n10. ((named-primop-node? 'procedure? node) (closurize-procedure? node))\n11. ((lambda-node? node) (closurize-lambda node))\n12. ((funrec-node? node) (closurize-funrec node))\n13. (else (subnode-map closurize node))))\n14. (define (closurize-application node)\n15. `(CALL-CLOSURE ,(closurize (call-rator node))\ni. ,@(map closurize (call-rands node))))\n16. (define (closurize-procedure? node)\n17. `(PRIMOP CLOSURE? ,@(map closurize (primop-args node))))\n18. (define (closurize-lambda node)\n19. (let ((formals (lambda-formals node))\n20. (body (lambda-body node))\n21. (frees (free-vars node))\n22. (closure-var (make-var (fresh-name 'closure))))\n23. `(PRIMOP CLOSURE\na. (LAMBDA (,closure-var ,@formals)\ni. ,(rewrite (list->set frees)\n1. ;; Ref-rewriting procedure\n2. (lambda (var)\n3. (make-primop 'closure-ref\ni. (list closure-var\nii. ;; Need 1+ to pass over code\niii. (1+ (position var frees)))))\n4. ;; SET!-rewriting procedure\n5. (lambda (var body)\n6. (make-primop 'closure-set!\ni. (list closure-var\nii. ;; Need 1+ to pass over code\niii. (1+ (position var frees))\niv. body)))\n7. (closurize body)))\nb. ,@frees)))"
    },
    {
      "category": "Resource",
      "title": "funrec.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/34f0a0c08ab9e77a83fd318d2caa6057_funrec.pdf",
      "content": "1. ;;;----------------------------------------------------------------------------\n2. ;;; Update to NODE.SCM abstractions to handle FUNREC:\n3. ;;;\n4. ;;; (funrec ((I1 (lambda (I*) E_1))\n5. ;;;\n...\n6. ;;;\n(In (lambda (I*) E_n)))\n7. ;;; E_body)\n8. ;;;\n9. (define (funrec-node? node)\n10. (eq? (node-type node) 'funrec))\n11. (define (make-funrec names lams body)\n12. `(FUNREC ,(map (lambda (name lam) `(,name ,lam))\ni. names\nii. lams)\nb. ,body))\n13. (define (funrec-names node)\n14. (map first (second node)))\n15. (define (funrec-lambdas node)\n16. (map second (second node)))\n17. (define (funrec-body node)\n18. (third node))\n\n19. (define *special-forms*\n20. '(program lambda call if set! begin quote primop let\n21. define ; Only should be a top-level\n22. define-global global-ref global-set! ; Introduced by globalizing\n23. call-generic call-closure\n24. if-zero if-non-zero constant\n25. integer boolean char string\n26. unspecific null\n27. error syscall\n28. code call-code\n29. funrec\n; ***\n30. ))\n31. (define (subnodes node)\n32. (cond\n33. ((leaf-node? node) '())\n; Closure conversion\n; Data-conversion\n34. ((lambda-node? node) (list (lambda-body node)))\n35. ; ((simple-let-node? node)\n36. ; (cons (simple-let-body node) (simple-let-defs node)))\n37. ((let-node? node)\n38. (cons (let-body node) (let-defs node)))\n39. ((application-node? node) (application-subexps node))\n40. ((primop-node? node) (primop-args node))\n41. ((syscall-node? node) (syscall-args node))\n42. ((assignment-node? node) (list (assignment-body node)))\n43. ((program-node? node)\n44. (cons (program-body node) (map definition-body node)))\n45. ((funrec-node? node)\n46. (cons (funrec-body node) (funrec-lambdas node)))\n47. (else (node-subexps node))))\n\n48. (define (subnode-map fn node)\n49. ;;\n50. ;; For compound (non-leaf) nodes, return a new compound node in which\n51. ;; FN has been applied to each subnode. Has no effect on leaf nodes.\n52. ;;\n53. (cond\n54. ((leaf-node? node) node)\n55. ((lambda-node? node)\n56. (make-lambda (lambda-formals node)\na. (fn (lambda-body node))))\n57. ((let-node? node)\n58. (make-let (let-names node)\na. (map fn (let-defs node))\nb. (fn (let-body node))))\n59. ((assignment-node? node)\n60. (new-assignment node (fn (assignment-body node))))\n61. ((primop-node? node)\n62. (make-primop (primop-op node)\na. (map fn (primop-args node))))\n63. ((syscall-node? node)\n64. (make-syscall (syscall-op node)\na. (map fn (syscall-args node))))\n65. ((program-node? node)\n66. (let ((defs (program-defs node)))\n67. (make-program\n68. (map new-definition defs (map (compose fn definition-body) defs))\n69. (fn (program-body node)))))\n70. ;;; *** NEW ***\n71. ((funrec-node? node)\n72. (make-funrec (funrec-names node)\ni. (map fn (funrec-lambdas node))\nii. (fn (funrec-body node))))\n73. ;; ************\n74. (else (make-node (node-keyword node)\ni. (map fn (node-subexps node))))\n75. ))\n\n76. (define (subnode-map-receive fn node leaf receive)\n77. ;;\n78. ;; Generalized version of SUBNODE-MAP that allows the return of\n79. ;; multiple results in a recursive tree accumulation over a node tree.\n80. ;; At any node, applies RECEIVE to:\n81. ;;\n82. ;; (i) A node-making procedure specialized for the node that\n83. ;;\nexpects new subnodes as arguments.\n84. ;; (ii) A rest arg that is the result of applying FN to all of the\n85. ;;\nsubnodes. In general, FN will return a compound structure only\n86. ;;\none component of which is the new node.\n87. ;;\n88. ;; Since leaf nodes have no subnodes, the LEAF procedure is applied\n89. ;; to leaf nodes to generate the appropriate base case for the\n90. ;; recursive tree accumuation.\n91. ;;\n92. (cond\n93. ((leaf-node? node)\n94. (receive (lambda (ignore) node)\na. (leaf node)))\n95. ((lambda-node? node)\n96. (receive (lambda (body) (make-lambda (lambda-formals node) body))\na. (fn (lambda-body node))))\n97. ((let-node? node)\n98. (apply receive\n99. (lambda (new-body . new-defs)\na. (make-let (let-names node) new-defs new-body))\nb. (map fn (cons (let-body node) (let-defs node)))))\n100.\n((assignment-node? node)\n101.\n(receive (lambda (body) (new-assignment node body))\na. (fn (assignment-body node))))\n102.\n((primop-node? node)\n103.\n(apply receive\n104.\n(lambda new-args (make-primop (primop-op node) new-args))\n105.\n(map fn (primop-args node))))\n106.\n((syscall-node? node)\n107.\n(apply receive\n108.\n(lambda new-args (make-syscall (syscall-op node) new-args))\n109.\n(map fn (syscall-args node))))\n110.\n((program-node? node)\n111.\n(let ((defs (program-defs node)))\n112.\n(apply receive\na. (lambda (new-body . new-def-bodies)\ni. (make-program (map new-definition defs new-def-bodies)\n1. new-body))\n\nb. (map fn (cons (program-body node)\n1. (map define-body defs))))))\n113.\n;; *** NEW ***\n114.\n((funrec-node? node)\n115.\n(apply receive\na. (lambda (new-body . new-lambdas)\nb. (make-funrec (funrec-names node)\n1. new-lambdas\n2. new-body))\nc. (map fn (cons (funrec-body node) (funrec-lambdas node)))))\n116.\n;; ***********\n117.\n(else\n118.\n(apply receive\n119.\n(lambda new-subnodes (make-node (node-keyword node) new-subnodes))\n120.\n(map fn (node-subexps node))))\n121.\n))\n\n122.\n(define (rewrite vars rewrite-ref rewrite-set! node)\n123.\n;;\n124.\n;; A simple substitution routine.\n125.\n;; For each X in the set VARS of variable names:\n126.\n;; (i) replace every reference to X in NODE by the result of\n127.\n;;\n(REWRITE-REF X).\n128.\n;; (ii) replace every (SET! X <body>) in NODE by the result of\n129.\n;;\n(REWRITE-SET! X <rewritten-body>)\n130.\n;;\n131.\n;; Neither REWRITE-REF and REWRITE-SET! should return nodes with\nnames\n132.\n;; that might be captured by enclosing lambdas.\n133.\n;;\n134.\n(let walk ((vars vars)\na. (node node))\n135.\n(cond\n136.\n((set-empty? vars) node) ;; Optimization\n137.\n((and (var-node? node) (set-member? (var-name node) vars))\n138.\n(rewrite-ref (var-name node)))\n139.\n((and (set!-node? node) (set-member? (set!-name node) vars))\n140.\n(rewrite-set! (set!-name node)\ni. (walk vars (set!-body node))))\n141.\n((lambda-node? node)\n142.\n(let ((formals (lambda-formals node)))\n143.\n(make-lambda formals\ni. (walk (set-difference vars (list->set formals))\nii. (lambda-body node)))))\n144.\n((let-node? node)\n145.\n(let ((names (let-names node)))\n146.\n(make-let names\ni. (map (lambda (def) (walk vars def))\nii. (let-defs node))\niii. (walk (set-difference vars (list->set names))\n1. (let-body node)))))\n147.\n((program-node? node)\n148.\n(let* ((defs (program-defs node))\na. (names (map definition-names defs))\nb. (new-vars (set-difference vars (list->set names))))\n149.\n(make-program\na. (map (lambda (def)\ni. (new-definition def\na. (walk new-vars (definition-body def))))\nb. defs)\nc. (walk new-vars (program-body node)))))\n150.\n;; *** NEW ***\n\n151.\n((funrec-node? node)\n152.\n(let ((new-vars (set-difference vars\na. (list->set (funrec-names node)))))\n153.\n(make-funrec (funrec-names node)\ni. (map (lambda (def) (walk new-vars def))\n1. (funrec-lambdas node))\nii. (walk new-vars (funrec-body node)))))\n154.\n;; **********\n155.\n(else (subnode-map (lambda (n) (walk vars n)) node))\n156.\n)))\n\n157.\n(define (free-vars node)\n158.\n(cond\n159.\n((var-node? node) (set-singleton (var-name node)))\n160.\n((assignment-node? node)\n161.\n(set-union (set-singleton (assignment-name node))\ni. (free-vars (assignment-body node))))\n162.\n((lambda-node? node)\n163.\n(set-difference (free-vars (lambda-body node))\ni. (list->set (lambda-formals node))))\n164.\n((let-node? node)\n165.\n(set-union (map-union free-vars (let-defs node))\ni. (set-difference (free-vars (let-body node))\na. (list->set (let-names node)))))\n166.\n((program-node? node)\n167.\n(set-difference\n168.\n(set-union\n169.\n(map-union free-vars (map define-body (program-defs node)))\n170.\n(free-vars (program-body node)))\n171.\n(list->set (map define-name (program-defs node)))))\n172.\n;; *** NEW ***\n173.\n((funrec-node? node)\n174.\n(set-difference\n175.\n(set-union (map-union free-vars (funrec-lambdas node))\ni. (free-vars (funrec-body node)))\n176.\n(list->set (funrec-names node))))\n177.\n;; ***********\n178.\n(else (map-union free-vars (subnodes node)))\n179.\n))\n180.\n(define (free-mutables node)\n181.\n;;\n182.\n;; New function (not in NODE.SCM).\n183.\n;; Finds all free vars in node that are assigned via SET!\n184.\n;;\n185.\n(cond\n186.\n((var-node? node) the-empty-set)\n187.\n((assignment-node? node)\n188.\n(set-union (set-singleton (assignment-name node))\ni. (free-mutables (assignment-body node))))\n189.\n((lambda-node? node)\n190.\n(set-difference (free-mutables (lambda-body node))\ni. (list->set (lambda-formals node))))\n191.\n((let-node? node)\n192.\n(set-union (map-union free-mutables (let-defs node))\ni. (set-difference (free-mutables (let-body node))\n\na. (list->set (let-names node)))))\n193.\n((program-node? node)\n194.\n(set-difference\n195.\n(set-union\n196.\n(map-union free-mutables (map define-body (program-defs node)))\n197.\n(free-mutables (program-body node)))\n198.\n(list->set (map define-name (program-defs node)))))\n199.\n;; *** NEW ***\n200.\n((funrec-node? node)\n201.\n(set-difference\n202.\n(set-union (map-union free-mutables (funrec-lambdas node))\ni. (free-mutables (funrec-body node)))\n203.\n(list->set (funrec-names node))))\n204.\n;; ***********\n205.\n(else (map-union free-mutables (subnodes node)))\n206.\n))\n\n207.\n;;;----------------------------------------------------------------------------\n208.\n;;; New implementation of closures supporting %CLOSURE-SHIFT to\nwork\n209.\n(define closure-tag '(closure))\n210.\n(define (%closure . elts)\n211.\n(vector closure-tag 0 (apply vector elts)))\n212.\n(define (%closure-ref closure index)\n213.\n(closure-check-index closure index)\n214.\n(vector-ref (vector-ref closure 2)\ni. (+ index (vector-ref closure 1))))\n215.\n(define (%closure-set! closure index new)\n216.\n(closure-check-index closure index)\n217.\n(vector-set! (vector-ref closure 2)\ni. (+ index (vector-ref closure 1))\nii. new))\n218.\n(define (closure-check-index closure index)\n219.\n(let ((elts (vector-ref closure 2))\n220.\n(real-index (+ index (vector-ref closure 1))))\n221.\n(if (or (< real-index 0)\na. (>= real-index (vector-length elts)))\n222.\n(error \"CLOSURE: index out of range -- \" index))))\n223.\n(define (%closure-shift closure offset)\n224.\n;;\n225.\n;; Effectively returns a pointer into the middle of the closure.\n226.\n;; Note that the result shares structure with the input.\n227.\n;;\n228.\n(let ((new-offset (+ offset (vector-ref closure 1)))\n229.\n(elts (vector-ref closure 2)))\n230.\n(if (or (< new-offset 0)\na. (>= new-offset (vector-length elts)))\n231.\n(error \"CLOSURE-SHIFT: Offset out of range -- \" (list closure offset))\n232.\n(vector closure-tag new-offset elts))))\n233.\n(define (%closure? obj)\n234.\n(and (vector? obj)\n235.\n(= (vector-length obj) 3)\n236.\n(eq? (vector-ref obj 0) closure-tag)))\n\n237.\n;;;----------------------------------------------------------------------------\n238.\n;;; Extension to DESUGAR.SCM to catch assignments to FUNREC names\n239.\n;;; (which are illegal).\n240.\n(define-sugar 'funrec\n241.\n(lambda (exp)\n242.\n(define (lambda-exp? exp)\n243.\n(and (list? exp)\na. (>= (length exp) 3)\nb. (eq? (car exp) 'lambda)))\n244.\n(define (check-lambda exp)\n245.\n(if (not (lambda-exp? exp))\na. (error \"FUNREC: non-lambda expression\" exp)\nb. exp))\n246.\n(let ((bindings (second exp))\na. (body-exps (cddr exp)))\n247.\n(let ((names (map first bindings))\na. (lams (map (compose check-lambda second) bindings)))\n248.\n(let ((new-lams (map desugar lams))\na. (new-body (make-desugared-begin\n1. (map desugar body-exps))))\nb. (let ((illegal-mutables\ni. (set-intersection\nii. (list->set names)\niii. (map-union free-mutables\n1. (cons new-body new-lams)))))\nc. (if (not (set-empty? illegal-mutables))\ni. (error \"SYNTAX ERROR: FUNREC contains illegal assignments\"\nii. illegal-mutables)\niii. `(FUNREC ,(map (lambda (name lam) `(,name ,lam))\na. names\nb. new-lams)\n2. ,new-body))))))))\n249.\n;;;----------------------------------------------------------------------------\n250.\n;;; GLOBALIZE and ASSIGNMENT CONVERSION phases don't need\nto change.\n251.\n;;;----------------------------------------------------------------------------\n252.\n;;; CPS-CONVERSION phase:\n253.\n;;; Modify CPS to dispatch to CPS-FUNREC (below)\n254.\n(define (cps node mcont)\n255.\n;; MCONT here is a \"meta-continuation\" that maps a lettable value\n256.\n;; (i.e., syntactic class W) into a syntactic continuation.\n\n257.\n(cond\n258.\n((leaf-node? node) (mcont node))\n259.\n((lambda-node? node) (cps-lambda node mcont))\n260.\n((let-node? node) (cps-let node mcont))\n261.\n((application-node? node) (cps-application node mcont))\n262.\n((conditional-node? node) (cps-conditional node mcont))\n263.\n((assignment-node? node) (cps-assignment node mcont))\n264.\n((primop-node? node) (cps-primop node mcont))\n265.\n((syscall-node? node) (cps-syscall node mcont))\n266.\n((program-node? node) (cps-program node mcont))\n267.\n((funrec-node? node) (cps-funrec node mcont))\n268.\n;; ((begin-node? node) (cps-begin node mcont)) ; No longer supported\n269.\n(else (error \"CPS: Don't know how to handle node:\" node))))\n270.\n(define (cps-funrec node mcont)\n271.\n;; Patterned after CPS-PROGRAM:\n272.\n(cps-list (funrec-lambdas node)\na. (lambda (Vs) ;; Guaranteed to be Vs because all are lambdas\nb. (make-funrec (funrec-names node)\n1. Vs\n2. (cps (funrec-body node) mcont)))))\n\n273.\n;;;----------------------------------------------------------------------------\n274.\n;;; Extension to RUNTIME.SCM to make FUNREC desugar into a\nLETREC within Scheme\n275.\n; The local version\n276.\n(define-syntax define-syntax-global\n277.\n(macro (name expander)\n278.\n`(begin\n279.\n(define-syntax ,name ,expander)\n280.\n(syntax-table-define system-global-syntax-table ',name ,expander))))\n281.\n; The exported version\n282.\n(syntax-table-define system-global-syntax-table\n283.\n'define-syntax-global\n284.\n(macro (name expander)\n285.\n`(begin\n286.\n(define-syntax ,name ,expander)\n287.\n(syntax-table-define system-global-syntax-table ',name ,expander))))\n288.\n(define-syntax-global define-macro-global\n289.\n(macro (pattern . body)\n290.\n`(DEFINE-SYNTAX-GLOBAL ,(car pattern)\n291.\n(MACRO ,(cdr pattern) ,@body))))\n292.\n(define-macro-global (funrec bindings . body)\n293.\n`(LETREC ,bindings ,@body))\n\n294.\n;;;----------------------------------------------------------------------------\n295.\n;;; Names for compiler passes\n296.\n(define ->desugar (cascade initialize desugar abbreviate pp))\n297.\n(define ->globalize (cascade initialize desugar globals/wrap abbreviate\npp))\n298.\n(define ->assign (cascade initialize desugar globals/wrap assignment-\nconvert\n1. abbreviate pp))\n299.\n(define ->cps (cascade initialize desugar globals/wrap assignment-convert\ni. cps-convert abbreviate pp))\n300.\n;; Note: the following passes don't include an ORDER-CONVERT at the\nend,\n301.\n;; but they could.\n302.\n(define ->closures (cascade initialize desugar globals/wrap assignment-\nconvert\n1. cps-convert closurize abbreviate pp))\n303.\n(define ->closures/no-cps\n304.\n(cascade initialize desugar globals/wrap assignment-convert\na. closurize abbreviate pp))\n305.\n(define ->lift (cascade initialize desugar globals/wrap assignment-convert\n1. cps-convert closurize lift-convert\n2. abbreviate pp))\n306.\n(define ->data (cascade initialize desugar globals/wrap assignment-convert\n1. cps-convert closurize lift-convert\n2. data-convert data-unconvert abbreviate pp))\n\n307.\n;;;----------------------------------------------------------------------------\n308.\n;;; Code for the even/odd example:\n309.\n(define even/odd\n310.\n'(funrec ((even? (lambda (a) (if (= 0 a)\na. #t\nb. (odd? (- a 1)))))\nb. (odd? (lambda (b) (if (= 0 b)\na. #f\nb. (even? (- b 1))))))\nc. (even? 2)))"
    },
    {
      "category": "Exam",
      "title": "moduleexamples.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/352ab91885c4fd25b4920fa946e73d7f_moduleexamples.pdf",
      "content": "1. (define test1\n2. '(let ((m (module\na. (define twice (lambda (f)\n1. (lambda (x)\na. (f (f x))))))))\n3. (with (twice) m\na. (if ((twice not?) #f)\ni. ((twice (lambda (x) (+ 1 x))) 4)\nii. 5))))\n4. (define test2\n5. '(let ((m (module\na. (define a 4)\nb. (define b 5)))\nc. (b 6))\n6. (with (a) m\na. b)))"
    },
    {
      "category": "Resource",
      "title": "postfix.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/816c1833dc3d31f7c58cb0d634406a0a_postfix.pdf",
      "content": "1. ;; This is a denotational interpreter for PostFix\n2. ;; Built on Wed Sep 7 12:45:14 EDT 1994\n3. ;; Includes:\n4. ;; pf-syntax.scm\n5. ;; repl.scm\n6. ;; pf-den-interp.scm\n7. ;;---------------------------------------------------\n8. ;; pf-syntax.scm\n9. ;;;----------------------------------------------------------------------------\n10. ;;; PF-SYNTAX.SCM\n11. ;;;\n12. ;;; Postfix syntax and parsing\n13. ;;;----------------------------------------------------------------------------\n14. ;;;---------------------------------------------------------------------------\n15. ;;; Datatypes\n16. (define-datatype program\n17. ($prog (listof command)))\n18. (define-datatype command\n19. ($int int)\n20. ($seq (listof command))\n21. ($pop)\n22. ($swap)\n23. ($dup)\n24. ($sel)\n25. ($exec)\n26. ($arithop (-> (int int) int))\n27. ($relop (-> (int int) bool))\n28. )\n29. ;;;----------------------------------------------------------------------------\n30. ;;; Parsing\n31. (define (pf-program sexp)\n32. (match sexp\n33. ((list->sexp lst) ($prog (pf-sequence lst)))\n34. (_ (error \"Ill-formed program\"))))\n35. (define (pf-sequence lst)\n36. (map pf-command lst))\n37. (define (pf-command sexp)\n38. (match sexp\n\n39. ( (int->sexp n)\n($int n)\n)\n40. ( (list->sexp lst) ($seq (pf-sequence lst))\n)\n41. ( 'pop\n($pop)\n)\n42. ( 'swap\n($swap)\n)\n43. ( 'exec\n($exec)\n)\n44. ( 'sel\n($sel)\n)\n45. ( 'dup\n($dup)\n)\n46. ;; Below, arithop and relop operations are functions, not symbols!\n47. ( 'add\n($arithop +)\n)\n48. ( 'sub\n($arithop -)\n)\n49. ( 'mul\n($arithop *)\n)\n50. ( 'div\n($arithop quotient)\n) ; integer division\n51. ( 'lt\n($relop <)\n)\n52. ( 'eq\n($relop =)\n)\n53. ( 'gt\n($relop >)\n)\n54. ( _\n(error \"Unrecognized command\"\ni. sexp)\n)\n55. ))\n\n56. ;;---------------------------------------------------\n57. ;; repl.scm\n58. (define (make-repl evaluator prompt parser unparser)\n59. (lambda ()\n60. (let loop ()\n61. (display \"\\n\\n\")\n62. (display prompt)\n63. (display \" \")\n64. (let ((sexp (read)))\n65. (if (eq? sexp 'quit)\na. (display \"\\nGoodbye!\\n\")\nb. (begin\nc. (display \"\\n\")\nd. (display (unparser (evaluator (parser sexp))))\ne. (loop)))))))\n\n66. ;;---------------------------------------------------\n67. ;; pf-den-interp.scm\n68. ;;;----------------------------------------------------------------------------\n69. ;;; PF-DEN-INTERP.SCM\n70. ;;;\n71. ;;; A PostFix interpreter based on the denotational semantics for PostFix.\n72. ;;; This is a \"curried version\" in which stacks are passed in a curried\n73. ;;; style. This corresponds directly to the denotational semantics.\n74. ;;; Uses Scheme's ERROR instead of error-stack to model errors.\n75. ;;;\n76. ;;; EXERCISES:\n77. ;;; * Model errors explicitly (don't forget divide-by-zero).\n78. ;;; * Write in terms of WITH-INT&STACK; WITH-ERROR\n79. ;;; * Add DUP.\n80. ;;; * Modify so that EVAL-COMMAND and EVAL-COMMANDS are take stack\nin\n81. ;;; uncurried fashion.\n82. ;;;\n83. ;;;----------------------------------------------------------------------------\n84. ;;;---------------------------------------------------------------------------\n85. ;;; Evaluation\n86. (define-datatype den-val\n87. (int->den-val int)\n88. (xform->den-val (-> (stack) stack)))\n89. ;; eval-program: (-> (program) den-val)\n90. (define (eval-program pgm)\n91. (match pgm\n92. (($prog seq) (top ((eval-commands seq) (empty-stack))))\n93. ))\n94. ;; eval-commands: (-> ((listof command)) (-> (stack) stack))\n95. (define (eval-commands seq)\n96. (match seq\n97. ((null) identity)\n98. ((cons com coms) (o (eval-commands coms) (eval-command com)))\n99. ))\n100.\n;; eval-command: (-> (command) (-> (stack) stack))\n101.\n(define (eval-command cmd)\n102.\n(match cmd\n103.\n( ($int i)\n(push (int->den-val i))\n)\n104.\n( ($seq s)\n(push (xform->den-val (eval-commands s)))\n)\n\n105.\n( ($pop)\npop\n)\n106.\n( ($swap)\n(with-value\ni. (lambda (v1)\nii. (with-value\n1. (lambda (v2)\n2. (o (push v2) (push v1))))))\n)\n107.\n( ($sel)\n(with-value\ni. (lambda (else)\nii. (with-value\n1. (lambda (then)\n2. (with-integer\n3. (lambda (test)\n4. (if (= test 0)\na. (push else)\nb. (push then))))))))\n)\n108.\n( ($exec)\n(with-transform identity)\n)\n109.\n( ($arithop op) (with-integer\ni. (lambda (i1)\nii. (with-integer\n1. (lambda (i2)\n2. (push (int->den-val (op i2 i1)))))))\n)\n110.\n( ($relop op) (with-integer\ni. (lambda (i1)\nii. (with-integer\n1. (lambda (i2)\n2. (push (int->den-val (if (op i2 i1) 1 0))))))) )\n111.\n))\n112.\n;;;-------------------------------------------------------------------------\n113.\n;;; Auxiliary Functions\n114.\n(define (empty-stack) '())\n115.\n(define (push val)\n116.\n(lambda (stack)\n117.\n(cons val stack)))\n118.\n(define (with-value proc)\n119.\n(lambda (stack)\n120.\n(match stack\n121.\n((null) (error \"Empty stack\"))\n122.\n((cons v s) ((proc v) s)))))\n123.\n(define top (with-value (lambda (top) (lambda (rest) top))))\n124.\n(define pop (with-value (lambda (top) (lambda (rest) rest))))\n\n125.\n(define (with-integer proc)\n126.\n(with-value\n127.\n(lambda (v)\n128.\n(match v\n129.\n((int->den-val i) (proc i))\n130.\n(_ (error \"Transform where integer expected\"))))))\n131.\n(define (with-transform proc)\n132.\n(with-value\n133.\n(lambda (v)\n134.\n(match v\n135.\n((xform->den-val t) (proc t))\n136.\n(_ (error \"Integer where transform expected\"))))))\n137.\n(define (identity x) x)\n138.\n(define (o f g)\n139.\n;; Function composition\n140.\n(lambda (x)\n141.\n(f (g x))))\n142.\n;;;---------------------------------------------------------------------------\n143.\n;;; Top-level\n144.\n(define (unparse-value value)\n145.\n(match value\n146.\n((int->den-val i) (int->sexp i))\n147.\n((xform->den-val s) 'executable)\n148.\n))\n149.\n(define pf-den-repl (make-repl eval-program\na. 'pf-den>\nb. pf-program\nc. unparse-value))"
    },
    {
      "category": "Resource",
      "title": "recon.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/bcf10eb6e226b49416cf63a46957bdec_recon.pdf",
      "content": "1. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n2. ;;;\n3. ;;; recon.scm: TYPE RECONSTRUCTOR FOR Scheme/R\n4. ;;;\n5. ;;; To run this code, first load Scheme+, then this file.\n6. ;;;\n7. ;;; Evaluate\n8. ;;;\n9. ;;; (recon <sexp>)\n10. ;;;\n11. ;;; to type-reconstruct the Scheme/R expression <sexp>\n12. ;;;\n13. ;;;\n14. ;;;----------------------------------------------------------------------------\n15. ;;; Magic for handling unit. This should really be in a separate file, or\n16. ;;; be part of Scheme+.\n17. (define-structure (unit-obj (print-procedure\n1. (lambda (state struct)\na. (unparse-string state \"#u\")))))\n18. ;; THE-UNIT is the unique instance of the UNIT-OBJ structure\n19. (define the-unit (make-unit-obj))\n20. (define (unit? obj) (eq? obj the-unit))\n21. ;;; Changing parser to handle #u\n22. (define parse-object/unit\n23. (let ((discard-char (access discard-char\n1. (->environment (find-package '(runtime parser))))))\n24. (lambda ()\n25. (discard-char)\n26. the-unit)))\n27. (parser-table/set-entry! system-global-parser-table\n1. '(\"#u\" \"#U\")\n2. parse-object/unit)\n28. ;;; Constructors for handling UNIT\n29. (define unit->sexp\n30. (make-constructor\n31. (lambda () #u)\n32. (lambda (sexp succ fail)\n\n33. (if (unit? sexp)\na. (succ)\nb. (fail)))))\n34. (define a-unit unit->sexp)\n35. ;;;----------------------------------------------------------------------------\n36. ;;; SYM-SEXP is a synonym for SYMBOL->SEXP (and should replace it in\n37. ;;; future versions of Scheme+)\n38. (define sym->sexp (make-sexp-constructor 'sym symbol?))\n39. ;;;----------------------------------------------------------------------------\n40. ;;; CELLS in Scheme\n41. (define cell-tag (list '*cell*))\n42. (define (cell val) (list cell-tag val))\n43. (define (cell? x) (and (list? x) (= (length x) 2) (eq? (car x) cell-tag)))\n44. (define (^ x) (if (cell? x) (cadr x) (error \"^: not a cell \" x)))\n45. (define (:= x y) (if (cell? x) (begin (set-car! (cdr x) y) #u)\ni. (error \"^: not a cell \" x)))\n46. ;;;----------------------------------------------------------------------------\n47. ;;; DATATYPES\n48. ;;; Expressions\n49. (define-datatype exp\n; E ::=\n50. (unit->exp)\n;\nUnit\n51. (boolean->exp bool)\n;\n| Bool\n52. (integer->exp int)\n;\n| Int\n53. (string->exp string)\n;\n| String\n54. (symbol->exp sym)\n;\n| (symbol Sym)\n55. (variable->exp sym)\n;\n| I\n56. (lambda->exp (listof sym) exp)\n;\n| (lambda (I*) E)\n57. (call->exp exp (listof exp))\n;\n| (E0 E*)\n58. (if->exp exp exp exp)\n;\n| (if E1 E2 E3)\n59. (primop->exp primop (listof exp))\n;\n| (primop O E*)\n60. (let->exp (listof definition) exp)\n;\n| (let ((I E)*) E0)\n61. (letrec->exp (listof definition) exp)\n;\n| (letrec ((I E)*) E0)\n62. (set!->exp sym exp)\n;\n| (set! I E)\n63. (begin->exp exp exp)\n;\n| (begin E E)\n64. ;; **MODULES**\n65. (module->exp (listof definition))\n;\n| (module (define I E)*)\n66. (with->exp (listof sym) exp exp)\n;\n| (with (I*) E1 E2)\n\n67. ;; **MODULES**\n68. )\n69. (define-datatype definition\n70. (make-definition sym exp))\n71. (define (definition-name d)\n72. (match d\n73. ((make-definition name value) name)))\n74. (define (definition-value d)\n75. (match d\n76. ((make-definition name value) value)))\n77. ;;; Types\n78. (define-datatype type\n; (I E)\n79. (tvariable->type tvariable)\n; type variable\n80. (base->type sym)\n; (unit, bool, int, string, symbol)\n81. (compound->type sym (listof type))\n; ->, list-of, etc.\n82. (unknown->type)\n; placeholder for unconstrained tvars\n83. ;; **MODULES**\n84. (moduleof->type (listof sym) (listof type)) ; (moduleof (val I T)*)\n85. ;; **MODULES**\n86. )\n87. (define unit-type (base->type 'unit))\n88. (define boolean-type (base->type 'bool))\n89. (define integer-type (base->type 'int))\n90. (define string-type (base->type 'string))\n91. (define symbol-type (base->type 'sym))\n92. (define same-constructor? eq?)\n93. ;; **MODULES**\n94. (define (same-field-names? names1 names2)\n95. (if (null? names1)\n96. (null? names2)\n97. (if (null? names2)\na. #f\nb. (and (eq? (car names1) (car names2))\ni. (same-field-names? (cdr names1) (cdr names2))))))\n98. ;; **MODULES**\n99. (define (make-arrow-type arg-types body-type)\n\n100.\n(compound->type arrow-constructor\ni. (cons body-type arg-types)))\n101.\n(define arrow-constructor '->)\n102.\n(define same-name? eq?)\n103.\n;;; Type schemas\n104.\n(define-datatype tvar-or-schema\n105.\n(tvar->tvar-or-schema tvariable)\n106.\n(schema->tvar-or-schema schema))\n107.\n(define-datatype schema\n108.\n(make-schema (listof tvariable) type))\n109.\n(define (schema-generics s)\n110.\n(match s\n111.\n((make-schema generics typ) generics)))\n112.\n(define (schema-type s)\n113.\n(match s\n114.\n((make-schema generics typ) typ)))\n\n115.\n;;;----------------------------------------------------------------------------\n116.\n;;; TYPE RECONSTRUCTION\n117.\n(define (reconstruct exp tenv)\n118.\n(match exp\n119.\n((unit->exp)\nunit-type)\n120.\n((boolean->exp _)\nboolean-type)\n121.\n((integer->exp _)\ninteger-type)\n122.\n((string->exp _)\nstring-type)\n123.\n((symbol->exp _)\nsymbol-type)\n124.\n((variable->exp var)\n(reconstruct-variable var tenv))\n125.\n((if->exp test con alt)\n(reconstruct-if test con alt tenv))\n126.\n((primop->exp primop args) (reconstruct-primop primop args tenv))\n127.\n((lambda->exp formals body) (reconstruct-lambda formals body tenv))\n128.\n((call->exp op args)\n(reconstruct-call op args tenv))\n129.\n((let->exp defs body)\n(reconstruct-let defs body tenv))\n130.\n((letrec->exp defs body) (reconstruct-letrec defs body tenv))\n131.\n((set!->exp id exp)\n(reconstruct-set! id exp tenv))\n132.\n((begin->exp exp1 exp2)\n(reconstruct-begin exp1 exp2 tenv))\n133.\n;; **MODULES**\n134.\n((module->exp defs)\n(reconstruct-module defs tenv))\n; ***\n135.\n((with->exp vars mod body) (reconstruct-with vars mod body tenv)) ; ***\n136.\n;; **MODULES**\n137.\n))\n138.\n(define (reconstruct-variable var tenv)\n139.\n(let ((tvar-or-schema (tlookup tenv var)))\n140.\n(match tvar-or-schema\n141.\n((tvar->tvar-or-schema tvar)\n142.\n(tvariable->type tvar))\n143.\n((schema->tvar-or-schema schema)\n144.\n(instantiate-schema schema)))))\n145.\n(define (reconstruct-if test con alt tenv)\n146.\n(begin (unify! (reconstruct test tenv)\ni. boolean-type)\nb. (let ((con-type (reconstruct con tenv))\ni. (alt-type (reconstruct alt tenv)))\nc. (begin (unify! con-type alt-type)\ni. con-type))))\n147.\n(define (reconstruct-lambda vars body tenv)\n148.\n(let ((new-tvars (map new-tvariable vars)))\n149.\n(make-arrow-type\n150.\n(map tvariable->type new-tvars)\n\n151.\n(reconstruct body\ni. (extend-by-tvariables tenv vars new-tvars)))))\n152.\n(define (reconstruct-call op args tenv)\n153.\n(let ((arg-types (map (lambda (arg) (reconstruct arg tenv))\n1. args))\n154.\n(result-type (tvariable->type (new-tvariable 'result))))\n155.\n(begin (unify! (reconstruct op tenv)\ni. (make-arrow-type arg-types result-type))\nb. result-type)))\n156.\n(define (reconstruct-primop op args tenv)\n157.\n(let ((arg-types (map (lambda (arg) (reconstruct arg tenv))\n1. args))\n158.\n(result-type (tvariable->type (new-tvariable 'result))))\n159.\n;; Get the type of the operator from the standard type env:\n160.\n(begin (unify! (reconstruct-variable op standard-type-environment)\ni. (make-arrow-type arg-types result-type))\nb. result-type)))\n161.\n(define (reconstruct-let defs body tenv)\n162.\n(reconstruct body\ni. (extend-by-schemas\nii. tenv\niii. (map definition-name defs)\niv. (map (lambda (def)\nv. (compute-schema\n1. (reconstruct (definition-value def) tenv)\n2. tenv))\nvi. defs))))\n163.\n(define (reconstruct-letrec defs body tenv)\n164.\n(let ((names (map definition-name defs)))\n165.\n(let ((tvars (map new-tvariable names)))\n166.\n(let ((dummy-tenv (extend-by-tvariables tenv names tvars)))\n167.\n(let ((types (map (lambda (def)\n1. (reconstruct (definition-value def) dummy-tenv))\n2. defs)))\nb. (begin (for-each-2 unify!\n1. (map tvariable->type tvars)\n2. types)\nii. (reconstruct body\n1. (extend-by-schemas\na. tenv\nb. names\nc. (map (lambda (type)\n\nd. (compute-schema type tenv))\ne. types)))))))))\n168.\n(define (for-each-2 proc lst1 lst2)\n169.\n(if (null? lst1)\n170.\n#u\n171.\n(begin\n172.\n(proc (car lst1) (car lst2))\n173.\n(for-each-2 proc (cdr lst1) (cdr lst2)))))\n174.\n;;; Note: the use of UNIFY!-LIST rather than FOR-EACH-2 fails to\n175.\n;;; correctly type (or find a type error in) the following example:\n176.\n;;; (recon '(letrec ((a (lambda () 3))\n177.\n;;;\n(b (if (a) 1 2)))\n178.\n;;;\n4))\n179.\n(define (reconstruct-set! id exp tenv)\n180.\n(begin (unify! (reconstruct-variable id tenv)\ni. (reconstruct exp tenv))\nb. unit-type))\n181.\n(define (reconstruct-begin exp1 exp2 tenv)\n182.\n;; Be sure to check type-safety of 1st expression:\n183.\n(begin (reconstruct exp1 tenv)\na. (reconstruct exp2 tenv)))\n\n184.\n;;;----------------------------------------------------------------------------\n185.\n;;; TYPE SCHEMAS\n186.\n(define (compute-schema type tenv) ;Function GEN from handout\n187.\n(make-schema (generic-tvariables type tenv)\ni. type))\n188.\n; NOTE: generic-tvariables looks not only at tvariables in the\n189.\n; given type, but also at tvariables in the leaves of\n190.\n; the fully unwound version of the given type. This interacts with\n191.\n; a similar unwinding at instantiation time to appropriately handle\n192.\n; generalization. There is potential confusion in that the returned\n193.\n; list may contain types that are not manifestly in TYPE but are in\n194.\n; the fully unwound tree associated with it.\n195.\n(define (generic-tvariables type tenv) ;Compute FTV(type) - FTE(tenv)\n196.\n(match (prune type)\n197.\n((tvariable->type tvar)\n198.\n(if (generic-tvariable? tvar tenv)\na. (list tvar)\nb. (null)))\n199.\n((compound->type _ operands)\n200.\n(letrec ((loop (lambda (ops tvars)\ni. (if (null? ops)\n1. tvars\n2. (loop (cdr ops)\na. (union (generic-tvariables (car ops) tenv)\ni. tvars))))))\n201.\n(loop operands (null))))\n202.\n;; **MODULES**\n203.\n((moduleof->type _ fields)\n204.\n(letrec ((loop (lambda (flds tvars)\ni. (if (null? flds)\n1. tvars\n2. (loop (cdr flds)\na. (union (generic-tvariables (car flds) tenv)\ni. tvars))))))\n205.\n(loop fields (null))))\n206.\n;; **MODULES**\n207.\n((base->type _) (null))\n208.\n(_ (error \"This shouldn't happen!\" (unparse-type type)))))\n209.\n(define (union l1 l2)\n210.\n(cond ((null? l1) l2)\n\n211.\n((null? l2) l1)\n212.\n((in-tvariable-list? (car l1) l2) (union (cdr l1) l2))\n213.\n(else (cons (car l1) (union (cdr l1) l2)))))\n214.\n(define (in-tvariable-list? tvar tvar-list)\n215.\n(if (null? tvar-list)\n216.\n#f\n217.\n(if (same-tvariable? tvar (car tvar-list))\na. #t\nb. (in-tvariable-list? tvar (cdr tvar-list)))))\n218.\n; Instantiate a type schema on a fresh set of type variables.\n219.\n; [This corresponds to Cardelli's \"FreshType\".]\n220.\n(define (instantiate-schema schema)\n221.\n(substitute-into-type\n222.\n(map (lambda (g)\na. (tvariable->type (new-tvariable (tvariable-name g))))\n223.\n(schema-generics schema))\n224.\n(schema-generics schema)\n225.\n(schema-type schema)))\n226.\n; [The following corresponds to Cardelli's \"Fresh\"; note the call to prune.]\n227.\n; Note that this unwinds TYPE out to the leaves when doing the\nsubstitution;\n228.\n; this guarantees that we don't miss any substitutions because type itself\n229.\n; isn't fully unwound.\n230.\n(define (substitute-into-type types tvars type)\n231.\n(let ((type (prune type)))\n232.\n(match type\n233.\n((tvariable->type tvar)\n234.\n(letrec ((loop (lambda (ts tvars)\n1. (if (null? ts)\n2. type\n3. (if (same-tvariable? tvar (car tvars))\na. (car ts)\nb. (loop (cdr ts) (cdr tvars)))))))\nb. (loop types tvars)))\n235.\n((base->type _) type)\n236.\n((compound->type c args)\n237.\n(compound->type c (map (lambda (arg)\na. (substitute-into-type types tvars arg))\n2. args)))\n238.\n((moduleof->type names args)\n\n239.\n(moduleof->type names (map (lambda (arg)\na. (substitute-into-type types tvars arg))\nb. args)))\n240.\n(_ (error \"This shouldn't happen\" (unparse-type type))))))\n\n241.\n;;;----------------------------------------------------------------------------\n242.\n;;; TYPE ENVIRONMENTS.\n243.\n;\n244.\n; Environments can be extended in either of two ways:\n245.\n; extend-by-tvariables should be used by lambda and letrec to bind\n246.\n;\nvariables to type variables\n247.\n; extend-by-schemas should be used by let and letrec to bind variables\n248.\n;\nto type schemas\n249.\n;\n250.\n; Once constructed, there are two operations one can perform on a\n251.\n; type environment:\n252.\n; tlookup : tenv * var -> (tvar + schema)\n253.\n;\ndoes the usual thing.\n254.\n; generic-tvariable? : tvar * tenv -> bool\n255.\n;\nreturns true iff tvar is not free in the type of any var bound in tenv.\n256.\n(define-datatype type-environment\n257.\n(make-type-env tlookup-proc generic-tvariable?-proc))\n258.\n(define (tenv-lookup te)\n259.\n(match te\n260.\n((make-type-env lookup generic?) lookup)))\n261.\n(define (tenv-generic? te)\n262.\n(match te\n263.\n((make-type-env lookup generic?) generic?)))\n264.\n(define (extend-by-tvariables outer-tenv vars tvars)\n265.\n(extend-tenv outer-tenv\ni. vars\nii. (map tvar->tvar-or-schema tvars)\niii. (lambda (tvar)\niv. ;; tvar is an unconstrained type variable.\nv. (letrec ((loop (lambda (tvars)\na. (if (null? tvars)\nb. (generic-tvariable? tvar outer-tenv)\nc. (if (occurs-in-type?\ni. tvar\nii. (tvariable->type (car tvars)))\niii. ;; (same-tvariable? tvar (car tvars))\niv. #f\nv. (loop (cdr tvars)))))))\nvi. (loop tvars)))))\n266.\n(define (extend-by-schemas outer-tenv vars schemas)\n\n267.\n(extend-tenv outer-tenv\ni. vars\nii. (map schema->tvar-or-schema schemas)\niii. (lambda (tvar)\niv. (generic-tvariable? tvar outer-tenv))))\n268.\n;Students' code should not call this\n269.\n(define (extend-tenv outer-tenv vars typas generic-tvariable?-proc)\n270.\n(make-type-env\n271.\n(lambda (var)\n272.\n(letrec ((loop (lambda (vars typas)\ni. (if (null? vars)\n1. (tlookup outer-tenv var)\n2. (if (same-variable? var (car vars))\n3. (car typas)\n4. (loop (cdr vars) (cdr typas)))))))\n273.\n(loop vars typas)))\n274.\ngeneric-tvariable?-proc))\n275.\n(define empty-type-environment\n276.\n(make-type-env\n277.\n(lambda (var) (error \"Unbound variable: \" (sym->sexp var)))\n278.\n(lambda (tvar) #t)))\n279.\n(define (tlookup tenv var)\n280.\n((tenv-lookup tenv) var))\n281.\n(define same-variable? eq?)\n282.\n(define (generic-tvariable? tvar tenv)\n283.\n((tenv-generic? tenv) tvar))\n284.\n; Proving the correctness of this implementation of GENERIC-\nTVARIABLE?\n285.\n; is tricky.\n\n286.\n;;;----------------------------------------------------------------------------\n287.\n;;; TYPE VARIABLES\n288.\n; A type variable is implemented as a record that contains a cell. The\n289.\n; global substitution is realized as the collective contents of the\n290.\n; cells for all type variables.\n291.\n(define-datatype tvariable\n292.\n(make-tvariable sym int (cellof type)))\n; id gennum cell\n293.\n(define (tvariable-name tvar)\n294.\n(match tvar\n295.\n((make-tvariable name _ _) name)))\n296.\n(define (tvariable-uid tvar)\n297.\n(match tvar\n298.\n((make-tvariable _ uid _) uid)))\n299.\n(define (tvariable-cell tvar)\n300.\n(match tvar\n301.\n((make-tvariable _ _ c) c)))\n302.\n(define tvariable-counter (cell 0))\n303.\n(define (reset-tvariable-counter!)\n304.\n(:= tvariable-counter 0))\n305.\n(define (new-tvariable id)\n306.\n(begin (:= tvariable-counter (+ (^ tvariable-counter) 1))\na. (make-tvariable id (^ tvariable-counter) (cell unknown-type))))\n307.\n(define (tvariable-binding tvar)\n308.\n(^ (tvariable-cell tvar)))\n309.\n(define (extend-substitution! tvar binding)\n310.\n(begin (:= (tvariable-cell tvar) binding)\na. #t))\n311.\n(define (same-tvariable? tvar1 tvar2)\n312.\n(= (tvariable-uid tvar1) (tvariable-uid tvar2)))\n313.\n(define unknown-type (unknown->type))\n314.\n(define (tvariable->symbol tvar)\n315.\n(string->symbol\n\n316.\n(string-append \"?\" (symbol->string (tvariable-name tvar))\ni. \"-\" (number->string (tvariable-uid tvar)))))\n\n317.\n;;;----------------------------------------------------------------------------\n318.\n;;; UNIFICATION\n319.\n;;;\n320.\n;;; Has side effects.\n321.\n;;; Generates an error if there is no unification.\n322.\n(define (unify! type1 type2)\n323.\n(if (unify!-internal type1 type2)\n324.\n#u\n325.\n(error \"Type clash: \"\na. (unparse-type type1) (unparse-type type2))))\n326.\n(define (unify!-internal type1 type2)\n327.\n(let ((type1 (prune type1))\n328.\n(type2 (prune type2)))\n329.\n;; Now if a type is a variable, it will be unbound\n330.\n(match type1\n331.\n((tvariable->type v1)\n332.\n(match type2\na. ((tvariable->type v2)\nb. (if (same-tvariable? v1 v2)\nc. #t\nd. (extend-substitution! v1 type2)))\ne. (_\nf. (if (occurs-in-type? v1 type2)\ng. #f\n;Circularity\n\nh. (extend-substitution! v1 type2)))))\n333.\n((base->type c1)\n334.\n(match type2\na. ((tvariable->type v2)\nb. (extend-substitution! v2 type1))\nc. ((base->type c2)\nd. (same-name? c1 c2))\ne. (_ #f)))\n335.\n((compound->type con1 args1)\n336.\n(match type2\na. ((tvariable->type v2)\nb. (if (occurs-in-type? v2 type1)\nc. #f\nd. (extend-substitution! v2 type1)))\ne. ((compound->type con2 args2)\nf. (if (same-constructor? con1 con2)\ng. (unify!-list args1 args2)\nh. #f))\ni. (_ #f)))\n\n337.\n((moduleof->type names1 args1)\n338.\n(match type2\na. ((tvariable->type v2)\nb. (if (occurs-in-type? v2 type1)\nc. #f\nd. (extend-substitution! v2 type1)))\ne. ((moduleof->type names2 args2)\nf. (if (same-field-names? names1 names2)\ng. (unify!-list args1 args2)\nh. #f))\ni. (_ #f))))))\n339.\n(define (unify!-list types1 types2)\n340.\n(if (null? types1)\n341.\n(null? types2)\n342.\n(if (null? types2)\na. #f\nb. (if (unify!-internal (car types1) (car types2))\nc. (unify!-list (cdr types1) (cdr types2))\nd. #f))))\n343.\n; Chase substitutions of tvariables until either a non-tvariable or an\n344.\n; unbound tvariable is found.\n345.\n(define (prune type)\n346.\n(match type\n347.\n((tvariable->type tvar)\n348.\n(match (tvariable-binding tvar)\n349.\n((unknown->type) type)\n350.\n(other-type (prune other-type))))\n351.\n(_ type)))\n352.\n; Occurs check: prevent circular substitutions.\n353.\n(define (occurs-in-type? tvar type)\n354.\n(match (prune type)\n355.\n((tvariable->type tvar2)\n356.\n;; prune has guaranteed that tvar2 is unbound\n357.\n(same-tvariable? tvar tvar2))\n358.\n((compound->type c args)\n359.\n(letrec ((loop (lambda (args)\ni. (if (null? args)\n1. #f\n2. (or (occurs-in-type? tvar (car args))\n3. (loop (cdr args)))))))\n360.\n(loop args)))\n\n361.\n((moduleof->type names args)\n362.\n(letrec ((loop (lambda (args)\ni. (if (null? args)\n1. #f\n2. (or (occurs-in-type? tvar (car args))\n3. (loop (cdr args)))))))\n363.\n(loop args)))\n364.\n(_ #f)))\n\n365.\n;;;----------------------------------------------------------------------------\n366.\n;;; PARSING/UNPARSING -- old version with non-optimal strategy\n367.\n; Parse a definition\n368.\n(define (parse-definition sexp)\n369.\n(match sexp\n370.\n;; Allow Scheme-style definitions ...\n371.\n(`(define (,name ,@args) ,body)\n372.\n(make-definition (parse-formal name)\ni. (parse `(lambda ,args ,body))))\n373.\n(`(define ,name ,value)\n374.\n(make-definition (parse-formal name) (parse value)))\n375.\n(_ (error \"Invalid definition: \" sexp))))\n376.\n(define (parse-formal sexp)\n377.\n(match sexp\n378.\n((sym->sexp name)\n379.\n(if ((member? eq?) name all-keywords)\na. (error \"Attempt to use reserved word as variable name\" sexp)\nb. name))\n380.\n(_ (error \"Invalid variable name: \" sexp))))\n381.\n(define (parse-call operator operands)\n382.\n(call->exp (parse operator)\na. (map parse operands)))\n383.\n(define (parse-binding-spec bspec)\n384.\n(match bspec\n385.\n(`(,name ,value) (make-definition (parse-formal name) (parse value)))\n386.\n(_ (error \"Invalid binding specifier: \" bspec))))\n387.\n(define (syntax-error sexp)\n388.\n(error \"Invalid expression syntax: \" sexp))\n389.\n; Parse a single expression\n390.\n(define (parse sexp)\n391.\n(match sexp\n392.\n((unit->sexp)\n393.\n((bool->sexp b)\n394.\n((int->sexp n)\n395.\n((sym->sexp sym)\n396.\n((string->sexp n)\n; sexp -> exp\n(unit->exp))\n(boolean->exp b))\n(integer->exp n))\n(variable->exp sym))\n(string->exp n))\n\n397.\n(`(,(sym->sexp head) ,@_) ((parser-for-keyword head) sexp))\n398.\n;; Procedure call is the default\n399.\n(`(,operator ,@operands) (parse-call operator operands))\n400.\n(_ (error \"Unrecognized expression \" sexp))))\n401.\n(define-datatype parser-table\n402.\n(make-parser-table (listof sym)\ni. (-> (sym) (-> (sexp) exp))))\n403.\n; Expressions of the form (reserved-word ...)\n404.\n(define keyword-table\n405.\n(letrec\n406.\n((keywords (cell (null)))\n407.\n(lookup (cell (lambda (head)\ni. (lambda (sexp)\n1. ;; Procedure call is the default\n2. (match sexp\n3. (`(,operator ,@operands)\n4. (parse-call operator operands))\n5. (_ (error \"KEYWORD TABLE: This shouldn't happen!\"\na. )))))))\n408.\n;; DEFINE-KEYWORD is a function that defines a reserved word,\n409.\n;; associating it with a function that can parse the named construct.\n410.\n(define-keyword\na. (lambda (keyword parser)\nb. (let ((current-lookup (^ lookup)))\nc. (begin (:= lookup\n1. (lambda (head)\n2. (if (eq? head keyword)\n3. parser\n4. (current-lookup head))))\nii. (:= keywords\n1. (cons keyword (^ keywords)))\niii. keyword)))))\n411.\n(begin\n412.\n;; List of parsing functions.\n413.\n(define-keyword 'quote\n; (quote Name)\n414.\n(lambda (sexp)\na. (match sexp\nb. (`(quote ,(sym->sexp name))\nc. (symbol->exp name))\nd. (_ (syntax-error sexp)))))\n\n415.\n(define-keyword 'lambda\n; (lambda (I*) E)\n416.\n(lambda (sexp)\na. (match sexp\nb. (`(lambda (,@formals) ,body)\nc. (lambda->exp (map parse-formal formals)\n1. (parse body)))\nd. (_ (syntax-error sexp)))))\n417.\n(define-keyword 'if\n; (if E1 E2 E3)\n418.\n(lambda (sexp)\na. (match sexp\nb. (`(if ,test ,con ,alt)\nc. (if->exp (parse test)\ni. (parse con)\nii. (parse alt)))\nd. (_ (syntax-error sexp)))))\n419.\n(define-keyword 'primop\n; (primop O E*)\n420.\n(lambda (sexp)\na. (match sexp\nb. (`(primop ,op ,@args)\nc. ;; Assume valid primop -- type reconstruction will verify\nd. ;; number of args.\ne. (primop->exp op (map parse args)))\nf. (_ (syntax-error sexp)))))\n421.\n(define-keyword 'let ; (let ((I E)*) E0)\n422.\n(lambda (sexp)\na. (match sexp\nb. (`(let (,@bspecs) ,body)\nc. (let->exp\nd. (map parse-binding-spec bspecs)\ne. (parse body)))\nf. (_ (syntax-error sexp)))))\n423.\n(define-keyword 'letrec\n; (letrec ((I E)*) E0)\n424.\n(lambda (sexp)\na. (match sexp\nb. (`(letrec (,@bspecs) ,body)\nc. (letrec->exp\nd. (map parse-binding-spec bspecs)\ne. (parse body)))\nf. (_ (syntax-error sexp)))))\n425.\n(define-keyword 'set! ; (set! I E)\n\n426.\n(lambda (sexp)\na. (match sexp\nb. (`(SET! ,(sym->sexp id) ,sexp)\nc. (set!->exp id (parse sexp)))\nd. (_ (syntax-error sexp)))))\n427.\n(define-keyword 'begin\n; (begin E1 E2) + sugars\n428.\n(lambda (sexp)\na. (match sexp\nb. (`(BEGIN) (unit->exp))\nc. (`(BEGIN ,sexp) (parse sexp))\nd. (`(BEGIN ,sexp1 ,sexp2) (begin->exp (parse sexp1) (parse sexp2)))\ne. (`(BEGIN ,sexp1 ,sexp2 ,@rest)\nf. (begin->exp (parse sexp1) (parse `(BEGIN ,sexp2 ,@rest))))\ng. (_ (syntax-error sexp)))))\n429.\n;; Sugar\n430.\n;; (and)\n==> #t\n431.\n;; (and E)\n==> E\n432.\n;; (and E0 E+) ==> (if E0 (and E+) #f)\n433.\n;;\n434.\n(define-keyword 'and\n435.\n(lambda (sexp)\na. (match sexp\nb. (`(and ,@exp-list)\nc. (parse (letrec ((recur (lambda (exps)\na. (match exps\ni. ((null)\n`#t)\nii. (`(,exp)\nexp)\niii. ((cons first rest)\niv. `(if ,first ,(recur rest) #f))))))\nii. (recur exp-list))))\nd. (_ (syntax-error sexp)))))\n436.\n;; (or)\n==> #f\n437.\n;; (or E)\n==> E\n438.\n;; (or E0 E+) ==> (if E0 #t (or E+))\n439.\n;;\n440.\n(define-keyword 'or\n441.\n(lambda (sexp)\na. (match sexp\nb. (`(or ,@exp-list)\nc. (parse (letrec ((recur (lambda (exps)\n\na. (match exps\ni. ((null)\n`#f)\nii. (`(,exp)\nexp)\niii. ((cons first rest)\niv. `(if ,first #t ,(recur rest)))))))\nii. (recur exp-list))))\nd. (_ (syntax-error sexp)))))\n442.\n;; (cond (E E)* (else E))\n443.\n(define-keyword 'cond\n444.\n(lambda (sexp)\na. (match sexp\nb. (`(cond) (syntax-error sexp))\nc. (`(cond (else ,default))\nd. (parse default))\ne. (`(cond (,predicate ,consequent) ,@clauses)\nf. (parse `(if ,predicate\n1. ,consequent\n2. (cond ,@clauses))))\ng. )))\n445.\n;; (list E*)\n446.\n;;\n447.\n(define-keyword 'list\n448.\n(lambda (sexp)\na. (match sexp\nb. (`(list ,@exp-list)\nc. (parse (letrec ((recur (lambda (exps)\na. (match exps\ni. ((null) `(null))\nii. ((cons first rest)\niii. `(cons ,first ,(recur rest)))))))\nii. (recur exp-list))))\nd. (_ (syntax-error sexp)))))\n449.\n;; Module stuff\n450.\n(define-keyword 'module\n; (module (define I E)*)\n451.\n(lambda (sexp)\na. (match sexp\nb. (`(module ,@fspecs)\nc. (module->exp\nd. (map parse-definition fspecs)))\ne. (_ (syntax-error sexp)))))\n452.\n(define-keyword 'with ; (with (I*) E1 E2)\n\n453.\n(lambda (sexp)\na. (match sexp\nb. (`(with (,@formals) ,mod ,body)\nc. (with->exp (map parse-formal formals)\n1. (parse mod)\n2. (parse body)))\nd. (_ (syntax-error sexp)))))\n454.\n;; Now return the whole parser table\n455.\n(make-parser-table (^ keywords)\n1. (^ lookup))\n456.\n)))\n457.\n(define parser-for-keyword\n458.\n(match keyword-table\n459.\n((make-parser-table keywords parser-lookup) parser-lookup)))\n460.\n(define all-keywords\n461.\n(match keyword-table\n462.\n((make-parser-table keywords parser-lookup) keywords)))\n\n463.\n;;; Type expression parser\n464.\n(define (parse-type sexp)\n465.\n(match sexp\n466.\n((sym->sexp sym) (base->type sym))\n467.\n(`(-> (,@arg-types) ,result-type)\n468.\n(compound->type arrow-constructor\ni. (cons (parse-type result-type)\n1. (map parse-type arg-types))))\n469.\n;; **MODULES**\n470.\n(`(moduleof ,@fields)\n471.\n(parse-module-type fields))\n472.\n;; **MODULES**\n473.\n(`(,(sym->sexp name) ,@types)\n474.\n(compound->type name (map parse-type types)))\n475.\n(_ (error \"Invalid type expression syntax \" sexp))))\n476.\n;; **MODULES**\n477.\n(define (parse-module-type fields)\n478.\n(if (null? fields)\n479.\n(moduleof->type (null) (null))\n480.\n(match (parse-module-type (cdr fields))\n481.\n((moduleof->type names typs)\na. (match (car fields)\n482.\n(`(val ,id ,typ)\na. (moduleof->type (cons id names) (cons (parse-type typ) typs)))\nb. (_ (error \"Invalid syntax in moduleof field entry \"\ni. (car fields)))))\n483.\n(_ (error \"PARSE-MODULE-TYPE: this shouldn't happen!\"\ni. fields)))))\n484.\n;; **MODULES**\n485.\n; Type expression unparser\n486.\n(define (unparse-type type)\n487.\n(match (prune type)\n488.\n((base->type sym) (sym->sexp sym))\n489.\n((compound->type constructor operands)\n490.\n(if (same-constructor? constructor arrow-constructor)\na. `(-> (,@(map unparse-type (cdr operands)))\nb. ,(unparse-type (car operands)))\nc. `(,(sym->sexp constructor) ,@(map unparse-type operands))))\n491.\n;; **MODULES**\n492.\n((moduleof->type names operands)\n493.\n`(moduleof\n\n494.\n,@(map2 (lambda (id t) `(val ,(sym->sexp id) ,(unparse-type t)))\ni. names\nii. operands)))\n495.\n;; **MODULES**\n496.\n((tvariable->type tvar)\n497.\n(sym->sexp (tvariable->symbol tvar)))\n498.\n((unknown->type)\n499.\n'(*unknown*))))\n500.\n; Parse a type schema (generic (I*) T)\n501.\n(define (parse-schema sexp)\n502.\n(match sexp\n503.\n(`(generic (,@names) ,type)\n504.\n(let ((names (map (lambda (name)\n1. (match name\n2. ((sym->sexp name) name)\n3. (_ (error \"Invalid type schema parameter: \" name))))\nii. names)))\n505.\n(let ((tvars (map new-tvariable names)))\na. (make-schema\nb. tvars\nc. (substitute-for-names (map tvariable->type tvars)\na. names\nb. (parse-type type))))))\n506.\n(_ (make-schema (null) (parse-type sexp)))))\n507.\n; substitute-for-names is a kludge, to be used only by initialization\n508.\n; code. Other ways to do this:\n509.\n;\n510.\n; (1) change the type parser to take an environment argument;\n511.\n;\n512.\n; (2) generalize substitute-into-type so that it; can substitute for\n513.\n;\neither names or tvars;\n514.\n;\n515.\n; (3) change the representation of schemas so that the generic variables\n516.\n;\nin the type are not tvars but rather names.\n517.\n(define (substitute-for-names types names type)\n518.\n(match type\n519.\n((tvariable->type _) type)\n;shouldn't happen\n\n520.\n((base->type name)\n521.\n(letrec ((loop (lambda (ts ns)\ni. (if (null? ts)\n1. type\n2. (if (same-name? name (car ns))\n\n3. (car ts)\n4. (loop (cdr ts) (cdr ns)))))))\n522.\n(loop types names)))\n523.\n((compound->type c args)\n524.\n(compound->type c (map (lambda (arg)\n1. (substitute-for-names types names arg))\n2. args)))\n525.\n;; **MODULES**\n526.\n((moduleof->type fieldnames args)\n527.\n(moduleof->type fieldnames (map (lambda (arg)\ni. (substitute-for-names types names arg))\nb. args)))\n528.\n;; **MODULES**\n529.\n(_ (error \"SUBSTITUTE-FOR-NAMES: This shouldn't happen! \"\na. (unparse-type type)))))\n530.\n(define (unparse-schema s)\n531.\n(match s\n532.\n((make-schema tvars type)\n533.\n`(generic (,@(map sym->sexp (map tvariable->symbol tvars)))\ni. ,(unparse-type type)))))\n\n534.\n;;;----------------------------------------------------------------------------\n535.\n;;; STANDARD TYPE ENVIRONMENT\n536.\n(define standard-type-bindings\n537.\n(list\n538.\n; Arithmetic\n539.\n'(+ (-> (int int) int))\n540.\n'(- (-> (int int) int))\n541.\n'(* (-> (int int) int))\n542.\n'(/ (-> (int int) int))\n543.\n; Relational\n544.\n'(= (-> (int int) bool))\n545.\n'(/= (-> (int int) bool))\n546.\n'(< (-> (int int) bool))\n547.\n'(> (-> (int int) bool))\n548.\n'(<= (-> (int int) bool))\n549.\n'(>= (-> (int int) bool))\n550.\n; Logical\n551.\n'(and? (-> (bool bool) bool))\n552.\n'(or? (-> (bool bool) bool))\n553.\n'(not? (-> (bool) bool))\n554.\n; Symbols\n555.\n'(sym=? (-> (sym sym) bool))\n556.\n; Strings\n557.\n'(string=? (-> (sym sym) bool))\n558.\n; Lists\n559.\n'(cons (generic (t) (-> (t (list-of t)) (list-of t))))\n560.\n'(car (generic (t) (-> ((list-of t)) t)))\n561.\n'(cdr (generic (t) (-> ((list-of t)) (list-of t))))\n562.\n'(null (generic (t) (-> () (list-of t))))\n563.\n'(null? (generic (t) (-> ((list-of t)) bool)))\n564.\n'(append (generic (t) (-> ((list-of t) (list-of t)) (list-of t))))\n565.\n))\n566.\n(define standard-type-environment\n567.\n(extend-by-schemas empty-type-environment\ni. (map (lambda (b)\n1. (match b\n2. (`(,(sym->sexp name) ,_) name)))\n3. standard-type-bindings)\n\nii. (map (lambda (b)\n1. (match b\n2. (`(,_ ,schema) (parse-schema schema))))\n3. standard-type-bindings)))\n568.\n;;;----------------------------------------------------------------------------\n569.\n;;; UTILITIES\n570.\n(define (member? pred)\n571.\n(lambda (elt lst)\n572.\n(letrec ((loop (lambda (lst)\ni. (if (null? lst)\n1. #f\n2. (if (pred elt (car lst))\n3. #t\n4. (loop (cdr lst)))))))\n573.\n(loop lst))))\n574.\n(define (map2 proc lst1 lst2)\n575.\n(if (or (null? lst1) (null? lst2))\n576.\n(null)\n577.\n(cons (proc (car lst1) (car lst2))\na. (map2 proc (cdr lst1) (cdr lst2)))))\n578.\n;;;----------------------------------------------------------------------------\n579.\n;;; TOP-LEVEL\n580.\n(define (recon sexp)\n581.\n(begin (reset-tvariable-counter!)\na. (unparse-type (reconstruct (parse sexp)\na. standard-type-environment))))"
    },
    {
      "category": "Resource",
      "title": "16.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/e27c992cb4302d14d5b6ee5f7d0dab34_16.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n1998 Midterm and Solutions\nThere are four problems on this examination. They are followed by an appendix that contains reference\nmaterial from the course notes. The appendix contains no problems; it is just a handy reference.\nYou will have eighty-five minutes in which to work the problems. Some problems are easier than others:\nread all problems before beginning to work, and use your time wisely!\nThis examination is open-book: you may use whatever reference books or papers you have brought to class.\nThe number of points awarded for each problem is placed in brackets next to the problem number. There\nare 100 points total on the exam.\nDo all written work in your examination booklet - we will not collect the examination handout itself; you\nwill only be graded for what appears in your examination booklet. It will be to your advantage to show\nyour work - we will award partial credit for incorrect solutions that make use of the right techniques.\nIf you feel rushed, be sure to write a brief statement indicating the key idea you expect to use in your\nsolutions. We understand time pressure, but we can't read your mind.\nThis examination has text printed on only one side of each page. Rather than flipping back and forth be-\ntween pages, you may find it helpful to rip pages out of the exam so that you can look at more than one\npage at the same time.\nAppendix:\nPage 6 FLK SOS\nPage 8 Standard denotational semantics of FLK! from Chapter 11\nThe figures in the Appendix are very similar to the ones in the course notes. Some bugs have been fixed,\nand some figures have been simplified to remove parts inessential for this exam. You will not be marked\ndown if you use the corresponding figures in the course notes instead of the appendices.\n\nProblem 1: The Two Game [10 points]\nIndicate whether each of the following expressions in the specified FL language-variant evaluates to the\nnumber two (2).\na. [2 points] Dynamically-scoped Call-By-Name FL\n(let ((foo (let ((a 5))\n(lambda (x) (- a x)))))\n(let ((b 3))\n(foo b)))\nb. [2 points] Statically-scoped Call-By-Reference FLAVAR!\n(let ((x 0)\n(foo (lambda (y z)\n(begin (set! y 2)\n(/ 4 z)))))\n(foo x x))\nc. [2 points] Statically-scoped Call-By-Value FL\n(let ((foo (proc x (rec x x)))\n(bar (proc y 2)))\n(bar foo))\nd. [2 points] Statically-scoped Call-By-Value FLK! (with label and jump)\n(label bar\n(* 2 (label foo\n(jump foo (jump bar 1)))))\ne. [2 points] Dynamically-scoped Call-By-Value FL\n(let ((x 1))\n(let ((f (lambda () x))\n(g (lambda (h) (h))))\n(let ((x 2))\n(g f))))\n\nProblem 2: Operational Semantics [30 points]\nYOUR ANSWERS TO THIS QUESTION SHOULD BE BASED ON THE FLK SOS AS PRESENTED IN AP\nPENDIX A.\nLouis Reasoner has an idea for a new FLK command, (terminate E1 E2). If either E1 or E2 terminates\nwith a value or an error, (terminate E1 E2) will also terminate with a value or an error. In evaluating\nterminate, we run one expression for one step, then run the other expression for one step, and so on. Louis\ninitially worked out a few examples of how his new construct would work:\n(terminate 1 2) ⇒ 1 or 2 (implementation dependent)\n(terminate 2 (rec x x)) ⇒ 2\n(terminate 1 (call 3 0)) ⇒ 1 or error: can't apply non-procedure (implementation dependent)\n(terminate (rec x x) (/ 3 0)) ⇒ error: divide by zero\n(terminate (rec x x) (rec x x)) ⇒⊥\nLouis is really excited about the terminate construct. His old implementation of FLK required him\nto reboot any time his program ran into an infinite loop. Although he hasn't solved the halting problem,\nnow he can guarantee not to have to reboot (excepting, of course, when his new-fangled operating system\ncrashes) by testing his programs with terminate and his new (timer N ) construct.\nLouis defined the following transition rule(s) for timer:\n(timer N1) ⇒ (timer N2)\nwhere N1 > 1\n[timer-countdown]\nand N2 = N1 - 1\n(timer 1) ⇒ #u\n[timer]\nLouis can now use the terminate construct to run his program might-go-infinite for exactly 1000 steps\n(where we consider each transition to be one step). The following expression will return the result of might-\ngo-infinite if it completes in under 1000 steps, otherwise it returns #u.\n(terminate (timer 1000) might-go-infinite )\nUnfortunately, Louis set off for Hawaii before he was able to extend the FL Operational Semantics to\ninclude terminate. In his absence, you are asked to finish it up.\na. [15 points] Give the transition rules for terminate.\nb. [5 points] Are your rules confluent?\nc. [10 points] Show how the following expression would be evaluated using the rules above:\n(terminate (call (proc x (primop + x 2)) 5)\n(if (> 3 4)\n(rec x x)\n(proc y 1)))\n\n[ ]\n[ ]\n[\n]\n[ ]\n[\n[\n[\n[\n]\n[\n]\nProblem 3: Denotational Semantics and Mutation [30 points]\nYOUR ANSWERS TO THIS PROBLEM SHOULD BE BASED ON THE STANDARD DENOTATIONAL\nSEMANTICS FOR FLK! AS PRESENTED IN APPENDIX B.\nAlyssa P. Hacker has decided to add a new feature to FLK!: the ability to undo store modifications. She\nintroduces a single new form into FLK! called undo!:\n(undo!)\n; undo the last mutation to the store\nHere is an example of how undo! can be used to undo a cell-set! using FL! sugar:\n(let ((c (cell 0)))\n(begin\n(primop cell-set! c 1)\n(undo!)\n(primop cell-ref c)))\n⇒ 0\nBefore Alyssa is called away to testify at a large antitrust trial, she managed to update the Standard\nSemantics found in Appendix B as follows:\nCmdcont = StoreStack → Answer\n∗\nz ∈ StoreStack = Store\nT L [E ] = E [E ] empty-env top-level-cont empty-store.[]Store\nYou can assume all of the semantic algebra helper functions that deal in CmdCont have been prop\nerly updated. Store operations same-location?, next-location, empty-store, fetch, assign, fresh-loc, and first-fresh\nremain unchanged.\na. [10 points] As she was running out the door, Alyssa mumbled something about the dangers of undo\ning cell creations using undo!. Give an example of a program that would generate a run-time error if\nAlyssa permits the cell form to be undone.\nb. [10 points] Dissatisfied with the possibility of run-time errors, Alyssa faxes you a revised meaning\nfunction for cell and assures you that we can prevent undos to cell creations.\nE [(primop cell E) ] = λek . E [E ] e (λvz . matching z\n. s.z1 ] (k (Location 7→Value (fresh-loc s ))\n(assign-to-all (fresh-loc s) v z))\nendmatching )\nassign-to-all : Location → Storable → StoreStack → StoreStack\n= fixLocation → Storable → StoreStack → StoreStack λf . (λlσz . matching z\n. []Store ] []Store\n. s.z1 ] (assign l σ s). (f l σ z1)\nendmatching )\nProvide a revised meaning function for E [(primop cell-set! E1 E2) ].\nc. [10 points] Also provide a revised meaning function for Alyssa's new undo! form, E [undo!) ]. Her\nnotes specified that even in the absense of cell-set!'s, undo! should not produce any errors.\n\n[\n]\n[\n]\n[\n]\n[\n]\nProblem 4: Denotational Semantics: Control [30 points]\nYOUR ANSWERS TO THIS PROBLEM SHOULD BE BASED ON THE STANDARD DENOTATIONAL\nSEMANTICS FOR FLK! AS PRESENTED IN APPENDIX B.\nBen Bitdiddle is now ensconced in a major research university where he's been fooling around with loops\nin FLK!. Ben has decided to add the following features to FLK!:\nE ::= ...all FLK! forms . . . | (loop E) | (exit E) | (jump)\nHere's an example of how Ben's new loop construct would work:\n(let ((c (cell 0)))\n(loop\n(begin\n(primop cell-set! c (+ (primop cell-ref c) 1))\n(if (> (cell-ref c) 10)\n(exit (primop cell-ref c))\n(jump)))))\n⇒ 11\nAs one of Ben's grad students, your job is to write the denotational semantics for FLK! with his new\nlooping functionality. Ben has already revised the domain equations for you:\nj ∈ Jumpcont = Cmdcont\nx ∈ Exitcont = Expcont\nHe's also changed the signature of the E meaning function so that every expression is evaluated with\nboth a jump and an exit continuation:\nE : Exp → Environment → Jumpcont → Exitcont → Expcont → Cmdcont\nBen did give you the meaning function clause for E [(jump) ] for reference.\nE [(jump) ] = λejxk . j\na. [10 points] Extend the meaning function in the FLK! Standard Semantics as given in Appendix B to\ninclude E [(loop E) ], given the new domains.\nb. [10 points] Define the meaning function clause for E [(exit E) ].\nc. [10 points] Show that (loop (jump)) is equivalent to bottom.\n\nA An Operational Semantics for FLK\nE\n∈\nExp\nL\n∈\nLit\nI\n∈\nIdentifier\nB\n∈\nBoollit\n=\n{#t, #f}\nN\n∈\nIntlit\n=\n{. . ., -2, -1, 0, 1, 2, . . .}\nO\n∈\nPrimop\n=\n; ; Defined by standard library.\nV\n∈\nValue\n=\n{#u} ∪ Boollit ∪ Intlit\n∪{(symbol I)} ∪{(proc I E)} ∪{(pair E1 E2)}\nE\n::=\nL\n[Literal]\n|\nI\n[Variable Reference]\n|\n(primop Oname Earg *)\n[Primitive Application]\n|\n(proc Iformal Ebody)\n[Abstraction]\n|\n(call Eoperator Eoperand)\n[Application]\n|\n(if Etest Econsequent Ealternate)\n[Branch]\n|\n(pair Eleft Eright)\n[Pairing]\n|\n(rec Ivar Ebody)\n[Recursion]\nL\n::=\n#u\n[Unit Literal]\n|\nB\n[Boolean Literal]\n|\nN\n[Integer Literal]\n|\n(symbol I)\n[Symbolic Literal]\nFigure 1: An s-expression grammar for FLK\n\n(call (proc I E1) E2) ⇒ [E2/I]E1\n[call-apply]\nE1 ⇒ E1 0\n(call E1 E2) ⇒ (call E1 0 E2)\n[call-operator]\n(if #t E1 E2) ⇒ E1\n[if-true]\n(if #f E1 E2) ⇒ E2\n[if-false]\nE1 ⇒ E1 0\n(if E1 E2 E3) ⇒ (if E1 0 E2 E3)\n[if-test]\n(rec I E) ⇒ [(rec I E)/I]E\n[rec]\nE ⇒ E0\n(primop O E) ⇒ (primop O E0)\n[unary-arg]\nE1 ⇒ E1 0\n(primop O E1 E2) ⇒ (primop O E1 0 E2)\n[binary-arg-1]\nE2 ⇒ E2 0\n(primop O V E2) ⇒ (primop O V E2 0)\n[binary-arg-2]\nFigure 2: A partial set of FLK rewrite rules\n\n[\n[\n[\nB Standard Semantics of FLK!\nv ∈ Value = Unit + Bool + Int + Sym + Pair + Procedure + Location\nk ∈ Expcont = Value → Cmdcont\nγ ∈ Cmdcont = Store → Answer\nAnswer = (Value + Error)⊥\nError = Sym\np ∈ Procedure = Denotable → Expcont → Cmdcont\nd ∈ Denotable = Value\ne ∈ Environment = Identifier → Binding\nβ ∈ Binding = (Denotable + Unbound)⊥\nUnbound = {unbound}\ns ∈ Store = Location → Assignment\nl ∈ Location = Nat\nAssignment = (Storable + Unassigned)⊥\nσ ∈ Storable = Value\nUnassigned = {unassigned}\ntop-level-cont : Expcont\n= λv . λs . (Value 7→Answer v)\nerror-cont : Error → Cmdcont\n= λy . λs . (Error 7→Answer y)\nempty-env : Environment = λI . (Unbound 7→Binding unbound)\ntest-boolean : (Bool → Cmdcont) → Expcont\n= λf . (λv . matching v\n. (Bool 7→Value b) ] (f b)\n. else (error-cont non-boolean)\nendmatching )\nSimilarly for:\ntest-procedure : (Procedure → Cmdcont) → Expcont\ntest-location : (Location → Cmdcont) → Expcont\netc.\nensure-bound : Binding → Expcont → Cmdcont\n= λβ k . matching β\n. (Denotable 7→Binding v) ] (k v)\n. (Unbound 7→Binding unbound) ] (error-cont unbound-variable)\nendmatching\nSimilarly for:\nensure-assigned : Assignment → Expcont → Cmdcont\nFigure 3: Semantic algebras for standard semantics of strict CBV FLK!.\n\n[\nsame-location? : Location → Location → Bool = λl1l2 . (l1 =Nat l2)\nnext-location : Location → Location = λl . (l +Nat 1)\nempty-store : Store = λl . (Unassigned 7→Assignment unassigned)\nfetch : Location → Store → Assignment = λls . (s l)\nassign : Location → Storable → Store → Store\n= λl1σ s . λl2 . if (same-location? l1 l2)\nthen (Storable 7→Assignment σ)\nelse (fetch l2 s)\nfresh-loc : Store → Location = λs . (first-fresh s 0)\nfirst-fresh : Store → Location → Location\n= λsl . matching (fetch l s)\n. (Unassigned 7→Assignment unassigned) ] l\n. else (first-fresh s (next-location l))\nendmatching\nFigure 4: Store helper functions for standard semantics of strict CBV FLK!.\n\n[ ]\n[ ]\n[ ]\n[ ]\n[ ]\n[\n]\n[ ]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[ ]\n[\n]\n[\n]\n[\n]\n[\n]\n[ ]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n[\n]\n[\nT L : Exp → Answer\nE : Exp → Environment → Expcont → Cmdcont\nL : Lit → Value ; Defined as usual\nT L [E ] = E [E ] empty-env top-level-cont empty-store\nE [L ] = λek . k L [L ]\nE [I ] = λek . ensure-bound (lookup e I) k\nE [(proc I E) ] = λek . k (Procedure 7→Value (λdk 0 . E [E ] [I : d]e k 0))\nE [(call E1 E2) ] = λek . E [E1 ] e (test-procedure (λp . E [E2 ] e (λv . p v k)))\nE [(if E1 E2 E3) ] =\nλek . E [E1 ] e (test-boolean (λb . if b then E [E2 ] e k else E [E3 ] e k))\nE [(pair E1 E2) ] = λek . E [E1 ] e (λv1 . E [E2 ] e (λv2 . k (Pair 7→Value hv1, v2i)))\nE [(cell E) ] = λek . E [E ] e (λvs . k (Location 7→Value (fresh-loc s))\n(assign (fresh-loc s) v s))\nE [(begin E1 E2) ] = λek . E [E1 ] e (λvignore . E [E2 ] e k)\nE [(primop cell-ref E) ] = λek . E [E ] e (test-location (λls . ensure-assigned (fetch l s) k s))\nE [(primop cell-set! E1 E2) ]\n= λek . E [E1 ] e (test-location (λl . E [E2 ] e (λvs . k (Unit 7→Value unit) (assign l v s))))\nE [(rec I E) ] = λeks . let f = fixAnswer (λa . E [E ] [I : (extract-value a)] e top-level-cont s)\nmatching f\n. (Value 7→Answer v) ] E [E ] [I : v] e k s\n. else f\nendmatching\nextract-value : Answer → Binding\n= λa . matching a\n. (Value 7→Expressible v) ] (Denotable 7→Binding v)\n. else ⊥Binding\nendmatching\nFigure 5: Valuation clauses for standard semantics of strict CBV FLK!.\n\nMidterm Solutions\n\nProblem 1: The Two Game [10 points]\nIndicate whether each of the following expressions in the specified FL language-variant evaluates to the\nnumber two (2).\na. [2 points] Dynamically-scoped Call-By-Name FL\n(let ((foo (let ((a 5))\n(lambda (x) (- a x)))))\n(let ((b 3))\n(foo b)))\nSolution: No, the result is error: a is undefined.\nb. [2 points] Statically-scoped Call-By-Reference FLAVAR!\n(let ((x 0)\n(foo (lambda (y z)\n(begin (set! y 2)\n(/ 4 z)))))\n(foo x x))\nSolution: Yes, aliasing allows us to use multiple names for the same location in the store.\nc. [2 points] Statically-scoped Call-By-Value FL\n(let ((foo (proc x (rec x x)))\n(bar (proc y 2)))\n(bar foo))\nSolution: Yes, even in Call-By-Value we don't evaluate the body of a procedure until it's called.\nd. [2 points] Statically-scoped Call-By-Value FLK! (with label and jump)\n(label bar\n(* 2 (label foo\n(jump foo (jump bar 1)))))\nSolution: No, (jump bar 1) passes 1 directly to the label bar, so the result is 1.\ne. [2 points] Dynamically-scoped Call-By-Value FL\n(let ((x 1))\n(let ((f (lambda () x))\n(g (lambda (h) (h))))\n(let ((x 2))\n(g f))))\nSolution: Yes, procedure f gets the value 2 for the free variable x from the dynamic environment.\n\nProblem 2: Operational Semantics [30 points]\nLouis Reasoner has an idea for a new FLK command, (terminate E1 E2). If either E1 or E2 terminates\nwith a value or an error, (terminate E1 E2) will also terminate with a value or an error. In evaluating\nterminate, we run one expression for one step, then run the other expression for one step, and so on. Louis\ninitially worked out a few examples of how his new construct would work:\n(terminate 1 2) ⇒ 1 or 2 (implementation dependent)\n(terminate 2 (rec x x)) ⇒ 2\n(terminate 1 (call 3 0)) ⇒ 1 or error: can't apply non-procedure (implementation dependent)\n(terminate (rec x x) (/ 3 0)) ⇒ error: divide by zero\n(terminate (rec x x) (rec x x)) ⇒⊥\nLouis is really excited about the terminate construct. His old implementation of FLK required him\nto reboot any time his program ran into an infinite loop. Although he hasn't solved the halting problem,\nnow he can guarantee not to have to reboot (excepting, of course, when his new-fangled operating system\ncrashes) by testing his programs with terminate and his new (timer N ) construct.\nLouis defined the following transition rule(s) for timer:\n(timer N1) ⇒ (timer N2)\nwhere N1> 1\n[timer-countdown]\nand N2 = N1 - 1\n(timer 1) ⇒ #u\n[timer]\nLouis can now use the terminate construct to run his program might-go-infinite for exactly 1000 steps\n(where we consider each transition to be one step). The following expression will return the result of might-\ngo-infinite if it completes in under 1000 steps, otherwise it returns #u.\n(terminate (timer 1000) might-go-infinite )\nUnfortunately, Louis set off for Hawaii before he was able to extend the FL Operational Semantics to\ninclude terminate. In his absence, you are asked to finish it up.\na. [15 points] Give the transition rules for terminate.\nSolution:\nE1 ⇒ E0\n1)\n[terminate-progress]\n(terminate E1 E2) ⇒ (terminate E2 E0\n(terminate V E) ⇒ V\n[terminate-with-value]\nb. [5 points] Are your rules confluent?\nSolution: Yes, the rules are confluent.\nc. [10 points] Show how the following expression would be evaluated using the rules above:\n(terminate (call (proc x (primop + x 2)) 5)\n(if (> 3 4)\n(rec x x)\n(proc y 1)))\n\nSolution:\n⇒ (terminate (if (> 3 4)\n(rec x x)\n(proc y 1))\n(primop + 5 2))\n⇒ (terminate (primop + 5 2)\n(if false\n(rec x x)\n(proc y 1)))\n⇒ (terminate (if false\n(rec x x)\n(proc y 1))\n7)\n⇒ (terminate 7\n(proc y 1))\n⇒ 7\n\n[ ]\n[ ]\n[\n]\n[ ]\n[\n[\n[\n[\n]\nProblem 3: Denotational Semantics and Mutation [30 points]\nAlyssa P. Hacker has decided to add a new feature to FLK!: the ability to undo store modifications. She\nintroduces a single new form into FLK! called undo!:\n(undo!)\n; undo the last mutation to the store\nHere is an example of how undo! can be used to undo a cell-set! using FL! sugar:\n(let ((c (cell 0)))\n(begin\n(primop cell-set! c 1)\n(undo!)\n(primop cell-ref c)))\n⇒ 0\nBefore Alyssa is called away to testify at a large antitrust trial, she managed to update the Standard\nSemantics as follows:\nCmdcont = StoreStack → Answer\n∗\nz ∈ StoreStack = Store\nT L [E ] = E [E ] empty-env top-level-cont empty-store.[]Store\nYou can assume all of the semantic algebra helper functions that deal in CmdCont have been prop\nerly updated. Store operations same-location?, next-location, empty-store, fetch, assign, fresh-loc, and first-fresh\nremain unchanged.\na. [10 points] As she was running out the door, Alyssa mumbled something about the dangers of undo\ning cell creations using undo!. Give an example of a program that would generate a run-time error if\nAlyssa permits the cell form to be undone.\nSolution:\n(let ((c (cell 0)))\n(begin\n(undo!)\n(primop cell-ref c)))\nb. [10 points] Dissatisfied with the possibility of run-time errors, Alyssa faxes you a revised meaning\nfunction for cell and assures you that we can prevent undos to cell creations.\nE [(primop cell E) ] = λek . E [E ] e (λvz . matching z\n. s.z1 ] (k (Location 7→Value (fresh-loc s))\n(assign-to-all (fresh-loc s) v z))\nendmatching )\nassign-to-all : Location → Storable → StoreStack → StoreStack\n= fixLocation → Storable → StoreStack → StoreStack λf . (λlσz . matching z\n. []Store ] []Store\n. s.z1 ] (assign l σ s). (f l σ z1)\nendmatching )\nProvide a revised meaning function for E [(primop cell-set! E1 E2) ].\n\n[\n]\n[\n]\n[\n]\n[\n[\n]\n[\n]\n[\n[\nSolution:\nE [(primop cell-set! E1 E2) ]\n= λek . E [E1 ] e (test-location (λl . E [E2 ] e (λvz . matching z\n. s.z1 ] (k (Unit 7→Value unit) (assign l v s).z)\nendmatching )))\nc. [10 points] Also provide a revised meaning function for Alyssa's new undo! form, E [undo!) ]. Her\nnotes specified that even in the absense of cell-set!'s, undo! should not produce any errors.\nSolution:\nE [(primop undo!) ] = λekz . matching z\n. s.[]Store ] (k (Unit 7→Value unit) s.[]Store)\n. s.z1 ] (k (Unit 7→Value unit) z1)\nendmatching\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nProblem 4: Denotational Semantics: Control [30 points]\nBen Bitdiddle is now ensconced in a major research university where he's been fooling around with loops\nin FLK!. Ben has decided to add the following features to FLK!:\nE ::= ...all FLK! forms . . . | (loop E) | (exit E) | (jump)\nHere's an example of how Ben's new loop construct would work:\n(let ((c (cell 0)))\n(loop\n(begin\n(primop cell-set! c (+ (primop cell-ref c) 1))\n(if (> (cell-ref c) 10)\n(exit (primop cell-ref c))\n(jump)))))\n⇒ 11\nAs one of Ben's grad students, your job is to write the denotational semantics for FLK! with his new\nlooping functionality. Ben has already revised the domain equations for you:\nj ∈ Jumpcont = Cmdcont\nx ∈ Exitcont = Expcont\nHe's also changed the signature of the E meaning function so that every expression is evaluated with\nboth a jump and an exit continuation:\nE : Exp → Environment → Jumpcont → Exitcont → Expcont → Cmdcont\nBen did give you the meaning function clause for E [(jump) ] for reference.\nE [(jump) ] = λejxk . j\na. [10 points] Extend the meaning function in the FLK! Standard Semantics to include E [(loop E) ],\ngiven the new domains.\nSolution:\nE [(loop E) ] = λejxk . (fixCmdcont (λj1 . (E [E ] e j1 k k)))\nb. [10 points] Define the meaning function clause for E [(exit E) ].\nSolution:\nE [(exit E) ] = λejxk . E [E ] e j x x\nc. [10 points] Show that (loop (jump)) is equivalent to bottom.\nSolution:\nE [(loop (jump)) ] = λejxk . (fix (λj1 . (E[[(jump)]] e j1 k k)))\n⇒\nE [(loop (jump)) ] = λejxk . (fix (λj1 . ((λejxk . j) e j1 k k)))\n⇒\nE [(loop (jump)) ] = λejxk . (fix (λj1 . j1))\n⇒\nE [(loop (jump)) ] = ⊥"
    },
    {
      "category": "Resource",
      "title": "17.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/255683fb5197bfe493a0fd9f1ff60adb_17.pdf",
      "content": "@ ¡\n@\n¡\n@\n¡\n6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n1999 Midterm & Solutions\nProblem 1: Short Answer Questions [15 points]\na. Let D and E be the following CPOs:\nz\nb\nc\n⊥\n⊥\nD\nE\nHow many elements are in the set of\n(i) [3 points] total functions from D to E?\n(ii) [4 points] continuous functions from D to E?\n(i) There are 32 or 9 total functions from D to E.\n(ii) For finite CPOs, the set of continuous functions is equal to the set of monotonic functions. The\nentire domain D is a chain. This means any monotonic function must map the domain D to a\nchain in E. There are three chains in E: {⊥}, {a, ⊥} and {b, ⊥}. There is one way to monotonically\nmap to the first chain, and there are two ways to monotonically map to the other two. This means\nthere are five monotonic functions from D to E, or five continuous functions from D to E.\nb. Evaluate each of the following expressions with the appropriate model.\n(i) [2 points] Static Scoping, call by value\n(let ((a 1))\n(let ((f (lambda (x y) (/ x a))))\n(let ((a 0))\n(f 4 3))))\nSolution:\n(ii) [2 points] Dynamic Scoping, call by value\n(let ((a 1))\n(let ((f (lambda (x y) (/ x a))))\n(let ((a 0))\n(f 4 3))))\nSolution:\nError, Division by 0\n\n(iii) [2 points] Dynamic Scoping, call by name\n(let ((a 1))\n(let ((f (lambda (x y) (/ x a))))\n(let ((a 2))\n(f 4 (let ((a 0)) (f 2 2))))))\nSolution:\n(iv) [2 points] Static Scoping, call by value\n(let ((a 1))\n(let ((f (lambda (x y) (/ x a))))\n(let ((a 2))\n(f 4 (let ((a 0)) (f 2 2))))))\nSolution:\n\nProblem 2: Operational Semantics [35 points]\nAfter completing 6.821, you get a job working for Ben Bitdiddle, whose company sells commercial imple\nmentations of PostFix (without dup). After several focus-group studies, Ben has decided that PostFix needs\na macro facility. Below is Ben's sketch of the informal semantics of the facility.\nMacros are specified as part of a PostFix program, as follows:\n(program ((I_1 V_1) ... (I_n V_n)) Q)\nI1 through In are identifiers. Each macro (Ii Vi) creates a command, Ii, that pushes the value Vi (which\ncan be an integer or a command sequence) onto the stack. It is illegal to give macros the names of existing\nPostFix commands, or to use an identifier more than once in a list of macros. The behavior of programs that\ndo so is undefined.\nHere are some examples Ben has come up with:\n(program ((inc (1 add))) (0 inc exec inc exec)) ⇒ 2\n(program ((A 1) (B (2 mul))) (A B exec)) ⇒ 2\n(program ((A 1) (B (2 mul))) (A C exec)) ⇒ error (undefined macro C)\n(program ((A 1) (B (C mul)) (C 2)) (A B exec)) ⇒ 2\n(program ((A pop)) (1 A)) ; Ill-formed program (The body of a macro must be a value, it cannot be a com\nmand.)\nBen started writing an SOS for PostFix with macros, but had to go make a presentation for some venture\ncapitalists. It is your job to complete the SOS.\nNew (or modified) domains:\nI\n∈\nIdentifier\nM\n∈\nMacro-list = (Identifier × Value)∗\nC\n∈\nCommandPostFix+macros = CommandPostFix + Identifier\nP\n∈\nProgram = Commands × Macro-list\nDefinition = Value\nValue = Intlit + Commands\nBen's notes describe a helper function, lookup, that you can use to figure out what identifiers have been\ndefined as. The function has the signature:\nlookup : Identifier × Macro-list → Definition\nIf lookup is given an identifier and a macro list, it returns a value if the identifier is defined to be that\nvalue in the macro list. Otherwise lookup gets stuck.\na. [10 points] Ben's notes begin the SOS for PostFix+macros as follows:\nC\n= Commands × Stack × Macro-list\nhQ, Si ⇒ P hQ0, S0i\n⇒\n:\nhQ, S, Mi ⇒hQ0, S0, Mi\nwhere ⇒ P is the original transition relation for PostFix\nComplete the transition relation for PostFix+macros. Your completed SOS should handle the first\nfour of Ben's examples. It should not handle the ill-formed program. Model errors in the SOS as stuck\nstates (and do not handle them explicitly).\nSolution:\n⇒ :\nhI.Q, S, Mi ⇒ hQ, V.S, Mi\nwhere V = (lookup I M )\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n]\n[\n]\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nb. [10 points] Louis Reasoner finds out that you have completed an SOS for PostFix+macros. He sees\nthat your SOS handles macros that depend on other macros. He wants to launch a new advertising\ncampaign with the slogan: \"Guaranteed to terminate: PostFix with mutually recursive macros!\" Show\nthat Louis' new campaign is a bad idea by writing a nonterminating program in PostFix+macros\n(without dup).\nSolution: A simple nonterminating program is:\n(program ((I (I exec))) (I exec))\nc. When Ben returns from his presentation, he finds out you've written a nonterminating program in\nPostFix+macros. He decides to restrict the language so nonterminating programs are no longer pos\nsible. Ben's restriction is that the body (or value) of a macro cannot use any macros. Ben wants you\nto prove that this restricted language terminates.\n(i) [10 points] Extend the PostFix energy function so that it assigns an energy to configurations that\ninclude macros. Fill in the definitions of the functions Ecom [C, M ], Eseq [Q, M ] and Estack [S, M ]\nand use these functions to define your extended energy function. (Hint: If a command pushes a\nvalue, V, onto the stack, how does the energy of the configuration change?)\nEcom [C, M ]\nEcom [I, M ]\nEseq[[[]Command, M ]\nEseq [C.Q, M ]\nEstack[[[]Value, M ]\nEstack [V.S, M ]\n=\n1 (C is not an identifier or an executable sequence)\n=\n=\n=\n=\n=\nSolution: Completing the energy function we have:\nEcom [I, M ]\n= Ecom [V, M ]\nwhere V = (lookup I M )\nThis is all that is necessary because if an undefined I is ever encountered,\nthe program will immediately get stuck (and terminate).\nEseq [C.Q, M ] = 1 + Ecom [C, M ] + Eseq [Q, M ]\nEstack [V.S, M ]\n= Ecom [V, M ] + Estack [S, M ]\nEconfig [hQ, S, Mi ]\n= Eseq [Q, M ] + Estack [S, M ]\n(ii) [5 points] Use the extended energy function (for the restricted form of PostFix+macros) to show\nthat executing a macro decreases the energy of a configuration. Since it is possible to show all the\nother commands decrease the energy of a configuration (by adapting the termination proof for\nPostFix without macros), this will show that the restricted form of PostFix+macros terminates.\nSolution:\nhI.Q, S, Mi ⇒ hQ, V.S, Mi\nwhere V = (lookup I M )\nEconfig [hI.Q, S, Mi ]\n=\nEseq [I.Q, M ] + Estack [S, M ]\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n=\n1 + Ecom [I, M ] + Eseq [Q, M ] + Estack [S, M ]\n=\n1 + Ecom [V, M ] + Eseq [Q, M ] + Estack [S, M ]\n=\n1 + Eseq [Q, M ] + Estack [V.S, M ]\n=\n1 + Econfig [hQ, V.S, Mi ]\nThus, after executing a macro, the energy of a configuration decreases by one unit, proving Post-\nFix with macros terminates.\n\n[ ]\n[\n[\n]\n[\n]\n[\n]\n[\n]\n[ ]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nProblem 3: Control [50 points]\nBen Bitdiddle, whose company also sells FLK!, has decided to improve FLK! with new facilities for excep\ntion handling. Ben's idea is to allow users to store exceptions in variables. Other exception facilities are also\nincluded, in the form of handle and exception. Ben also adds let-x to allow either an exception or a value\nto be bound to an identifier:\n(exception E)\n; creates an exception with value E\n(handle E1 E2) ; handler procedure E1 handles exceptions\n; from E2. If E2 does not raise an exception,\n; E2 is the value of the HANDLE. If E2 raises\n; an exception, the value of the HANDLE is the\n; result of calling the handler procedure E1 on\n; the value of the exception.\n(let-x I E1 E2) ; binds an exception or value from E1\n; to I in E2.\nFor example:\n(handle (lambda (x) (+ 1 x))\n(let-x a (exception 4)\n(let ((b 2))\n(+ a b))))\n⇒ 5\nAny attempt to reference a variable that is bound to an exception will result in the immediate raising of\nthe exception. Thus, the above example will evaluate to 5 because the reference to a in (+ a b) will cause\nan exception to be raised.\nBen had begun to develop a new semantics for FLK!, but was called away to work for a new Internet\nstartup that was about to have an IPO event. You find on Ben's desk the following sheet of paper:\nE : Exp → Environment → Computation\nComputation = ExceptionCont → ExpCont → CmdCont\nCmdCont = Store → Answer\nk ∈ ExpCont = Value → CmdCont\nw ∈ ExceptionCont = ExpCont\nProcedure = Value → Computation\nδ ∈ Denotable = Value + Exception\nException = Value\nE [L ] = λewk . (k L [L]])\nE [(handle E1 E2) ] = λewk . (E [E1 ] e w (test-procedure λp . (E [E2 ] e (λv . (p v w k)) k)))\nE [(proc I E) ] = λewk . (k (Procedure 7→Value (λvw0k0 . (E [E ] [I : (Value 7→Denotable v)]e w0 k0))))\nE [(call E1 E2) ] = λewk . E [E1 ] e w (test-procedure λp . E [E2 ]e w (λv . (p v w k)))\na. [10 points] Ben wants to add a new kernel form (exception? I) that tests whether or not an identifier\nI is bound to an exception and returns a boolean. Alyssa insists that the form can be desugared into\nthe other exception-handling forms, but does not have time to provide the desugaring. Prove Alyssa\ncorrect by writing a desugaring for (exception? I).\nD [(exception? I) ] =\nSolution:\nD [(exception? I) ] = (handle (lambda (x) #t) (begin I #f))\n\n[\n]\n[ ]\n[ ]\n[\n[\n[\n[\n[\n]\n[\n]\n[\n]\n[\n]\nb. [10 points] Write the meaning function clause for (exception E).\nSolution:\nE [(exception E) ] = λewk . (E [E ] e w w)\nc. [10 points] Write the meaning function clause for I.\nSolution:\nE [I ] = λewk . matching (lookup e I)\n. (Denotable7→Binding d) ] matching d\n. (Value7→Denotable v) ] (k v)\n. (Exception7→Denotable v) ] (w v)\nendmatching\n. else ] λs . (Error7→Answer error)\nendmatching\nd. [10 points] Write the meaning function clause for (let-x I E1 E2).\nSolution:\nE [(let-x I E1 E2) ] =\nλewk . ( E [E1 ] e (λv . (E [E2 ] [I : (Exception7→Denotable v)]e w k))\n(λv . (E [E2 ] [I : (Value7→Denotable v)]e w k)))\nWhile scrounging through Ben's notes, you noticed Bolt Cola spilled all over a very important doc\nument. After sponging off most of the goop, you notice it's a memo from Alyssa P. Hacker about a\nbrand new command called rec-handle. It reads the following:\nDear Ben,\nI figured out how you can get ahead of the competition.\nAll you need is a\nrecursive handler. Something like:\n(rec-handle E1 E2) ; handler procedure E1 handles exceptions\n; from E2. If E2 does not raise an exception,\n; E2 is the value of REC-HANDLE. In addition, any\n; exceptions raised during execution of E1\n; are HANDLED by E1.\nHere's an example:\n(rec-handle (lambda (x)\n(if (= x 0) 1\n(exception (- x 1))))\n(exception 5))\n⇒1\n\n[\n]\n[\n]\n[\n]\nHere, I whipped up the meaning function for you.\nE [(handle E1 E2) ] = λew1k .\n(E [E1 ] e w1 (test-procedure λp . let w2 be BOLTCOLA in (E [E2 ] e (λv . (p v w2 k) k))))\nUnfortunately, the critical part of the function was too smeared with Cola. It's your job to help Ben by\nfixing Alyssa's memo.\ne. [10 points] Fill in the BOLTCOLA splotch for rec-handle.\nSolution:\nfixExceptionCont λw3 . λv . (p v w3 k)"
    },
    {
      "category": "Resource",
      "title": "18.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/e539d3a64579761e074b691a974aab84_18.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n2000 Midterm\nProblem 1: Short Answer [20 points]\nEvaluate the following expressions in the given models.\n(let ((a 1)\n(g (lambda (x) 25)))\n(let ((f (lambda (y) (if (< a y)\n(g (/ 2 0))\n((lambda (x) 15) (g g)))))\n(let ((a 4)\n(y 5)\n(g (lambda (x) (x x))))\n(f 2)))))\na. [5 points] static scoping, call by value\nSolution: error (divide by 0)\nb. [5 points] dynamic scoping, call by value\nSolution: ⊥ (infinite loop)\nc. [5 points] static scoping, call by name\nSolution: 25\nd. [5 points] dynamic scoping, call by name\nSolution: 15\n\n[\n]\n[\n]\n[\n]\n[\n]\nProblem 2: Operational Semantics: Postfix + {sdup} [20 points]\nAlyssa P. Hacker extended the PostFix language with a new command called sdup: smart dup. This allows\nus to compute square(x) = x2 without hurting the termination property of PostFix programs. The informal\nsemantics for sdup is as follows: duplicate the top of the stack if it is a number or a command sequence that\ndoesn't contain sdup; otherwise, report an error.\nFormally, the operational semantics has been extended with the following two transition rules:\nhsdup. Qrest, N . Si ⇒hQrest, N . N . Si\n[sdup-numeral]\nhsdup. Qrest, Q . Si ⇒hQrest, Q . Q . Si\n[sdup-sequence]\nwhere ¬(contains sdup Q)\ncontains sdup : Command ∗ → Bool is a helper function that takes a sequence of commands and checks\nwhether it contains sdup or not (yes, contains sdup handles even nested sequences of commands)\nAs a new graduate student in Alyssa's AHRG (Advanced Hacking Research Group), you were assigned\nto give a proof that all PostFix + {sdup} programs terminate. However, you are not alone! Alyssa already\ntook care of most of the mathematical weaponry:\nConsider the product domain P = Nat × Nat (as usual, Nat is the set of natural numbers, starting with\n0). On this domain, we define the relation <P as follows:\nDefinition 1 (lexicographic order) ha1, b1i <P ha2, b2i iff:\na. a1 < a2 or\nb. a1 = a2 and b1 < b2.\nE.g. h3, 10000i <P h4, 0i, h5, 2i <P h5, 3i.\nDefinition 2 A strictly decreasing chain in P is a finite or infinite sequence of elements p1, p2, . . . such that\npi ∈ P, ∀i and pi+1 <P pi, ∀i.\nAfter a long struggle, Alyssa proved the following lemma for you:\nLemma 1 There is no infinite strictly decreasing chain in P .\nGive a rigorous proof that each PostFix+ {sdup} program terminates by using a cleverly defined energy\nfunction ESconfig . Hint: Each transition of Postfix reduces the energy function Econfig you saw in class. Try\nto see what is reduced by the two new rules, and how you can combine these two things into a single energy\nfunction.\nNote: If you need to use some helper functions that are intuitively easy to describe but tedious to define\n(e.g. contains sdup), just give an informal description of them.\nGrading scheme:\n- [10 points] ESconfig ;\n- [10 points] Termination proof.\nSolution:\nConsider the following energy function:\nESconfig : C → Nat × Nat = λhQ, Si . hsdup count [hQ, Si ], Econfig [hQ, Si ]i\nwhere sdup count is a helper function that computes the number of times sdup appears in a configuration\nand E config is the energy function shown in class.\nLet's first prove that for any transition cold ⇒ cnew , ESconfig [cnew ] <P ESconfig [cold ].\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nOld transitions: None of them introduces new sdup commands but they all strictly decrease E config . So, the\nfirst component of ESconfig doesn't increase and the second one strictly decreases which implies\nESconfig [cnew ] <P ESconfig [cold ].\nNew transitions: Each of the new sdup related rules \"consumes\" exactly one sdup: this is clearly true for\n[dup-numeral] and [dup-sequence] doesn't duplicate sequences containing sdup. So the first component of\nESconfig is strictly decreased by these transitions which implies that no matter what happens with the sec\nond component (note that [dup-sequence] might actually increase it), ESconfig [cnew ] <P ESconfig [cold ] for\nthe new transitions too.\nSuppose now for the sake of contradiction that there is some PostFix + {sdup} program with an infinite\nexecution c1 ⇒ c2 ⇒ c3 ⇒ . . . . This implies ESconfig [c2 ] <P ESconfig [c1 ], ESconfig [c3 ] <P ESconfig [c2 ], . . .\nand we've just constructed an infinite strictly decreasing chain in P! Contradiction with Lemma 1.\n\n[ ]\n[ ]\n[\n]\n[\n]\n[\n[\n[\n]\nProblem 3: State: FLK! + {undo-once!} [30 points]\nBen Bitdiddle introduced a new undo-once! instruction to roll the store back one operation at a time. In-\nformally speaking, undo-once! undoes the last store operation (cell or cell-set!). If there is no store\noperation to undo, undo-once! does nothing.\nE\n::=\n. . .\n[Classic FLK! expressions]\n|\n(undo-once!)\n[Undo last store operation]\nInitially, Ben thought of modifying the meaning function to use a stack of stores (as it did in the fall-98\nmidterm), but the implementors refused to work on such an idea and threatened to quite Ben's company en\nmasse. So, Ben had to turn to a more efficient idea: maintain the current store and a stack of undo functions.\nAn undo function takes a store and reverses a specific store operation (one done with cell or cell-set!)\nto obtain the store before the operation.\nPursuing this idea, Ben modified the Cmdcont semantic domain and the top level function as follows:\nCmdcont = Store → StoreTransformStack → Expressible\nh ∈ StoreTransformStack = StoreTransform∗\nt ∈ StoreTransform = Store → Store\nT L [E ] = ( E [E ] empty-env top-level-cont empty-store [ ]StoreTransform )\nAs each store operation (cell or cell-set!) consists of assigning a Storable to a Location, it can be\nreversed by putting the old Assignment into that Location. Ben even wrote the following undo function\nproducer for you:\nmake-undofun : Location → Assignment → StoreTransform\n= λlα . λs . (assign' l α s)\nassign' is a function similar to assign which allows us to assign even unassigned:\nassign' : Location → Assignment → Store → Store\n= λl1αs . λl2 . if (same-location? l1 l2) then α else (fetch l2 s) fi\nIf a store operation modified location l, the undo function for it can be obtained by calling make-undofun on\nl and the old assignment for l. All the undo functions that you write in this problem must be obtained\nby calling make-undofun with the appropriate arguments.\nNow, guess what?, Ben went away to deliver a better Internet and grab some more billions, and you\nwere assigned to finish his job.\na. [10 points] Write the meaning function clause for E [(undo-once!) ].\nSolution:\nE [(undo-once!) ] =\nλeksh . matching h\n. t . hrest ] (k (Unit 7→Value unit) (t s) hrest)\n. [ ]StoreTransform ] (k (Unit 7→Value unit) s h)\nendmatching\nWe specially treat the case of an enpty stack of undo functions: when there is nothing to undo,\nundo-once! does nothing.\nb. [10 points] Write a revised version for E [(primop cell-set! E1 E2) ].\nSolution:\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[ ]\nE [(primop cell-set! E1 E2) ] =\nλek . (E [E1 ] e (test-location (λl . (E [E2 ] e\n(λvsh . (k (Unit 7→Value unit)\n(assign l v s )\n(make-undofun l (fetch l s) ) . h )))))))\nThe store that is passed to k is, as previously, the store obtained by assigning v to location l; we add\nto the head of the stack of store transformers an undo function that restores the old assignment for l.\nc. [10 points] Write a revised version for E [(cell E) ]. Note: we want to be able to undo even cell creation\noperations. That is, the following program must end with an error:\n(let ((c (cell 0)))\n(begin\n(undo-once!)\n(primop cell-ref c)))\nSolution:\nE [(cell E) ] =\nλek . (E [E ] e (λvsh . ((λl . (k (Location 7→Value l)\n(assign l v s)\n(make-undofun l (Unassigned 7→Assignment unassigned)) . h ))\n(fresh-loc s) ))))\nUndoing a cell allocation is done by assigning back unassigned to the cell location l. Now, that cell is\nfree to be allocated again! Calling (λl . . . .) on (fresh-loc s) is just a trick to avoid us writing (fresh-loc s)\nthree times (it's like the desugaring for let in FL).\n\n[\n]\n[\n]\nProblem 4: Denotational Semantics: Control [30 points]\nSam Antics of eFLK.com wants to cash in on the election year media bonanza by introducing a new feature\ninto standard FLK!:\n(elect Epres Evp) ;\n;\n;\n;\n(reelect) ;\n;\n;\n(impeach) ;\n;\n;\nFor example:\nevaluates to Epres unless impeach\nis evaluated within Epres, in which\ncase evaluates to Evp. If impeach is\nevaluated within Evp, signals an error.\nif evaluated within Epres of (elect Epres Evp),\ngoes back to the beginning of elect.\notherwise, signals an error.\nif evaluated within Epres of (elect Epres Evp),\ncauses the expression to evaluate to Evp.\notherwise, signals an error.\n(let ((scandals (primop cell 0)))\n(elect (if (< (primop cell-ref scandals) 5)\n(begin (primop cell-set! (+ (primop cell-ref scandals) 1))\n(reelect))\n(impeach))\n(* (primop cell-ref scandals) 2)))\n⇒ 10\nYou are hired by eFLK.com to modify the standard denotational semantics of FLK! to produce FLK! 2000\nPresidential Edition (TM). To get you started, Sam tells you that he has added the following domains:\nr ∈ Prescont = Cmdcont\ni ∈ Vpcont = Cmdcont\nHe also changed the signature of the meaning function:\nE : Exp → Environment → Prescont → Vpcont → Expcont → Cmdcont\na. [9 points] give the meaning function for (elect Epres Evp).\nSolution:\nE [[(elect Epres Evp)]] =\nλerik . (fixCmdcont (λr1 . E [Epres ] e r1 (λs . E [Evp ] e\n(error-cont cannot-reelect-vp)\n(error-cont cannot-impeach-vp) k) k))\nb. [7 points] give the meaning function for (reelect).\nSolution:\nE [[(reelect)]] = λerik . r\n\nc. [7 points] give the meaning function for (impeach).\nSolution:\nE [[(impeach)]] = λerik . i\nd. [7 points] using the meaning functions you defined, show that (elect (reelect) 1) is equivalent to ⊥.\nSolution:\nE [[(elect (reelect) 1)]] =\nλerik . (fixCmdcont (λr1 . E [[(reelect)]] e r1 (λs . E [[1]] e\n(error-cont cannot-reelect-vp)\n(error-cont cannot-impeach-vp) k) k))\n⇒\nE [[(elect (reelect) 1)]] =\nλerik . (fixCmdcont (λr1 . (λerik . r) e r1 (λs . E [[1]] e\n(error-cont cannot-reelect-vp)\n(error-cont cannot-impeach-vp) k) k))\n⇒\nE [[(elect (reelect) 1)]] = λerik . (fixCmdcont (λr1 . r1))\n⇒\nE [[(elect (reelect) 1)]] = ⊥"
    },
    {
      "category": "Resource",
      "title": "20.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/42df9c62648b09819119228da2661548_20.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n2002 Midterm\nThere are four problems on this examination. They are followed by an appendix that contains reference\nmaterial from the course notes. The appendix contains no problems; it is just a handy reference.\nYou will have eighty-five minutes in which to work the problems. Some problems are easier than others:\nread all problems before beginning to work, and use your time wisely!\nThis examination is open-book: you may use whatever reference books or papers you have brought to class.\nThe number of points awarded for each problem is placed in brackets next to the problem number. There\nare 100 points total on the exam.\nDo all written work in your examination booklet -- we will not collect the examination handout itself; you\nwill only be graded for what appears in your examination booklet. It will be to your advantage to show\nyour work -- we will award partial credit for incorrect solutions that make use of the right techniques.\nIf you feel rushed, be sure to write a brief statement indicating the key idea you expect to use in your\nsolutions. We understand time pressure, but we can't read your mind.\nThis examination has text printed on only one side of each page. Rather than flipping back and forth be-\ntween pages, you may find it helpful to rip pages out of the exam so that you can look at more than one\npage at the same time.\nContents\nProblem 1: Short Answer [18 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 2: Operational Semantics: [18 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 3: Denotational Semantics: [34 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 4: Control [30 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix A: PostFix Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix B: PostFix SOS from Chapter 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix C: Standard Semantics of FLK! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nThe figures in the Appendix are very similar to the ones in the course notes. Some bugs have been fixed,\nand some figures have been simplified to remove parts inessential for this exam. You will not be marked\ndown if you use the corresponding figures in the course notes instead of the appendices.\n\nProblem 1: Short Answer [18 points]\nEvaluate the following expressions in the given models. If the expression evaluates to an error, say what\nkind of error it is.\n(let ((x 1))\n(let ((f (lambda (y) (+ x y))))\n(let ((x 2))\n(f 1))))\na. [2 points] static scoping, call by value\nb. [2 points] dynamic scoping, call by value\n(let ((f (lambda () 1))\n(g (lambda () (f))))\n(let ((f (lambda () 2)))\n(g)))\nc. [2 points] static scoping, call by value\nd. [2 points] dynamic scoping, call by name\n(let ((x 0))\n(let ((f (lambda (y) (/ y x))))\n(let ((x 1))\n(set! f (lambda (y) (/ y x))))\n(let ((x 2))\n(f x))))\ne. [2 points] static scoping, call by value\nf. [2 points] dynamic scoping, call by value\n(let ((x (/ 1 0))\n(y 0))\n(let ((z (begin (set! y (+ y 1)) 5)))\n((lambda (x) (x (x x)))\n(lambda (x) (+ z y z y)))))\ng. [2 points] static scoping, call by name\nh. [2 points] static scoping, call by value\ni. [2 points] static scoping, call by need\n\nProblem 2: Operational Semantics: [18 points]\nBen Bitdiddle's company, which sells commercial PostFix implementations, has been hard-hit by the In\nternet stock bust and has sent him off to MIT to bring back new commercializable technology. Ben Bitdiddle\nhas been learning about functional programming, and while he still prefers PostFix, he is intrigued by the\nnotion of currying. He proposes two new PostFix constructs that permit creating and taking apart PostFix\nprocedures. The constructs are called pack and unpack.\n- pack expects the first value on the stack to be a number n, and it expects there to be at least n more\nvalues on the stack. It packages together the next n values on the stack, cn, . . . , c1, as a command\nsequence C = (c1 . . . cn) and pushes C on the stack.\n- unpack expects the first value on the stack to be a command sequence C = (c1 . . . cn). It pushes\nc1, . . . , cn, n on the stack in that order.\nIf the preconditions are not met, the operational semantics gets stuck.\nunpack permits the PostFix stack to contain commands, which was previously impossible. For example,\nconsider the following PostFix program:\n(N3 N2 N1 (add add) exec) ⇒ N1 + N2 + N3\nWe can think of (add add) as a procedure of three arguments that adds N1, N2, and N3. Using unpack\nand pack, we can write a currying procedure that takes a three-argument procedure, N1, and N2, and\noutputs a procedure that takes one argument N3 and outputs N1 + N2 + N3. The currying procedure is\n(unpack 2 add pack) and it works as follows:\n(N2 N1 (add add) (unpack 2 add pack) exec) ⇒ (N2 N1 add add)\nBen's company has built proprietary optimization technology that can convert this command sequence to\n(N4 add), where N4 = N1 + N2. Together, these two innovations promise a remarkable improvement in\nPostFix efficiency.\na. [5 points] Give a rewrite rule for unpack.\nb. [5 points] Give a rewrite rule for pack.\nc. [8 points] In addition to performing partial evaluation, Ben would like to be able to reuse its results;\nafter all, procedures that can only be called once are of limited use. Ben proposes to add a restricted\nform of dup to PostFix+{unpack, pack}; the restricted dup may only be used immediately after pack.\nDo all such programs terminate? Argue briefly: give either an energy function or a counterexample.\n\nProblem 3: Denotational Semantics: [34 points]\nYOUR ANSWERS TO THIS PROBLEM SHOULD BE BASED ON THE STANDARD DENOTATIONAL SE\nMANTICS FOR FLK! AS PRESENTED IN APPENDIX C.\nBen Bitdiddle enjoys the convenience of short-circuiting operators and has a proposal for making them\neven more powerful.\nA standard short-circuiting logical operator evaluates only as many of its operands as necessary; it\nevaluates its arguments in left-to-right order, stopping as soon as it evaluates an argument that determines\nthe value of the entire expression. For instance, if and is a short-circuiting operator, then the following\nprogram evaluates to #f without raising an error:\n(and #f (= 0 (/ 1 0)))\nHowever, reversing the order of the expressions leads to an error:\n(and (= 0 (/ 1 0)) #f)\nBen Bitdiddle reasons that the second expression, too, should evaluate to #f. After all, one of the\noperands evaluates to #f, and that determines the value of the entire expression. He proposes a very-short\ncircuiting operator nd-and (non-deterministic and) such that if either operand evaluates to false, then only\nthat operand is evaluated; otherwise, both operands are evaluated. His goals are:\n- The expression errs or infinite-loops only if at least one of the operands does, and the other expression\ndoes not evaluate to #f. (Hint: infinite loops, errors, and concurrency are not the main point of this\nproblem.)\n- The value of the entire expression is the and of all the visibly evaluated operands, where a visibly\nexecuted operand is one whose side effects have been performed on the resulting store.\n- The entire expression evaluates to #t if and only if both operands are visibly evaluated (because both\noperands must be evaluated to achieve that result).\n- The entire expression evaluates to #f if and only if exactly one expression is visibly evaluated.\nAlyssa P. Hacker does not believe Ben's goals are achievable. She says she can satisfy the first two goals\nplus either of the last two goals, but not all four goals simultaneously.\na. [6 points] Informally describe the operational semantics for one of the possibilities for nd-and that\nsatisfies Alyssa's claim.\nb. [8 points] What is E [[(nd-and E1 E2)]] for the version of nd-and that you described above?\nc. [4 points] Can nd-or (nondeterministic or) be defined in terms of nd-and? Explain briefly.\nd. [3 points] What does the following FLAVAR! program evaluate to?\n(let ((a 2))\n(let ((and-result (nd-and (= a 3)\n(begin (set! a 3) #t))))\n(list and-result a)))\ne. [3 points] What does the following FLAVAR! program evaluate to?\n(let ((a 2))\n(let ((and-result (nd-and (= a 2)\n(begin (set! a 3) #t))))\n(list and-result a)))\n\nf. [6 points] Demonstrate that Alyssa's assertion is correct. Given your semantics for nd-and, write an\nnd-and expression that fails one of the last two constraints. The expression should either definitely\nevaluate to #t, but with the side effects of just one of its arguments; or it should definitely evaluate to\n#f, but with the side effects of both arguments.\ng. [4 points] Suggest a restriction (to FLAVAR!, FLK!, or nd-and) that achieves all of Ben's goals.\n\n[\n]\n[\n]\n[\n]\nProblem 4: Control [30 points]\nYOUR ANSWERS TO THIS PROBLEM SHOULD BE BASED ON THE STANDARD DENOTATIONAL SE\nMANTICS FOR FLK! AS PRESENTED IN APPENDIX C.\nAfter hearing that Ben Bitdiddle's MIT experience led him to experiment with currying (Problem 2), the\npresident of Ben's company exclaimed, \"I won't be caught selling buggy whips, curry combs, or other\nhorse products in the modern economy!\" and sent Ben off to New Jersey to learn some more practical\nprogramming constructs.\nBen noted that FLK! is missing the while loop, which is standard in other languages, and reasons that\nadding it will reduce programmers' resistance to FLK!.\nBen proposes three new constructs -- while, continue, and break -- to ensure that C programmers feel\nat home programming in FLAVAR!. The command (while Econd Ebody Efinal) behaves as follows. If Econd\nis true, then evaluate Ebody and loop back to re-evaluate the entire while form (starting with Econd again).\nIf Econd is false, then the value of the entire while expression is the result of evaluating Efinal.\nWithin Ebody , (continue) preempts execution of the smallest enclosing Ebody and returns to the top of\nthat loop.\nFinally, (break E3) forces the entire while expression to terminate with the value E3 (without evaluat\ning Efinal).\nConsider the following procedure:\n(define f\n(lambda (xval)\n(let ((x (cell xval)))\n(while (begin (cell-set! x (+ (cell-ref x) 1)) (< (cell-ref x) 0))\n(begin (cell-set! x (+ (cell-ref x) 1))\n(if (< (cell-ref x) 0)\n(continue)\n(break 42)))\n(- (cell-ref! x) 1)))))\nEvaluation proceeds as follows:\n(f -10) ⇒ 42\n(f -11) ⇒ -1\nIn order to provide a meaning for the new commands, we must change the meaning function E and add\na new domain:\nE : Exp → Environment → Expcont → ContCont → BreakCont → Cmdcont\nc ∈ ContCont = Expcont\nb ∈ BreakCont = Expcont\na. [14 points] What is E [(while Econd Ebody Efinal) ]?\nb. [8 points] What is E [(continue) ]?\nc. [8 points] What is E [(break E) ]?\n\nAppendix A: PostFix Grammar\nP ∈ Program\nQ ∈ Commands\nC ∈ Command\nA ∈ Arithmetic-operator = {add, sub, mul, div}\nR ∈ Relational-operator = {lt, eq, gt}\nN ∈ Intlit = {. . ., -2, -1, 0, 1, 2, . . .}\nP\n::=\n(Q)\n[Program]\nQ\n::=\nC*\n[Command-sequence]\nC\n::=\nN\n[Integer-literal]\n|\npop\n[Pop]\n|\nswap\n[Swap]\n|\nA\n[Arithmetic-op]\n|\nR\n[Relational-op]\n|\nsel\n[Select]\n|\nexec\n[Execute]\n|\n(Q)\n[Executable-sequence]\nFigure 1: The S-Expression Grammar for PostFix\n\n[\n[\n[\nAppendix B: PostFix SOS from Chapter 3\nC, F , I and O for our PostFix SOS are given by:\nC = Commands × Stack\nF = {[ ]Command} × Stack\nI : Program →C\n= λP . matching P\n. (Q) ] hQ, [ ]Valuei\nendmatching\nO : F → Answer\n= λh[ ]Command, Si . matching S\n. V . S0 ] (Value 7→Answer V)\n. [ ] ] (Error 7→Answer error)\nendmatching\nhN . Q, Si ⇒hQ, N . Si\n[numeral]\nh(Qexec). Qrest, Si ⇒hQrest, Qexec . Si\n[executable]\nhpop. Q, Vtop . Si ⇒hQ, Si\n[pop]\nhswap. Q, V1 . V2 . Si ⇒hQ, V2 . V1 . Si\n[swap]\nhsel. Qrest, Vfalse . Vtrue .0. Si ⇒hQrest, Vfalse . Si\n[sel-false]\nhsel. Qrest, Vfalse . Vtrue . Ntest . Si ⇒hQrest, Vtrue . Si\n[sel-true]\nwhere Ntest 6≡ 0\nhexec. Qrest, Qexec . Si ⇒hQexec @ Qrest, Si\n[execute]\nhA . Q, N1 . N2 . Si ⇒hQ, Nresult . Si\nwhere Nresult ≡ (calculate A N2 N1)\n[arithop]\nand ¬ ((A ≡ div) ∧ (N1 ≡ 0))\nhR . Q, N1 . N2 . Si ⇒hQ, 1. Si\n[relop-true]\nwhere (compare R N2 N1)\nhR . Q, N1 . N2 . Si ⇒hQ, 0. Si\n[relop-false]\nwhere ¬ (compare R N2 N1)\nFigure 2: Rewrite rules defining the transition relation for PostFix.\n\n[\n[\n[\nAppendix C: Standard Semantics of FLK!\nv ∈ Value = Unit + Bool + Int + Sym + Pair + Procedure + Location\nk ∈ Expcont = Value → Cmdcont\nγ ∈ Cmdcont = Store → Expressible\nExpressible = (Value + Error)⊥\nError = Sym\np ∈ Procedure = Denotable → Expcont → Cmdcont\nd ∈ Denotable = Value\ne ∈ Environment = Identifier → Binding\nβ ∈ Binding = (Denotable + Unbound)⊥\nUnbound = {unbound}\ns ∈ Store = Location → Assignment\nl ∈ Location = Nat\nα ∈ Assignment = (Storable + Unassigned)⊥\nσ ∈ Storable = Value\nUnassigned = {unassigned}\ntop-level-cont : Expcont\n= λv . λs . (Value 7→Expressible v)\nerror-cont : Error → Cmdcont\n= λy . λs . (Error 7→Expressible y)\nempty-env : Environment = λI . (Unbound 7→Binding unbound)\ntest-boolean : (Bool → Cmdcont) → Expcont\n= λf . (λv . matching v\n. (Bool 7→Value b) ] (f b)\n. else (error-cont non-boolean)\nendmatching )\nSimilarly for:\ntest-procedure : (Procedure → Cmdcont) → Expcont\ntest-location : (Location → Cmdcont) → Expcont\netc.\nensure-bound : Binding → Expcont → Cmdcont\n= λβ k . matching β\n. (Denotable 7→Binding v) ] (k v)\n. (Unbound 7→Binding unbound) ] (error-cont unbound-variable)\nendmatching\nSimilarly for:\nensure-assigned : Assignment → Expcont → Cmdcont\nFigure 3: Semantic algebras for standard semantics of strict CBV FLK!.\n\n[\nsame-location? : Location → Location → Bool = λl1l2 . (l1 =Nat l2)\nnext-location : Location → Location = λl . (l +Nat 1)\nempty-store : Store = λl . (Unassigned 7→Assignment unassigned)\nfetch : Location → Store → Assignment = λls . (s l)\nassign : Location → Storable → Store → Store\n= λl1σ s . λl2 . if (same-location? l1 l2)\nthen (Storable 7→Assignment σ)\nelse (fetch l2 s)\nfresh-loc : Store → Location = λs . (first-fresh s 0)\nfirst-fresh : Store → Location → Location\n= λsl . matching (fetch l s)\n. (Unassigned 7→Assignment unassigned) ] l\n. else (first-fresh s (next-location l))\nendmatching\nlookup : Environment → Identifier → Binding = λeI . (e I)\nFigure 4: Store helper functions for standard semantics of strict CBV FLK!.\n\n[ ]\n[ ]\n[ ]\n[ ]\n[ ]\n[\n]\n[ ]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[ ]\n[\n]\n[\n]\n[\n]\n[\n]\n[ ]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n[\n]\n[\nT L : Exp → Expressible\nE : Exp → Environment → Expcont → Cmdcont\nL : Lit → Value ; Defined as usual\nT L [E ] = E [E ] empty-env top-level-cont empty-store\nE [L ] = λek . k L [L ]\nE [I ] = λek . ensure-bound (lookup e I) k\nE [(proc I E) ] = λek . k (Procedure 7→Value (λdk 0 . E [E ] [I : d]e k 0))\nE [(call E1 E2) ] = λek . E [E1 ] e (test-procedure (λp . E [E2 ] e (λv . p v k)))\nE [(if E1 E2 E3) ] =\nλek . E [E1 ] e (test-boolean (λb . if b then E [E2 ] e k else E [E3 ] e k))\nE [(pair E1 E2) ] = λek . E [E1 ] e (λv1 . E [E2 ] e (λv2 . k (Pair 7→Value hv1, v2i)))\nE [(cell E) ] = λek . E [E ] e (λvs . k (Location 7→Value (fresh-loc s))\n(assign (fresh-loc s) v s))\nE [(begin E1 E2) ] = λek . E [E1 ] e (λvignore . E [E2 ] e k)\nE [(primop cell-ref E) ] = λek . E [E ] e (test-location (λls . ensure-assigned (fetch l s) k s))\nE [(primop cell-set! E1 E2) ]\n= λek . E [E1 ] e (test-location (λl . E [E2 ] e (λvs . k (Unit 7→Value unit) (assign l v s))))\nE [(rec I E) ] = λeks . let f = fixExpressible (λa . E [E ] [I : (extract-value a)] e top-level-cont s)\nmatching f\n. (Value 7→Expressible v) ] E [E ] [I : v] e k s\n. else f\nendmatching\nextract-value : Expressible → Binding\n= λa . matching a\n. (Value 7→Expressible v) ] (Denotable 7→Binding v)\n. else ⊥Binding\nendmatching\nFigure 5: Valuation clauses for standard semantics of strict CBV FLK!."
    },
    {
      "category": "Resource",
      "title": "21.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/8da2b2b1e8b7e7f6c63261139bc9c67e_21.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n2002 Midterm Solutions\nProblem 1: Short Answer [18 points]\nEvaluate the following expressions in the given models. If the expression evaluates to an error, say what\nkind of error it is.\n(let ((x 1))\n(let ((f (lambda (y) (+ x y))))\n(let ((x 2))\n(f 1))))\na. [2 points] static scoping, call by value\nSolution: 2\nb. [2 points] dynamic scoping, call by value\nSolution: 3\n(let ((f (lambda () 1))\n(g (lambda () (f))))\n(let ((f (lambda () 2)))\n(g)))\nc. [2 points] static scoping, call by value\nSolution: error, f is not bound\nd. [2 points] dynamic scoping, call by name\nSolution: 2\n(let ((x 0))\n(let ((f (lambda (y) (/ y x))))\n(let ((x 1))\n(set! f (lambda (y) (/ y x))))\n(let ((x 2))\n(f x))))\ne. [2 points] static scoping, call by value\nSolution: 2\n\nf. [2 points] dynamic scoping, call by value\nSolution: 1\n(let ((x (/ 1 0))\n(y 0))\n(let ((z (begin (set! y (+ y 1)) 5)))\n((lambda (x) (x (x x)))\n(lambda (x) (+ z y z y)))))\ng. [2 points] static scoping, call by name\nSolution: 13\nh. [2 points] static scoping, call by value\nSolution: error, divide by 0\ni. [2 points] static scoping, call by need\nSolution: 12\n\nProblem 2: Operational Semantics: [18 points]\nBen Bitdiddle's company, which sells commercial PostFix implementations, has been hard-hit by the In\nternet stock bust and has sent him off to MIT to bring back new commercializable technology. Ben Bitdiddle\nhas been learning about functional programming, and while he still prefers PostFix, he is intrigued by the\nnotion of currying. He proposes two new PostFix constructs that permit creating and taking apart PostFix\nprocedures. The constructs are called pack and unpack.\n- pack expects the first value on the stack to be a number n, and it expects there to be at least n more\nvalues on the stack. It packages together the next n values on the stack, cn, . . . , c1, as a command\nsequence C = (c1 . . . cn) and pushes C on the stack.\n- unpack expects the first value on the stack to be a command sequence C = (c1 . . . cn). It pushes\nc1, . . . , cn, n on the stack in that order.\nIf the preconditions are not met, the operational semantics gets stuck.\nunpack permits the PostFix stack to contain commands, which was previously impossible. For example,\nconsider the following PostFix program:\n(N3 N2 N1 (add add) exec) ⇒ N1 + N2 + N3\nWe can think of (add add) as a procedure of three arguments that adds N1, N2, and N3. Using unpack\nand pack, we can write a currying procedure that takes a three-argument procedure, N1, and N2, and\noutputs a procedure that takes one argument N3 and outputs N1 + N2 + N3. The currying procedure is\n(unpack 2 add pack) and it works as follows:\n(N2 N1 (add add) (unpack 2 add pack) exec) ⇒ (N2 N1 add add)\nBen's company has built proprietary optimization technology that can convert this command sequence to\n(N4 add), where N4 = N1 + N2. Together, these two innovations promise a remarkable improvement in\nPostFix efficiency.\na. [5 points] Give a rewrite rule for unpack.\nSolution:\nhunpack. Q, (V1 V2 ... Vn). Si ⇒hQ, n . Vn...V1 . Si\n[unpack]\nb. [5 points] Give a rewrite rule for pack.\nSolution:\nhpack. Q, n . Vn...V1 . Si ⇒hQ, (V1 V2 ... Vn). Si\n[pack]\nc. [8 points] In addition to performing partial evaluation, Ben would like to be able to reuse its results;\nafter all, procedures that can only be called once are of limited use. Ben proposes to add a restricted\nform of dup to PostFix+{unpack, pack}; the restricted dup may only be used immediately after pack.\nDo all such programs terminate? Argue briefly: give either an energy function or a counterexample.\nSolution: PostFix+{unpack, pack, duprestricted} programs may not terminate. Recall that the canonical\nnon-terminating PostFix+dup program is (dup exec) dup exec. Notice that unpack and pack are\nduals. The following program does not terminate.\n(unpack pack dup exec) unpack pack dup exec\nOne can also write unrestricted dup in terms of restricted dup:\ndup = 1 pack dup unpack pop swap unpack pop\n\n[\n]\n[\n]\n[\n]\n[\n]\nProblem 3: Denotational Semantics: [34 points]\nBen Bitdiddle enjoys the convenience of short-circuiting operators and has a proposal for making them\neven more powerful.\nA standard short-circuiting logical operator evaluates only as many of its operands as necessary; it\nevaluates its arguments in left-to-right order, stopping as soon as it evaluates an argument that determines\nthe value of the entire expression. For instance, if and is a short-circuiting operator, then the following\nprogram evaluates to #f without raising an error:\n(and #f (= 0 (/ 1 0)))\nHowever, reversing the order of the expressions leads to an error:\n(and (= 0 (/ 1 0)) #f)\nBen Bitdiddle reasons that the second expression, too, should evaluate to #f. After all, one of the\noperands evaluates to #f, and that determines the value of the entire expression. He proposes a very-short\ncircuiting operator nd-and (non-deterministic and) such that if either operand evaluates to false, then only\nthat operand is evaluated; otherwise, both operands are evaluated. His goals are:\n- The expression errs or infinite-loops only if at least one of the operands does, and the other expression\ndoes not evaluate to #f. (Hint: infinite loops, errors, and concurrency are not the main point of this\nproblem.)\n- The value of the entire expression is the and of all the visibly evaluated operands, where a visibly\nexecuted operand is one whose side effects have been performed on the resulting store.\n- The entire expression evaluates to #t if and only if both operands are visibly evaluated (because both\noperands must be evaluated to achieve that result).\n- The entire expression evaluates to #f if and only if exactly one expression is visibly evaluated.\nAlyssa P. Hacker does not believe Ben's goals are achievable. She says she can satisfy the first two goals\nplus either of the last two goals, but not all four goals simultaneously.\na. [6 points] Informally describe the operational semantics for one of the possibilities for nd-and that\nsatisfies Alyssa's claim.\nSolution: There are multiple solutions to this problem. Here is one of them.\nLet s0 be the initial store.\nEvaluate E1 in s0, giving hv, s1i. If v is false, return hv, s1i.\nOtherwise, evaluate E2 in s0, giving hv, s2i. If v is false, return hv, s2i.\nOtherwise, evaluate E2 in s1, giving hv, s3i. Return hv, s3i.\n(This might be false, even though both operands have been evaluated.)\nb. [8 points] What is E [[(nd-and E1 E2)]] for the version of nd-and that you described above?\nSolution:\nE [(nd-and E1 E2) ]\n= λeks0 . E [E1 ] e (λv1 . if ¬v1\nthen (k false)\nelse E [E2 ] e (λv2 . if ¬v2\nthen (k false)\nelse E [E1 ] e k)\ns0)\ns0\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nAlternately, with explicit stores:\nE [(nd-and E1 E2) ]\n= λeks0 . E [E1 ] e (λv1s1 . if ¬v1\nthen (k false s1)\nelse E [E2 ] e (λv2s2 . if ¬v2\nthen (k false s2)\nelse E [E1 ] e k s2)\ns0)\ns0\nc. [4 points] Can nd-or (nondeterministic or) be defined in terms of nd-and? Explain briefly.\nSolution: Yes.\nDexp [(nd-or E1 E2) ]\n= (not (nd-and (not E1) (not E2)))\nBecause not preserves nontermination and errors, the semantics are as desired: if either E1 or E2\nevaluates to true, the other is not evaluated.\nd. [3 points] What does the following FLAVAR! program evaluate to?\n(let ((a 2))\n(let ((and-result (nd-and (= a 3)\n(begin (set! a 3) #t))))\n(list and-result a)))\nSolution: E1 evaluates to false, and E2 evaluates to true. The entire expression evaluates to (#f 2).\ne. [3 points] What does the following FLAVAR! program evaluate to?\n(let ((a 2))\n(let ((and-result (nd-and (= a 2)\n(begin (set! a 3) #t))))\n(list and-result a)))\nSolution: E1 in isolation evaluates to true, and E2 evaluates to true. The entire expression evaluates\nto either (#t 3) or (#f 3), depending on the order of evaluation.\nf. [6 points] Demonstrate that Alyssa's assertion is correct. Given your semantics for nd-and, write an\nnd-and expression that fails one of the last two constraints. The expression should either definitely\nevaluate to #t, but with the side effects of just one of its arguments; or it should definitely evaluate to\n#f, but with the side effects of both arguments.\nSolution: This expression evaluates to false, but evaluates both arguments:\n(let ((a #t) (b #t))\n(nd-and (begin (set! b #f) a)\n(begin (set! a #f) b)))\ng. [4 points] Suggest a restriction (to FLAVAR!, FLK!, or nd-and) that achieves all of Ben's goals.\nSolution: Disallow uses of set!.\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nProblem 4: Control [30 points]\nAfter hearing that Ben Bitdiddle's MIT experience led him to experiment with currying (Problem 2), the\npresident of Ben's company exclaimed, \"I won't be caught selling buggy whips, curry combs, or other\nhorse products in the modern economy!\" and sent Ben off to New Jersey to learn some more practical\nprogramming constructs.\nBen noted that FLK! is missing the while loop, which is standard in other languages, and reasons that\nadding it will reduce programmers' resistance to FLK!.\nBen proposes three new constructs -- while, continue, and break -- to ensure that C programmers feel\nat home programming in FLAVAR!. The command (while Econd Ebody Efinal) behaves as follows. If Econd\nis true, then evaluate Ebody and loop back to re-evaluate the entire while form (starting with Econd again).\nIf Econd is false, then the value of the entire while expression is the result of evaluating Efinal.\nWithin Ebody , (continue) preempts execution of the smallest enclosing Ebody and returns to the top of\nthat loop.\nFinally, (break E3) forces the entire while expression to terminate with the value E3 (without evaluat\ning Efinal).\nConsider the following procedure:\n(define f\n(lambda (xval)\n(let ((x (cell xval)))\n(while (begin (cell-set! x (+ (cell-ref x) 1)) (< (cell-ref x) 0))\n(begin (cell-set! x (+ (cell-ref x) 1))\n(if (< (cell-ref x) 0)\n(continue)\n(break 42)))\n(- (cell-ref! x) 1)))))\nEvaluation proceeds as follows:\n(f -10) ⇒ 42\n(f -11) ⇒ -1\nIn order to provide a meaning for the new commands, we must change the meaning function E and add\na new domain:\nE : Exp → Environment → Expcont → ContCont → BreakCont → Cmdcont\nc ∈ ContCont = Expcont\nb ∈ BreakCont = Expcont\na. [14 points] What is E [(while Econd Ebody Efinal) ]?\nSolution: Here is a version that re-evaluates the condition after (continue), and where (break) or\n(continue) in Econd break out of the while form to which Econd belongs:\nE [(while Econd Ebody Efinal) ]\n= λekcb . fixCmdcont λl . E [Econd ] e (λv . if v\nthen E [Ebody ] e (λv . l) (λv . l) k\nelse E [Efinal ] e k c b)\n(λv . l) k\nHere is a version that does not re-evaluate the condition after (continue), and where (break) or\n(continue) in Econd break out of a while form that encloses the one to which Econdbelongs:\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nE [(while Econd Ebody Efinal) ]\n= λekcb . fixCmdcont λl . E [Econd ] e (λv . if v\nthen fixCmdcont (λj . E [Ebody ] e (λv . l) (λv . j) k)\nelse E [Efinal ] e k c b)\nc b\nb. [8 points] What is E [(continue) ]?\nSolution: E [(continue) ] = λekcb . (c unit)\nc. [8 points] What is E [(break E) ]?\nSolution: E [(break E) ] = λekcb . E [E ] e b c b"
    },
    {
      "category": "Resource",
      "title": "32.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/4aab7b982a3611fcdef9918421869aec_32.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n6.821 Jeopardy: The Home Version\nThe game that turns 6.821 into 6.82fun!\nThis is the home version of the 6.821 Jeopardy game played in class. It includes questions and answers\nfor all categories.\n\nRound 1: Jeopardy\nDynamic Semantics\n100 This parameter passing mechanism is indicated by the following transition rules:\nhE 0, si ⇒hE0\n0 , s0i\nh(E0 E1), si ⇒h(E0\n0 E1), s0i\nhE1, si ⇒hE1\n0 , s0i\nh(V E1), si ⇒h(V E1\n0 ), s0i\nh((lambda (I) Eb) V ), si ⇒h[V/I]Eb, si\n200 This is the value of the following expression in a dynamically scoped version of FL:\n(let ((make-sub (lambda (x)\n(lambda (n) (- n x))))\n(apply (lambda (f x) (f x))))\n(let ((x 1))\n(apply (make-sub 20) 300)))\n300 In a version of FL! supporting label and jump, this is the value of the following expression.\n(let ((r (cell 1)))\n(let ((top (label x x)))\n(if (> (cell-ref r) 10)\n(cell-ref r)\n(begin\n(cell-set! r (* 2 (cell-ref r)))\n(jump top)))))\n400 In a language with termination semantics for dynamic exceptions, this is the value of:\n(handle (err (y) (+ y 200))\n(let ((f (lambda (x)\n(+ (raise err x) 1000))))\n(handle (err (z) (+ z 500))\n(f 4))))\n500 Suppose language L has a direct semantics with the following:\nProcedure = Denotable* → Store → Result\nE : Exp → Environment → Store → Result\n\nIf the language L is call-by-name, this is the definition of the Denotable domain.\nType Reconstruction\n100 Can Hindley-Milner type reconstruction reconstruct a type for the following SCHEME/R expression?\nExplain. (Give the type or explain why the algorithm cannot reconstruct one.)\n(lambda (f)\n(let ((g f))\n(if (g #t) (g 1) (g 2))))\n200 This is the type reconstructed for the following SCHEME/R expression.\n(lambda (g f)\n(lambda (x) (g (f x))))\n300 Consider the following definition of the Y operator in SCHEME/R. Is its type reconstructible? Explain.\n(define y\n(lambda (g)\n(let ((s (lambda (x) (g (x x)))))\n(s s))))\n400 List all of the following expressions that are reconstructible in SCHEME/R:\n1. (letrec\n((id (lambda (a) a))\n(test (lambda ()\n(if (id #t) (id 1) 2))))\n(test))\n2. (letrec ((id (lambda (a) a))\n(test (lambda (y)\n(if (id #t) y 2))))\n(test (id 1)))\n3. (letrec ((id (lambda (a) a))\n(test (lambda (x y)\n(if x y 2))))\n(test (id #t) (id 1)))\nThis type schema is bound to x in the body of the following SCHEME/R expression.\n(letrec ((x (lambda () (x))))\nbody)\nPragmatics\n\n100 This compiler pass must precede closure conversion with flat environments, but need not precede\nclosure conversion with nested environments.\n200 After CPS conversion, this is the syntactic form of the continuation for a tail call in the source program.\n300 Suppose a language has the construct (value E) that evaluates E to a symbol, and returns the value\nbound to that symbol. E.g.,\n(let ((x (symbol a))\n(a 3))\n(value x))\n; Value = 3\nWhat change in the compiler would have to be made to environment representations in order to accomodate\nthis construct?\n400 If a SCHEME/R program type checks, will the program resulting from CPS conversion also type check?\nExplain.\n500 What additional run-time support is needed for SCHEME/XSP's plambda expression? Be specific.\nProgram Translations\n100 Under this variable scoping mechanism for FL, the following desugaring is invalid.\n(lambda (I1 I2) E)\n⇒\n(lambda (I1) (lambda (I2) E))\n(Assume all applications of the procedure are appropriately modified.)\n200 Is the following a safe (i.e., semantics-preserving) transformation in a strictly functional language?\nExplain.\n(if E1 E1 E2)\n⇒\n(let ((I1 E1)) (if I1 I1 E2))\n300 Is the following desugaring valid in SCHEME/R? Explain.\n(let ((I1 E1)) E2)\n⇒\n((lambda (I1) E2) E1)\n400 This problem is encountered in using the following two rules in a simplifier for PostFix+{dup}.\n(Q) . exec . S ==> Q @ S\nV . dup . S\n==> V . V . S\n500 Is the following a valid transformation in every functional language? Explain.\n(let ((I1 E1)) E2) ⇒ [E1/I1]E2\n\nTrivia\n100 This OODL (Object Oriented Dynamic Langauge), once backed by Apple Computer, is noted for its\nsophisticated run-time memory management and functional style, including first class and anonymous\nfunctions.\n200 This is widely recognized as the first object-oriented language.\n300 Alan Perlis says that syntactic sugar causes this.\n400 This language designer once quipped that he could be called both by name and by value.\n500 This one of the following is not the title or subtitle of a Steele & Sussman Scheme paper.\na. Lambda the Ultimate Declarative\nb. Lambda the Ultimate GOTO\nc. Lambda the Ultimate Imperative\nd. Lambda the Ultimate Objective\ne. Lambda the Ultimate Opcode\n\n[\n]\n[ ]\n[ ]\nRound 2: Double Jeopardy\nSemantics Fundamentals\n200 Suppose domain A has 4 elements and domain B has 3 elements. There are this many set-theoretic\nfunctions from A to B.\n400 Suppose Bool = {true, false}. There are this many elements in the domain:\n(Bool⊥ × (Bool⊥ + Bool⊥))⊥\n600 What is wrong with the following denotational semantics for a language that supports recursion?\ne ∈ Environment = Identifier → (Expressible + Unbound)\nextend-env : Environment → Identifier → Expressible → Environment\nE : Exp → Environment → (Expressible + Error)\nE [(rec I E) ] =\nλe0 . (E [E ] (fixEnvironment(λe1 . (extend-env e0 I (E [E ] e1)))))\n800 Suppose b ∈ Bool⊥, f ∈ Bool⊥ → Bool⊥, and or is strict boolean disjunction. The following functional\nhas this many fixed points.\nλf . λb . (or b (f b))\n1000 Consider the following domains E and F :\nd\n|\na\nb\nc\n\\ /\n|\nbottom\nbottom\nE\nF\nThere are this many monotonic functions from E to F .\nMemory Management\n200 Could dangling references to freed memory ever cause a program to run out of memory? Explain.\n400 In implementations of dynamically-typed languages, tag bits are often used to encode the types of\nrun-time objects. Even though SCHEME/X is statically typed, every word of memory would still need one\ntag bit. Why?\n600 This many words of memory (including header words) are required to represent the following value\nin the TORTOISE compiler.\n\n(cons 1 (cons 2 (null)))\n800 Write a SCHEME expression that generates a run-time structure that is not collectible by a reference-\ncounting garbage collector.\n1000 Below is the non-zero portion of the lower semispace of a 40-word memory. We represent a tagged\nvalue as integer, tag bit(s). Show the non-zero portion of the upper semispace (starting at address 20) of\nmemory after a stop-and-copy garbage collection is performed with a register containing 4 , 01. We have\nomitted the type field in the header word, so you should assume that all words in the block must be scanned.\nRecall that 0 tags an integer (or header word), and 01 tags a pointer.\nO : 3, 0\n6 : 2, 0\n1 : 4, 0\n7 : 9, 01\n2 : 7, 01\n8 : 0, 01\n3 : 6, 0\n9 : 2, 0\n4 : 1, 0\n10: 4, 01\n5 : 9, 01\n11: 9, 0\nTypes\n200 Consider the set of all syntactically legal SCHEME/R expressions that contain no free variables. This\nis the shortest (in terms of fewest characters) expression in this set that is not well-typed.\n400 Does the following SCHEME/XSP expression type check? Explain.\n(plambda (int)\n(lambda ((x int))\n(+ x 5)))\n600 There are this many distinct values with the following type (assume that our language does not have\nside-effects or divergence).\n(poly (t) (-> (t t t) bool))\n800 This is the SCHEME/XSP type checking rule for applications with one argument: (E0 E1)\n1000 This is the typing rule in SCHEME/R for letrec with a single binding:\n(letrec ((I1 E1)) EB )\n(Recall that Gen(T, A) appropriately forms a type schema given type T and type environment A.)\nProgramming Paradigms\n200 How can a run-time lock system dynamically check for deadlock?\n400 Recall that all PostFix programs terminate. Is it possible to write a PostFix command sequence that\ncomputes the absolute value of a number at the top of the stack? Explain.\n600 What is the value of the following object-oriented programming system expression:\n\n]\n[\n]\n[\n]\n(let ((ob2 (object (method value (self) 2)))\n(ob3 (object (method value (self) 3))))\n(let ((ob5 (object\n(method value (self) 5)\n(method compute (self)\n(send * (send value ob3)\n(send value self))))))\n(send compute (object ob2 ob3 ob5))))\n800 Let S and F be the success and failure continuations. Fill in the desugaring for the pattern matching\noperators.\nDclauseseq[[[], [], V, F ] = ??\nDpat [ , V, S, F ] = ??\nDpatseq [ , [], V, F ] = ??\n1000 List all possible values for the following control-parallel expression:\n(let ((x (cell 3)))\n(let ((thread (fork (cell-set! x\n(+ (cell-ref x)\n(cell-ref x))))))\n(begin (cell-set! x 7)\n(join thread)\n(cell-ref x))))\nPotpourri\n200 In a purely functional programming language, can the meaning of an expression under call-by-value\nsemantics differ from the meaning of the same expression under call-by-name semantics? Explain.\n400 What problem arises if we add the following procedure to a language with references?\nfree : (poly (t)\n(-> ((ref-of t)) unit))\nGiven a reference value, free deallocates the storage occupied by the value pointed to by the reference\nso that it can be reused.\n600 The terms \"bug\" and \"compile\" were coined by this Navy rear admiral who designed COBOL.\n800 Name the (1) parameter-passing mechanism and (2) variable scoping mechanism implied by the fol\nlowing domain definitions and signatures:\nProcedure = Denotable* → Environment → Expcont → Answer\nDenotable = Expcont → Answer\nExpcont = Expressible → Answer\nE : Exp → Environment → Expcont → Answer\n1000 Suppose (pairof T1 T2) is a type constructor for heterogeneous pairs. Give a type T that makes the\nfollowing two types equivalent:\n\na. (recof s (pairof int (pairof bool s)))\nb. (pairof int T)\n\nRound 3: Final Jeopardy\nTypes\nWhat is the reconstructed type for the following SCHEME/R expression?\n(letrec\n((accumulate\n(lambda (combiner seed lst)\n(if (null? lst)\nseed\n(combiner\n(car lst)\n(accumulate combiner\nseed\n(cdr lst)))))))\naccumulate)\n\nAnswers\nRound 1: Jeopardy\nDynamic Semantics\n100 What is call-by-value?\n200 What is 0?\n300 What is 16?\n400 What is 504?\n500 What is Denotable = Store → Result?\nType Reconstruction\n100 No -- the expression uses first-class polymorphism.\n200 (-> ((-> (?b) ?c) (-> (?a) ?b)) (-> (?a) ?c))\n300 No -- self application of a non-generic variable x fails (fails in occurs check).\n400 Only number 3 is reconstructible; in the other cases, id is constrained by the fact that the letrec\nbound variables aren't generic within the right-hand-side expressions.\n500 What is (generic (t) (-> () t))?\nPragmatics\n100 What is Assignment Conversion?\n200 What is an identifier?\n300 Environments must hold names as well as values.\n400 Yes. Basically, each continutation is only used once to return the value of a procedure to the rest of\nthe computation. Thus all the continuations have type (-> (T1) T2) where T1 is the return type of the\nprocedure the continuation is used with and T2 is the result of the entire program.\n500 None. plambda expressions have no run-time aspect -- they are only used during type checking and\nthus the value of a plambda is just the value of its body.\nProgram Translations\n100 What is dynamic scoping? References to I1 within E will not be handled correctly.\n200 No; Name capture of I can occur in E2.\n\n300 No. E could be polymorphic in the first expression, but the desugaring would require first-class poly\nmorphism to support the same semantics.\n400 What is simplifier non-termination?\n500 In call-by-value, doesn't preserve termination. E.g\n(let ((x ((lambda (y) (y y)) (lambda (y) (y y)))))\n3)\nTrivia\n100 What is Dylan?\n200 What is Simula 67?\n300 What is cancer of the semi-colon?\n400 Who is Niklaus Wirth? His name is pronounceable both as \"Vert\" and \"Worth\". Some people go\nfurther and call him \"Nickle's-worth.\"\n500 What is \"Lambda the Ultimate Objective\"?\nRound 2: Double Jeopardy\nSemantics Fundamentals\n200 What is 81? |B||A| = 34 = 81.\n400 What is 19?\n600 The domain Environment isn't pointed, and fix is only well defined over pointed CPOs.\n800 What is 6? Since or is strict, f must map ⊥ to ⊥. Since or is disjunction, it consistent for f to map true to\neither ⊥ or true, and to map false to any element of Bool. Since there are two independent choices for true,\nand three for false, there are six possible fixed points.\n1000 What is 14? Here are the 14 possibilities:\n9 if E⊥ ⇒ F⊥, then each of a and b can map to all 3 elts of F\n4 if E⊥ ⇒ c, then each of a and b can map to c and d\n1 if E⊥ ⇒ d, then each of a and b must map to d\nMemory Management\n200 Yes. In a stop-and-copy garbage collector, all memory pointed to by pointers accessible from the root\nset (including the dangling reference) would be copied over, despite the fact the program explictly freed it.\nSo the memory pointed to by a dangling reference is never actually released by the garbage collector.\n\n400 The single tag bit is used by the garbage collector, not the typing system. It is crucial for distinguishing\npointers from non-pointers.\n600 What is 6? A cons cell has one header word and two field words. The cdr of the first cons cell is a\npointer to a second cons cell, which has a header word and two immediate values in its car and cdr. (null)\nis represented by immediate integer 0.\n800 Reference counting garbage collectors don't collect structures with cycles, so we need to construct a\ncyclic structure. The easiest way to do this in SCHEME is with cells; for example, the following expression\nreturns a reference cell that points to itself.\n(let ((a (cell 0)))\n(begin (cell-set! a a)\na))\nEven if SCHEME did not support side effects, it would still be possible to create cyclic runtime structures\nvia letrec, since a procedures created in a letrec binding has a pointer to itself through the environment.\nTherefore, another cycle-creating expression is:\n(letrec ((f (lambda () (f))))\nf)\nIn fact, any procedure created by letrec, should work, e.g.:\n(letrec ((g (lambda () 3)))\ng)\nHowever, since compiler optimizations might remove the cyclic dependencies in a situation like g, it's safer\nto stick with a truly recursive function like f.\n1000 The non-garbage in the given memory consists of a block A of size 1 that points to a block B of size\n2 whose first slot points to A and whose second slot contains an immediate 9. These two blocks get copied\ninto the first five words of the second semispace as shown below. Note that the second semispace begins at\nlocation 20.\n...\n20: 1, 0\n21: 22, 1\n22: 2, 0\n23: 20, 1\n24: 9, 0\n...\nTypes\n200 What is (1)? (Similar variants have the same length.)\n400 It is not well-typed. + expects two arguments of base type int, but x is of some polymorphic type, int.\nThe typing rule for plambda prohibits the plambda-bound identifier from clashing with names that appear\nin the types of free variables within the body (in this case, + uses the base type int).\n\n]\n[\n]\n[\n]\n600 What is two? The two are the polymorphic function of three arguments of the same type that returns\ntrue, and a similar function that returns false. The result can't possibly depend on the three arguments\nbecause there are no polymorphic predicate or comparison operators.\n800 What is\nA ` E0 : T1 → T2\nA ` E1 : T1\nT1\n0 vT1\nA ` (E0 E1) : T2\n[application]\n1000 What is\nA[I1:T1] ` E1 : T1\nA[I1:Gen(T1, A)] ` EB : TB\nA ` (letrec ((I1 E1)) EB ) : TB\n[letrec]\nProgramming Paradigms\n200 By constructing a dependancy graph and looking for cycles. Consider each process a node, and insert\na directed edge from P1 to P2 iff P2 holds a lock P1 is trying to aquire. A cycle indicates deadlock.\n400 No. Computing the absolute value requires two references to the number: comparing it to zero and\npossibly negating it. Without dup (or some means of naming a value), PostFix is unable to make more than\none reference to any value.\n600 The value is 6. Even though ob5 responds to the compute message, its variable self is bound at that\npoint to the object composed of ob2, ob3, and ob5; a value message sent to this object is handled by ob2,\nreturning 2. A value message sent directly to ob3 returns 3.\n800 Dclauseseq[[[], [], V, F ] = (F )\nDpat [ , V, S, F ] = S\nDpatseq [ , [], V, F ] = S\n1000 6, 7, 10, and 14.\nPotpourri\n200 Yes, it affects termination. Example:\n((lambda (a) 3)\n((lambda (x) (x x))\n(lambda (x) (x x))))\n400 Dangling pointers can result from a use of free.\n600 Grace Murray Hopper.\n800 The domains are from a standard semantics for a functional programming language. (1) Call-by-name\n(in call-by-value, Denotable would be Expressible) (2) Dynamic scoping (because elements of the Procedure\ndomain take an environment).\n\n1000 The recof types are equivalent if their infinite expansions are equal. The first type denotes an infinite\nlist of alternating int and bool, so T must denote an infinite list of alternating bool and int.\nT = (recof t (pairof bool (pairof int t)))\nRound 3: Final Jeopardy\n(-> ((-> (?s ?t) ?t) ?t (list-of ?s)) ?t)"
    },
    {
      "category": "Resource",
      "title": "33.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/db93ce43c8a91cf43eab03a20f2946c7_33.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n2000 Final Examination and Solutions\n1. Final Examination\nThere are four problems on this examination. Make sure you don't skip over any of a problem's parts! They\nare followed by an appendix that contains reference material from the course notes. The appendix contains\nno problems; it is just a handy reference.\nYou will have ninety minutes in which to work the problems. Some problems are easier than others: read all\nproblems before beginning to work, and use your time wisely!\nThis examination is open-book: you may use whatever reference books or papers you have brought to the\nexam. The number of points awarded for each problem is placed in brackets next to the problem number.\nThere are 100 points total on the exam.\nDo all written work in your examination booklet - we will not collect the examination handout itself; you\nwill only be graded for what appears in your examination booklet. It will be to your advantage to show\nyour work - we will award partial credit for incorrect solutions that make use of the right techniques.\nIf you feel rushed, be sure to write a brief statement indicating the key idea you expect to use in your\nsolutions. We understand time pressure, but we can't read your mind.\nThis examination has text printed on only one side of each page. Rather than flipping back and forth be-\ntween pages, you may find it helpful to rip pages out of the exam so that you can look at more than one\npage at the same time.\nContents\nProblem 1: Parameter Passing [21 points]\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 2: Explicit Types [24 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 3: Type Reconstruction [30 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 4: Pragmatics [25 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix A: Standard Semantics of FLK! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix B: Parameter Passing Semantics for FLAVAR! . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix C: Typing Rules for SCHEME/XSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix D: Typing Rules for SCHEME/R . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix E: Type Reconstruction Algorithm for SCHEME/R . . . . . . . . . . . . . . . . . . . . . . 15\nAppendix F: Simple-CPS Conversion Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix G: Meta-CPS Conversion Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nThe figures in the Appendix are very similar to the ones in the course notes. Some bugs have been fixed,\nand some figures have been simplified to remove parts inessential for this exam. You will not be marked\ndown if you use the corresponding figures in the course notes instead of the appendices.\n\nProblem 1: Parameter Passing [21 points]\nGive the meaning of the following FLAVAR! expression under each parameter passing scheme. Hint: try to\nfigure out the values of (begin (f a) a) and (f (begin (set! b (+ b 2)) b)) separately, then find the\nsum.\n(let ((a 4) (b 0))\n(let ((f (lambda (x)\n(begin (set! x (* x x))\n(/ x 2)))))\n(+ (begin (f a) a)\n(f (begin (set! b (+ b 2)) b)))))\na. [7 points] call-by-value\nb. [7 points] call-by-name\nc. [7 points] call-by-reference\n\nProblem 2: Explicit Types [24 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON THE SCHEME/XSP TYPING\nRULES GIVEN IN APPENDIX C.\nLouis Reasoner likes both dynamic scoping and explicit types, and thus decides to create a new language,\nScheme/DX, that includes both! However, certain problems arise and you are called into rescue Louis' at-\ntempt.\nLouis revised a procedure definition to be:\n′\nT1\n′\n)) ((I1\nn\n) . . . (I′\nT ′\nm ))) EB)\nm\nE := . . . | (lambda (((I1 T1) . . . (In T\nwith the new type:\n′\nT1\n′\n) ((I1\nn\n. . . (I′\nT ′\nm ))) TB)\nm\nT := . . . | (-> ((T1 . . . T\n)\nThe first list of identifiers {Ii\nand the second list of identifiers\nin LAMBDA specifies the formal parameters to LAMBDA,\n}\nTi\n′\nTi\n} and types\n} specifies all of the dynamically bound identifiers used\nby E and their types. Thus when a procedure is called, the types of BOTH the actual parameters and the\nand types\n}\n{\n′Ii\n{\n{\ndynamically bound variables must match.\nFor example:\n(let ((x 1))\n(let ((p (lambda (((y int)) ((x bool))) (if x y 0))))\n(let ((x #t))\n(p 1))))\n⇒ 1\n(let ((x #t))\n(let ((p (lambda (((y int)) ((x bool))) (if x y 0))))\n(let ((x 1))\n(p 1))))\n⇒ NOT WELL TYPED\nFor an expression E, let S be the set of dynamically bound identifiers in E. We can extend our typing frame-\nwork to be\nA ⊢ E : T @ S\nIn this framework, \"@\" means \"E uses dynamic variables\" just like \":\" means \"has type\".\nOur new combined typing and dynamic variable rule for identifiers is:\nA[I : T] ⊢ I : T @ {I}\nHere are two examples to give you an idea of what we mean:\nA[x : int] ⊢ (+ 1 x) : int @ {x}\nA[x : int] ⊢ (let ((x 1)) (+ 1 x)) : int @ {}\nIn this framework:\n\na. [6 points] Give a combined typing and dynamic variable rule for LET.\nb. [6 points] Give a combined typing and dynamic variable rule for LAMBDA.\nc. [6 points] Give a combined typing and dynamic variable rule for application.\nd. [6 points] Briefly argue that your rules always guarantee that in well-typed programs references to\ndynamic variables are bound.\n\nProblem 3: Type Reconstruction [30 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON THE SCHEME/R TYPING\nRULES AND TYPE RECONSTRUCTION ALGORITHM GIVEN IN THE APPENDIX.\nBen Bitdiddle is at it again, further enhancing Scheme/R. In this new and improved version he has added\na new construct called go that executes all of its constituent expressions E1...En in parallel:\nE := . . . | (go (I1 . . . In) E1 . . . Em) | (talk! I E) | (listen I)\ngo terminates when all of E1 . . . Em terminate, and it returns the value of E1. go includes the ability to use\ncommunication variables I1 . . . In in a parallel computation. A communication variable can be assigned\na value by talk!. An expression in go can wait for a communication variable to be given a value with\nlisten. listen returns the value of the variable once it is set with talk!. For a program to be well typed,\nall E1 . . . En in go must be well typed.\nCommunication variables will have the unique type (commof T) where T is the type of value they hold.\nThis will ensure that only communication variables can be used with talk! and listen, and that commu-\nnication variables can not be used in any other expression.\nBen has given you the Scheme/R typing rules for talk! and listen:\nA ⊢ E : T\nA ⊢ I : (commof T)\n[talk!]\nA ⊢ (talk! I E) : unit\nA ⊢ I : (commof T)\n[listen]\nA ⊢ (listen I) : T\na. [8 points] Give the Scheme/R typing rule for go.\nb. [7 points] Give the Scheme/R reconstruction algorithm for talk!.\nc. [7 points] Give the Scheme/R reconstruction algorithm for listen.\nd. [8 points] Give the Scheme/R reconstruction algorithm for go.\n\nProblem 4: Pragmatics [25 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON THE META CPS CONVER-\nSION ALGORITHM GIVEN IN APPENDIX G.\nThis problem contains two independent parts:\na. Ben Bitdiddle, the engineer in charge of the MCPS phase in the Tortoise compiler, looked over the\nbook and the previous years' finals and couldn't find the meta-cps rule for label and jump. As Ben is\nvery rushed - the new Tortoise compiler should hit the market in the middle of the holiday season -\nhe's asking for your help.\nHere is a quick reminder of the semantics of label and jump:\n(label I E) evaluates E; inside E, I is bound to the continuation of (label I E). The labels are statically\nscoped (as the normal Scheme variables are).\n(jump E1 E2) calls the continuation resulted from evaluating E1, passing to it the result of evaluating\nE2. E1 should evaluate to a label (i.e. a continuation introduced by label). The behavior of (jump\nE1 E2) is unspecified if E1 doesn't evaluate to a label (this is considered to be a programming\nerror).\nE.g.: The expression (label foo (+ 1 (jump foo (+ 2 (jump foo 3))))) should evaluate to 3.\nBen even wrote the SCPS rules for label and jump:\nSCPS[ (label I E)]]\n=\n(lambda (k)\n(let ((I k))\n(call SCPS[ ]\n[E] k)))\nSCPS[ (jump E1 E2)]]\n=\n(lambda (k1)\n(call SCPS[ E1]\n(lambda (k2)\n(call SCPS[ E2] k2))))\n(i) [10 points] What is MCPS[ (LABEL I E)] ? Be careful to avoid code bloat.\n(ii) [10 points] What is MCPS[ (JUMP E1 E2)] ?\nb. [5 points] In class, we've mentioned a couple of times that type safety is impossible without automatic\nmemory management (i.e. garbage collection). Please explain why this is true.\n\nAppendix A: Standard Semantics of FLK!\nv ∈ Value = Unit + Bool + Int + Sym + Pair + Procedure + Location\nk ∈ Expcont = Value\nCmdcont\n→\nγ ∈ Cmdcont = Store → Expressible\nExpressible = (Value + Error) ⊥\nError = Sym\np ∈ Procedure = Denotable → Expcont → Cmdcont\nd ∈ Denotable = Value\ne ∈ Environment = Identifier → Binding\nβ ∈ Binding = (Denotable + Unbound)⊥\nUnbound = {unbound}\ns ∈ Store = Location → Assignment\nl ∈ Location = Nat\nα ∈ Assignment = (Storable + Unassigned)⊥\nσ ∈ Storable = Value\nUnassigned = {unassigned}\ntop-level-cont : Expcont\n= λv . λs . (Value →Expressible v)\nerror-cont : Error\nCmdcont\n→\n= λy . λs . (Error →Expressible y)\nempty-env : Environment = λI . (Unbound →Binding unbound)\ntest-boolean : (Bool → Cmdcont) → Expcont\n= λf . (λv . matching v\n[\n▷(Bool\nValue b) ] (f b)\n→\n▷else (error-cont non-boolean)\nendmatching )\nSimilarly for:\ntest-procedure : (Procedure → Cmdcont) → Expcont\ntest-location : (Location → Cmdcont) → Expcont\netc.\nensure-bound : Binding → Expcont → Cmdcont\n= λβk . matching β\n[\n▷(Denotable →Binding v) ] (k v)\n[\n▷(Unbound →Binding unbound) ] (error-cont unbound-variable )\nendmatching\nSimilarly for:\nensure-assigned : Assignment → Expcont → Cmdcont\nFigure 1: Semantic algebras for standard semantics of strict CBV FLK!.\n\nsame-location? : Location\nLocation\nBool = λl1l2 . (l1 =Nat l2)\n→\nnext-location : Location\n→\nLocation = λl . (l +Nat 1)\n→\nempty-store : Store = λl . (Unassigned →Assignment unassigned)\nfetch : Location → Store → Assignment = λls . (s l)\nassign : Location\nStorable\nStore\nStore\n→\n→\n→\n= λl1σ s . λl2 . if (same-location? l1 l2)\nthen (Storable →Assignment σ)\nelse (fetch l2 s)\nfresh-loc : Store\nLocation = λs . (first-fresh s 0)\n→\nfirst-fresh : Store\nLocation\nLocation\n→\n= λsl . matching (fetch l s)\n→\n▷ (Unassigned →Assignment unassigned) ][ l\n▷ else (first-fresh s (next-location l))\nendmatching\nlookup : Environment → Identifier → Binding = λeI . (e I)\nFigure 2: Store helper functions for standard semantics of strict CBV FLK!.\n\nT L : Exp →Expressible\nE : Exp →Environment →Expcont →Cmdcont\nL : Lit\nValue ; Defined as usual\n→\n[ ]\n[ ]\nE ] = E [E ] empty-env top-level-cont empty-store\nT L[\n[ ]\n[ ]\nL ] = λek . k L[L ]\nE [\n[ ]I ] = λek . ensure-bound (lookup e I) k\nE [\n[ ]\nE[ (proc I E)]] = λek . k (Procedure\nValue (λdk ′ . E E ] [I : d]e k ′))\n→\n[\n]\n\ne (test-procedure (λp . E E2\nE[ (call E1 E2)]] = λek . E E1\n[\n]\n\ne (λv . p v k)))\nE[ (if E1 E2 E3)]] =\n[\n]\n\n[\n]\n[\n]\nλek . E [E1 ] e (test-boolean (λb . if b then E [E2 ] e k else E [E3 ] e k))\n[\n]\n\ne (λv1 . E E2\nE[ (pair E1 E2)]] = λek . E E1\n[\n]\n\ne (λv2 . k (Pair\nValue\nv1, v2 )))\n→\n⟨\n⟩\nE[ (cell E)]] = λek . E E\n[ ]\n\ne (λvs . k (Location\nValue (fresh-loc s))\n→\n(assign (fresh-loc s) v s))\n[\n]\n\n[\n]\nE[ (begin E1 E2)]] = λek . E [E1 ] e (λvignore . E [E2 ] e k)\n[ ]\n\nE[ (primop cell-ref E)]] = λek . E E\ne (test-location (λls . ensure-assigned (fetch l s) k s))\nE[ (primop cell-set! E1 E2)]\n[\n]\n\n[\n]\n= λek . E [E1 ] e (test-location (λl . E [E2 ] e (λvs . k (Unit\nValue unit) (assign l v s))))\n→\nE[ (rec I E)]] = λeks . let f = fixExpressible (λa . E E\n[\n]\n\n[I : (extract-value a)] e top-level-cont s)\nmatching f\n▷(Value →Expressible v) ] E E\n\n[\n[\n]\n\n[I : v] e k s\n▷else f\nendmatching\nextract-value : Expressible →Binding\n= λa . matching a\n[\n▷(Value →Expressible v) ] (Denotable →Binding v)\n▷else ⊥Binding\nendmatching\nFigure 3: Valuation clauses for standard semantics of strict CBV FLK!.\n\nAppendix B: Parameter Passing Semantics for FLAVAR!\nσ\n∈\nStorable\n=\nValue\nval-to-storable = λv . v\nE [ (call E1 E2)]] = λe . (with-procedure (E E1\n[\n] e)\n[\n]\n(λp . (with-value (E [E2 ] e)\n(λv . (allocating v p)))))\n[ ]I ] = λe . (with-denotable (lookup e I) (λl . (fetching l val-to-comp)))\nE [\nCall-by-Value\nσ\n∈\nStorable\n=\nComputation\nval-to-storable = val-to-comp\nE [ (call E1 E2)]] = λe . (with-procedure (E E1\n[\n]\n\ne)\n[\n]\n(λp . (allocating (E [E2 ] e) p)))\n[ ]\nI ] = λe . (with-denotable (lookup e I) (λl . (fetching l (λc . c))))\nE [\nCall-by-Name\nFigure 4: Parameter passing mechanisms in FLAVAR!, part I.\n\nσ\nStorable\n=\nMemo\nm\n∈\nMemo\n=\nComputation + Value\n∈\nval-to-storable = λv . (Value\nMemo v)\n→\n[\n]\n\ne)\n[\n]\nE [ (call E1 E2)]] = λe . (with-procedure (E E1\n(λp . (allocating (Computation →Memo (E [E2 ] e)) p)))\n[ ]\nE [I ] = λe . (with-denotable (lookup e I)\n(λl . (fetching l\n(λm . matching m\n▷ (Computation\nMemo c)\n[] (with-value c\n→\n(λv . (sequence (update l (Value\nMemo v))\n(val-to-comp v))))\n→\n[\n▷ (Value\nMemo v) ] (val-to-comp v)\n→\nendmatching ))))\nCall-by-Need (Lazy Evaluation)\nσ\n∈\nStorable\n=\nValue\nE : Exp → Environment → Computation\nLV : Exp → Environment → Computation\nval-to-storable = λv . v\n[\n]\n\ne)\n(λp . (with-location (LV [E2 ]\nE [ (call E1 E2)]] = λe . (with-procedure (E E1\n[\n]\ne) p)))\n[ ]\nE [I ] = λe . (with-denotable (lookup e I) (λl . (fetching l val-to-comp)))\n[ ]\n. (with-denotable (lookup e I) (λl . (val-to-comp (Location\nValue l))))\nLV [I ] = λe\n→\nLV[ Eother ] ; where Eother is not I\n= λe . (with-value (E [ Eother ] e)\n(λv . (allocating v (λl . (val-to-comp (Location\nValue l)))))\n→\nCall-by-Reference\nFigure 5: Parameter passing mechanisms in FLAVAR!, part II.\n\nAppendix C: Typing Rules for SCHEME/XSP\nSCHEME/X Rules\n: int\n[int]\n⊢ N\n: bool\n[bool]\n⊢ B\n: string\n[string]\n⊢ S\n⊢ (symbol I) : sym\n[sym]\nA[I:T] ⊢ I : T\n[var]\n∀i (A ⊢ Ei : Ti)\n[begin]\nA ⊢ (begin E1 . . . En) : Tn\n: T\nA ⊢ E\n[the]\nA ⊢ (the T E) : T\nA ⊢ E1 : bool ; A ⊢ E2 : T ; A ⊢ E3 : T\n[if ]\nA ⊢ (if E1 E2 E3) : T\nA[I1:T1, ..., In:Tn] ⊢ EB : TB\n[λ]\nA ⊢ (lambda ((I1 T1) . . . (In Tn)) EB) : (-> (T1 . . . Tn) TB)\nA ⊢ EP : (-> (T1 . . . Tn) TB)\n∀i (A ⊢ Ei : Ti)\n[call]\nA ⊢ (EP E1 . . . En) : TB\n∀i (A ⊢ Ei : Ti)\nA[I1:T1, ..., In:Tn] ⊢ EB : TB\n[let]\nA ⊢ (let ((I1 E1) . . . (In En)) EB) : TB\nA′ = A[I1:T1, ..., In:Tn]\n∀i (A′ ⊢ Ei : Ti)\nA′ ⊢ EB : TB\n[letrec]\nA ⊢ (letrec ((I1 T1 E1) . . . (In T1 En)) EB) : TB\nA ⊢ (∀i [Ti/Ii])Ebody : Tbody\n[tlet]\nA ⊢ (tlet ((I1 T1) . . . (In Tn)) Ebody ) : Tbody\n∀i (A ⊢ Ei : Ti)\n[record]\nA ⊢ (record (I1 E1) . . . (In En)) : (recordof (I1 T1) . . . (In Tn))\nA ⊢ E : (recordof . . . (I T) . . .)\n[select]\nA ⊢ (select I E) : T\nA ⊢ E : TE ; T = (oneof . . . (I TE) . . .)\n[one]\nA ⊢ (one T I E) : T\nA ⊢ Edisc : (oneof (I1 T1) . . . (In Tn))\n∀i . ∃j . ((Ii = Itagj) ∧ (A[Ivalj:Ti] ⊢ Ej : T))\n[tagcase1]\nA ⊢ (tagcase Edisc (Itag1 Ival1 E1) . . . (Itagn Ivaln En)) : T\nA ⊢ Edisc : (oneof (I1 T1) . . . (In Tn))\n(∃j . (Ii = Itagj)) . A[Ivalj:Ti] ⊢ Ej : T\n∀i |\nA ⊢ Edef ault : T\n[tagcase2]\nA ⊢ (tagcase Edisc (Itag1 Ival1 E1) . . . (Itagn Ivaln En) (else Edef ault )) : T\n\nRules Introduced by SCHEME/XS to Handle Subtyping\nT ⊑ T\n[reflexive-⊑]\nT1 ⊑ T2 ; T2 ⊑ T3\n[transitive-⊑]\nT1 ⊑ T3\n(T1 ⊑ T2)\n(T2 ⊑ T1)\n[≡]\nT1 ≡ T2\n∀i ∃j ((Ii = Jj) ∧ (Sj ⊑ Ti))\n(recordof (J1 S1) . . .(Jm Sm)) ⊑ (recordof (I1 T1) . . .(In Tn))\n[recordof-⊑]\n∀j ∃i ((Jj = Ii) ∧ (Sj ⊑ Si))\n(oneof (J1 S1) . . .(Jm Sm)) ⊑ (oneof (I1 T1) . . .(In Tn))\n[oneof-⊑]\n∀i (Ti ⊑ Si) ; Sbody ⊑ Tbody\n(-> (S1 . . .Sn) Sbody ) ⊑ (-> (T1 . . .Tn) Tbody )\n[->-⊑]\n∀T ([T/I1]T1 ⊑ [T/I2]T2)\n(recof I1 T1) ⊑ (recof I2 T2)\n[recof-⊑]\nA ⊢ Erator : (-> (T1 . . .Tn) Tbody )\n∀i ((A ⊢ Ei : Si) ∧ (Si ⊑ Ti))\n[call-inclusion]\nA ⊢ (Erator E1 . . .En) : Tbody\n: S\nA\nS\n⊢\n⊑\nE\nT\n[the-inclusion]\nA ⊢ (the T E) : T\nRules Introduced by SCHEME/XSP to Handle Polymorphism\nA ⊢ E : T;\n[\n∀i (Ii ∈ (FTV (Free-Ids E]])A))\n\n[pλ]\nA ⊢ (plambda (I1 . . . In) E) : (poly (I1 . . . In) T)\nA ⊢ E : (poly (I1 . . . In) TE)\n[project]\nA ⊢ (proj E T1 . . . Tn) : (∀i [Ti/Ii]) TE\n[\n(∀i [Ii/Ji]) S ⊑ T, ∀i (Ii ∈ Free-Ids S]])\n(poly (J1 . . . Jn) S) ⊑ (poly (I1 . . . In) T)\n[poly-⊑]\nrecof Equivalence\n(recof I T) ≡ [(recof I T)/I]T\n\nAppendix D: Typing Rules for SCHEME/R\n⊢ #u : unit\n[unit]\n⊢ B : bool\n[bool]\n⊢ N : int\n[int]\n⊢ (symbol I) : sym\n[symbol]\n[. . . , I:T, . . .] ⊢ I : T\n[var]\n[. . . , I:(generic (I1 . . . In) Tbody ), . . .] ⊢ I : (∀i [Ti/Ii])Tbody\n[genvar]\nA ⊢ Etest : bool ; A ⊢ Econ : T ; A ⊢ Ealt : T\n[if ]\nA ⊢ (if Etest Econ Ealt ) : T\nA[I1:T1, . . ., In:Tn] ⊢ Ebody : Tbody\n[λ]\nA ⊢ (lambda (I1 . . . In) Ebody ) : (-> (T1 . . . Tn) Tbody )\nA ⊢ Erator : (-> (T1 . . . Tn) Tbody )\n∀i . (A ⊢ Ei : Ti)\n[apply]\nA ⊢ (Erator E1 . . . En) : Tbody\n∀i . (A ⊢ Ei : Ti)\nA[I1:Gen(T1, A), . . ., In:Gen(Tn, A)] ⊢ Ebody : Tbody\n[let]\nA ⊢ (let ((I1 E1) . . . (In En)) Ebody ) : Tbody\n∀i . (A[I1:T1, . . ., In:Tn] ⊢ Ei : Ti)\nA[I1:Gen(T1, A), . . . In:Gen(Tn, A)] ⊢ Ebody : Tbody\n[letrec]\nA ⊢ (letrec ((I1 E1) . . . (In En)) Ebody ) : Tbody\n∀i . (A ⊢ Ei : Ti)\n[record]\nA ⊢ (record (I1 E1) . . . (In En)) : (recordof (I1 T1) . . . (In Tn))\nA ⊢ Er : (recordof (I1 T1) . . . (In Tn))\nA[I1:T1, . . ., In:Tn] ⊢ Eb : T\n[with]\nA ⊢ (with (I1 . . . In) Er Eb) : T\nA ⊢ (letrec ((I1 E1) . . . (In En)) Ebody ) : T\n[program]\nA ⊢ (program (define I1 E1) . . . (define In En) Ebody ) : T\nGen(T, A) = (generic (I1 . . . In) T), where {Ii} = FTV (T) - FTE(A)\n\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\nAppendix E: Type Reconstruction Algorithm for SCHEME/R\n[\n]\nR[#u ] A S = unit, S\n[\n]\nR[B ] A S = bool, S\n[\n]\nR[N ] A S = int, S\nR[ (symbol I)] A S = sym, S\n[ ]\nR[I ] A[I : T] S = T, S\n[ ]\nR[I ] A[I : (generic (I1 . . . In) T)] S = T[?vi/Ii], S\n(?vi are new)\n[ ]\nR[I ] A S = fail\n(when I is unbound)\n[\nR[ (if Et Ec Ea)] A S = let Tt, St = R Et] A S\nin\n⟨\nlet St\n′ ⟩\n= U(Tt, bool, St)\n[\nin let ⟨Tc, Sc = R Ec] A St\n′\n[\nin let Ta, Sa = R Ea] A Sc\nin\n⟨\nlet S′ ⟩\n= U(Tc, Ta, Sa)\na\nin Ta, S′\na\n[\nR[ (lambda (I1 . . . In) Eb)] A S =\nlet Tb, Sb = R Eb] A[Ii :?vi] S\nin (-> (?v1 . . . ?vn) Tb), Sb\n(?vi are new)\n[\nR[ (E0 E1 . . . En)] A S =\nlet T0, S0 = R E0] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\nin\n⟨\nlet Sf = U(T0, (-> (T1 . . . Tn) ?vf ), Sn)\nin ?vf, Sf\n(?vf is new)\n[\nR[ (let ((I1 E1) . . . (In En)) Eb)] A S =\nlet ⟨T1, S1 = R E1] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\n[\nin R Eb] A[Ii : Rgen(Ti, A, Sn)]Sn\nR[ (letrec ((I1 E1) . . . (In En)) Eb)] A S =\nlet A1 = A[Ii :?vi]\n(?vi are new)\n[\nin let T1, S1 = R E1] A1 S\nin . . .\n[\nlet Tn, Sn = R En] A1 Sn-1\nin\n⟨\nlet Sb = U(?vi, Ti, Sn)\n[\nin R Eb] A[Ii : Rgen(Ti, A, Sb)] Sb\n[\nR[ (record (I1 E1) . . . (In En))] A S =\nlet T1, S1 = R E1] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\nin (recordof (I1 T1) . . . (In Tn)), Sn⟩\n[\nR[ (with (I1 . . . In) Er Eb)] A S = let Tr, Sr = R Er] A S\nin\n⟨\nlet Sb\n⟩\n= U(Tr, (recordof (I1 ?vi) . . . (In ?vn)), Sr)\n(?vi are new)\n[\nin R Eb] A[Ii :?vi] Sb\nRgen(T, A, S) = Gen((S T), (subst-in-type-env S A))\n\nAppendix F: Simple-CPS Conversion Rules\nSCPS[ ]\n[I ]\n=\n(lambda (k) (call k I))\nSCPS[ ]\n[L]\n=\n(lambda (k) (call k L))\nSCPS[ (lambda (I) E)]]\n=\n(lambda (k)\n(call k\n(lambda (I k-call)\n(call SCPS[\n]] k-call))))\n[E\nSCPS[ (call E1 E2)]]\n=\n(lambda (k)\n(call SCPS[ E1]\n(lambda (v1)\n(call SCPS[ E2]\n(lambda (v2)\n(call v1 v2 k))))))\nSCPS[ (let ((I1 E1) . . . (I2 E2)) E)]]\n=\n(lambda (k)\n(call SCPS[ E1]\n(lambda (I1)\n. . .\n(call SCPS[ En]\n(lambda (In)\n(call SCPS[ ]\n[E] k))). . .)))\nSCPS[ (label I E)]]\n=\n(lambda (k)\n(let ((I k))\n(call SCPS[ ]\n[E] k)))\nSCPS[ (jump E1 E2)]]\n=\n(lambda (k1)\n(call SCPS[ E1]\n(lambda (k2)\n(call SCPS[ E2] k2))))\n\nAppendix G: Meta-CPS Conversion Rules\nIn the following rules, grey mathematical notation (like λv) and square brackets [ ] are used for\n\"meta-application\", which is evaluated as part of meta-CPS conversion. Code in BLACK TYPEWRITER FONT is\npart of the output program; meta-CPS conversion does not evaluate any of this code. Therefore, you can\nthink of meta-CPS-converting an expression E as rewriting MCPS[\n]] until no grey is left.\n[E\nE ∈ Exp\nm ∈ Meta-Continuation = Exp → Exp\nmeta-cont → exp : (Exp → Exp) → Exp = [λm . (LAMBDA (t)[m t])]\nexp → meta-cont : Exp → (Exp → Exp) = [λE . [λV . (CALL E V )]]\nmeta-cont→exp [λV . (CALL K V )] = K\nMCPS : Exp → Meta-Continuation → Exp\n[I\nMCPS[ ]] = [λm . [m I]]\nMCPS[ ]\n[L ] = [λm . [m L]]\nMCPS[ (LAMBDA (I1 ... In) E)]\n= [λm . [m (LAMBDA (I1 ... In .Ki.)\n[MCPS[\n]\n[E ] [exp → meta-cont .Ki.]])]]\nMCPS[ (CALL E1 E2)]\n= [λm . [MCPS[ E1]] [λv1 .\n[MCPS[ E2]] [λv2 .\n(CALL v1 v2 [meta-cont → exp m])]]]]]\nMCPS[ (PRIMOP P E1 E2)]\n= [λm . [MCPS[ E1]] [λv1 .\n[MCPS[ E2]] [λv2 .\n(LET ((.Ti. (PRIMOP P v1 v2)))\n[m\n.Ti.])]]]]]\nMCPS[ (IF Ec Et Ef)]\n= [λm . [MCPS[ Ec]] [λv1 .\n(LET ((K [meta-cont → exp m]))\n(IF v1\n[MCPS[ Et]] [exp → meta-cont K]]\n[MCPS[ Ef]] [exp → meta-cont K]]))]]]\nMCPS[ (LET ((I Edef )) Ebody)]\n= [λm . [MCPS[ Edef ]] [λv .\n(LET ((I v)) [MCPS[ Ebody] m])]]]\n\n′\n′\n2. Final Examination Solutions\nProblem 1: Parameter Passing\na. 6\nb. 8\nc. 18\nProblem 2: Explicit Types\na.\n∀i (A ⊢Ei : Ti @ Si)\nA[I1:T1, ..., In:Tn] ⊢EB : TB @ SB\nA ⊢(let ((I1 E1) . . . (In En)) EB) : TB @ S1 ∪ . . . ∪Sn ∪SB -{I1 . . . In}\n[let]\nb.\n′\n′\nI′\nA[I1:T1, ..., In:Tn, I1 : T1, ..., I′ : T ′ ] ⊢EB : TB @ S\nS\n\n⊂{I1 . . . In, I1\n′ . . .\nm}\nm\nm\nA ⊢(lambda (((I1 T1) . . . (In Tn)) ((I1 T1\n′ ) . . . (I′\nT ′\n′\nm ))) EB) :\nm\n(-> ((T1 . . . Tn) ((I1 T1\n′ ) . . . (I′\nT ′\nm ))) TB) @ {}\nm\n[λ]\nc.\nA ⊢EP : (-> ((T1 . . . Tn) ((I1 T1\n′ ) . . . (I′\nT ′\n′\nm ))) TB) @ SP\nm\n∀i . (A ⊢Ei : Ti @ Si) ∧∀j . (A[Ij\n′ ] = Tj\n′ )\n[call]\n′\nI′\nA ⊢(EP E1 . . . En) : TB @ S1 ∪. . . ∪Sn ∪SP ∪{I1 . . .\nm}\nd. The [call] rule guarantees that all dynamic variables needed in the procedure are bound. The expres-\nsion (A[I′ ] = Tj\n′) will produce a type error if any I′ is not bound. In addition, the [λ] rule guarantees\nj\nj\nthat every dynamic variable used in the body of a procedure is properly declared.\nProblem 3: Type Reconstruction\na.\n∀i . (A[I1:(commof T1\n′ ), ...In:(commof T ′\nn)] ⊢Ei : Ti)\n[go]\nA ⊢(go (I1 ...In) E1 ...En) : T1\n[\nb. R[ (talk! I E)] A S = let ⟨T, S1⟩= R I] A S\nin let ⟨T ′, S2⟩= R[\n]] A S\n[E\nin let S3 = U(T, (commof T ′), S2)\nin ⟨unit, S3⟩\nc. R[ (listen I)] A S = let ⟨T, S1⟩= R[I] A S\nin let S2 = U((commof ?t), T, S1)\nin ⟨?t, S2⟩\n\nd. R[ (go (I1 . . . In) E1 . . . Em)] A S = let A1 = A[I1 : (commof ?t1) . . . In : (commof ?tn)]\n[\nin let ⟨T1, S1⟩ = R E1] A1 S\nin . . .\n[\nlet ⟨Tm, Sm⟩ = R Em] A1 Sm-1\nin ⟨T1, Sm⟩\nwhere ?ti . . . ?tn are fresh.\nProblem 4: Pragmatics\na.\n(i) MCPS[ (LABEL I E)]\n= [λm . (LET\n((I [meta-cont → exp m]))\n[MCPS[ ]\n[E ] [λv . (CALL I v)]])]\nI is lexically bound to [meta-cont → exp m]. In the last line, we could have put m instead of\n[λv . (CALL I v) but this would lead to an exponential increase in the code size.\n(ii) MCPS[ (JUMP E1 E2)]\n= [λm . [MCPS[\n]\n\n[E1 ] [λv1 .\n[MCPS[\n]\n[E2 ] [λv2 .\n(CALL v1 v2) ]]]]]\nVery similar to the rule for CALL. However, this time we totally ignore m as required by the\nsemantics of jump.\nb. If we can explictly free memory, then it would be possible to free a block of memory orginally con-\ntaining data of type T, then allocating it to data containing T', thus resulting in a type error when an\nexpression gets a T' instead of a T."
    },
    {
      "category": "Resource",
      "title": "34.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/ed3c4c32091833c40bfb5701a7228b0d_34.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\n1999 Final Examination and Solutions\n1. Final Examination\nThere are five problems on this examination. Make sure you don't skip over any of a problem's parts! They\nare followed by an appendix that contains reference material from the course notes. The appendix contains\nno problems; it is just a handy reference.\nYou will have three hours in which to work the problems. Some problems are easier than others: read all\nproblems before beginning to work, and use your time wisely!\nThis examination is open-book: you may use whatever reference books or papers you have brought to the\nexam. The number of points awarded for each problem is placed in brackets next to the problem number.\nThere are 100 points total on the exam.\nDo all written work in your examination booklet - we will not collect the examination handout itself; you\nwill only be graded for what appears in your examination booklet. It will be to your advantage to show\nyour work - we will award partial credit for incorrect solutions that make use of the right techniques.\nIf you feel rushed, be sure to write a brief statement indicating the key idea you expect to use in your\nsolutions. We understand time pressure, but we can't read your mind.\nThis examination has text printed on only one side of each page. Rather than flipping back and forth be-\ntween pages, you may find it helpful to rip pages out of the exam so that you can look at more than one\npage at the same time.\nContents\nProblem 1: Short Answer [18 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 2: Operational Semantics [22 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 3: Denotational Semantics [24 points]\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 4: Type Reconstruction [20 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 5: Compilers [16 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix A: PostFix Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix B: PostFix SOS from Chapter 3\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix C: Standard Semantics of FLK! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix D: Typing Rules for SCHEME/R . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix E: Type Reconstruction Algorithm for SCHEME/R . . . . . . . . . . . . . . . . . . . . . . 15\nAppendix F: Meta-CPS Conversion Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nThe figures in the Appendix are very similar to the ones in the course notes. Some bugs have been fixed,\nand some figures have been simplified to remove parts inessential for this exam. You will not be marked\ndown if you use the corresponding figures in the course notes instead of the appendices.\n\nProblem 1: Short Answer [18 points]\na. Explicit Polymorphism [6 points]\nRewrite the following programs in Scheme/XSP with the most flexible type possible.\n(i) [3 points]\n(lambda (f g x)\n(if (f x)\n(g x)\n(g (g x))))\n(ii) [3 points]\n(lambda (f)\n(if (f #t)\n(f (f 1))\n(f 2)))\nb. Type Reconstruction [12 points]\nDetermine the reconstructed types of the following Scheme/R expressions. If none exists, explain\nwhy.\n(i) [3 points]\n(lambda (f x)\n(if (f #t)\n(f x)\n2))\n(ii) [3 points]\n(let ((f (lambda (g x) (g (g x)))))\n(if (f not #t)\n(f (lambda (x) (+ x 1)) 1)\n2))\n(iii) [3 points]\n(let ((f (lambda (x) x)))\n(cons (f 1)\n(cons (f #t)\n(null))))\n(iv) [3 points]\n(lambda (g) (g g))\n\nProblem 2: Operational Semantics [22 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON EXTENDING THE POSTFIX\nGRAMMAR IN APPENDIX A AND THE POSTFIX OPERATIONAL SEMANTICS GIVEN IN APPENDIX\nB.\nIntel has released the new 747 chip, a chip so big it can handle mind boggling amounts of number crunch-\ning. The good programmers over at Microsquish are excited because this means there is now a computer\nfast enough to run their dream programming language, TwoStack PostFix. In TwoStack PostFix, a program\nis a tuple of two command sequences, one per stack. For instance, to have one stack add the numbers 1 and\n3 and have the other stack multiply 4 * 5, use the program\n<[1 3 add],[4 5 mul]>\nThe meaning of a TwoStack program is also a tuple, reporting the top of each stack at the end of the pro-\ngram. In the previous case, <4,20>.\nKeep in mind that the stacks are represented as completely separate entities at different locations in mem-\nory. Note that we will model errors as stuck states. For example, the program\n<[5 1 mul],[4 0 div]>\nshould get stuck. It is also a stuck state if one stack runs out of commands before the other. For instance,\n<[5 1 mul 3 add],[4 1 div]>\nshould get stuck right after the transition which performs the div command. Note that matching com-\nmands are executed simultaneously- that is, the 5 and 4 are pushed at the same time and the mul and the\ndiv are executed at the same time.\nFinally, Executives at Microsquish would like to implement a talk command allowing the two stacks to\ncommunicate. For now, do not worry about the transition rule for the talk command, but know that it\nrequires the following domain updates:\nC\n∈\nCommandPostFix+Talk\nC\n::=\n... existing PostFix commands ...\n|\ntalk\nQ\n∈\nCommandsPostFix+Talk = CommandPostFix+Talk *\nV\n∈\nValue = IntLit + CommandsPostFix+Talk\nIn addition, the transition relation for PostFix+Talk is the same as the relation for PostFix except it is\nupdated to work with the new domains. It currently results in a stuck state for the talk command.\nThe important domains for TwoStack are as follows:\nP\n∈ ProgramTwoStack = CommandsTwoStack\nCommandsTwoStack = CommandsPostFix+Talk × CommandsPostFix+Talk\nA\nAnswerTwoStack = Answer × Answer\n∈\na. [12 points] Louis Reasoner is given the job of defining the Operational Semantics of PostFix+Talk. He\ndecides on the following configuration:\n\nCTwoStack\n=\nCommandsTwoStack × Stack × Stack\nHowever, he needs your help to define the rest of the 5-tuple. Define the Input, Ouput and Transition\nfunctions in terms of the PostFix+Talk functions. Use subscripting to express which domains the func-\ntions are over. For instance, ⇒P ostF ix+T alk is the transition function for PostFix+Talk and ⇒T woStack\nis the transition function for TwoStack PostFix.\nBe sure to also define the set of final configurations of TwoStack Postfix, but do not worry about\nreporting errors for stuck states.\nIt's not very exciting having two stacks run in parallel unless they can communicate. So, Louis Reasoner\ndecides to define the talk command. If talk is at the front of both command sequences, the top value on\neach stack is copied to the top of the other stack. For instance,\n<[5 1 mul talk add],[4 1 div talk mul]>\nshould return <9,20>\nb. [6 points] Extend the transition function for TwoStack to include the talk command.\nc. [4 points] Mark An-treason (who is also working at Microsquish since his company was bought out)\nis worried that programs with talk may not terminate. If programs in TwoStack PostFix always ter-\nminate, set Mark's fears at rest by explaining how you would modify the energy proof to show this.\nIf not, give an example program which does not terminate.\n\nProblem 3: Denotational Semantics [24 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON MODIFYING THE FLK! STAN-\nDARD SEMANTICS GIVEN IN APPENDIX C.\nBen Bitdiddle has been called in to assist in the development of a new feature for FL!. This feature will allow\nprocedures to call themselves recursively without having to use rec or letrec. Ben proposes adding a new\nform (self E) to FLK!. The form (self E) calls the containing procedure with an actual parameter that is the\nresult of evaluating E.\nThe FLK! expression grammar is changed by the addition of the form (self E):\nE\n::=\n... existing FLK! forms ..\n|\n(self E)\nHere is an example of the use of (self E) written in FL! (which would be desugared into FLK! before execu-\ntion):\n(let ((fact (lambda (n) (if (= n 0) 1 (* n (self (- n 1)))))))\n(fact 4))\n⇒\nBen further specifies that when (self E) is used outside of a procedure it causes the program to terminate\nimmediately with a value that is the result of evaluating E.\nBen begins describing the denotational semantics of the self form by modifying the signature of the mean-\ning function, E. His new signature is:\n:\nExp →Environment →SelfProc →ExpCont →CmdCont\nE\nSelfProc\n=\nProcedure\nBen asks you to complete the denotational description of the self form because he is going to a confer-\nence to give a speech on why FL! is the language of the future.\n[E\na. [4 points] Give the revised meaning function T L[\n]].\nb. [4 points] What is the revised E[ (call E1 E2)] ?\nc. [4 points] What is E[ (self E)] ?\nd. [4 points] What is the revised E[ (proc I E)] ?\ne. [4 points] Prove that T L[ (self (self 1))] in your semantics means (Value→Expressible (Int→Value 1)).\nf. [4 points] Use your semantics to show (proc x (self 1)) evaluates to a procedure that, no matter what\ninput it is called with, loops forever.\n\nProblem 4: Type Reconstruction [20 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON EXTENDING THE TYPING\nRULES GIVEN IN APPENDIX D AND THE TYPE RECONSTRUCTION ALGORITHM GIVEN IN AP-\nPENDIX E.\nAlyssa P. Hacker has been asked to extend the type system for SCHEME/R to handle (label I E) and (jump\nE1 E2). As introduced in class and in the book, (label I E) establishes a control point called I in E, and (jump\nE1 E2) jumps to the control point that is the value of E1 and gives it the value obtained by evaluating E2.\nFor example:\n(label out\n(if (= x 0)\n(jump out 0)\n(/ y x)))\nAlyssa has added a control point type to the type grammar for SCHEME/R as follows:\nT\n::=\n... existing SCHEME/R types ...\n(control-point T)\n|\nIn the example above, the control point out would have type (control-point int). It is possible to have control\npoint type errors in SCHEME/R. For example, a label expression must have the same type regardless of\nwhether a jump is encountered, making the following expression not well-typed:\n(label out\n(if (= x 0)\n(jump out #f)\n(/ y x)))\nYour job is to complete the implementation of typed control points.\na. [5 points] Give the new typing rules in SCHEME/R for (label I E) and (jump E1 E2).\nb. [5 points] Give the type reconstruction algorithm clause for (label I E).\nc. [5 points] Give the type reconstruction algorithm clause for (jump E1 E2).\nd. [5 points] Give the reconstructed type of the following expression, or give the input parameters to the\nprocedure that fails during the reconstruction:\n(let ((x (label y y)))\n(jump x (label z z)))\n\nx\nProblem 5: Compilers [16 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON META CPS CONVERSION\nALGORITHM GIVEN IN APPENDIX F.\nBen Bitdiddle is a consummate compiler hacker, and has been asked by JavaHard to analyze their new\nScheme compiler. JavaHard has recently realized that Java will not win in the marketplace against Scheme,\nand has adopted the 6.821 Scheme compiler as the cornerstone of their crash development effort.\nThe following code was produced by the compiler after the desugar, globals/wrap, cps-convert, closures/flat-all,\nand lift-convert phases of compilation.\n(program\n(define\n.lambda24.\n(lambda\n(.closure11. .t5.)\n(call-closure .t5. 1 (primop closure-ref .closure11. 1))))\n(define\n.lambda21.\n(lambda\n(.closure14. f g .k1.)\n(call-closure .k1. (primop closure .lambda22. g f))))\n(define\n.lambda22.\n(lambda\n(.closure13. x .k2.)\n(call-closure\n(primop closure-ref .closure13. 1)\n(primop closure .lambda23. (primop closure-ref .closure13. 2) .k2.))))\n(define\n.lambda23.\n(lambda\n(.closure12. .t3.)\n(call-closure\n(primop closure-ref .closure12. 1)\n.t3.\n(primop closure-ref .closure12. 2))))\n(define .lambda20. (lambda (.closure17. x) x))\n(define\n.lambda19.\n(lambda\n(.closure16. a .k9.)\n(let ((.t10. (primop not a))) (call-closure .k9. .t10.))))\n(define\n.lambda18.\n(lambda\n(.closure15. a .k7.)\n(let ((.t8. (primop integer? a))) (call-closure .k7. .t8.))))\n(define *top* (primop closure .lambda20.))\n(define not (primop closure .lambda19.))\n(define integer? (primop closure .lambda18.))\n(let\n((compose (primop closure .lambda21.)))\n(call-closure compose not integer? (primop closure .lambda24. *top*))))\n\na. [6 points] What source code resulted in the incompletely compiled code above?\nJavaHard soon discovers another problem with the compiler. The compiler they are using cannot\nhandle the begin form because the cps-convert phase does not include a rule for translating begin.\nb. [4 points] Ben looked in the 6.821 book and could not find the meta-cps rule for begin. What is\nMCPS[[(begin E1 E2)]]?\nJavaHard has decided to not let programmers access control features such as cwcc, label, and jump to\nsimplify the analysis of programs. Ben suggests to JavaHard that they include a region identifier in every\nprocedure type:\n∗\nT\n::=\n... (→ (T ) T R)\n|\nJust as regions are assigned to cells, every procedure will be assigned a new region identifier except\nwhen two procedures are aliased together.\nA procedure in E can be explicitly freed if all of the following conditions are met: (1) the procedure is in\nregion R, (2) region R is not in the type of any free variables of E, and (3) region R is not in the type of E.\nc. [4 points] Excited about explicit freedom, Ben invents a new primitive called (%procedure-free x) that\nfrees the procedure represented by value x. In the following example, the lambda expression (lambda\n(y) y) is bound to x and freed:\n(let ((x (lambda (y) y)))\n(%procedure-free x))\nLet E be an expression that contains a non-nested lambda expression P. From effect analysis, we know\nthat P's value is no longer needed after E completes. Thus, Ben would like to use (%procedure-free x)\nto free the procedure value corresponding to P. Help Ben by writing a translation function for E that\nwill free the value of P and return the value of E. Use [v/P]E to substitute the variable v for lambda\nexpression P in E. Assume that your translation occurs before MCPS conversion and that the variable\nv does not appear in E.\nT [\n]\n[E ]=(let ((v P))\n...fill in text here...\n)\nd. [2 points] Ben revises his compiler to call this primitive to free all closures using your translation rule\n(assuming it works), and notes that certain programs slow down as a consequence. Ben had thought\nthat reducing the work that the garbage collector had to do would make programs run faster. What is\na possible explanation for this behavior?\n\nAppendix A: PostFix Grammar\nP ∈ Program\nQ ∈ Commands\nC ∈ Command\nA ∈ Arithmetic-operator = {add, sub, mul, div}\nR ∈ Relational-operator = {lt, eq, gt}\nN ∈ Intlit = {. . ., -2, -1, 0, 1, 2, . . .}\nP\n::=\n(Q)\n[Program]\nQ\n::=\nC*\n[Command-sequence]\nC\n::=\nN\n[Integer-literal]\npop\n[Pop]\n|\nswap\n[Swap]\n|\nA\n[Arithmetic-op]\n|\nR\n[Relational-op]\n|\nsel\n[Select]\n|\nexec\n[Execute]\n|\n(Q)\n[Executable-sequence]\n|\nFigure 1: The S-Expression Grammar for PostFix\n\n⟩\n\n⟩\n⟩\n\n⟩\nAppendix B: PostFix SOS from Chapter 3\n, I and O for our PostFix SOS are given by:\n, F\nC\n= Commands × Stack\nC\n= {[ ]Command } × Stack\nF\nI : Program →C\n= λP . matching P\n▷ (Q) [] ⟨Q, [ ]Value\nendmatching\nO : F →Answer\n= λ⟨[ ]Command , S . matching S\n⟩\n▷ V . S′ [] (Value\nAnswer V)\n→\n▷ [ ] [] (Error\nAnswer error)\nendmatching\n→\n⟨N . Q,\nQ, N . S\n[numeral]\nS⟩⇒⟨\n⟩\n⟨(Qexec ).Qrest ,\nQrest , Qexec . S⟩\n[executable]\nS⟩⇒⟨\n⟨pop . Q, Vtop . S⟩⇒⟨Q, S\n[pop]\n⟨swap . Q, V1 . V2\nQ, V2 . V1 . S\n[swap]\n. S⟩⇒⟨\n⟩\n⟨sel . Qrest , Vfalse . Vtrue .0. S⟩⇒⟨Qrest , Vfalse . S\n[sel-false]\n⟨sel . Qrest , Vfalse . Vtrue . Ntest . S⟩⇒⟨Qrest , Vtrue . S\nwhere Ntest ≡0\n⟩\n[sel-true]\n⟨exec . Qrest , Qexec . S⟩⇒⟨Qexec @ Qrest , S\n[execute]\nA . Q, N1 . N2 . S⟩⇒⟨Q, Nresult . S\n⟨\nwhere Nresult ≡(calculate A N2 N1)\n⟩\n[arithop]\nand\n((A ≡div) ∧(N1 ≡0))\n¬\n⟨R . Q, N1 . N2\nQ, 1. S\n. S⟩⇒ ⟨\n⟩\n[relop-true]\nwhere (compare R N2 N1)\n⟨R . Q, N1 . N2\nQ, 0. S\n. S⟩⇒ ⟨\n⟩\n[relop-false]\nwhere\n(compare R N2 N1)\n¬\nFigure 2: Rewrite rules defining the transition relation for PostFix.\n\nAppendix C: Standard Semantics of FLK!\nv ∈ Value = Unit + Bool + Int + Sym + Pair + Procedure + Location\nk ∈ Expcont = Value\nCmdcont\n→\nγ ∈ Cmdcont = Store → Expressible\nExpressible = (Value + Error) ⊥\nError = Sym\np ∈ Procedure = Denotable → Expcont → Cmdcont\nd ∈ Denotable = Value\ne ∈ Environment = Identifier → Binding\nβ ∈ Binding = (Denotable + Unbound)⊥\nUnbound = {unbound}\ns ∈ Store = Location → Assignment\nl ∈ Location = Nat\nα ∈ Assignment = (Storable + Unassigned)⊥\nσ ∈ Storable = Value\nUnassigned = {unassigned}\ntop-level-cont : Expcont\n= λv . λs . (Value →Expressible v)\nerror-cont : Error\nCmdcont\n→\n= λy . λs . (Error →Expressible y)\nempty-env : Environment = λI . (Unbound →Binding unbound)\ntest-boolean : (Bool → Cmdcont) → Expcont\n= λf . (λv . matching v\n[\n▷(Bool\nValue b) ] (f b)\n→\n▷else (error-cont non-boolean)\nendmatching )\nSimilarly for:\ntest-procedure : (Procedure → Cmdcont) → Expcont\ntest-location : (Location → Cmdcont) → Expcont\netc.\nensure-bound : Binding → Expcont → Cmdcont\n= λβk . matching β\n[\n▷(Denotable →Binding v) ] (k v)\n[\n▷(Unbound →Binding unbound) ] (error-cont unbound-variable )\nendmatching\nSimilarly for:\nensure-assigned : Assignment → Expcont → Cmdcont\nFigure 3: Semantic algebras for standard semantics of strict CBV FLK!.\n\nsame-location? : Location\nLocation\nBool = λl1l2 . (l1 =Nat l2)\n→\nnext-location : Location\n→\nLocation = λl . (l +Nat 1)\n→\nempty-store : Store = λl . (Unassigned →Assignment unassigned)\nfetch : Location → Store → Assignment = λls . (s l)\nassign : Location\nStorable\nStore\nStore\n→\n→\n→\n= λl1σ s . λl2 . if (same-location? l1 l2)\nthen (Storable →Assignment σ)\nelse (fetch l2 s)\nfresh-loc : Store\nLocation = λs . (first-fresh s 0)\n→\nfirst-fresh : Store\nLocation\nLocation\n→\n= λsl . matching (fetch l s)\n→\n▷ (Unassigned →Assignment unassigned) ][ l\n▷ else (first-fresh s (next-location l))\nendmatching\nlookup : Environment → Identifier → Binding = λeI . (e I)\nFigure 4: Store helper functions for standard semantics of strict CBV FLK!.\n\nT L : Exp →Expressible\nE : Exp →Environment →Expcont →Cmdcont\nL : Lit\nValue ; Defined as usual\n→\n[ ]\n[ ]\nE ] = E [E ] empty-env top-level-cont empty-store\nT L[\n[ ]\n[ ]\nL ] = λek . k L[L ]\nE [\n[ ]I ] = λek . ensure-bound (lookup e I) k\nE [\n[ ]\nE[ (proc I E)]] = λek . k (Procedure\nValue (λdk ′ . E E ] [I : d]e k ′))\n→\n[\n]\n\ne (test-procedure (λp . E E2\nE[ (call E1 E2)]] = λek . E E1\n[\n]\n\ne (λv . p v k)))\nE[ (if E1 E2 E3)]] =\n[\n]\n\n[\n]\n[\n]\nλek . E [E1 ] e (test-boolean (λb . if b then E [E2 ] e k else E [E3 ] e k))\n[\n]\n\ne (λv1 . E E2\nE[ (pair E1 E2)]] = λek . E E1\n[\n]\n\ne (λv2 . k (Pair\nValue\nv1, v2 )))\n→\n⟨\n⟩\nE[ (cell E)]] = λek . E E\n[ ]\n\ne (λvs . k (Location\nValue (fresh-loc s))\n→\n(assign (fresh-loc s) v s))\n[\n]\n\n[\n]\nE[ (begin E1 E2)]] = λek . E [E1 ] e (λvignore . E [E2 ] e k)\n[ ]\n\nE[ (primop cell-ref E)]] = λek . E E\ne (test-location (λls . ensure-assigned (fetch l s) k s))\nE[ (primop cell-set! E1 E2)]\n[\n]\n\n[\n]\n= λek . E [E1 ] e (test-location (λl . E [E2 ] e (λvs . k (Unit\nValue unit) (assign l v s))))\n→\nE[ (rec I E)]] = λeks . let f = fixExpressible (λa . E E\n[\n]\n\n[I : (extract-value a)] e top-level-cont s)\nmatching f\n▷(Value →Expressible v) ] E E\n\n[\n[\n]\n\n[I : v] e k s\n▷else f\nendmatching\nextract-value : Expressible →Binding\n= λa . matching a\n[\n▷(Value →Expressible v) ] (Denotable →Binding v)\n▷else ⊥Binding\nendmatching\nFigure 5: Valuation clauses for standard semantics of strict CBV FLK!.\n\nAppendix D: Typing Rules for SCHEME/R\n⊢ #u : unit\n[unit]\n: bool\n[bool]\n⊢ B\n: int\n[int]\n⊢ N\n⊢ (symbol I) : sym\n[symbol]\n[. . . , I:T, . . .] ⊢ I : T\n[var]\n[. . . , I:(generic (I1 . . . In) Tbody ), . . .] ⊢ I : (∀i [Ti/Ii])Tbody\n[genvar]\nA ⊢ Etest : bool ; A ⊢ Econ : T ; A ⊢ Ealt : T\n[if ]\nA ⊢ (if Etest Econ Ealt ) : T\nA[I1:T1, . . ., In:Tn] ⊢ Ebody : Tbody\n[λ]\nA ⊢ (lambda (I1 . . . In) Ebody ) : (-> (T1 . . . Tn) Tbody )\nA ⊢ Erator : (-> (T1 . . . Tn) Tbody )\n∀i . (A ⊢ Ei : Ti)\nA ⊢ (Erator E1 . . . En) : Tbody\n[apply]\n∀i . (A ⊢ Ei : Ti)\nA[I1:Gen(T1, A), . . ., In:Gen(Tn, A)] ⊢ Ebody : Tbody\n[let]\nA ⊢ (let ((I1 E1) . . . (In En)) Ebody ) : Tbody\n∀i . (A[I1:T1, . . ., In:Tn] ⊢ Ei : Ti)\nA[I1:Gen(T1, A), . . . In:Gen(Tn, A)] ⊢ Ebody : Tbody\n[letrec]\nA ⊢ (letrec ((I1 E1) . . . (In En)) Ebody ) : Tbody\n∀i . (A ⊢ Ei : Ti)\n[record]\nA ⊢ (record (I1 E1) . . . (In En)) : (recordof (I1 T1) . . . (In Tn))\nA ⊢ Er : (recordof (I1 T1) . . . (In Tn))\nA[I1:T1, . . ., In:Tn] ⊢ Eb : T\n[with]\nA ⊢ (with (I1 . . . In) Er Eb) : T\nA ⊢ (letrec ((I1 E1) . . . (In En)) Ebody ) : T\nA ⊢ (program (define I1 E1) . . . (define In En) Ebody ) : T\n[program]\nGen(T, A) = (generic (I1 . . . In) T), where {Ii} = FTV (T) - FTE(A)\n\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\nAppendix E: Type Reconstruction Algorithm for SCHEME/R\n[\n]\nR[#u ] A S = unit, S\n[\n]\nR[B ] A S = bool, S\n[\n]\nR[N ] A S = int, S\nR[ (symbol I)] A S = sym, S\n[ ]\nR[I ] A[I : T] S = T, S\n[ ]\nR[I ] A[I : (generic (I1 . . . In) T)] S = T[?vi/Ii], S\n(?vi are new)\n[ ]\nR[I ] A S = fail\n(when I is unbound)\n[\nR[ (if Et Ec Ea)] A S = let Tt, St = R Et] A S\nin\n⟨\nlet St\n′ ⟩\n= U(Tt, bool, St)\n[\nin let ⟨Tc, Sc = R Ec] A St\n′\n[\nin let Ta, Sa = R Ea] A Sc\nin\n⟨\nlet S′ ⟩\n= U(Tc, Ta, Sa)\na\nin Ta, S′\na\n[\nR[ (lambda (I1 . . . In) Eb)] A S =\nlet Tb, Sb = R Eb] A[Ii :?vi] S\nin (-> (?v1 . . . ?vn) Tb), Sb\n(?vi are new)\n[\nR[ (E0 E1 . . . En)] A S =\nlet T0, S0 = R E0] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\nin\n⟨\nlet Sf = U(T0, (-> (T1 . . . Tn) ?vf ), Sn)\nin ?vf, Sf\n(?vf is new)\n[\nR[ (let ((I1 E1) . . . (In En)) Eb)] A S =\nlet ⟨T1, S1 = R E1] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\n[\nin R Eb] A[Ii : Rgen(Ti, A, Sn)]Sn\nR[ (letrec ((I1 E1) . . . (In En)) Eb)] A S =\nlet A1 = A[Ii :?vi]\n(?vi are new)\n[\nin let T1, S1 = R E1] A1 S\nin . . .\n[\nlet Tn, Sn = R En] A1 Sn-1\nin\n⟨\nlet Sb = U(?vi, Ti, Sn)\n[\nin R Eb] A[Ii : Rgen(Ti, A, Sb)] Sb\n[\nR[ (record (I1 E1) . . . (In En))] A S =\nlet T1, S1 = R E1] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\nin (recordof (I1 T1) . . . (In Tn)), Sn⟩\n[\nR[ (with (I1 . . . In) Er Eb)] A S = let Tr, Sr = R Er] A S\nin\n⟨\nlet Sb\n⟩\n= U(Tr, (recordof (I1 ?vi) . . . (In ?vn)), Sr)\n(?vi are new)\n[\nin R Eb] A[Ii :?vi] Sb\nRgen(T, A, S) = Gen((S T), (subst-in-type-env S A))\n\nAppendix F: Meta-CPS Conversion Rules\nIn the following rules, grey mathematical notation (like λv) and square brackets [ ] are used for\n\"meta-application\", which is evaluated as part of meta-CPS conversion. Code in BLACK TYPEWRITER FONT is\npart of the output program; meta-CPS conversion does not evaluate any of this code. Therefore, you can\nthink of meta-CPS-converting an expression E as rewriting MCPS[\n]] until no grey is left.\n[E\nE ∈ Exp\nm ∈ Meta-Continuation = Exp → Exp\nmeta-cont → exp : (Exp → Exp) → Exp = [λm . (LAMBDA (t)[m t])]\nexp → meta-cont : Exp → (Exp → Exp) = [λE . [λV . (CALL E V )]]\nmeta-cont→exp [λV . (CALL K V )] = K\nMeta-Continuation → Exp\nMCPS : Exp →\n[I\nMCPS[ ]] = [λm . [m I]]\n[L ] = [λm . [m L]]\nMCPS[ ]\nMCPS[ (LAMBDA (I1 ... In) E)]\n= [λm . [m (LAMBDA (I1 ... In .Ki.)\n[E ] [exp → meta-cont .Ki.]])]]\n[MCPS[\n]\n\nMCPS[ (CALL E1 E2)]\n= [λm . [MCPS[ E1]] [λv1 .\n[MCPS[ E2]] [λv2 .\n(CALL v1 v2 [meta-cont → exp m])]]]]]\nMCPS[ (PRIMOP P E1 E2)]\n= [λm . [MCPS[ E1]] [λv1 .\n[MCPS[ E2]] [λv2 .\n(LET ((.Ti. (PRIMOP P v1 v2)))\n[m\n.Ti.])]]]]]\n[\nEt Ef)]\nMCPS (IF Ec\n[\n]\n= [λm . [MCPS Ec ] [λv1 .\n(LET ((K [meta-cont → exp m]))\n(IF v1\n[\n[\n]\nmeta-cont K]]\nMCPS\n[\nEt ] [exp →\n[MCPS Ef]] [exp → meta-cont K]]))]]]\nMCPS[ (LET ((I Edef )) Ebody)]\n= [λm . [MCPS[ Edef ]] [λv .\n(LET ((I v)) [MCPS[ Ebody] m])]]]\n\n′\n2. Final Examination Solutions\nProblem 1: Short Answer\na. Explicit Polymorphism\n(i) (plambda (t)\n(lambda ((f (-> (t) bool)) (g (-> (t) t) (x t)))\n(if (f x)\n(g x)\n(g (g x)))))\n(ii) (lambda ((f (poly (t) (-> (t) t))))\n(if ((proj f bool) #t)\n((proj f int) ((proj f int) 1))\n((proj f int) 2)))\nb. Type Reconstruction\n(i) No reconstructed type exists. There is no first class polymorphism allowed in Scheme/R.\n(ii) int\n(iii) No reconstructed type exists. No heterogeneous lists in Scheme/R.\n(iv) No reconstructed type exists. Hindley-Milner cannot reconstruct the type of an identifier in-\nvolved in a self application.\nProblem 2: Operational Semantics\na.\n:\nProgramTwoStack →CTwoStack\nI TwoStack\nTwoStack\n=\nλ Q1, Q2 .\n1, Q2⟩, []Value , []Value\nI\n⟨\n⟩⟨⟨Q\n⟩\nTwoStack\n=\n{[]CommandPostFix+Talk } × {[]CommandPostFix+Talk } × Stack × Stack\nF\nTwoStack\n:\nF →AnswerTwoStack\nO\n, S1, S2 .\nTwoStack\n=\nλ⟨⟨[]CommandPostFix+Talk , []CommandPostFix+Talk\nO\n⟩\n⟩\nPostFix ⟨[]CommandPostFix+Talk , S1 , OPostFix ⟨[]CommandPostFix+Talk , S\n⟨O\n⟩\n2⟩⟩\n⇒TwoStack\n:\nQ1, S\nPostFix+Talk Q1, S′\n2, S\nPostFix+Talk Q2, S′\n⟨\n1⟩⇒\n⟨\n1⟩∧⟨Q\n2⟩⇒\n′\n⟨\n′\n⟩\n1, Q2 , S1, S\nTwoStack ⟨⟨Q1, Q2 , S1, S2\n′\n⟨⟨Q\n⟩\n2⟩⇒\n′\n⟩\n′\n⟩\nb.\n⟨⟨talk.Q1, talk.Q2 , V1.S1, V2.S\nTwoStack\n1, Q2 , V2.V1.S1, V1.V2.S2\n⟩\n2⟩\n⇒\n⟨⟨Q\n⟩\n⟩\nc. The following program does not terminate:\n<((talk exec) talk exec),((talk exec) talk exec)>\n\n⟩\nProblem 3: Denotational Semantics\n[E ] = (E[\n]] empty-env (λdk . (top-level-cont d)) top-level-cont empty-store)\na. T L[\n]\n\n[E\nb. E[ (call E1 E2)] = λep1k . (E[ E1] e p1 (test-procedure (λp2 . (E[ E2] e p1 (λv . (p2 v k))))))\nc. E[ (self E)] = λepk . (E[ E] e p λv . (p v k))\nd. E[ (proc I E)] =\nλep1k1 . (k1 (Procedure→Value (fixP rocedure(λp2 . (λdk2 . (E[ ]\n\n[E ] [I : d]e p2 k2))))))\ne.\nT L[ (self (self 1))]] =\n=\n(E[ (self (self 1))] empty-env (λdk . (top-level-cont d)) top-level-cont empty-store)\n=\n(E[ (self 1)] empty-env (λdk . (top-level-cont d)) top-level-cont empty-store)\nbecause λv . (λdk . (top-level-cont d) v k) = top-level-cont\n=\n(E[ ]\n[1] empty-env (λdk . (top-level-cont d)) top-level-cont empty-store)\n=\n(top-level-cont L[ 1]])\n=\n(Value→Expressible (Int→Value 1))\nf.\nE[ (proc x (self 1))]\n=\nλep1k1 . (k1 (Procedure→Value (fixP rocedure λp2 . (λdk2 . (E[ (self 1)]] [x : d]e p2 k2)))))\n=\nλep1k1 . (k1 (Procedure→Value (fixP rocedure λp2 . (λdk2 . (E1) [x : d]e p2 λv . (p2 v k2))))))\n=\nλep1k1 . (k1 (Procedure→Value (fixP rocedure λp2 . (λdk2 . (λv . (p2 v k2) L[ 1]])))))\n=\nλep1k1 . (k1 (Procedure→Value (fixP rocedure λp2 . (λdk2 . (p2 L[ ]\n\n[1] k2)))))\nbut ⊥P rocedure is a fixed point of λp2 . (λdk2 . (p2 L[ ]\n[1] k2))\nIt should be clear that ⊥P rocedure must be the procedure-generating function's least fixed point. This\nmeans that the procedural value that the expression (proc x (self 1)) computes is ⊥P rocedure, a pro-\ncedure that given any denotable and expression continuation returns ⊥CmdC ont i.e. a procedure that\nloops forever regardless of its input. Since this procedural value is the value computed by (proc x (self\n1)), we have completed the demonstration.\nProblem 4: Type Reconstruction\na.\nA[I:(control-point T)] ⊢E : T\n[label]\nA ⊢(label I E) : T\nA ⊢E1 : (control-point T)\nA ⊢E2 : T\nA ⊢(jump E1 E2) : Tany\n[jump]\nb. R[ (label I E)] A S = let T1, S1 = R E A[I : (control-point ?v1)] S\nin ⟨\n⟨\nT1, U (T\n⟩\n1, ?v1\n[\n, S\n]\n1)\nwhere ?v1 is a fresh type variable\n\n⟩\nc. R[ (jump E1 E2)] A S = let T1, S1 = R[ E1] A S\nin\n⟨\nlet T2\n⟩\n, S2 = R[ E2] A S1\nin ⟨\n⟨\n?v1, U(\n⟩\nT1, (control-point T2), S2)\nwhere ?v1 is a fresh type variable\nd. Unification fails while reconstructing the type of (label y y). The unification call that fails is\nU((control-point ?v1),?v1,S1).\nProblem 5: Compilers\na.\n(let ((compose (lambda (f g)(lambda (x)(f (g x))))))\n((compose not integer?) 1))\nb. MCPS[[(begin E1 E2)]] m =\n(begin (MCPS[ E1]] (λV . V)) (MCPS[ E2]] m))\nc. T [\n]\n[E ]=\n(let ((v P))\n(let ((r [v/P]E))\n(begin\n(%procedure-free v)\nr)))\nd. One possible explanation is that the programs do not exhaust memory, and thus the garbage collec-\ntor is never called. In that case, explicitly freeing unused closures is extra work that has no benefit.\nAnother possibility is that in some programs, explicitly freeing closures releases enough memory so\nthe garbage collector is no longer invoked, leading to storage fragmentation that slows the program\ndown."
    },
    {
      "category": "Resource",
      "title": "35.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/5ff04820d22e8dc01700ee53c485facc_35.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\nFinal Examination 2001\nThere are five problems on this examination. Make sure you don't skip over any of a problem's parts! They\nare followed by an appendix that contains reference material from the course notes. The appendix contains\nno problems; it is just a handy reference.\nYou will have three hours in which to work the problems. Some problems are easier than others: read all\nproblems before beginning to work, and use your time wisely!\nThis examination is open-book: you may use whatever reference books or papers you have brought to the\nexam. The number of points awarded for each problem is placed in brackets next to the problem number.\nThere are 100 points total on the exam.\nDo all written work in your examination booklet - we will not collect the examination handout itself; you\nwill only be graded for what appears in your examination booklet. It will be to your advantage to show\nyour work - we will award partial credit for incorrect solutions that make use of the right techniques.\nIf you feel rushed, be sure to write a brief statement indicating the key idea you expect to use in your\nsolutions. We understand time pressure, but we can't read your mind.\nThis examination has text printed on only one side of each page. Rather than flipping back and forth be-\ntween pages, you may find it helpful to rip pages out of the exam so that you can look at more than one\npage at the same time.\nContents\nProblem 1: Short Answer [20 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 2: State: FLK# [20 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 3: Explicit Types [20 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 4: Type Reconstruction [20 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nProblem 5: Compiling [20 points] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix A: Standard Semantics of FLK! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix B: Typing Rules for SCHEME/XSP\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix C: Typing Rules for SCHEME/R . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix D: Type Reconstruction Algorithm for SCHEME/R . . . . . . . . . . . . . . . . . . . . . .\nAppendix E: Meta-CPS Conversion Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nAppendix F: Match Desugaring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nThe figures in the Appendix are very similar to the ones in the course notes. Some bugs have been fixed,\nand some figures have been simplified to remove parts inessential for this exam. You will not be marked\ndown if you use the corresponding figures in the course notes instead of the appendices.\n\nProblem 1: Short Answer [20 points]\na. Given the following domains:\nA = {1} ⊥\nB = {a, b}⊥\n(i) [2 points]How many set theoretic functions are there in A → B?\n(ii) [2 points] How many continuous functions are there in A → B?\nb. In Scheme/R (Scheme with type reconstruction) give the most general type schemes of the following\nexpressions, or state why the expression does not have a type:\n(i) [1 points]\n(lambda (f) (lambda (g) (lambda (x) (g (f x)))))\n(ii) [1 points]\n(lambda (x) (x x))\n(iii) [1 points]\n(letrec ((f (lambda (x) (if (id x) (id 0) (id 1))))\n(id (lambda (y) y)))\n(f #t))\n(iv) [1 points]\n(lambda (id) (if (id #t) (id 0) (id 1)))\nc. Give the equivalent Scheme/XSP expression, and the type thereof, for each of the expressions in the\nprevious part (part b).\n(i) [2 points]\n(ii) [2 points]\n(iii) [2 points]\n(iv) [2 points]\nd. [2 points] Give the desugaring of the following Scheme/R expression (the match desugaring can be\nfound in Appendix F)\n(match z\n((cons 1 x) x)\n(x (cons 1 x)))\ne. [2 points] Use define-datatype to define the (queueof T) datatype that represents a queue with a list.\nFor example, a (queueof int) would be represented by an integer list.\n\nProblem 2: State: FLK# [20 points]\nYOUR ANSWERS TO THIS PROBLEM SHOULD BE BASED ON THE STANDARD DENOTATIONAL SE-\nMANTICS FOR FLK! AS PRESENTED IN APPENDIX A.\nSam Antics is working on a new language with hot new features that will appeal to government customers.\nHe was going to base his language on Caffeine from Moon Microsystems, but negotiations broke down. He\nhas therefore decided to extend FLK! and has hired you, a top FLK! consultant, to assist with modifying\nthe language to support these new features. The new language is called FLK#, part of Sam Antics' new\n.GOV platform. The big feature of FLK# is user tracking and quotas in the store. An important customer\nobserved that government users tended to use the store carelessly, resulting in expensive memory upgrades.\nTo improve the situation, the FLK# store will maintain a per-user quota. (A quota restricts the number of\ncells a particular user can allocate.) The Standard Semantics of FLK! are changed as follows:\nw ∈ UserID = Int\nq ∈ Quota = UserID → Int\nγ ∈ Cmdcont = UserID → Quota → Store → Expressible\nerror-cont : Error → Cmdcont\n= λy . λw . λq . λs . (Error →Expressible y)\nUserID is just an integer. User ID 0 is reserved for the case when no one is logged in. Quota is a function\nthat when given a UserID returns the number of cells remaining in the user 's quota. The quota starts at\n100 cells, and a user 's quota is tracked throughout the lifetime of the program (i.e., the quota is not reset\nupon logout). Cmdcont has been changed to take the currently logged in user ID, the current quota, and\nthe current store to yield an answer. Plus, FLK# adds the following commands:\nE\n::=\n. . .\n[Classic FLK! expressions]\n|\n(login! w)\n[Log in user w]\n|\n(logout!)\n[Log out current user]\n|\n(check-quota)\n[Check user quota]\n(login! w) - logs in the user associated with the identifier w; returns w (returns an error if a user is already\nlogged in or if the UserID is 0)\n(logout!) - logs the current user out; returns the last user 's identifier (returns an error if there is no user\nlogged in)\n(check-quota) - returns the amount of quota remaining\nThe definition of E [ (check-quota)] is:\nE [ (check-quota)]] =\nλekwq . if w = 0\nthen error-cont no-user-logged-in w q\nelse (k (Int →Value (q w)) w q) fi\na. [5 points] Write the meaning function clause for E [ (login! E)] .\nb. [5 points] Write the meaning function clause for E [ (logout!)] .\nc. [5 points] Give the definition of E [ (cell E)] . Remember you cannot create a cell unless you are\nlogged in.\nd. [5 points] Naturally, Sam Antics wants to embed some \"trap doors\" into the .GOV platform to enable\nhim to \"learn more about his customers.\" One of these trap doors is the undocumented (raise-quota! n)\ncommand, which adds n cells to the quota of the current user and returns 0. Give the definition of\nE [ (raise-quota! E)] .\n\nProblem 3: Explicit Types [20 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON THE SCHEME/XSP TYPING\nRULES GIVEN IN APPENDIX B.\nLouis Reasoner has had a hard time implementing letrec in a call-by-name version of Scheme/XSP,\nand has decided to use the fixed point operator FIX instead. For example, here the the correct defintion of\nfactorial in Louis' approach:\n(let ((fact-gen (lambda ((fact (-> (int) int)))\n(lambda ((n int)) (if (= n 0) 1 (* n (fact (- n 1))))))))\n((proj fix (-> (int) int)) fact-gen))\nThus fix is a procedure that computes the fixed point of a generating function. Ben Bitdiddle has been\ncalled on the scene to help, and he has ensured that Louis' Scheme/XSP supports recursive types using\nRECOF (see Appendix B).\na. [4 points] What is the type of fact-gen?\nb. [3 points] What is the type of fix?\nc. [3 points] What is the type of ((proj fix (-> (int) int)) fact-gen)?\nBen Bitdiddle defined the call-by-name version of fix to be:\n(let ((fix (plambda (t) (lambda ((f T1))\n(lambda ((x T2)) (f (x x))) (lambda ((x T2)) (f (x x)))))))\n... fix can be used here ...\n)\nd. [3 points] What is T1?\ne. [4 points] What is T2?\nf. [3 points] Louis has decided that he would like (fix E) to be a standard expression in his language.\nWhat is the typing rule for (fix E)?\n\nProblem 4: Type Reconstruction [20 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON THE SCHEME/R TYPING\nRULES AND TYPE RECONSTRUCTION ALGORITHM GIVEN IN APPENDICES C AND D.\nWith sales declining and customers flocking to competitors' products, the board of directors at Prophet.com\nhas decided to oust CTO Louis Reasoner and has assigned you and Alyssa P. Hacker as the pro tempore co-\nCTOs. Alyssa believes the secret to regaining market share is to make Scheme/R more Internet-friendly. The\nnext generation product, code-named Scheme/R 9i (the i stands for Internet), contains socket functionality\nto make it easier to write Internet servers.\nA socket is like a stream or a channel in that you can read data from and write data to sockets. Sockets\nare named by a port number and also have a specific data type associated with them that determines the\ntype of data that can be transmitted or received over the socket. (For the purpose of this problem, you can\nignore any problems involved with opening more than one socket on the same port.)\nWe introduce a new type (socketof T) and six new forms:\n- (int-socket Eport) returns a new integer socket.\n- (bool-socket Eport) returns a new boolean socket.\n- (unit-socket Eport) returns a new unit socket.\n- (symbol-socket Eport) returns a new symbol socket.\n- (read-all! Esocket Ereader ) takes a socket and calls procedure Ereader once for each item remaining\nin the socket to be read; returns #u.\n- (write! Esocket Edatum ) Writes Edatum into the socket and returns #u.\nAlyssa has written the following Scheme/R type rules to get you started:\nA ⊢ E : int\n[int-socket]\nA ⊢ (int-socket E) : (socketof int)\nA ⊢ E : int\n[bool-socket]\nA ⊢ (bool-socket E) : (socketof bool)\nA ⊢ E : int\n[unit-socket]\nA ⊢ (unit-socket E) : (socketof unit)\nA ⊢ E : int\n[symbol-socket]\nA ⊢ (symbol-socket E) : (socketof symbol)\nA ⊢ Esocket : (socketof T)\nA ⊢ Ereader : (-> (T) unit)\n[read-all!]\nA ⊢ (read-all! Esocket Ereader ) : unit\nA ⊢ Esocket : (socketof T)\nA ⊢ Edatum : T\n[write!]\nA ⊢ (write! Esocket Edatum ) : unit\nShe has also agreed to write the implementation. Because you are a high-paid 6.821 consultant, your part is\nto write the type reconstruction algorithm for these constructs.\na. [4 points] Give the type reconstruction algorithm for (int-socket Eport).\n\nb. [4 points] Give the type reconstruction algorithm for (write! Esocket Edatum ).\nc. [4 points] Give the type reconstruction algorithm for (read-all! Esocket Ereader ).\nd. [4 points] As part of Louis's severance agreement, he agreed to stay on for one month to write a proxy\nserver for Prophet.com's intranet (by proxy server we mean something that reads data on one socket\nand writes it to another). He wrote the following code:\n(letrec ((proxy (lambda (socket-in socket-out)\n(read-all! socket-in\n(lambda (x) (write! socket-out x)))))\n(do-proxy-http (lambda () (proxy (symbol-socket 80)\n(symbol-socket 8080))))\n(do-proxy-ftp (lambda () (proxy (int-socket 20)\n(int-socket 8020)))))\n(begin\n(do-proxy-http)\n(do-proxy-ftp)))\nUnfortunately, on his way out on his last day, he gives you the code and tells you it doesn't type check.\nGive a semantically equivalent (i.e., preserves procedures and procedure calls) replacement for Louis'\ncode that does type check.\ne. [4 points] Being the astute 6.821 consultant that you are, you also discover that Louis has used a\nconstruct that doesn't have a type reconstruction algorithm in the book: begin. Give the type recon-\nstruction algorithm for (begin E1 E2).\n\nProblem 5: Compiling [20 points]\nANSWERS FOR THE FOLLOWING QUESTIONS SHOULD BE BASED ON THE META CPS CONVER-\nSION ALGORITHM GIVEN IN APPENDIX E.\na. [7 points] What source code generated the following output from the Tortoise compiler?\n(program\n(define *top*\n(%closure (lambda (.closure8. x) x)))\n(call-closure\n*top*\n(%closure\n(lambda (.closure7. f .k1.)\n(call-closure\n.k1.\n(%closure\n(lambda (.closure6. x .k2.)\n(call-closure\n(%closure-ref .closure6. 1)\nx\n(%closure\n(lambda (.closure5. .t3.)\n(call-closure (%closure-ref .closure5. 1)\n.t3.\n(%closure-ref .closure5. 2)))\n(%closure-ref .closure6. 1)\n.k2.)))\nf))))))\nb. [7 points] The meaning of\n(COND (P1 E1) (P2 E2) (else E3))\nis E1 if P1 is true, E2 is P1 is false\nand P2 is true, and E3 otherwise.\nWhat is MCPS[ (COND (P1 E1) (P2 E2) (else E3))] ?\nc. Louis Reasoner has decided to add garbage collection to a language that previously employed explicit\nstorage allocation with MALLOC and FREE opeators. His new implementation ignores FREE and\nreclaims space using a brand new and correct garbage collector. The garbage collector has more than\ntwice as much heap space as the old explictly managed heap. As soon as this new version of the\nlanguage is released, several programs that used to run fine - crash!!\n(i) [3 points] What is the problem?\n(ii) [3 points] How can the programmers fix the problems with their programs?\n\nAppendix A: Standard Semantics of FLK!\nv ∈ Value = Unit + Bool + Int + Sym + Pair + Procedure + Location\nk ∈ Expcont = Value\nCmdcont\n→\nγ ∈ Cmdcont = Store → Expressible\nExpressible = (Value + Error) ⊥\nError = Sym\np ∈ Procedure = Denotable → Expcont → Cmdcont\nd ∈ Denotable = Value\ne ∈ Environment = Identifier → Binding\nβ ∈ Binding = (Denotable + Unbound)⊥\nUnbound = {unbound}\ns ∈ Store = Location → Assignment\nl ∈ Location = Nat\nα ∈ Assignment = (Storable + Unassigned)⊥\nσ ∈ Storable = Value\nUnassigned = {unassigned}\ntop-level-cont : Expcont\n= λv . λs . (Value →Expressible v)\nerror-cont : Error\nCmdcont\n→\n= λy . λs . (Error →Expressible y)\nempty-env : Environment = λI . (Unbound →Binding unbound)\ntest-boolean : (Bool → Cmdcont) → Expcont\n= λf . (λv . matching v\n[\n▷(Bool\nValue b) ] (f b)\n→\n▷else (error-cont non-boolean)\nendmatching )\nSimilarly for:\ntest-procedure : (Procedure → Cmdcont) → Expcont\ntest-location : (Location → Cmdcont) → Expcont\netc.\nensure-bound : Binding → Expcont → Cmdcont\n= λβk . matching β\n[\n▷(Denotable →Binding v) ] (k v)\n[\n▷(Unbound →Binding unbound) ] (error-cont unbound-variable )\nendmatching\nSimilarly for:\nensure-assigned : Assignment → Expcont → Cmdcont\nFigure 1: Semantic algebras for standard semantics of strict CBV FLK!.\n\nsame-location? : Location\nLocation\nBool = λl1l2 . (l1 =Nat l2)\n→\nnext-location : Location\n→\nLocation = λl . (l +Nat 1)\n→\nempty-store : Store = λl . (Unassigned →Assignment unassigned)\nfetch : Location → Store → Assignment = λls . (s l)\nassign : Location\nStorable\nStore\nStore\n→\n→\n→\n= λl1σ s . λl2 . if (same-location? l1 l2)\nthen (Storable →Assignment σ)\nelse (fetch l2 s)\nfresh-loc : Store\nLocation = λs . (first-fresh s 0)\n→\nfirst-fresh : Store\nLocation\nLocation\n→\n= λsl . matching (fetch l s)\n→\n▷ (Unassigned →Assignment unassigned) ][ l\n▷ else (first-fresh s (next-location l))\nendmatching\nlookup : Environment → Identifier → Binding = λeI . (e I)\nFigure 2: Store helper functions for standard semantics of strict CBV FLK!.\n\nT L : Exp →Expressible\nE : Exp →Environment →Expcont →Cmdcont\nL : Lit\nValue ; Defined as usual\n→\n[ ]\n[ ]\nE ] = E [E ] empty-env top-level-cont empty-store\nT L[\n[ ]\n[ ]\nL ] = λek . k L[L ]\nE [\n[ ]I ] = λek . ensure-bound (lookup e I) k\nE [\n[ ]\nE[ (proc I E)]] = λek . k (Procedure\nValue (λdk ′ . E E ] [I : d]e k ′))\n→\n[\n]\n\ne (test-procedure (λp . E E2\nE[ (call E1 E2)]] = λek . E E1\n[\n]\n\ne (λv . p v k)))\nE[ (if E1 E2 E3)]] =\n[\n]\n\n[\n]\n[\n]\nλek . E [E1 ] e (test-boolean (λb . if b then E [E2 ] e k else E [E3 ] e k))\n[\n]\n\ne (λv1 . E E2\nE[ (pair E1 E2)]] = λek . E E1\n[\n]\n\ne (λv2 . k (Pair\nValue\nv1, v2 )))\n→\n⟨\n⟩\nE[ (cell E)]] = λek . E E\n[ ]\n\ne (λvs . k (Location\nValue (fresh-loc s))\n→\n(assign (fresh-loc s) v s))\n[\n]\n\n[\n]\nE[ (begin E1 E2)]] = λek . E [E1 ] e (λvignore . E [E2 ] e k)\n[ ]\n\nE[ (primop cell-ref E)]] = λek . E E\ne (test-location (λls . ensure-assigned (fetch l s) k s))\nE[ (primop cell-set! E1 E2)]\n[\n]\n\n[\n]\n= λek . E [E1 ] e (test-location (λl . E [E2 ] e (λvs . k (Unit\nValue unit) (assign l v s))))\n→\nE[ (rec I E)]] = λeks . let f = fixExpressible (λa . E E\n[\n]\n\n[I : (extract-value a)] e top-level-cont s)\nmatching f\n▷(Value →Expressible v) ] E E\n\n[\n[\n]\n\n[I : v] e k s\n▷else f\nendmatching\nextract-value : Expressible →Binding\n= λa . matching a\n[\n▷(Value →Expressible v) ] (Denotable →Binding v)\n▷else ⊥Binding\nendmatching\nFigure 3: Valuation clauses for standard semantics of strict CBV FLK!.\n\nAppendix B: Typing Rules for SCHEME/XSP\nSCHEME/X Rules\n: int\n[int]\n⊢ N\n: bool\n[bool]\n⊢ B\n: string\n[string]\n⊢ S\n⊢ (symbol I) : sym\n[sym]\nA[I:T] ⊢ I : T\n[var]\n∀i (A ⊢ Ei : Ti)\n[begin]\nA ⊢ (begin E1 . . . En) : Tn\n: T\nA ⊢ E\n[the]\nA ⊢ (the T E) : T\nA ⊢ E1 : bool ; A ⊢ E2 : T ; A ⊢ E3 : T\n[if ]\nA ⊢ (if E1 E2 E3) : T\nA[I1:T1, ..., In:Tn] ⊢ EB : TB\n[λ]\nA ⊢ (lambda ((I1 T1) . . . (In Tn)) EB) : (-> (T1 . . . Tn) TB)\nA ⊢ EP : (-> (T1 . . . Tn) TB)\n∀i (A ⊢ Ei : Ti)\n[call]\nA ⊢ (EP E1 . . . En) : TB\n∀i (A ⊢ Ei : Ti)\nA[I1:T1, ..., In:Tn] ⊢ EB : TB\n[let]\nA ⊢ (let ((I1 E1) . . . (In En)) EB) : TB\nA′ = A[I1:T1, ..., In:Tn]\n∀i (A′ ⊢ Ei : Ti)\nA′ ⊢ EB : TB\n[letrec]\nA ⊢ (letrec ((I1 T1 E1) . . . (In T1 En)) EB) : TB\nA ⊢ (∀i [Ti/Ii])Ebody : Tbody\n[tlet]\nA ⊢ (tlet ((I1 T1) . . . (In Tn)) Ebody ) : Tbody\n∀i (A ⊢ Ei : Ti)\n[record]\nA ⊢ (record (I1 E1) . . . (In En)) : (recordof (I1 T1) . . . (In Tn))\nA ⊢ E : (recordof . . . (I T) . . .)\n[select]\nA ⊢ (select I E) : T\nA ⊢ E : TE ; T = (oneof . . . (I TE) . . .)\n[one]\nA ⊢ (one T I E) : T\nA ⊢ Edisc : (oneof (I1 T1) . . . (In Tn))\n∀i . ∃j . ((Ii = Itagj) ∧ (A[Ivalj:Ti] ⊢ Ej : T))\n[tagcase1]\nA ⊢ (tagcase Edisc (Itag1 Ival1 E1) . . . (Itagn Ivaln En)) : T\nA ⊢ Edisc : (oneof (I1 T1) . . . (In Tn))\n(∃j . (Ii = Itagj)) . A[Ivalj:Ti] ⊢ Ej : T\n∀i |\nA ⊢ Edef ault : T\n[tagcase2]\nA ⊢ (tagcase Edisc (Itag1 Ival1 E1) . . . (Itagn Ivaln En) (else Edef ault )) : T\n\nRules Introduced by SCHEME/XS to Handle Subtyping\nT ⊑ T\n[reflexive-⊑]\nT1 ⊑ T2 ; T2 ⊑ T3\n[transitive-⊑]\nT1 ⊑ T3\n(T1 ⊑ T2)\n(T2 ⊑ T1)\n[≡]\nT1 ≡ T2\n∀i ∃j ((Ii = Jj) ∧ (Sj ⊑ Ti))\n(recordof (J1 S1) . . .(Jm Sm)) ⊑ (recordof (I1 T1) . . .(In Tn))\n[recordof-⊑]\n∀j ∃i ((Jj = Ii) ∧ (Sj ⊑ Si))\n(oneof (J1 S1) . . .(Jm Sm)) ⊑ (oneof (I1 T1) . . .(In Tn))\n[oneof-⊑]\n∀i (Ti ⊑ Si) ; Sbody ⊑ Tbody\n(-> (S1 . . .Sn) Sbody ) ⊑ (-> (T1 . . .Tn) Tbody )\n[->-⊑]\n∀T ([T/I1]T1 ⊑ [T/I2]T2)\n(recof I1 T1) ⊑ (recof I2 T2)\n[recof-⊑]\nA ⊢ Erator : (-> (T1 . . .Tn) Tbody )\n∀i ((A ⊢ Ei : Si) ∧ (Si ⊑ Ti))\n[call-inclusion]\nA ⊢ (Erator E1 . . .En) : Tbody\n: S\nA\nS\n⊢\n⊑\nE\nT\n[the-inclusion]\nA ⊢ (the T E) : T\nRules Introduced by SCHEME/XSP to Handle Polymorphism\nA ⊢ E : T;\n[\n∀i (Ii ∈ (FTV (Free-Ids E]])A))\n\n[pλ]\nA ⊢ (plambda (I1 . . . In) E) : (poly (I1 . . . In) T)\nA ⊢ E : (poly (I1 . . . In) TE)\n[project]\nA ⊢ (proj E T1 . . . Tn) : (∀i [Ti/Ii]) TE\n[\n(∀i [Ii/Ji]) S ⊑ T, ∀i (Ii ∈ Free-Ids S]])\n(poly (J1 . . . Jn) S) ⊑ (poly (I1 . . . In) T)\n[poly-⊑]\nrecof Equivalence\n(recof I T) ≡ [(recof I T)/I]T\n\nAppendix C: Typing Rules for SCHEME/R\n⊢ #u : unit\n[unit]\n⊢ B : bool\n[bool]\n⊢ N : int\n[int]\n⊢ (symbol I) : sym\n[symbol]\n[. . . , I:T, . . .] ⊢ I : T\n[var]\n[. . . , I:(generic (I1 . . . In) Tbody ), . . .] ⊢ I : (∀i [Ti/Ii])Tbody\n[genvar]\nA ⊢ Etest : bool ; A ⊢ Econ : T ; A ⊢ Ealt : T\n[if ]\nA ⊢ (if Etest Econ Ealt ) : T\nA[I1:T1, . . ., In:Tn] ⊢ Ebody : Tbody\n[λ]\nA ⊢ (lambda (I1 . . . In) Ebody ) : (-> (T1 . . . Tn) Tbody )\nA ⊢ Erator : (-> (T1 . . . Tn) Tbody )\n∀i . (A ⊢ Ei : Ti)\n[apply]\nA ⊢ (Erator E1 . . . En) : Tbody\n∀i . (A ⊢ Ei : Ti)\nA[I1:Gen(T1, A), . . ., In:Gen(Tn, A)] ⊢ Ebody : Tbody\n[let]\nA ⊢ (let ((I1 E1) . . . (In En)) Ebody ) : Tbody\n∀i . (A[I1:T1, . . ., In:Tn] ⊢ Ei : Ti)\nA[I1:Gen(T1, A), . . . In:Gen(Tn, A)] ⊢ Ebody : Tbody\n[letrec]\nA ⊢ (letrec ((I1 E1) . . . (In En)) Ebody ) : Tbody\n∀i . (A ⊢ Ei : Ti)\n[record]\nA ⊢ (record (I1 E1) . . . (In En)) : (recordof (I1 T1) . . . (In Tn))\nA ⊢ Er : (recordof (I1 T1) . . . (In Tn))\nA[I1:T1, . . ., In:Tn] ⊢ Eb : T\n[with]\nA ⊢ (with (I1 . . . In) Er Eb) : T\nA ⊢ (letrec ((I1 E1) . . . (In En)) Ebody ) : T\n[program]\nA ⊢ (program (define I1 E1) . . . (define In En) Ebody ) : T\nGen(T, A) = (generic (I1 . . . In) T), where {Ii} = FTV (T) - FTE(A)\n\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟩\n⟨\n⟩\n⟨\n⟩\n⟨\nAppendix D: Type Reconstruction Algorithm for SCHEME/R\n[\n]\nR[#u ] A S = unit, S\n[\n]\nR[B ] A S = bool, S\n[\n]\nR[N ] A S = int, S\nR[ (symbol I)] A S = sym, S\n[ ]\nR[I ] A[I : T] S = T, S\n[ ]\nR[I ] A[I : (generic (I1 . . . In) T)] S = T[?vi/Ii], S\n(?vi are new)\n[ ]\nR[I ] A S = fail\n(when I is unbound)\n[\nR[ (if Et Ec Ea)] A S = let Tt, St = R Et] A S\nin\n⟨\nlet St\n′ ⟩\n= U(Tt, bool, St)\n[\nin let ⟨Tc, Sc = R Ec] A St\n′\n[\nin let Ta, Sa = R Ea] A Sc\nin\n⟨\nlet S′ ⟩\n= U(Tc, Ta, Sa)\na\nin Ta, S′\na\n[\nR[ (lambda (I1 . . . In) Eb)] A S =\nlet Tb, Sb = R Eb] A[Ii :?vi] S\nin (-> (?v1 . . . ?vn) Tb), Sb\n(?vi are new)\n[\nR[ (E0 E1 . . . En)] A S =\nlet T0, S0 = R E0] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\nin\n⟨\nlet Sf = U(T0, (-> (T1 . . . Tn) ?vf ), Sn)\nin ?vf, Sf\n(?vf is new)\n[\nR[ (let ((I1 E1) . . . (In En)) Eb)] A S =\nlet ⟨T1, S1 = R E1] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\n[\nin R Eb] A[Ii : Rgen(Ti, A, Sn)]Sn\nR[ (letrec ((I1 E1) . . . (In En)) Eb)] A S =\nlet A1 = A[Ii :?vi]\n(?vi are new)\n[\nin let T1, S1 = R E1] A1 S\nin . . .\n[\nlet Tn, Sn = R En] A1 Sn-1\nin\n⟨\nlet Sb = U(?vi, Ti, Sn)\n[\nin R Eb] A[Ii : Rgen(Ti, A, Sb)] Sb\n[\nR[ (record (I1 E1) . . . (In En))] A S =\nlet T1, S1 = R E1] A S\nin . . .\n[\nlet Tn, Sn = R En] A Sn-1\nin (recordof (I1 T1) . . . (In Tn)), Sn⟩\n[\nR[ (with (I1 . . . In) Er Eb)] A S = let Tr, Sr = R Er] A S\nin\n⟨\nlet Sb\n⟩\n= U(Tr, (recordof (I1 ?vi) . . . (In ?vn)), Sr)\n(?vi are new)\n[\nin R Eb] A[Ii :?vi] Sb\nRgen(T, A, S) = Gen((S T), (subst-in-type-env S A))\n\nAppendix E: Meta-CPS Conversion Rules\nIn the following rules, grey mathematical notation (like λv) and square brackets [ ] are used for\n\"meta-application\", which is evaluated as part of meta-CPS conversion. Code in BLACK TYPEWRITER FONT is\npart of the output program; meta-CPS conversion does not evaluate any of this code. Therefore, you can\nthink of meta-CPS-converting an expression E as rewriting MCPS[\n]] until no grey is left.\n[E\nE ∈ Exp\nm ∈ Meta-Continuation = Exp → Exp\nmeta-cont → exp : (Exp → Exp) → Exp = [λm . (LAMBDA (t)[m t])]\nexp → meta-cont : Exp → (Exp → Exp) = [λE . [λV . (CALL E V )]]\nmeta-cont→exp [λV . (CALL K V )] = K\nMCPS : Exp → Meta-Continuation → Exp\n[I\nMCPS[ ]] = [λm . [m I]]\nMCPS[ ]\n[L ] = [λm . [m L]]\nMCPS[ (LAMBDA (I1 ... In) E)]\n= [λm . [m (LAMBDA (I1 ... In .Ki.)\n[MCPS[\n]\n[E ] [exp → meta-cont .Ki.]])]]\nMCPS[ (CALL E1 E2)]\n= [λm . [MCPS[ E1]] [λv1 .\n[MCPS[ E2]] [λv2 .\n(CALL v1 v2 [meta-cont → exp m])]]]]]\nMCPS[ (PRIMOP P E1 E2)]\n= [λm . [MCPS[ E1]] [λv1 .\n[MCPS[ E2]] [λv2 .\n(LET ((.Ti. (PRIMOP P v1 v2)))\n[m\n.Ti.])]]]]]\nMCPS[ (IF Ec Et Ef)]\n= [λm . [MCPS[ Ec]] [λv1 .\n(LET ((K [meta-cont → exp m]))\n(IF v1\n[MCPS[ Et]] [exp → meta-cont K]]\n[MCPS[ Ef]] [exp → meta-cont K]]))]]]\nMCPS[ (LET ((I Edef )) Ebody)]\n= [λm . [MCPS[ Edef ]] [λv .\n(LET ((I v)) [MCPS[ Ebody] m])]]]\n\nAppendix F: Match Desugaring\nD[ (match E (P1 E1) ... (Pn En))] =\n(let ((Itop E))\nDclauseseq [[[P1, . . . , Pn], [E1, . . . , En], Itop, (lambda () (error \"No pattern matches!\"))] )\nDclauseseq [[[ ], [ ], V, F] = (F)\nDclauseseq [ P1 . Prest , E1 . Erest , V, F] =\n(let ((Ifail (lambda () ; If P1 doesn't match, try the other clauses\nDclauseseq [ Prest , Erest , V, F] )))\nDpat[ P1, V, E1, Ifail ] )\nDpat[ L, V, S, F] = (if (equal? LIT L V) S (F))\nDpat[ _, V, S, F] = S\nDpat[ I, V, S, F] = (let ((I V)) S)\nDpat[ (I P1 ... Pn), V, S, F] =\n(I~ V\n(lambda (I1 ... In) ; Match the object's component parts\nDpatseq [[[P1, . . . , Pn], [I1, . . . , In], S, F] )\nF)\nDpatseq [[[ ], [ ], S, F] = S\nDpatseq [ P1 . Prest , I1 . Irest , S, F] =\nDpat[ P1, I1,\nDpatseq [ Prest , Irest , S, F] , ; If P1 matches, continue trying to match the rest\nF]"
    },
    {
      "category": "Resource",
      "title": "36.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/050ecdea6adb8ff1980e19f452272040_36.pdf",
      "content": "6.821 Programming Languages\nHandout\nFall 2002\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\nFinal Examination Solutions 2001\nProblem 1: Short Answer [20 points]\na. Given the following domains:\nA = {1}⊥\nB = {a, b}⊥\n(i) [2 points]How many set theoretic functions are there in A → B?\nSolution: 9\n(ii) [2 points] How many continuous functions are there in A → B?\nSolution: 5\nb. In Scheme/R (Scheme with type reconstruction) give the most general type schemes of the following\nexpressions, or state why the expression does not have a type:\n(i) [1 points]\n(lambda (f) (lambda (g) (lambda (x) (g (f x)))))\nSolution:\n(generic (t1, t2, t3) (-> ((-> (t1) t2)) (-> ((-> (t2) t3)) (-> (t1) t3))))\n(ii) [1 points]\n(lambda (x) (x x))\nSolution: Self application, no type\n(iii) [1 points]\n(letrec ((f (lambda (x) (if (id x) (id 0) (id 1))))\n(id (lambda (y) y)))\n(f #t))\nSolution: Attempted polymorphic use of id in letrec bindings, no type\n\n(iv) [1 points]\n(lambda (id) (if (id #t) (id 0) (id 1)))\nSolution: First class polymorphism, no type\nc. Give the equivalent Scheme/XSP expression, and the type thereof, for each of the expressions in the\nprevious part (part b).\n(i) [2 points]\nSolution:\n(plambda (t1 t2 t3)\n(lambda ((f (-> (t1) t2)))\n(lambda ((g (-> (t2) t3)))\n(lambda ((x t1))\n(g (f x))))))\n(poly (t1 t2 t3)\n(-> ((-> (t1) t2)) (-> ((-> (t2) t3)) (-> (t1) t3))))\n(ii) [2 points]\nSolution:\nexpression:\n(plambda (t1)\n(lambda ((x (recof t2 (-> (t2) t1))))\n(x x)))\ntype:\n(poly (t1) (-> (recof t2 (-> (t2) t1)) t1))\n(iii) [2 points]\nSolution:\nexpression:\n(letrec ((f (-> (bool) int) (f (lambda (x)\n(if ((proj id bool) x)\n((proj id int) 0)\n((proj id int) 1)))))\n(id (poly (t) (-> (t) t)) (plambda (t) (lambda ((y t)) y))))\n(f #t))\ntype:\nint\n\n(iv) [2 points]\nSolution:\nexpression:\n(lambda ((id (poly (t) (-> (t) t))))\n(if ((proj id bool) #t) ((proj id int) 0) ((proj id int) 1)))\ntype:\n(-> (poly (t) (-> (t) t)) int)\nd. [2 points] Give the desugaring of the following Scheme/R expression\n(match z\n((cons 1 x) x)\n(x (cons 1 x)))\nSolution:\n(let ((Itop z))\n(let ((Ifail (lambda () (let ((x Itop)) (cons 1 x)))))\n(cons~ Itop (lambda (I1 I2)\n(if (= I1 1)\n(let ((x I2)) x)\n(Ifail)))\nIfail)))\ne. [2 points] Use define-datatype to define the (queueof T) datatype that represents a queue with a list.\nFor example, a (queueof int) would be represented by an integer list.\nSolution:\n(define-datatype (queueof T) (list->queue (listof T))))\n\n[\n]\n[\n]\n[\n]\n[\n]\n[ ]\n[\n]\n[\n]\nProblem 2: State: FLK# [20 points]\nSam Antics is working on a new language with hot new features that will appeal to government customers.\nHe was going to base his language on Caffeine from Moon Microsystems, but negotiations broke down. He\nhas therefore decided to extend FLK! and has hired you, a top FLK! consultant, to assist with modifying\nthe language to support these new features. The new language is called FLK#, part of Sam Antics' new\n.GOV platform. The big feature of FLK# is user tracking and quotas in the store. An important customer\nobserved that government users tended to use the store carelessly, resulting in expensive memory upgrades.\nTo improve the situation, the FLK# store will maintain a per-user quota. (A quota restricts the number of\ncells a particular user can allocate.) The Standard Semantics of FLK! are changed as follows:\nw ∈ UserID = Int\nq ∈ Quota = UserID → Int\nγ ∈ Cmdcont = UserID → Quota → Store → Expressible\nerror-cont : Error → Cmdcont\n= λy . λw . λq . λs . (Error 7→Expressible y)\nUserID is just an integer. User ID 0 is reserved for the case when no one is logged in. Quota is a function\nthat when given a UserID returns the number of cells remaining in the user's quota. The quota starts at\n100 cells, and a user's quota is tracked throughout the lifetime of the program (i.e., the quota is not reset\nupon logout). Cmdcont has been changed to take the currently logged in user ID, the current quota, and\nthe current store to yield an answer. Plus, FLK# adds the following commands:\nE\n::=\n. . .\n[Classic FLK! expressions]\n|\n(login! w)\n[Log in user w]\n|\n(logout!)\n[Log out current user]\n|\n(check-quota)\n[Check user quota]\n(login! w) - logs in the user associated with the identifier w; returns w (returns an error if a user is already\nlogged in or if the UserID is 0)\n(logout!) - logs the current user out; returns the last user's identifier (returns an error if there is no user\nlogged in)\n(check-quota) - returns the amount of quota remaining\nThe definition of E [(check-quota) ] is:\nE [(check-quota) ] =\nλekwq . if w = 0\nthen error-cont no-user-logged-in w q\nelse (k (Int 7→Value (q w)) w q) fi\na. [5 points] Write the meaning function clause for E [(login! E) ].\nSolution:\nE [(login! E) ] =\nλek . E [E ] e (test-int λiw . if (w = 0) and (i 6= 0)\nthen (k (Int 7→Value i) i)\nelse error-cont already-logged-in w fi)\nb. [5 points] Write the meaning function clause for E [(logout!) ].\nSolution:\nE [(logout!) ] =\nλekw . if (w = 0) then (error-cont not-logged-in w) else (k (Int 7→Value w) 0) fi\n\n[\n]\n[\n]\n[ ]\n[\n]\n[\n]\n[ ]\nc. [5 points] Give the definition of E [(cell E) ]. Remember you cannot create a cell unless you are\nlogged in.\nSolution:\nE [(cell E) ] =\nλek . E [E ] e\n(λvw1qs . if (w1 = 0) or ((q w1) = 0)\nthen error-cont error w1 q s\nelse (k (Location 7→Value (fresh-loc s))\nw1\n(λw2 . if w2 = w1\nthen (q w1) -1\nelse (q w1) fi)\n(assign (fresh-loc s) v s))\nfi)\nd. [5 points] Naturally, Sam Antics wants to embed some \"trap doors\" into the .GOV platform to enable\nhim to \"learn more about his customers.\" One of these trap doors is the undocumented (raise-quota! n)\ncommand, which adds n cells to the quota of the current user and returns 0. Give the definition of\nE [(raise-quota! E) ].\nSolution:\nE [(raise-quota! E) ] =\nλek . E [E ] e (test-int λiw1q . if w1 = 0\nthen error-cont error-no-user-logged-in w q\nelse (k (Int 7→Value 0) w1\nλw2 . if w2 = w1 then (q w1) + i else (q w1)) fi\nfi)\n\nProblem 3: Explicit Types [20 points]\nLouis Reasoner has had a hard time implementing letrec in a call-by-name version of Scheme/XSP,\nand has decided to use the fixed point operator FIX instead. For example, here the the correct defintion of\nfactorial in Louis' approach:\n(let ((fact-gen (lambda ((fact (-> (int) int)))\n(lambda ((n int)) (if (= n 0) 1 (* n (fact (- n 1))))))))\n((proj fix (-> (int) int)) fact-gen))\nThus fix is a procedure that computes the fixed point of a generating function. Ben Bitdiddle has been\ncalled on the scene to help, and he has ensured that Louis' Scheme/XSP supports recursive types using\nRECOF (see Appendix ??).\na. [4 points] What is the type of fact-gen?\nSolution:\n(-> ((-> (int) int)) (-> (int) int))\nb. [3 points] What is the type of fix?\nSolution:\n(poly (t) (-> ((-> (t) t)) t))\nc. [3 points] What is the type of ((proj fix (-> (int) int)) fact-gen)?\nSolution:\n(-> (int) int)\nBen Bitdiddle defined the call-by-name version of fix to be:\n(let ((fix (plambda (t) (lambda ((f T1))\n(lambda ((x T2)) (f (x x))) (lambda ((x T2)) (f (x x)))))))\n... fix can be used here ...\n)\nd. [3 points] What is T1?\nSolution:\nT1 = (-> (t) t)\ne. [4 points] What is T2?\nSolution:\nT2 = (recof x (-> (x) t))\n\nf. [3 points] Louis has decided that he would like (fix E) to be a standard expression in his language.\nWhat is the typing rule for (fix E)?\nSolution:\nA ` E : (-> (T) T)\nA ` (fix E) : T\n[fix]\n\n[\n]\n[\n]\nProblem 4: Type Reconstruction [20 points]\nWith sales declining and customers flocking to competitors' products, the board of directors at Prophet.com\nhas decided to oust CTO Louis Reasoner and has assigned you and Alyssa P. Hacker as the pro tempore co-\nCTOs. Alyssa believes the secret to regaining market share is to make Scheme/R more Internet-friendly. The\nnext generation product, code-named Scheme/R 9i (the i stands for Internet), contains socket functionality\nto make it easier to write Internet servers.\nA socket is like a stream or a channel in that you can read data from and write data to sockets. Sockets\nare named by a port number and also have a specific data type associated with them that determines the\ntype of data that can be transmitted or received over the socket. (For the purpose of this problem, you can\nignore any problems involved with opening more than one socket on the same port.)\nWe introduce a new type (socketof T) and six new forms:\n- (int-socket Eport) returns a new integer socket.\n- (bool-socket Eport) returns a new boolean socket.\n- (unit-socket Eport) returns a new unit socket.\n- (symbol-socket Eport) returns a new symbol socket.\n- (read-all! Esocket Ereader ) takes a socket and calls procedure Ereader once for each item remaining\nin the socket to be read; returns #u.\n- (write! Esocket Edatum) Writes Edatum into the socket and returns #u.\nAlyssa has written the following Scheme/R type rules to get you started:\nA ` E : int\nA ` (int-socket E) : (socketof int)\n[int-socket]\nA ` E : int\nA ` (bool-socket E) : (socketof bool)\n[bool-socket]\nA ` E : int\nA ` (unit-socket E) : (socketof unit)\n[unit-socket]\nA ` E : int\nA ` (symbol-socket E) : (socketof symbol)\n[symbol-socket]\nA ` Esocket : (socketof T)\nA ` Ereader : (-> (T) unit)\n[read-all!]\nA ` (read-all! Esocket Ereader ) : unit\nA ` Esocket : (socketof T)\nA ` Edatum : T\n[write!]\nA ` (write! Esocket Edatum) : unit\nShe has also agreed to write the implementation. Because you are a high-paid 6.821 consultant, your part is\nto write the type reconstruction algorithm for these constructs.\na. [4 points] Give the type reconstruction algorithm for (int-socket Eport).\nSolution:\nR [(int-socket E) ] A S = let hT, S1i = R [E ] A S\nin h(socketof int), U (T, int, S1)i\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nb. [4 points] Give the type reconstruction algorithm for (write! Esocket Edatum).\nSolution:\nR [(write! Esocket Edatum) ] A S = let hT1, S1i = R [Esocket ] A S\nin let hT2, S2i = R [Edatum ] A S1\nin let S3 = U (T1, (socketof ?t), S2)\nin hunit, U (T2, ?t, S3)i\nc. [4 points] Give the type reconstruction algorithm for (read-all! Esocket Ereader ).\nSolution:\nR [(read-all! Esocket Ereader ) ] A S = let hT1, S1i = R [Esocket ] A S\nin let hT2, S2i = R [Ereader ] A S1\nin let S3 = U (T1, (socketof ?t), S2)\nin hunit, U (T2, (-> (?t) unit), S3)i\nd. [4 points] As part of Louis's severance agreement, he agreed to stay on for one month to write a proxy\nserver for Prophet.com's intranet (by proxy server we mean something that reads data on one socket\nand writes it to another). He wrote the following code:\n(letrec ((proxy (lambda (socket-in socket-out)\n(read-all! socket-in\n(lambda (x) (write! socket-out x)))))\n(do-proxy-http (lambda () (proxy (symbol-socket 80)\n(symbol-socket 8080))))\n(do-proxy-ftp (lambda () (proxy (int-socket 20)\n(int-socket 8020)))))\n(begin\n(do-proxy-http)\n(do-proxy-ftp)))\nUnfortunately, on his way out on his last day, he gives you the code and tells you it doesn't type check.\nGive a semantically equivalent (i.e., preserves procedures and procedure calls) replacement for Louis'\ncode that does type check.\nSolution: It doesn't type check because in the definition of do-proxy-http, proxy is resolved to have\ntype (-> ((socketof symbol) (socketof symbol)) unit), and thus canont be used polymorphi\ncally by (do-proxy-ftp) to have type (-> ((socketof int) (socketof int)) unit).\nThe following code does not exhibit this problem.\n(let ((proxy (lambda (socket-in socket-out)\n(read-all! socket-in\n(lambda (x) (write! socket-out x))))))\n(let (do-proxy-http (lambda () (proxy (symbol-socket 80)\n(symbol-socket 8080))))\n(do-proxy-ftp (lambda () (proxy (int-socket 20)\n(int-socket 8020)))))\n(begin\n(do-proxy-http)\n(do-proxy-ftp))))\n\n[\n]\n[\n]\n[\n]\ne. [4 points] Being the astute 6.821 consultant that you are, you also discover that Louis has used a\nconstruct that doesn't have a type reconstruction algorithm in the book: begin. Give the type recon\nstruction algorithm for (begin E1 E2).\nSolution:\nR [(begin E1E2...En) ] A S = let hT1, S1i = R [E1 ] A S\nin . . .\nlet hTn, Sni = R [En ] A Sn-1\nin hTn, Sni\n\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\n[\n]\nProblem 5: Compiling [20 points]\na. [7 points] What source code generated the following output from the Tortoise compiler?\n(program\n(define *top*\n(%closure (lambda (.closure8. x) x)))\n(call-closure\n*top*\n(%closure\n(lambda (.closure7. f .k1.)\n(call-closure\n.k1.\n(%closure\n(lambda (.closure6. x .k2.)\n(call-closure\n(%closure-ref .closure6. 1)\nx\n(%closure\n(lambda (.closure5. .t3.)\n(call-closure (%closure-ref .closure5. 1)\n.t3.\n(%closure-ref .closure5. 2)))\n(%closure-ref .closure6. 1)\n.k2.)))\nf))))))\nSolution:\n(lambda (f) (lambda (x) (f (f x))))\nb. [7 points] The meaning of (COND (P1 E1) (P2 E2) (else E3)) is E1 if P1 is true, E2 is P1 is false\nand P2 is true, and E3 otherwise.\nWhat is MCPS [(COND (P1 E1) (P2 E2) (else E3)) ]?\nSolution:\nMCPS [(COND (P1 E1) (P2 E2) (else E3)) ]\n= λm .\n(let ((k (lambda (v) [m v])))\nλm . MCPS [P1 ] [λv1 .\n(IF v1\n[MCPS [E1 ][exp → meta-cont k]]\n[MCPS [P2 ][λv2 .\n(IF v2\n[MCPS [E2 ][exp → meta-cont k]]\n[MCPS [E3 ][exp → meta-cont k]])]])]\nc. Louis Reasoner has decided to add garbage collection to a language that previously employed explicit\nstorage allocation with MALLOC and FREE opeators. His new implementation ignores FREE and\nreclaims space using a brand new and correct garbage collector. The garbage collector has more than\ntwice as much heap space as the old explictly managed heap. As soon as this new version of the\nlanguage is released, several programs that used to run fine - crash!!\n\n(i) [3 points] What is the problem?\nSolution: The programs crash because they run out of storage. Pointers to unused storage are\nnot being destroyed, and thus the GC can not reclaim storage that was previosly freeded with\nFREE.\n(ii) [3 points] How can the programmers fix the problems with their programs?\nSolution: Zero all pointers to storage that are no longer in use."
    },
    {
      "category": "Resource",
      "title": "04.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/a26c4abed48538917955fefe084adfdd_04.pdf",
      "content": "6.821 Programming Languages\nHandout 4\nFall 2002\nSeptember 5\nMASSACHVSETTS INSTITVTE OF TECHNOLOGY\nDepartment of Electrical Engineering and Compvter Science\nLab Notes\n6.821 programming assignments use Scheme+, an extension of Scheme extended with a few new fea-\ntures -- see the Scheme+ tutorial (appendix A of the Scheme supplement of the course notes).\nThis handout provides information about how to access and run Scheme+. There are two ways to run\nScheme+:\na. Run Scheme+ on your office or personal machine. To do so requires having a version of MIT Scheme\nrunning on your machine. section 2 gives instructions for getting Scheme+ and MIT Scheme.\nThis option provides you with the most control over your lab time and resources, but may require\nsome extra work if MIT Scheme is not already installed on your system.\nScheme+ may run on other Scheme implementations with some modifications, but porting the ex-\ntended features may take significant time.\nb. Use an Athena workstation to run Scheme+. Section 1 gives instructions on how to use Scheme+ on\nAthena.\nThis option provides a pre-configured environment with MIT Scheme already set up, but will not\nallow you to be as flexible in doing your labs. It may be difficult to find an Athena workstation when\nyou want one.\nOnce you have Scheme+ up and running, see section 3 for some usage notes.\nRunning Scheme+ on Athena\nMIT Scheme is available on Athena in the scheme locker. To access Scheme, type\nadd scheme\nat an athena% prompt. This will attach the scheme locker to your directory structure at /mit/scheme as well\nas put the MIT Scheme binaries in your path. At this point, running Scheme+ on Athena is more or less like\nrunning Scheme+ on your personal machine, described in the rest of this handout.\nIf you are using Athena for 6.821, you should also be aware of the 6.821 locker. You can access the 6.821\nlocker by typing\nadd 6.821\nat an athena% prompt, which will attach the 6.821 locker to your directory structure at /mit/6.821. All of\nthe code for the course, including Scheme+, will be in the 6.821 locker. Refer to the README file in the 6.821\nlocker for more information.\nRunning Scheme+ on Your Own Machine\nTo run Scheme+ on your own machine, you must have a version of MIT Scheme. If you're using a machine\nin Tech Square, there's a good chance there's already a version of MIT Scheme on your machine. If not, read\nthe details below on how to load one up (section 2.1). Once you have MIT Scheme, you can run Scheme+\nby downloading the source and loading it up (section 2.2).\n\n2.1\nGetting MIT Scheme\na. First see if there's already a version of Scheme running on your machine. Typically, you can find out\nby typing scheme at the shell or M-x run-scheme in Emacs.1 If there is a Scheme, this will start it up,\nand it will print out a herald like this:\nScheme Microcode Version 11.146\nMIT Scheme running under SunOS\nType '^C' (control-C) followed by 'H' to obtain information about interrupts.\nScheme saved on Sunday November 21, 1993 at 9:15:23 PM\nRelease 7.3.0 (beta)\nMicrocode 11.146\nRuntime 14.166\n1 ]=>\nThe key line in the herald is the one beginning with Release. If it's followed by a number beginning\nwith 7.1 or higher you're in luck. If you're using a Sparc, you need at least version 7.3 -- earlier\nversions do not have a native code compiler and the interpreter is much too slow. If you have an\nappropriate version you can go on to the section on loading Scheme+. Otherwise, continue with the\nnext step, where you will load up an appropriate version of MIT Scheme.\nb. If there's not already a Scheme on your machine, you can try to load one up. The appropriate files and\ninstructions are available by anonymous FTP from swiss-ftp.ai.mit.edu in these directories:\npub/scheme-7.3\npub/scheme-7.4\nWhich version of Scheme should you try to load? The README file in each of the above directories\ndescribes what machines that version of Scheme runs on. In the past, we recommended using ver-\nsion 7.3 as it is latest version with which Scheme+ has been fully tested. Version 7.4 is an improved\nIntel x86-only release of MIT Scheme that runs on almost any x86 operating system except DOS. You\nshouldn't have any problems running Scheme+ with version 7.4, but if you do, please tell us.\nWe recommend NOT using any version of MIT Scheme that you may have installed for 6.001. 6.001\nversions of MIT Scheme do not include the compiler. Syntaxing and compiling Scheme+, as described\nin section 2.2, can make loading and using Scheme+ significantly faster.\nSparc users must use at least version 7.3 to get suitable performance. Previous versions did not have\na native code compiler for the Sparc, thus the entire Scheme system was interpreted which meant\nthat it was very slow. Version 7.3 generates native code on Sparcs by compiling Scheme to C and then\ncompiling the C. This gives quite reasonable performance.\nThe distribution contains pre-compiled executables for various target architectures. Please see the files\nREADME, INSTALL, and NEWS for more information about which platforms are supported and installing\nMIT Scheme.\nc. Alternatively, check the information at http://www-swiss.ai.mit.edu/scheme-home.html\n2.2\nGetting Scheme+\n2.2.1\nInstalling Scheme+\na. Copy the Scheme+ implementation to your machine from the course FTP server, psrg.lcs.mit.edu.\nThis is the file name:\npub/6.821/fall-02/code/scheme+/scheme+1.2.scm\n1If you have not used Emacs before, see section 3.4 for information about Emacs and key sequences like M-x.\n\nWhile you're at it, you might as well grab code/ps1/postfix.scm in preparation for the first problem\nset.\nIn the future, we will refer to the directory pub/6.821/fall-02 on psrg.lcs.mit.edu as the course\ndirectory. We will make all necessary files available there throughout the term.\nb. This part is optional but highly recommended. It only need be done once for any version of Scheme+.\nSyntaxing the Scheme+ implementation will greatly improve load time and compiling can increase\nperformance. Go to the directory where you put your copy of the Scheme+ implementation and start\nup a Scheme with the -compiler option, either by typing\nscheme -compiler\nat the shell or by typing\nC-u M-x run-scheme\n-emacs -compiler\nin Emacs.\nTo syntax the implementation, evaluate this Scheme expression:\n(sf \"scheme+1.2.scm\")\nThis will print out a lot of stuff, including some warning messages that you can safely ignore, and\nit will create scheme+1.2.bin, which is a fast-loading version of scheme+1.2.scm. The difference in\nloading time between the two is orders of magnitude!\nTo compile the implementation, evaluate this Scheme expression:\n(cf \"scheme+1.2.scm\")\nAgain, ignore the warning messages. This will create a compiled file scheme+1.2.com, which should\nrun faster.2\n2.2.2\nRunning Scheme+\nStart up a Scheme, either by typing\nscheme\nat the shell or by typing\nM-x run-scheme\n-emacs\nin Emacs. Evaluate this Scheme expression:\n(load \"scheme+1.2.scm\")\nReplacing the .scm extension with .bin will load the syntaxed version. Using the .com extension will load\nthe compiled version.\nAfter printing out a herald, this will plop you into a Scheme+ interpreter. Now you're ready to rock 'n\nroll for 6.821! Unfortunately, syntaxing and compiling Scheme+ programs is not currently supported.\nUsage Notes\nScheme+ is implemented on top of MIT Scheme, and almost all MIT Scheme features are supported within\nScheme+. Additionally, Scheme+ provides some extra features described in appendix A of the Scheme sup-\nplement. This section briefly describes those MIT Scheme features that are particularly useful for interacting\nwith Scheme+ as well as notes about using MIT Scheme within Emacs.\n2Unfortunately, there seems to be a bug in the Sparc compiler for version 7.3, so Sparc users will not be able to compile the Scheme+\nimplementation. They can syntax it, however.\n\n3.1\nHandy MIT Scheme Features\n- (pp object ) pretty-prints object. That is, it displays object on the screen in a readable format. If object\nis a procedure, pp prints out its definition.\n- (pwd) prints the current working directory.\n- (cd string ) changes the working directory to that named by string.\n- (exit) kills Scheme after requesting confirmation.\n- '#@number refers to a value by its identity number. Every compound value has an identity number,\nwhich is shown in its ;Value comment when it is displayed. For example:\n> (define a (lambda (x) 3))\n;Value 27: a\n> (pp '#@27)\n(named-lambda (a x) 3)\n;No value\n> (list 1 2 3)\n;Value 29: (1 2 3)\n> (pp '#@29)\n(1 2 3)\n;No value\n3.2\nDebugging Support\n- (trace procedure ) prints out information on every call and return of procedure.\n- (trace-entry procedure ) prints out information on every call of procedure.\n- (trace-exit procedure ) prints out information on every return of procedure.\n- (untrace [procedure] ) turns off tracing for procedure. Calling untrace with no arguments turns\ntracing off for all procedures.\n- (where procedure ) runs the environment inspector on the environment of procedure. The environ-\nment inspector supports a wide variety of options accessed by single-letter commands:\n?\nhelp, list command letters\nA\nshow All bindings in current environment and its ancestors\nC\nshow bindings of identifiers in the Current environment\nE\nEnter a read-eval-print loop in the current environment\nO\npretty print the procedure that created the current environment\nP\nmove to environment that is Parent of current environment\nQ\nQuit (exit environment inspector)\nS\nmove to child of current environment (in current chain)\nV\neValuate expression in current environment\nW\nenter environment inspector (Where) on the current environment\n- (debug) enters the stack inspector. This is probably the most useful debugging tool, but the hardest\nto use. The stack inspector also supports a wide variety of commands:\n\n?\nhelp, list command letters\nA\nshow All bindings in current environment and its ancestors\nB\nmove (Back) to next reduction (earlier in time)\nC\nshow bindings of identifiers in the Current environment\nD\nmove (Down) to the previous subproblem (later in time)\nE\nEnter a read-eval-print loop in the current environment\nF\nmove (Forward) to previous reduction (later in time)\nG\nGo to a particular subproblem\nH\nprints a summary (History) of all subproblems\nI\nredisplay the error message Info\nJ\nreturn TO the current subproblem with a value\nK\ncontinue the program using a standard restart option\nL\n(List expression) pretty print the current expression\nO\npretty print the procedure that created the current environment\nP\nmove to environment that is Parent of current environment\nQ\nQuit (exit debugger)\nR\nprint the execution history (Reductions) of the current subproblem level\nS\nmove to child of current environment (in current chain)\nT\nprint the current subproblem or reduction\nU\nmove (Up) to the next subproblem (earlier in time)\nV\neValuate expression in current environment\nW\nenter environment inspector (Where) on the current environment\nX\ncreate a read eval print loop in the debugger environment\nY\ndisplay the current stack frame\nZ\nreturn FROM the current subproblem with a value\nThe most useful of these are H, G, and E. It is especially useful to type H immediately after evaluating\n(debug) because the subproblem history often shows exactly where the error is. G and E are useful for\nprobing the subproblem history for important information. Using the debugger is by no means easy\nor natural at first, but it is incredibly powerful once you become accustomed to it.\n3.3\nMoving Between Scheme+ and Scheme\nThose of you who know Scheme may want to access Scheme features within Scheme+ or move between\nScheme+ and Scheme. The following Scheme+ procedures are helpful in this regard:\n- (scheme) leaves Scheme+ and enters Scheme.\n- (scheme+) leaves Scheme and enters Scheme+.\n3.4\nUsing Scheme in Emacs\nThe preferred way to run Scheme is within Emacs. Scheme comes with an Emacs configuration file that aids\nin writing Scheme programs. One of the most important features is automatic indenting and highlighting\nmatching parens. Emacs indents s-expressions in the Scheme pretty-printing style, thus making your code\neasier to read. Emacs also flashes the cursor to the matching left paren every time you type a right paren,\nthus helping you to keep track of parentheses.\nEmacs commands are invoked by control sequences. For example, holding down the control key and\npressing the x key followed by holding down the control key and pressing the f key will invoke the\nfind-file command for loading a file into a buffer. This key sequence is denoted by the shorthand C-x C-f.\nThe find-file command will then ask for the name of the file to be loaded by putting you in the minibuffer\n(the one line below the modeline with the time, etc.) with a line like Find file: /home/szilagyi/. You\ncan edit the default file name (in this case /home/szilagyi/) before pressing return.\nYou can load MIT Scheme in Emacs by using the run-scheme command. To run this command you type\nthe key sequence: press the x while holding the meta key, followed by typing run-scheme, followed by\n\npressing enter. This key sequence is written M-x run-scheme (the trailing enter is usually omitted). The key\nsequence discussed above for find-file is a hot-key sequence -- you do not have to type the command\nname. The find-file command can also be invoked by M-x find-file.\nIf you want to change the options to Scheme, such as starting it in compiler mode, you must preface\nyour command with C-u. If you type C-u M-x run-scheme, you will end up in the minibuffer with Run\nScheme: scheme -emacs. scheme -emacs is the shell command used to invoke Scheme with the -emacs\noption telling Scheme to running inside emacs. You can edit the mini-buffer to add the -compiler option\nto start up Scheme in compiler mode. Thus the entire key sequence would be written C-u M-x run-scheme\nenter -compiler.\nHere's a short list of other emacs commands that may be useful. You can always type C-h C-h for help.\nTyping C-h t will bring up the Emacs tutorial, which is an easy way to learn how to use Emacs if this is\nyour first time. Typing C-h m while in Scheme-mode will describe the special Scheme commands and C-h\nf followed by the name of a command will give you documentation on that command:\nC-x C-f\nfind-file\n;; loads file into a buffer\nC-x C-s\nsave-buffer\n;; saves current buffer\nC-x b\nswitch-to-buffer\n;; prompts for buffer name\nC-h C-h\nhelp-for-help\n;; emacs help\nC-h m\n;; provides mode specific documentation\nC-h f\n;; provide documentation for a command\nM-x info\n;; runs documentation browser\nC-x C-c\n;; exit emacs after asking to save modified buffers\nC-a\nbeginning-of-line\nC-e\nend-of-line\nC-v\n;; move down one page\nM-v\n;; move up one page\nM-<\nbeginning-of-buffer\nM->\nend-of-buffer\nTyping M-x run-scheme will start Scheme in a buffer called *scheme*."
    },
    {
      "category": "Resource",
      "title": "r5rs.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/89a3761e77b6adea3dbf759abcb27d72_r5rs.pdf",
      "content": "and\nenitions\n\nt\nt\no\nert\nSc\nheme\nis\nnd\nsimple\nf\nys\no\ni\nbrief\nhistory\nhe\nand\nfor\nputoutput\nvides\ntax\nheme\nBNF\nalong\nwith\nexample\nof\nthe\nuse\no\nthe\nthe\nphab\ntic\ntro\nand\nWhitespace\nOther\nords\nnd\no\nStorage\nd\nProp\ntax\n\nStandard\npro\nb\nOther\nd\nInput\ns\ns\nAdditional\nAlphab\nindex\nof\no\nords\nnd\npro\n\nRevised\nRep\nort\non\nthe\nAlgorithmic\nLanguage\nSc\nheme\nA\nw\nR\nK\nLINGER\nJ\nR\n\nC\nICHARD\nELSEY\nW ILLIAM\nND\nA\nONA\nTHAN\nEES\nEditors\n\nA\nA\nH\nBELSON\nR\nK\nD\nYBVIG\nC\nT\nH\nYNES\nG\nJ\nR\nOZAS\nN\nI\nA\nD\nIV\nE\nK\nAMS\nD\nP\n\nRIEDMAN\nOHLBECKER\nG\nL\nS\nTEELE\nJ R\nH\nD\nH\nB\nAR\nTLEY\nR\nALSTEAD\nD\nO\nXLEY\nG\nJ\nS\nUSSMAN\nR\nG\nB\nOOKS\nC\nH\nANSON\nK\nM\nP\nITMAN\nM\nW\nAND\nf\no\nDe\ndic\nate\nMemory\nd\nR\nhe\nob\nHieb\n\nebruary\n\nCONTENTS\nF\nIn\nuction\n\nd\n\nOv\nerview\nof\nSc\nheme\n\nSUMMAR\nY\n\nSeman\ntics\n\nrep\ngiv\nes\na\nprogram\nThe\nrt\no\ndening\ndescription\nof\nthe\n\nSyn\ntax\n\na\nlanguage\nheme\nand\nscop\nNotation\nSc\nming\ned\nstatically\n\nterminology\n\nLexical\ncon\nv\nen\ntions\n\nrly\ne\nprop\ntailrecursiv\ne\ndialect\nof\nthe\nLisp\nprogramming\n\nIden\ntiers\n\nlanguage\nin\nv\nen\nted\nb\ny\nGuy\nLewis\nSteele\nJr\nand\nGerald\ncommen\n\nand\nts\n\nJa\nSussman\nIt\nw\nas\nexceptionally\ny\ndesigned\nto\nha\nv\ne\nan\n\notations\n\nn\na\nand\nform\new\neman\ns\nclear\ndieren\ntics\nt\na\nto\n\nBasic\nconcepts\n\nariet\nprogramming\nin\ny\nexpressions\nv\ne\ni\nw\nd\nparadigms\nf\n\nV\nariables\nk\neyw\nregions\nsyn\ntactic\na\n\ni\ne\nerativ\nnd\na\nmp\npassing\nfunctional\nyles\ncluding\nst\nmessage\nf\nt\nyp\n\nDisjoin\ntness\nes\n\ncon\nv\nSc\nt\nnd\nenien\nexpression\nheme\nin\n\nExternal\nrepresen\ntations\n\no\nm\n\nel\nlanguage\nuction\ntro\nand\nThe\noers\nd\na\nn\nof\nthe\n\ner\ntail\nrecursion\n\no\nof\nthe\nrt\nrep\n\nExpressions\n\nrst\n\nc\npresen\ntal\nThe\nthree\nhapters\nt\nthe\nfundamen\nideas\nof\nexpression\nyp\n\nPrimitiv\ne\nt\nes\n\nt\nnd\na\nthe\ne\nnotational\nl\nen\ntions\ncon\ndescrib\nanguage\nv\nsed\nu\nexpression\nyp\n\nDeriv\ned\nt\nes\n\nwriting\nescribing\nd\nprograms\nlanguage\nthe\nfor\n\nMacros\n\nProgram\ns tructure\n\nlanguage\n\nPrograms\n\nChapters\n\nand\ne\n\ndescrib\nthe\nsyn\ntax\nand\nseman\ntics\nof\n\nDenitions\n\nexpressions\nrograms\np\nd\n\nSyn\nenitions\n\nc edures\n\ndescrib\nSc\nedures\nc\nChapter\ns\ne\n\nhemes\nbuiltin\npro\nwhic\nh\n\nEquiv\nalence\npredicates\n\ninclude\nall\nof\nthe\nlanguages\ndata\nmanipulation\nand\nin\n\nNum\ne r s\n\np\nrimitiv\nes\nt\nyp\n\nata\nes\n\nChapter\nsyn\nfor\nwritten\n\na\nro\np\nformal\nSc\nin\n\nCon\ntrol\nfeatures\n\nEval\n\nextended\ntics\na\nseman\normal\nenotational\nd\nf\n\nutput\no\nand\n\nlanguage\normal\nfollo\nf\nAn\nws\nf\nyn\nand\n\nF\normal\nseman\ntax\ntics\n\nsyn\nseman\ntax\ntics\nand\n\nF\normal\n\nyn\ntax\n\nrep\nconcludes\nwith\na\nlist\nof\nThe\nort\nreferences\nand\nan\nal\n\ns\n\nF\normal\neman\ntics\n\ne\nindex\nexpression\nyp\n\nDeriv\ned\nt\nes\n\nNotes\n\nm\naterial\n\nExample\n\nReferences\n\netic\nf\ndenitions\nconcepts\nk\neyw\nc\na\nedures\n\nb\nesigned\non\nho\necien\ncedures\nfeature\non\ntop\nof\nving\nestrictions\nhat\nadditional\na\nr\no\nrules\nfor\nsuce\nto\nractical\nthe\nas\none\no\nt\nt\na\nk\nin\nas\nrst\nma\njor\nd\no\nLisp\nols\nsingle\nical\nor\nto\naluate\nthe\no\no\ni\nteration\nheme\nthe\ne\nfrom\ntrol\nuced\nextension\nCommon\ntly\ncame\nr\nof\nwritten\nh\ned\nolution\nof\nthe\nheme\nand\npublished\ni\nally\nfound\nco\nwritten\na\nes\nthe\nof\nmet\ni\nr\nt\npublished\nMIT\ni\nspring\no\n\nand\ni\nspring\nof\nmeeting\nin\nthis\nep\nort\nto\nb\nelong\nto\nto\nt\ni\nor\nwithout\ne\nof\nSc\nthis\nort\ns\na\nt\nt\nhael\nCarrette\ney\nDuba\nMiller\nPhilbin\nagle\nfrom\ngladly\nAlgol\ne\nalso\nhank\nDexter\nfor\neort\nto\nuth\nsigning\nThe\no\nof\nand\nnformation\nh\nrted\nSupp\nfor\nvided\nts\nNCS\nnd\ne\ne\n\nRevised\nSc\nheme\nINTR\nODUCTION\ny\ng\ne\nlanguages\ng\nso\nshould\nProgramming\ni\np\nl i n\nm\nunit\ny\n\nermission\ni\nin\nn\nw\nnd\na\nn\na\nr\nop\nc\nt\np\ny\nwhole\nbut\nb\ny\nw\nfee\nparticular\nncourage\ne\ntors\nfeature\nremo\nthe\neaknesses\npart\nw\nIn\nimplemen\nw\nv\ns\ny\na\nG\ny\nF\nak\nand\nnec\napp\ne\ntarting\nuse\nt\nm\nr\nar\ne\nfeatures\noin\ns\na\nep\nr\nto\nor\np\nheme\nman\nf\nuals\nthat\nv\nSc\nheme\nmall\no\nd\nm\no\nifying\n\nery\num\nf\ne\nb\ncumen\nther\ntation\ni\ns\na\n\nessary\ndemonstrates\ns\nn\ndo\nand\nnecessary\nexpressions\nf\nw\nno\norming\nwith\nrestrictions\nand\nform\nomp\nc\nthey\nt\np\nsed\no\nare\na\nAc\nkno\nwledgemen\nts\nlanguage\nis\nenough\nort\nthat\nprogramming\nexible\nto\nsupp\nparadigms\nmost\nor\ny\n\nuse\nprogramming\na\nto\nm\nda\nin\nof\nj\nW\ne\nw\nould\nlik\ne\nto\nthank\nthe\nfollo\nwing ople\ne\np\nfor\ntheir\nSc\nheme\nprogramming\nw\nlanguages\nrst\nAlan\nwden\nBlair\no\nin\nf\nhe\nhelp\na\nB\nMic\nndy\nA\nGeorge\nlass\norate\nd\nKen\nc\npro\nrst\n\ncorp\nalculus\nc\nb\nCromart\ny\n\nP\na\nv\nel\nCurtis\nJe\nDalton\nOlivier\nDan\nvy\n\nthereb\ny\npro\nving\nthe\nscop\nrules\nand\nDic\nk\nM\n\nRic\nusefulness\nof\nstatic\ne\narc\nF\nruce\nB\neeley\n\nd\nn\nA\nreeman\nhard\nc\ndynamically\ns\ned\na\nyp\nSc\nheme\nGabriel\nY\nekta\nursel\nKen\nHaase\nert\nt\nblo\ntructure\nlanguage\n\nRob\nHieb\nP\naul\nf\nto\ndistinguish\npro\ncedures\nialect\nw\nthe\nHudak\nMorry\nKatz\nChris\nLindblad\nMark\nMey\ner\nJim\nlam\nand\na\nd\nuse\nRamsdell\nsym\nexpressions\nb\nlex\nb\nto\nJim\nM\nik\nSha\nfrom\na\nJohn\nonathan\nJ\ne\nen\nvironmen\nt\nall\nariables\nop\nussman\nS\nev\nP\nShapiro\nerry\naniel\nD\neise\nf\nv\nand\nJulie\nW\nW\nHenry\np\na\nthe\nsition\ncedure\nf\nsame\nro\np\nF\ncall\nw\nn\nerator\na\nn\na\nW\nu\nand\nOzan\nYigit\nW\ne\nthank\nCarol\nessenden\nDaniel\nerand\no\np\non\npro\ncalls\nriedman\nand\nChristopher\nHa\nynes\nfor\np\nto\nop\nsition\nBy\nrelying\nen\ntirely\nedure\nc\nF\nrmission\ne\nuse\nSc\nto\nfact\nexpress\nemphasized\nv\n\ni\nthat\ntail\ntext\nfrom\nthe\nSc\nheme\n\nersion\nreference\nman\nual\npro\ncalls\nare\nessen\ntially\ngotos\nthat\npass\nW\ne\nthank\nexas\nInstrumen\nts\nInc\nfor\np\nto\nuse\nrecursiv\nedure\nc\nT\nermission\nargumen\nts\nSc\nheme\nw\nas\nthe\nrst\nwidely\nused\nprogram\ntext\nTI\nR\nL\ne\nthe\nScheme\nanguage\nefer\nenc\nManual\n\nbrace\nrst\nclass\ne\npro\nW\ne\nac\nkno\nwledge\ninuence\nof\nMIT\nming\nlanguage\nto\nem\nescap\ncedures\nthe\nman\nuals\nfor\nwhic\nkno\nh\na\npreviously\nsequen\ntial\nheme\n\nT\n\nand\nll\nwn\ncon\nstruc\nSc\nSc\nheme\n\nCommon\nLisp\n\ne\nSc\nt\nan\nc\nA\nof\nsyn\nb\ntures\nthesized\nsubsequen\nersion\nheme\n\nt\nin\nd\nn\nand\num\ners\nconcept\nof\nhe\ntro\nexact\ninexact\nb\nan\nBett\nshe\nextreme\nt\ny\nW\nt\nput\nhe\narithmetic\nLisps\nre\ngeneric\nof\nMore\nrep\nKn\nand\nde\nf\nin\nsetting\nX\nor\nort\nin\nT\nthis\nDonald\nE\n\nlanguage\nrst\n\nb\ncen\nrogramming\np\nto\nthe\nc e\nS\nheme\ncaused\nhe\nher\nprogram\nt\nthat\nt\nroubles\nrt\no\nh\np\nsupp\nygienic\nmacros\nwhic\nh\nm\ni t\nthe\nsyn\ntax\nof\na\noratory\ntelligence\nusetts\nI\nof\nthe\nLab\nh\nArticial\nn\nMassac\nblo\nkstructured\nlanguage\nto\ne\nb\na\nc\nextended\nin\nconsisten\nt\nf\nhnology\nDepartmen\nComputer\nInstitute\nT\nec\nScience\n\nhe\nt\nt\nand\nmanner\nr\neliable\nUniv\ny\nI\n\nthe\nIndiana\nersit Sci\nComputer\nences\nDepartmen\nt\nof\nthe\nUniv\nersit\ny\nof\nOregon\nand\nthe\nBac\nkground\nupp\ns\nResearc\nreparation\np\no\nNEC\nof\nthis\nthe\nInstitute\no\nhe\nw\nas\npart\ny\nt\nin\nrt\nrep\nort\nMIT\nw\nork\npro\nb\nSc\nrst\n\nw\n\nA\nas\nescription\nd\nThe\nheme\n\nin\nAdv\nAgency\nro\nP\nResearc\nof\nthe\njects\nh\nt\nthe\nanced\nDepartmen\nrt\no\neared\n\nrevised\n\nescrib\nd\nrep\nwhic\nin\napp\nthe\nNa\nof\nnder\nu\nof\nv\nal\nh\nN\nOce\nDefense\nResearc\ncon\ntract\nits\nMIT\nl\nw\ns\na\nimplemen\nev\nanguage\ntation\nas\nC\nort\nw\nw\nSupp\nfor\nthe\nIndiana\nUniv\nersit\ny\nork\nas\nupgraded\nort\nsupp\nan\ninno\nv\nativ\ne\n\nto\ncompiler\n\nThree\ny\nNCS\na\n\npro\nvided\ngran\nb\nNSF\n\npro\ngan\ne\n\nand\n\nto\nv\ndistinct\njects\nb\nin\nuse\narian\nts\nourses\nc\nUniv\nat\nof\nSc\nfor\nMIT\nY\nale\nIndiana\ner\n\nAn\nductory\nsit\ny\n\ncomputer\nin\ntro\nscience\ntext\nc\nS\nok\nb\nheme\n\nas\nn\nusing\no\nw\n\nAs\nSc\nheme\ne\nm\na\nc\ne\nb\nmore\nwidespread\ncal\nlo\ndialects\n\nb\ngan\nto\ndiv\nstuden\nts\nand\no\nerge\nun\ntil\nresearc\nhers\ncasion\nc\nother\nicult\nto\nt\nunderstand\nde\ni t\nd\nepresen\nr\nof\nma\njor\ntations\nsites\nFifteen\ntativ\nimplemen\nOctob\n\ne\nn\ntherefore\no\nw\nto\nw\nSc\nheme\nork\nard\nb\na\netter\nand\nmore\nwidely\naccepted\nstandard\nfor\nSc\nheme\nort\n\nIndiana\n\nep\nr\nniv\nas\ner\n\nTheir\nat\nU\nnd\na\nof\ny\nn\nrevision\nF\n\nthe\nplace\nto\nurther\nsit\nsummer\nin\nok\n\nn\nt\nf\nthe\n\nhe\nThe\nrep\nreects\nfurther\nrevisions\nagreed\non\npresen\nrt\no\nt\nup\nin\na\nx\nP\nat\nune\nJ\nXero\nAR\n\nC\ne\nthe\nr\ntire\ncom\nW\ni n\nen\ntend\nSc\nheme\n\nOv\nerview\nof\nSc\nheme\n\nDESCRIPTION\nOF\nTHE\nLANGUA\nGE\n\nOv\nerview\nof\nSc\nheme\n\nSeman\ntics\nThis\nsection\ngiv\nes\nan\no\nv\nerview\nof\nSc\nhemes\nseman\ntics\nA\ndetailed\ninformal\nseman\ntics\nis\nthe\nsub\nject\nof\nc\nhapters\n\nthrough\n\nF\nor\nreference\npurp\noses\nsection\n\npro\nvides\na\nformal\nseman\ntics\nof\nSc\nheme\nF\nollo\nwing\nAlgol\nSc\nheme\nis\na\nstatically\nscop\ned\nprogram\nming\nlanguage\nEac\nh\nuse\nof\na\nv\nariable\nis\nasso\nciated\nwith\na\nlexically\napparen\nt\nbinding\nof\nthat\nv\nariable\nSc\nheme\nhas\nlaten\nt\nas\nopp\nosed\nto\nmanifest\nt\nyp\nes\nT\nyp\nes\nare\nasso\nciated\nwith\nv\nalues\nalso\ncalled\nob\njects\nrather\nthan\nwith\nv\nariables\nSome\nauthors\nrefer\nto\nlanguages\nwith\nlaten\nt\nt\nyp\nes\nas\nw\neakly\nt\nyp\ned\nor\ndynamically\nt\nyp\ned\nlan\nguages\nOther\nlanguages\nwith\nlaten\nt\nt\nyp\nes\nare\nAPL\nSnob\nol\nand\nother\ndialects\nof\nLisp\nLanguages\nwith\nmani\nfest\nt\nyp\nes\nsometimes\nreferred\nto\nas\nstrongly\nt\nyp\ned\nor\nstat\nically\nt\nyp\ned\nlanguages\ninclude\nAlgol\n\nP\nascal\nand\nC\nAll\nob\njects\ncreated\nin\nthe\ncourse\nof\na\nSc\nheme\ncomputation\nincluding\npro\ncedures\nand\ncon\ntin\nuations\nha\nv\ne\nunlimited\nex\nten\nt\nNo\nSc\nheme\nob\nject\nis\nev\ner\ndestro\ny\ned\nThe\nreason\nthat\nimplemen\ntations\nof\nSc\nheme\ndo\nnot\nusually\nrun\nout\nof\nstorage\nis\nthat\nthey\nare\np\nermitted\nto\nreclaim\nthe\nstorage\no\nccupied\nb\ny\nan\nob\nject\nif\nthey\ncan\npro\nv\ne\nthat\nthe\nob\nject\ncannot\np\nossibly\nmatter\nto\nan\ny\nfuture\ncomputation\nOther\nlanguages\nin\nwhic\nh\nmost\nob\njects\nha\nv\ne\nunlimited\nexten\nt\nin\nclude\nAPL\nand\nother\nLisp\ndialects\nImplemen\ntations\nof\nSc\nheme\nare\nrequired\nto\nb\ne\nprop\nerly\ntailrecursiv\ne\nThis\nallo\nws\nthe\nexecution\nof\nan\niterativ\ne\ncomputation\nin\nconstan\nt\nspace\nev\nen\nif\nthe\niterativ\ne\ncompu\ntation\nis\ndescrib\ned\nb\ny\na\nsyn\ntactically\nrecursiv\ne\npro\ncedure\nTh\nus\nwith\na\nprop\nerly\ntailrecursiv\ne\nimplemen\ntation\niter\nation\ncan\nb\ne\nexpressed\nusing\nthe\nordinary\npro\ncedurecall\nmec\nhanics\nso\nthat\nsp\necial\niteration\nconstructs\nare\nuseful\nonly\nas\nsyn\ntactic\nsugar\nSee\nsection\n\nSc\nheme\npro\ncedures\nare\nob\njects\nin\ntheir\no\nwn\nrigh\nt\nPro\ncedures\ncan\nb\ne\ncreated\ndynamically\n\nstored\nin\ndata\nstruc\ntures\nreturned\nas\nresults\nof\npro\ncedures\nand\nso\non\nOther\nlanguages\nwith\nthese\nprop\nerties\ninclude\nCommon\nLisp\nand\nML\nOne\ndistinguishing\nfeature\nof\nSc\nheme\nis\nthat\ncon\ntin\nuations\nwhic\nh\nin\nmost\nother\nlanguages\nonly\nop\nerate\nb\nehind\nthe\nscenes\nalso\nha\nv\ne\nrstclass\nstatus\nCon\ntin\nuations\nare\nuseful\nfor\nimplemen\nting\na\nwide\nv\nariet\ny\nof\nadv\nanced\ncon\ntrol\nconstructs\nincluding\nnonlo\ncal\nexits\nbac\nktrac\nking\nand\ncoroutines\nSee\nsection\n\nArgumen\nts\nto\nSc\nheme\npro\ncedures\nare\nalw\na\nys\npassed\nb\ny\nv\nalue\nwhic\nh\nmeans\nthat\nthe\nactual\nargumen\nt\nexpressions\nare\nev\naluated\nb\nefore\nthe\npro\ncedure\ngains\ncon\ntrol\nwhether\nthe\npro\ncedure\nneeds\nthe\nresult\nof\nthe\nev\naluation\nor\nnot\nML\nC\nand\nAPL\nare\nthree\nother\nlanguages\nthat\nalw\na\nys\npass\nargumen\nts\nb\ny\nv\nalue\nThis\nis\ndistinct\nfrom\nthe\nlazy\nev\naluation\nseman\ntics\nof\nHask\nell\nor\nthe\ncallb\nyname\nse\nman\ntics\nof\nAlgol\n\nwhere\nan\nargumen\nt\nexpression\nis\nnot\nev\naluated\nunless\nits\nv\nalue\nis\nneeded\nb\ny\nthe\npro\ncedure\nSc\nhemes\nmo\ndel\nof\narithmetic\nis\ndesigned\nto\nremain\nas\nin\ndep\nenden\nt\nas\np\nossible\nof\nthe\nparticular\nw\na\nys\nin\nwhic\nh\nn\num\nb\ners\nare\nrepresen\nted\nwithin\na\ncomputer\nIn\nSc\nheme\nev\nery\nin\nteger\nis\na\nrational\nn\num\nb\ner\nev\nery\nrational\nis\na\nreal\nand\nev\nery\nreal\nis\na\ncomplex\nn\num\nb\ner\nTh\nus\nthe\ndistinction\nb\ne\nt\nw\neen\nin\nteger\nand\nreal\narithmetic\nso\nimp\nortan\nt\nto\nman\ny\nprogramming\nlanguages\ndo\nes\nnot\napp\near\nin\nSc\nheme\nIn\nits\nplace\nis\na\ndistinction\nb\net\nw\neen\nexact\narithmetic\nwhic\nh\ncor\nresp\nonds\nto\nthe\nmathematical\nideal\nand\ninexact\narithmetic\non\nappro\nximations\nAs\nin\nCommon\nLisp\nexact\narithmetic\nis\nnot\nlimited\nto\nin\ntegers\n\nSyn\ntax\nSc\nheme\nlik\ne\nmost\ndialects\nof\nLisp\nemplo\nys\na\nfully\nparen\nthesized\nprex\nnotation\nfor\nprograms\nand\nother\ndata\nthe\ngrammar\nof\nSc\nheme\ngenerates\na\nsublanguage\nof\nthe\nlan\nguage\nused\nfor\ndata\nAn\nimp\nortan\nt\nconsequence\nof\nthis\nsim\nple\nuniform\nrepresen\ntation\nis\nthe\nsusceptibilit\ny\nof\nSc\nheme\nprograms\nand\ndata\nto\nuniform\ntreatmen\nt\nb\ny\nother\nSc\nheme\nprograms\nF\nor\nexample\nthe\neval\npro\ncedure\nev\naluates\na\nSc\nheme\nprogram\nexpressed\nas\ndata\nThe\nread\npro\ncedure\np\nerforms\nsyn\ntactic\nas\nw\nell\nas\nlexical\ndecomp\nosition\nof\nthe\ndata\nit\nreads\nThe\nread\npro\ncedure\nparses\nits\ninput\nas\ndata\nsection\n\nnot\nas\nprogram\nThe\nformal\nsyn\ntax\nof\nSc\nheme\nis\ndescrib\ned\nin\nsection\n\nNotation\nand\nterminology\n\nPrimitiv\ne\nlibrary\n\nand\noptional\nfeatures\nIt\nis\nrequired\nthat\nev\nery\nimplemen\ntation\nof\nSc\nheme\nsupp\nort\nall\nfeatures\nthat\nare\nnot\nmark\ned\nas\nb\neing\noptional\nImple\nmen\ntations\nare\nfree\nto\nomit\noptional\nfeatures\nof\nSc\nheme\nor\nto\nadd\nextensions\npro\nvided\nthe\nextensions\nare\nnot\nin\nconict\nwith\nthe\nlanguage\nrep\norted\nhere\nIn\nparticular\nimplemen\ntations\nm\nust\nsupp\nort\np\nortable\nco\nde\nb\ny\npro\nviding\na\nsyn\ntactic\nmo\nde\nthat\npreempts\nno\nlexical\ncon\nv\nen\ntions\nof\nthis\nrep\nort\nT\no\naid\nin\nunderstanding\nand\nimplemen\nting\nSc\nheme\nsome\nfeatures\nare\nmark\ned\nas\nlibr\nary\nThese\ncan\nb\ne\neasily\nimple\nmen\nted\nin\nterms\nof\nthe\nother\nprimitiv\ne\nfeatures\nThey\nare\nredundan\nt\nin\nthe\nstrict\nsense\nof\nthe\nw\nord\nbut\nthey\ncapture\ncommon\npatterns\nof\nusage\nand\nare\ntherefore\npro\nvided\nas\ncon\nv\nenien\nt\nabbreviations\n\nRevised\n\nSc\nheme\n\nError\nsituations\nand\nunsp\neci ed\nb\neha\nvior\nWhen\nsp\neaking\nof\nan\nerror\nsituation\nthis\nrep\nort\nuses\nthe\nphrase\nan\nerror\nis\nsignalled\nto\nindicate\nthat\nimplemen\ntations\nm\nust\ndetect\nand\nrep\nort\nthe\nerror\nIf\nsuc\nh\nw\nording\ndo\nes\nnot\napp\near\nin\nthe\ndiscussion\nof\nan\nerror\nthen\nimple\nmen\ntations\nare\nnot\nrequired\nto\ndetect\nor\nrep\nort\nthe\nerror\nthough\nthey\nare\nencouraged\nto\ndo\nso\nAn\nerror\nsituation\nthat\nimplemen\ntations\nare\nnot\nrequired\nto\ndetect\nis\nusually\nreferred\nto\nsimply\nas\nan\nerror\nF\nor\nexample\nit\nis\nan\nerror\nfor\na\npro\ncedure\nto\nb\ne\npassed\nan\nargumen\nt\nthat\nthe\npro\ncedure\nis\nnot\nexplicitly\nsp\necied\nto\nhandle\nev\nen\nthough\nsuc\nh\ndomain\nerrors\nare\nseldom\nmen\ntioned\nin\nthis\nrep\nort\nImplemen\ntations\nma\ny\nextend\na\npro\ncedures\ndomain\nof\ndenition\nto\ninclude\nsuc\nh\nargumen\nts\nThis\nrep\nort\nuses\nthe\nphrase\nma\ny\nrep\nort\na\nviolation\nof\nan\nimplemen\ntation\nrestriction\nto\nindicate\ncircumstances\nun\nder\nwhic\nh\nan\nimplemen\ntation\nis\np\nermitted\nto\nrep\nort\nthat\nit\nis\nunable\nto\ncon\ntin\nue\nexecution\nof\na\ncorrect\nprogram\nb\ne\ncause\nof\nsome\nrestriction\nimp\nosed\nb\ny\nthe\nimplemen\ntation\nImplemen\ntation\nrestrictions\nare\nof\ncourse\ndiscouraged\nbut\nimplemen\ntations\nare\nencouraged\nto\nrep\nort\nviolations\nof\nim\nplemen\ntation\nrestrictions\nF\nor\nexample\nan\nimplemen\ntation\nma\ny\nrep\nort\na\nviolation\nof\nan\nimplemen\ntation\nrestriction\nif\nit\ndo\nes\nnot\nha\nv\ne\nenough\nstorage\nto\nrun\na\nprogram\nIf\nthe\nv\nalue\nof\nan\nexpression\nis\nsaid\nto\nb\ne\nunsp\necied\nthen\nthe\nexpression\nm\nust\nev\naluate\nto\nsome\nob\nject\nwithout\nsignalling\nan\nerror\nbut\nthe\nv\nalue\ndep\nends\non\nthe\nimple\nmen\ntation\nthis\nrep\nort\nexplicitly\ndo\nes\nnot\nsa\ny\nwhat\nv\nalue\nshould\nb\ne\nreturned\n\nEn\ntry\nformat\nChapters\n\nand\n\nare\norganized\nin\nto\nen\ntries\nEac\nh\nen\ntry\nde\nscrib\nes\none\nlanguage\nfeature\nor\na\ngroup\nof\nrelated\nfeatures\nwhere\na\nfeature\nis\neither\na\nsyn\ntactic\nconstruct\nor\na\nbuiltin\npro\ncedure\nAn\nen\ntry\nb\negins\nwith\none\nor\nmore\nheader\nlines\nof\nthe\nform\ntemplate\nc\nate\ngory\nfor\nrequired\nprimitiv\ne\nfeatures\nor\ntemplate\nqualier\nc\nate\ngory\nwhere\nqualier\nis\neither\nlibrary\nor\noptional\nas\ndened\nin\nsection\n\nIf\nc\nate\ngory\nis\nsyn\ntax\nthe\nen\ntry\ndescrib\nes\nan\nexpression\nt\nyp\ne\nand\nthe\ntemplate\ngiv\nes\nthe\nsyn\ntax\nof\nthe\nexpression\nt\nyp\ne\nComp\nonen\nts\nof\nexpressions\nare\ndesignated\nb\ny\nsyn\ntactic\nv\nariables\nwhic\nh\nare\nwritten\nusing\nangle\nbrac\nk\nets\nfor\nexample\nhexpressioni\n\nhv\nariablei\nSyn\ntactic\nv\nariables\nshould\nb\ne\nundersto\no\nd\nto\ndenote\nsegmen\nts\nof\nprogram\ntext\nfor\nexample\nhexpressioni\nstands\nfor\nan\ny\nstring\nof\nc\nharac\nters\nwhic\nh\nis\na\nsyn\ntactically\nv\nalid\nexpression\nThe\nnotation\nhthing\n\ni\n\nindicates\nzero\nor\nmore\no\nccurrences\nof\na\nhthingi\n\nand\nhthing\n\ni\nhthing\n\ni\n\nindicates\none\nor\nmore\no\nccurrences\nof\na\nhthingi\n\nIf\nc\nate\ngory\nis\npro\ncedure\nthen\nthe\nen\ntry\ndescrib\nes\na\npro\ncedure\nand\nthe\nheader\nline\ngiv\nes\na\ntemplate\nfor\na\ncall\nto\nthe\npro\ncedure\nArgumen\nt\nnames\nin\nthe\ntemplate\nare\nitalicize\nd\n\nTh\nus\nthe\nheader\nline\nvectorref\nve\nctor\nk\n\npro\ncedure\nindicates\nthat\nthe\nbuiltin\npro\ncedure\nvectorref\ntak\nes\nt\nw\no\nargumen\nts\na\nv\nector\nve\nctor\nand\nan\nexact\nnonnegativ\ne\nin\nteger\nk\nsee\nb\nelo\nw\nThe\nheader\nlines\nmakevector\nk\n\npro\ncedure\nmakevector\nk\nl\nl\n\npro\ncedure\nindicate\nthat\nthe\nmakevector\npro\ncedure\nm\nust\nb\ne\ndened\nto\ntak\ne\neither\none\nor\nt\nw\no\nargumen\nts\nIt\nis\nan\nerror\nfor\nan\nop\neration\nto\nb\ne\npresen\nted\nwith\nan\nar\ngumen\nt\nthat\nit\nis\nnot\nsp\necied\nto\nhandle\nF\nor\nsuccinctness\nw\ne\nfollo\nw\nthe\ncon\nv\nen\ntion\nthat\nif\nan\nargumen\nt\nname\nis\nalso\nthe\nname\nof\na\nt\nyp\ne\nlisted\nin\nsection\n\nthen\nthat\nargu\nmen\nt\nm\nust\nb\ne\nof\nthe\nnamed\nt\nyp\ne\nF\nor\nexample\nthe\nheader\nline\nfor\nvectorref\ngiv\nen\nab\no\nv\ne\ndictates\nthat\nthe\nrst\nar\ngumen\nt\nto\nvectorref\nm\nust\nb\ne\na\nv\nector\nThe\nfollo\nwing\nnaming\ncon\nv\nen\ntions\nalso\nimply\nt\nyp\ne\nrestrictions\nobj\nan\ny\nob\nject\nl\nist\n\nl\nist\n\nl\nist\nj\n\nlist\nsee\nsection\n\nz\n\nz\n\nz\nj\n\ncomplex\nn\num\nb\ner\nx\nx\n\nx\nj\n\nreal\nn\num\nb\ner\ny\n\ny\n\ny\nj\n\nreal\nn\num\nb\ner\nq\n\nq\n\nq\nj\n\nrational\nn\num\nb\ner\nn\n\nn\n\nn\nj\n\nin\nteger\nk\n\nk\n\nk\nj\n\nexact\nnonnegativ\ne\nin\nteger\n\nEv\naluation\nexamples\nThe\nsym\nb\nol\n\nused\nin\nprogram\nexamples\nshould\nb\ne\nread\nev\naluates\nto\nF\nor\nexample\n\nmeans\nthat\nthe\nexpression\n\nev\naluates\nto\nthe\nob\nject\n\nOr\nmore\nprecisely\nthe\nexpression\ngiv\nen\nb\ny\nthe\nsequence\nof\nc\nharacters\n\nev\naluates\nin\nthe\ninitial\nen\nvironmen\nt\nto\nan\nob\nject\nthat\nma\ny\nb\ne\nrepresen\nted\nexter\nnally\nb\ny\nthe\nsequence\nof\nc\nharacters\n\nSee\nsection\n\nfor\na\ndiscussion\nof\nexternal\nrepresen\ntations\nof\nob\njects\n\nNaming\ncon\nv\nen\ntions\nBy\ncon\nv\nen\ntion\nthe\nnames\nof\npro\ncedures\nthat\nalw\na\nys\nreturn\na\nb\no\nolean\nv\nalue\nusually\nend\nin\n\nSuc\nh\npro\ncedures\nare\ncalled\npredicates\n\nLexical\ncon\nv\nen\ntions\n\nBy\ncon\nv\nen\ntion\nthe\nnames\nof\npro\ncedures\nthat\nstore\nv\nalues\nin\nto\npreviously\nallo\ncated\nlo\ncations\nsee\nsection\n\nusually\nend\nin\n\nSuc\nh\npro\ncedures\nare\ncalled\nm\nutation\npro\nce\ndures\nBy\ncon\nv\nen\ntion\nthe\nv\nalue\nreturned\nb\ny\na\nm\nutation\npro\ncedure\nis\nunsp\necied\nBy\ncon\nv\nen\ntion\n\napp\nears\nwithin\nthe\nnames\nof\npro\nce\ndures\nthat\ntak\ne\nan\nob\nject\nof\none\nt\nyp\ne\nand\nreturn\nan\nanal\nogous\nob\nject\nof\nanother\nt\nyp\ne\nF\nor\nexample\nlistvector\ntak\nes\na\nlist\nand\nreturns\na\nv\nector\nwhose\nelemen\nts\nare\nthe\nsame\nas\nthose\nof\nthe\nlist\n\nLexical\ncon\nv\nen\ntions\nThis\nsection\ngiv\nes\nan\ninformal\naccoun\nt\nof\nsome\nof\nthe\nlexical\ncon\nv\nen\ntions\nused\nin\nwriting\nSc\nheme\nprograms\nF\nor\na\nformal\nsyn\ntax\nof\nSc\nheme\nsee\nsection\n\nUpp\ner\nand\nlo\nw\ner\ncase\nforms\nof\na\nletter\nare\nnev\ner\ndistin\nguished\nexcept\nwithin\nc\nharacter\nand\nstring\nconstan\nts\nF\nor\nexample\nFoo\nis\nthe\nsame\niden\ntier\nas\nFOO\nand\nxAB\nis\nthe\nsame\nn\num\nb\ner\nas\nXab\n\nIden\ntiers\nMost\niden\ntiers\nallo\nw\ned\nb\ny\nother\nprogramming\nlanguages\nare\nalso\nacceptable\nto\nSc\nheme\nThe\nprecise\nrules\nfor\nform\ning\niden\ntiers\nv\nary\namong\nimplemen\ntations\nof\nSc\nheme\nbut\nin\nall\nimplemen\ntations\na\nsequence\nof\nletters\ndigits\nand\nex\ntended\nalphab\netic\nc\nharacters\nthat\nb\negins\nwith\na\nc\nharacter\nthat\ncannot\nb\negin\na\nn\num\nb\ner\nis\nan\niden\ntier\nIn\naddition\n\nand\n\nare\niden\ntiers\nHere\nare\nsome\nexamples\nof\niden\ntiers\nlambda\nq\nlist vector\nsoup\n\nVa\n\nakTMNs\nthewordrecursionhasmanym\neanin\ngs\nExtended\nalphab\netic\nc\nharacters\nma\ny\nb\ne\nused\nwithin\niden\ntiers\nas\nif\nthey\nw\nere\nletters\nThe\nfollo\nwing\nare\nextended\nalphab\netic\nc\nharacters\n\nSee\nsection\n\nfor\na\nformal\nsyn\ntax\nof\niden\ntiers\nIden\ntiers\nha\nv\ne\nt\nw\no\nuses\nwithin\nSc\nheme\nprograms\n\nAn\ny\niden\ntier\nma\ny\nb\ne\nused\nas\na\nv\nariable\nor\nas\na\nsyn\ntactic\nk\neyw\nord\nsee\nsections\n\nand\n\nWhen\nan\niden\ntier\napp\nears\nas\na\nliteral\nor\nwithin\na\nliteral\nsee\nsection\n\nit\nis\nb\neing\nused\nto\ndenote\na\nsymb\nol\nsee\nsection\n\nWhitespace\nand\ncommen\nts\nWhitesp\nac\ne\nc\nharacters\nare\nspaces\nand\nnewlines\nImple\nmen\ntations\nt\nypically\npro\nvide\nadditional\nwhitespace\nc\nhar\nacters\nsuc\nh\nas\ntab\nor\npage\nbreak\nWhitespace\nis\nused\nfor\nimpro\nv\ned\nreadabilit\ny\nand\nas\nnecessary\nto\nseparate\ntok\nens\nfrom\neac\nh\nother\na\ntok\nen\nb\neing\nan\nindivisible\nlexical\nunit\nsuc\nh\nas\nan\niden\ntier\nor\nn\num\nb\ner\nbut\nis\notherwise\ninsigni\ncan\nt\nWhitespace\nma\ny\no\nccur\nb\net\nw\neen\nan\ny\nt\nw\no\ntok\nens\nbut\nnot\nwithin\na\ntok\nen\nWhitespace\nma\ny\nalso\no\nccur\ninside\na\nstring\nwhere\nit\nis\nsignican\nt\nA\nsemicolon\n\nindicates\nthe\nstart\nof\na\ncommen\nt\nThe\ncommen\nt\ncon\ntin\nues\nto\nthe\nend\nof\nthe\nline\non\nwhic\nh\nthe\nsemicolon\napp\nears\nCommen\nts\nare\nin\nvisible\nto\nSc\nheme\nbut\nthe\nend\nof\nthe\nline\nis\nvisible\nas\nwhitespace\nThis\nprev\nen\nts\na\ncommen\nt\nfrom\napp\nearing\nin\nthe\nmiddle\nof\nan\niden\ntier\nor\nn\num\nb\ner\n\nThe\nFACT\nprocedure\ncomputes\nthe\nfactorial\n\nof\na\nnonnegative\ninteger\ndefine\nfact\nlambda\nn\nif\n\nn\n\nBase\ncase\nreturn\n\nn\nfact\n\nn\n\nOther\nnotations\nF\nor\na\ndescription\nof\nthe\nnotations\nused\nfor\nn\num\nb\ners\nsee\nsection\n\nThese\nare\nused\nin\nn\num\nb\ners\nand\nma\ny\nalso\no\nccur\nan\nywhere\nin\nan\niden\ntier\nexcept\nas\nthe\nrst\nc\nharac\nter\nA\ndelimited\nplus\nor\nmin\nus\nsign\nb\ny\nitself\nis\nalso\nan\niden\ntier\nA\ndelimited\np\nerio\nd\nnot\no\nccurring\nwithin\na\nn\num\nb\ner\nor\niden\ntier\nis\nused\nin\nthe\nnotation\nfor\npairs\nsection\n\nand\nto\nindicate\na\nrestparameter\nin\na\nformal\nparameter\nlist\nsection\n\nA\ndelimited\nse\nquence\nof\nthree\nsuccessiv\ne\np\nerio\nds\nis\nalso\nan\niden\ntier\n\nP\naren\ntheses\nare\nused\nfor\ngrouping\nand\nto\nnotate\nlists\nsection\n\nThe\nsingle\nquote\nc\nharacter\nis\nused\nto\nindicate\nliteral\ndata\nsection\n\nThe\nbac\nkquote\nc\nharacter\nis\nused\nto\nindicate\nalmost\nconstan\nt\ndata\nsection\n\nThe\nc\nharacter\ncomma\nand\nthe\nsequence\ncomma\nat\nsign\nare\nused\nin\nconjunction\nwith\nbac\nkquote\nsec\ntion\n\nThe\ndouble\nquote\nc\nharacter\nis\nused\nto\ndelimit\nstrings\nsection\n\nRevised\n\nSc\nheme\n\nBac\nkslash\nis\nused\nin\nthe\nsyn\ntax\nfor\nc\nharacter\nconstan\nts\nsection\n\nand\nas\nan\nescap\ne\nc\nharacter\nwithin\nstring\nconstan\nts\nsection\n\nLeft\nand\nrigh\nt\nsquare\nbrac\nk\nets\nand\ncurly\nbraces\nand\nv\nertical\nbar\nare\nreserv\ned\nfor\np\nossible\nfuture\nexten\nsions\nto\nthe\nlanguage\n\nSharp\nsign\nis\nused\nfor\na\nv\nariet\ny\nof\npurp\noses\ndep\nending\non\nthe\nc\nharacter\nthat\nimmediately\nfollo\nws\nit\nt\nf\nThese\nare\nthe\nb\no\nolean\nconstan\nts\nsection\n\nThis\nin\ntro\nduces\na\nc\nharacter\nconstan\nt\nsection\n\nThis\nin\ntro\nduces\na\nv\nector\nconstan\nt\nsection\n\nV\nec\ntor\nconstan\nts\nare\nterminated\nb\ny\n\ne\ni\nb\no\nd\nx\nThese\nare\nused\nin\nthe\nnotation\nfor\nn\num\nb\ners\nsection\n\nBasic\nconcepts\n\nV\nariables\nsyn\ntactic\nk\neyw\nords\nand\nre\ngions\nAn\niden\ntier\nma\ny\nname\na\nt\nyp\ne\nof\nsyn\ntax\nor\nit\nma\ny\nname\na\nlo\ncation\nwhere\na\nv\nalue\ncan\nb\ne\nstored\nAn\niden\ntier\nthat\nnames\na\nt\nyp\ne\nof\nsyn\ntax\nis\ncalled\na\nsyntactic\nkeywor\nd\nand\nis\nsaid\nto\nb\ne\nb\nound\nto\nthat\nsyn\ntax\nAn\niden\ntier\nthat\nnames\na\nlo\ncation\nis\ncalled\na\nvariable\nand\nis\nsaid\nto\nb\ne\nb\nound\nto\nthat\nlo\ncation\nThe\nset\nof\nall\nvisible\nbindings\nin\neect\nat\nsome\np\noin\nt\nin\na\nprogram\nis\nkno\nwn\nas\nthe\nenvir\nonment\nin\neect\nat\nthat\np\noin\nt\nThe\nv\nalue\nstored\nin\nthe\nlo\ncation\nto\nwhic\nh\na\nv\nariable\nis\nb\nound\nis\ncalled\nthe\nv\nariables\nv\nalue\nBy\nabuse\nof\nterminology\n\nthe\nv\nariable\nis\nsometimes\nsaid\nto\nname\nthe\nv\nalue\nor\nto\nb\ne\nb\nound\nto\nthe\nv\nalue\nThis\nis\nnot\nquite\naccurate\nbut\nconfusion\nrarely\nresults\nfrom\nthis\npractice\nCertain\nexpression\nt\nyp\nes\nare\nused\nto\ncreate\nnew\nkinds\nof\nsyn\ntax\nand\nbind\nsyn\ntactic\nk\neyw\nords\nto\nthose\nnew\nsyn\ntaxes\nwhile\nother\nexpression\nt\nyp\nes\ncreate\nnew\nlo\ncations\nand\nbind\nv\nariables\nto\nthose\nlo\ncations\nThese\nexpression\nt\nyp\nes\nare\ncalled\nbinding\nc\nonstructs\nThose\nthat\nbind\nsyn\ntactic\nk\ney\nw\nords\nare\nlisted\nin\nsection\n\nThe\nmost\nfundamen\ntal\nof\nthe\nv\nariable\nbinding\nconstructs\nis\nthe\nlambda\nexpression\nb\necause\nall\nother\nv\nariable\nbinding\nconstructs\ncan\nb\ne\nex\nplained\nin\nterms\nof\nlambda\nexpressions\nThe\nother\nv\nariable\nbinding\nconstructs\nare\nlet\nlet\nletrec\nand\ndo\nexpres\nsions\nsee\nsections\n\nand\n\nLik\ne\nAlgol\nand\nP\nascal\nand\nunlik\ne\nmost\nother\ndialects\nof\nLisp\nexcept\nfor\nCommon\nLisp\nSc\nheme\nis\na\nstatically\nscop\ned\nlanguage\nwith\nblo\nc\nk\nstructure\nT\no\neac\nh\nplace\nwhere\nan\niden\ntier\nis\nb\nound\nin\na\nprogram\nthere\ncorresp\nonds\na\nr\ne\ngion\nof\nthe\nprogram\ntext\nwithin\nwhic\nh\nthe\nbinding\nis\nvisible\nThe\nregion\nis\ndetermined\nb\ny\nthe\nparticular\nbinding\ncon\nstruct\nthat\nestablishes\nthe\nbinding\nif\nthe\nbinding\nis\nestab\nlished\nb\ny\na\nlambda\nexpression\nfor\nexample\nthen\nits\nregion\nis\nthe\nen\ntire\nlambda\nexpression\nEv\nery\nmen\ntion\nof\nan\niden\ntier\nrefers\nto\nthe\nbinding\nof\nthe\niden\ntier\nthat\nestablished\nthe\ninnermost\nof\nthe\nregions\ncon\ntaining\nthe\nuse\nIf\nthere\nis\nno\nbinding\nof\nthe\niden\ntier\nwhose\nregion\ncon\ntains\nthe\nuse\nthen\nthe\nuse\nrefers\nto\nthe\nbinding\nfor\nthe\nv\nariable\nin\nthe\ntop\nlev\nel\nen\nvironmen\nt\nif\nan\ny\nc\nhapters\n\nand\n\nif\nthere\nis\nno\nbinding\nfor\nthe\niden\ntier\nit\nis\nsaid\nto\nb\ne\nunb\nound\n\nDisjoin\ntness\nof\nt\nyp\nes\nNo\nob\nject\nsatises\nmore\nthan\none\nof\nthe\nfollo\nwing\npredi\ncates\nboolean\npair\nsymbol\nnumber\nchar\nstring\nvector\nport\nprocedure\nThese\npredicates\ndene\nthe\nt\nyp\nes\nb\no\nole\nan\np\nair\nsymb\nol\nnumb\ner\nchar\nor\nchar\nacter\nstring\nve\nctor\np\nort\nand\npr\no\nc\ne\ndur\ne\nThe\nempt\ny\nlist\nis\na\nsp\necial\nob\nject\nof\nits\no\nwn\nt\nyp\ne\nit\nsatises\nnone\nof\nthe\nab\no\nv\ne\npredicates\nAlthough\nthere\nis\na\nseparate\nb\no\nolean\nt\nyp\ne\nan\ny\nSc\nheme\nv\nalue\ncan\nb\ne\nused\nas\na\nb\no\nolean\nv\nalue\nfor\nthe\npurp\nose\nof\na\nconditional\ntest\nAs\nexplained\nin\nsection\n\nall\nv\nalues\ncoun\nt\nas\ntrue\nin\nsuc\nh\na\ntest\nexcept\nfor\nf\nThis\nrep\nort\nuses\nthe\nw\nord\ntrue\nto\nrefer\nto\nan\ny\nSc\nheme\nv\nalue\nexcept\nf\nand\nthe\nw\nord\nfalse\nto\nrefer\nto\nf\n\nExternal\nrepresen\ntations\nAn\nimp\nortan\nt\nconcept\nin\nSc\nheme\nand\nLisp\nis\nthat\nof\nthe\nexternal\nr\nepr\nesentation\nof\nan\nob\nject\nas\na\nsequence\nof\nc\nhar\nacters\nF\nor\nexample\nan\nexternal\nrepresen\ntation\nof\nthe\nin\nte\nger\n\nis\nthe\nsequence\nof\nc\nharacters\n\nand\nan\nexternal\nrepresen\ntation\nof\na\nlist\nconsisting\nof\nthe\nin\ntegers\n\nand\n\nis\nthe\nsequence\nof\nc\nharacters\n\nThe\nexternal\nrepresen\ntation\nof\nan\nob\nject\nis\nnot\nneces\nsarily\nunique\nThe\nin\nteger\n\nalso\nhas\nrepresen\ntations\ne\nand\nxc\nand\nthe\nlist\nin\nthe\nprevious\npara\ngraph\nalso\nhas\nthe\nrepresen\ntations\n\nand\n\nsee\nsection\n\nMan\ny\nob\njects\nha\nv\ne\nstandard\nexternal\nrepresen\ntations\nbut\nsome\nsuc\nh\nas\npro\ncedures\ndo\nnot\nha\nv\ne\nstandard\nrepresen\ntations\nalthough\nparticular\nimplemen\ntations\nma\ny\ndene\nrepresen\ntations\nfor\nthem\nAn\nexternal\nrepresen\ntation\nma\ny\nb\ne\nwritten\nin\na\nprogram\nto\nobtain\nthe\ncorresp\nonding\nob\nject\nsee\nquote\nsection\n\nBasic\nconcepts\n\nExternal\nrepresen\ntations\ncan\nalso\nb\ne\nused\nfor\ninput\nand\noutput\nThe\npro\ncedure\nread\nsection\n\nparses\nexternal\nrepresen\ntations\nand\nthe\npro\ncedure\nwrite\nsection\n\ngenerates\nthem\nT\nogether\nthey\npro\nvide\nan\nelegan\nt\nand\np\no\nw\nerful\ninputoutput\nfacilit\ny\n\nNote\nthat\nthe\nsequence\nof\nc\nharacters\n\nis\nnot\nan\nexternal\nrepresen\ntation\nof\nthe\nin\nteger\n\nev\nen\nthough\nit\nis\nan\nexpression\nev\naluating\nto\nthe\nin\nteger\n\nrather\nit\nis\nan\nexter\nnal\nrepresen\ntation\nof\na\nthreeelemen\nt\nlist\nthe\nelemen\nts\nof\nwhic\nh\nare\nthe\nsym\nb\nol\n\nand\nthe\nin\ntegers\n\nand\n\nSc\nhemes\nsyn\ntax\nhas\nthe\nprop\nert\ny\nthat\nan\ny\nsequence\nof\nc\nharacters\nthat\nis\nan\nexpression\nis\nalso\nthe\nexternal\nrepresen\ntation\nof\nsome\nob\nject\nThis\ncan\nlead\nto\nconfusion\nsince\nit\nma\ny\nnot\nb\ne\nob\nvious\nout\nof\ncon\ntext\nwhether\na\ngiv\nen\nsequence\nof\nc\nhar\nacters\nis\nin\ntended\nto\ndenote\ndata\nor\nprogram\nbut\nit\nis\nalso\na\nsource\nof\np\no\nw\ner\nsince\nit\nfacilitates\nwriting\nprograms\nsuc\nh\nas\nin\nterpreters\nand\ncompilers\nthat\ntreat\nprograms\nas\ndata\nor\nvice\nv\nersa\nThe\nsyn\ntax\nof\nexternal\nrepresen\ntations\nof\nv\narious\nkinds\nof\nob\njects\naccompanies\nthe\ndescription\nof\nthe\nprimitiv\nes\nfor\nmanipulating\nthe\nob\njects\nin\nthe\nappropriate\nsections\nof\nc\nhapter\n\nStorage\nmo\ndel\nV\nariables\nand\nob\njects\nsuc\nh\nas\npairs\nv\nectors\nand\nstrings\nimplicitly\ndenote\nlo\ncations\nor\nsequences\nof\nlo\ncations\nA\nstring\nfor\nexample\ndenotes\nas\nman\ny\nlo\ncations\nas\nthere\nare\nc\nharacters\nin\nthe\nstring\nThese\nlo\ncations\nneed\nnot\ncorresp\nond\nto\na\nfull\nmac\nhine\nw\nord\nA\nnew\nv\nalue\nma\ny\nb\ne\nstored\nin\nto\none\nof\nthese\nlo\ncations\nusing\nthe\nstringset\npro\ncedure\nbut\nthe\nstring\ncon\ntin\nues\nto\ndenote\nthe\nsame\nlo\ncations\nas\nb\nefore\nAn\nob\nject\nfetc\nhed\nfrom\na\nlo\ncation\nb\ny\na\nv\nariable\nreference\nor\nb\ny\na\npro\ncedure\nsuc\nh\nas\ncar\nvectorref\nor\nstringref\nis\nequiv\nalen\nt\nin\nthe\nsense\nof\neqv\nsection\n\nto\nthe\nob\nject\nlast\nstored\nin\nthe\nlo\ncation\nb\nefore\nthe\nfetc\nh\nEv\nery\nlo\ncation\nis\nmark\ned\nto\nsho\nw\nwhether\nit\nis\nin\nuse\nNo\nv\nariable\nor\nob\nject\nev\ner\nrefers\nto\na\nlo\ncation\nthat\nis\nnot\nin\nuse\nWhenev\ner\nthis\nrep\nort\nsp\neaks\nof\nstorage\nb\neing\nallo\ncated\nfor\na\nv\nariable\nor\nob\nject\nwhat\nis\nmean\nt\nis\nthat\nan\nappropriate\nn\num\nb\ner\nof\nlo\ncations\nare\nc\nhosen\nfrom\nthe\nset\nof\nlo\ncations\nthat\nare\nnot\nin\nuse\nand\nthe\nc\nhosen\nlo\ncations\nare\nmark\ned\nto\nindicate\nthat\nthey\nare\nno\nw\nin\nuse\nb\nefore\nthe\nv\nariable\nor\nob\nject\nis\nmade\nto\ndenote\nthem\nIn\nman\ny\nsystems\nit\nis\ndesirable\nfor\nconstan\nts\nie\nthe\nv\nal\nues\nof\nliteral\nexpressions\nto\nreside\nin\nreadonlymemory\n\nT\no\nexpress\nthis\nit\nis\ncon\nv\nenien\nt\nto\nimagine\nthat\nev\nery\nob\nject\nthat\ndenotes\nlo\ncations\nis\nasso\nciated\nwith\na\nag\ntelling\nwhether\nthat\nob\nject\nis\nm\nutable\nor\nimm\nutable\nIn\nsuc\nh\nsystems\nliteral\nconstan\nts\nand\nthe\nstrings\nreturned\nb\ny\nsymbolstring\nare\nimm\nutable\nob\njects\nwhile\nall\nob\njects\ncreated\nb\ny\nthe\nother\npro\ncedures\nlisted\nin\nthis\nrep\nort\nare\nm\nutable\nIt\nis\nan\nerror\nto\nattempt\nto\nstore\na\nnew\nv\nalue\nin\nto\na\nlo\ncation\nthat\nis\ndenoted\nb\ny\nan\nimm\nutable\nob\nject\n\nProp\ner\ntail\nrecursion\nImplemen\ntations\nof\nSc\nheme\nare\nrequired\nto\nb\ne\npr\nop\nerly\ntail\nr\ne\ncursive\nPro\ncedure\ncalls\nthat\no\nccur\nin\ncertain\nsyn\ntactic\ncon\ntexts\ndened\nb\nelo\nw\nare\ntail\ncalls\nA\nSc\nheme\nimple\nmen\ntation\nis\nprop\nerly\ntailrecursiv\ne\nif\nit\nsupp\norts\nan\nun\nb\nounded\nn\num\nb\ner\nof\nactiv\ne\ntail\ncalls\nA\ncall\nis\nactive\nif\nthe\ncalled\npro\ncedure\nma\ny\nstill\nreturn\nNote\nthat\nthis\nin\ncludes\ncalls\nthat\nma\ny\nb\ne\nreturned\nfrom\neither\nb\ny\nthe\ncur\nren\nt\ncon\ntin\nuation\nor\nb\ny\ncon\ntin\nuations\ncaptured\nearlier\nb\ny\ncallwithcurrent\nc\nont\nin\nuat\nio\nn\nthat\nare\nlater\nin\nv\nok\ned\nIn\nthe\nabsence\nof\ncaptured\ncon\ntin\nuations\ncalls\ncould\nreturn\nat\nmost\nonce\nand\nthe\nactiv\ne\ncalls\nw\nould\nb\ne\nthose\nthat\nhad\nnot\ny\net\nreturned\nA\nformal\ndenition\nof\nprop\ner\ntail\nrecur\nsion\ncan\nb\ne\nfound\nin\n\nR\nationale\nIn\ntuitiv\nely\n\nno\nspace\nis\nneeded\nfor\nan\nactiv\ne\ntail\ncall\nb\necause\nthe\ncon\ntin\nuation\nthat\nis\nused\nin\nthe\ntail\ncall\nhas\nthe\nsame\nseman\ntics\nas\nthe\ncon\ntin\nuation\npassed\nto\nthe\npro\ncedure\ncon\ntaining\nthe\ncall\nAlthough\nan\nimprop\ner\nimplemen\ntation\nmigh\nt\nuse\na\nnew\ncon\ntin\nuation\nin\nthe\ncall\na\nreturn\nto\nthis\nnew\ncon\ntin\nuation\nw\nould\nb\ne\nfollo\nw\ned\nimmediately\nb\ny\na\nreturn\nto\nthe\ncon\ntin\nuation\npassed\nto\nthe\npro\ncedure\nA\nprop\nerly\ntailrecursiv\ne\nimplemen\ntation\nre\nturns\nto\nthat\ncon\ntin\nuation\ndirectly\n\nProp\ner\ntail\nrecursion\nw\nas\none\nof\nthe\ncen\ntral\nideas\nin\nSteele\nand\nSussmans\noriginal\nv\nersion\nof\nSc\nheme\nTheir\nrst\nSc\nheme\nin\nterpreter\nimplemen\nted\nb\noth\nfunctions\nand\nactors\nCon\ntrol\no\nw\nw\nas\nexpressed\nusing\nactors\nwhic\nh\ndiered\nfrom\nfunctions\nin\nthat\nthey\npassed\ntheir\nresults\non\nto\nanother\nactor\ninstead\nof\nreturning\nto\na\ncaller\nIn\nthe\nterminology\nof\nthis\nsection\neac\nh\nactor\nnished\nwith\na\ntail\ncall\nto\nanother\nactor\nSteele\nand\nSussman\nlater\nobserv\ned\nthat\nin\ntheir\nin\nterpreter\nthe\nco\nde\nfor\ndealing\nwith\nactors\nw\nas\niden\ntical\nto\nthat\nfor\nfunctions\nand\nth\nus\nthere\nw\nas\nno\nneed\nto\ninclude\nb\noth\nin\nthe\nlanguage\nA\ntail\nc\nal\nl\nis\na\npro\ncedure\ncall\nthat\no\nccurs\nin\na\ntail\nc\non\ntext\nT\nail\ncon\ntexts\nare\ndened\ninductiv\nely\n\nNote\nthat\na\ntail\ncon\ntext\nis\nalw\na\nys\ndetermined\nwith\nresp\nect\nto\na\nparticular\nlam\nb\nda\nexpression\n\nThe\nlast\nexpression\nwithin\nthe\nb\no\ndy\nof\na\nlam\nb\nda\nex\npression\nsho\nwn\nas\nhtail\nexpressioni\nb\nelo\nw\no\nccurs\nin\na\ntail\ncon\ntext\nlambda\nhformalsi\nhdenitioni\nhexpressioni\nhtail\nexpressioni\n\nIf\none\nof\nthe\nfollo\nwing\nexpressions\nis\nin\na\ntail\ncon\ntext\nthen\nthe\nsub\nexpressions\nsho\nwn\nas\nhtail\nexpressioni\nare\nin\na\ntail\ncon\ntext\nThese\nw\nere\nderiv\ned\nfrom\nrules\nin\n\nRevised\n\nSc\nheme\nthe\ngrammar\ngiv\nen\nin\nc\nhapter\n\nb\ny\nreplacing\nsome\no\nc\ncurrences\nof\nhexpressioni\nwith\nhtail\nexpressioni\n\nOnly\nthose\nrules\nthat\ncon\ntain\ntail\ncon\ntexts\nare\nsho\nwn\nhere\nif\nhexpressioni\nhtail\nexpressioni\nhtail\nexpressioni\n\nif\nhexpressioni\nhtail\nexpressioni\n\ncond\nhcond\nclausei\n\ncond\nhcond\nclausei\nelse\nhtail\nsequencei\ncase\nhexpressioni\nhcase\nclausei\n\ncase\nhexpressioni\nhcase\nclausei\nelse\nhtail\nsequencei\n\nand\nhexpressioni\n\nhtail\nexpressioni\n\nor\nhexpressioni\n\nhtail\nexpressioni\n\nlet\nhbinding\nsp\neci\n\nhtail\nb\no\ndyi\n\nlet\nhv\nariablei\nhbinding\nsp\neci\n\nhtail\nb\no\ndyi\nlet\nhbinding\nsp\neci\nhtail\nb\no\ndyi\n\nletrec\nhbinding\nsp\neci\n\nhtail\nb\no\ndyi\n\nletsyntax\nhsyn\ntax\nsp\neci\n\nhtail\nb\no\ndyi\n\nletrecsyntax\nhsyn\ntax\nsp\neci\n\nhtail\nb\no\ndyi\n\nbegin\nhtail\nsequencei\ndo\nhiteration\nsp\neci\nhtesti\nhtail\nsequencei\nhexpressioni\n\nwhere\nhcond\nclausei\n\nhtesti\nhtail\nsequencei\nhcase\nclausei\n\nhdatumi\n\nhtail\nsequencei\nhtail\nb\no\ndyi\n\nhdenitioni\n\nhtail\nsequencei\nhtail\nsequencei\n\nhexpressioni\n\nhtail\nexpressioni\n\nIf\na\ncond\nexpression\nis\nin\na\ntail\ncon\ntext\nand\nhas\na\nclause\nof\nthe\nform\nhexpression\n\ni\n\nhexpression\n\ni\nthen\nthe\nimplied\ncall\nto\nthe\npro\ncedure\nthat\nresults\nfrom\nthe\nev\naluation\nof\nhexpression\n\ni\nis\nin\na\ntail\ncon\ntext\nhexpression\n\ni\nitself\nis\nnot\nin\na\ntail\ncon\ntext\nCertain\nbuiltin\npro\ncedures\nare\nalso\nrequired\nto\np\nerform\ntail\ncalls\nThe\nrst\nargumen\nt\npassed\nto\napply\nand\nto\ncallwithcurren\ntc\non\nti\nnua\nti\non\nand\nthe\nsecond\nargu\nmen\nt\npassed\nto\ncallwithvalues\n\nm\nust\nb\ne\ncalled\nvia\na\ntail\ncall\nSimilarly\n\neval\nm\nust\nev\naluate\nits\nargumen\nt\nas\nif\nit\nw\nere\nin\ntail\np\nosition\nwithin\nthe\neval\npro\ncedure\nIn\nthe\nfollo\nwing\nexample\nthe\nonly\ntail\ncall\nis\nthe\ncall\nto\nf\nNone\nof\nthe\ncalls\nto\ng\nor\nh\nare\ntail\ncalls\nThe\nreference\nto\nx\nis\nin\na\ntail\ncon\ntext\nbut\nit\nis\nnot\na\ncall\nand\nth\nus\nis\nnot\na\ntail\ncall\nlambda\n\nif\ng\nlet\nx\nh\nx\nand\ng\nf\nNote\nImplemen\ntations\nare\nallo\nw\ned\nbut\nnot\nrequired\nto\nrecog\nnize\nthat\nsome\nnontail\ncalls\nsuc\nh\nas\nthe\ncall\nto\nh\nab\no\nv\ne\ncan\nb\ne\nev\naluated\nas\nthough\nthey\nw\nere\ntail\ncalls\nIn\nthe\nexample\nab\no\nv\ne\nthe\nlet\nexpression\ncould\nb\ne\ncompiled\nas\na\ntail\ncall\nto\nh\nThe\np\nossibilit\ny\nof\nh\nreturning\nan\nunexp\nected\nn\num\nb\ner\nof\nv\nalues\ncan\nb\ne\nignored\nb\necause\nin\nthat\ncase\nthe\neect\nof\nthe\nlet\nis\nexplicitly\nunsp\necied\nand\nimplemen\ntationdep\nenden\nt\n\nExpressions\nExpression\nt\nyp\nes\nare\ncategorized\nas\nprimitive\nor\nderive\nd\nPrimitiv\ne\nexpression\nt\nyp\nes\ninclude\nv\nariables\nand\npro\ncedure\ncalls\nDeriv\ned\nexpression\nt\nyp\nes\nare\nnot\nseman\ntically\nprim\nitiv\ne\nbut\ncan\ninstead\nb\ne\ndened\nas\nmacros\nWith\nthe\nex\nception\nof\nquasiquote\nwhose\nmacro\ndenition\nis\ncomplex\nthe\nderiv\ned\nexpressions\nare\nclassied\nas\nlibrary\nfeatures\nSuitable\ndenitions\nare\ngiv\nen\nin\nsection\n\nPrimitiv\ne\nexpression\nt\nyp\nes\n\nV\nariable\nreferences\nhv\nariablei\nsyn\ntax\nAn\nexpression\nconsisting\nof\na\nv\nariable\nsection\n\nis\na\nv\nariable\nreference\nThe\nv\nalue\nof\nthe\nv\nariable\nreference\nis\nthe\nv\nalue\nstored\nin\nthe\nlo\ncation\nto\nwhic\nh\nthe\nv\nariable\nis\nb\nound\nIt\nis\nan\nerror\nto\nreference\nan\nun\nb\nound\nv\nariable\ndefine\nx\n\nx\n\nLiteral\nexpressions\nquote\nhdatumi\n\nsyn\ntax\nhdatumi\nsyn\ntax\nhconstan\nti\nsyn\ntax\nquote\nhdatumi\n\nev\naluates\nto\nhdatumi\n\nhDatumi\nma\ny\nb\ne\nan\ny\nexternal\nrepresen\ntation\nof\na\nSc\nheme\nob\nject\nsee\nsec\ntion\n\nThis\nnotation\nis\nused\nto\ninclude\nliteral\nconstan\nts\nin\nSc\nheme\nco\nde\nquote\na\n\na\nquote\na\nb\nc\n\na\nb\nc\nquote\n\nExpressions\n\nquote\nhdatumi\n\nma\ny\nb\ne\nabbreviated\nas\nhdatumi\nThe\nt\nw\no\nnotations\nare\nequiv\nalen\nt\nin\nall\nresp\nects\na\n\na\na\nb\nc\n\na\nb\nc\n\nquote\na\n\nquote\na\na\n\nquote\na\nNumerical\nconstan\nts\nstring\nconstan\nts\nc\nharacter\nconstan\nts\nand\nb\no\nolean\nconstan\nts\nev\naluate\nto\nthemselv\nes\nthey\nneed\nnot\nb\ne\nquoted\nabc\n\nabc\nabc\n\nabc\n\nt\n\nt\nt\n\nt\nAs\nnoted\nin\nsection\n\nit\nis\nan\nerror\nto\nalter\na\nconstan\nt\nie\nthe\nv\nalue\nof\na\nliteral\nexpression\nusing\na\nm\nutation\npro\ncedure\nlik\ne\nsetcar\nor\nstringset\n\nPro\ncedure\ncalls\nhop\neratori\nhop\nerand\n\ni\n\nsyn\ntax\nA\npro\ncedure\ncall\nis\nwritten\nb\ny\nsimply\nenclosing\nin\nparen\ntheses\nexpressions\nfor\nthe\npro\ncedure\nto\nb\ne\ncalled\nand\nthe\nargumen\nts\nto\nb\ne\npassed\nto\nit\nThe\nop\nerator\nand\nop\nerand\nexpressions\nare\nev\naluated\nin\nan\nunsp\necied\norder\nand\nthe\nresulting\npro\ncedure\nis\npassed\nthe\nresulting\nargumen\nts\n\nif\nf\n\nA\nn\num\nb\ner\nof\npro\ncedures\nare\na\nv\nailable\nas\nthe\nv\nalues\nof\nv\nari\nables\nin\nthe\ninitial\nen\nvironmen\nt\nfor\nexample\nthe\naddition\nand\nm\nultiplication\npro\ncedures\nin\nthe\nab\no\nv\ne\nexamples\nare\nthe\nv\nalues\nof\nthe\nv\nariables\n\nand\n\nNew\npro\ncedures\nare\ncre\nated\nb\ny\nev\naluating\nlambda\nexpressions\nsee\nsection\n\nPro\ncedure\ncalls\nma\ny\nreturn\nan\ny\nn\num\nb\ner\nof\nv\nalues\nsee\nvalues\nin\nsection\n\nWith\nthe\nexception\nof\nvalues\nthe\npro\ncedures\na\nv\nailable\nin\nthe\ninitial\nen\nvironmen\nt\nreturn\none\nv\nalue\nor\nfor\npro\ncedures\nsuc\nh\nas\napply\npass\non\nthe\nv\nalues\nreturned\nb\ny\na\ncall\nto\none\nof\ntheir\nargumen\nts\nPro\ncedure\ncalls\nare\nalso\ncalled\nc\nombinations\nNote\nIn\ncon\ntrast\nto\nother\ndialects\nof\nLisp\nthe\norder\nof\nev\naluation\nis\nunsp\necied\nand\nthe\nop\nerator\nexpression\nand\nthe\nop\nerand\nexpressions\nare\nalw\na\nys\nev\naluated\nwith\nthe\nsame\nev\nalu\nation\nrules\nNote\nAlthough\nthe\norder\nof\nev\naluation\nis\notherwise\nunsp\neci\ned\nthe\neect\nof\nan\ny\nconcurren\nt\nev\naluation\nof\nthe\nop\nerator\nand\nop\nerand\nexpressions\nis\nconstrained\nto\nb\ne\nconsisten\nt\nwith\nsome\nsequen\ntial\norder\nof\nev\naluation\nThe\norder\nof\nev\naluation\nma\ny\nb\ne\nc\nhosen\ndieren\ntly\nfor\neac\nh\npro\ncedure\ncall\nNote\nIn\nman\ny\ndialects\nof\nLisp\nthe\nempt\ny\ncom\nbination\n\nis\na\nlegitimate\nexpression\nIn\nSc\nheme\ncom\nbinations\nm\nust\nha\nv\ne\nat\nleast\none\nsub\nexpression\nso\n\nis\nnot\na\nsyn\ntactically\nv\nalid\nexpression\n\nPro\ncedures\nlambda\nhformalsi\nhb\no\ndyi\n\nsyn\ntax\nSyntax\nhF\normalsi\nshould\nb\ne\na\nformal\nargumen\nts\nlist\nas\ndescrib\ned\nb\nelo\nw\nand\nhb\no\ndyi\nshould\nb\ne\na\nsequence\nof\none\nor\nmore\nexpressions\nSemantics\nA\nlambda\nexpression\nev\naluates\nto\na\npro\ncedure\nThe\nen\nvironmen\nt\nin\neect\nwhen\nthe\nlambda\nexpression\nw\nas\nev\naluated\nis\nremem\nb\nered\nas\npart\nof\nthe\npro\ncedure\nWhen\nthe\npro\ncedure\nis\nlater\ncalled\nwith\nsome\nactual\nargumen\nts\nthe\nen\nvironmen\nt\nin\nwhic\nh\nthe\nlambda\nexpression\nw\nas\nev\nalu\nated\nwill\nb\ne\nextended\nb\ny\nbinding\nthe\nv\nariables\nin\nthe\nformal\nargumen\nt\nlist\nto\nfresh\nlo\ncations\nthe\ncorresp\nonding\nactual\nargumen\nt\nv\nalues\nwill\nb\ne\nstored\nin\nthose\nlo\ncations\nand\nthe\nexpressions\nin\nthe\nb\no\ndy\nof\nthe\nlambda\nexpression\nwill\nb\ne\nev\naluated\nsequen\ntially\nin\nthe\nextended\nen\nvironmen\nt\nThe\nresults\nof\nthe\nlast\nexpression\nin\nthe\nb\no\ndy\nwill\nb\ne\nreturned\nas\nthe\nresults\nof\nthe\npro\ncedure\ncall\nlambda\nx\n\nx\nx\n\na\npr\no\nc\ne\ndur\ne\nlambda\nx\n\nx\nx\n\ndefine\nreversesubtract\nlambda\nx\ny\n\ny\nx\nreversesubtract\n\ndefine\nadd\nlet\nx\n\nlambda\ny\n\nx\ny\nadd\n\nhF\normalsi\nshould\nha\nv\ne\none\nof\nthe\nfollo\nwing\nforms\n\nhv\nariable\n\ni\n\nThe\npro\ncedure\ntak\nes\na\nxed\nn\num\nb\ner\nof\nargumen\nts\nwhen\nthe\npro\ncedure\nis\ncalled\nthe\nargumen\nts\nwill\nb\ne\nstored\nin\nthe\nbindings\nof\nthe\ncorre\nsp\nonding\nv\nariables\n\nhv\nariablei\nThe\npro\ncedure\ntak\nes\nan\ny\nn\num\nb\ner\nof\nar\ngumen\nts\nwhen\nthe\npro\ncedure\nis\ncalled\nthe\nsequence\nof\nactual\nargumen\nts\nis\ncon\nv\nerted\nin\nto\na\nnewly\nallo\ncated\nlist\nand\nthe\nlist\nis\nstored\nin\nthe\nbinding\nof\nthe\nhv\nariablei\n\nhv\nariable\n\ni\n\nhv\nariable\nn\ni\n\nhv\nariable\nn\ni\n\nIf\na\nspacedelimited\np\nerio\nd\nprecedes\nthe\nlast\nv\nariable\nthen\nthe\npro\ncedure\ntak\nes\nn\nor\nmore\nargumen\nts\nwhere\nn\nis\nthe\nn\num\nb\ner\nof\nformal\nargumen\nts\nb\nefore\nthe\np\nerio\nd\nthere\nm\nust\nb\ne\nat\nleast\none\nThe\nv\nalue\nstored\nin\nthe\nbinding\nof\nthe\nlast\nv\nariable\nwill\nb\ne\na\nnewly\nallo\ncated\nlist\nof\nthe\nactual\nargumen\nts\nleft\no\nv\ner\nafter\nall\nthe\nother\nactual\nargumen\nts\nha\nv\ne\nb\neen\nmatc\nhed\nup\nagainst\nthe\nother\nformal\nargumen\nts\n\nRevised\n\nSc\nheme\nIt\nis\nan\nerror\nfor\na\nhv\nariablei\nto\napp\near\nmore\nthan\nonce\nin\nhformalsi\n\nlambda\nx\nx\n\nlambda\nx\ny\n\nz\nz\n\nEac\nh\npro\ncedure\ncreated\nas\nthe\nresult\nof\nev\naluating\na\nlambda\nexpression\nis\nconceptually\ntagged\nwith\na\nstorage\nlo\ncation\nin\norder\nto\nmak\ne\neqv\nand\neq\nw\nork\non\npro\ncedures\nsee\nsection\n\nConditionals\nif\nhtesti\nhconsequen\nti\nhalternatei\nsyn\ntax\nif\nhtesti\nhconsequen\nti\n\nsyn\ntax\nSyntax\nhT\nesti\n\nhconsequen\nti\nand\nhalternatei\nma\ny\nb\ne\narbi\ntrary\nexpressions\nSemantics\nAn\nif\nexpression\nis\nev\naluated\nas\nfollo\nws\nrst\nhtesti\nis\nev\naluated\nIf\nit\nyields\na\ntrue\nv\nalue\nsee\nsec\ntion\n\nthen\nhconsequen\nti\nis\nev\naluated\nand\nits\nv\nalues\nisare\nreturned\nOtherwise\nhalternatei\nis\nev\naluated\nand\nits\nv\nalues\nisare\nreturned\nIf\nhtesti\nyields\na\nfalse\nv\nalue\nand\nno\nhalternatei\nis\nsp\necied\nthen\nthe\nresult\nof\nthe\nexpression\nis\nunsp\necied\nif\n\nyes\nno\n\nyes\nif\n\nyes\nno\n\nno\nif\n\nAssignmen\nts\nset\nhv\nariablei\nhexpressioni\n\nsyn\ntax\nhExpressioni\nis\nev\naluated\nand\nthe\nresulting\nv\nalue\nis\nstored\nin\nthe\nlo\ncation\nto\nwhic\nh\nhv\nariablei\nis\nb\nound\nhV\nariablei\nm\nust\nb\ne\nb\nound\neither\nin\nsome\nregion\nenclosing\nthe\nset\nexpression\nor\nat\ntop\nlev\nel\nThe\nresult\nof\nthe\nset\nexpression\nis\nunsp\necied\ndefine\nx\n\nx\n\nset\nx\n\nunsp\ne\ncie\nd\n\nx\n\nDeriv\ned\nexpression\nt\nyp\nes\nThe\nconstructs\nin\nthis\nsection\nare\nh\nygienic\nas\ndiscussed\nin\nsection\n\nF\nor\nreference\npurp\noses\nsection\n\ngiv\nes\nmacro\ndenitions\nthat\nwill\ncon\nv\nert\nmost\nof\nthe\nconstructs\ndescrib\ned\nin\nthis\nsection\nin\nto\nthe\nprimitiv\ne\nconstructs\nde\nscrib\ned\nin\nthe\nprevious\nsection\n\nConditionals\ncond\nhclause\n\ni\nhclause\n\ni\n\nlibrary\nsyn\ntax\nSyntax\nEac\nh\nhclausei\nshould\nb\ne\nof\nthe\nform\nhtesti\nhexpression\n\ni\n\nwhere\nhtesti\nis\nan\ny\nexpression\nAlternativ\nely\n\na\nhclausei\nma\ny\nb\ne\nof\nthe\nform\nhtesti\n\nhexpressioni\n\nThe\nlast\nhclausei\nma\ny\nb\ne\nan\nelse\nclause\nwhic\nh\nhas\nthe\nform\nelse\nhexpression\n\ni\nhexpression\n\ni\n\nSemantics\nA\ncond\nexpression\nis\nev\naluated\nb\ny\nev\naluating\nthe\nhtesti\nexpressions\nof\nsuccessiv\ne\nhclauseis\nin\norder\nun\ntil\none\nof\nthem\nev\naluates\nto\na\ntrue\nv\nalue\nsee\nsection\n\nWhen\na\nhtesti\nev\naluates\nto\na\ntrue\nv\nalue\nthen\nthe\nremain\ning\nhexpressioni\ns\nin\nits\nhclausei\nare\nev\naluated\nin\norder\nand\nthe\nresults\nof\nthe\nlast\nhexpressioni\nin\nthe\nhclausei\nisare\nreturned\nas\nthe\nresults\nof\nthe\nen\ntire\ncond\nexpres\nsion\nIf\nthe\nselected\nhclausei\ncon\ntains\nonly\nthe\nhtesti\nand\nno\nhexpressioni\ns\nthen\nthe\nv\nalue\nof\nthe\nhtesti\nis\nreturned\nas\nthe\nresult\nIf\nthe\nselected\nhclausei\nuses\nthe\n\nalternate\nform\nthen\nthe\nhexpressioni\nis\nev\naluated\nIts\nv\nalue\nm\nust\nb\ne\na\npro\ncedure\nthat\naccepts\none\nargumen\nt\nthis\npro\ncedure\nis\nthen\ncalled\non\nthe\nv\nalue\nof\nthe\nhtesti\nand\nthe\nv\nalues\nreturned\nb\ny\nthis\npro\ncedure\nisare\nreturned\nb\ny\nthe\ncond\nexpression\nIf\nall\nhtesti\ns\nev\naluate\nto\nfalse\nv\nalues\nand\nthere\nis\nno\nelse\nclause\nthen\nthe\nresult\nof\nthe\nconditional\nexpression\nis\nun\nsp\necied\nif\nthere\nis\nan\nelse\nclause\nthen\nits\nhexpressioni\ns\nare\nev\naluated\nand\nthe\nv\nalues\nof\nthe\nlast\none\nisare\nreturned\ncond\n\ngreater\n\nless\n\ngreater\ncond\n\ngreater\n\nless\nelse\nequal\n\nequal\ncond\nassv\nb\na\n\nb\n\ncadr\nelse\nf\n\ncase\nhk\neyi\nhclause\n\ni\nhclause\n\ni\n\nlibrary\nsyn\ntax\nSyntax\nhKeyi\nma\ny\nb\ne\nan\ny\nexpression\nEac\nh\nhclausei\nshould\nha\nv\ne\nthe\nform\nhdatum\n\ni\n\nhexpression\n\ni\nhexpression\n\ni\n\nwhere\neac\nh\nhdatumi\nis\nan\nexternal\nrepresen\ntation\nof\nsome\nob\nject\nAll\nthe\nhdatumis\nm\nust\nb\ne\ndistinct\nThe\nlast\nhclausei\nma\ny\nb\ne\nan\nelse\nclause\nwhic\nh\nhas\nthe\nform\nelse\nhexpression\n\ni\nhexpression\n\ni\n\nSemantics\nA\ncase\nexpression\nis\nev\naluated\nas\nfollo\nws\nhKeyi\nis\nev\naluated\nand\nits\nresult\nis\ncompared\nagainst\neac\nh\nhdatumi\n\nIf\nthe\nresult\nof\nev\naluating\nhk\neyi\nis\nequiv\nalen\nt\nin\nthe\nsense\nof\neqv\nsee\nsection\n\nto\na\nhdatumi\n\nthen\nthe\nexpressions\nin\nthe\ncorresp\nonding\nhclausei\nare\nev\naluated\nfrom\nleft\nto\nrigh\nt\nand\nthe\nresults\nof\nthe\nlast\nexpression\nin\n\nExpressions\n\nthe\nhclausei\nisare\nreturned\nas\nthe\nresults\nof\nthe\ncase\nex\npression\nIf\nthe\nresult\nof\nev\naluating\nhk\neyi\nis\ndieren\nt\nfrom\nev\nery\nhdatumi\n\nthen\nif\nthere\nis\nan\nelse\nclause\nits\nexpres\nsions\nare\nev\naluated\nand\nthe\nresults\nof\nthe\nlast\nisare\nthe\nresults\nof\nthe\ncase\nexpression\notherwise\nthe\nresult\nof\nthe\ncase\nexpression\nis\nunsp\necied\ncase\n\nprime\n\ncomposite\n\ncomposite\ncase\ncar\nc\nd\na\na\nb\nb\n\nunsp\ne\ncie\nd\ncase\ncar\nc\nd\na\ne\ni\no\nu\nvowel\nw\ny\nsemivowel\nelse\nconsonant\n\nconsonant\nand\nhtest\n\ni\n\nlibrary\nsyn\ntax\nThe\nhtesti\nexpressions\nare\nev\naluated\nfrom\nleft\nto\nrigh\nt\nand\nthe\nv\nalue\nof\nthe\nrst\nexpression\nthat\nev\naluates\nto\na\nfalse\nv\nalue\nsee\nsection\n\nis\nreturned\nAn\ny\nremaining\nex\npressions\nare\nnot\nev\naluated\nIf\nall\nthe\nexpressions\nev\naluate\nto\ntrue\nv\nalues\nthe\nv\nalue\nof\nthe\nlast\nexpression\nis\nreturned\nIf\nthere\nare\nno\nexpressions\nthen\nt\nis\nreturned\nand\n\nt\nand\n\nf\nand\n\nc\nf\ng\n\nf\ng\nand\n\nt\nor\nhtest\n\ni\n\nlibrary\nsyn\ntax\nThe\nhtesti\nexpressions\nare\nev\naluated\nfrom\nleft\nto\nrigh\nt\nand\nthe\nv\nalue\nof\nthe\nrst\nexpression\nthat\nev\naluates\nto\na\ntrue\nv\nalue\nsee\nsection\n\nis\nreturned\nAn\ny\nremaining\nex\npressions\nare\nnot\nev\naluated\nIf\nall\nexpressions\nev\naluate\nto\nfalse\nv\nalues\nthe\nv\nalue\nof\nthe\nlast\nexpression\nis\nreturned\nIf\nthere\nare\nno\nexpressions\nthen\nf\nis\nreturned\nor\n\nt\nor\n\nt\nor\nf\nf\nf\n\nf\nor\nmemq\nb\na\nb\nc\n\nb\nc\n\nBinding\nconstructs\nThe\nthree\nbinding\nconstructs\nlet\nlet\nand\nletrec\ngiv\ne\nSc\nheme\na\nblo\nc\nk\nstructure\nlik\ne\nAlgol\n\nThe\nsyn\ntax\nof\nthe\nthree\nconstructs\nis\niden\ntical\nbut\nthey\ndier\nin\nthe\nregions\nthey\nestablish\nfor\ntheir\nv\nariable\nbindings\nIn\na\nlet\nex\npression\nthe\ninitial\nv\nalues\nare\ncomputed\nb\nefore\nan\ny\nof\nthe\nv\nariables\nb\necome\nb\nound\nin\na\nlet\nexpression\nthe\nbind\nings\nand\nev\naluations\nare\np\nerformed\nsequen\ntially\nwhile\nin\na\nletrec\nexpression\nall\nthe\nbindings\nare\nin\neect\nwhile\ntheir\ninitial\nv\nalues\nare\nb\neing\ncomputed\nth\nus\nallo\nwing\nm\nutually\nrecursiv\ne\ndenitions\nlet\nhbindingsi\nhb\no\ndyi\n\nlibrary\nsyn\ntax\nSyntax\nhBindingsi\nshould\nha\nv\ne\nthe\nform\nhv\nariable\n\ni\nhinit\n\ni\n\nwhere\neac\nh\nhiniti\nis\nan\nexpression\nand\nhb\no\ndyi\nshould\nb\ne\na\nsequence\nof\none\nor\nmore\nexpressions\nIt\nis\nan\nerror\nfor\na\nhv\nariablei\nto\napp\near\nmore\nthan\nonce\nin\nthe\nlist\nof\nv\nariables\nb\neing\nb\nound\nSemantics\nThe\nhiniti\ns\nare\nev\naluated\nin\nthe\ncurren\nt\nen\nvi\nronmen\nt\nin\nsome\nunsp\necied\norder\nthe\nhv\nariableis\nare\nb\nound\nto\nfresh\nlo\ncations\nholding\nthe\nresults\nthe\nhb\no\ndyi\nis\nev\naluated\nin\nthe\nextended\nen\nvironmen\nt\nand\nthe\nv\nalues\nof\nthe\nlast\nexpression\nof\nhb\no\ndyi\nisare\nreturned\nEac\nh\nbind\ning\nof\na\nhv\nariablei\nhas\nhb\no\ndyi\nas\nits\nregion\nlet\nx\n\ny\n\nx\ny\n\nlet\nx\n\ny\n\nlet\nx\n\nz\n\nx\ny\n\nz\nx\n\nSee\nalso\nnamed\nlet\nsection\n\nlet\nhbindingsi\nhb\no\ndyi\n\nlibrary\nsyn\ntax\nSyntax\nhBindingsi\nshould\nha\nv\ne\nthe\nform\nhv\nariable\n\ni\nhinit\n\ni\n\nand\nhb\no\ndyi\nshould\nb\ne\na\nsequence\nof\none\nor\nmore\nexpres\nsions\nSemantics\nLet\nis\nsimilar\nto\nlet\nbut\nthe\nbindings\nare\np\nerformed\nsequen\ntially\nfrom\nleft\nto\nrigh\nt\nand\nthe\nregion\nof\na\nbinding\nindicated\nb\ny\nhv\nariablei\nhiniti\n\nis\nthat\npart\nof\nthe\nlet\nexpression\nto\nthe\nrigh\nt\nof\nthe\nbinding\nTh\nus\nthe\nsecond\nbinding\nis\ndone\nin\nan\nen\nvironmen\nt\nin\nwhic\nh\nthe\nrst\nbinding\nis\nvisible\nand\nso\non\nlet\nx\n\ny\n\nlet\nx\n\nz\n\nx\ny\n\nz\nx\n\nletrec\nhbindingsi\nhb\no\ndyi\n\nlibrary\nsyn\ntax\nSyntax\nhBindingsi\nshould\nha\nv\ne\nthe\nform\nhv\nariable\n\ni\nhinit\n\ni\n\nand\nhb\no\ndyi\nshould\nb\ne\na\nsequence\nof\none\nor\nmore\nexpres\nsions\nIt\nis\nan\nerror\nfor\na\nhv\nariablei\nto\napp\near\nmore\nthan\nonce\nin\nthe\nlist\nof\nv\nariables\nb\neing\nb\nound\nSemantics\nThe\nhv\nariablei\ns\nare\nb\nound\nto\nfresh\nlo\ncations\nholding\nundened\nv\nalues\nthe\nhiniti\ns\nare\nev\naluated\nin\nthe\n\nRevised\n\nSc\nheme\nresulting\nen\nvironmen\nt\nin\nsome\nunsp\necied\norder\neac\nh\nhv\nariablei\nis\nassigned\nto\nthe\nresult\nof\nthe\ncorresp\nonding\nhiniti\n\nthe\nhb\no\ndyi\nis\nev\naluated\nin\nthe\nresulting\nen\nvironmen\nt\nand\nthe\nv\nalues\nof\nthe\nlast\nexpression\nin\nhb\no\ndyi\nisare\nre\nturned\nEac\nh\nbinding\nof\na\nhv\nariablei\nhas\nthe\nen\ntire\nletrec\nexpression\nas\nits\nregion\nmaking\nit\np\nossible\nto\ndene\nm\nutu\nally\nrecursiv\ne\npro\ncedures\nletrec\neven\nlambda\nn\nif\nzero\nn\nt\nodd\n\nn\n\nodd\nlambda\nn\nif\nzero\nn\nf\neven\n\nn\n\neven\n\nt\nOne\nrestriction\non\nletrec\nis\nv\nery\nimp\nortan\nt\nit\nm\nust\nb\ne\np\nossible\nto\nev\naluate\neac\nh\nhiniti\nwithout\nassigning\nor\nrefer\nring\nto\nthe\nv\nalue\nof\nan\ny\nhv\nariablei\n\nIf\nthis\nrestriction\nis\nviolated\nthen\nit\nis\nan\nerror\nThe\nrestriction\nis\nnecessary\nb\necause\nSc\nheme\npasses\nargumen\nts\nb\ny\nv\nalue\nrather\nthan\nb\ny\nname\nIn\nthe\nmost\ncommon\nuses\nof\nletrec\nall\nthe\nhiniti\ns\nare\nlambda\nexpressions\nand\nthe\nrestriction\nis\nsatised\nau\ntomatically\n\nSequencing\nbegin\nhexpression\n\ni\nhexpression\n\ni\n\nlibrary\nsyn\ntax\nThe\nhexpressioni\ns\nare\nev\naluated\nsequen\ntially\nfrom\nleft\nto\nrigh\nt\nand\nthe\nv\nalues\nof\nthe\nlast\nhexpressioni\nisare\nre\nturned\nThis\nexpression\nt\nyp\ne\nis\nused\nto\nsequence\nside\nef\nfects\nsuc\nh\nas\ninput\nand\noutput\ndefine\nx\n\nbegin\nset\nx\n\nx\n\nbegin\ndisplay\n\nplus\n\nequals\n\ndisplay\n\nunsp\ne\ncie\nd\nand\nprints\n\nplus\n\nequals\n\nIteration\ndo\nhv\nariable\n\ni\nhinit\n\ni\nhstep\n\ni\n\nlibrary\nsyn\ntax\n\nhtesti\nhexpressioni\n\nhcommandi\n\nDo\nis\nan\niteration\nconstruct\nIt\nsp\necies\na\nset\nof\nv\nariables\nto\nb\ne\nb\nound\nho\nw\nthey\nare\nto\nb\ne\ninitialized\nat\nthe\nstart\nand\nho\nw\nthey\nare\nto\nb\ne\nup\ndated\non\neac\nh\niteration\nWhen\na\ntermination\ncondition\nis\nmet\nthe\nlo\nop\nexits\nafter\nev\naluating\nthe\nhexpressioni\ns\nDo\nexpressions\nare\nev\naluated\nas\nfollo\nws\nThe\nhiniti\nex\npressions\nare\nev\naluated\nin\nsome\nunsp\necied\norder\nthe\nhv\nariableis\nare\nb\nound\nto\nfresh\nlo\ncations\nthe\nresults\nof\nthe\nhiniti\nexpressions\nare\nstored\nin\nthe\nbindings\nof\nthe\nhv\nariableis\nand\nthen\nthe\niteration\nphase\nb\negins\nEac\nh\niteration\nb\negins\nb\ny\nev\naluating\nhtesti\n\nif\nthe\nresult\nis\nfalse\nsee\nsection\n\nthen\nthe\nhcommandi\nexpressions\nare\nev\naluated\nin\norder\nfor\neect\nthe\nhstepi\nexpressions\nare\nev\naluated\nin\nsome\nunsp\necied\norder\nthe\nhv\nariablei\ns\nare\nb\nound\nto\nfresh\nlo\ncations\nthe\nresults\nof\nthe\nhstepi\ns\nare\nstored\nin\nthe\nbindings\nof\nthe\nhv\nariablei\ns\nand\nthe\nnext\niter\nation\nb\negins\nIf\nhtesti\nev\naluates\nto\na\ntrue\nv\nalue\nthen\nthe\nhexpressioni\ns\nare\nev\naluated\nfrom\nleft\nto\nrigh\nt\nand\nthe\nv\nalues\nof\nthe\nlast\nhexpressioni\nisare\nreturned\nIf\nno\nhexpressioni\ns\nare\npresen\nt\nthen\nthe\nv\nalue\nof\nthe\ndo\nexpression\nis\nunsp\necied\nThe\nregion\nof\nthe\nbinding\nof\na\nhv\nariablei\nconsists\nof\nthe\nen\ntire\ndo\nexpression\nexcept\nfor\nthe\nhiniti\ns\nIt\nis\nan\nerror\nfor\na\nhv\nariablei\nto\napp\near\nmore\nthan\nonce\nin\nthe\nlist\nof\ndo\nv\nariables\nA\nhstepi\nma\ny\nb\ne\nomitted\nin\nwhic\nh\ncase\nthe\neect\nis\nthe\nsame\nas\nif\nhv\nariablei\nhiniti\nhv\nariablei\n\nhad\nb\neen\nwritten\ninstead\nof\nhv\nariablei\nhiniti\n\ndo\nvec\nmakevector\n\ni\n\ni\n\ni\n\nvec\nvectorset\nvec\ni\ni\n\nlet\nx\n\ndo\nx\nx\ncdr\nx\nsum\n\nsum\ncar\nx\nnull\nx\nsum\n\nlet\nhv\nariablei\nhbindingsi\nhb\no\ndyi\n\nlibrary\nsyn\ntax\nNamed\nlet\nis\na\nv\narian\nt\non\nthe\nsyn\ntax\nof\nlet\nwhic\nh\npro\nvides\na\nmore\ngeneral\nlo\noping\nconstruct\nthan\ndo\nand\nma\ny\nalso\nb\ne\nused\nto\nexpress\nrecursions\nIt\nhas\nthe\nsame\nsyn\ntax\nand\nseman\ntics\nas\nordinary\nlet\nexcept\nthat\nhv\nariablei\nis\nb\nound\nwithin\nhb\no\ndyi\nto\na\npro\ncedure\nwhose\nformal\nargu\nmen\nts\nare\nthe\nb\nound\nv\nariables\nand\nwhose\nb\no\ndy\nis\nhb\no\ndyi\n\nTh\nus\nthe\nexecution\nof\nhb\no\ndyi\nma\ny\nb\ne\nrep\neated\nb\ny\nin\nv\noking\nthe\npro\ncedure\nnamed\nb\ny\nhv\nariablei\n\nlet\nloop\nnumbers\n\nnonneg\n\nneg\n\ncond\nnull\nnumbers\nlist\nnonneg\nneg\n\ncar\nnumbers\n\nloop\ncdr\nnumbers\ncons\ncar\nnumbers\nnonneg\nneg\n\ncar\nnumbers\n\nExpressions\n\nloop\ncdr\nnumbers\nnonneg\ncons\ncar\nnumbers\nneg\n\nDela\ny\ned\nev\naluation\ndelay\nhexpressioni\n\nlibrary\nsyn\ntax\nThe\ndelay\nconstruct\nis\nused\ntogether\nwith\nthe\npro\nce\ndure\nforce\nto\nimplemen\nt\nlazy\nevaluation\nor\nc\nal\nl\nby\nne\ne\nd\ndelay\nhexpressioni\n\nreturns\nan\nob\nject\ncalled\na\npr\nomise\nwhic\nh\nat\nsome\np\noin\nt\nin\nthe\nfuture\nma\ny\nb\ne\nask\ned\nb\ny\nthe\nforce\npro\ncedure\nto\nev\naluate\nhexpressioni\n\nand\ndeliv\ner\nthe\nresulting\nv\nalue\nThe\neect\nof\nhexpressioni\nreturning\nm\nulti\nple\nv\nalues\nis\nunsp\necied\nSee\nthe\ndescription\nof\nforce\nsection\n\nfor\na\nmore\ncom\nplete\ndescription\nof\ndelay\n\nQuasiquotation\nquasiquote\nhqq\ntemplatei\nsyn\ntax\nhqq\ntemplatei\nsyn\ntax\nBac\nkquote\nor\nquasiquote\nexpressions\nare\nuseful\nfor\nconstructing\na\nlist\nor\nv\nector\nstructure\nwhen\nmost\nbut\nnot\nall\nof\nthe\ndesired\nstructure\nis\nkno\nwn\nin\nadv\nance\nIf\nno\ncommas\napp\near\nwithin\nthe\nhqq\ntemplatei\nthe\nresult\nof\nev\naluating\nhqq\ntemplatei\nis\nequiv\nalen\nt\nto\nthe\nresult\nof\nev\naluating\nhqq\ntemplatei\nIf\na\ncomma\napp\nears\nwithin\nthe\nhqq\ntemplatei\nho\nw\nev\ner\nthe\nexpression\nfollo\nwing\nthe\ncomma\nis\nev\naluated\nunquoted\nand\nits\nresult\nis\ninserted\nin\nto\nthe\nstructure\ninstead\nof\nthe\ncomma\nand\nthe\nexpres\nsion\nIf\na\ncomma\napp\nears\nfollo\nw\ned\nimmediately\nb\ny\nan\nat\nsign\n\nthen\nthe\nfollo\nwing\nexpression\nm\nust\nev\naluate\nto\na\nlist\nthe\nop\nening\nand\nclosing\nparen\ntheses\nof\nthe\nlist\nare\nthen\nstripp\ned\na\nw\na\ny\nand\nthe\nelemen\nts\nof\nthe\nlist\nare\nin\nserted\nin\nplace\nof\nthe\ncomma\natsign\nexpression\nsequence\nA\ncomma\natsign\nshould\nonly\napp\near\nwithin\na\nlist\nor\nv\nector\nhqq\ntemplatei\n#list\n$\n\nlist\n\nlet\nname\na\n#list\n$name\n$name\n\nlist\na\nquote\na\n#a\n$\n\n$map\nabs\n\nb\n\na\n\nb\n#\nfoo\n$\n\n$cdr\nc\n\n$car\ncons\n\nfoo\n\ncons\n#\n\n$sqrt\n\n$map\nsqrt\n\nQuasiquote\nforms\nma\ny\nb\ne\nnested\nSubstitutions\nare\nmade\nonly\nfor\nunquoted\ncomp\nonen\nts\napp\nearing\nat\nthe\nsame\nnest\ning\nlev\nel\nas\nthe\noutermost\nbac\nkquote\nThe\nnesting\nlev\nel\nin\ncreases\nb\ny\none\ninside\neac\nh\nsuccessiv\ne\nquasiquotation\nand\ndecreases\nb\ny\none\ninside\neac\nh\nunquotation\n#a\n#b\n$\n\n$foo\n$\n\nd\ne\nf\n\na\n#b\n$\n\n$foo\n\nd\ne\nf\nlet\nname\nx\nname\ny\n#a\n#b\n$$name\n$$name\nd\ne\n\na\n#b\n$x\n$y\nd\ne\nThe\nt\nw\no\nnotations\nhqq\ntemplatei\nand\nquasiquote\nhqq\ntemplatei\nare\niden\ntical\nin\nall\nresp\nects\nhexpressioni\nis\niden\ntical\nto\nunquote\nhexpressioni\n\nand\nhexpressioni\nis\niden\ntical\nto\nunquotesplicing\nhexpressioni\n\nThe\nex\nternal\nsyn\ntax\ngenerated\nb\ny\nwrite\nfor\nt\nw\noelemen\nt\nlists\nwhose\ncar\nis\none\nof\nthese\nsym\nb\nols\nma\ny\nv\nary\nb\net\nw\neen\nim\nplemen\ntations\nquasiquote\nlist\nunquote\n\nlist\n\nquasiquote\nlist\nunquote\n\n#list\n$\n\nie\nquasiquote\nlist\nunquote\n\nUnpredictable\nb\neha\nvior\ncan\nresult\nif\nan\ny\nof\nthe\nsym\nb\nols\nquasiquote\nunquote\nor\nunquotesplicing\napp\near\nin\np\no\nsitions\nwithin\na\nhqq\ntemplatei\notherwise\nthan\nas\ndescrib\ned\nab\no\nv\ne\n\nMacros\nSc\nheme\nprograms\ncan\ndene\nand\nuse\nnew\nderiv\ned\nexpres\nsion\nt\nyp\nes\ncalled\nmacr\nos\nProgramdened\nexpression\nt\nyp\nes\nha\nv\ne\nthe\nsyn\ntax\nhk\neyw\nordi\nhdatumi\n\nwhere\nhk\neyw\nordi\nis\nan\niden\ntier\nthat\nuniquely\ndetermines\nthe\nexpression\nt\nyp\ne\nThis\niden\ntier\nis\ncalled\nthe\nsyntactic\nkeywor\nd\nor\nsimply\nkeywor\nd\nof\nthe\nmacro\nThe\nn\num\nb\ner\nof\nthe\nhdatumi\ns\nand\ntheir\nsyn\ntax\ndep\nends\non\nthe\nexpression\nt\nyp\ne\nEac\nh\ninstance\nof\na\nmacro\nis\ncalled\na\nuse\nof\nthe\nmacro\nThe\nset\nof\nrules\nthat\nsp\necies\nho\nw\na\nuse\nof\na\nmacro\nis\ntranscrib\ned\nin\nto\na\nmore\nprimitiv\ne\nexpression\nis\ncalled\nthe\ntr\nansformer\nof\nthe\nmacro\nThe\nmacro\ndenition\nfacilit\ny\nconsists\nof\nt\nw\no\nparts\n\nA\nset\nof\nexpressions\nused\nto\nestablish\nthat\ncertain\niden\ntiers\nare\nmacro\nk\neyw\nords\nasso\nciate\nthem\nwith\nmacro\ntransformers\nand\ncon\ntrol\nthe\nscop\ne\nwithin\nwhic\nh\na\nmacro\nis\ndened\nand\n\na\npattern\nlanguage\nfor\nsp\necifying\nmacro\ntransformers\nThe\nsyn\ntactic\nk\neyw\nord\nof\na\nmacro\nma\ny\nshado\nw\nv\nariable\nbindings\nand\nlo\ncal\nv\nariable\nbindings\nma\ny\nshado\nw\nk\neyw\nord\nbindings\nAll\nmacros\ndened\nusing\nthe\npattern\nlanguage\nare\nh\nygienic\nand\nreferen\ntially\ntransparen\nt\nand\nth\nus\npreserv\ne\nSc\nhemes\nlexical\nscoping\n\nRevised\n\nSc\nheme\n\nIf\na\nmacro\ntransformer\ninserts\na\nbinding\nfor\nan\niden\nti\ner\nv\nariable\nor\nk\neyw\nord\nthe\niden\ntier\nwill\nin\neect\nb\ne\nrenamed\nthroughout\nits\nscop\ne\nto\na\nv\noid\nconicts\nwith\nother\niden\ntiers\nNote\nthat\na\ndefine\nat\ntop\nlev\nel\nma\ny\nor\nma\ny\nnot\nin\ntro\nduce\na\nbinding\nsee\nsection\n\nIf\na\nmacro\ntransformer\ninserts\na\nfree\nreference\nto\nan\niden\ntier\nthe\nreference\nrefers\nto\nthe\nbinding\nthat\nw\nas\nvisible\nwhere\nthe\ntransformer\nw\nas\nsp\necied\nregardless\nof\nan\ny\nlo\ncal\nbindings\nthat\nma\ny\nsurround\nthe\nuse\nof\nthe\nmacro\n\nBinding\nconstructs\nfor\nsyn\ntactic\nk\neyw\nords\nLetsyntax\nand\nletrecsyntax\nare\nanalogous\nto\nlet\nand\nletrec\nbut\nthey\nbind\nsyn\ntactic\nk\neyw\nords\nto\nmacro\ntrans\nformers\ninstead\nof\nbinding\nv\nariables\nto\nlo\ncations\nthat\ncon\ntain\nv\nalues\nSyn\ntactic\nk\neyw\nords\nma\ny\nalso\nb\ne\nb\nound\nat\ntop\nlev\nel\nsee\nsection\n\nletsyntax\nhbindingsi\nhb\no\ndyi\n\nsyn\ntax\nSyntax\nhBindingsi\nshould\nha\nv\ne\nthe\nform\nhk\neyw\nordi\nhtransformer\nsp\neci\n\nEac\nh\nhk\neyw\nordi\nis\nan\niden\ntier\neac\nh\nhtransformer\nsp\neci\nis\nan\ninstance\nof\nsyntaxrules\nand\nhb\no\ndyi\nshould\nb\ne\na\nsequence\nof\none\nor\nmore\nexpressions\nIt\nis\nan\nerror\nfor\na\nhk\neyw\nordi\nto\napp\near\nmore\nthan\nonce\nin\nthe\nlist\nof\nk\neyw\nords\nb\neing\nb\nound\nSemantics\nThe\nhb\no\ndyi\nis\nexpanded\nin\nthe\nsyn\ntactic\nen\nvi\nronmen\nt\nobtained\nb\ny\nextending\nthe\nsyn\ntactic\nen\nvironmen\nt\nof\nthe\nletsyntax\nexpression\nwith\nmacros\nwhose\nk\neyw\nords\nare\nthe\nhk\neyw\nordi\ns\nb\nound\nto\nthe\nsp\necied\ntransformers\nEac\nh\nbinding\nof\na\nhk\neyw\nordi\nhas\nhb\no\ndyi\nas\nits\nregion\nletsyntax\nwhen\nsyntaxrules\n\nwhen\ntest\nstmt\nstmt\n\nif\ntest\nbegin\nstmt\nstmt\n\nlet\nif\nt\nwhen\nif\nset\nif\nnow\nif\n\nnow\nlet\nx\nouter\nletsyntax\nm\nsyntaxrules\n\nm\nx\nlet\nx\ninner\nm\n\nouter\nletrecsyntax\nhbindingsi\nhb\no\ndyi\n\nsyn\ntax\nSyntax\nSame\nas\nfor\nletsyntax\nSemantics\nThe\nhb\no\ndyi\nis\nexpanded\nin\nthe\nsyn\ntactic\nen\nvi\nronmen\nt\nobtained\nb\ny\nextending\nthe\nsyn\ntactic\nen\nvironmen\nt\nof\nthe\nletrecsyntax\nexpression\nwith\nmacros\nwhose\nk\ney\nw\nords\nare\nthe\nhk\neyw\nordi\ns\nb\nound\nto\nthe\nsp\necied\ntrans\nformers\nEac\nh\nbinding\nof\na\nhk\neyw\nordi\nhas\nthe\nhbindingsi\nas\nw\nell\nas\nthe\nhb\no\ndyi\nwithin\nits\nregion\nso\nthe\ntransformers\ncan\ntranscrib\ne\nexpressions\nin\nto\nuses\nof\nthe\nmacros\nin\ntro\nduced\nb\ny\nthe\nletrecsyntax\nexpression\nletrecsyntax\nmyor\nsyntaxrules\n\nmyor\nf\nmyor\ne\ne\nmyor\ne\ne\n\nlet\ntemp\ne\nif\ntemp\ntemp\nmyor\ne\n\nlet\nx\nf\ny\n\ntemp\n\nlet\nodd\nif\neven\nmyor\nx\nlet\ntemp\nif\ny\ny\n\nP\nattern\nlanguage\nA\nhtransformer\nsp\neci\nhas\nthe\nfollo\nwing\nform\nsyntaxrules\nhliteralsi\nhsyn\ntax\nrulei\n\nSyntax\nhLiteralsi\nis\na\nlist\nof\niden\ntiers\nand\neac\nh\nhsyn\ntax\nrulei\nshould\nb\ne\nof\nthe\nform\nhpatterni\nhtemplatei\n\nThe\nhpatterni\nin\na\nhsyn\ntax\nrulei\nis\na\nlist\nhpatterni\nthat\nb\negins\nwith\nthe\nk\neyw\nord\nfor\nthe\nmacro\nA\nhpatterni\nis\neither\nan\niden\ntier\na\nconstan\nt\nor\none\nof\nthe\nfollo\nwing\nhpatterni\n\nhpatterni\nhpatterni\n\nhpatterni\n\nhpatterni\n\nhpatterni\nhellipsisi\n\nhpatterni\n\nhpatterni\n\nhpatterni\nhellipsisi\n\nand\na\ntemplate\nis\neither\nan\niden\ntier\na\nconstan\nt\nor\none\nof\nthe\nfollo\nwing\nhelemen\nti\n\nhelemen\nti\nhelemen\nti\n\nhtemplatei\n\nhelemen\nti\n\nwhere\nan\nhelemen\nti\nis\na\nhtemplatei\noptionally\nfollo\nw\ned\nb\ny\nan\nhellipsisi\nand\nan\nhellipsisi\nis\nthe\niden\ntier\n\nwhic\nh\ncannot\nb\ne\nused\nas\nan\niden\ntier\nin\neither\na\ntemplate\nor\na\npattern\nSemantics\nAn\ninstance\nof\nsyntaxrules\npro\nduces\na\nnew\nmacro\ntransformer\nb\ny\nsp\necifying\na\nsequence\nof\nh\nygienic\n\nExpressions\n\nrewrite\nrules\nA\nuse\nof\na\nmacro\nwhose\nk\neyw\nord\nis\nasso\nciated\nwith\na\ntransformer\nsp\necied\nb\ny\nsyntaxrules\nis\nmatc\nhed\nagainst\nthe\npatterns\ncon\ntained\nin\nthe\nhsyn\ntax\nruleis\nb\ne\nginning\nwith\nthe\nleftmost\nhsyn\ntax\nrulei\n\nWhen\na\nmatc\nh\nis\nfound\nthe\nmacro\nuse\nis\ntranscrib\ned\nh\nygienically\naccording\nto\nthe\ntemplate\nAn\niden\ntier\nthat\napp\nears\nin\nthe\npattern\nof\na\nhsyn\ntax\nrulei\nis\na\np\nattern\nvariable\nunless\nit\nis\nthe\nk\neyw\nord\nthat\nb\negins\nthe\npattern\nis\nlisted\nin\nhliteralsi\nor\nis\nthe\niden\ntier\n\nP\nattern\nv\nariables\nmatc\nh\narbitrary\ninput\nelemen\nts\nand\nare\nused\nto\nrefer\nto\nelemen\nts\nof\nthe\ninput\nin\nthe\ntemplate\nIt\nis\nan\nerror\nfor\nthe\nsame\npattern\nv\nariable\nto\napp\near\nmore\nthan\nonce\nin\na\nhpatterni\nThe\nk\neyw\nord\nat\nthe\nb\neginning\nof\nthe\npattern\nin\na\nhsyn\ntax\nrulei\nis\nnot\nin\nv\nolv\ned\nin\nthe\nmatc\nhing\nand\nis\nnot\nconsidered\na\npattern\nv\nariable\nor\nliteral\niden\ntier\nR\nationale\nThe\nscop\ne\nof\nthe\nk\neyw\nord\nis\ndetermined\nb\ny\nthe\nexpression\nor\nsyn\ntax\ndenition\nthat\nbinds\nit\nto\nthe\nasso\nciated\nmacro\ntransformer\nIf\nthe\nk\neyw\nord\nw\nere\na\npattern\nv\nariable\nor\nliteral\niden\ntier\nthen\nthe\ntemplate\nthat\nfollo\nws\nthe\npattern\nw\nould\nb\ne\nwithin\nits\nscop\ne\nregardless\nof\nwhether\nthe\nk\neyw\nord\nw\nere\nb\nound\nb\ny\nletsyntax\nor\nb\ny\nletrecsyntax\nIden\ntiers\nthat\napp\near\nin\nhliteralsi\nare\nin\nterpreted\nas\nliteral\niden\ntiers\nto\nb\ne\nmatc\nhed\nagainst\ncorresp\nonding\nsubforms\nof\nthe\ninput\nA\nsubform\nin\nthe\ninput\nmatc\nhes\na\nliteral\niden\ntier\nif\nand\nonly\nif\nit\nis\nan\niden\ntier\nand\neither\nb\noth\nits\no\nccurrence\nin\nthe\nmacro\nexpression\nand\nits\no\nccurrence\nin\nthe\nmacro\ndenition\nha\nv\ne\nthe\nsame\nlexical\nbinding\nor\nthe\nt\nw\no\niden\ntiers\nare\nequal\nand\nb\noth\nha\nv\ne\nno\nlexical\nbinding\nA\nsubpattern\nfollo\nw\ned\nb\ny\n\ncan\nmatc\nh\nzero\nor\nmore\nel\nemen\nts\nof\nthe\ninput\nIt\nis\nan\nerror\nfor\n\nto\napp\near\nin\nhliteralsi\nWithin\na\npattern\nthe\niden\ntier\n\nm\nust\nfollo\nw\nthe\nlast\nelemen\nt\nof\na\nnonempt\ny\nsequence\nof\nsubpatterns\nMore\nformally\n\nan\ninput\nform\nF\nmatc\nhes\na\npattern\nP\nif\nand\nonly\nif\n\nP\nis\na\nnonliteral\niden\ntier\nor\n\nP\nis\na\nliteral\niden\ntier\nand\nF\nis\nan\niden\ntier\nwith\nthe\nsame\nbinding\nor\n\nP\nis\na\nlist\nP\n\nP\nn\n\nand\nF\nis\na\nlist\nof\nn\nforms\nthat\nmatc\nh\nP\n\nthrough\nP\nn\n\nresp\nectiv\nely\nor\n\nP\nis\nan\nimprop\ner\nlist\nP\n\nP\n\nP\nn\n\nP\nn\n\nand\nF\nis\na\nlist\nor\nimprop\ner\nlist\nof\nn\nor\nmore\nforms\nthat\nmatc\nh\nP\n\nthrough\nP\nn\n\nresp\nectiv\nely\n\nand\nwhose\nnth\ncdr\nmatc\nhes\nP\nn\n\nor\n\nP\nis\nof\nthe\nform\nP\n\nP\nn\nP\nn\nhellipsisi\n\nwhere\nhellipsisi\nis\nthe\niden\ntier\n\nand\nF\nis\na\nprop\ner\nlist\nof\nat\nleast\nn\nforms\nthe\nrst\nn\nof\nwhic\nh\nmatc\nh\nP\n\nthrough\nP\nn\n\nresp\nectiv\nely\n\nand\neac\nh\nremaining\nelemen\nt\nof\nF\nmatc\nhes\nP\nn\n\nor\n\nP\nis\na\nv\nector\nof\nthe\nform\nP\n\nP\nn\n\nand\nF\nis\na\nv\nector\nof\nn\nforms\nthat\nmatc\nh\nP\n\nthrough\nP\nn\n\nor\n\nP\nis\nof\nthe\nform\nP\n\nP\nn\nP\nn\nhellipsisi\nwhere\nhellipsisi\nis\nthe\niden\ntier\n\nand\nF\nis\na\nv\nector\nof\nn\nor\nmore\nforms\nthe\nrst\nn\nof\nwhic\nh\nmatc\nh\nP\n\nthrough\nP\nn\n\nresp\nectiv\nely\n\nand\neac\nh\nremaining\nelemen\nt\nof\nF\nmatc\nhes\nP\nn\n\nor\n\nP\nis\na\ndatum\nand\nF\nis\nequal\nto\nP\nin\nthe\nsense\nof\nthe\nequal\npro\ncedure\nIt\nis\nan\nerror\nto\nuse\na\nmacro\nk\neyw\nord\nwithin\nthe\nscop\ne\nof\nits\nbinding\nin\nan\nexpression\nthat\ndo\nes\nnot\nmatc\nh\nan\ny\nof\nthe\npatterns\nWhen\na\nmacro\nuse\nis\ntranscrib\ned\naccording\nto\nthe\ntemplate\nof\nthe\nmatc\nhing\nhsyn\ntax\nrulei\npattern\nv\nariables\nthat\no\nccur\nin\nthe\ntemplate\nare\nreplaced\nb\ny\nthe\nsubforms\nthey\nmatc\nh\nin\nthe\ninput\nP\nattern\nv\nariables\nthat\no\nccur\nin\nsubpatterns\nfollo\nw\ned\nb\ny\none\nor\nmore\ninstances\nof\nthe\niden\ntier\n\nare\nallo\nw\ned\nonly\nin\nsubtemplates\nthat\nare\nfollo\nw\ned\nb\ny\nas\nman\ny\ninstances\nof\n\nThey\nare\nreplaced\nin\nthe\noutput\nb\ny\nall\nof\nthe\nsubforms\nthey\nmatc\nh\nin\nthe\ninput\ndistributed\nas\nindicated\nIt\nis\nan\nerror\nif\nthe\noutput\ncannot\nb\ne\nbuilt\nup\nas\nsp\necied\nIden\ntiers\nthat\napp\near\nin\nthe\ntemplate\nbut\nare\nnot\npattern\nv\nariables\nor\nthe\niden\ntier\n\nare\ninserted\nin\nto\nthe\noutput\nas\nliteral\niden\ntiers\nIf\na\nliteral\niden\ntier\nis\ninserted\nas\na\nfree\niden\ntier\nthen\nit\nrefers\nto\nthe\nbinding\nof\nthat\niden\ntier\nwithin\nwhose\nscop\ne\nthe\ninstance\nof\nsyntaxrules\napp\nears\nIf\na\nliteral\niden\ntier\nis\ninserted\nas\na\nb\nound\niden\ntier\nthen\nit\nis\nin\neect\nrenamed\nto\nprev\nen\nt\ninadv\nerten\nt\ncaptures\nof\nfree\niden\ntiers\nAs\nan\nexample\nif\nlet\nand\ncond\nare\ndened\nas\nin\nsection\n\nthen\nthey\nare\nh\nygienic\nas\nrequired\nand\nthe\nfollo\nwing\nis\nnot\nan\nerror\nlet\n\nf\ncond\nt\n\nok\n\nok\nThe\nmacro\ntransformer\nfor\ncond\nrecognizes\n\nas\na\nlo\ncal\nv\nariable\nand\nhence\nan\nexpression\nand\nnot\nas\nthe\ntoplev\nel\niden\ntier\n\nwhic\nh\nthe\nmacro\ntransformer\ntreats\nas\na\nsyn\ntactic\nk\neyw\nord\nTh\nus\nthe\nexample\nexpands\nin\nto\nlet\n\nf\nif\nt\nbegin\n\nok\ninstead\nof\nlet\n\nf\nlet\ntemp\nt\nif\ntemp\nok\ntemp\nwhic\nh\nw\nould\nresult\nin\nan\nin\nv\nalid\npro\ncedure\ncall\n\nRevised\n\nSc\nheme\n\nProgram\nstructure\n\nPrograms\nA\nSc\nheme\nprogram\nconsists\nof\na\nsequence\nof\nexpressions\ndenitions\nand\nsyn\ntax\ndenitions\nExpressions\nare\nde\nscrib\ned\nin\nc\nhapter\n\ndenitions\nand\nsyn\ntax\ndenitions\nare\nthe\nsub\nject\nof\nthe\nrest\nof\nthe\npresen\nt\nc\nhapter\nPrograms\nare\nt\nypically\nstored\nin\nles\nor\nen\ntered\nin\nter\nactiv\nely\nto\na\nrunning\nSc\nheme\nsystem\nalthough\nother\nparadigms\nare\np\nossible\nquestions\nof\nuser\nin\nterface\nlie\nout\nside\nthe\nscop\ne\nof\nthis\nrep\nort\nIndeed\nSc\nheme\nw\nould\nstill\nb\ne\nuseful\nas\na\nnotation\nfor\nexpressing\ncomputational\nmetho\nds\nev\nen\nin\nthe\nabsence\nof\na\nmec\nhanical\nimplemen\ntation\nDenitions\nand\nsyn\ntax\ndenitions\no\nccurring\nat\nthe\ntop\nlev\nel\nof\na\nprogram\ncan\nb\ne\nin\nterpreted\ndeclarativ\nely\n\nThey\ncause\nbindings\nto\nb\ne\ncreated\nin\nthe\ntop\nlev\nel\nen\nvironmen\nt\nor\nmo\nd\nify\nthe\nv\nalue\nof\nexisting\ntoplev\nel\nbindings\nExpressions\no\nccurring\nat\nthe\ntop\nlev\nel\nof\na\nprogram\nare\nin\nterpreted\nim\np\nerativ\nely\nthey\nare\nexecuted\nin\norder\nwhen\nthe\nprogram\nis\nin\nv\nok\ned\nor\nloaded\nand\nt\nypically\np\nerform\nsome\nkind\nof\ninitialization\nA\nt\nthe\ntop\nlev\nel\nof\na\nprogram\nbegin\nhform\n\ni\n\nis\nequiv\nalen\nt\nto\nthe\nsequence\nof\nexpressions\ndenitions\nand\nsyn\ntax\ndenitions\nthat\nform\nthe\nb\no\ndy\nof\nthe\nbegin\n\nDenitions\nDenitions\nare\nv\nalid\nin\nsome\nbut\nnot\nall\ncon\ntexts\nwhere\nexpressions\nare\nallo\nw\ned\nThey\nare\nv\nalid\nonly\nat\nthe\ntop\nlev\nel\nof\na\nhprogrami\nand\nat\nthe\nb\neginning\nof\na\nhb\no\ndyi\n\nA\ndenition\nshould\nha\nv\ne\none\nof\nthe\nfollo\nwing\nforms\n\ndefine\nhv\nariablei\nhexpressioni\n\ndefine\nhv\nariablei\nhformalsi\nhb\no\ndyi\n\nhF\normalsi\nshould\nb\ne\neither\na\nsequence\nof\nzero\nor\nmore\nv\nariables\nor\na\nsequence\nof\none\nor\nmore\nv\nariables\nfol\nlo\nw\ned\nb\ny\na\nspacedelimited\np\nerio\nd\nand\nanother\nv\nari\nable\nas\nin\na\nlam\nb\nda\nexpression\nThis\nform\nis\nequiv\nalen\nt\nto\ndefine\nhv\nariablei\nlambda\nhformalsi\n\nhb\no\ndyi\n\ndefine\nhv\nariablei\n\nhformali\n\nhb\no\ndyi\n\nhF\normali\nshould\nb\ne\na\nsingle\nv\nariable\nThis\nform\nis\nequiv\nalen\nt\nto\ndefine\nhv\nariablei\nlambda\nhformali\nhb\no\ndyi\n\nT\nop\nlev\nel\nde nitions\nA\nt\nthe\ntop\nlev\nel\nof\na\nprogram\na\ndenition\ndefine\nhv\nariablei\nhexpressioni\nhas\nessen\ntially\nthe\nsame\neect\nas\nthe\nassignmen\nt\nexpres\nsion\nset\nhv\nariablei\nhexpressioni\nif\nhv\nariablei\nis\nb\nound\nIf\nhv\nariablei\nis\nnot\nb\nound\nho\nw\nev\ner\nthen\nthe\ndenition\nwill\nbind\nhv\nariablei\nto\na\nnew\nlo\ncation\nb\nefore\np\nerforming\nthe\nassignmen\nt\nwhereas\nit\nw\nould\nb\ne\nan\nerror\nto\np\nerform\na\nset\non\nan\nun\nb\nound\nv\nariable\ndefine\nadd\nlambda\nx\n\nx\n\nadd\n\ndefine\nfirst\ncar\nfirst\n\nSome\nimplemen\ntations\nof\nSc\nheme\nuse\nan\ninitial\nen\nviron\nmen\nt\nin\nwhic\nh\nall\np\nossible\nv\nariables\nare\nb\nound\nto\nlo\ncations\nmost\nof\nwhic\nh\ncon\ntain\nundened\nv\nalues\nT\nop\nlev\nel\ndeni\ntions\nin\nsuc\nh\nan\nimplemen\ntation\nare\ntruly\nequiv\nalen\nt\nto\nassignmen\nts\n\nIn\nternal\nde nitions\nDenitions\nma\ny\no\nccur\nat\nthe\nb\neginning\nof\na\nhb\no\ndyi\nthat\nis\nthe\nb\no\ndy\nof\na\nlambda\nlet\nlet\nletrec\nletsyntax\nor\nletrecsyntax\nexpression\nor\nthat\nof\na\ndenition\nof\nan\nappropriate\nform\nSuc\nh\ndenitions\nare\nkno\nwn\nas\ninternal\ndenitions\nas\nopp\nosed\nto\nthe\ntop\nlev\nel\ndenitions\ndescrib\ned\nab\no\nv\ne\nThe\nv\nariable\ndened\nb\ny\nan\nin\nternal\ndenition\nis\nlo\ncal\nto\nthe\nhb\no\ndyi\n\nThat\nis\nhv\nariablei\nis\nb\nound\nrather\nthan\nassigned\nand\nthe\nregion\nof\nthe\nbinding\nis\nthe\nen\ntire\nhb\no\ndyi\n\nF\nor\nexample\nlet\nx\n\ndefine\nfoo\nlambda\ny\nbar\nx\ny\ndefine\nbar\nlambda\na\nb\n\na\nb\na\nfoo\n\nx\n\nA\nhb\no\ndyi\ncon\ntaining\nin\nternal\ndenitions\ncan\nalw\na\nys\nb\ne\ncon\nv\nerted\nin\nto\na\ncompletely\nequiv\nalen\nt\nletrec\nexpression\nF\nor\nexample\nthe\nlet\nexpression\nin\nthe\nab\no\nv\ne\nexample\nis\nequiv\nalen\nt\nto\nlet\nx\n\nletrec\nfoo\nlambda\ny\nbar\nx\ny\nbar\nlambda\na\nb\n\na\nb\na\nfoo\n\nx\n\nJust\nas\nfor\nthe\nequiv\nalen\nt\nletrec\nexpression\nit\nm\nust\nb\ne\np\nossible\nto\nev\naluate\neac\nh\nhexpressioni\nof\nev\nery\nin\nternal\ndef\ninition\nin\na\nhb\no\ndyi\nwithout\nassigning\nor\nreferring\nto\nthe\nv\nalue\nof\nan\ny\nhv\nariablei\nb\neing\ndened\nWherev\ner\nan\nin\nternal\ndenition\nma\ny\no\nccur\nbegin\nhdenition\n\ni\n\nis\nequiv\nalen\nt\nto\nthe\nsequence\nof\ndeni\ntions\nthat\nform\nthe\nb\no\ndy\nof\nthe\nbegin\n\nStandard\npro\ncedures\n\nSyn\ntax\ndenitions\nSyn\ntax\ndenitions\nare\nv\nalid\nonly\nat\nthe\ntop\nlev\nel\nof\na\nhprogrami\n\nThey\nha\nv\ne\nthe\nfollo\nwing\nform\ndefinesyntax\nhk\neyw\nordi\nhtransformer\nsp\neci\nhKeyw\nordi\nis\nan\niden\ntier\nand\nthe\nhtransformer\nsp\neci\nshould\nb\ne\nan\ninstance\nof\nsyntaxrules\nThe\ntoplev\nel\nsyn\ntactic\nen\nvironmen\nt\nis\nextended\nb\ny\nbinding\nthe\nhk\neyw\nordi\nto\nthe\nsp\necied\ntransformer\nThere\nis\nno\ndefinesyntax\nanalogue\nof\nin\nternal\ndeni\ntions\nAlthough\nmacros\nma\ny\nexpand\nin\nto\ndenitions\nand\nsyn\ntax\ndenitions\nin\nan\ny\ncon\ntext\nthat\np\nermits\nthem\nit\nis\nan\nerror\nfor\na\ndenition\nor\nsyn\ntax\ndenition\nto\nshado\nw\na\nsyn\ntactic\nk\neyw\nord\nwhose\nmeaning\nis\nneeded\nto\ndetermine\nwhether\nsome\nform\nin\nthe\ngroup\nof\nforms\nthat\ncon\ntains\nthe\nshad\no\nwing\ndenition\nis\nin\nfact\na\ndenition\nor\nfor\nin\nternal\ndef\ninitions\nis\nneeded\nto\ndetermine\nthe\nb\noundary\nb\net\nw\neen\nthe\ngroup\nand\nthe\nexpressions\nthat\nfollo\nw\nthe\ngroup\nF\nor\nex\nample\nthe\nfollo\nwing\nare\nerrors\ndefine\ndefine\n\nbegin\ndefine\nbegin\nlist\nletsyntax\nfoo\nsyntaxrules\n\nfoo\nproc\nargs\n\nbody\n\ndefine\nproc\nlambda\nargs\n\nbody\n\nlet\nx\n\nfoo\nplus\nx\ny\n\nx\ny\ndefine\nfoo\nx\nplus\nfoo\nx\n\nStandard\npro\ncedures\nThis\nc\nhapter\ndescrib\nes\nSc\nhemes\nbuiltin\npro\ncedures\nThe\ninitial\nor\ntop\nlev\nel\nSc\nheme\nen\nvironmen\nt\nstarts\nout\nwith\na\nn\num\nb\ner\nof\nv\nariables\nb\nound\nto\nlo\ncations\ncon\ntaining\nuseful\nv\nalues\nmost\nof\nwhic\nh\nare\nprimitiv\ne\npro\ncedures\nthat\nma\nnipulate\ndata\nF\nor\nexample\nthe\nv\nariable\nabs\nis\nb\nound\nto\na\nlo\ncation\ninitially\ncon\ntaining\na\npro\ncedure\nof\none\nargu\nmen\nt\nthat\ncomputes\nthe\nabsolute\nv\nalue\nof\na\nn\num\nb\ner\nand\nthe\nv\nariable\n\nis\nb\nound\nto\na\npro\ncedure\nthat\ncomputes\nsums\nBuiltin\npro\ncedures\nthat\ncan\neasily\nb\ne\nwritten\nin\nterms\nof\nother\nbuiltin\npro\ncedures\nare\niden\ntied\nas\nlibrary\npro\nce\ndures\nA\nprogram\nma\ny\nuse\na\ntoplev\nel\ndenition\nto\nbind\nan\ny\nv\nari\nable\nIt\nma\ny\nsubsequen\ntly\nalter\nan\ny\nsuc\nh\nbinding\nb\ny\nan\nassignmen\nt\nsee\n\nThese\nop\nerations\ndo\nnot\nmo\ndify\nthe\nb\neha\nvior\nof\nSc\nhemes\nbuiltin\npro\ncedures\nAltering\nan\ny\ntoplev\nel\nbinding\nthat\nhas\nnot\nb\neen\nin\ntro\nduced\nb\ny\na\ndeni\ntion\nhas\nan\nunsp\necied\neect\non\nthe\nb\neha\nvior\nof\nthe\nbuiltin\npro\ncedures\n\nEquiv\nalence\npredicates\nA\npr\ne\ndic\nate\nis\na\npro\ncedure\nthat\nalw\na\nys\nreturns\na\nb\no\nolean\nv\nalue\nt\nor\nf\nAn\ne\nquivalenc\ne\npr\ne\ndic\nate\nis\nthe\ncompu\ntational\nanalogue\nof\na\nmathematical\nequiv\nalence\nrelation\nit\nis\nsymmetric\nreexiv\ne\nand\ntransitiv\ne\nOf\nthe\nequiv\na\nlence\npredicates\ndescrib\ned\nin\nthis\nsection\neq\nis\nthe\nnest\nor\nmost\ndiscriminating\nand\nequal\nis\nthe\ncoarsest\nEqv\nis\nsligh\ntly\nless\ndiscriminating\nthan\neq\neqv\nobj\n\nobj\n\npro\ncedure\nThe\neqv\npro\ncedure\ndenes\na\nuseful\nequiv\nalence\nrelation\non\nob\njects\nBriey\n\nit\nreturns\nt\nif\nobj\n\nand\nobj\n\nshould\nnormally\nb\ne\nregarded\nas\nthe\nsame\nob\nject\nThis\nrelation\nis\nleft\nsligh\ntly\nop\nen\nto\nin\nterpretation\nbut\nthe\nfollo\nwing\npar\ntial\nsp\necication\nof\neqv\nholds\nfor\nall\nimplemen\ntations\nof\nSc\nheme\nThe\neqv\npro\ncedure\nreturns\nt\nif\n\nobj\n\nand\nobj\n\nare\nb\noth\nt\nor\nb\noth\nf\n\nobj\n\nand\nobj\n\nare\nb\noth\nsym\nb\nols\nand\nstring\nsymbol string\nobj\nsymbol string\nobj\n\nt\nNote\nThis\nassumes\nthat\nneither\nobj\n\nnor\nobj\n\nis\nan\nun\nin\nterned\nsym\nb\nol\nas\nalluded\nto\nin\nsection\n\nThis\nre\np\nort\ndo\nes\nnot\npresume\nto\nsp\necify\nthe\nb\neha\nvior\nof\neqv\non\nimplemen\ntationdep\nenden\nt\nextensions\n\nobj\n\nand\nobj\n\nare\nb\noth\nn\num\nb\ners\nare\nn\numerically\nequal\nsee\n\nsection\n\nand\nare\neither\nb\noth\nexact\nor\nb\noth\ninexact\n\nobj\n\nand\nobj\n\nare\nb\noth\nc\nharacters\nand\nare\nthe\nsame\nc\nharacter\naccording\nto\nthe\nchar\npro\ncedure\nsec\ntion\n\nb\noth\nobj\n\nand\nobj\n\nare\nthe\nempt\ny\nlist\n\nobj\n\nand\nobj\n\nare\npairs\nv\nectors\nor\nstrings\nthat\ndenote\nthe\nsame\nlo\ncations\nin\nthe\nstore\nsection\n\nobj\n\nand\nobj\n\nare\npro\ncedures\nwhose\nlo\ncation\ntags\nare\nequal\nsection\n\nThe\neqv\npro\ncedure\nreturns\nf\nif\n\nobj\n\nand\nobj\n\nare\nof\ndieren\nt\nt\nyp\nes\nsection\n\nRevised\n\nSc\nheme\n\none\nof\nobj\n\nand\nobj\n\nis\nt\nbut\nthe\nother\nis\nf\n\nobj\n\nand\nobj\n\nare\nsym\nb\nols\nbut\nstring\nsymbol string\nobj\n\nsymbol string\nobj\n\nf\n\none\nof\nobj\n\nand\nobj\n\nis\nan\nexact\nn\num\nb\ner\nbut\nthe\nother\nis\nan\ninexact\nn\num\nb\ner\n\nobj\n\nand\nobj\n\nare\nn\num\nb\ners\nfor\nwhic\nh\nthe\n\npro\ncedure\nreturns\nf\n\nobj\n\nand\nobj\n\nare\nc\nharacters\nfor\nwhic\nh\nthe\nchar\npro\ncedure\nreturns\nf\n\none\nof\nobj\n\nand\nobj\n\nis\nthe\nempt\ny\nlist\nbut\nthe\nother\nis\nnot\n\nobj\n\nand\nobj\n\nare\npairs\nv\nectors\nor\nstrings\nthat\ndenote\ndistinct\nlo\ncations\n\nobj\n\nand\nobj\n\nare\npro\ncedures\nthat\nw\nould\nb\neha\nv\ne\ndier\nen\ntly\nreturn\ndieren\nt\nv\nalues\nor\nha\nv\ne\ndieren\nt\nside\neects\nfor\nsome\nargumen\nts\neqv\na\na\n\nt\neqv\na\nb\n\nf\neqv\n\nt\neqv\n\nt\neqv\n\nt\neqv\ncons\n\ncons\n\nf\neqv\nlambda\n\nlambda\n\nf\neqv\nf\nnil\n\nf\nlet\np\nlambda\nx\nx\neqv\np\np\n\nt\nThe\nfollo\nwing\nexamples\nillustrate\ncases\nin\nwhic\nh\nthe\nab\no\nv\ne\nrules\ndo\nnot\nfully\nsp\necify\nthe\nb\neha\nvior\nof\neqv\nAll\nthat\ncan\nb\ne\nsaid\nab\nout\nsuc\nh\ncases\nis\nthat\nthe\nv\nalue\nreturned\nb\ny\neqv\nm\nust\nb\ne\na\nb\no\nolean\neqv\n\nunsp\ne\ncie\nd\neqv\n\nunsp\ne\ncie\nd\neqv\nlambda\nx\nx\nlambda\nx\nx\n\nunsp\ne\ncie\nd\neqv\nlambda\nx\nx\nlambda\ny\ny\n\nunsp\ne\ncie\nd\nThe\nnext\nset\nof\nexamples\nsho\nws\nthe\nuse\nof\neqv\nwith\npro\ncedures\nthat\nha\nv\ne\nlo\ncal\nstate\nGencounter\nm\nust\nreturn\na\ndistinct\npro\ncedure\nev\nery\ntime\nsince\neac\nh\npro\ncedure\nhas\nits\no\nwn\nin\nternal\ncoun\nter\nGenloser\nho\nw\nev\ner\nreturns\nequiv\nalen\nt\npro\ncedures\neac\nh\ntime\nsince\nthe\nlo\ncal\nstate\ndo\nes\nnot\naect\nthe\nv\nalue\nor\nside\neects\nof\nthe\npro\ncedures\ndefine\ngencounter\nlambda\n\nlet\nn\n\nlambda\n\nset\nn\n\nn\n\nn\nlet\ng\ngencounter\neqv\ng\ng\n\nt\neqv\ngencounter\ngencounter\n\nf\ndefine\ngenloser\nlambda\n\nlet\nn\n\nlambda\n\nset\nn\n\nn\n\nlet\ng\ngenloser\neqv\ng\ng\n\nt\neqv\ngenloser\ngenloser\n\nunsp\ne\ncie\nd\nletrec\nf\nlambda\n\nif\neqv\nf\ng\nboth\nf\ng\nlambda\n\nif\neqv\nf\ng\nboth\ng\neqv\nf\ng\n\nunsp\ne\ncie\nd\nletrec\nf\nlambda\n\nif\neqv\nf\ng\nf\nboth\ng\nlambda\n\nif\neqv\nf\ng\ng\nboth\neqv\nf\ng\n\nf\nSince\nit\nis\nan\nerror\nto\nmo\ndify\nconstan\nt\nob\njects\nthose\nre\nturned\nb\ny\nliteral\nexpressions\nimplemen\ntations\nare\np\ner\nmitted\nthough\nnot\nrequired\nto\nshare\nstructure\nb\net\nw\neen\nconstan\nts\nwhere\nappropriate\nTh\nus\nthe\nv\nalue\nof\neqv\non\nconstan\nts\nis\nsometimes\nimplemen\ntationdep\nenden\nt\neqv\na\na\n\nunsp\ne\ncie\nd\neqv\na\na\n\nunsp\ne\ncie\nd\neqv\nb\ncdr\na\nb\n\nunsp\ne\ncie\nd\nlet\nx\na\neqv\nx\nx\n\nt\nR\nationale\nThe\nab\no\nv\ne\ndenition\nof\neqv\nallo\nws\nimplemen\nta\ntions\nlatitude\nin\ntheir\ntreatmen\nt\nof\npro\ncedures\nand\nliterals\nim\nplemen\ntations\nare\nfree\neither\nto\ndetect\nor\nto\nfail\nto\ndetect\nthat\nt\nw\no\npro\ncedures\nor\nt\nw\no\nliterals\nare\nequiv\nalen\nt\nto\neac\nh\nother\nand\ncan\ndecide\nwhether\nor\nnot\nto\nmerge\nrepresen\ntations\nof\nequiv\nalen\nt\nob\njects\nb\ny\nusing\nthe\nsame\np\noin\nter\nor\nbit\npattern\nto\nrepresen\nt\nb\noth\neq\nobj\n\nobj\n\npro\ncedure\nEq\nis\nsimilar\nto\neqv\nexcept\nthat\nin\nsome\ncases\nit\nis\ncapable\nof\ndiscerning\ndistinctions\nner\nthan\nthose\ndetectable\nb\ny\neqv\nEq\nand\neqv\nare\nguaran\nteed\nto\nha\nv\ne\nthe\nsame\nb\neha\nvior\non\nsym\nb\nols\nb\no\noleans\nthe\nempt\ny\nlist\npairs\npro\ncedures\nand\nnonempt\ny\nstrings\nand\nv\nectors\nEq s\nb\neha\nvior\non\nn\num\nb\ners\nand\nc\nharacters\nis\nimplemen\ntationdep\nenden\nt\nbut\nit\nwill\nal\nw\na\nys\nreturn\neither\ntrue\nor\nfalse\nand\nwill\nreturn\ntrue\nonly\nwhen\neqv\nw\nould\nalso\nreturn\ntrue\nEq\nma\ny\nalso\nb\neha\nv\ne\ndieren\ntly\nfrom\neqv\non\nempt\ny\nv\nectors\nand\nempt\ny\nstrings\n\nStandard\npro\ncedures\n\neq\na\na\n\nt\neq\na\na\n\nunsp\ne\ncie\nd\neq\nlist\na\nlist\na\n\nf\neq\na\na\n\nunsp\ne\ncie\nd\neq\n\nunsp\ne\ncie\nd\neq\n\nt\neq\n\nunsp\ne\ncie\nd\neq\n%A\n%A\n\nunsp\ne\ncie\nd\neq\ncar\ncar\n\nt\nlet\nn\n\neq\nn\nn\n\nunsp\ne\ncie\nd\nlet\nx\na\neq\nx\nx\n\nt\nlet\nx\n\neq\nx\nx\n\nt\nlet\np\nlambda\nx\nx\neq\np\np\n\nt\nR\nationale\nIt\nwill\nusually\nb\ne\np\nossible\nto\nimplemen\nt\neq\nm\nuc\nh\nmore\necien\ntly\nthan\neqv\nfor\nexample\nas\na\nsimple\np\noin\nter\ncom\nparison\ninstead\nof\nas\nsome\nmore\ncomplicated\nop\neration\nOne\nreason\nis\nthat\nit\nma\ny\nnot\nb\ne\np\nossible\nto\ncompute\neqv\nof\nt\nw\no\nn\num\nb\ners\nin\nconstan\nt\ntime\nwhereas\neq\nimplemen\nted\nas\np\noin\nter\ncomparison\nwill\nalw\na\nys\nnish\nin\nconstan\nt\ntime\nEq\nma\ny\nb\ne\nused\nlik\ne\neqv\nin\napplications\nusing\npro\ncedures\nto\nimplemen\nt\nob\njects\nwith\nstate\nsince\nit\nob\neys\nthe\nsame\nconstrain\nts\nas\neqv\nequal\nobj\n\nobj\n\nlibrary\npro\ncedure\nEqual\nrecursiv\nely\ncompares\nthe\ncon\nten\nts\nof\npairs\nv\nectors\nand\nstrings\napplying\neqv\non\nother\nob\njects\nsuc\nh\nas\nn\num\nb\ners\nand\nsym\nb\nols\nA\nrule\nof\nth\num\nb\nis\nthat\nob\njects\nare\ngenerally\nequal\nif\nthey\nprin\nt\nthe\nsame\nEqual\nma\ny\nfail\nto\nterminate\nif\nits\nargumen\nts\nare\ncircular\ndata\nstructures\nequal\na\na\n\nt\nequal\na\na\n\nt\nequal\na\nb\nc\na\nb\nc\n\nt\nequal\nabc\nabc\n\nt\nequal\n\nt\nequal\nmakevector\n\na\nmakevector\n\na\n\nt\nequal\nlambda\nx\nx\nlambda\ny\ny\n\nunsp\ne\ncie\nd\n\nNum\nb\ners\nNumerical\ncomputation\nhas\ntraditionally\nb\neen\nneglected\nb\ny\nthe\nLisp\ncomm\nunit\ny\n\nUn\ntil\nCommon\nLisp\nthere\nw\nas\nno\ncarefully\nthough\nt\nout\nstrategy\nfor\norganizing\nn\numerical\ncomputation\nand\nwith\nthe\nexception\nof\nthe\nMacLisp\nsys\ntem\n\nlittle\neort\nw\nas\nmade\nto\nexecute\nn\numerical\nco\nde\necien\ntly\n\nThis\nrep\nort\nrecognizes\nthe\nexcellen\nt\nw\nork\nof\nthe\nCommon\nLisp\ncommittee\nand\naccepts\nman\ny\nof\ntheir\nrec\nommendations\nIn\nsome\nw\na\nys\nthis\nrep\nort\nsimplies\nand\ngeneralizes\ntheir\nprop\nosals\nin\na\nmanner\nconsisten\nt\nwith\nthe\npurp\noses\nof\nSc\nheme\nIt\nis\nimp\nortan\nt\nto\ndistinguish\nb\net\nw\neen\nthe\nmathemati\ncal\nn\num\nb\ners\nthe\nSc\nheme\nn\num\nb\ners\nthat\nattempt\nto\nmo\ndel\nthem\nthe\nmac\nhine\nrepresen\ntations\nused\nto\nimplemen\nt\nthe\nSc\nheme\nn\num\nb\ners\nand\nnotations\nused\nto\nwrite\nn\num\nb\ners\nThis\nrep\nort\nuses\nthe\nt\nyp\nes\nnumb\ner\nc\nomplex\nr\ne\nal\nr\national\nand\ninte\nger\nto\nrefer\nto\nb\noth\nmathematical\nn\num\nb\ners\nand\nSc\nheme\nn\num\nb\ners\nMac\nhine\nrepresen\ntations\nsuc\nh\nas\nxed\np\noin\nt\nand\noating\np\noin\nt\nare\nreferred\nto\nb\ny\nnames\nsuc\nh\nas\nxnum\nand\nonum\n\nNumerical\nt\nyp\nes\nMathematically\n\nn\num\nb\ners\nma\ny\nb\ne\narranged\nin\nto\na\nto\nw\ner\nof\nsubt\nyp\nes\nin\nwhic\nh\neac\nh\nlev\nel\nis\na\nsubset\nof\nthe\nlev\nel\nab\no\nv\ne\nit\nn\num\nb\ner\ncomplex\nreal\nrational\nin\nteger\nF\nor\nexample\n\nis\nan\nin\nteger\nTherefore\n\nis\nalso\na\nrational\na\nreal\nand\na\ncomplex\nThe\nsame\nis\ntrue\nof\nthe\nSc\nheme\nn\num\nb\ners\nthat\nmo\ndel\n\nF\nor\nSc\nheme\nn\num\nb\ners\nthese\nt\nyp\nes\nare\ndened\nb\ny\nthe\npredicates\nnumber\ncomplex\nreal\nrational\nand\ninteger\nThere\nis\nno\nsimple\nrelationship\nb\net\nw\neen\na\nn\num\nb\ners\nt\nyp\ne\nand\nits\nrepresen\ntation\ninside\na\ncomputer\nAlthough\nmost\nimplemen\ntations\nof\nSc\nheme\nwill\noer\nat\nleast\nt\nw\no\ndieren\nt\nrepresen\ntations\nof\n\nthese\ndieren\nt\nrepresen\ntations\ndenote\nthe\nsame\nin\nteger\nSc\nhemes\nn\numerical\nop\nerations\ntreat\nn\num\nb\ners\nas\nabstract\ndata\nas\nindep\nenden\nt\nof\ntheir\nrepresen\ntation\nas\np\nossible\nAlthough\nan\nimplemen\ntation\nof\nSc\nheme\nma\ny\nuse\nxn\num\non\num\nand\np\nerhaps\nother\nrepresen\ntations\nfor\nn\num\nb\ners\nthis\nshould\nnot\nb\ne\napparen\nt\nto\na\ncasual\nprogrammer\nwriting\nsimple\nprograms\nIt\nis\nnecessary\n\nho\nw\nev\ner\nto\ndistinguish\nb\net\nw\neen\nn\num\nb\ners\nthat\nare\nrepresen\nted\nexactly\nand\nthose\nthat\nma\ny\nnot\nb\ne\nF\nor\nexample\nindexes\nin\nto\ndata\nstructures\nm\nust\nb\ne\nkno\nwn\nexactly\n\nas\nm\nust\nsome\np\nolynomial\nco\necien\nts\nin\na\nsym\nb\nolic\nalgebra\nsystem\nOn\nthe\nother\nhand\nthe\nresults\nof\nmeasure\nmen\nts\nare\ninheren\ntly\ninexact\nand\nirrational\nn\num\nb\ners\nma\ny\nb\ne\nappro\nximated\nb\ny\nrational\nand\ntherefore\ninexact\nappro\nx\nimations\nIn\norder\nto\ncatc\nh\nuses\nof\ninexact\nn\num\nb\ners\nwhere\nexact\nn\num\nb\ners\nare\nrequired\nSc\nheme\nexplicitly\ndistinguishes\nexact\nfrom\ninexact\nn\num\nb\ners\nThis\ndistinction\nis\northogonal\nto\nthe\ndimension\nof\nt\nyp\ne\n\nExactness\nSc\nheme\nn\num\nb\ners\nare\neither\nexact\nor\ninexact\nA\nn\num\nb\ner\nis\nexact\nif\nit\nw\nas\nwritten\nas\nan\nexact\nconstan\nt\nor\nw\nas\nderiv\ned\nfrom\nexact\nn\num\nb\ners\nusing\nonly\nexact\nop\nerations\nA\nn\num\nb\ner\n\nRevised\n\nSc\nheme\nis\ninexact\nif\nit\nw\nas\nwritten\nas\nan\ninexact\nconstan\nt\nif\nit\nw\nas\nderiv\ned\nusing\ninexact\ningredien\nts\nor\nif\nit\nw\nas\nderiv\ned\nusing\ninexact\nop\nerations\nTh\nus\ninexactness\nis\na\ncon\ntagious\nprop\nert\ny\nof\na\nn\num\nb\ner\nIf\nt\nw\no\nimplemen\ntations\npro\nduce\nexact\nresults\nfor\na\ncom\nputation\nthat\ndid\nnot\nin\nv\nolv\ne\ninexact\nin\ntermediate\nresults\nthe\nt\nw\no\nultimate\nresults\nwill\nb\ne\nmathematically\nequiv\nalen\nt\nThis\nis\ngenerally\nnot\ntrue\nof\ncomputations\nin\nv\nolving\ninex\nact\nn\num\nb\ners\nsince\nappro\nximate\nmetho\nds\nsuc\nh\nas\noating\np\noin\nt\narithmetic\nma\ny\nb\ne\nused\nbut\nit\nis\nthe\ndut\ny\nof\neac\nh\nimplemen\ntation\nto\nmak\ne\nthe\nresult\nas\nclose\nas\npractical\nto\nthe\nmathematically\nideal\nresult\nRational\nop\nerations\nsuc\nh\nas\n\nshould\nalw\na\nys\npro\nduce\nex\nact\nresults\nwhen\ngiv\nen\nexact\nargumen\nts\nIf\nthe\nop\neration\nis\nunable\nto\npro\nduce\nan\nexact\nresult\nthen\nit\nma\ny\neither\nrep\nort\nthe\nviolation\nof\nan\nimplemen\ntation\nrestriction\nor\nit\nma\ny\nsilen\ntly\nco\nerce\nits\nresult\nto\nan\ninexact\nv\nalue\nSee\nsec\ntion\n\nWith\nthe\nexception\nof\ninexactexact\nthe\nop\nerations\nde\nscrib\ned\nin\nthis\nsection\nm\nust\ngenerally\nreturn\ninexact\nresults\nwhen\ngiv\nen\nan\ny\ninexact\nargumen\nts\nAn\nop\neration\nma\ny\n\nho\nw\nev\ner\nreturn\nan\nexact\nresult\nif\nit\ncan\npro\nv\ne\nthat\nthe\nv\nalue\nof\nthe\nresult\nis\nunaected\nb\ny\nthe\ninexactness\nof\nits\nargumen\nts\nF\nor\nexample\nm\nultiplication\nof\nan\ny\nn\num\nb\ner\nb\ny\nan\nexact\nzero\nma\ny\npro\nduce\nan\nexact\nzero\nresult\nev\nen\nif\nthe\nother\nargumen\nt\nis\ninexact\n\nImplemen\ntation\nrestrictions\nImplemen\ntations\nof\nSc\nheme\nare\nnot\nrequired\nto\nimplemen\nt\nthe\nwhole\nto\nw\ner\nof\nsubt\nyp\nes\ngiv\nen\nin\nsection\n\nbut\nthey\nm\nust\nimplemen\nt\na\ncoheren\nt\nsubset\nconsisten\nt\nwith\nb\noth\nthe\npurp\noses\nof\nthe\nimplemen\ntation\nand\nthe\nspirit\nof\nthe\nSc\nheme\nlanguage\nF\nor\nexample\nan\nimplemen\ntation\nin\nwhic\nh\nall\nn\num\nb\ners\nare\nreal\nma\ny\nstill\nb\ne\nquite\nuseful\nImplemen\ntations\nma\ny\nalso\nsupp\nort\nonly\na\nlimited\nrange\nof\nn\num\nb\ners\nof\nan\ny\nt\nyp\ne\nsub\nject\nto\nthe\nrequiremen\nts\nof\nthis\nsection\nThe\nsupp\norted\nrange\nfor\nexact\nn\num\nb\ners\nof\nan\ny\nt\nyp\ne\nma\ny\nb\ne\ndieren\nt\nfrom\nthe\nsupp\norted\nrange\nfor\ninex\nact\nn\num\nb\ners\nof\nthat\nt\nyp\ne\nF\nor\nexample\nan\nimplemen\ntation\nthat\nuses\non\nums\nto\nrepresen\nt\nall\nits\ninexact\nreal\nn\num\nb\ners\nma\ny\nsupp\nort\na\npractically\nun\nb\nounded\nrange\nof\nexact\nin\nte\ngers\nand\nrationals\nwhile\nlimiting\nthe\nrange\nof\ninexact\nreals\nand\ntherefore\nthe\nrange\nof\ninexact\nin\ntegers\nand\nrationals\nto\nthe\ndynamic\nrange\nof\nthe\non\num\nformat\nF\nurthermore\nthe\ngaps\nb\net\nw\neen\nthe\nrepresen\ntable\ninexact\nin\ntegers\nand\nra\ntionals\nare\nlik\nely\nto\nb\ne\nv\nery\nlarge\nin\nsuc\nh\nan\nimplemen\ntation\nas\nthe\nlimits\nof\nthis\nrange\nare\napproac\nhed\nAn\nimplemen\ntation\nof\nSc\nheme\nm\nust\nsupp\nort\nexact\nin\ntegers\nthroughout\nthe\nrange\nof\nn\num\nb\ners\nthat\nma\ny\nb\ne\nused\nfor\nindexes\nof\nlists\nv\nectors\nand\nstrings\nor\nthat\nma\ny\nresult\nfrom\ncomputing\nthe\nlength\nof\na\nlist\nv\nector\nor\nstring\nThe\nlength\nvectorlength\nand\nstringlength\npro\ncedures\nm\nust\nreturn\nan\nexact\nin\nteger\nand\nit\nis\nan\nerror\nto\nuse\nan\nything\nbut\nan\nexact\nin\nteger\nas\nan\nindex\nF\nurthermore\nan\ny\nin\nteger\nconstan\nt\nwithin\nthe\nindex\nrange\nif\nexpressed\nb\ny\nan\nexact\nin\nteger\nsyn\ntax\nwill\nindeed\nb\ne\nread\nas\nan\nexact\nin\nteger\nregardless\nof\nan\ny\nimplemen\ntation\nrestrictions\nthat\nma\ny\napply\noutside\nthis\nrange\nFinally\n\nthe\npro\ncedures\nlisted\nb\nelo\nw\nwill\nalw\na\nys\nreturn\nan\nexact\nin\nteger\nresult\npro\nvided\nall\ntheir\nargumen\nts\nare\nexact\nin\ntegers\nand\nthe\nmathematically\nexp\nected\nresult\nis\nrepresen\ntable\nas\nan\nexact\nin\nteger\nwithin\nthe\nimplemen\ntation\n\nquotient\nremainder\nmodulo\nmax\nmin\nabs\nnumerator\ndenominator\ngcd\nlcm\nfloor\nceiling\ntruncate\nround\nrationalize\nexpt\nImplemen\ntations\nare\nencouraged\nbut\nnot\nrequired\nto\nsup\np\nort\nexact\nin\ntegers\nand\nexact\nrationals\nof\npractically\nunlim\nited\nsize\nand\nprecision\nand\nto\nimplemen\nt\nthe\nab\no\nv\ne\npro\nce\ndures\nand\nthe\n\npro\ncedure\nin\nsuc\nh\na\nw\na\ny\nthat\nthey\nalw\na\nys\nreturn\nexact\nresults\nwhen\ngiv\nen\nexact\nargumen\nts\nIf\none\nof\nthese\npro\ncedures\nis\nunable\nto\ndeliv\ner\nan\nexact\nresult\nwhen\ngiv\nen\nexact\nargumen\nts\nthen\nit\nma\ny\neither\nrep\nort\na\nvio\nlation\nof\nan\nimplemen\ntation\nrestriction\nor\nit\nma\ny\nsilen\ntly\nco\nerce\nits\nresult\nto\nan\ninexact\nn\num\nb\ner\nSuc\nh\na\nco\nercion\nma\ny\ncause\nan\nerror\nlater\nAn\nimplemen\ntation\nma\ny\nuse\noating\np\noin\nt\nand\nother\nap\npro\nximate\nrepresen\ntation\nstrategies\nfor\ninexact\nn\num\nb\ners\nThis\nrep\nort\nrecommends\nbut\ndo\nes\nnot\nrequire\nthat\nthe\nIEEE\nbit\nand\nbit\noating\np\noin\nt\nstandards\nb\ne\nfollo\nw\ned\nb\ny\nimplemen\ntations\nthat\nuse\non\num\nrepresen\ntations\nand\nthat\nimplemen\ntations\nusing\nother\nrepresen\ntations\nshould\nmatc\nh\nor\nexceed\nthe\nprecision\nac\nhiev\nable\nusing\nthese\noat\ning\np\noin\nt\nstandards\n\nIn\nparticular\nimplemen\ntations\nthat\nuse\non\num\nrepresen\ntations\nm\nust\nfollo\nw\nthese\nrules\nA\non\num\nresult\nm\nust\nb\ne\nrepresen\nted\nwith\nat\nleast\nas\nm\nuc\nh\nprecision\nas\nis\nused\nto\nexpress\nan\ny\nof\nthe\ninexact\nargumen\nts\nto\nthat\nop\neration\nIt\nis\ndesirable\nbut\nnot\nrequired\nfor\np\noten\ntially\ninexact\nop\ner\nations\nsuc\nh\nas\nsqrt\nwhen\napplied\nto\nexact\nargumen\nts\nto\npro\nduce\nexact\nansw\ners\nwhenev\ner\np\nossible\nfor\nexample\nthe\nsquare\nro\not\nof\nan\nexact\n\nough\nt\nto\nb\ne\nan\nexact\n\nIf\nho\nw\nev\ner\nan\nexact\nn\num\nb\ner\nis\nop\nerated\nup\non\nso\nas\nto\npro\nduce\nan\ninexact\nresult\nas\nb\ny\nsqrt\nand\nif\nthe\nresult\nis\nrepresen\nted\nas\na\non\num\nthen\nthe\nmost\nprecise\non\num\nformat\na\nv\nailable\nm\nust\nb\ne\nused\nbut\nif\nthe\nresult\nis\nrepresen\nted\nin\nsome\nother\nw\na\ny\nthen\nthe\nrepresen\ntation\nm\nust\nha\nv\ne\nat\nleast\nas\nm\nuc\nh\nprecision\nas\nthe\nmost\nprecise\non\num\nformat\na\nv\nailable\nAlthough\nSc\nheme\nallo\nws\na\nv\nariet\ny\nof\nwritten\nnotations\nfor\nn\num\nb\ners\nan\ny\nparticular\nimplemen\ntation\nma\ny\nsupp\nort\nonly\nsome\nof\nthem\nF\nor\nexample\nan\nimplemen\ntation\nin\nwhic\nh\nall\nn\num\nb\ners\nare\nreal\nneed\nnot\nsupp\nort\nthe\nrectangular\nand\n\nStandard\npro\ncedures\n\np\nolar\nnotations\nfor\ncomplex\nn\num\nb\ners\nIf\nan\nimplemen\nta\ntion\nencoun\nters\nan\nexact\nn\numerical\nconstan\nt\nthat\nit\ncannot\nrepresen\nt\nas\nan\nexact\nn\num\nb\ner\nthen\nit\nma\ny\neither\nrep\nort\na\nviolation\nof\nan\nimplemen\ntation\nrestriction\nor\nit\nma\ny\nsilen\ntly\nrepresen\nt\nthe\nconstan\nt\nb\ny\nan\ninexact\nn\num\nb\ner\n\nSyn\ntax\nof\nn\numerical\nconstan\nts\nThe\nsyn\ntax\nof\nthe\nwritten\nrepresen\ntations\nfor\nn\num\nb\ners\nis\ndescrib\ned\nformally\nin\nsection\n\nNote\nthat\ncase\nis\nnot\nsignican\nt\nin\nn\numerical\nconstan\nts\nA\nn\num\nb\ner\nma\ny\nb\ne\nwritten\nin\nbinary\n\no\nctal\ndecimal\nor\nhex\nadecimal\nb\ny\nthe\nuse\nof\na\nradix\nprex\nThe\nradix\nprexes\nare\nb\nbinary\no\no\nctal\nd\ndecimal\nand\nx\nhexadec\nimal\nWith\nno\nradix\nprex\na\nn\num\nb\ner\nis\nassumed\nto\nb\ne\nexpressed\nin\ndecimal\nA\nn\numerical\nconstan\nt\nma\ny\nb\ne\nsp\necied\nto\nb\ne\neither\nexact\nor\ninexact\nb\ny\na\nprex\nThe\nprexes\nare\ne\nfor\nexact\nand\ni\nfor\ninexact\nAn\nexactness\nprex\nma\ny\napp\near\nb\nefore\nor\nafter\nan\ny\nradix\nprex\nthat\nis\nused\nIf\nthe\nwritten\nrepresen\ntation\nof\na\nn\num\nb\ner\nhas\nno\nexactness\nprex\nthe\nconstan\nt\nma\ny\nb\ne\neither\ninexact\nor\nexact\nIt\nis\ninexact\nif\nit\ncon\ntains\na\ndecimal\np\noin\nt\nan\nexp\nonen\nt\nor\na\n\nc\nharacter\nin\nthe\nplace\nof\na\ndigit\notherwise\nit\nis\nexact\nIn\nsystems\nwith\ninexact\nn\num\nb\ners\nof\nv\narying\nprecisions\nit\nma\ny\nb\ne\nuseful\nto\nsp\necify\nthe\nprecision\nof\na\nconstan\nt\nF\nor\nthis\npurp\nose\nn\numerical\nconstan\nts\nma\ny\nb\ne\nwritten\nwith\nan\nexp\nonen\nt\nmark\ner\nthat\nindicates\nthe\ndesired\nprecision\nof\nthe\ninexact\nrepresen\ntation\nThe\nletters\ns\nf\nd\nand\nl\nsp\necify\nthe\nuse\nof\nshort\n\nsingle\n\ndouble\n\nand\nlong\nprecision\nresp\nec\ntiv\nely\n\nWhen\nfew\ner\nthan\nfour\nin\nternal\ninexact\nrepresen\ntations\nexist\nthe\nfour\nsize\nsp\necications\nare\nmapp\ned\non\nto\nthose\na\nv\nailable\nF\nor\nexample\nan\nimplemen\ntation\nwith\nt\nw\no\nin\nternal\nrepresen\ntations\nma\ny\nmap\nshort\nand\nsingle\ntogether\nand\nlong\nand\ndouble\ntogether\nIn\naddition\nthe\nexp\nonen\nt\nmark\ner\ne\nsp\necies\nthe\ndefault\nprecision\nfor\nthe\nimplemen\ntation\nThe\ndefault\nprecision\nhas\nat\nleast\nas\nm\nuc\nh\nprecision\nas\ndouble\n\nbut\nimplemen\ntations\nma\ny\nwish\nto\nallo\nw\nthis\nde\nfault\nto\nb\ne\nset\nb\ny\nthe\nuser\nF\nRound\nto\nsingle\n\nL\nExtend\nto\nlong\n\nNumerical\nop\nerations\nThe\nreader\nis\nreferred\nto\nsection\n\nfor\na\nsummary\nof\nthe\nnaming\ncon\nv\nen\ntions\nused\nto\nsp\necify\nrestrictions\non\nthe\nt\nyp\nes\nof\nargumen\nts\nto\nn\numerical\nroutines\nThe\nexamples\nused\nin\nthis\nsection\nassume\nthat\nan\ny\nn\numerical\nconstan\nt\nwritten\nusing\nan\nexact\nnotation\nis\nindeed\nrepresen\nted\nas\nan\nexact\nn\num\nb\ner\nSome\nexamples\nalso\nassume\nthat\ncertain\nn\numerical\nconstan\nts\nwritten\nusing\nan\ninexact\nnotation\ncan\nb\ne\nrepresen\nted\nwithout\nloss\nof\naccuracy\nthe\ninexact\ncon\nstan\nts\nw\nere\nc\nhosen\nso\nthat\nthis\nis\nlik\nely\nto\nb\ne\ntrue\nin\nimple\nmen\ntations\nthat\nuse\non\nums\nto\nrepresen\nt\ninexact\nn\num\nb\ners\nnumber\nobj\n\npro\ncedure\ncomplex\nobj\n\npro\ncedure\nreal\nobj\n\npro\ncedure\nrational\nobj\n\npro\ncedure\ninteger\nobj\n\npro\ncedure\nThese\nn\numerical\nt\nyp\ne\npredicates\ncan\nb\ne\napplied\nto\nan\ny\nkind\nof\nargumen\nt\nincluding\nnonn\num\nb\ners\nThey\nreturn\nt\nif\nthe\nob\nject\nis\nof\nthe\nnamed\nt\nyp\ne\nand\notherwise\nthey\nreturn\nf\nIn\ngeneral\nif\na\nt\nyp\ne\npredicate\nis\ntrue\nof\na\nn\num\nb\ner\nthen\nall\nhigher\nt\nyp\ne\npredicates\nare\nalso\ntrue\nof\nthat\nn\num\nb\ner\nConsequen\ntly\n\nif\na\nt\nyp\ne\npredicate\nis\nfalse\nof\na\nn\num\nb\ner\nthen\nall\nlo\nw\ner\nt\nyp\ne\npredicates\nare\nalso\nfalse\nof\nthat\nn\num\nb\ner\nIf\nz\nis\nan\ninexact\ncomplex\nn\num\nb\ner\nthen\nreal\nz\n\nis\ntrue\nif\nand\nonly\nif\nzero\nimagpart\nz\n\nis\ntrue\nIf\nx\nis\nan\ninexact\nreal\nn\num\nb\ner\nthen\ninteger\nx\n\nis\ntrue\nif\nand\nonly\nif\n\nx\nround\nx\n\ncomplex\n\ni\n\nt\ncomplex\n\nt\nreal\n\nt\nreal\n\ni\n\nt\nreal\nee\n\nt\nrational\n\nt\nrational\n\nt\ninteger\n\ni\n\nt\ninteger\n\nt\ninteger\n\nt\nNote\nThe\nb\neha\nvior\nof\nthese\nt\nyp\ne\npredicates\non\ninexact\nn\num\nb\ners\nis\nunreliable\nsince\nan\ny\ninaccuracy\nma\ny\naect\nthe\nresult\nNote\nIn\nman\ny\nimplemen\ntations\nthe\nrational\npro\ncedure\nwill\nb\ne\nthe\nsame\nas\nreal\nand\nthe\ncomplex\npro\ncedure\nwill\nb\ne\nthe\nsame\nas\nnumber\nbut\nun\nusual\nimplemen\ntations\nma\ny\nb\ne\nable\nto\nrepresen\nt\nsome\nirrational\nn\num\nb\ners\nexactly\nor\nma\ny\nextend\nthe\nn\num\nb\ner\nsystem\nto\nsupp\nort\nsome\nkind\nof\nnoncomplex\nn\num\nb\ners\nexact\nz\n\npro\ncedure\ninexact\nz\n\npro\ncedure\nThese\nn\numerical\npredicates\npro\nvide\ntests\nfor\nthe\nexactness\nof\na\nquan\ntit\ny\n\nF\nor\nan\ny\nSc\nheme\nn\num\nb\ner\nprecisely\none\nof\nthese\npredicates\nis\ntrue\n\nz\n\nz\n\nz\n\npro\ncedure\n!\nx\n\nx\n\nx\n\npro\ncedure\n\nx\n\nx\n\nx\n\npro\ncedure\n!\nx\n\nx\n\nx\n\npro\ncedure\n\nx\n\nx\n\nx\n\npro\ncedure\nThese\npro\ncedures\nreturn\nt\nif\ntheir\nargumen\nts\nare\nresp\nec\ntiv\nely\nequal\nmonotonically\nincreasing\nmonotonically\nde\ncreasing\nmonotonically\nnondecreasing\nor\nmonotonically\nnonincreasing\n\nRevised\n\nSc\nheme\nThese\npredicates\nare\nrequired\nto\nb\ne\ntransitiv\ne\nNote\nThe\ntraditional\nimplemen\ntations\nof\nthese\npredicates\nin\nLisplik\ne\nlanguages\nare\nnot\ntransitiv\ne\nNote\nWhile\nit\nis\nnot\nan\nerror\nto\ncompare\ninexact\nn\num\nb\ners\nusing\nthese\npredicates\nthe\nresults\nma\ny\nb\ne\nunreliable\nb\necause\na\nsmall\ninaccuracy\nma\ny\naect\nthe\nresult\nthis\nis\nesp\necially\ntrue\nof\n\nand\nzero\nWhen\nin\ndoubt\nconsult\na\nn\numerical\nanalyst\nzero\nz\n\nlibrary\npro\ncedure\npositive\nx\n\nlibrary\npro\ncedure\nnegative\nx\n\nlibrary\npro\ncedure\nodd\nn\n\nlibrary\npro\ncedure\neven\nn\nlibrary\npro\ncedure\nThese\nn\numerical\npredicates\ntest\na\nn\num\nb\ner\nfor\na\nparticular\nprop\nert\ny\n\nreturning\nt\nor\nf\nSee\nnote\nab\no\nv\ne\nmax\nx\n\nx\n\nlibrary\npro\ncedure\nmin\nx\n\nx\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nreturn\nthe\nmaxim\num\nor\nminim\num\nof\ntheir\nargumen\nts\nmax\n\nexact\nmax\n\ninexact\nNote\nIf\nan\ny\nargumen\nt\nis\ninexact\nthen\nthe\nresult\nwill\nalso\nb\ne\ninexact\nunless\nthe\npro\ncedure\ncan\npro\nv\ne\nthat\nthe\ninaccuracy\nis\nnot\nlarge\nenough\nto\naect\nthe\nresult\nwhic\nh\nis\np\nossible\nonly\nin\nun\nusual\nimplemen\ntations\n\nIf\nmin\nor\nmax\nis\nused\nto\ncompare\nn\num\nb\ners\nof\nmixed\nexactness\nand\nthe\nn\numerical\nv\nalue\nof\nthe\nresult\ncannot\nb\ne\nrepresen\nted\nas\nan\ninexact\nn\num\nb\ner\nwithout\nloss\nof\naccuracy\n\nthen\nthe\npro\ncedure\nma\ny\nrep\nort\na\nviolation\nof\nan\nimplemen\ntation\nrestriction\n\nz\n\npro\ncedure\n\nz\n\npro\ncedure\nThese\npro\ncedures\nreturn\nthe\nsum\nor\npro\nduct\nof\ntheir\nargu\nmen\nts\n\nz\n\nz\n\npro\ncedure\n\nz\n\npro\ncedure\n\nz\n\nz\n\noptional\npro\ncedure\n\nz\n\nz\n\npro\ncedure\n\nz\n\npro\ncedure\n\nz\n\nz\n\noptional\npro\ncedure\nWith\nt\nw\no\nor\nmore\nargumen\nts\nthese\npro\ncedures\nreturn\nthe\ndierence\nor\nquotien\nt\nof\ntheir\nargumen\nts\nasso\nciating\nto\nthe\nleft\nWith\none\nargumen\nt\nho\nw\nev\ner\nthey\nreturn\nthe\nadditiv\ne\nor\nm\nultiplicativ\ne\nin\nv\nerse\nof\ntheir\nargumen\nt\n\nabs\nx\n\nlibrary\npro\ncedure\nAbs\nreturns\nthe\nabsolute\nv\nalue\nof\nits\nargumen\nt\nabs\n\nquotient\nn\n\nn\n\npro\ncedure\nremainder\nn\n\nn\n\npro\ncedure\nmodulo\nn\n\nn\n\npro\ncedure\nThese\npro\ncedures\nimplemen\nt\nn\num\nb\nertheoretic\nin\nteger\ndi\nvision\nn\n\nshould\nb\ne\nnonzero\nAll\nthree\npro\ncedures\nreturn\nin\ntegers\nIf\nn\n\nn\n\nis\nan\nin\nteger\nquotient\nn\n\nn\n\nn\n\nn\n\nremainder\nn\n\nn\n\nmodulo\nn\n\nn\n\nIf\nn\n\nn\n\nis\nnot\nan\nin\nteger\nquotient\nn\n\nn\n\nn\nq\nremainder\nn\n\nn\n\nn\nr\nmodulo\nn\n\nn\n\nn\nm\nwhere\nn\nq\nis\nn\n\nn\n\nrounded\nto\nw\nards\nzero\n\njn\nr\nj\n\njn\n\nj\n\njn\nm\nj\n\njn\n\nj\nn\nr\nand\nn\nm\ndier\nfrom\nn\n\nb\ny\na\nm\nultiple\nof\nn\n\nn\nr\nhas\nthe\nsame\nsign\nas\nn\n\nand\nn\nm\nhas\nthe\nsame\nsign\nas\nn\n\nF\nrom\nthis\nw\ne\ncan\nconclude\nthat\nfor\nin\ntegers\nn\n\nand\nn\n\nwith\nn\n\nnot\nequal\nto\n\nn\n\nn\n\nquotient\nn\n\nn\n\nremainder\nn\n\nn\n\nt\npro\nvided\nall\nn\num\nb\ners\nin\nv\nolv\ned\nin\nthat\ncomputation\nare\nex\nact\nmodulo\n\nremainder\n\nmodulo\n\nremainder\n\nmodulo\n\nremainder\n\nmodulo\n\nremainder\n\nremainder\n\ninexact\n\nStandard\npro\ncedures\n\ngcd\nn\n\nlibrary\npro\ncedure\nlcm\nn\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nreturn\nthe\ngreatest\ncommon\ndivisor\nor\nleast\ncommon\nm\nultiple\nof\ntheir\nargumen\nts\nThe\nresult\nis\nalw\na\nys\nnonnegativ\ne\ngcd\n\ngcd\n\nlcm\n\nlcm\n\ninexact\nlcm\n\nnumerator\nq\n\npro\ncedure\ndenominator\nq\n\npro\ncedure\nThese\npro\ncedures\nreturn\nthe\nn\numerator\nor\ndenominator\nof\ntheir\nargumen\nt\nthe\nresult\nis\ncomputed\nas\nif\nthe\nargumen\nt\nw\nas\nrepresen\nted\nas\na\nfraction\nin\nlo\nw\nest\nterms\nThe\ndenom\ninator\nis\nalw\na\nys\np\nositiv\ne\nThe\ndenominator\nof\n\nis\ndened\nto\nb\ne\n\nnumerator\n\ndenominator\n\ndenominator\nexact inexact\n\nfloor\nx\n\npro\ncedure\nceiling\nx\n\npro\ncedure\ntruncate\nx\n\npro\ncedure\nround\nx\n\npro\ncedure\nThese\npro\ncedures\nreturn\nin\ntegers\nFloor\nreturns\nthe\nlargest\nin\nteger\nnot\nlarger\nthan\nx\n\nCeiling\nreturns\nthe\nsmallest\nin\nteger\nnot\nsmaller\nthan\nx\n\nTruncate\nreturns\nthe\nin\nteger\nclosest\nto\nx\nwhose\nabsolute\nv\nalue\nis\nnot\nlarger\nthan\nthe\nabsolute\nv\nalue\nof\nx\nRound\nreturns\nthe\nclosest\nin\nte\nger\nto\nx\nrounding\nto\nev\nen\nwhen\nx\nis\nhalfw\na\ny\nb\net\nw\neen\nt\nw\no\nin\ntegers\nR\nationale\nRound\nrounds\nto\nev\nen\nfor\nconsistency\nwith\nthe\nde\nfault\nrounding\nmo\nde\nsp\necied\nb\ny\nthe\nIEEE\noating\np\noin\nt\nstan\ndard\nNote\nIf\nthe\nargumen\nt\nto\none\nof\nthese\npro\ncedures\nis\ninexact\nthen\nthe\nresult\nwill\nalso\nb\ne\ninexact\nIf\nan\nexact\nv\nalue\nis\nneeded\nthe\nresult\nshould\nb\ne\npassed\nto\nthe\ninexact exact\npro\ncedure\nfloor\n\nceiling\n\ntruncate\n\nround\n\nfloor\n\nceiling\n\ntruncate\n\nround\n\ninexact\nround\n\nexact\nround\n\nrationalize\nx\ny\n\nlibrary\npro\ncedure\nRationalize\nreturns\nthe\nsimplest\nrational\nn\num\nb\ner\ndier\ning\nfrom\nx\nb\ny\nno\nmore\nthan\ny\n\nA\nrational\nn\num\nb\ner\nr\n\nis\nsimpler\nthan\nanother\nrational\nn\num\nb\ner\nr\n\nif\nr\n\np\n\nq\n\nand\nr\n\np\n\nq\n\nin\nlo\nw\nest\nterms\nand\njp\n\nj\n\njp\n\nj\nand\njq\n\nj\n\njq\n\nj\nTh\nus\n\nis\nsimpler\nthan\n\nAlthough\nnot\nall\nrationals\nare\ncomparable\nin\nthis\nordering\nconsider\n\nand\n\nan\ny\nin\nterv\nal\ncon\ntains\na\nrational\nn\num\nb\ner\nthat\nis\nsimpler\nthan\nev\nery\nother\nrational\nn\num\nb\ner\nin\nthat\nin\nterv\nal\nthe\nsimpler\n\nlies\nb\net\nw\neen\n\nand\n\nNote\nthat\n\nis\nthe\nsim\nplest\nrational\nof\nall\nrationalize\ninexact exact\n\nexact\nrationalize\n\ni\n\ninexact\nexp\nz\n\npro\ncedure\nlog\nz\n\npro\ncedure\nsin\nz\n\npro\ncedure\ncos\nz\n\npro\ncedure\ntan\nz\n\npro\ncedure\nasin\nz\n\npro\ncedure\nacos\nz\n\npro\ncedure\natan\nz\n\npro\ncedure\natan\ny\nx\n\npro\ncedure\nThese\npro\ncedures\nare\npart\nof\nev\nery\nimplemen\ntation\nthat\nsupp\norts\ngeneral\nreal\nn\num\nb\ners\nthey\ncompute\nthe\nusual\ntranscenden\ntal\nfunctions\nLog\ncomputes\nthe\nnatural\nlog\narithm\nof\nz\nnot\nthe\nbase\nten\nlogarithm\nAsin\nacos\nand\natan\ncompute\narcsine\nsin\n\narccosine\ncos\n\nand\narctangen\nt\ntan\n\nresp\nectiv\nely\n\nThe\nt\nw\noargumen\nt\nv\nari\nan\nt\nof\natan\ncomputes\nangle\nmakerectangul\nar\nx\ny\n\nsee\nb\nelo\nw\nev\nen\nin\nimplemen\ntations\nthat\ndont\nsupp\nort\ngeneral\ncomplex\nn\num\nb\ners\nIn\ngeneral\nthe\nmathematical\nfunctions\nlog\narcsine\narc\ncosine\nand\narctangen\nt\nare\nm\nultiply\ndened\nThe\nv\nalue\nof\nlog\nz\nis\ndened\nto\nb\ne\nthe\none\nwhose\nimaginary\npart\nlies\nin\nthe\nrange\nfrom\n\nexclusiv\ne\nto\n\ninclusiv\ne\nlog\n\nis\nun\ndened\nWith\nlog\ndened\nthis\nw\na\ny\n\nthe\nv\nalues\nof\nsin\n\nz\n\ncos\n\nz\n\nand\ntan\n\nz\nare\naccording\nto\nthe\nfollo\nwing\nfor\nm\nul!\nsin\n\nz\n\ni\nlogiz\n\"\np\n\nz\n\ncos\n\nz\n\nsin\n\nz\ntan\n\nz\n\nlog\n\"\niz\n\nlog\n\niz\ni\nThe\nab\no\nv\ne\nsp\necication\nfollo\nws\n\nwhic\nh\nin\nturn\ncites\n\nrefer\nto\nthese\nsources\nfor\nmore\ndetailed\ndiscussion\nof\nbranc\nh\ncuts\nb\noundary\nconditions\nand\nimplemen\ntation\nof\nthese\nfunctions\nWhen\nit\nis\np\nossible\nthese\npro\ncedures\npro\nduce\na\nreal\nresult\nfrom\na\nreal\nargumen\nt\n\nRevised\n\nSc\nheme\nsqrt\nz\n\npro\ncedure\nReturns\nthe\nprincipal\nsquare\nro\not\nof\nz\n\nThe\nresult\nwill\nha\nv\ne\neither\np\nositiv\ne\nreal\npart\nor\nzero\nreal\npart\nand\nnonnegativ\ne\nimaginary\npart\nexpt\nz\n\nz\n\npro\ncedure\nReturns\nz\n\nraised\nto\nthe\np\no\nw\ner\nz\n\nF\nor\nz\n\nz\n\nz\n\ne\nz\n\nlog\nz\n\nz\nis\n\nif\nz\n\nand\n\notherwise\nmakerectangula\nr\nx\n\nx\n\npro\ncedure\nmakepolar\nx\n\nx\n\npro\ncedure\nrealpart\nz\n\npro\ncedure\nimagpart\nz\n\npro\ncedure\nmagnitude\nz\n\npro\ncedure\nangle\nz\n\npro\ncedure\nThese\npro\ncedures\nare\npart\nof\nev\nery\nimplemen\ntation\nthat\nsupp\norts\ngeneral\ncomplex\nn\num\nb\ners\nSupp\nose\nx\n\nx\n\nx\n\nand\nx\n\nare\nreal\nn\num\nb\ners\nand\nz\nis\na\ncomplex\nn\num\nb\ner\nsuc\nh\nthat\nz\n\nx\n\n\"\nx\n\ni\n\nx\n\ne\ni\nx\n\nThen\nmakerectangular\nx\n\nx\n\nz\nmakepolar\nx\n\nx\n\nz\nrealpart\nz\n\nx\n\nimagpart\nz\n\nx\n\nmagnitude\nz\n\njx\n\nj\nangle\nz\n\nx\nang\nle\nwhere\n\nx\nang\nle\n\nwith\nx\nang\nle\n\nx\n\n\"\n\nn\nfor\nsome\nin\nteger\nn\nR\nationale\nMagnitude\nis\nthe\nsame\nas\nabs\nfor\na\nreal\nargu\nmen\nt\nbut\nabs\nm\nust\nb\ne\npresen\nt\nin\nall\nimplemen\ntations\nwhereas\nmagnitude\nneed\nonly\nb\ne\npresen\nt\nin\nimplemen\ntations\nthat\nsup\np\nort\ngeneral\ncomplex\nn\num\nb\ners\nexactinexact\nz\n\npro\ncedure\ninexactexact\nz\n\npro\ncedure\nExactinexact\nreturns\nan\ninexact\nrepresen\ntation\nof\nz\n\nThe\nv\nalue\nreturned\nis\nthe\ninexact\nn\num\nb\ner\nthat\nis\nn\numeri\ncally\nclosest\nto\nthe\nargumen\nt\nIf\nan\nexact\nargumen\nt\nhas\nno\nreasonably\nclose\ninexact\nequiv\nalen\nt\nthen\na\nviolation\nof\nan\nimplemen\ntation\nrestriction\nma\ny\nb\ne\nrep\norted\nInexactexact\nreturns\nan\nexact\nrepresen\ntation\nof\nz\n\nThe\nv\nalue\nreturned\nis\nthe\nexact\nn\num\nb\ner\nthat\nis\nn\numerically\nclos\nest\nto\nthe\nargumen\nt\nIf\nan\ninexact\nargumen\nt\nhas\nno\nrea\nsonably\nclose\nexact\nequiv\nalen\nt\nthen\na\nviolation\nof\nan\nim\nplemen\ntation\nrestriction\nma\ny\nb\ne\nrep\norted\nThese\npro\ncedures\nimplemen\nt\nthe\nnatural\nonetoone\ncorre\nsp\nondence\nb\net\nw\neen\nexact\nand\ninexact\nin\ntegers\nthroughout\nan\nimplemen\ntationdep\nenden\nt\nrange\nSee\nsection\n\nNumerical\ninput\nand\noutput\nnumberstring\nz\n\npro\ncedure\nnumberstring\nz\nr\nadix\n\npro\ncedure\nR\nadix\nm\nust\nb\ne\nan\nexact\nin\nteger\neither\n\nor\n\nIf\nomitted\nr\nadix\ndefaults\nto\n\nThe\npro\ncedure\nnumber\nstring\ntak\nes\na\nn\num\nb\ner\nand\na\nradix\nand\nreturns\nas\na\nstring\nan\nexternal\nrepresen\ntation\nof\nthe\ngiv\nen\nn\num\nb\ner\nin\nthe\ngiv\nen\nradix\nsuc\nh\nthat\nlet\nnumber\nnumber\n\nradix\nr\nadix\n\neqv\nnumber\nstring number\nnumber string\nnumber\nradix\nradix\nis\ntrue\nIt\nis\nan\nerror\nif\nno\np\nossible\nresult\nmak\nes\nthis\nex\npression\ntrue\nIf\nz\nis\ninexact\nthe\nradix\nis\n\nand\nthe\nab\no\nv\ne\nexpression\ncan\nb\ne\nsatised\nb\ny\na\nresult\nthat\ncon\ntains\na\ndecimal\np\noin\nt\nthen\nthe\nresult\ncon\ntains\na\ndecimal\np\noin\nt\nand\nis\nexpressed\nusing\nthe\nminim\num\nn\num\nb\ner\nof\ndigits\nexclusiv\ne\nof\nexp\nonen\nt\nand\ntrailing\nzero\nes\nneeded\nto\nmak\ne\nthe\nab\no\nv\ne\nexpression\ntrue\n\notherwise\nthe\nformat\nof\nthe\nresult\nis\nunsp\necied\nThe\nresult\nreturned\nb\ny\nnumberstring\nnev\ner\ncon\ntains\nan\nexplicit\nradix\nprex\nNote\nThe\nerror\ncase\ncan\no\nccur\nonly\nwhen\nz\nis\nnot\na\ncomplex\nn\num\nb\ner\nor\nis\na\ncomplex\nn\num\nb\ner\nwith\na\nnonrational\nreal\nor\nimaginary\npart\nR\nationale\nIf\nz\nis\nan\ninexact\nn\num\nb\ner\nrepresen\nted\nusing\non\nums\nand\nthe\nradix\nis\n\nthen\nthe\nab\no\nv\ne\nexpression\nis\nnormally\nsatis\ned\nb\ny\na\nresult\ncon\ntaining\na\ndecimal\np\noin\nt\nThe\nunsp\necied\ncase\nallo\nws\nfor\ninnities\nNaNs\nand\nnonon\num\nrepresen\ntations\nstringnumber\nstring\n\npro\ncedure\nstringnumber\nstring\nr\nadix\n\npro\ncedure\nReturns\na\nn\num\nb\ner\nof\nthe\nmaximally\nprecise\nrepresen\ntation\nexpressed\nb\ny\nthe\ngiv\nen\nstr\ning\n\nR\nadix\nm\nust\nb\ne\nan\nexact\nin\nteger\neither\n\nor\n\nIf\nsupplied\nr\nadix\nis\na\ndefault\nradix\nthat\nma\ny\nb\ne\no\nv\nerridden\nb\ny\nan\nexplicit\nradix\nprex\nin\nstr\ning\neg\no\nIf\nr\nadix\nis\nnot\nsupplied\nthen\nthe\ndefault\nradix\nis\n\nIf\nstr\ning\nis\nnot\na\nsyn\ntactically\nv\nalid\nnotation\nfor\na\nn\num\nb\ner\nthen\nstringnumber\nreturns\nf\nstring number\n\nstring number\n\nstring number\ne\n\nstring number\n\nNote\nThe\ndomain\nof\nstring number\nma\ny\nb\ne\nrestricted\nb\ny\nimplemen\ntations\nin\nthe\nfollo\nwing\nw\na\nys\nString number\nis\np\ner\nmitted\nto\nreturn\nf\nwhenev\ner\nstr\ning\ncon\ntains\nan\nexplicit\nradix\nprex\nIf\nall\nn\num\nb\ners\nsupp\norted\nb\ny\nan\nimplemen\ntation\nare\nreal\n\nStandard\npro\ncedures\n\nthen\nstring number\nis\np\nermitted\nto\nreturn\nf\nwhenev\ner\nstr\ning\nuses\nthe\np\nolar\nor\nrectangular\nnotations\nfor\ncomplex\nn\num\nb\ners\nIf\nall\nn\num\nb\ners\nare\nin\ntegers\nthen\nstring number\nma\ny\nreturn\nf\nwhenev\ner\nthe\nfractional\nnotation\nis\nused\nIf\nall\nn\num\nb\ners\nare\nexact\nthen\nstring number\nma\ny\nreturn\nf\nwhenev\ner\nan\nex\np\nonen\nt\nmark\ner\nor\nexplicit\nexactness\nprex\nis\nused\nor\nif\na\n\napp\nears\nin\nplace\nof\na\ndigit\nIf\nall\ninexact\nn\num\nb\ners\nare\nin\ntegers\nthen\nstring number\nma\ny\nreturn\nf\nwhenev\ner\na\ndecimal\np\noin\nt\nis\nused\n\nOther\ndata\nt\nyp\nes\nThis\nsection\ndescrib\nes\nop\nerations\non\nsome\nof\nSc\nhemes\nnon\nn\numeric\ndata\nt\nyp\nes\nb\no\noleans\npairs\nlists\nsym\nb\nols\nc\nhar\nacters\nstrings\nand\nv\nectors\n\nBo\noleans\nThe\nstandard\nb\no\nolean\nob\njects\nfor\ntrue\nand\nfalse\nare\nwritten\nas\nt\nand\nf\nWhat\nreally\nmatters\nthough\nare\nthe\nob\njects\nthat\nthe\nSc\nheme\nconditional\nexpressions\nif\ncond\nand\nor\ndo\ntreat\nas\ntrue\nor\nfalse\nThe\nphrase\na\ntrue\nv\nalue\nor\nsometimes\njust\ntrue\nmeans\nan\ny\nob\nject\ntreated\nas\ntrue\nb\ny\nthe\nconditional\nexpressions\nand\nthe\nphrase\na\nfalse\nv\nalue\nor\nfalse\nmeans\nan\ny\nob\nject\ntreated\nas\nfalse\nb\ny\nthe\nconditional\nexpressions\nOf\nall\nthe\nstandard\nSc\nheme\nv\nalues\nonly\nf\ncoun\nts\nas\nfalse\nin\nconditional\nexpressions\nExcept\nfor\nf\nall\nstandard\nSc\nheme\nv\nalues\nincluding\nt\npairs\nthe\nempt\ny\nlist\nsym\nb\nols\nn\num\nb\ners\nstrings\nv\nectors\nand\npro\ncedures\ncoun\nt\nas\ntrue\nNote\nProgrammers\naccustomed\nto\nother\ndialects\nof\nLisp\nshould\nb\ne\na\nw\nare\nthat\nSc\nheme\ndistinguishes\nb\noth\nf\nand\nthe\nempt\ny\nlist\nfrom\nthe\nsym\nb\nol\nnil\nBo\nolean\nconstan\nts\nev\naluate\nto\nthemselv\nes\nso\nthey\ndo\nnot\nneed\nto\nb\ne\nquoted\nin\nprograms\nt\n\nt\nf\n\nf\nf\n\nf\nnot\nobj\n\nlibrary\npro\ncedure\nNot\nreturns\nt\nif\nobj\nis\nfalse\nand\nreturns\nf\notherwise\nnot\nt\n\nf\nnot\n\nf\nnot\nlist\n\nf\nnot\nf\n\nt\nnot\n\nf\nnot\nlist\n\nf\nnot\nnil\n\nf\nboolean\nobj\n\nlibrary\npro\ncedure\nBoolean\nreturns\nt\nif\nobj\nis\neither\nt\nor\nf\nand\nreturns\nf\notherwise\nboolean\nf\n\nt\nboolean\n\nf\nboolean\n\nf\n\nP\nairs\nand\nlists\nA\np\nair\nsometimes\ncalled\na\ndotte\nd\np\nair\nis\na\nrecord\nstructure\nwith\nt\nw\no\nelds\ncalled\nthe\ncar\nand\ncdr\nelds\nfor\nhistorical\nreasons\nP\nairs\nare\ncreated\nb\ny\nthe\npro\ncedure\ncons\nThe\ncar\nand\ncdr\nelds\nare\naccessed\nb\ny\nthe\npro\ncedures\ncar\nand\ncdr\nThe\ncar\nand\ncdr\nelds\nare\nassigned\nb\ny\nthe\npro\ncedures\nsetcar\nand\nsetcdr\n\nP\nairs\nare\nused\nprimarily\nto\nrepresen\nt\nlists\nA\nlist\ncan\nb\ne\ndened\nrecursiv\nely\nas\neither\nthe\nempt\ny\nlist\nor\na\npair\nwhose\ncdr\nis\na\nlist\nMore\nprecisely\n\nthe\nset\nof\nlists\nis\ndened\nas\nthe\nsmallest\nset\nX\nsuc\nh\nthat\n\nThe\nempt\ny\nlist\nis\nin\nX\n\nIf\nlist\nis\nin\nX\n\nthen\nan\ny\npair\nwhose\ncdr\neld\ncon\ntains\nlist\nis\nalso\nin\nX\n\nThe\nob\njects\nin\nthe\ncar\nelds\nof\nsuccessiv\ne\npairs\nof\na\nlist\nare\nthe\nelemen\nts\nof\nthe\nlist\nF\nor\nexample\na\nt\nw\noelemen\nt\nlist\nis\na\npair\nwhose\ncar\nis\nthe\nrst\nelemen\nt\nand\nwhose\ncdr\nis\na\npair\nwhose\ncar\nis\nthe\nsecond\nelemen\nt\nand\nwhose\ncdr\nis\nthe\nempt\ny\nlist\nThe\nlength\nof\na\nlist\nis\nthe\nn\num\nb\ner\nof\nelemen\nts\nwhic\nh\nis\nthe\nsame\nas\nthe\nn\num\nb\ner\nof\npairs\nThe\nempt\ny\nlist\nis\na\nsp\necial\nob\nject\nof\nits\no\nwn\nt\nyp\ne\nit\nis\nnot\na\npair\nit\nhas\nno\nelemen\nts\nand\nits\nlength\nis\nzero\nNote\nThe\nab\no\nv\ne\ndenitions\nimply\nthat\nall\nlists\nha\nv\ne\nnite\nlength\nand\nare\nterminated\nb\ny\nthe\nempt\ny\nlist\nThe\nmost\ngeneral\nnotation\nexternal\nrepresen\ntation\nfor\nSc\nheme\npairs\nis\nthe\ndotted\nnotation\nc\n\nc\n\nwhere\nc\n\nis\nthe\nv\nalue\nof\nthe\ncar\neld\nand\nc\n\nis\nthe\nv\nalue\nof\nthe\ncdr\neld\nF\nor\nexample\n\nis\na\npair\nwhose\ncar\nis\n\nand\nwhose\ncdr\nis\n\nNote\nthat\n\nis\nthe\nexternal\nrepre\nsen\ntation\nof\na\npair\nnot\nan\nexpression\nthat\nev\naluates\nto\na\npair\nA\nmore\nstreamlined\nnotation\ncan\nb\ne\nused\nfor\nlists\nthe\nelemen\nts\nof\nthe\nlist\nare\nsimply\nenclosed\nin\nparen\ntheses\nand\nseparated\nb\ny\nspaces\nThe\nempt\ny\nlist\nis\nwritten\n\nF\nor\nexample\na\nb\nc\nd\ne\nand\na\n\nb\n\nc\n\nd\n\ne\n\nRevised\n\nSc\nheme\nare\nequiv\nalen\nt\nnotations\nfor\na\nlist\nof\nsym\nb\nols\nA\nc\nhain\nof\npairs\nnot\nending\nin\nthe\nempt\ny\nlist\nis\ncalled\nan\nimpr\nop\ner\nlist\nNote\nthat\nan\nimprop\ner\nlist\nis\nnot\na\nlist\nThe\nlist\nand\ndotted\nnotations\ncan\nb\ne\ncom\nbined\nto\nrepresen\nt\nimprop\ner\nlists\na\nb\nc\n\nd\nis\nequiv\nalen\nt\nto\na\n\nb\n\nc\n\nd\nWhether\na\ngiv\nen\npair\nis\na\nlist\ndep\nends\nup\non\nwhat\nis\nstored\nin\nthe\ncdr\neld\nWhen\nthe\nsetcdr\npro\ncedure\nis\nused\nan\nob\nject\ncan\nb\ne\na\nlist\none\nmomen\nt\nand\nnot\nthe\nnext\ndefine\nx\nlist\na\nb\nc\ndefine\ny\nx\ny\n\na\nb\nc\nlist\ny\n\nt\nsetcdr\nx\n\nunsp\ne\ncie\nd\nx\n\na\n\neqv\nx\ny\n\nt\ny\n\na\n\nlist\ny\n\nf\nsetcdr\nx\nx\n\nunsp\ne\ncie\nd\nlist\nx\n\nf\nWithin\nliteral\nexpressions\nand\nrepresen\ntations\nof\nob\njects\nread\nb\ny\nthe\nread\npro\ncedure\nthe\nforms\nhdatumi\n\nhdatumi\nhdatumi\nand\nhdatumi\ndenote\nt\nw\noele\nmen\nt\nlists\nwhose\nrst\nelemen\nts\nare\nthe\nsym\nb\nols\nquote\nquasiquote\nunquote\n\nand\nunquotesplicing\n\nresp\nec\ntiv\nely\n\nThe\nsecond\nelemen\nt\nin\neac\nh\ncase\nis\nhdatumi\nThis\ncon\nv\nen\ntion\nis\nsupp\norted\nso\nthat\narbitrary\nSc\nheme\npro\ngrams\nma\ny\nb\ne\nrepresen\nted\nas\nlists\nThat\nis\naccording\nto\nSc\nhemes\ngrammar\nev\nery\nhexpressioni\nis\nalso\na\nhdatumi\nsee\nsection\n\nAmong\nother\nthings\nthis\np\nermits\nthe\nuse\nof\nthe\nread\npro\ncedure\nto\nparse\nSc\nheme\nprograms\nSee\nsection\n\npair\nobj\n\npro\ncedure\nPair\nreturns\nt\nif\nobj\nis\na\npair\nand\notherwise\nreturns\nf\npair\na\n\nb\n\nt\npair\na\nb\nc\n\nt\npair\n\nf\npair\na\nb\n\nf\ncons\nobj\n\nobj\n\npro\ncedure\nReturns\na\nnewly\nallo\ncated\npair\nwhose\ncar\nis\nobj\n\nand\nwhose\ncdr\nis\nobj\n\nThe\npair\nis\nguaran\nteed\nto\nb\ne\ndieren\nt\nin\nthe\nsense\nof\neqv\nfrom\nev\nery\nexisting\nob\nject\ncons\na\n\na\ncons\na\nb\nc\nd\n\na\nb\nc\nd\ncons\na\nb\nc\n\na\nb\nc\ncons\na\n\na\n\ncons\na\nb\nc\n\na\nb\n\nc\ncar\np\nair\n\npro\ncedure\nReturns\nthe\ncon\nten\nts\nof\nthe\ncar\neld\nof\np\nair\n\nNote\nthat\nit\nis\nan\nerror\nto\ntak\ne\nthe\ncar\nof\nthe\nempt\ny\nlist\ncar\na\nb\nc\n\na\ncar\na\nb\nc\nd\n\na\ncar\n\ncar\n\nerr\nor\ncdr\np\nair\n\npro\ncedure\nReturns\nthe\ncon\nten\nts\nof\nthe\ncdr\neld\nof\np\nair\n\nNote\nthat\nit\nis\nan\nerror\nto\ntak\ne\nthe\ncdr\nof\nthe\nempt\ny\nlist\ncdr\na\nb\nc\nd\n\nb\nc\nd\ncdr\n\ncdr\n\nerr\nor\nsetcar\np\nair\nobj\n\npro\ncedure\nStores\nobj\nin\nthe\ncar\neld\nof\np\nair\n\nThe\nv\nalue\nreturned\nb\ny\nsetcar\nis\nunsp\necied\ndefine\nf\nlist\nnotaconstantlist\ndefine\ng\nconstantlist\nsetcar\nf\n\nunsp\ne\ncie\nd\nsetcar\ng\n\nerr\nor\nsetcdr\np\nair\nobj\n\npro\ncedure\nStores\nobj\nin\nthe\ncdr\neld\nof\np\nair\n\nThe\nv\nalue\nreturned\nb\ny\nsetcdr\nis\nunsp\necied\ncaar\np\nair\n\nlibrary\npro\ncedure\ncadr\np\nair\n\nlibrary\npro\ncedure\n\ncdddar\np\nair\n\nlibrary\npro\ncedure\ncddddr\np\nair\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nare\ncomp\nositions\nof\ncar\nand\ncdr\nwhere\nfor\nexample\ncaddr\ncould\nb\ne\ndened\nb\ny\ndefine\ncaddr\nlambda\nx\ncar\ncdr\ncdr\nx\nArbitrary\ncomp\nositions\nup\nto\nfour\ndeep\nare\npro\nvided\nThere\nare\nt\nw\nen\nt\nyeigh\nt\nof\nthese\npro\ncedures\nin\nall\nnull\nobj\n\nlibrary\npro\ncedure\nReturns\nt\nif\nobj\nis\nthe\nempt\ny\nlist\notherwise\nreturns\nf\nlist\nobj\n\nlibrary\npro\ncedure\nReturns\nt\nif\nobj\nis\na\nlist\notherwise\nreturns\nf\nBy\ndeni\ntion\nall\nlists\nha\nv\ne\nnite\nlength\nand\nare\nterminated\nb\ny\nthe\nempt\ny\nlist\n\nStandard\npro\ncedures\n\nlist\na\nb\nc\n\nt\nlist\n\nt\nlist\na\n\nb\n\nf\nlet\nx\nlist\na\nsetcdr\nx\nx\nlist\nx\n\nf\nlist\nobj\n\nlibrary\npro\ncedure\nReturns\na\nnewly\nallo\ncated\nlist\nof\nits\nargumen\nts\nlist\na\n\nc\n\na\n\nc\nlist\n\nlength\nlist\n\nlibrary\npro\ncedure\nReturns\nthe\nlength\nof\nlist\n\nlength\na\nb\nc\n\nlength\na\nb\nc\nd\ne\n\nlength\n\nappend\nlist\n\nlibrary\npro\ncedure\nReturns\na\nlist\nconsisting\nof\nthe\nelemen\nts\nof\nthe\nrst\nlist\nfollo\nw\ned\nb\ny\nthe\nelemen\nts\nof\nthe\nother\nlist\ns\nappend\nx\ny\n\nx\ny\nappend\na\nb\nc\nd\n\na\nb\nc\nd\nappend\na\nb\nc\n\na\nb\nc\nThe\nresulting\nlist\nis\nalw\na\nys\nnewly\nallo\ncated\nexcept\nthat\nit\nshares\nstructure\nwith\nthe\nlast\nlist\nargumen\nt\nThe\nlast\nargumen\nt\nma\ny\nactually\nb\ne\nan\ny\nob\nject\nan\nimprop\ner\nlist\nresults\nif\nthe\nlast\nargumen\nt\nis\nnot\na\nprop\ner\nlist\nappend\na\nb\nc\n\nd\n\na\nb\nc\n\nd\nappend\n\na\n\na\nreverse\nlist\n\nlibrary\npro\ncedure\nReturns\na\nnewly\nallo\ncated\nlist\nconsisting\nof\nthe\nelemen\nts\nof\nlist\nin\nrev\nerse\norder\nreverse\na\nb\nc\n\nc\nb\na\nreverse\na\nb\nc\nd\ne\nf\n\ne\nf\nd\nb\nc\na\nlisttail\nlist\nk\n\nlibrary\npro\ncedure\nReturns\nthe\nsublist\nof\nlist\nobtained\nb\ny\nomitting\nthe\nrst\nk\nelemen\nts\nIt\nis\nan\nerror\nif\nlist\nhas\nfew\ner\nthan\nk\nelemen\nts\nListtail\ncould\nb\ne\ndened\nb\ny\ndefine\nlisttail\nlambda\nx\nk\nif\nzero\nk\nx\nlisttail\ncdr\nx\n\nk\n\nlistref\nlist\nk\n\nlibrary\npro\ncedure\nReturns\nthe\nk\nth\nelemen\nt\nof\nlist\n\nThis\nis\nthe\nsame\nas\nthe\ncar\nof\nlisttail\nlist\nk\n\nIt\nis\nan\nerror\nif\nlist\nhas\nfew\ner\nthan\nk\nelemen\nts\nlistref\na\nb\nc\nd\n\nc\nlistref\na\nb\nc\nd\ninexact exact\nround\n\nc\nmemq\nobj\nlist\n\nlibrary\npro\ncedure\nmemv\nobj\nlist\n\nlibrary\npro\ncedure\nmember\nobj\nlist\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nreturn\nthe\nrst\nsublist\nof\nlist\nwhose\ncar\nis\nobj\n\nwhere\nthe\nsublists\nof\nlist\nare\nthe\nnonempt\ny\nlists\nreturned\nb\ny\nlisttail\nlist\nk\n\nfor\nk\nless\nthan\nthe\nlength\nof\nlist\n\nIf\nobj\ndo\nes\nnot\no\nccur\nin\nlist\n\nthen\nf\nnot\nthe\nempt\ny\nlist\nis\nreturned\nMemq\nuses\neq\nto\ncompare\nobj\nwith\nthe\nelemen\nts\nof\nlist\n\nwhile\nmemv\nuses\neqv\nand\nmember\nuses\nequal\nmemq\na\na\nb\nc\n\na\nb\nc\nmemq\nb\na\nb\nc\n\nb\nc\nmemq\na\nb\nc\nd\n\nf\nmemq\nlist\na\nb\na\nc\n\nf\nmember\nlist\na\nb\na\nc\n\na\nc\nmemq\n\nunsp\ne\ncie\nd\nmemv\n\nassq\nobj\nalist\n\nlibrary\npro\ncedure\nassv\nobj\nalist\n\nlibrary\npro\ncedure\nassoc\nobj\nalist\n\nlibrary\npro\ncedure\nA\nlist\nfor\nasso\nciation\nlist\nm\nust\nb\ne\na\nlist\nof\npairs\nThese\npro\ncedures\nnd\nthe\nrst\npair\nin\nalist\nwhose\ncar\neld\nis\nobj\n\nand\nreturns\nthat\npair\nIf\nno\npair\nin\nalist\nhas\nobj\nas\nits\ncar\nthen\nf\nnot\nthe\nempt\ny\nlist\nis\nreturned\nAssq\nuses\neq\nto\ncompare\nobj\nwith\nthe\ncar\nelds\nof\nthe\npairs\nin\nalist\n\nwhile\nassv\nuses\neqv\nand\nassoc\nuses\nequal\ndefine\ne\na\n\nb\n\nc\n\nassq\na\ne\n\na\n\nassq\nb\ne\n\nb\n\nassq\nd\ne\n\nf\nassq\nlist\na\na\nb\nc\n\nf\nassoc\nlist\na\na\nb\nc\n\na\nassq\n\nunsp\ne\ncie\nd\nassv\n\nR\nationale\nAlthough\nthey\nare\nordinarily\nused\nas\npredicates\nmemq\nmemv\nmember\nassq\nassv\nand\nassoc\ndo\nnot\nha\nv\ne\nquestion\nmarks\nin\ntheir\nnames\nb\necause\nthey\nreturn\nuseful\nv\nalues\nrather\nthan\njust\nt\nor\nf\n\nRevised\n\nSc\nheme\n\nSym\nb\nols\nSym\nb\nols\nare\nob\njects\nwhose\nusefulness\nrests\non\nthe\nfact\nthat\nt\nw\no\nsym\nb\nols\nare\niden\ntical\nin\nthe\nsense\nof\neqv\nif\nand\nonly\nif\ntheir\nnames\nare\nsp\nelled\nthe\nsame\nw\na\ny\n\nThis\nis\nexactly\nthe\nprop\nert\ny\nneeded\nto\nrepresen\nt\niden\ntiers\nin\nprograms\nand\nso\nmost\nimplemen\ntations\nof\nSc\nheme\nuse\nthem\nin\nternally\nfor\nthat\npurp\nose\nSym\nb\nols\nare\nuseful\nfor\nman\ny\nother\napplica\ntions\nfor\ninstance\nthey\nma\ny\nb\ne\nused\nthe\nw\na\ny\nen\numerated\nv\nalues\nare\nused\nin\nP\nascal\nThe\nrules\nfor\nwriting\na\nsym\nb\nol\nare\nexactly\nthe\nsame\nas\nthe\nrules\nfor\nwriting\nan\niden\ntier\nsee\nsections\n\nand\n\nIt\nis\nguaran\nteed\nthat\nan\ny\nsym\nb\nol\nthat\nhas\nb\neen\nreturned\nas\npart\nof\na\nliteral\nexpression\nor\nread\nusing\nthe\nread\npro\nce\ndure\nand\nsubsequen\ntly\nwritten\nout\nusing\nthe\nwrite\npro\nce\ndure\nwill\nread\nbac\nk\nin\nas\nthe\niden\ntical\nsym\nb\nol\nin\nthe\nsense\nof\neqv\nThe\nstringsymbol\npro\ncedure\nho\nw\nev\ner\ncan\ncreate\nsym\nb\nols\nfor\nwhic\nh\nthis\nwriteread\nin\nv\nariance\nma\ny\nnot\nhold\nb\necause\ntheir\nnames\ncon\ntain\nsp\necial\nc\nharacters\nor\nletters\nin\nthe\nnonstandard\ncase\nNote\nSome\nimplemen\ntations\nof\nSc\nheme\nha\nv\ne\na\nfeature\nkno\nwn\nas\nslashication\nin\norder\nto\nguaran\ntee\nwriteread\nin\nv\nariance\nfor\nall\nsym\nb\nols\nbut\nhistorically\nthe\nmost\nimp\nortan\nt\nuse\nof\nthis\nfeature\nhas\nb\neen\nto\ncomp\nensate\nfor\nthe\nlac\nk\nof\na\nstring\ndata\nt\nyp\ne\nSome\nimplemen\ntations\nalso\nha\nv\ne\nunin\nterned\nsym\nb\nols\nwhic\nh\ndefeat\nwriteread\nin\nv\nariance\nev\nen\nin\nimplemen\ntations\nwith\nslashication\nand\nalso\ngenerate\nexceptions\nto\nthe\nrule\nthat\nt\nw\no\nsym\nb\nols\nare\nthe\nsame\nif\nand\nonly\nif\ntheir\nnames\nare\nsp\nelled\nthe\nsame\nsymbol\nobj\n\npro\ncedure\nReturns\nt\nif\nobj\nis\na\nsym\nb\nol\notherwise\nreturns\nf\nsymbol\nfoo\n\nt\nsymbol\ncar\na\nb\n\nt\nsymbol\nbar\n\nf\nsymbol\nnil\n\nt\nsymbol\n\nf\nsymbol\nf\n\nf\nsymbolstring\nsymb\nol\n\npro\ncedure\nReturns\nthe\nname\nof\nsymb\nol\nas\na\nstring\nIf\nthe\nsym\nb\nol\nw\nas\npart\nof\nan\nob\nject\nreturned\nas\nthe\nv\nalue\nof\na\nliteral\nexpres\nsion\nsection\n\nor\nb\ny\na\ncall\nto\nthe\nread\npro\ncedure\nand\nits\nname\ncon\ntains\nalphab\netic\nc\nharacters\nthen\nthe\nstring\nreturned\nwill\ncon\ntain\nc\nharacters\nin\nthe\nimplemen\ntations\npreferred\nstandard\ncase#some\nimplemen\ntations\nwill\nprefer\nupp\ner\ncase\nothers\nlo\nw\ner\ncase\nIf\nthe\nsym\nb\nol\nw\nas\nreturned\nb\ny\nstringsymbol\nthe\ncase\nof\nc\nharacters\nin\nthe\nstring\nreturned\nwill\nb\ne\nthe\nsame\nas\nthe\ncase\nin\nthe\nstring\nthat\nw\nas\npassed\nto\nstringsymbol\nIt\nis\nan\nerror\nto\napply\nm\nutation\npro\ncedures\nlik\ne\nstringset\nto\nstrings\nreturned\nb\ny\nthis\npro\ncedure\nThe\nfollo\nwing\nexamples\nassume\nthat\nthe\nimplemen\ntations\nstandard\ncase\nis\nlo\nw\ner\ncase\nsymbol string\nflyingfish\n\nflyingfish\nsymbol string\nMartin\n\nmartin\nsymbol string\nstring symbol\nMalvina\n\nMalvina\nstringsymbol\nstring\n\npro\ncedure\nReturns\nthe\nsym\nb\nol\nwhose\nname\nis\nstring\n\nThis\npro\ncedure\ncan\ncreate\nsym\nb\nols\nwith\nnames\ncon\ntaining\nsp\necial\nc\nharac\nters\nor\nletters\nin\nthe\nnonstandard\ncase\nbut\nit\nis\nusually\na\nbad\nidea\nto\ncreate\nsuc\nh\nsym\nb\nols\nb\necause\nin\nsome\nimple\nmen\ntations\nof\nSc\nheme\nthey\ncannot\nb\ne\nread\nas\nthemselv\nes\nSee\nsymbolstring\nThe\nfollo\nwing\nexamples\nassume\nthat\nthe\nimplemen\ntations\nstandard\ncase\nis\nlo\nw\ner\ncase\neq\nmISSISSIppi\nmississippi\n\nt\nstring symbol\nmISSISSIppi\n\nthe\nsym\nb\nol\nwith\nname\nmISSISSIppi\neq\nbitBlt\nstring symbol\nbitBlt\n\nf\neq\nJollyWog\nstring symbol\nsymbol string\nJollyWog\n\nt\nstring\nK\nHarper$\nMD\nsymbol string\nstring symbol\nK\nHarper$\nMD\n\nt\n\nCharacters\nCharacters\nare\nob\njects\nthat\nrepresen\nt\nprin\nted\nc\nharacters\nsuc\nh\nas\nletters\nand\ndigits\nCharacters\nare\nwritten\nusing\nthe\nnotation\nhc\nharacteri\nor\nhc\nharacter\nnamei\nF\nor\nexam\nple\na\n\nlo\nw\ner\ncase\nletter\nA\n\nupp\ner\ncase\nletter\n\nleft\nparen\nthesis\n\nthe\nspace\nc\nharacter\nspace\n\nthe\npreferred\nw\na\ny\nto\nwrite\na\nspace\nnewline\n\nthe\nnewline\nc\nharacter\nCase\nis\nsignican\nt\nin\nhc\nharacteri\n\nbut\nnot\nin\nhc\nharacter\nnamei\nIf\nhc\nharacteri\nin\nhc\nharacteri\nis\nalphab\netic\nthen\nthe\nc\nharacter\nfollo\nwing\nhc\nharacteri\nm\nust\nb\ne\na\ndelimiter\nc\nharacter\nsuc\nh\nas\na\nspace\nor\nparen\nthesis\nThis\nrule\nresolv\nes\nthe\nam\nbiguous\ncase\nwhere\nfor\nexample\nthe\nsequence\nof\n\nStandard\npro\ncedures\n\nc\nharacters\nspace\ncould\nb\ne\ntak\nen\nto\nb\ne\neither\na\nrepre\nsen\ntation\nof\nthe\nspace\nc\nharacter\nor\na\nrepresen\ntation\nof\nthe\nc\nharacter\ns\nfollo\nw\ned\nb\ny\na\nrepresen\ntation\nof\nthe\nsym\nb\nol\npace\nCharacters\nwritten\nin\nthe\n\nnotation\nare\nselfev\naluating\nThat\nis\nthey\ndo\nnot\nha\nv\ne\nto\nb\ne\nquoted\nin\nprograms\nSome\nof\nthe\npro\ncedures\nthat\nop\nerate\non\nc\nharacters\nignore\nthe\ndierence\nb\net\nw\neen\nupp\ner\ncase\nand\nlo\nw\ner\ncase\nThe\npro\ncedures\nthat\nignore\ncase\nha\nv\ne\nci\nfor\ncase\ninsensitiv\ne\nem\nb\nedded\nin\ntheir\nnames\nchar\nobj\n\npro\ncedure\nReturns\nt\nif\nobj\nis\na\nc\nharacter\notherwise\nreturns\nf\nchar\nchar\n\nchar\n\npro\ncedure\nchar!\nchar\n\nchar\n\npro\ncedure\nchar\nchar\n\nchar\n\npro\ncedure\nchar!\nchar\n\nchar\n\npro\ncedure\nchar\nchar\n\nchar\n\npro\ncedure\nThese\npro\ncedures\nimp\nose\na\ntotal\nordering\non\nthe\nset\nof\nc\nharacters\nIt\nis\nguaran\nteed\nthat\nunder\nthis\nordering\n\nThe\nupp\ner\ncase\nc\nharacters\nare\nin\norder\nF\nor\nexample\nchar!\nA\nB\nreturns\nt\n\nThe\nlo\nw\ner\ncase\nc\nharacters\nare\nin\norder\nF\nor\nexample\nchar!\na\nb\nreturns\nt\n\nThe\ndigits\nare\nin\norder\nF\nor\nexample\nchar!\n\nreturns\nt\n\nEither\nall\nthe\ndigits\nprecede\nall\nthe\nupp\ner\ncase\nletters\nor\nvice\nv\nersa\n\nEither\nall\nthe\ndigits\nprecede\nall\nthe\nlo\nw\ner\ncase\nletters\nor\nvice\nv\nersa\nSome\nimplemen\ntations\nma\ny\ngeneralize\nthese\npro\ncedures\nto\ntak\ne\nmore\nthan\nt\nw\no\nargumen\nts\nas\nwith\nthe\ncorresp\nonding\nn\numerical\npredicates\ncharci\nchar\n\nchar\n\nlibrary\npro\ncedure\ncharci!\nchar\n\nchar\n\nlibrary\npro\ncedure\ncharci\nchar\n\nchar\n\nlibrary\npro\ncedure\ncharci!\nchar\n\nchar\n\nlibrary\npro\ncedure\ncharci\nchar\n\nchar\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nare\nsimilar\nto\nchar\net\ncetera\nbut\nthey\ntreat\nupp\ner\ncase\nand\nlo\nw\ner\ncase\nletters\nas\nthe\nsame\nF\nor\nexample\ncharci\nA\na\nreturns\nt\nSome\nimple\nmen\ntations\nma\ny\ngeneralize\nthese\npro\ncedures\nto\ntak\ne\nmore\nthan\nt\nw\no\nargumen\nts\nas\nwith\nthe\ncorresp\nonding\nn\numerical\npredicates\ncharalphabetic\nchar\n\nlibrary\npro\ncedure\ncharnumeric\nchar\n\nlibrary\npro\ncedure\ncharwhitespace\nchar\n\nlibrary\npro\ncedure\ncharuppercase\nletter\n\nlibrary\npro\ncedure\ncharlowercase\nletter\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nreturn\nt\nif\ntheir\nargumen\nts\nare\nalpha\nb\netic\nn\numeric\nwhitespace\nupp\ner\ncase\nor\nlo\nw\ner\ncase\nc\nhar\nacters\nresp\nectiv\nely\n\notherwise\nthey\nreturn\nf\nThe\nfollo\nw\ning\nremarks\nwhic\nh\nare\nsp\necic\nto\nthe\nASCI\nI\nc\nharacter\nset\nare\nin\ntended\nonly\nas\na\nguide\nThe\nalphab\netic\nc\nharacters\nare\nthe\n\nupp\ner\nand\nlo\nw\ner\ncase\nletters\nThe\nn\numeric\nc\nharac\nters\nare\nthe\nten\ndecimal\ndigits\nThe\nwhitespace\nc\nharacters\nare\nspace\ntab\nline\nfeed\nform\nfeed\nand\ncarriage\nreturn\ncharinteger\nchar\n\npro\ncedure\nintegerchar\nn\npro\ncedure\nGiv\nen\na\nc\nharacter\ncharinteger\nreturns\nan\nexact\nin\nte\nger\nrepresen\ntation\nof\nthe\nc\nharacter\nGiv\nen\nan\nexact\nin\nte\nger\nthat\nis\nthe\nimage\nof\na\nc\nharacter\nunder\ncharinteger\nintegerchar\nreturns\nthat\nc\nharacter\nThese\npro\ncedures\nimplemen\nt\norderpreserving\nisomorphisms\nb\net\nw\neen\nthe\nset\nof\nc\nharacters\nunder\nthe\nchar!\nordering\nand\nsome\nsubset\nof\nthe\nin\ntegers\nunder\nthe\n!\nordering\nThat\nis\nif\nchar\na\nb\n\nt\nand\n\nx\ny\n\nt\nand\nx\nand\ny\nare\nin\nthe\ndomain\nof\nintegerchar\nthen\n\nchar integer\na\n\nchar integer\nb\n\nt\nchar\ninteger char\nx\n\ninteger char\ny\n\nt\ncharupcase\nchar\n\nlibrary\npro\ncedure\nchardowncase\nchar\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nreturn\na\nc\nharacter\nchar\n\nsuc\nh\nthat\ncharci\nchar\nchar\n\nIn\naddition\nif\nchar\nis\nalpha\nb\netic\nthen\nthe\nresult\nof\ncharupcase\nis\nupp\ner\ncase\nand\nthe\nresult\nof\nchardowncase\nis\nlo\nw\ner\ncase\n\nStrings\nStrings\nare\nsequences\nof\nc\nharacters\nStrings\nare\nwritten\nas\nsequences\nof\nc\nharacters\nenclosed\nwithin\ndoublequotes\n\nA\ndoublequote\ncan\nb\ne\nwritten\ninside\na\nstring\nonly\nb\ny\nescaping\nit\nwith\na\nbac\nkslash\n\nas\nin\nThe\nword\n% recursion%\nhas\nmany\nmeanings\nA\nbac\nkslash\ncan\nb\ne\nwritten\ninside\na\nstring\nonly\nb\ny\nescaping\nit\nwith\nanother\nbac\nkslash\nSc\nheme\ndo\nes\nnot\nsp\necify\nthe\neect\nof\na\nbac\nkslash\nwithin\na\nstring\nthat\nis\nnot\nfollo\nw\ned\nb\ny\na\ndoublequote\nor\nbac\nkslash\n\nRevised\n\nSc\nheme\nA\nstring\nconstan\nt\nma\ny\ncon\ntin\nue\nfrom\none\nline\nto\nthe\nnext\nbut\nthe\nexact\ncon\nten\nts\nof\nsuc\nh\na\nstring\nare\nunsp\necied\nThe\nlength\nof\na\nstring\nis\nthe\nn\num\nb\ner\nof\nc\nharacters\nthat\nit\ncon\ntains\nThis\nn\num\nb\ner\nis\nan\nexact\nnonnegativ\ne\nin\nteger\nthat\nis\nxed\nwhen\nthe\nstring\nis\ncreated\nThe\nvalid\nindexes\nof\na\nstring\nare\nthe\nexact\nnonnegativ\ne\nin\ntegers\nless\nthan\nthe\nlength\nof\nthe\nstring\nThe\nrst\nc\nharacter\nof\na\nstring\nhas\nindex\n\nthe\nsecond\nhas\nindex\n\nand\nso\non\nIn\nphrases\nsuc\nh\nas\nthe\nc\nharacters\nof\nstring\nb\neginning\nwith\nindex\nstart\nand\nending\nwith\nindex\nend\n\nit\nis\nundersto\no\nd\nthat\nthe\nindex\nstart\nis\ninclusiv\ne\nand\nthe\nindex\nend\nis\nex\nclusiv\ne\nTh\nus\nif\nstart\nand\nend\nare\nthe\nsame\nindex\na\nn\null\nsubstring\nis\nreferred\nto\nand\nif\nstart\nis\nzero\nand\nend\nis\nthe\nlength\nof\nstring\n\nthen\nthe\nen\ntire\nstring\nis\nreferred\nto\nSome\nof\nthe\npro\ncedures\nthat\nop\nerate\non\nstrings\nignore\nthe\ndierence\nb\net\nw\neen\nupp\ner\nand\nlo\nw\ner\ncase\nThe\nv\nersions\nthat\nignore\ncase\nha\nv\ne\nci\nfor\ncase\ninsensitiv\ne\nem\nb\nedded\nin\ntheir\nnames\nstring\nobj\n\npro\ncedure\nReturns\nt\nif\nobj\nis\na\nstring\notherwise\nreturns\nf\nmakestring\nk\n\npro\ncedure\nmakestring\nk\nchar\n\npro\ncedure\nMakestring\nreturns\na\nnewly\nallo\ncated\nstring\nof\nlength\nk\n\nIf\nchar\nis\ngiv\nen\nthen\nall\nelemen\nts\nof\nthe\nstring\nare\nini\ntialized\nto\nchar\n\notherwise\nthe\ncon\nten\nts\nof\nthe\nstring\nare\nunsp\necied\nstring\nchar\n\nlibrary\npro\ncedure\nReturns\na\nnewly\nallo\ncated\nstring\ncomp\nosed\nof\nthe\nargu\nmen\nts\nstringlength\nstring\n\npro\ncedure\nReturns\nthe\nn\num\nb\ner\nof\nc\nharacters\nin\nthe\ngiv\nen\nstring\n\nstringref\nstring\nk\n\npro\ncedure\nk\nm\nust\nb\ne\na\nv\nalid\nindex\nof\nstring\n\nStringref\nreturns\nc\nharacter\nk\nof\nstring\nusing\nzeroorigin\nindexing\nstringset\nstring\nk\nchar\n\npro\ncedure\nk\nm\nust\nb\ne\na\nv\nalid\nindex\nof\nstring\n\nStringset\nstores\nchar\nin\nelemen\nt\nk\nof\nstring\nand\nreturns\nan\nunsp\necied\nv\nalue\ndefine\nf\nmakestring\n\n%\ndefine\ng\n\nstringset\nf\n\n%\n\nunsp\ne\ncie\nd\nstringset\ng\n\n%\n\nerr\nor\nstringset\nsymbol string\nimmutable\n\n%\n\nerr\nor\nstring\nstring\n\nstring\n\nlibrary\npro\ncedure\nstringci\nstring\n\nstring\n\nlibrary\npro\ncedure\nReturns\nt\nif\nthe\nt\nw\no\nstrings\nare\nthe\nsame\nlength\nand\ncon\ntain\nthe\nsame\nc\nharacters\nin\nthe\nsame\np\nositions\notherwise\nreturns\nf\nStringci\ntreats\nupp\ner\nand\nlo\nw\ner\ncase\nlet\nters\nas\nthough\nthey\nw\nere\nthe\nsame\nc\nharacter\nbut\nstring\ntreats\nupp\ner\nand\nlo\nw\ner\ncase\nas\ndistinct\nc\nharacters\nstring!\nstring\n\nstring\n\nlibrary\npro\ncedure\nstring\nstring\n\nstring\n\nlibrary\npro\ncedure\nstring!\nstring\n\nstring\n\nlibrary\npro\ncedure\nstring\nstring\n\nstring\n\nlibrary\npro\ncedure\nstringci!\nstring\n\nstring\n\nlibrary\npro\ncedure\nstringci\nstring\n\nstring\n\nlibrary\npro\ncedure\nstringci!\nstring\n\nstring\n\nlibrary\npro\ncedure\nstringci\nstring\n\nstring\n\nlibrary\npro\ncedure\nThese\npro\ncedures\nare\nthe\nlexicographic\nextensions\nto\nstrings\nof\nthe\ncorresp\nonding\norderings\non\nc\nharacters\nF\nor\nexample\nstring!\nis\nthe\nlexicographic\nordering\non\nstrings\ninduced\nb\ny\nthe\nordering\nchar!\non\nc\nharacters\nIf\nt\nw\no\nstrings\ndier\nin\nlength\nbut\nare\nthe\nsame\nup\nto\nthe\nlength\nof\nthe\nshorter\nstring\nthe\nshorter\nstring\nis\nconsidered\nto\nb\ne\nlexicographically\nless\nthan\nthe\nlonger\nstring\nImplemen\ntations\nma\ny\ngeneralize\nthese\nand\nthe\nstring\nand\nstringci\npro\ncedures\nto\ntak\ne\nmore\nthan\nt\nw\no\nargu\nmen\nts\nas\nwith\nthe\ncorresp\nonding\nn\numerical\npredicates\nsubstring\nstring\nstart\nend\n\nlibrary\npro\ncedure\nString\nm\nust\nb\ne\na\nstring\nand\nstart\nand\nend\nm\nust\nb\ne\nexact\nin\ntegers\nsatisfying\n\nstart\n\nend\n\nstringlength\nstring\n\nSubstring\nreturns\na\nnewly\nallo\ncated\nstring\nformed\nfrom\nthe\nc\nharacters\nof\nstring\nb\neginning\nwith\nindex\nstart\ninclu\nsiv\ne\nand\nending\nwith\nindex\nend\nexclusiv\ne\nstringappend\nstring\n\nlibrary\npro\ncedure\nReturns\na\nnewly\nallo\ncated\nstring\nwhose\nc\nharacters\nform\nthe\nconcatenation\nof\nthe\ngiv\nen\nstrings\nstringlist\nstring\n\nlibrary\npro\ncedure\nliststring\nlist\n\nlibrary\npro\ncedure\nStringlist\nreturns\na\nnewly\nallo\ncated\nlist\nof\nthe\nc\nharac\nters\nthat\nmak\ne\nup\nthe\ngiv\nen\nstring\nListstring\nreturns\na\nnewly\nallo\ncated\nstring\nformed\nfrom\nthe\nc\nharacters\nin\nthe\nlist\nlist\n\nwhic\nh\nm\nust\nb\ne\na\nlist\nof\nc\nharacters\nStringlist\nand\nliststring\nare\nin\nv\nerses\nso\nfar\nas\nequal\nis\ncon\ncerned\nstringcopy\nstring\n\nlibrary\npro\ncedure\nReturns\na\nnewly\nallo\ncated\ncop\ny\nof\nthe\ngiv\nen\nstring\n\nStandard\npro\ncedures\n\nstringfill\nstring\nchar\n\nlibrary\npro\ncedure\nStores\nchar\nin\nev\nery\nelemen\nt\nof\nthe\ngiv\nen\nstring\nand\nreturns\nan\nunsp\necied\nv\nalue\n\nV\nectors\nV\nectors\nare\nheterogenous\nstructures\nwhose\nelemen\nts\nare\nin\ndexed\nb\ny\nin\ntegers\nA\nv\nector\nt\nypically\no\nccupies\nless\nspace\nthan\na\nlist\nof\nthe\nsame\nlength\nand\nthe\na\nv\nerage\ntime\nre\nquired\nto\naccess\na\nrandomly\nc\nhosen\nelemen\nt\nis\nt\nypically\nless\nfor\nthe\nv\nector\nthan\nfor\nthe\nlist\nThe\nlength\nof\na\nv\nector\nis\nthe\nn\num\nb\ner\nof\nelemen\nts\nthat\nit\ncon\ntains\nThis\nn\num\nb\ner\nis\na\nnonnegativ\ne\nin\nteger\nthat\nis\nxed\nwhen\nthe\nv\nector\nis\ncreated\nThe\nvalid\nindexes\nof\na\nv\nector\nare\nthe\nexact\nnonnegativ\ne\nin\ntegers\nless\nthan\nthe\nlength\nof\nthe\nv\nector\nThe\nrst\nelemen\nt\nin\na\nv\nector\nis\nindexed\nb\ny\nzero\nand\nthe\nlast\nelemen\nt\nis\nindexed\nb\ny\none\nless\nthan\nthe\nlength\nof\nthe\nv\nector\nV\nectors\nare\nwritten\nusing\nthe\nnotation\nobj\n\nF\nor\nexample\na\nv\nector\nof\nlength\n\ncon\ntaining\nthe\nn\num\nb\ner\nzero\nin\nelemen\nt\n\nthe\nlist\n\nin\nelemen\nt\n\nand\nthe\nstring\nAnna\nin\nelemen\nt\n\ncan\nb\ne\nwritten\nas\nfollo\nwing\n\nAnna\nNote\nthat\nthis\nis\nthe\nexternal\nrepresen\ntation\nof\na\nv\nector\nnot\nan\nexpression\nev\naluating\nto\na\nv\nector\nLik\ne\nlist\nconstan\nts\nv\nector\nconstan\nts\nm\nust\nb\ne\nquoted\n\nAnna\n\nAnna\nvector\nobj\n\npro\ncedure\nReturns\nt\nif\nobj\nis\na\nv\nector\notherwise\nreturns\nf\nmakevector\nk\n\npro\ncedure\nmakevector\nk\nl\nl\n\npro\ncedure\nReturns\na\nnewly\nallo\ncated\nv\nector\nof\nk\nelemen\nts\nIf\na\nsecond\nargumen\nt\nis\ngiv\nen\nthen\neac\nh\nelemen\nt\nis\ninitialized\nto\nl\nl\n\nOtherwise\nthe\ninitial\ncon\nten\nts\nof\neac\nh\nelemen\nt\nis\nunsp\neci\ned\nvector\nobj\n\nlibrary\npro\ncedure\nReturns\na\nnewly\nallo\ncated\nv\nector\nwhose\nelemen\nts\ncon\ntain\nthe\ngiv\nen\nargumen\nts\nAnalogous\nto\nlist\nvector\na\nb\nc\n\na\nb\nc\nvectorlength\nve\nctor\n\npro\ncedure\nReturns\nthe\nn\num\nb\ner\nof\nelemen\nts\nin\nve\nctor\nas\nan\nexact\nin\nteger\nvectorref\nve\nctor\nk\n\npro\ncedure\nk\nm\nust\nb\ne\na\nv\nalid\nindex\nof\nve\nctor\n\nVectorref\nreturns\nthe\ncon\nten\nts\nof\nelemen\nt\nk\nof\nve\nctor\n\nvectorref\n\nvectorref\n\nlet\ni\nround\n\nacos\n\nif\ninexact\ni\ninexact exact\ni\ni\n\nvectorset\nve\nctor\nk\nobj\n\npro\ncedure\nk\nm\nust\nb\ne\na\nv\nalid\nindex\nof\nve\nctor\n\nVectorset\nstores\nobj\nin\nelemen\nt\nk\nof\nve\nctor\n\nThe\nv\nalue\nreturned\nb\ny\nvectorset\nis\nunsp\necied\nlet\nvec\nvector\n\nAnna\nvectorset\nvec\n\nSue\nSue\nvec\n\nSue\nSue\nAnna\nvectorset\n\ndoe\n\nerr\nor\n\nconstant\nvector\nvectorlist\nve\nctor\n\nlibrary\npro\ncedure\nlistvector\nlist\n\nlibrary\npro\ncedure\nVectorlist\nreturns\na\nnewly\nallo\ncated\nlist\nof\nthe\nob\njects\ncon\ntained\nin\nthe\nelemen\nts\nof\nve\nctor\n\nListvector\nreturns\na\nnewly\ncreated\nv\nector\ninitialized\nto\nthe\nelemen\nts\nof\nthe\nlist\nlist\n\nvector list\ndah\ndah\ndidah\n\ndah\ndah\ndidah\nlist vector\ndididit\ndah\n\ndididit\ndah\nvectorfill\nve\nctor\nl\nl\n\nlibrary\npro\ncedure\nStores\nl\nl\nin\nev\nery\nelemen\nt\nof\nve\nctor\n\nThe\nv\nalue\nreturned\nb\ny\nvectorfill\nis\nunsp\necied\n\nCon\ntrol\nfeatures\nThis\nc\nhapter\ndescrib\nes\nv\narious\nprimitiv\ne\npro\ncedures\nwhic\nh\ncon\ntrol\nthe\no\nw\nof\nprogram\nexecution\nin\nsp\necial\nw\na\nys\nThe\nprocedure\npredicate\nis\nalso\ndescrib\ned\nhere\nprocedure\nobj\n\npro\ncedure\nReturns\nt\nif\nobj\nis\na\npro\ncedure\notherwise\nreturns\nf\nprocedure\ncar\n\nt\nprocedure\ncar\n\nf\nprocedure\nlambda\nx\n\nx\nx\n\nt\nprocedure\nlambda\nx\n\nx\nx\n\nf\ncallwithcurrentcontinuat\nion\nprocedure\n\nt\n\nRevised\n\nSc\nheme\napply\npr\no\nc\nar\ng\n\nar\ngs\n\npro\ncedure\nPr\no\nc\nm\nust\nb\ne\na\npro\ncedure\nand\nar\ngs\nm\nust\nb\ne\na\nlist\nCalls\npr\no\nc\nwith\nthe\nelemen\nts\nof\nthe\nlist\nappend\nlist\nar\ng\n\nar\ngs\n\nas\nthe\nactual\nargumen\nts\napply\n\nlist\n\ndefine\ncompose\nlambda\nf\ng\nlambda\nargs\nf\napply\ng\nargs\ncompose\nsqrt\n\nmap\npr\no\nc\nlist\n\nlist\n\nlibrary\npro\ncedure\nThe\nlist\ns\nm\nust\nb\ne\nlists\nand\npr\no\nc\nm\nust\nb\ne\na\npro\ncedure\ntaking\nas\nman\ny\nargumen\nts\nas\nthere\nare\nlists\nand\nreturning\na\nsingle\nv\nalue\nIf\nmore\nthan\none\nlist\nis\ngiv\nen\nthen\nthey\nm\nust\nall\nb\ne\nthe\nsame\nlength\nMap\napplies\npr\no\nc\nelemen\ntwise\nto\nthe\nelemen\nts\nof\nthe\nlist\ns\nand\nreturns\na\nlist\nof\nthe\nresults\nin\norder\nThe\ndynamic\norder\nin\nwhic\nh\npr\no\nc\nis\napplied\nto\nthe\nelemen\nts\nof\nthe\nlist\ns\nis\nunsp\necied\nmap\ncadr\na\nb\nd\ne\ng\nh\n\nb\ne\nh\nmap\nlambda\nn\nexpt\nn\nn\n\nmap\n\nlet\ncount\n\nmap\nlambda\nignored\nset\ncount\n\ncount\n\ncount\na\nb\n\nor\n\nforeach\npr\no\nc\nlist\n\nlist\n\nlibrary\npro\ncedure\nThe\nargumen\nts\nto\nforeach\nare\nlik\ne\nthe\nargumen\nts\nto\nmap\nbut\nforeach\ncalls\npr\no\nc\nfor\nits\nside\neects\nrather\nthan\nfor\nits\nv\nalues\nUnlik\ne\nmap\nforeach\nis\nguaran\nteed\nto\ncall\npr\no\nc\non\nthe\nelemen\nts\nof\nthe\nlist\ns\nin\norder\nfrom\nthe\nrst\nele\nmen\nts\nto\nthe\nlast\nand\nthe\nv\nalue\nreturned\nb\ny\nforeach\nis\nunsp\necied\nlet\nv\nmakevector\n\nforeach\nlambda\ni\nvectorset\nv\ni\n\ni\ni\n\nv\n\nforce\npr\nomise\n\nlibrary\npro\ncedure\nF\norces\nthe\nv\nalue\nof\npr\nomise\nsee\ndelay\nsection\n\nIf\nno\nv\nalue\nhas\nb\neen\ncomputed\nfor\nthe\npromise\nthen\na\nv\nalue\nis\ncomputed\nand\nreturned\nThe\nv\nalue\nof\nthe\npromise\nis\ncac\nhed\nor\nmemoized\nso\nthat\nif\nit\nis\nforced\na\nsecond\ntime\nthe\npreviously\ncomputed\nv\nalue\nis\nreturned\nforce\ndelay\n\nlet\np\ndelay\n\nlist\nforce\np\nforce\np\n\ndefine\nastream\nletrec\nnext\nlambda\nn\ncons\nn\ndelay\nnext\n\nn\n\nnext\n\ndefine\nhead\ncar\ndefine\ntail\nlambda\nstream\nforce\ncdr\nstream\nhead\ntail\ntail\nastream\n\nForce\nand\ndelay\nare\nmainly\nin\ntended\nfor\nprograms\nwritten\nin\nfunctional\nst\nyle\nThe\nfollo\nwing\nexamples\nshould\nnot\nb\ne\nconsidered\nto\nillustrate\ngo\no\nd\nprogramming\nst\nyle\nbut\nthey\nillustrate\nthe\nprop\nert\ny\nthat\nonly\none\nv\nalue\nis\ncomputed\nfor\na\npromise\nno\nmatter\nho\nw\nman\ny\ntimes\nit\nis\nforced\ndefine\ncount\n\ndefine\np\ndelay\nbegin\nset\ncount\n\ncount\n\nif\n\ncount\nx\ncount\nforce\np\ndefine\nx\n\np\n\na\npr\nomise\nforce\np\n\np\n\na\npr\nomise\nstil\nl\nbegin\nset\nx\n\nforce\np\n\nHere\nis\na\np\nossible\nimplemen\ntation\nof\ndelay\nand\nforce\nPromises\nare\nimplemen\nted\nhere\nas\npro\ncedures\nof\nno\nargu\nmen\nts\nand\nforce\nsimply\ncalls\nits\nargumen\nt\ndefine\nforce\nlambda\nobject\nobject\nW\ne\ndene\nthe\nexpression\ndelay\nhexpressioni\nto\nha\nv\ne\nthe\nsame\nmeaning\nas\nthe\npro\ncedure\ncall\nmakepromise\nlambda\n\nhexpressioni\nas\nfollo\nws\ndefinesyntax\ndelay\nsyntaxrules\n\ndelay\nexpression\nmakepromise\nlambda\n\nexpression$\n\nStandard\npro\ncedures\n\nwhere\nmakepromise\nis\ndened\nas\nfollo\nws\ndefine\nmakepromise\nlambda\nproc\nlet\nresultready\nf\nresult\nf\nlambda\n\nif\nresultready\nresult\nlet\nx\nproc\nif\nresultready\nresult\nbegin\nset\nresultready\nt\nset\nresult\nx\nresult\nR\nationale\nA\npromise\nma\ny\nrefer\nto\nits\no\nwn\nv\nalue\nas\nin\nthe\nlast\nexample\nab\no\nv\ne\nF\norcing\nsuc\nh\na\npromise\nma\ny\ncause\nthe\npromise\nto\nb\ne\nforced\na\nsecond\ntime\nb\nefore\nthe\nv\nalue\nof\nthe\nrst\nforce\nhas\nb\neen\ncomputed\nThis\ncomplicates\nthe\ndenition\nof\nmakepromise\nV\narious\nextensions\nto\nthis\nseman\ntics\nof\ndelay\nand\nforce\nare\nsupp\norted\nin\nsome\nimplemen\ntations\n\nCalling\nforce\non\nan\nob\nject\nthat\nis\nnot\na\npromise\nma\ny\nsimply\nreturn\nthe\nob\nject\n\nIt\nma\ny\nb\ne\nthe\ncase\nthat\nthere\nis\nno\nmeans\nb\ny\nwhic\nh\na\npromise\ncan\nb\ne\nop\nerationally\ndistinguished\nfrom\nits\nforced\nv\nalue\nThat\nis\nexpressions\nlik\ne\nthe\nfollo\nwing\nma\ny\nev\naluate\nto\neither\nt\nor\nto\nf\ndep\nending\non\nthe\nimplemen\ntation\neqv\ndelay\n\nunsp\ne\ncie\nd\npair\ndelay\ncons\n\nunsp\ne\ncie\nd\n\nSome\nimplemen\ntations\nma\ny\nimplemen\nt\nimplicit\nforc\ning\nwhere\nthe\nv\nalue\nof\na\npromise\nis\nforced\nb\ny\nprimi\ntiv\ne\npro\ncedures\nlik\ne\ncdr\nand\n$\n\ndelay\n\ncallwithcurre\nnt\nco\nnt\ninu\nat\nion\npr\no\nc\n\npro\ncedure\nPr\no\nc\nm\nust\nb\ne\na\npro\ncedure\nof\none\nargumen\nt\nThe\npro\ncedure\ncallwithcurren\ntc\non\nti\nnua\nti\non\npac\nk\nages\nup\nthe\ncur\nren\nt\ncon\ntin\nuation\nsee\nthe\nrationale\nb\nelo\nw\nas\nan\nescap\ne\npro\ncedure\nand\npasses\nit\nas\nan\nargumen\nt\nto\npr\no\nc\n\nThe\nes\ncap\ne\npro\ncedure\nis\na\nSc\nheme\npro\ncedure\nthat\nif\nit\nis\nlater\ncalled\nwill\nabandon\nwhatev\ner\ncon\ntin\nuation\nis\nin\neect\nat\nthat\nlater\ntime\nand\nwill\ninstead\nuse\nthe\ncon\ntin\nuation\nthat\nw\nas\nin\neect\nwhen\nthe\nescap\ne\npro\ncedure\nw\nas\ncreated\nCall\ning\nthe\nescap\ne\npro\ncedure\nma\ny\ncause\nthe\nin\nv\no\ncation\nof\nb\nefor\ne\nand\nafter\nth\nunks\ninstalled\nusing\ndynamicwind\nThe\nescap\ne\npro\ncedure\naccepts\nthe\nsame\nn\num\nb\ner\nof\nar\ngumen\nts\nas\nthe\ncon\ntin\nuation\nto\nthe\noriginal\ncall\nto\ncallwithcurrent\nc\nont\nin\nuat\nio\nn\nExcept\nfor\ncon\ntin\nua\ntions\ncreated\nb\ny\nthe\ncallwithvalues\npro\ncedure\nall\ncon\ntin\nuations\ntak\ne\nexactly\none\nv\nalue\nThe\neect\nof\npassing\nno\nv\nalue\nor\nmore\nthan\none\nv\nalue\nto\ncon\ntin\nuations\nthat\nw\nere\nnot\ncreated\nb\ny\ncallwithvalues\nis\nunsp\necied\nThe\nescap\ne\npro\ncedure\nthat\nis\npassed\nto\npr\no\nc\nhas\nunlimited\nexten\nt\njust\nlik\ne\nan\ny\nother\npro\ncedure\nin\nSc\nheme\nIt\nma\ny\nb\ne\nstored\nin\nv\nariables\nor\ndata\nstructures\nand\nma\ny\nb\ne\ncalled\nas\nman\ny\ntimes\nas\ndesired\nThe\nfollo\nwing\nexamples\nsho\nw\nonly\nthe\nmost\ncommon\nw\na\nys\nin\nwhic\nh\ncallwithcurren\ntc\non\ntin\nua\ntio\nn\nis\nused\nIf\nall\nreal\nuses\nw\nere\nas\nsimple\nas\nthese\nexamples\nthere\nw\nould\nb\ne\nno\nneed\nfor\na\npro\ncedure\nwith\nthe\np\no\nw\ner\nof\ncallwithcurrent\nc\nont\nin\nuat\nio\nn\ncallwithcurrentcontinuat\nion\nlambda\nexit\nforeach\nlambda\nx\nif\nnegative\nx\nexit\nx\n\nt\n\ndefine\nlistlength\nlambda\nobj\ncallwithcurrentcontinuati\non\nlambda\nreturn\nletrec\nr\nlambda\nobj\ncond\nnull\nobj\n\npair\nobj\n\nr\ncdr\nobj\n\nelse\nreturn\nf\nr\nobj\nlistlength\n\nlistlength\na\nb\n\nc\n\nf\nR\nationale\nA\ncommon\nuse\nof\ncallwithcurrentcontinuati\non\nis\nfor\nstructured\nnonlo\ncal\nexits\nfrom\nlo\nops\nor\npro\ncedure\nb\no\ndies\nbut\nin\nfact\ncallwithcurrentcontinuatio\nn\nis\nextremely\nuseful\nfor\nimplemen\nting\na\nwide\nv\nariet\ny\nof\nadv\nanced\ncon\ntrol\nstructures\nWhenev\ner\na\nSc\nheme\nexpression\nis\nev\naluated\nthere\nis\na\nc\nontin\nuation\nw\nan\nting\nthe\nresult\nof\nthe\nexpression\nThe\ncon\ntin\nuation\nrepresen\nts\nan\nen\ntire\ndefault\nfuture\nfor\nthe\ncomputation\nIf\nthe\nexpression\nis\nev\naluated\nat\ntop\nlev\nel\nfor\nexample\nthen\nthe\ncon\ntin\nuation\nmigh\nt\ntak\ne\nthe\nresult\nprin\nt\nit\non\nthe\nscreen\nprompt\nfor\nthe\nnext\ninput\nev\naluate\nit\nand\nso\non\nforev\ner\nMost\nof\nthe\ntime\nthe\ncon\ntin\nuation\nincludes\nactions\nsp\necied\nb\ny\nuser\nco\nde\nas\nin\na\ncon\ntin\nuation\nthat\nwill\ntak\ne\nthe\nresult\nm\nultiply\nit\nb\ny\nthe\nv\nalue\nstored\nin\na\nlo\ncal\nv\nariable\nadd\nsev\nen\nand\ngiv\ne\nthe\nansw\ner\nto\nthe\ntop\nlev\nel\ncon\ntin\nuation\nto\nb\ne\nprin\nted\nNormally\nthese\nubiquitous\ncon\ntin\nuations\nare\nhidden\nb\nehind\nthe\nscenes\nand\npro\ngrammers\ndo\nnot\nthink\nm\nuc\nh\nab\nout\nthem\nOn\nrare\no\nccasions\nho\nw\nev\ner\na\nprogrammer\nma\ny\nneed\nto\ndeal\nwith\ncon\ntin\nuations\nex\nplicitly\n\nCallwithcurrentcontinuati\non\nallo\nws\nSc\nheme\npro\n\nRevised\n\nSc\nheme\ngrammers\nto\ndo\nthat\nb\ny\ncreating\na\npro\ncedure\nthat\nacts\njust\nlik\ne\nthe\ncurren\nt\ncon\ntin\nuation\nMost\nprogramming\nlanguages\nincorp\norate\none\nor\nmore\nsp\necial\npurp\nose\nescap\ne\nconstructs\nwith\nnames\nlik\ne\nexit\nreturn\n\nor\nev\nen\ngoto\nIn\n\nho\nw\nev\ner\nP\neter\nLandin\n\nin\nv\nen\nted\na\ngeneral\npurp\nose\nescap\ne\nop\nerator\ncalled\nthe\nJop\nerator\nJohn\nReynolds\n\ndescrib\ned\na\nsimpler\nbut\nequally\np\no\nw\nerful\ncon\nstruct\nin\n\nThe\ncatch\nsp\necial\nform\ndescrib\ned\nb\ny\nSussman\nand\nSteele\nin\nthe\n\nrep\nort\non\nSc\nheme\nis\nexactly\nthe\nsame\nas\nReynoldss\nconstruct\nthough\nits\nname\ncame\nfrom\na\nless\ngeneral\nconstruct\nin\nMacLisp\nSev\neral\nSc\nheme\nimplemen\ntors\nnoticed\nthat\nthe\nfull\np\no\nw\ner\nof\nthe\ncatch\nconstruct\ncould\nb\ne\npro\nvided\nb\ny\na\npro\ncedure\ninstead\nof\nb\ny\na\nsp\necial\nsyn\ntactic\nconstruct\nand\nthe\nname\ncallwithcurrentcontinuation\nw\nas\ncoined\nin\n\nThis\nname\nis\ndescriptiv\ne\nbut\nopinions\ndier\non\nthe\nmerits\nof\nsuc\nh\na\nlong\nname\nand\nsome\np\neople\nuse\nthe\nname\ncallcc\nin\nstead\nvalues\nobj\n\npro\ncedure\nDeliv\ners\nall\nof\nits\nargumen\nts\nto\nits\ncon\ntin\nuation\nExcept\nfor\ncon\ntin\nuations\ncreated\nb\ny\nthe\ncallwithvalues\npro\ncedure\nall\ncon\ntin\nuations\ntak\ne\nexactly\none\nv\nalue\nValues\nmigh\nt\nb\ne\ndened\nas\nfollo\nws\ndefine\nvalues\n\nthings\ncallwithcurrentcontinua\ntion\nlambda\ncont\napply\ncont\nthings\ncallwithvalue\ns\npr\no\nduc\ner\nc\nonsumer\n\npro\ncedure\nCalls\nits\npr\no\nduc\ner\nargumen\nt\nwith\nno\nv\nalues\nand\na\ncon\ntin\nuation\nthat\nwhen\npassed\nsome\nv\nalues\ncalls\nthe\nc\nonsumer\npro\ncedure\nwith\nthose\nv\nalues\nas\nargumen\nts\nThe\ncon\ntin\nua\ntion\nfor\nthe\ncall\nto\nc\nonsumer\nis\nthe\ncon\ntin\nuation\nof\nthe\ncall\nto\ncallwithvalues\ncallwithvalues\nlambda\n\nvalues\n\nlambda\na\nb\nb\n\ncallwithvalues\n\ndynamicwind\nb\nefor\ne\nthunk\nafter\n\npro\ncedure\nCalls\nthunk\nwithout\nargumen\nts\nreturning\nthe\nresults\nof\nthis\ncall\nBefor\ne\nand\nafter\nare\ncalled\nalso\nwithout\nar\ngumen\nts\nas\nrequired\nb\ny\nthe\nfollo\nwing\nrules\nnote\nthat\nin\nthe\nabsence\nof\ncalls\nto\ncon\ntin\nuations\ncaptured\nusing\ncallwithcurren\ntc\non\nti\nnua\nti\non\nthe\nthree\nargumen\nts\nare\ncalled\nonce\neac\nh\nin\norder\nBefor\ne\nis\ncalled\nwhenev\ner\nexecution\nen\nters\nthe\ndynamic\nexten\nt\nof\nthe\ncall\nto\nthunk\nand\nafter\nis\ncalled\nwhenev\ner\nit\nexits\nthat\ndynamic\nexten\nt\nThe\ndynamic\nexten\nt\nof\na\npro\ncedure\ncall\nis\nthe\np\nerio\nd\nb\ne\nt\nw\neen\nwhen\nthe\ncall\nis\ninitiated\nand\nwhen\nit\nreturns\nIn\nSc\nheme\nb\necause\nof\ncallwithcurrent\nco\nnt\nin\nuat\nio\nn\nthe\ndynamic\nexten\nt\nof\na\ncall\nma\ny\nnot\nb\ne\na\nsingle\nconnected\ntime\np\nerio\nd\nIt\nis\ndened\nas\nfollo\nws\n\nThe\ndynamic\nexten\nt\nis\nen\ntered\nwhen\nexecution\nof\nthe\nb\no\ndy\nof\nthe\ncalled\npro\ncedure\nb\negins\n\nThe\ndynamic\nexten\nt\nis\nalso\nen\ntered\nwhen\nexe\ncution\nis\nnot\nwithin\nthe\ndynamic\nexten\nt\nand\na\ncon\ntin\nuation\nis\nin\nv\nok\ned\nthat\nw\nas\ncaptured\nusing\ncallwithcurrent\nc\nont\nin\nuat\nio\nn\nduring\nthe\ndy\nnamic\nexten\nt\n\nIt\nis\nexited\nwhen\nthe\ncalled\npro\ncedure\nreturns\n\nIt\nis\nalso\nexited\nwhen\nexecution\nis\nwithin\nthe\ndynamic\nexten\nt\nand\na\ncon\ntin\nuation\nis\nin\nv\nok\ned\nthat\nw\nas\ncaptured\nwhile\nnot\nwithin\nthe\ndynamic\nexten\nt\nIf\na\nsecond\ncall\nto\ndynamicwind\no\nccurs\nwithin\nthe\ndynamic\nexten\nt\nof\nthe\ncall\nto\nthunk\nand\nthen\na\ncon\ntin\nuation\nis\nin\nv\nok\ned\nin\nsuc\nh\na\nw\na\ny\nthat\nthe\nafter\ns\nfrom\nthese\nt\nw\no\nin\nv\no\nca\ntions\nof\ndynamicwind\nare\nb\noth\nto\nb\ne\ncalled\nthen\nthe\nafter\nasso\nciated\nwith\nthe\nsecond\ninner\ncall\nto\ndynamicwind\nis\ncalled\nrst\nIf\na\nsecond\ncall\nto\ndynamicwind\no\nccurs\nwithin\nthe\ndy\nnamic\nexten\nt\nof\nthe\ncall\nto\nthunk\nand\nthen\na\ncon\ntin\nua\ntion\nis\nin\nv\nok\ned\nin\nsuc\nh\na\nw\na\ny\nthat\nthe\nb\nefor\ne\ns\nfrom\nthese\nt\nw\no\nin\nv\no\ncations\nof\ndynamicwind\nare\nb\noth\nto\nb\ne\ncalled\nthen\nthe\nb\nefor\ne\nasso\nciated\nwith\nthe\nrst\nouter\ncall\nto\ndynamicwind\nis\ncalled\nrst\nIf\nin\nv\noking\na\ncon\ntin\nuation\nrequires\ncalling\nthe\nb\nefor\ne\nfrom\none\ncall\nto\ndynamicwind\nand\nthe\nafter\nfrom\nanother\nthen\nthe\nafter\nis\ncalled\nrst\nThe\neect\nof\nusing\na\ncaptured\ncon\ntin\nuation\nto\nen\nter\nor\nexit\nthe\ndynamic\nexten\nt\nof\na\ncall\nto\nb\nefor\ne\nor\nafter\nis\nundened\nlet\npath\n\nc\nf\nlet\nadd\nlambda\ns\nset\npath\ncons\ns\npath\ndynamicwind\nlambda\n\nadd\nconnect\nlambda\n\nadd\ncallwithcurrentcontinuat\nion\nlambda\nc\nset\nc\nc\ntalk\nlambda\n\nadd\ndisconnect\nif\n\nlength\npath\n\nc\ntalk\nreverse\npath\n\nconnect\ntalk\ndisconnect\nconnect\ntalk\ndisconnect\n\nStandard\npro\ncedures\n\nEval\neval\nexpr\nession\nenvir\nonmentsp\ne\ncier\n\npro\ncedure\nEv\naluates\nexpr\nession\nin\nthe\nsp\necied\nen\nvironmen\nt\nand\nre\nturns\nits\nv\nalue\nExpr\nession\nm\nust\nb\ne\na\nv\nalid\nSc\nheme\nexpres\nsion\nrepresen\nted\nas\ndata\nand\nenvir\nonmentsp\ne\ncier\nm\nust\nb\ne\na\nv\nalue\nreturned\nb\ny\none\nof\nthe\nthree\npro\ncedures\nde\nscrib\ned\nb\nelo\nw\nImplemen\ntations\nma\ny\nextend\neval\nto\nallo\nw\nnonexpression\nprograms\ndenitions\nas\nthe\nrst\nargumen\nt\nand\nto\nallo\nw\nother\nv\nalues\nas\nen\nvironmen\nts\nwith\nthe\nre\nstriction\nthat\neval\nis\nnot\nallo\nw\ned\nto\ncreate\nnew\nbindings\nin\nthe\nen\nvironmen\nts\nasso\nciated\nwith\nnullenvironment\nor\nschemereporten\nvir\non\nme\nnt\neval\n\nschemereportenvironment\n\nlet\nf\neval\nlambda\nf\nx\nf\nx\nx\nnullenvironment\n\nf\n\nschemereporte\nnvi\nro\nnm\nent\nversion\n\npro\ncedure\nnullenvironmen\nt\nversion\n\npro\ncedure\nV\nersion\nm\nust\nb\ne\nthe\nexact\nin\nteger\n\ncorresp\nonding\nto\nthis\nrevision\nof\nthe\nSc\nheme\nrep\nort\nthe\nRevised\n\nRep\nort\non\nSc\nheme\nSchemereporten\nvir\non\nmen\nt\nreturns\na\nsp\necier\nfor\nan\nen\nvironmen\nt\nthat\nis\nempt\ny\nexcept\nfor\nall\nbindings\nde\nned\nin\nthis\nrep\nort\nthat\nare\neither\nrequired\nor\nb\noth\noptional\nand\nsupp\norted\nb\ny\nthe\nimplemen\ntation\nNullenvironment\nreturns\na\nsp\necier\nfor\nan\nen\nvironmen\nt\nthat\nis\nempt\ny\nexcept\nfor\nthe\nsyn\ntactic\nbindings\nfor\nall\nsyn\ntactic\nk\neyw\nords\nde\nned\nin\nthis\nrep\nort\nthat\nare\neither\nrequired\nor\nb\noth\noptional\nand\nsupp\norted\nb\ny\nthe\nimplemen\ntation\nOther\nv\nalues\nof\nversion\ncan\nb\ne\nused\nto\nsp\necify\nen\nvironmen\nts\nmatc\nhing\npast\nrevisions\nof\nthis\nrep\nort\nbut\ntheir\nsupp\nort\nis\nnot\nrequired\nAn\nimplemen\ntation\nwill\nsignal\nan\nerror\nif\nversion\nis\nneither\n\nnor\nanother\nv\nalue\nsupp\norted\nb\ny\nthe\nimplemen\ntation\nThe\neect\nof\nassigning\nthrough\nthe\nuse\nof\neval\na\nv\nari\nable\nb\nound\nin\na\nschemereporten\nvi\nro\nnme\nnt\nfor\nexam\nple\ncar\nis\nunsp\necied\nTh\nus\nthe\nen\nvironmen\nts\nsp\necied\nb\ny\nschemereportenv\nir\nonm\nen\nt\nma\ny\nb\ne\nimm\nutable\ninteractionenv\niro\nnm\nen\nt\n\noptional\npro\ncedure\nThis\npro\ncedure\nreturns\na\nsp\necier\nfor\nthe\nen\nvironmen\nt\nthat\ncon\ntains\nimplementationdened\nbindings\nt\nypically\na\nsu\np\nerset\nof\nthose\nlisted\nin\nthe\nrep\nort\nThe\nin\nten\nt\nis\nthat\nthis\npro\ncedure\nwill\nreturn\nthe\nen\nvironmen\nt\nin\nwhic\nh\nthe\nimple\nmen\ntation\nw\nould\nev\naluate\nexpressions\ndynamically\nt\nyp\ned\nb\ny\nthe\nuser\n\nInput\nand\noutput\n\nP\norts\nP\norts\nrepresen\nt\ninput\nand\noutput\ndevices\nT\no\nSc\nheme\nan\ninput\np\nort\nis\na\nSc\nheme\nob\nject\nthat\ncan\ndeliv\ner\nc\nharacters\nup\non\ncommand\nwhile\nan\noutput\np\nort\nis\na\nSc\nheme\nob\nject\nthat\ncan\naccept\nc\nharacters\ncallwithinput\nfi\nle\nstring\npr\no\nc\n\nlibrary\npro\ncedure\ncallwithoutput\nf\nile\nstring\npr\no\nc\n\nlibrary\npro\ncedure\nString\nshould\nb\ne\na\nstring\nnaming\na\nle\nand\npr\no\nc\nshould\nb\ne\na\npro\ncedure\nthat\naccepts\none\nargumen\nt\nF\nor\ncallwithinputf\nil\ne\nthe\nle\nshould\nalready\nexist\nfor\ncallwithoutput\nfi\nle\nthe\neect\nis\nunsp\necied\nif\nthe\nle\nalready\nexists\nThese\npro\ncedures\ncall\npr\no\nc\nwith\none\nar\ngumen\nt\nthe\np\nort\nobtained\nb\ny\nop\nening\nthe\nnamed\nle\nfor\ninput\nor\noutput\nIf\nthe\nle\ncannot\nb\ne\nop\nened\nan\nerror\nis\nsignalled\nIf\npr\no\nc\nreturns\nthen\nthe\np\nort\nis\nclosed\nautomati\ncally\nand\nthe\nv\nalues\nyielded\nb\ny\nthe\npr\no\nc\nisare\nreturned\nIf\npr\no\nc\ndo\nes\nnot\nreturn\nthen\nthe\np\nort\nwill\nnot\nb\ne\nclosed\nautomatically\nunless\nit\nis\np\nossible\nto\npro\nv\ne\nthat\nthe\np\nort\nwill\nnev\ner\nagain\nb\ne\nused\nfor\na\nread\nor\nwrite\nop\neration\nR\nationale\nBecause\nSc\nhemes\nescap\ne\npro\ncedures\nha\nv\ne\nun\nlimited\nexten\nt\nit\nis\np\nossible\nto\nescap\ne\nfrom\nthe\ncurren\nt\ncon\ntin\nuation\nbut\nlater\nto\nescap\ne\nbac\nk\nin\nIf\nimplemen\ntations\nw\nere\np\nermitted\nto\nclose\nthe\np\nort\non\nan\ny\nescap\ne\nfrom\nthe\ncurren\nt\ncon\ntin\nuation\nthen\nit\nw\nould\nb\ne\nimp\nossible\nto\nwrite\np\nortable\nco\nde\nusing\nb\noth\ncallwithcurrentcontinuati\non\nand\ncallwithinputfile\nor\ncallwithoutputfile\ninputport\nobj\n\npro\ncedure\noutputport\nobj\n\npro\ncedure\nReturns\nt\nif\nobj\nis\nan\ninput\np\nort\nor\noutput\np\nort\nresp\nec\ntiv\nely\n\notherwise\nreturns\nf\ncurrentinputpo\nrt\n\npro\ncedure\ncurrentoutputp\nor\nt\n\npro\ncedure\nReturns\nthe\ncurren\nt\ndefault\ninput\nor\noutput\np\nort\nwithinputfrom\nfi\nle\nstring\nthunk\n\noptional\npro\ncedure\nwithoutputtof\nil\ne\nstring\nthunk\n\noptional\npro\ncedure\nString\nshould\nb\ne\na\nstring\nnaming\na\nle\nand\npr\no\nc\nshould\nb\ne\na\npro\ncedure\nof\nno\nargumen\nts\nF\nor\nwithinputfromf\nil\ne\nthe\nle\nshould\nalready\nexist\nfor\nwithoutputtof\nil\ne\nthe\neect\nis\nunsp\necied\nif\nthe\nle\nalready\nexists\nThe\nle\nis\nop\nened\nfor\ninput\nor\noutput\nan\ninput\nor\noutput\np\nort\nconnected\nto\nit\nis\nmade\nthe\ndefault\nv\nalue\nreturned\nb\ny\ncurrentinputpor\nt\nor\ncurrentoutputp\nort\nand\nis\n\nRevised\n\nSc\nheme\nused\nb\ny\nread\nwrite\nobj\n\nand\nso\nforth\nand\nthe\nthunk\nis\ncalled\nwith\nno\nargumen\nts\nWhen\nthe\nthunk\nreturns\nthe\np\nort\nis\nclosed\nand\nthe\nprevious\ndefault\nis\nrestored\nWithinputfrom\nfil\ne\nand\nwithoutputtofi\nle\nre\nturns\nthe\nv\nalues\nyielded\nb\ny\nthunk\n\nIf\nan\nescap\ne\npro\ncedure\nis\nused\nto\nescap\ne\nfrom\nthe\ncon\ntin\nuation\nof\nthese\npro\ncedures\ntheir\nb\neha\nvior\nis\nimplemen\ntation\ndep\nenden\nt\nopeninputfile\nlename\n\npro\ncedure\nT\nak\nes\na\nstring\nnaming\nan\nexisting\nle\nand\nreturns\nan\ninput\np\nort\ncapable\nof\ndeliv\nering\nc\nharacters\nfrom\nthe\nle\nIf\nthe\nle\ncannot\nb\ne\nop\nened\nan\nerror\nis\nsignalled\nopenoutputfil\ne\nlename\n\npro\ncedure\nT\nak\nes\na\nstring\nnaming\nan\noutput\nle\nto\nb\ne\ncreated\nand\nreturns\nan\noutput\np\nort\ncapable\nof\nwriting\nc\nharacters\nto\na\nnew\nle\nb\ny\nthat\nname\nIf\nthe\nle\ncannot\nb\ne\nop\nened\nan\nerror\nis\nsignalled\nIf\na\nle\nwith\nthe\ngiv\nen\nname\nalready\nexists\nthe\neect\nis\nunsp\necied\ncloseinputpor\nt\np\nort\n\npro\ncedure\ncloseoutputpo\nrt\np\nort\n\npro\ncedure\nCloses\nthe\nle\nasso\nciated\nwith\np\nort\n\nrendering\nthe\np\nort\nin\ncapable\nof\ndeliv\nering\nor\naccepting\nc\nharacters\nThese\nrou\ntines\nha\nv\ne\nno\neect\nif\nthe\nle\nhas\nalready\nb\neen\nclosed\nThe\nv\nalue\nreturned\nis\nunsp\necied\n\nInput\nread\n\nlibrary\npro\ncedure\nread\np\nort\n\nlibrary\npro\ncedure\nRead\ncon\nv\nerts\nexternal\nrepresen\ntations\nof\nSc\nheme\nob\njects\nin\nto\nthe\nob\njects\nthemselv\nes\nThat\nis\nit\nis\na\nparser\nfor\nthe\nnon\nterminal\nhdatumi\nsee\nsections\n\nand\n\nRead\nreturns\nthe\nnext\nob\nject\nparsable\nfrom\nthe\ngiv\nen\ninput\np\nort\n\nup\ndating\np\nort\nto\np\noin\nt\nto\nthe\nrst\nc\nharacter\npast\nthe\nend\nof\nthe\nexternal\nrepresen\ntation\nof\nthe\nob\nject\nIf\nan\nend\nof\nle\nis\nencoun\ntered\nin\nthe\ninput\nb\nefore\nan\ny\nc\nhar\nacters\nare\nfound\nthat\ncan\nb\negin\nan\nob\nject\nthen\nan\nend\nof\nle\nob\nject\nis\nreturned\nThe\np\nort\nremains\nop\nen\nand\nfur\nther\nattempts\nto\nread\nwill\nalso\nreturn\nan\nend\nof\nle\nob\nject\nIf\nan\nend\nof\nle\nis\nencoun\ntered\nafter\nthe\nb\neginning\nof\nan\nob\njects\nexternal\nrepresen\ntation\nbut\nthe\nexternal\nrepresen\ntation\nis\nincomplete\nand\ntherefore\nnot\nparsable\nan\nerror\nis\nsignalled\nThe\np\nort\nargumen\nt\nma\ny\nb\ne\nomitted\nin\nwhic\nh\ncase\nit\nde\nfaults\nto\nthe\nv\nalue\nreturned\nb\ny\ncurrentinputpor\nt\nIt\nis\nan\nerror\nto\nread\nfrom\na\nclosed\np\nort\nreadchar\n\npro\ncedure\nreadchar\np\nort\n\npro\ncedure\nReturns\nthe\nnext\nc\nharacter\na\nv\nailable\nfrom\nthe\ninput\np\nort\n\nup\ndating\nthe\np\nort\nto\np\noin\nt\nto\nthe\nfollo\nwing\nc\nharacter\nIf\nno\nmore\nc\nharacters\nare\na\nv\nailable\nan\nend\nof\nle\nob\nject\nis\nreturned\nPort\nma\ny\nb\ne\nomitted\nin\nwhic\nh\ncase\nit\ndefaults\nto\nthe\nv\nalue\nreturned\nb\ny\ncurrentinputp\nort\n\npeekchar\n\npro\ncedure\npeekchar\np\nort\n\npro\ncedure\nReturns\nthe\nnext\nc\nharacter\na\nv\nailable\nfrom\nthe\ninput\np\nort\n\nwithout\nup\ndating\nthe\np\nort\nto\np\noin\nt\nto\nthe\nfollo\nwing\nc\nhar\nacter\nIf\nno\nmore\nc\nharacters\nare\na\nv\nailable\nan\nend\nof\nle\nob\nject\nis\nreturned\nPort\nma\ny\nb\ne\nomitted\nin\nwhic\nh\ncase\nit\ndefaults\nto\nthe\nv\nalue\nreturned\nb\ny\ncurrentinputpor\nt\nNote\nThe\nv\nalue\nreturned\nb\ny\na\ncall\nto\npeekchar\nis\nthe\nsame\nas\nthe\nv\nalue\nthat\nw\nould\nha\nv\ne\nb\neen\nreturned\nb\ny\na\ncall\nto\nreadchar\nwith\nthe\nsame\np\nort\n\nThe\nonly\ndierence\nis\nthat\nthe\nv\nery\nnext\ncall\nto\nreadchar\nor\npeekchar\non\nthat\np\nort\nwill\nreturn\nthe\nv\nalue\nreturned\nb\ny\nthe\npreceding\ncall\nto\npeekchar\nIn\nparticular\na\ncall\nto\npeekchar\non\nan\nin\nteractiv\ne\np\nort\nwill\nhang\nw\naiting\nfor\ninput\nwhenev\ner\na\ncall\nto\nreadchar\nw\nould\nha\nv\ne\nh\nung\neofobject\nobj\n\npro\ncedure\nReturns\nt\nif\nobj\nis\nan\nend\nof\nle\nob\nject\notherwise\nreturns\nf\nThe\nprecise\nset\nof\nend\nof\nle\nob\njects\nwill\nv\nary\namong\nimplemen\ntations\nbut\nin\nan\ny\ncase\nno\nend\nof\nle\nob\nject\nwill\nev\ner\nb\ne\nan\nob\nject\nthat\ncan\nb\ne\nread\nin\nusing\nread\ncharready\n\npro\ncedure\ncharready\np\nort\n\npro\ncedure\nReturns\nt\nif\na\nc\nharacter\nis\nready\non\nthe\ninput\np\nort\nand\nreturns\nf\notherwise\nIf\ncharready\nreturns\nt\nthen\nthe\nnext\nreadchar\nop\neration\non\nthe\ngiv\nen\np\nort\nis\nguaran\nteed\nnot\nto\nhang\nIf\nthe\np\nort\nis\nat\nend\nof\nle\nthen\ncharready\nreturns\nt\nPort\nma\ny\nb\ne\nomitted\nin\nwhic\nh\ncase\nit\ndefaults\nto\nthe\nv\nalue\nreturned\nb\ny\ncurrentinputp\nort\n\nR\nationale\nCharready\nexists\nto\nmak\ne\nit\np\nossible\nfor\na\npro\ngram\nto\naccept\nc\nharacters\nfrom\nin\nteractiv\ne\np\norts\nwithout\ngetting\nstuc\nk\nw\naiting\nfor\ninput\nAn\ny\ninput\neditors\nasso\nciated\nwith\nsuc\nh\np\norts\nm\nust\nensure\nthat\nc\nharacters\nwhose\nexistence\nhas\nb\neen\nas\nserted\nb\ny\ncharready\ncannot\nb\ne\nrubb\ned\nout\nIf\ncharready\nw\nere\nto\nreturn\nf\nat\nend\nof\nle\na\np\nort\nat\nend\nof\nle\nw\nould\nb\ne\nindistinguishable\nfrom\nan\nin\nteractiv\ne\np\nort\nthat\nhas\nno\nready\nc\nharacters\n\nOutput\n\nStandard\npro\ncedures\n\nwrite\nobj\n\nlibrary\npro\ncedure\nwrite\nobj\np\nort\n\nlibrary\npro\ncedure\nW\nrites\na\nwritten\nrepresen\ntation\nof\nobj\nto\nthe\ngiv\nen\np\nort\n\nStrings\nthat\napp\near\nin\nthe\nwritten\nrepresen\ntation\nare\nen\nclosed\nin\ndoublequotes\nand\nwithin\nthose\nstrings\nbac\nkslash\nand\ndoublequote\nc\nharacters\nare\nescap\ned\nb\ny\nbac\nkslashes\nCharacter\nob\njects\nare\nwritten\nusing\nthe\n\nnotation\nWrite\nreturns\nan\nunsp\necied\nv\nalue\nThe\np\nort\nargumen\nt\nma\ny\nb\ne\nomitted\nin\nwhic\nh\ncase\nit\ndefaults\nto\nthe\nv\nalue\nreturned\nb\ny\ncurrentoutputp\nort\n\ndisplay\nobj\n\nlibrary\npro\ncedure\ndisplay\nobj\np\nort\n\nlibrary\npro\ncedure\nW\nrites\na\nrepresen\ntation\nof\nobj\nto\nthe\ngiv\nen\np\nort\n\nStrings\nthat\napp\near\nin\nthe\nwritten\nrepresen\ntation\nare\nnot\nenclosed\nin\ndoublequotes\nand\nno\nc\nharacters\nare\nescap\ned\nwithin\nthose\nstrings\nCharacter\nob\njects\napp\near\nin\nthe\nrepresen\ntation\nas\nif\nwritten\nb\ny\nwritechar\ninstead\nof\nb\ny\nwrite\nDisplay\nreturns\nan\nunsp\necied\nv\nalue\nThe\np\nort\nargumen\nt\nma\ny\nb\ne\nomitted\nin\nwhic\nh\ncase\nit\ndefaults\nto\nthe\nv\nalue\nre\nturned\nb\ny\ncurrentoutputp\nort\n\nR\nationale\nWrite\nis\nin\ntended\nfor\npro\nducing\nmac\nhinereadable\noutput\nand\ndisplay\nis\nfor\npro\nducing\nh\numanreadable\noutput\nImplemen\ntations\nthat\nallo\nw\nslashication\nwithin\nsym\nb\nols\nwill\nprobably\nw\nan\nt\nwrite\nbut\nnot\ndisplay\nto\nslashify\nfunn\ny\nc\nharac\nters\nin\nsym\nb\nols\nnewline\n\nlibrary\npro\ncedure\nnewline\np\nort\n\nlibrary\npro\ncedure\nW\nrites\nan\nend\nof\nline\nto\np\nort\n\nExactly\nho\nw\nthis\nis\ndone\ndiers\nfrom\none\nop\nerating\nsystem\nto\nanother\nReturns\nan\nunsp\necied\nv\nalue\nThe\np\nort\nargumen\nt\nma\ny\nb\ne\nomit\nted\nin\nwhic\nh\ncase\nit\ndefaults\nto\nthe\nv\nalue\nreturned\nb\ny\ncurrentoutputp\nort\n\nwritechar\nchar\n\npro\ncedure\nwritechar\nchar\np\nort\n\npro\ncedure\nW\nrites\nthe\nc\nharacter\nchar\nnot\nan\nexternal\nrepresen\nta\ntion\nof\nthe\nc\nharacter\nto\nthe\ngiv\nen\np\nort\nand\nreturns\nan\nunsp\necied\nv\nalue\nThe\np\nort\nargumen\nt\nma\ny\nb\ne\nomit\nted\nin\nwhic\nh\ncase\nit\ndefaults\nto\nthe\nv\nalue\nreturned\nb\ny\ncurrentoutputp\nort\n\nSystem\nin\nterface\nQuestions\nof\nsystem\nin\nterface\ngenerally\nfall\noutside\nof\nthe\ndomain\nof\nthis\nrep\nort\nHo\nw\nev\ner\nthe\nfollo\nwing\nop\nerations\nare\nimp\nortan\nt\nenough\nto\ndeserv\ne\ndescription\nhere\nload\nlename\n\noptional\npro\ncedure\nFilename\nshould\nb\ne\na\nstring\nnaming\nan\nexisting\nle\ncon\ntaining\nSc\nheme\nsource\nco\nde\nThe\nload\npro\ncedure\nreads\nex\npressions\nand\ndenitions\nfrom\nthe\nle\nand\nev\naluates\nthem\nsequen\ntially\n\nIt\nis\nunsp\necied\nwhether\nthe\nresults\nof\nthe\nexpressions\nare\nprin\nted\nThe\nload\npro\ncedure\ndo\nes\nnot\naect\nthe\nv\nalues\nreturned\nb\ny\ncurrentinputpo\nrt\nand\ncurrentoutputpo\nrt\n\nLoad\nreturns\nan\nunsp\necied\nv\nalue\nR\nationale\nF\nor\np\nortabilit\ny\n\nload\nm\nust\nop\nerate\non\nsource\nles\nIts\nop\neration\non\nother\nkinds\nof\nles\nnecessarily\nv\naries\namong\nimplemen\ntations\ntranscripton\nlename\n\noptional\npro\ncedure\ntranscriptoff\n\noptional\npro\ncedure\nFilename\nm\nust\nb\ne\na\nstring\nnaming\nan\noutput\nle\nto\nb\ne\ncre\nated\nThe\neect\nof\ntranscripton\nis\nto\nop\nen\nthe\nnamed\nle\nfor\noutput\nand\nto\ncause\na\ntranscript\nof\nsubsequen\nt\nin\nteraction\nb\net\nw\neen\nthe\nuser\nand\nthe\nSc\nheme\nsystem\nto\nb\ne\nwritten\nto\nthe\nle\nThe\ntranscript\nis\nended\nb\ny\na\ncall\nto\ntranscriptoff\nwhic\nh\ncloses\nthe\ntranscript\nle\nOnly\none\ntranscript\nma\ny\nb\ne\nin\nprogress\nat\nan\ny\ntime\nthough\nsome\nimplemen\ntations\nma\ny\nrelax\nthis\nrestriction\nThe\nv\nalues\nre\nturned\nb\ny\nthese\npro\ncedures\nare\nunsp\necied\n\nRevised\n\nSc\nheme\n\nF\normal\nsyn\ntax\nand\nseman\ntics\nThis\nc\nhapter\npro\nvides\nformal\ndescriptions\nof\nwhat\nhas\nal\nready\nb\neen\ndescrib\ned\ninformally\nin\nprevious\nc\nhapters\nof\nthis\nrep\nort\n\nF\normal\nsyn\ntax\nThis\nsection\npro\nvides\na\nformal\nsyn\ntax\nfor\nSc\nheme\nwritten\nin\nan\nextended\nBNF\nAll\nspaces\nin\nthe\ngrammar\nare\nfor\nlegibilit\ny\n\nCase\nis\ninsignif\nican\nt\nfor\nexample\nxA\nand\nXa\nare\nequiv\nalen\nt\nhempt\nyi\nstands\nfor\nthe\nempt\ny\nstring\nThe\nfollo\nwing\nextensions\nto\nBNF\nare\nused\nto\nmak\ne\nthe\nde\nscription\nmore\nconcise\nhthingi\n\nmeans\nzero\nor\nmore\no\nccur\nrences\nof\nhthingi\n\nand\nhthingi\n\nmeans\nat\nleast\none\nhthingi\n\nLexical\nstructure\nThis\nsection\ndescrib\nes\nho\nw\nindividual\ntok\nens\niden\ntiers\nn\num\nb\ners\netc\nare\nformed\nfrom\nsequences\nof\nc\nharacters\nThe\nfollo\nwing\nsections\ndescrib\ne\nho\nw\nexpressions\nand\npro\ngrams\nare\nformed\nfrom\nsequences\nof\ntok\nens\nhIn\ntertok\nen\nspacei\nma\ny\no\nccur\non\neither\nside\nof\nan\ny\ntok\nen\nbut\nnot\nwithin\na\ntok\nen\nT\nok\nens\nwhic\nh\nrequire\nimplicit\ntermination\niden\ntiers\nn\num\nb\ners\nc\nharacters\nand\ndot\nma\ny\nb\ne\nterminated\nb\ny\nan\ny\nhdelimiteri\n\nbut\nnot\nnecessarily\nb\ny\nan\nything\nelse\nThe\nfollo\nwing\nv\ne\nc\nharacters\nare\nreserv\ned\nfor\nfuture\nexten\nsions\nto\nthe\nlanguage\n\nhtok\neni\n\nhiden\ntieri\nj\nhb\no\noleani\nj\nhn\num\nb\neri\nj\nhc\nharacteri\nj\nhstringi\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nhdelimiteri\n\nhwhitespacei\nj\n\nj\n\nj\n\nj\n\nhwhitespacei\n\nhspace\nor\nnewlinei\nhcommen\nti\n\nhall\nsubsequen\nt\nc\nharacters\nup\nto\na\nline\nbreaki\nhatmospherei\n\nhwhitespacei\nj\nhcommen\nti\nhin\ntertok\nen\nspacei\n\nhatmospherei\nhiden\ntieri\n\nhinitiali\nhsubsequen\nti\nj\nhp\neculiar\niden\ntieri\nhinitiali\n\nhletteri\nj\nhsp\necial\ninitiali\nhletteri\n\na\nj\nb\nj\nc\nj\n\nj\nz\nhsp\necial\ninitiali\n\nj\n%\nj\n&\nj\n'\nj\n\nj\n\nj\n$\nj\n!\nj\n\nj\n\nj\n\nj\n(\nj\n)\nj\n*\nhsubsequen\nti\n\nhinitiali\nj\nhdigiti\nj\nhsp\necial\nsubsequen\nti\nhdigiti\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nhsp\necial\nsubsequen\nti\n\nj\n\nj\n\nj\n\nhp\neculiar\niden\ntieri\n\nj\n\nj\n\nhsyn\ntactic\nk\neyw\nordi\n\nhexpression\nk\neyw\nordi\nj\nelse\nj\n\nj\ndefine\nj\nunquote\nj\nunquotesplicin\ng\nhexpression\nk\neyw\nordi\n\nquote\nj\nlambda\nj\nif\nj\nset\nj\nbegin\nj\ncond\nj\nand\nj\nor\nj\ncase\nj\nlet\nj\nlet\nj\nletrec\nj\ndo\nj\ndelay\nj\nquasiquote\nhv\nariablei\n\nhan\ny\nhiden\ntieri\nthat\nisnt\nalso\na\nhsyn\ntactic\nk\neyw\nordi\ni\nhb\no\noleani\n\nt\nj\nf\nhc\nharacteri\n\nhan\ny\nc\nharacteri\nj\n\nhc\nharacter\nnamei\nhc\nharacter\nnamei\n\nspace\nj\nnewline\nhstringi\n\nhstring\nelemen\nti\n\nhstring\nelemen\nti\n\nhan\ny\nc\nharacter\nother\nthan\n\nor\ni\nj\n\nj\n\nhn\num\nb\neri\n\nhn\num\ni\nj\nhn\num\ni\nj\nhn\num\nij\nhn\num\ni\nThe\nfollo\nwing\nrules\nfor\nhn\num\nR\ni\nhcomplex\nR\ni\nhreal\nR\ni\nhureal\nR\ni\nhuin\nteger\nR\ni\n\nand\nhprex\nR\ni\nshould\nb\ne\nrepli\ncated\nfor\nR\n\nand\n\nThere\nare\nno\nrules\nfor\nhdecimal\ni\nhdecimal\ni\nand\nhdecimal\ni\nwhic\nh\nmeans\nthat\nn\num\nb\ners\ncon\ntaining\ndecimal\np\noin\nts\nor\nexp\nonen\nts\nm\nust\nb\ne\nin\ndecimal\nradix\nhn\num\nR\ni\n\nhprex\nR\ni\nhcomplex\nR\ni\nhcomplex\nR\ni\n\nhreal\nR\ni\nj\nhreal\nR\ni\n\nhreal\nR\ni\nj\nhreal\nR\ni\n\nhureal\nR\ni\ni\nj\nhreal\nR\ni\n\nhureal\nR\ni\ni\nj\nhreal\nR\ni\n\ni\nj\nhreal\nR\ni\n\ni\nj\n\nhureal\nR\ni\ni\nj\n\nhureal\nR\ni\ni\nj\n\ni\nj\n\ni\nhreal\nR\ni\n\nhsigni\nhureal\nR\ni\nhureal\nR\ni\n\nhuin\nteger\nR\ni\nj\nhuin\nteger\nR\ni\n\nhuin\nteger\nR\ni\nj\nhdecimal\nR\ni\nhdecimal\ni\n\nhuin\nteger\ni\nhsuxi\nj\n\nhdigit\ni\n\nhsuxi\nj\nhdigit\ni\n\nhdigit\ni\n\nhsuxi\nj\nhdigit\ni\n\nhsuxi\nhuin\nteger\nR\ni\n\nhdigit\nR\ni\n\nhprex\nR\ni\n\nhradix\nR\ni\nhexactnessi\nj\nhexactnessi\nhradix\nR\ni\nhsuxi\n\nhempt\nyi\nj\nhexp\nonen\nt\nmark\neri\nhsigni\nhdigit\ni\n\nhexp\nonen\nt\nmark\neri\n\ne\nj\ns\nj\nf\nj\nd\nj\nl\nhsigni\n\nhempt\nyi\nj\n\nj\n\nhexactnessi\n\nhempt\nyi\nj\ni\nj\ne\nhradix\ni\n\nb\nhradix\ni\n\no\nhradix\ni\n\nhempt\nyi\nj\nd\n\nF\normal\nsyn\ntax\nand\nseman\ntics\n\nhradix\ni\n\nx\nhdigit\ni\n\nj\n\nhdigit\ni\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nj\n\nhdigit\ni\n\nhdigiti\nhdigit\ni\n\nhdigit\ni\nj\na\nj\nb\nj\nc\nj\nd\nj\ne\nj\nf\n\nExternal\nrepresen\ntations\nhDatumi\nis\nwhat\nthe\nread\npro\ncedure\nsection\n\nsuc\ncessfully\nparses\nNote\nthat\nan\ny\nstring\nthat\nparses\nas\nan\nhexpressioni\nwill\nalso\nparse\nas\na\nhdatumi\nhdatumi\n\nhsimple\ndatumi\nj\nhcomp\nound\ndatumi\nhsimple\ndatumi\n\nhb\no\noleani\nj\nhn\num\nb\neri\nj\nhc\nharacteri\nj\nhstringi\nj\nhsym\nb\noli\nhsym\nb\noli\n\nhiden\ntieri\nhcomp\nound\ndatumi\n\nhlisti\nj\nhv\nectori\nhlisti\n\nhdatumi\nj\nhdatumi\n\nhdatumi\nj\nhabbreviationi\nhabbreviationi\n\nhabbrev\nprexi\nhdatumi\nhabbrev\nprexi\n\nj\n\nj\n\nj\n\nhv\nectori\n\nhdatumi\n\nExpressions\nhexpressioni\n\nhv\nariablei\nj\nhliterali\nj\nhpro\ncedure\ncalli\nj\nhlam\nb\nda\nexpressioni\nj\nhconditionali\nj\nhassignmen\nti\nj\nhderiv\ned\nexpressioni\nj\nhmacro\nusei\nj\nhmacro\nblo\nc\nki\nhliterali\n\nhquotationi\nj\nhselfev\naluatingi\nhselfev\naluatingi\n\nhb\no\noleani\nj\nhn\num\nb\neri\nj\nhc\nharacteri\nj\nhstringi\nhquotationi\n\nhdatumi\nj\nquote\nhdatumi\n\nhpro\ncedure\ncalli\n\nhop\neratori\nhop\nerandi\n\nhop\neratori\n\nhexpressioni\nhop\nerandi\n\nhexpressioni\nhlam\nb\nda\nexpressioni\n\nlambda\nhformalsi\nhb\no\ndyi\n\nhformalsi\n\nhv\nariablei\n\nj\nhv\nariablei\nj\nhv\nariablei\n\nhv\nariablei\n\nhb\no\ndyi\n\nhdenitioni\n\nhsequencei\nhsequencei\n\nhcommandi\nhexpressioni\nhcommandi\n\nhexpressioni\nhconditionali\n\nif\nhtesti\nhconsequen\nti\nhalternatei\n\nhtesti\n\nhexpressioni\nhconsequen\nti\n\nhexpressioni\nhalternatei\n\nhexpressioni\nj\nhempt\nyi\nhassignmen\nti\n\nset\nhv\nariablei\nhexpressioni\n\nhderiv\ned\nexpressioni\n\ncond\nhcond\nclausei\n\nj\ncond\nhcond\nclausei\nelse\nhsequencei\nj\ncase\nhexpressioni\nhcase\nclausei\n\nj\ncase\nhexpressioni\nhcase\nclausei\nelse\nhsequencei\nj\nand\nhtesti\n\nj\nor\nhtesti\nj\nlet\nhbinding\nsp\neci\nhb\no\ndyi\n\nj\nlet\nhv\nariablei\nhbinding\nsp\neci\nhb\no\ndyi\n\nj\nlet\nhbinding\nsp\neci\n\nhb\no\ndyi\n\nj\nletrec\nhbinding\nsp\neci\n\nhb\no\ndyi\nj\nbegin\nhsequencei\nj\ndo\nhiteration\nsp\neci\n\nhtesti\nhdo\nresulti\nhcommandi\n\nj\ndelay\nhexpressioni\n\nj\nhquasiquotationi\nhcond\nclausei\n\nhtesti\nhsequencei\nj\nhtesti\n\nj\nhtesti\n\nhrecipien\nti\nhrecipien\nti\n\nhexpressioni\nhcase\nclausei\n\nhdatumi\n\nhsequencei\nhbinding\nsp\neci\n\nhv\nariablei\nhexpressioni\n\nhiteration\nsp\neci\n\nhv\nariablei\nhiniti\nhstepi\n\nj\nhv\nariablei\nhiniti\n\nhiniti\n\nhexpressioni\nhstepi\n\nhexpressioni\nhdo\nresulti\n\nhsequencei\nj\nhempt\nyi\nhmacro\nusei\n\nhk\neyw\nordi\nhdatumi\nhk\neyw\nordi\n\nhiden\ntieri\nhmacro\nblo\nc\nki\n\nletsyntax\nhsyn\ntax\nsp\neci\nhb\no\ndyi\n\nj\nletrecsyntax\nhsyn\ntax\nsp\neci\n\nhb\no\ndyi\nhsyn\ntax\nsp\neci\n\nhk\neyw\nordi\nhtransformer\nsp\neci\n\nQuasiquotations\nThe\nfollo\nwing\ngrammar\nfor\nquasiquote\nexpressions\nis\nnot\ncon\ntextfree\nIt\nis\npresen\nted\nas\na\nrecip\ne\nfor\ngenerating\nan\ninnite\nn\num\nb\ner\nof\npro\nduction\nrules\nImagine\na\ncop\ny\nof\nthe\nfollo\nwing\nrules\nfor\nD\n\nD\nk\neeps\ntrac\nk\nof\nthe\nnesting\ndepth\nhquasiquotationi\n\nhquasiquotation\ni\nhqq\ntemplate\ni\n\nhexpressioni\n\nRevised\n\nSc\nheme\nhquasiquotation\nD\ni\n\nhqq\ntemplate\nD\ni\nj\nquasiquote\nhqq\ntemplate\nD\ni\nhqq\ntemplate\nD\ni\n\nhsimple\ndatumi\nj\nhlist\nqq\ntemplate\nD\ni\nj\nhv\nector\nqq\ntemplate\nD\ni\nj\nhunquotation\nD\ni\nhlist\nqq\ntemplate\nD\ni\n\nhqq\ntemplate\nor\nsplice\nD\ni\nj\nhqq\ntemplate\nor\nsplice\nD\ni\n\nhqq\ntemplate\nD\ni\nj\nhqq\ntemplate\nD\ni\nj\nhquasiquotation\nD\n\"\ni\nhv\nector\nqq\ntemplate\nD\ni\n\nhqq\ntemplate\nor\nsplice\nD\ni\nhunquotation\nD\ni\n\nhqq\ntemplate\nD\n\ni\nj\nunquote\nhqq\ntemplate\nD\n\ni\nhqq\ntemplate\nor\nsplice\nD\ni\n\nhqq\ntemplate\nD\ni\nj\nhsplicing\nunquotation\nD\ni\nhsplicing\nunquotation\nD\ni\n\nhqq\ntemplate\nD\n\ni\nj\nunquotesplicin\ng\nhqq\ntemplate\nD\n\ni\n\nIn\nhquasiquotationi\ns\na\nhlist\nqq\ntemplate\nD\ni\ncan\nsome\ntimes\nb\ne\nconfused\nwith\neither\nan\nhunquotation\nD\ni\nor\na\nhsplicing\nunquotation\nD\ni\nThe\nin\nterpretation\nas\nan\nhunquotationi\nor\nhsplicing\nunquotation\nD\ni\ntak\nes\nprece\ndence\n\nT\nransformers\nhtransformer\nsp\neci\n\nsyntaxrules\nhiden\ntieri\n\nhsyn\ntax\nrulei\nhsyn\ntax\nrulei\n\nhpatterni\nhtemplatei\n\nhpatterni\n\nhpattern\niden\ntieri\nj\nhpatterni\n\nj\nhpatterni\n\nhpatterni\nj\nhpatterni\nhpatterni\nhellipsisi\nj\nhpatterni\n\nj\nhpatterni\n\nhpatterni\nhellipsisi\n\nj\nhpattern\ndatumi\nhpattern\ndatumi\n\nhstringi\nj\nhc\nharacteri\nj\nhb\no\noleani\nj\nhn\num\nb\neri\nhtemplatei\n\nhpattern\niden\ntieri\nj\nhtemplate\nelemen\nti\nj\nhtemplate\nelemen\nti\n\nhtemplatei\n\nj\nhtemplate\nelemen\nti\n\nj\nhtemplate\ndatumi\nhtemplate\nelemen\nti\n\nhtemplatei\nj\nhtemplatei\nhellipsisi\nhtemplate\ndatumi\n\nhpattern\ndatumi\nhpattern\niden\ntieri\n\nhan\ny\niden\ntier\nexcept\ni\nhellipsisi\n\nhthe\niden\ntier\ni\n\nPrograms\nand\nde nitions\nhprogrami\n\nhcommand\nor\ndenitioni\nhcommand\nor\ndenitioni\n\nhcommandi\nj\nhdenitioni\nj\nhsyn\ntax\ndenitioni\nj\nbegin\nhcommand\nor\ndenitioni\n\nhdenitioni\n\ndefine\nhv\nariablei\nhexpressioni\n\nj\ndefine\nhv\nariablei\nhdef\nformalsi\n\nhb\no\ndyi\n\nj\nbegin\nhdenitioni\n\nhdef\nformalsi\n\nhv\nariablei\n\nj\nhv\nariablei\n\nhv\nariablei\nhsyn\ntax\ndenitioni\n\ndefinesyntax\nhk\neyw\nordi\nhtransformer\nsp\neci\n\nF\normal\nseman\ntics\nThis\nsection\npro\nvides\na\nformal\ndenotational\nseman\ntics\nfor\nthe\nprimitiv\ne\nexpressions\nof\nSc\nheme\nand\nselected\nbuiltin\npro\ncedures\nThe\nconcepts\nand\nnotation\nused\nhere\nare\nde\nscrib\ned\nin\n\nthe\nnotation\nis\nsummarized\nb\nelo\nw\nh\n\ni\nsequence\nformation\ns\n\nk\nk\nth\nmem\nb\ner\nof\nthe\nsequence\ns\nbased\n$s\nlength\nof\nsequence\ns\ns\nx\nt\nconcatenation\nof\nsequences\ns\nand\nt\ns\ny\nk\ndrop\nthe\nrst\nk\nmem\nb\ners\nof\nsequence\ns\nt\n\na\nb\nMcCarth\ny\nconditional\nif\nt\nthen\na\nelse\nb\nxi\nsubstitution\n\nwith\nx\nfor\ni\nx\nin\nD\ninjection\nof\nx\nin\nto\ndomain\nD\nx\nj\nD\npro\njection\nof\nx\nto\ndomain\nD\nThe\nreason\nthat\nexpression\ncon\ntin\nuations\ntak\ne\nsequences\nof\nv\nalues\ninstead\nof\nsingle\nv\nalues\nis\nto\nsimplify\nthe\nformal\ntreatmen\nt\nof\npro\ncedure\ncalls\nand\nm\nultiple\nreturn\nv\nalues\nThe\nb\no\nolean\nag\nasso\nciated\nwith\npairs\nv\nectors\nand\nstrings\nwill\nb\ne\ntrue\nfor\nm\nutable\nob\njects\nand\nfalse\nfor\nimm\nutable\nob\njects\nThe\norder\nof\nev\naluation\nwithin\na\ncall\nis\nunsp\necied\nW\ne\nmimic\nthat\nhere\nb\ny\napplying\narbitrary\np\nerm\nutations\np\ner\nmute\nand\nunp\nermute\nwhic\nh\nm\nust\nb\ne\nin\nv\nerses\nto\nthe\nargu\nmen\nts\nin\na\ncall\nb\nefore\nand\nafter\nthey\nare\nev\naluated\nThis\nis\nnot\nquite\nrigh\nt\nsince\nit\nsuggests\nincorrectly\n\nthat\nthe\norder\nof\nev\naluation\nis\nconstan\nt\nthroughout\na\nprogram\nfor\nan\ny\ngiv\nen\nn\num\nb\ner\nof\nargumen\nts\nbut\nit\nis\na\ncloser\nappro\nxima\ntion\nto\nthe\nin\ntended\nseman\ntics\nthan\na\nlefttorigh\nt\nev\nalua\ntion\nw\nould\nb\ne\nThe\nstorage\nallo\ncator\nnew\nis\nimplemen\ntationdep\nenden\nt\nbut\nit\nm\nust\nob\ney\nthe\nfollo\nwing\naxiom\nif\nnew\n\nL\nthen\n\nnew\n\nj\nL\n\nfalse\n\nThe\ndenition\nof\nK\nis\nomitted\nb\necause\nan\naccurate\ndeni\ntion\nof\nK\nw\nould\ncomplicate\nthe\nseman\ntics\nwithout\nb\neing\nv\nery\nin\nteresting\nIf\nP\nis\na\nprogram\nin\nwhic\nh\nall\nv\nariables\nare\ndened\nb\nefore\nb\neing\nreferenced\nor\nassigned\nthen\nthe\nmeaning\nof\nP\nis\nE\n\nlambda\nI\n\nP\nhundenedi\n\nF\normal\nsyn\ntax\nand\nseman\ntics\n\nwhere\nI\nis\nthe\nsequence\nof\nv\nariables\ndened\nin\nP\n\nP\n\nis\nthe\nsequence\nof\nexpressions\nobtained\nb\ny\nreplacing\nev\nery\ndeni\ntion\nin\nP\nb\ny\nan\nassignmen\nt\nhundenedi\nis\nan\nexpression\nthat\nev\naluates\nto\nundene\nd\n\nand\nE\nis\nthe\nseman\ntic\nfunction\nthat\nassigns\nmeaning\nto\nexpressions\n\nAbstract\nsyn\ntax\nK\n\nCon\nconstan\nts\nincluding\nquotations\nI\n\nIde\niden\ntiers\nv\nariables\nE\n\nExp\nexpressions\n%\n\nCom\n\nExp\ncommands\nExp\n\nK\nj\nI\nj\nE\n\nE\n\nj\nlambda\nI\n\n%\nE\n\nj\nlambda\nI\n\nI\n%\nE\n\nj\nlambda\nI\n%\nE\n\nj\nif\nE\n\nE\n\nE\n\nj\nif\nE\n\nE\n\nj\nset\nI\nE\n\nDomain\nequations\n\nL\nlo\ncations\n\nN\nnatural\nn\num\nb\ners\nT\n\nffalse\ntrueg\nb\no\noleans\nQ\nsym\nb\nols\nH\nc\nharacters\nR\nn\num\nb\ners\nE\np\n\nL\n\nL\n\nT\npairs\nE\nv\n\nL\n\nT\nv\nectors\nE\ns\n\nL\n\nT\nstrings\nM\n\nffalse\ntrue\nnul\nl\nundene\nd\nunsp\ne\ncie\ndg\nmiscellaneous\n\nF\n\nL\n\nE\n\nK\n\nC\npro\ncedure\nv\nalues\n\nE\n\nQ\n\"\nH\n\"\nR\n\"\nE\np\n\"\nE\nv\n\"\nE\ns\n\"\nM\n\"\nF\nexpressed\nv\nalues\n\nS\n\nL\n\nE\n\nT\n\nstores\n\nU\n\nIde\n\nL\nen\nvironmen\nts\n\nC\n\nS\n\nA\ncommand\ncon\ntin\nuations\n\nK\n\nE\n\nC\nexpression\ncon\ntin\nuations\nA\nansw\ners\nX\nerrors\n\nSeman\ntic\nfunctions\nK\n\nCon\n\nE\nE\n\nExp\n\nU\n\nK\n\nC\nE\n\nExp\n\nU\n\nK\n\nC\nC\n\nCom\n\nU\n\nC\n\nC\nDenition\nof\nK\ndelib\nerately\nomitted\nE\n\nK\n\nsend\nK\n\nK\n\nE\n\nI\n\nhold\nlo\nokup\n\nI\nsingle\n\nundene\nd\n\nwr\nong\nundened\nv\nariable\n\nsend\n\nE\n\nE\n\nE\n\nE\n\np\nermute\nhE\n\ni\nx\nE\n\napplic\nate\n\ny\n\nunp\nermute\n\nE\n\nlambda\nI\n\nE\n\nnew\n\nL\n\nsend\nhnew\n\nj\nL\n\nI\n\ntievals\n\nC\n\nE\n\nE\n\nextends\n\nI\n\nwr\nong\nwrong\nn\num\nb\ner\nof\nargumen\ntsi\nin\nE\n\nup\ndate\nnew\n\nj\nL\nunsp\ne\ncie\nd\n\nwr\nong\nout\nof\nmemory\n\nE\n\nlambda\nI\n\nI\n\nE\n\nnew\n\nL\n\nsend\nhnew\n\nj\nL\n\nI\n\ntievalsr\nest\n\nC\n\nE\n\nE\n\nextends\n\nI\nx\nhIi\n\nI\n\nwr\nong\nto\no\nfew\nargumen\nts\ni\nin\nE\n\nup\ndate\nnew\n\nj\nL\nunsp\ne\ncie\nd\n\nwr\nong\nout\nof\nmemory\n\nE\n\nlambda\nI\n\nE\n\nE\n\nlambda\n\nI\n\nE\n\nE\n\nif\nE\n\nE\n\nE\n\nE\n\nE\n\nsingle\n\ntruish\n\nE\n\nE\n\nE\n\nE\n\nE\n\nif\nE\n\nE\n\nE\n\nE\n\nsingle\n\ntruish\n\nE\n\nE\n\nsend\nunsp\ne\ncie\nd\n\nHere\nand\nelsewhere\nan\ny\nexpressed\nv\nalue\nother\nthan\nundene\nd\nma\ny\nb\ne\nused\nin\nplace\nof\nunsp\ne\ncie\nd\nE\n\nset\nI\nE\n\nE\n\nE\n\nsingle\n\nassign\nlo\nokup\n\nI\n\nsend\nunsp\ne\ncie\nd\n\nE\n\nh\ni\nE\n\nE\n\nE\n\nE\n\nE\n\nsingle\n\nE\n\nE\n\nh\n\ni\nx\n\nC\n\nC\n\nE\n\nC\n\nRevised\n\nSc\nheme\n\nAuxiliary\nfunctions\nlo\nokup\n\nU\n\nIde\n\nL\nlo\nokup\n\nI\n\nI\nextends\n\nU\n\nIde\n\nL\n\nU\nextends\n\nI\n\nI\n\nextends\n\nI\n\nI\ny\n\ny\n\nwr\nong\n\nX\n\nC\nimplemen\ntationdep\nenden\nt\nsend\n\nE\n\nK\n\nC\nsend\n\nhi\nsingle\n\nE\n\nC\n\nK\nsingle\n\nwr\nong\nwrong\nn\num\nb\ner\nof\nreturn\nv\nalues\nnew\n\nS\n\nL\n!\nferr\nor\ng\nimplemen\ntationdep\nenden\nt\nhold\n\nL\n\nK\n\nC\nhold\n\nsend\n\nassign\n\nL\n\nE\n\nC\n\nC\nassign\n\nup\ndate\n\nup\ndate\n\nL\n\nE\n\nS\n\nS\nup\ndate\n\nh\ntrue\ni\n\ntievals\n\nL\n\nC\n\nE\n\nC\ntievals\n\nh\ni\n\nnew\n\nL\n\ntievals\n\nhnew\n\nj\nLi\nx\n\ny\n\nup\ndate\nnew\n\nj\nL\n\nwr\nong\nout\nof\nmemory\n\ntievalsr\nest\n\nL\n\nC\n\nE\n\nN\n\nC\ntievalsr\nest\n\nlist\ndr\noprst\n\nsingle\n\ntievals\n\ntakerst\n\nx\nhi\n\ndr\noprst\n\nl\nn\n\nn\n\nl\n\ndr\noprst\nl\ny\n\nn\n\ntakerst\n\nl\nn\n\nn\n\nh\ni\nhl\n\ni\nx\ntakerst\nl\ny\n\nn\n\ntruish\n\nE\n\nT\ntruish\n\nfalse\n\nfalse\ntrue\np\nermute\n\nExp\n\nExp\n\nimplemen\ntationdep\nenden\nt\nunp\nermute\n\nE\n\nE\nin\nv\nerse\nof\np\nermute\n\napplic\nate\n\nE\n\nE\n\nK\n\nC\napplic\nate\n\nF\n\nj\nF\n\nwr\nong\nbad\npro\ncedure\none\nar\ng\n\nE\n\nK\n\nC\n\nE\n\nK\n\nC\none\nar\ng\n\nwr\nong\nwrong\nn\num\nb\ner\nof\nargumen\nts\ntwo\nar\ng\n\nE\n\nE\n\nK\n\nC\n\nE\n\nK\n\nC\ntwo\nar\ng\n\nwr\nong\nwrong\nn\num\nb\ner\nof\nargumen\nts\nlist\n\nE\n\nK\n\nC\nlist\n\nsend\nnul\nl\n\nlist\n\ny\n\nsingle\n\nc\nons\nh\n\ni\n\nc\nons\n\nE\n\nK\n\nC\nc\nons\n\ntwo\nar\ng\n\nnew\n\nL\n\nnew\n\nL\n\nsend\nhnew\n\nj\nL\nnew\n\nj\nL\n\ntrue\ni\nin\nE\n\nup\ndate\nnew\n\nj\nL\n\nwr\nong\nout\nof\nmemory\n\nup\ndate\nnew\n\nj\nL\n\nwr\nong\nout\nof\nmemory\n\nless\n\nE\n\nK\n\nC\nless\n\ntwo\nar\ng\n\nR\n\nR\n\nsend\n\nj\nR\n\nj\nR\n\ntrue\n\nfalse\n\nwr\nong\nnonn\numeric\nargumen\nt\nto\n\nadd\n\nE\n\nK\n\nC\nadd\n\ntwo\nar\ng\n\nR\n\nR\n\nsend\n\nj\nR\n!\n\nj\nR\nin\nE\n\nwr\nong\nnonn\numeric\nargumen\nt\nto\n\nc\nar\n\nE\n\nK\n\nC\nc\nar\n\none\nar\ng\n\nE\np\n\nhold\n\nj\nE\np\n\nwr\nong\nnonpair\nargumen\nt\nto\ncar\n\nc\ndr\n\nE\n\nK\n\nC\nsimilar\nto\nc\nar\n\nsetc\nar\n\nE\n\nK\n\nC\nsetc\nar\n\ntwo\nar\ng\n\nE\np\n\nj\nE\np\n\nassign\n\nj\nE\np\n\nsend\nunsp\ne\ncie\nd\n\nwr\nong\nimm\nutable\nargumen\nt\nto\nsetcar\n\nwr\nong\nnonpair\nargumen\nt\nto\nsetcar\n\ne\nqv\n\nE\n\nK\n\nC\ne\nqv\n\ntwo\nar\ng\n\nM\n\nM\n\nsend\n\nj\nM\n\nj\nM\n\ntrue\n\nfalse\n\nQ\n\nQ\n\nsend\n\nj\nQ\n\nj\nQ\n\ntrue\n\nfalse\n\nH\n\nH\n\nsend\n\nj\nH\n\nj\nH\n\ntrue\n\nfalse\n\nR\n\nR\n\nsend\n\nj\nR\n\nj\nR\n\ntrue\n\nfalse\n\nE\np\n\nE\np\n\nsend\np\n\np\n\np\n\np\n\np\n\np\n\ntrue\n\nfalse\n\nj\nE\np\n\nj\nE\np\n\nF\normal\nsyn\ntax\nand\nseman\ntics\n\nE\nv\n\nE\nv\n\nE\ns\n\nE\ns\n\nF\n\nF\n\nsend\n\nj\nF\n\nj\nF\n\ntrue\n\nfalse\n\nsend\nfalse\n\napply\n\nE\n\nK\n\nC\napply\n\ntwo\nar\ng\n\nF\n\nvalueslist\nh\n\ni\n\napplic\nate\n\nwr\nong\nbad\npro\ncedure\nargumen\nt\nto\napply\n\nvalueslist\n\nE\n\nK\n\nC\nvalueslist\n\none\nar\ng\n\nE\np\n\nc\ndr\nhi\n\nvalueslist\n\nc\nar\nhi single\n\nhi\nx\n\nnul\nl\n\nh\ni\nwr\nong\nnonlist\nargumen\nt\nto\nvalueslist\n\ncwc\nc\n\nE\n\nK\n\nC\ncallwithcurrentcontinu\nation\n\ncwc\nc\n\none\nar\ng\n\nF\n\nnew\n\nL\n\napplic\nate\n\nhhnew\n\nj\nL\n\ni\nin\nEi\n\nup\ndate\nnew\n\nj\nL\nunsp\ne\ncie\nd\n\nwr\nong\nout\nof\nmemory\n\nwr\nong\nbad\npro\ncedure\nargumen\nt\nvalues\n\nE\n\nK\n\nC\nvalues\n\ncwv\n\nE\n\nK\n\nC\ncallwithvalues\ncwv\n\ntwo\nar\ng\n\napplic\nate\n\nh\ni\n\napplic\nate\n\nDeriv\ned\nexpression\nt\nyp\nes\nThis\nsection\ngiv\nes\nmacro\ndenitions\nfor\nthe\nderiv\ned\nexpres\nsion\nt\nyp\nes\nin\nterms\nof\nthe\nprimitiv\ne\nexpression\nt\nyp\nes\nlit\neral\nv\nariable\ncall\nlambda\nif\nset\n\nSee\nsection\n\nfor\na\np\nossible\ndenition\nof\ndelay\ndefinesyntax\ncond\nsyntaxrules\nelse\n\ncond\nelse\nresult\nresult\n\nbegin\nresult\nresult\n\ncond\ntest\n\nresult\nlet\ntemp\ntest\nif\ntemp\nresult\ntemp\ncond\ntest\n\nresult\nclause\nclause\n\nlet\ntemp\ntest\nif\ntemp\nresult\ntemp\ncond\nclause\nclause\n\ncond\ntest\ntest\ncond\ntest\nclause\nclause\n\nlet\ntemp\ntest\nif\ntemp\ntemp\ncond\nclause\nclause\n\ncond\ntest\nresult\nresult\n\nif\ntest\nbegin\nresult\nresult\n\ncond\ntest\nresult\nresult\n\nclause\nclause\n\nif\ntest\nbegin\nresult\nresult\n\ncond\nclause\nclause\n\ndefinesyntax\ncase\nsyntaxrules\nelse\ncase\nkey\n\nclauses\n\nlet\natomkey\nkey\n\ncase\natomkey\nclauses\n\ncase\nkey\nelse\nresult\nresult\n\nbegin\nresult\nresult\n\ncase\nkey\natoms\n\nresult\nresult\n\nif\nmemv\nkey\natoms\n\nbegin\nresult\nresult\n\ncase\nkey\natoms\n\nresult\nresult\n\nclause\nclauses\n\nif\nmemv\nkey\natoms\n\nbegin\nresult\nresult\n\ncase\nkey\nclause\nclauses\n\ndefinesyntax\nand\nsyntaxrules\n\nand\nt\nand\ntest\ntest\nand\ntest\ntest\n\nif\ntest\nand\ntest\n\nf\ndefinesyntax\nor\nsyntaxrules\n\nor\nf\nor\ntest\ntest\nor\ntest\ntest\n\nlet\nx\ntest\nif\nx\nx\nor\ntest\n\ndefinesyntax\nlet\nsyntaxrules\n\nlet\nname\nval\n\nbody\nbody\n\nlambda\nname\n\nbody\nbody\n\nval\n\nlet\ntag\nname\nval\n\nbody\nbody\n\nletrec\ntag\nlambda\nname\n\nbody\nbody\n\ntag\n\nRevised\n\nSc\nheme\nval\n\ndefinesyntax\nlet\nsyntaxrules\n\nlet\n\nbody\nbody\n\nlet\n\nbody\nbody\n\nlet\nname\nval\nname\nval\n\nbody\nbody\n\nlet\nname\nval\nlet\nname\nval\n\nbody\nbody\n\nThe\nfollo\nwing\nletrec\nmacro\nuses\nthe\nsym\nb\nol\n!undefined\nin\nplace\nof\nan\nexpression\nwhic\nh\nreturns\nsomething\nthat\nwhen\nstored\nin\na\nlo\ncation\nmak\nes\nit\nan\nerror\nto\ntry\nto\nob\ntain\nthe\nv\nalue\nstored\nin\nthe\nlo\ncation\nno\nsuc\nh\nexpression\nis\ndened\nin\nSc\nheme\nA\ntric\nk\nis\nused\nto\ngenerate\nthe\ntemp\no\nrary\nnames\nneeded\nto\na\nv\noid\nsp\necifying\nthe\norder\nin\nwhic\nh\nthe\nv\nalues\nare\nev\naluated\nThis\ncould\nalso\nb\ne\naccomplished\nb\ny\nusing\nan\nauxiliary\nmacro\ndefinesyntax\nletrec\nsyntaxrules\n\nletrec\nvar\ninit\n\nbody\n\nletrec\ngenerate\ntemp\nnames\nvar\n\nvar\ninit\n\nbody\n\nletrec\ngenerate\ntemp\nnames\n\ntemp\n\nvar\ninit\n\nbody\n\nlet\nvar\nundefined\n\nlet\ntemp\ninit\n\nset\nvar\ntemp\n\nbody\n\nletrec\ngenerate\ntemp\nnames\nx\ny\n\ntemp\n\nvar\ninit\n\nbody\n\nletrec\ngenerate\ntemp\nnames\ny\n\nnewtemp\ntemp\n\nvar\ninit\n\nbody\n\ndefinesyntax\nbegin\nsyntaxrules\n\nbegin\nexp\n\nlambda\n\nexp\n\nThe\nfollo\nwing\nalternativ\ne\nexpansion\nfor\nbegin\ndo\nes\nnot\nmak\ne\nuse\nof\nthe\nabilit\ny\nto\nwrite\nmore\nthan\none\nexpression\nin\nthe\nb\no\ndy\nof\na\nlam\nb\nda\nexpression\nIn\nan\ny\ncase\nnote\nthat\nthese\nrules\napply\nonly\nif\nthe\nb\no\ndy\nof\nthe\nbegin\ncon\ntains\nno\ndenitions\ndefinesyntax\nbegin\nsyntaxrules\n\nbegin\nexp\nexp\nbegin\nexp\nexp\n\nlet\nx\nexp\nbegin\nexp\n\nThe\nfollo\nwing\ndenition\nof\ndo\nuses\na\ntric\nk\nto\nexpand\nthe\nv\nariable\nclauses\nAs\nwith\nletrec\nab\no\nv\ne\nan\nauxiliary\nmacro\nw\nould\nalso\nw\nork\nThe\nexpression\nif\nf\nf\nis\nused\nto\nobtain\nan\nunsp\necic\nv\nalue\ndefinesyntax\ndo\nsyntaxrules\n\ndo\nvar\ninit\nstep\n\ntest\nexpr\n\ncommand\n\nletrec\nloop\nlambda\nvar\n\nif\ntest\nbegin\nif\nf\nf\nexpr\n\nbegin\ncommand\n\nloop\ndo\nstep\nvar\nstep\n\nloop\ninit\n\ndo\nstep\nx\nx\ndo\nstep\nx\ny\ny\n\nExample\n\nNOTES\nLanguage\nc\nhanges\nThis\nsection\nen\numerates\nthe\nc\nhanges\nthat\nha\nv\ne\nb\neen\nmade\nto\nSc\nheme\nsince\nthe\nRevised\n\nrep\nort\n\nw\nas\npublished\n\nThe\nrep\nort\nis\nno\nw\na\nsup\nerset\nof\nthe\nIEEE\nstandard\nfor\nSc\nheme\n\nimplemen\ntations\nthat\nconform\nto\nthe\nrep\nort\nwill\nalso\nconform\nto\nthe\nstandard\nThis\nrequired\nthe\nfollo\nwing\nc\nhanges\n\nThe\nempt\ny\nlist\nis\nno\nw\nrequired\nto\ncoun\nt\nas\ntrue\n\nThe\nclassication\nof\nfeatures\nas\nessen\ntial\nor\ninessen\ntial\nhas\nb\neen\nremo\nv\ned\nThere\nare\nno\nw\nthree\nclasses\nof\nbuiltin\npro\ncedures\nprimitiv\ne\nli\nbrary\n\nand\noptional\nThe\noptional\npro\ncedures\nare\nload\nwithinputfrom\nf\nile\n\nwithoutput\ntofile\ntranscripton\ntranscriptoff\nand\ninteractionenv\niro\nnm\nent\n\nand\n\nand\n\nwith\nmore\nthan\nt\nw\no\nargumen\nts\nNone\nof\nthese\nare\nin\nthe\nIEEE\nstandard\n\nPrograms\nare\nallo\nw\ned\nto\nredene\nbuiltin\npro\nce\ndures\nDoing\nso\nwill\nnot\nc\nhange\nthe\nb\neha\nvior\nof\nother\nbuiltin\npro\ncedures\n\nPort\nhas\nb\neen\nadded\nto\nthe\nlist\nof\ndisjoin\nt\nt\nyp\nes\n\nThe\nmacro\napp\nendix\nhas\nb\neen\nremo\nv\ned\nHighlev\nel\nmacros\nare\nno\nw\npart\nof\nthe\nmain\nb\no\ndy\nof\nthe\nrep\nort\nThe\nrewrite\nrules\nfor\nderiv\ned\nexpressions\nha\nv\ne\nb\neen\nreplaced\nwith\nmacro\ndenitions\nThere\nare\nno\nreserv\ned\niden\ntiers\n\nSyntaxrules\nno\nw\nallo\nws\nv\nector\npatterns\n\nMultiplev\nalue\nreturns\neval\nand\ndynamicwind\nha\nv\ne\nb\neen\nadded\n\nThe\ncalls\nthat\nare\nrequired\nto\nb\ne\nimplemen\nted\nin\na\nprop\nerly\ntailrecursiv\ne\nfashion\nare\ndened\nexplicitly\n\ncan\nb\ne\nused\nwithin\niden\ntiers\n\nis\nreserv\ned\nfor\np\nossible\nfuture\nextensions\nADDITIONAL\nMA\nTERIAL\nThe\nIn\nternet\nSc\nheme\nRep\nository\nat\nhttp$ wwwcsind\nian\na\nedu\ns\nch\neme\nr\nepo\nsi\ntor\ny\ncon\ntains\nan\nextensiv\ne\nSc\nheme\nbibliograph\ny\n\nas\nw\nell\nas\npa\np\ners\nprograms\nimplemen\ntations\nand\nother\nmaterial\nre\nlated\nto\nSc\nheme\nEXAMPLE\nIntegratesystem\nin\ntegrates\nthe\nsystem\ny\n\nk\n\nf\nk\ny\n\ny\n\ny\nn\n\nk\n\nn\nof\ndieren\ntial\nequations\nwith\nthe\nmetho\nd\nof\nRungeKutta\nThe\nparameter\nsystemderivati\nve\nis\na\nfunction\nthat\ntak\nes\na\nsystem\nstate\na\nv\nector\nof\nv\nalues\nfor\nthe\nstate\nv\nari\nables\ny\n\ny\nn\n\nand\npro\nduces\na\nsystem\nderiv\nativ\ne\nthe\nv\nal\nues\ny\n\ny\n\nn\n\nThe\nparameter\ninitialstate\npro\nvides\nan\ninitial\nsystem\nstate\nand\nh\nis\nan\ninitial\nguess\nfor\nthe\nlength\nof\nthe\nin\ntegration\nstep\nThe\nv\nalue\nreturned\nb\ny\nintegratesystem\nis\nan\ninnite\nstream\nof\nsystem\nstates\ndefine\nintegratesystem\nlambda\nsystemderivative\ninitialstate\nh\nlet\nnext\nrungekutta\nsystemderivative\nh\nletrec\nstates\ncons\ninitialstate\ndelay\nmapstreams\nnext\nstates\nstates\nRungeKutta\ntak\nes\na\nfunction\nf\nthat\npro\nduces\na\nsystem\nderiv\nativ\ne\nfrom\na\nsystem\nstate\nRungeKutta\npro\nduces\na\nfunction\nthat\ntak\nes\na\nsystem\nstate\nand\npro\nduces\na\nnew\nsystem\nstate\ndefine\nrungekutta\nlambda\nf\nh\nlet\nh\nscalevector\nh\n\nscalevector\n\nscalevector\n\nscalevector\n\nlambda\ny\n\ny\nis\na\nsystem\nstate\nlet\nk\nh\nf\ny\nk\nh\nf\naddvectors\ny\n\nk\nk\nh\nf\naddvectors\ny\n\nk\nk\nh\nf\naddvectors\ny\nk\naddvectors\ny\n\naddvectors\nk\n\nk\n\nk\nk\ndefine\nelementwise\nlambda\nf\nlambda\nvectors\ngeneratevector\nvectorlength\ncar\nvectors\nlambda\ni\napply\nf\nmap\nlambda\nv\nvectorref\nv\ni\nvectors\ndefine\ngeneratevector\nlambda\nsize\nproc\n\nRevised\n\nSc\nheme\nlet\nans\nmakevector\nsize\nletrec\nloop\nlambda\ni\ncond\n\ni\nsize\nans\nelse\nvectorset\nans\ni\nproc\ni\nloop\n\ni\n\nloop\n\ndefine\naddvectors\nelementwise\n\ndefine\nscalevector\nlambda\ns\nelementwise\nlambda\nx\n\nx\ns\nMapstreams\nis\nanalogous\nto\nmap\nit\napplies\nits\nrst\nargu\nmen\nt\na\npro\ncedure\nto\nall\nthe\nelemen\nts\nof\nits\nsecond\nargu\nmen\nt\na\nstream\ndefine\nmapstreams\nlambda\nf\ns\ncons\nf\nhead\ns\ndelay\nmapstreams\nf\ntail\ns\nInnite\nstreams\nare\nimplemen\nted\nas\npairs\nwhose\ncar\nholds\nthe\nrst\nelemen\nt\nof\nthe\nstream\nand\nwhose\ncdr\nholds\na\npromise\nto\ndeliv\ner\nthe\nrest\nof\nthe\nstream\ndefine\nhead\ncar\ndefine\ntail\nlambda\nstream\nforce\ncdr\nstream\nThe\nfollo\nwing\nillustrates\nthe\nuse\nof\nintegratesystem\nin\nin\ntegrating\nthe\nsystem\nC\ndv\nC\ndt\n\ni\nL\n\nv\nC\nR\nL\ndi\nL\ndt\n\nv\nC\nwhic\nh\nmo\ndels\na\ndamp\ned\noscillator\ndefine\ndampedoscillator\nlambda\nR\nL\nC\nlambda\nstate\nlet\nVc\nvectorref\nstate\n\nIl\nvectorref\nstate\n\nvector\n\nVc\n\nR\nC\n\nIl\nC\n\nVc\nL\ndefine\nthestates\nintegratesystem\ndampedoscillator\n\nREFERENCES\n\nHarold\nAb\nelson\nand\nGerald\nJa\ny\nSussman\nwith\nJulie\nSussman\nStructur\ne\nand\nInterpr\netation\nof\nComputer\nPr\no\ngr\nams\nse\nc\nond\ne\ndition\nMIT\nPress\nCam\nbridge\n\nAlan\nBa\nwden\nand\nJonathan\nRees\nSyn\ntactic\nclosures\nIn\nPr\no\nc\ne\ne\ndings\nof\nthe\n\nA\nCM\nSymp\nosium\non\nLisp\nand\nF\nunctional\nPr\no\ngr\namming\npages\n&\n\nRob\nert\nG\nBurger\nand\nR\nKen\nt\nDyb\nvig\nPrin\nting\noatingp\noin\nt\nn\num\nb\ners\nquic\nkly\nand\naccurately\n\nIn\nPr\no\nc\ne\ne\ndings\nof\nthe\nA\nCM\nSIGPLAN\n\nConfer\nenc\ne\non\nPr\no\ngr\namming\nL\nanguage\nDesign\nand\nImplementa\ntion\npages\n&\n\nWilliam\nClinger\neditor\nThe\nrevised\nrevised\nrep\nort\non\nSc\nheme\nor\nan\nuncommon\nLisp\nMIT\nArticial\nIn\ntelligence\nMemo\n\nAugust\n\nAlso\npublished\nas\nComputer\nScience\nDepartmen\nt\nT\nec\nhnical\nRep\nort\n\nIndiana\nUniv\nersit\ny\n\nJune\n\nWilliam\nClinger\nHo\nw\nto\nread\noating\np\noin\nt\nn\num\nb\ners\naccurately\n\nIn\nPr\no\nc\ne\ne\ndings\nof\nthe\nA\nCM\nSIGPLAN\n\nConfer\nenc\ne\non\nPr\no\ngr\namming\nL\nanguage\nDesign\nand\nImplementation\npages\n&\nPro\nceedings\npub\nlished\nas\nSIGPLAN\nNotic\nes\n\nJune\n\nWilliam\nClinger\nand\nJonathan\nRees\neditors\nThe\nrevised\n\nrep\nort\non\nthe\nalgorithmic\nlanguage\nSc\nheme\nIn\nA\nCM\nLisp\nPointers\n\npages\n&\n\nWilliam\nClinger\nand\nJonathan\nRees\nMacros\nthat\nw\nork\nIn\nPr\no\nc\ne\ne\ndings\nof\nthe\n\nA\nCM\nConfer\nenc\ne\non\nPrinciples\nof\nPr\no\ngr\namming\nL\nanguages\npages\n&\n\nWilliam\nClinger\nProp\ner\nT\nail\nRecursion\nand\nSpace\nEciency\n\nT\no\napp\near\nin\nPr\no\nc\ne\ne\ndings\nof\nthe\n\nA\nCM\nConfer\nenc\ne\non\nPr\no\ngr\namming\nL\nanguage\nDesign\nand\nImplementation\nJune\n\nR\nKen\nt\nDyb\nvig\nRob\nert\nHieb\nand\nCarl\nBruggeman\nSyn\ntactic\nabstraction\nin\nSc\nheme\nLisp\nand\nSymb\nolic\nComputation\n&\n\nCarol\nF\nessenden\nWilliam\nClinger\nDaniel\nP\n\nF\nried\nman\nand\nChristopher\nHa\nynes\nSc\nheme\n\nv\nersion\n\nreference\nman\nual\nIndiana\nUniv\nersit\ny\nComputer\nSci\nence\nT\nec\nhnical\nRep\nort\n\nF\nebruary\n\nSup\ner\nseded\nb\ny\n\nD\nF\nriedman\nC\nHa\nynes\nE\nKohlb\nec\nk\ner\nand\nM\nW\nand\nSc\nheme\n\nin\nterim\nreference\nman\nual\nIndi\nana\nUniv\nersit\ny\nComputer\nScience\nT\nec\nhnical\nRep\nort\n\nJan\nuary\n\nReferences\n\nIEEE\nStandar\nd\n\nIEEE\nStandar\nd\nfor\nBinary\nFlo\natingPoint\nA\nrithmetic\nIEEE\nNew\nY\nork\n\nIEEE\nStandar\nd\n\nIEEE\nStandar\nd\nfor\nthe\nScheme\nPr\no\ngr\namming\nL\nanguage\nIEEE\nNew\nY\nork\n\nEugene\nE\nKohlb\nec\nk\ner\nJr\nSyntactic\nExtensions\nin\nthe\nPr\no\ngr\namming\nL\nanguage\nLisp\nPhD\nthesis\nIndi\nana\nUniv\nersit\ny\n\nAugust\n\nEugene\nE\nKohlb\nec\nk\ner\nJr\nDaniel\nP\n\nF\nriedman\nMatthias\nF\nelleisen\nand\nBruce\nDuba\nHygienic\nmacro\nexpansion\nIn\nPr\no\nc\ne\ne\ndings\nof\nthe\n\nA\nCM\nCon\nfer\nenc\ne\non\nLisp\nand\nF\nunctional\nPr\no\ngr\namming\npages\n&\n\nP\neter\nLandin\nA\ncorresp\nondence\nb\net\nw\neen\nAlgol\n\nand\nCh\nurc\nhs\nlam\nb\nda\nnotation\nP\nart\nI\nCommunic\na\ntions\nof\nthe\nA\nCM\n&\nF\nebruary\n\nMIT\nDepartmen\nt\nof\nElectrical\nEngineering\nand\nCom\nputer\nScience\nSc\nheme\nman\nual\nsev\nen\nth\nedition\nSeptem\nb\ner\n\nP\neter\nNaur\net\nal\nRevised\nrep\nort\non\nthe\nalgorith\nmic\nlanguage\nAlgol\n\nCommunic\nations\nof\nthe\nA\nCM\n&\nJan\nuary\n\nP\naul\nP\neneld\nJr\nPrincipal\nv\nalues\nand\nbranc\nh\ncuts\nin\ncomplex\nAPL\nIn\nAPL\n\nConfer\nenc\ne\nPr\no\nc\ne\ne\nd\nings\npages\n&\nA\nCM\nSIGAPL\nSan\nF\nran\ncisco\nSeptem\nb\ner\n\nPro\nceedings\npublished\nas\nAPL\nQuote\nQuad\n\nA\nCM\nSeptem\nb\ner\n\nKen\nt\nM\nPitman\nThe\nrevised\nMacLisp\nman\nual\nSat\nurda\ny\nev\nening\nedition\nMIT\nLab\noratory\nfor\nCom\nputer\nScience\nT\nec\nhnical\nRep\nort\n\nMa\ny\n\nJonathan\nA\nRees\nand\nNorman\nI\nAdams\nIV\nT\nA\ndialect\nof\nLisp\nor\nlam\nb\nda\nThe\nultimate\nsoft\nw\nare\nto\nol\nIn\nConfer\nenc\ne\nR\ne\nc\nor\nd\nof\nthe\n\nA\nCM\nSym\np\nosium\non\nLisp\nand\nF\nunctional\nPr\no\ngr\namming\npages\n&\n\nJonathan\nA\nRees\nNorman\nI\nAdams\nIV\nand\nJames\nR\nMeehan\nThe\nT\nman\nual\nfourth\nedition\nY\nale\nUniv\nersit\ny\nComputer\nScience\nDepartmen\nt\nJan\nuary\n\nJonathan\nRees\nand\nWilliam\nClinger\neditors\nThe\nrevised\n\nrep\nort\non\nthe\nalgorithmic\nlanguage\nSc\nheme\nIn\nA\nCM\nSIGPLAN\nNotic\nes\n\npages\n&\nDe\ncem\nb\ner\n\nJohn\nReynolds\nDenitional\nin\nterpreters\nfor\nhigher\norder\nprogramming\nlanguages\nIn\nA\nCM\nConfer\nenc\ne\nPr\no\nc\ne\ne\ndings\npages\n&\nA\nCM\n\nGuy\nLewis\nSteele\nJr\nand\nGerald\nJa\ny\nSussman\nThe\nrevised\nrep\nort\non\nSc\nheme\na\ndialect\nof\nLisp\nMIT\nAr\nticial\nIn\ntelligence\nMemo\n\nJan\nuary\n\nGuy\nLewis\nSteele\nJr\nRabbit\na\ncompiler\nfor\nSc\nheme\nMIT\nArticial\nIn\ntelligence\nLab\noratory\nT\nec\nhnical\nRe\np\nort\n\nMa\ny\n\nGuy\nLewis\nSteele\nJr\nCommon\nLisp\nThe\nL\nanguage\nse\nc\nond\ne\ndition\nDigital\nPress\nBurlington\nMA\n\nGerald\nJa\ny\nSussman\nand\nGuy\nLewis\nSteele\nJr\nSc\nheme\nan\nin\nterpreter\nfor\nextended\nlam\nb\nda\ncalcu\nlus\nMIT\nArticial\nIn\ntelligence\nMemo\n\nDecem\nb\ner\n\nJoseph\nE\nSto\ny\n\nDenotational\nSemantics\nThe\nSc\nott\nStr\nachey\nAppr\no\nach\nto\nPr\no\ngr\namming\nL\nanguage\nThe\nory\nMIT\nPress\nCam\nbridge\n\nT\nexas\nInstrumen\nts\nInc\nTI\nSc\nheme\nLanguage\nRef\nerence\nMan\nual\nPreliminary\nv\nersion\n\nNo\nv\nem\nb\ner\n\nRevised\n\nSc\nheme\nALPHABETIC\nINDEX\nOF\nDEFINITIONS\nOF\nCONCEPTS\nKEYW\nORDS\nAND\nPR\nOCEDURES\nThe\nprincipal\nen\ntry\nfor\neac\nh\nterm\npro\ncedure\nor\nk\neyw\nord\nis\nlisted\nrst\nseparated\nfrom\nthe\nother\nen\ntries\nb\ny\na\nsemicolon\n\n!\n\n!\n\n+\n\nabs\n\nacos\n\nand\n\nangle\n\nappend\n\napply\n\nasin\n\nassoc\n\nassq\n\nassv\n\natan\n\nb\n\nbac\nkquote\n\nbegin\n\nbinding\n\nbinding\nconstruct\n\nboolean\n\nb\nound\n\ncaar\n\ncadr\n\ncall\n\ncall\nb\ny\nneed\n\ncallwithcurren\ntc\non\nti\nnua\nti\non\n\ncallwithinput\nfil\ne\n\ncallwithoutput\nfi\nle\n\ncallwithvalues\n\ncall cc\n\ncar\n\ncase\n\ncatch\n\ncdddar\n\ncddddr\n\ncdr\n\nceiling\n\ncharinteger\n\ncharalphabetic\n\ncharci!\n\ncharci!\n\ncharci\n\ncharci\n\ncharci\n\nchardowncase\n\ncharlowercase\n\ncharnumeric\n\ncharready\n\ncharupcase\n\ncharuppercase\n\ncharwhitespace\n\nchar!\n\nchar!\n\nchar\n\nchar\n\nchar\n\nchar\n\ncloseinputport\n\ncloseoutputport\n\ncom\nbination\n\ncomma\n\ncommen\nt\n\ncomplex\n\ncond\n\ncons\n\nconstan\nt\n\ncon\ntin\nuation\n\ncos\n\ncurrentinputpor\nt\n\ncurrentoutputpo\nrt\n\nd\n\ndefine\n\ndefinesyntax\n\ndenition\n\ndelay\n\ndenominator\n\ndisplay\n\ndo\n\ndotted\npair\n\ndynamicwind\n\ne\n\nIndex\n\nelse\n\nempt\ny\nlist\n\neofobject\n\neq\n\nequal\n\nequiv\nalence\npredicate\n\neqv\n\nerror\n\nescap\ne\npro\ncedure\n\neval\n\neven\n\nexact\n\nexactinexact\n\nexact\n\nexactness\n\nexp\n\nexpt\n\nf\n\nfalse\n\nfloor\n\nforeach\n\nforce\n\ngcd\n\nh\nygienic\n\ni\n\niden\ntier\n\nif\n\nimagpart\n\nimm\nutable\n\nimplemen\ntation\nrestriction\n\nimprop\ner\nlist\n\ninexact\n\ninexactexact\n\ninexact\n\ninitial\nen\nvironmen\nt\n\ninputport\n\nintegerchar\n\ninteger\n\ninteractionenvi\nron\nme\nnt\n\nin\nternal\ndenition\n\nk\neyw\nord\n\nlambda\n\nlazy\nev\naluation\n\nlcm\n\nlength\n\nlet\n\nlet\n\nletsyntax\n\nletrec\n\nletrecsyntax\n\nlibrary\n\nlibrary\npro\ncedure\n\nlist\n\nliststring\n\nlistvector\n\nlistref\n\nlisttail\n\nlist\n\nload\n\nlo\ncation\n\nlog\n\nmacro\n\nmacro\nk\neyw\nord\n\nmacro\ntransformer\n\nmacro\nuse\n\nmagnitude\n\nmakepolar\n\nmakerectangular\n\nmakestring\n\nmakevector\n\nmap\n\nmax\n\nmember\n\nmemq\n\nmemv\n\nmin\n\nmodulo\n\nm\nutable\n\nnegative\n\nnewline\n\nnil\n\nnot\n\nnullenvironment\n\nnull\n\nn\num\nb\ner\n\nnumberstring\n\nnumber\n\nnumerator\n\nn\numerical\nt\nyp\nes\n\no\n\nob\nject\n\nodd\n\nopeninputfile\n\nopenoutputfile\n\noptional\n\nor\n\noutputport\n\npair\n\npair\n\npeekchar\n\np\nort\n\nport\n\nRevised\n\nSc\nheme\npositive\n\npredicate\n\npro\ncedure\ncall\n\nprocedure\n\npromise\n\nprop\ner\ntail\nrecursion\n\nquasiquote\n\nquote\n\nquotient\n\nrational\n\nrationalize\n\nread\n\nreadchar\n\nrealpart\n\nreal\n\nreferen\ntially\ntransparen\nt\n\nregion\n\nremainder\n\nreverse\n\nround\n\nschemereporten\nvir\non\nme\nnt\n\nset\n\nsetcar\n\nsetcdr\n\nsetcar\n\nsimplest\nrational\n\nsin\n\nsqrt\n\nstring\n\nstringlist\n\nstringnumber\n\nstringsymbol\n\nstringappend\n\nstringci!\n\nstringci!\n\nstringci\n\nstringci\n\nstringci\n\nstringcopy\n\nstringfill\n\nstringlength\n\nstringref\n\nstringset\n\nstring!\n\nstring!\n\nstring\n\nstring\n\nstring\n\nstring\n\nsubstring\n\nsymbolstring\n\nsymbol\n\nsyn\ntactic\nk\neyw\nord\n\nsyn\ntax\ndenition\n\nsyntaxrules\n\nt\n\ntail\ncall\n\ntan\n\ntok\nen\n\ntop\nlev\nel\nen\nvironmen\nt\n\ntranscriptoff\n\ntranscripton\n\ntrue\n\ntruncate\n\nt\nyp\ne\n\nun\nb\nound\n\nunquote\n\nunquotesplicing\n\nunsp\necied\n\nv\nalid\nindexes\n\nvalues\n\nv\nariable\n\nvector\n\nvectorlist\n\nvectorfill\n\nvectorlength\n\nvectorref\n\nvectorset\n\nvector\n\nwhitespace\n\nwithinputfromf\nil\ne\n\nwithoutputtofi\nle\n\nwrite\n\nwritechar\n\nx\n\nzero"
    },
    {
      "category": "Resource",
      "title": "scheme12.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/67a55c1d46c11a2ee774b7e184e3869c_scheme12.pdf",
      "content": "1. ;; This Scheme+ Version 1.2\n2. ;; Built on Wed Sep 14 16:47:44 EDT 1994\n3. ;; Includes:\n4. ;; macros.scm\n5. ;; constructor.scm\n6. ;; datatype.scm\n7. ;; match.scm\n8. ;; top-level.scm\n9. (declare (usual-integrations))\n10. (define scheme+/version \"1.2\")\n11. ;;---------------------------------------------------\n12. ;; macros.scm\n13. ;;; ---------------------------------------------------------------------------\n14. ;;; Macro definitions\n15. ;;; Create the syntax table to be used by the compiler\n16. (define scheme+/syntax-table\n17. (make-syntax-table system-global-syntax-table))\n18. ;;; Scheme+ macros need to be visible both at run-time and a compile-time\n19. ;;;\n20. ;;; BJR: put define-scheme+-macro in user-initial-syntax-table so that\n21. ;;; we can load datatype.scm and match.scm independently.\n22. ;;;\n23. (syntax-table-define\n24. user-initial-syntax-table\n25. 'define-scheme+-macro\n26. (macro (pattern . body)\n27. `(begin\na. (syntax-table-define\nb. user-initial-syntax-table\nc. ',(car pattern)\nd. (macro ,(cdr pattern) ,@body))\ne. (syntax-table-define\nf. scheme+/syntax-table\ng. ',(car pattern)\nh. (macro ,(cdr pattern) ,@body)))))\n28. ;;Also need it in this file so it's visible when we concat everything together.\n29. (define-macro (define-scheme+-macro pattern . body)\n30. `(begin\n31. (syntax-table-define\na. user-initial-syntax-table\n\nb. ',(car pattern)\n32. (macro ,(cdr pattern) ,@body))\n33. (syntax-table-define\na. scheme+/syntax-table\nb. ',(car pattern)\n34. (macro ,(cdr pattern) ,@body))))\n35. ;;; Get real scheme value in expanded code\n36. (define-scheme+-macro (get-real identifier)\n37. `(access ,identifier ()))\n38. ;;; ---------------------------------------------------------------------\n39. ;;; Error handling macros - need to be visible both in this file\n40. ;;; and at run time.\n41. ;; BJR - These are now scheme procedures\n42. ; (define-macro (define-macro-both pattern . body)\n43. ; `(begin\n44. ;\n(define-macro ,pattern ,@body)\n45. ;\n(syntax-table-define\n46. ;\nuser-initial-syntax-table\n47. ;\n',(car pattern)\n48. ;\n(macro ,(cdr pattern) ,@body))))\n49. ;\n50. ; (define-macro-both (syntax-error string . rest)\n51. ; `(error (string-append \"\\nSCHEME+ SYNTAX ERROR: \" ,string)\n52. ;\n,@(if rest rest '())))\n53. ;\n54. ; (define-macro-both (runtime-error string . rest)\n55. ; `((get-real error)\n56. ;\n((get-real string-append) \"\\nSCHEME+ RUN-TIME TYPE ERROR!\\n\"\n57. ;\n,string)\n58. ;\n,@(if rest rest '())))\n59. (define (scheme+/syntax-error msg . rest)\n60. (error (apply error-string \"\\nSCHEME+ SYNTAX ERROR: \" msg rest)\na. rest))\n61. (define (scheme+/runtime-error msg . rest)\n62. (error (apply error-string \"\\nSCHEME+ RUN-TIME TYPE ERROR!\\n\" msg rest)\na. rest))\n\n63. ;; From mini-fx/version-4.2.7.scm\n64. (define (error-string str msg . objs )\n65. (string-append\n66. str\n67. msg\n68. \"\\n\"\n69. (objects->string objs)\n70. \"\\n\"\n71. ))\n72. (define objects->string\n73. (let ((separator \"------------------------------------------------------------\"))\n74. (lambda (objs)\n75. (if (null? objs)\na. \"\"\nb. (string-append\nc. separator\nd. (apply\ne. string-append\nf. (map\ng. (lambda (obj)\ni. (string-append\nii. (with-output-to-string (lambda () (pp obj)))\niii. \"\\n\"\niv. separator\nv. ))\nh. objs)))))))\n\n76. ;;---------------------------------------------------\n77. ;; constructor.scm\n78. ;;;----------------------------------------------------------------------------\n79. ;;; Constructors\n80. ;;; reistad 8/19/94 -- added quote and quasiquote s-expression consructors\n81. ;;\nfrom mini-fx.scm (1991)\n\n82. (define constructor-tag '(constructor))\n83. (define (scheme+/make-constructor bundler unbundler)\n84. (make-apply-hook bundler\ni. (list constructor-tag unbundler)))\n85. (define make-constructor scheme+/make-constructor)\n86. (define (constructor? obj)\n87. (and (apply-hook? obj)\n88. (let ((extra (apply-hook-extra obj)))\na. (and (list? extra)\nb. (= (length extra) 2)\nc. (eq? (first extra) constructor-tag)))))\n89. (define (bundler obj)\n90. (if (constructor? obj)\n91. obj\n92. (error \"bundler: Not a constructor!\" obj)))\n93. (define (unbundler obj)\n94. (if (constructor? obj)\n95. (second (apply-hook-extra obj))\n96. (error \"unbundler: Not a constructor!\" obj)))\n97. ;;;----------------------------------------------------------------------------\n98. ;;; Simulated LIST datatype\n99. (define null\n100.\n(make-constructor\n101.\n(lambda () '())\n102.\n(lambda (obj succ fail)\n103.\n(if (null? obj)\na. (succ)\nb. (fail)))))\n\n104.\n(define cons\n105.\n(make-constructor\n106.\n(access cons system-global-environment)\n107.\n(lambda (obj succ fail)\n108.\n(if (pair? obj)\na. (succ (car obj) (cdr obj))\nb. (fail)))))\n109.\n; (define null\n110.\n; (make-constructor\n111.\n; (lambda () '())\n112.\n; (lambda (obj succ fail)\n113.\n;\n(if *datatype-paranoid-match?* ; See DATATYPE.SCM\n114.\n;\n(if (not (or (null? obj) (pair? obj)))\n115.\n;\n(error \"Deconstructor for NULL given a non list\")))\n116.\n;\n(if (null? obj)\n117.\n;\n(succ)\n118.\n;\n(fail)))))\n119.\n;\n120.\n; (define cons\n121.\n; (make-constructor\n122.\n; (access cons ())\n123.\n; (lambda (obj succ fail)\n124.\n;\n(if *datatype-paranoid-match?* ; See DATATYPE.SCM\n125.\n;\n(if (not (or (null? obj) (pair? obj)))\n126.\n;\n(error \"Deconstructor for CONS given a non list\")))\n127.\n;\n(if (pair? obj)\n128.\n;\n(succ (car obj) (cdr obj))\n129.\n; This can't work without the deconstructor being passed the\n130.\n; number of args given to the deconstructor (or a datum from\n131.\n; which that number could be constructed).\n132.\n;\n133.\n; (define list\n134.\n; (make-constructor\n135.\n; (access list ())\n136.\n; (lambda (obj succ fail)\n137.\n;\n(if (list? obj)\n138.\n;\n(apply succ obj)\n139.\n;\n(fail)))))\n140.\n;;;----------------------------------------------------------------------------\n141.\n;;; Simulated S-EXPRESSION datatype\n\n142.\n(define (make-sexp-constructor sym pred)\n143.\n(make-constructor\n144.\n(lambda (sexp)\n; Constructor does a type check with PRED\n145.\n(if (pred sexp)\na. sexp\nb. (error \"Sexp constructor -- incorrect type:\" sym sexp)))\n146.\n(lambda (sexp succ fail) ; Deconstructor does a type check with PRED\n147.\n(if (pred sexp)\na. (succ sexp)\nb. (fail)))))\n148.\n(define int->sexp (make-sexp-constructor 'int integer?))\n149.\n(define real->sexp (make-sexp-constructor 'real real?))\n150.\n(define bool->sexp (make-sexp-constructor 'bool boolean?))\n151.\n(define char->sexp (make-sexp-constructor 'char char?))\n152.\n(define string->sexp (make-sexp-constructor 'string string?))\n153.\n(define symbol->sexp (make-sexp-constructor 'symbol symbol?))\n154.\n(define list->sexp (make-sexp-constructor 'list list?))\n155.\n(define vector->sexp (make-sexp-constructor 'vector vector?))\n\n156.\n;; reistad 8/24/94 -- added for orthogonality/uniformity with Scheme\n157.\n(define (scheme+/make-check-type-constructor sym pred?)\n158.\n(make-constructor\n159.\n(lambda (obj) (if (pred? obj)\ni. obj\nii. (error \"Object was not of correct type:\" sym obj)))\n160.\n(lambda (obj succ fail)\n161.\n(if (pred? obj)\na. (succ obj)\nb. (fail)))))\n162.\n(define a-number (scheme+/make-check-type-constructor 'number\nnumber?))\n163.\n(define an-integer (scheme+/make-check-type-constructor 'integer\ninteger?))\n164.\n(define a-real\n(scheme+/make-check-type-constructor 'real real?))\n165.\n(define a-complex (scheme+/make-check-type-constructor 'complex\ncomplex?))\n166.\n(define a-rational (scheme+/make-check-type-constructor 'rational\nrational?))\n167.\n(define a-char\n(scheme+/make-check-type-constructor 'char char?))\n168.\n(define a-boolean (scheme+/make-check-type-constructor 'boolean\nboolean?))\n169.\n(define a-symbol (scheme+/make-check-type-constructor 'symbol\nsymbol?))\n170.\n(define a-procedure (scheme+/make-check-type-constructor 'procedure\nprocedure?))\n171.\n(define a-vector (scheme+/make-check-type-constructor 'vector\nvector?))\n172.\n(define a-list\n(scheme+/make-check-type-constructor 'list list?))\n173.\n(define a-string (scheme+/make-check-type-constructor 'string string?))\n\n174.\n;;; reistad 8/19/94 -- taken from mini-fx (1991) for low level macro system\n175.\n;;;\n176.\n;;; Additional procedures for manipulating s-expressions with QUOTE,\n177.\n;;; QUASIQUOTE, UNQUOTE, and UNQUOTE-SPLICING.\n178.\n(define (scheme+/make-quote-constructor sym)\n179.\n(make-constructor\n180.\n(lambda (x) (list sym x))\n181.\n(let ((pred (lambda (thing)\ni. (and (pair? thing)\nii. (eq? (car thing) sym)\niii. (pair? (cdr thing))\niv. (null? (cddr thing))))))\n182.\n(lambda (thing succ fail)\n183.\n(if (pred thing)\na. (succ (cadr thing))\nb. (fail))))))\n;; Constructor tags item\n;; Deconstructor checks tag\n184.\n(define quoted->sexp\n(scheme+/make-quote-constructor 'quote))\n185.\n(define quasiquoted->sexp\n(scheme+/make-quote-constructor\n'quasiquote))\n186.\n(define unquoted->sexp\n(scheme+/make-quote-constructor\n'unquote))\n187.\n(define unquoted-splicing->sexp (scheme+/make-quote-constructor\n'unquote-splicing))\n\n188.\n;;---------------------------------------------------\n189.\n;; datatype.scm\n190.\n;;;----------------------------------------------------------------------------\n191.\n;;; DATATYPE.SCM\n192.\n;;;\n193.\n;;; Author: Lyn\n194.\n;;; Log:\n195.\n;;; * 8/19/94 - reistad: Eliminated use of define-syntax so define-datatype\n196.\n;;;\nmacro is now in match.scm. Also dropped use of dtyp-desc\nas\n197.\n;;;\nScheme+ ingnores all type crap.\n198.\n;;;\nDefine-Datatype now defines the constructor name to be a package\n199.\n;;;\nof both a bundler and unbundler as we've eliminated ~. The\n200.\n;;;\nconstructor is behaves just like the bundler but has a way to\n201.\n;;;\nget to the unbundler.\n202.\n;;; * 8/11/94 - Updated\n203.\n;;; * 6/20/94 - Created\n204.\n;;;\n205.\n;;; Notes:\n206.\n;;; Implements datatypes for Scheme+. There is a design choice here that\n207.\n;;; doesn't exist for Mini-FX: what should an unbundler do when not given\n208.\n;;; a discriminant of the expected type? E.g., suppose BAR is a constructor\n209.\n;;; for datatype FOO, and P is an instance of the CONS datatype. Should\n210.\n;;;\n211.\n;;; ((unbundler bar) p <succeed> <fail>)\n212.\n;;;\n213.\n;;; signal an error, or merely call <fail>? The latter is more in the\n214.\n;;; \"Scheme tradition\", but the former provides superior error messages\n215.\n;;; (otherwise, the only error is the largely unuseful \"No pattern\nmatched!\").\n216.\n;;; The latter makes sense if we view MATCH as being instantiated to a\n217.\n;;; particular datatype before we apply it.\n218.\n;;;\n219.\n;;; Since its not clear which version is The Right Thing, I provide a flag\n220.\n;;; *DATATYPE-PARANOID-MATCH?* that controls how this situation\nis handled.\n221.\n;;; By default, this is #t -- i.e., all desconstructors in a given match\n222.\n;;; are assumed to be for the same datatype.\n223.\n;;;\n224.\n;;;----------------------------------------------------------------------------\n225.\n;; see NOTES above\n226.\n(define *datatype-paranoid-match?* #t)\n\n227.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n228.\n;;; DEFINE-DATATYPE Begin\n229.\n;;;\n230.\n;;; DEFINE-DATATYPE declares a sum-of-products data structure\n231.\n;;; and creates the associated constructors.\n232.\n;;;\n233.\n;;; NOTE: the implementation below uses the same name for both the\nconstructor\n234.\n;;; and deconstructor. (Actually uses application hooks to store the\n235.\n;;; deconstructor on the constructor.) -- ACTUALLY, renamed so that\n236.\n;;; always use constructor to refer to bundler/unbundler pair.\n237.\n;;;\n238.\n;;; E.g.\n239.\n;;;\n240.\n;;; (define-datatype int-tree\n241.\n;;;\n(int-leaf int)\n242.\n;;;\n(int-node int-tree int-tree))\n243.\n;;;\n244.\n;;; expands into\n\n245.\n;;;\n246.\n;;; (define int-leaf (make-constructor\n247.\n;;;\n(lambda (i) ...)\n;; constructor\n\n248.\n;;;\n(lambda (t succ fail) ...)))\n;; deconstructor\n249.\n;;; (define int-node (make-constructor\n250.\n;;;\n(lambda (t1 t2) ...)\n;; constructor\n251.\n;;;\n(lambda (t succ fail) ...)))\n;; deconstructor\n252.\n;;;\n253.\n;;; where\n254.\n;;;\n255.\n;;; (int-leaf 0) -> #[int-tree:int-leaf 0]\n256.\n;;;\n257.\n;;; (int-node (int-leaf 0) (int-leaf 1)) ->\n258.\n;;;\n#[int-tree:int-node\n259.\n;;;\n#[int-tree:int-leaf 0]\n260.\n;;;\n#[int-tree:int-leaf 1]]\n261.\n;;;\n262.\n;;; Here's a sample procedure using INT-TREE. Note the use of\n263.\n;;; deconstructors in the patterns of MATCH (eventhough there's no ~s)\n264.\n;;;\n265.\n;;; (define (int-tree-sum t)\n266.\n;;;\n(match t\n\n267.\n;;;\n((int-leaf n) n)\n268.\n;;;\n((int-node left right) (+ (tree-sum left) (tree-sum right)))))\n269.\n;;;\n270.\n;;;\n271.\n;;; DEFINE-DATATYPE can be parameterized by type as well:\n272.\n;;; (Yeah, but all types are ignored -- documentation only.\n273.\n;;;\n274.\n;;; (define-datatype (tree t)\n275.\n;;;\n(leaf t)\n276.\n;;;\n(node (tree t) (tree t)))\n277.\n;;;\n278.\n;;;DROP THIS?\n279.\n;;; These type parameters are (conceptually) parameters of the constructors\n280.\n;;; and deselectors, but can be thought of as being removed by\n281.\n;;; implicit projection. E.g. the above \"expands\" into\n282.\n;;;\n283.\n;;; ; Constructors\n284.\n;;; (define leaf (plambda (t) (lambda (i) ...)\n285.\n;;; (define node (plambda (t) (lambda (t1 t2) ...)\n286.\n;;; ; Deconstructors\n287.\n;;; (define leaf~ (plambda (t) (lambda (t success-cont fail-cont) ...))\n288.\n;;; (define node~ (plambda (t) (lambda (t success-cont fail-cont) ...))\n289.\n;;;\n290.\n;;; but the t's never have to be specified:\n291.\n;;;\n292.\n;;; (define (tree-depth t)\n293.\n;;;\n(match t\n294.\n;;;\n((leaf t) 0)\n295.\n;;;\n((node left right) (1+ (max (tree-depth left) (tree-depth right))))\n296.\n;;;\n297.\n;;;\n((node left right) (1+ (max (tree-depth left) (tree-depth right))))))\n298.\n;;;\n299.\n;;;\n300.\n;;; ---------------------------------------------------------------------------\n301.\n;;; Begin DEFINE-DATATYPE code\n302.\n;;; ---------------------------------------------------------------------------\n303.\n;;; The DEFINE-DATATYPE macro\n304.\n;;; There are two possible forms for DEFINE-DATATYPE:\n305.\n;;;\n306.\n;;; (define-datatype I (I D*)*)\n; Straightforward datatype\n307.\n;;; (define-datatype (I I*) (I D*)*)\n; Parameterized datatype\n308.\n;;;\n309.\n;;; Here we ignore any params if they occur.\n\n310.\n;;;\n311.\n;;; In this implementation we ignore types altogether and simply simulate\nthe\n312.\n;;; run-time behavior of DEFINE-DATATYPE.\n313.\n;;; Begin DEFINE-DATATYPE macro\n314.\n(define-scheme+-macro (define-datatype name-or-name+params . sum-of-\nproducts)\n315.\n(define (datatype-name header)\n316.\n(cond\n317.\n((symbol? header)\nheader)\n; (define-datatype I (I D*)*)\n318.\n((and (pair? header)\n; (define-datatype (I I*) (I D*)*)\na. (every? symbol? header))\n319.\n(car name-or-name+params))\n320.\n(else\n; otherwise is not a legal define-datatype\n321.\n(scheme+/syntax-error \"Ill-formed DEFINE-DATATYPE header: \"\nheader))\n322.\n))\n323.\n(define (datatype-clause-names-and-params clause-list receiver)\n324.\n(if (null? clause-list)\n325.\n(receiver '() '())\n326.\n(let ((first-clause (car clause-list)))\na. (if (and (list? first-clause)\ni. (>= (length first-clause) 1))\nb. (datatype-clause-names-and-params\ni. (cdr clause-list)\nii. (lambda (names params)\niii. (receiver\niv. (cons (check-clause-name (car (car clause-list)))\n1. names)\nv. (cons (map check-clause-param (cdr (car clause-list)))\n1. params))))\nc. (scheme+/syntax-error\ni. (string-append\nii. \"Ill-formed DEFINE-DATATYPE clause.\\n\"\niii. \"(Clauses must be of the form: (<constructor-name> <type_1> ...\n<type_n>) ):\\n\"\niv. )\nv. first-clause)))))\n327.\n(define (check-clause-name obj)\n328.\n(if (symbol? obj)\n329.\nobj\n\n330.\n(scheme+/syntax-error\na. \"Non-symbolic constructor name within a DEFINE-DATATYPE\nclause:\\n\"\nb. obj)))\n331.\n;; *** Need to have this do real error checking in future\n332.\n(define (check-clause-param type) type)\n333.\n(define (every? test lst)\n334.\n(if (null? lst)\n335.\n#t\n336.\n(and (test (car lst))\na. (every? test (cdr lst)))))\n337.\n; Main body of DEFINE-DATATYPE macro\n338.\n(let ((dname (datatype-name name-or-name+params)))\n339.\n(datatype-clause-names-and-params sum-of-products\n340.\n(lambda (clause-names clause-params)\n341.\n`(begin\na. ;; Since Scheme+ has a single namespace, we must bind the datatype\nb. ;; name to *some* kind of object in order to preserve the semantics\nc. (DEFINE ,dname ,(make-datatype-descriptor dname)) ;;? clause-names\nd. ,@(map (lambda (cname cparams)\ni. `(DEFINE ,cname\nii. (scheme+/make-constructor\n1. (scheme+/make-datatype-bundler ',dname\na. ',cname\nb. ,(length cparams))\n2. (scheme+/make-datatype-unbundler ',dname\na. ',cname))))\niii. clause-names\niv. clause-params)\ne. ,dname))))\n342.\n)\n343.\n;;; End DEFINE-DATATYPE macro\n344.\n;;; ---------------------------------------------------------------------------\n345.\n;;; DEFDATATYPE is a synonym for DEFINE-DATATYPE\n346.\n(define-scheme+-macro (defdatatype name-or-name+params . sum-of-\nproducts)\n347.\n`(DEFINE-DATATYPE ,name-or-name+params ,@sum-of-products))\n\n348.\n;; helper procedures\n349.\n(define (scheme+/make-datatype-bundler dtyp-name cnstr-name nargs)\n350.\n(lambda args\n351.\n(if (= nargs (length args))\n352.\n(make-datatype-instance dtyp-name dtyp-name cnstr-name args)\n353.\n(error \"Incorrect number of arguments given to bundler\"\ni. cnstr-name\nii. args))))\n354.\n(define make-datatype-bundler scheme+/make-datatype-bundler)\n355.\n(define (scheme+/make-datatype-unbundler dtyp-name cnstr-name)\n356.\n(lambda (obj succ fail)\n357.\n(if *datatype-paranoid-match?* ; Could move this outside if\n1. ; wanted creation-time choice.\n358.\n;; This case signals an error if OBJ isn't exactly right.\n359.\n(scheme+/ensure-datatype dtyp-name cnstr-name obj)\n360.\nobj)\n361.\n(if (and (datatype-instance? obj)\na. (eq? dtyp-name (datatype-instance-descriptor obj))\nb. (eq? cnstr-name (datatype-instance-constructor obj)))\n362.\n(apply succ (datatype-instance-args obj))\n363.\n(fail))))\n364.\n(define make-datatype-unbundler scheme+/make-datatype-unbundler)\n365.\n(define (scheme+/ensure-datatype dtyp-name cnstr-name obj)\n366.\n(cond\n367.\n((not (datatype-instance? obj))\n368.\n(error (string-append \"Unbundler \"\n1. (symbol->string cnstr-name)\n2. \" for datatype \"\n3. (symbol->string dtyp-name)\n4. \" applied to non-datatype instance: \")\nb. obj))\n369.\n((not (eq? dtyp-name (datatype-instance-descriptor obj)))\n370.\n(error (string-append \"Unbundler \"\n1. (symbol->string cnstr-name)\n2. \" for datatype \"\n3. (object->string dtyp-name)\n4. \" applied to instance of datatype \"\n5. (object->string (datatype-instance-descriptor obj))\n6. \": \")\nb. obj))\n371.\n(else obj)))\n\n372.\n(define (print-datatype-descriptor state desc)\n373.\n(unparse-string state \"#[datatype \")\n374.\n(unparse-object state (datatype-descriptor-name desc))\n375.\n(unparse-string state \"]\"))\n376.\n(define (print-datatype-instance state instance)\n377.\n(let ((type-name (datatype-instance-type-name instance))\n378.\n(constructor (datatype-instance-constructor instance))\n379.\n(args (datatype-instance-args instance)))\n380.\n(unparse-string state \"#[\")\n381.\n(unparse-object state type-name)\n382.\n(unparse-string state \":\")\n383.\n(unparse-object state constructor)\n384.\n(for-each (lambda (arg)\ni. (unparse-string state \" \")\nii. (unparse-object state arg))\nb. args)\n385.\n(unparse-string state \"]\")\n386.\n))\n387.\n(define (object->string obj)\n388.\n(with-output-to-string\n389.\n(lambda () (display obj))))\n390.\n;;; Structures\n391.\n(define-structure (datatype-descriptor\ni. (print-procedure print-datatype-descriptor))\n392.\nname)\n393.\n(define-structure (datatype-instance\ni. (print-procedure print-datatype-instance))\n394.\ndescriptor\n395.\ntype-name\n396.\nconstructor\n397.\nargs)\n\n398.\n;;---------------------------------------------------\n399.\n;; match.scm\n400.\n;;; DEFINE-DATATYPE and MATCH\n401.\n;;; Log:\n402.\n;;;\n403.\n;;; reistad 8/19/94 -- Taken from /zu/lyn/6821/fall-91/code/mini-fx.scm\n404.\n;;;\nto replace original Scheme+ implementation with define-syntax.\n405.\n;;;\nNow use low level macros like in the past.\n406.\n;;;\nAll global refs in macro output code protected with (get-real <id>)\n407.\n;;;\nwhich ensures that they cannot be shadowed by user definitions.\n408.\n;;;\n409.\n;;; reistad & lyn 8/23/94 (or thereabouts) Redesigned the MATCH\ndesugaring\n410.\n;;;\nto look a lot nicer. Previous version was verbose and\n411.\n;;;\ntended to shift to the right a lot.\n412.\n;;;\n413.\n;;; reistad & lyn 8/24/94 Designed and implemented a WITH-FAIL\nconstruct\n414.\n;;;\nthat captures the failure continuation at the beginning of\n415.\n;;;\na MATCH clause. Brian extends to handle duplicated pattern\n416.\n;;;\nby doing a renaming prepass on the pattern and using WITH-FAIL.\n417.\n;;;\n418.\n;;; lyn 9/09/94 -- Fixed RENAME-IN-QUASIQUOTE to handle `_'\ncorrectly\n419.\n;;;\nwithin QUASIQUOTED patterns. They were getting renamed when\n420.\n;;;\nthey shouldn't have been.\n421.\n;;;\n422.\n;;; lyn 9/10/94 -- Fixed RENAME-IN-QUASIQUOTE to correctly handle\n423.\n;;;\n+ non-symbol atoms (e.g., null, numbers, strings, etc.)\n424.\n;;;\n+ deconstructions (i.e., applications of constructors in\n425.\n;;;\npattern position)\n426.\n;;;\nPrevious version would try to rename these and barf if it\n427.\n;;;\nfound duplicates!\n428.\n;;;\nI'm still somewhat confused because I don't understand why\n429.\n;;;\nrenamer seems to get called twice on every pattern!\n430.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n431.\n;;; MATCH Begin\n432.\n;;; This is not the most efficient possible strategy for implementing\n433.\n;;; ML-style pattern matching.\n\n434.\n;;;\n435.\n;;; (match foo ((make-foo x y) ...) ...)\n436.\n;;; ==> (~match-make-foo foo 2 (lambda (x y) ...) (lambda () ...))\n437.\n;;;\n438.\n;;; JAR sez: Don't try to understand the implementation of this macro\nwithout\n439.\n;;; proper supervision.\n440.\n;;; Here are the desugaring rules used below\n441.\n;;;\n442.\n;;; -------------------------------------------------------\n443.\n;;; (match e (pat_1 e_1) ... (pat_n e_n))\n444.\n;;;\n445.\n;;; -> expand(e,\n446.\n;;;\npat_1, ..., pat_n\n447.\n;;;\ne_1, ... e_n)\n448.\n;;;\n449.\n;;; -------------------------------------------------------\n450.\n;;; expand(e,\n451.\n;;;\npat_1, ..., pat_n\n452.\n;;;\ne_1, ... e_n)\n453.\n;;;\n454.\n;;;\n455.\n;;; -> (error \"Match -- no pattern matched\"), n = 0\n456.\n;;;\n457.\n;;; -> (let ((id e))\n; id is fresh\n458.\n;;;\nexpand-pattern(pat_1\n459.\n;;;\nid\n460.\n;;;\ne_1\n461.\n;;;\nexpand(id,\n462.\n;;;\npat_2, ... pat_n\n463.\n;;;\ne_2, ..., e_n))) else\n464.\n;;;\n465.\n;;; -------------------------------------------------------\n466.\n;;;\n467.\n;;; expand-pattern(pat, v, succ-exp, fail-exp) ; Note v is always an id\n468.\n;;;\n469.\n;;; -> succ-exp, pat = _\n470.\n;;;\n471.\n;;; -> (if (=pat v) succ-exp fail-exp), pat a literal\n472.\n;;;\n; Note this is *only* place where failure\nexpression\n473.\n;;;\n; can be evaluated, which makes sense, since\n474.\n;;;\n; it's the only place that can really detect\n475.\n;;;\n; a mismatch\n476.\n;;;\n\n477.\n;;; -> (let ((pat v)) succ-exp), pat a variable\n478.\n;;;\n479.\n;;; -> (e v (lambda (id_1 ... id_n) ; where id_i = pat_i, pat_i is a variable\n480.\n;;;\n;\nis fresh, otherwise\n481.\n;;;\nexpand-sub-patterns(pat_1, ..., pat_n,\n482.\n;;;\nid_1, ... id_n,\n483.\n;;;\nsucc-exp,\n484.\n;;;\nfail-exp))\n485.\n;;;\n(lambda () ,fail-exp)), pat = (e pat_1 ... pat_n)\n486.\n;;;\n487.\n;;; -------------------------------------------------------\n488.\n;;;\n489.\n;;; expand-sub-patterns(pat_1, ..., pat_n,\n490.\n;;;\nid_1, ... id_n,\n491.\n;;;\nsucc-exp,\n492.\n;;;\nfail-exp)\n493.\n;;;\n494.\n;;; -> succ-exp, n = 0\n495.\n;;;\n496.\n;;; -> expand-pattern(pat_1\n497.\n;;;\nid_1\n498.\n;;;\nexpand-sub-patterns(pat_2, ..., pat_n,\n499.\n;;;\nid_2, ..., id_n,\n500.\n;;;\nsucc-exp,\n501.\n;;;\nfail-exp)\n502.\n;;;\n(fail-exp))\n503.\n;;;\n504.\n;;;-------------------------------------------------------------------\n505.\n;;; Example (note extra error checking and space-saving code\n506.\n;;;\noptimizations not necessarily implied by above rules:\n507.\n;;;\n508.\n;;; (match x\n509.\n;;; ((foo~ a (bar~ b)) (list a b))\n510.\n;;; (_ '())))\n511.\n;;;\n512.\n;;; -- desugars to -->\n513.\n;;;\n514.\n;;; (let\n515.\n;;; ((#fail-254 (lambda () ()))) ; Why isn't the second () quoted here?\n516.\n;;; (foo~\n517.\n;;; x\n518.\n;;; (lambda\n519.\n;;; #success-arg-256\n520.\n;;; (if\n521.\n;;;\n(not (= (*mini-fx-length* #success-arg-256) 2))\n522.\n;;;\n(*mini-fx-success-number-of-args-mismatch* '(a (bar~ b)) 2)\n\n523.\n;;;\n(apply\n524.\n;;;\n(lambda\n525.\n;;;\n(a #temp-255)\n526.\n;;;\n(bar~\n527.\n;;;\n#temp-255\n528.\n;;;\n(lambda\n529.\n;;;\n#success-arg-257\n530.\n;;;\n(if\n531.\n;;;\n(not (= (*mini-fx-length* #success-arg-257) 1))\n532.\n;;;\n(*mini-fx-success-number-of-args-mismatch* '(b) 1)\n533.\n;;;\n(apply (lambda (b) (list a b)) #success-arg-257)))\n534.\n;;;\n#fail-254))\n535.\n;;;\n#success-arg-256)))\n536.\n;;; #fail-254))\n\n537.\n;;; ---------------------------------------------------------------------------\n538.\n;;; The MATCH macro\n539.\n(define-scheme+-macro (match thing . clauses)\n540.\n(define (expand thing clauses)\n541.\n(if (null? clauses)\n542.\n`(scheme+/runtime-error \"MATCH -- no pattern matched to disc.\" ,thing)\n543.\n(let ((clause (car clauses)))\na. (define (make-matcher disc clauses)\nb. `(scheme+/match-clauses ,disc\na. '(match ,thing ,@clauses)\nb. ,@(map (expand-clause disc) clauses)))\nc. (if (not (pair? thing))\nd. ;; Optimization where discriminant is a literal or variable\ne. (make-matcher thing clauses)\nf. ;; Name discriminate so that only evaluate once\ng. (let ((thing-gensym (scheme+/gensym 'thing)))\ni. `(LET ((,thing-gensym ,thing))\nii. ,(make-matcher thing-gensym clauses)))))))\n544.\n(define (expand-clause thing)\n545.\n(lambda (clause)\n546.\n;; should return a failure acceptor\n547.\n(let* ((failure (scheme+/gensym 'fail))\na. (make-failure-acceptor (lambda (body)\na. `(lambda (,failure) ,body))))\n548.\n(cond ((with-fail? clause)\ni. (make-failure-acceptor (expand-with-fail thing clause failure)))\nb. ((and (pair? clause)\ni. (pair? (cdr clause))\nii. (null? (cddr clause)))\niii. (make-failure-acceptor\niv. (expand-pattern-top (car clause) thing (cadr clause) failure)))\nc. (else (scheme+/syntax-error \"Invalid match clause syntax: \" clause))))))\n549.\n;; Original version without user-level capture of the failure continuation\n550.\n; (define (expand-clause thing clause fail-exp)\n551.\n;\n(if (and (pair? clause)\n552.\n;\n(pair? (cdr clause))\n553.\n;\n(null? (cddr clause)))\n554.\n;\n(expand-pattern (car clause) thing (cadr clause) fail-exp)\n555.\n;\n(scheme+/syntax-error \"Invalid match clause syntax\" clause)))\n\n556.\n;; With-fail allows the user to capture the failure continuation. Ie,\n557.\n;; (match <foo>\n558.\n;; ((add e e) <body>))\n559.\n;;\n560.\n;; would be written:\n561.\n;;\n562.\n;; (match <foo>\n563.\n;; ((add e e.2)\n564.\n;; (with-fail\n565.\n;;\n(lambda (fail)\n566.\n;;\n(if (equal? e e.2)\n567.\n;;\n<body>\n568.\n;;\n(fail))))))\n569.\n;;\n570.\n;; Idea for new sugar on-top of with-fail (trevor)\n571.\n;; (<pat> (where <exp_test> <exp_body))\n572.\n;; ==> (<pat> (with-fail (lambda (fail) (if <exp_test> <exp_body>\n(fail)))))\n573.\n;;\n574.\n(define (with-fail? clause)\n575.\n(and (pair? clause)\na. (pair? (cdr clause))\nb. (null? (cddr clause))\nc. (let ((body (cadr clause)))\nd. (and (pair? body)\ni. (pair? (cdr body))\nii. (null? (cddr body))\niii. (eq? (car body) 'with-fail)))))\n576.\n(define (fail-body clause)\n577.\n(cadr (cadr clause)))\n578.\n(define (expand-with-fail thing clause fail-name)\n579.\n;; Be sure to call expand-pattern-top to handle\n580.\n;; duplicate pattern variables.\n581.\n(expand-pattern-top (car clause)\n1. thing\n2. `(scheme+/handle-with-fail ,(fail-body clause)\n1. ,fail-name)\n3. fail-name))\n582.\n;; End with-fail.\n583.\n;; expand-pattern-top: entry point for pattern expansion\n584.\n;; First grovell pat to find duplicate pattern variables so we can\n585.\n;; use with-fail to make them do the right thing.\n\n586.\n(define (expand-pattern-top pat thing succ-exp fail-name)\n587.\n(with-values (lambda () (rename-pattern-variables pat empty-dict))\n588.\n(lambda (new-pat dict)\n589.\n(let ((dict (list-transform-negative dict used-once?)))\na. (if (null? dict)\nb. (expand-pattern pat thing succ-exp fail-name)\nc. ;; Note: could just call expand-pattern directly as fail-name\nd. ;; is in scope:\ne. ;; (expand-pattern new-pat thing\nf. ;;\n(if (and ,@(gen-check-dups dict))\ng. ;;\n,succ-exp\nh. ;;\n(,fail-name))\ni. ;;\nfail-name)\nj. (expand-with-fail\ni. thing\nii. (let ((fail-gensym (scheme+/gensym 'fail)))\niii. `(,new-pat (with-fail\n1. (lambda (,fail-gensym)\na. (if (and ,@(gen-check-dups dict))\nb. ,succ-exp\nc. (,fail-gensym))))))\niv. fail-name))))))\n590.\n(define (rename-pattern-variables pat dict)\n591.\n;; Rename duplicate pattern variables and\n592.\n;; use values to return new pattern and a dictionary of pattern variables\n593.\n;; Eg. (mul (add e e) (var x)) ==> (values (add e e.2) ((e e.2) (x)))\n594.\n(cond ((eq? pat '_) (values pat dict))\na. ((symbol? pat)\nb. (if (in-dict? pat dict)\ni. (let ((new-var (scheme+/gensym pat)))\nii. (extend-entry! pat new-var dict)\niii. (values new-var dict))\niv. (values pat (add-entry pat dict))))\nc. ((not (pair? pat)) (values pat dict))\n;; constant pattern\nd. ((or (eq? (car pat) 'symbol)\ni. (eq? (car pat) 'quote))\ne. (values pat dict))\nf. ((eq? (car pat) 'quasiquote)\ng. (with-values (lambda () (rename-in-quasiquote (cadr pat) dict))\nh. (lambda (new-cadr dict)\ni. (values `(,'quasiquote ,new-cadr) dict))))\ni. (else\nj. ;; (constructor pat1 pat2 ... patn)\nk. (with-values (lambda () (rename-list (cdr pat) dict))\n\nl. (lambda (patterns dict)\ni. (values `(,(car pat) ,@patterns) dict))))\nm. ))\n595.\n(define empty-dict '())\n596.\n(define (in-dict? x dict) (assoc x dict))\n597.\n(define (add-entry x dict) `((,x) ,@dict))\n598.\n(define (extend-entry! x new dict)\n599.\n(let ((entry (assoc x dict)))\n600.\n(set-cdr! entry (cons new (cdr entry)))\n601.\n))\n602.\n(define (used-once? dict-entry)\n603.\n(= (length dict-entry) 1))\n604.\n(define (gen-check-dups dict)\n605.\n(if (null? dict)\n606.\n'()\n607.\n`(,(gen-ensure-equal (car dict)) ,@(gen-check-dups (cdr dict)))))\n608.\n(define (gen-ensure-equal lst)\n609.\n(let ((first (car lst)))\n610.\n`(and ,@(let loop ((rest (cdr lst)))\ni. (if (null? rest)\nii. '()\niii. ;;; Lyn changed on 9/10/94 to install scheme+/equal?\niv. ; `(((get-real equal?) ,first ,(car rest))\nv. ; ,@(loop (cdr rest)))\nvi. `((scheme+/equal? ,first ,(car rest))\nvii. ,@(loop (cdr rest))))))))\n611.\n(define (rename-list lst dict)\n612.\n(if (null? lst)\n613.\n(values '() dict)\n614.\n(with-values (lambda () (rename-pattern-variables (car lst) dict))\na. (lambda (new-head dict)\nb. (with-values (lambda () (rename-list (cdr lst) dict))\nc. (lambda (new-tail dict)\ni. (values (cons new-head new-tail) dict)))))))\n615.\n(define (rename-in-quasiquote body dict)\n616.\n(define (descend-quasi x level dict)\n617.\n(cond ((eq? x '_)\n; Handle _ specially -- don't rename!\na. (values x dict))\nb. ((symbol? x)\n; Level 0 symbols get added to dict\nc. (if (= level 0)\ni. (if (in-dict? x dict)\nii. (let ((tmp (scheme+/gensym x)))\n\niii. (extend-entry! x tmp dict)\niv. (values tmp dict))\nv. (values x (add-entry x dict)))\nvi. (values x dict)))\nd. ((not (pair? x))\n; Other atomic data (including empty list)\ne. (values x dict))\n; are treated as constants.\nf. ((and (not (null? (cdr x))) (null? (cddr x))) ; List of length 2\ng. (case (car x)\ni. ((unquote)\nii. (if (= level 0)\niii. (scheme+/syntax-error \"unquote too deep\")\niv. (with-values (lambda ()\na. (descend-quasi (cadr x) (- level 1) dict))\nv. (lambda (new dict)\n1. (values `(,'unquote ,new) dict)))))\nvi. ((unquote-splicing)\nvii. (if (= level 0)\nviii. (scheme+/syntax-error \"unquote-splicing too deep\")\nix. (with-values (lambda ()\na. (descend-quasi (cadr x) (- level 1) dict))\nx. (lambda (new dict)\n1. (values `(,'unquote-splicing ,new) dict)))))\nxi. ((quasiquote)\nxii. (with-values (lambda ()\na. (descend-quasi (cadr x) (+ level 1) dict))\nxiii. (lambda (new dict)\nxiv. (values `(,'quasiquote ,new) dict))))\nxv. ((quote)\nxvi. (with-values (lambda ()\na. (descend-quasi (cadr x) level dict))\nxvii. (lambda (new dict)\nxviii. (values `(,'quote ,new) dict))))\nxix. (else\nxx. (descend-quasi-deconstruction x level dict))))\nh. (else (descend-quasi-deconstruction x level dict))))\n618.\n(define (descend-quasi-deconstruction lst level dict)\n619.\n;;\n620.\n;; LST must be non-empty.\n621.\n;;\n622.\n;; If LEVEL is 0, then LST is a deconstruction and the car of LST\n623.\n;; is a constructor. The constructor should not be renamed, but\n624.\n;; its arguments should be.\n625.\n;;\n626.\n;; If LEVEL is not 0, treat LST as a regular list.\n627.\n;;\n628.\n(if (= level 0)\n\na. (with-values (lambda () (descend-quasi-list (cdr lst) level dict))\nb. (lambda (new-args dict)\nc. (values (cons (car lst) ; The constructor\n1. new-args)\nii. dict)))\nd. (descend-quasi-list lst level dict)))\n629.\n(define (descend-quasi-list x level dict)\n630.\n(if (null? x)\na. (values '() dict)\nb. (with-values (lambda () (descend-quasi (car x) level dict))\nc. (lambda (first dict)\nd. ;BJR: change to descend-quasi to handle dotted pairs\ne. ;(with-values (lambda() (descend-quasi-list (cdr x) level dict)))\nf. (with-values (lambda () (descend-quasi (cdr x) level dict))\ni. (lambda (rest dict)\nii. (values (cons first rest) dict)))))))\n631.\n; (trace-entry descend-quasi)\n632.\n; (trace-entry descend-quasi-list)\n633.\n; (trace-entry descend-quasi-deconstruction)\n634.\n(descend-quasi body 1 dict)\n635.\n)\n636.\n;; End rename-pattern-variables\n637.\n; succ-exp is an expressions\n638.\n; fail-name is a symbol -- name of the current failure continuation\n639.\n(define (expand-pattern pat thing succ-exp fail-name)\n640.\n(let ((fail-exp `(,fail-name)))\n641.\n(cond ((eq? pat '_) succ-exp)\na. ((symbol? pat)\nb. (if (eq? pat thing)\ni. succ-exp\n;Optimization for same variable that works\na. ;in conjunction with optimization for naming\nb. ;success lambda args below\nii. `(let ((,pat ,thing)) ,succ-exp)))\nc. ;; Don't make any assumptions about thing.\n642.\n;\n((number? pat)\n643.\n;\n`(if ((get-real =) ,thing ,pat) ,succ-exp ,fail-exp))\n644.\n;\n((boolean? pat)\n645.\n;\n`(if ((get-real eq?) ,thing ,pat) ,succ-exp ,fail-exp))\n646.\n;\n((char? pat)\n647.\n;\n`(if ((get-real char=?) ,thing ,pat) ,succ-exp ,fail-exp))\n648.\n;\n((string? pat)\n649.\n;\n`(if ((get-real string=?) ,thing ,pat) ,succ-exp ,fail-exp))\n\na. ((number? pat)\nb. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\nc. ((boolean? pat)\nd. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\ne. ((char? pat)\nf. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\ng. ((string? pat)\nh. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\ni. ((not (pair? pat))\nj. (scheme+/syntax-error \"unrecognized MATCH pattern: \" pat))\nk. ((eq? (car pat) 'symbol)\nl. `(if ((get-real eq?) ,thing ,pat) ,succ-exp ,fail-exp))\nm. ((eq? (car pat) 'quote)\nn. (let ((pred (if (symbol? (cadr pat))\n1. '(get-real eq?) ;Optimization\n2. '(get-real equal?))))\nii. `(if (,pred ,thing ,pat) ,succ-exp ,fail-exp)))\no. ((eq? (car pat) 'quasiquote)\np. (expand-pattern (expand-quasiquote (cadr pat) 0)\n1. thing succ-exp fail-name))\nq. (else\nr. (expand-compound-pattern pat thing succ-exp fail-name)))))\n650.\n; Expand a pattern of the form (op arg ...).\n651.\n; op is assumed to be an injection or construction procedure.\n652.\n; If it's not, you'll get a Scheme error of the form\n653.\n; \"unbound variable ~MATCH-OP\".\n654.\n(define (expand-compound-pattern pat thing succ-exp fail-name)\n655.\n(let ((number-of-sub-patterns (length (cdr pat)))\na. (success-arg-gensym (scheme+/gensym 'success-arg))\nb. (names (map (lambda (pat)\n1. (if (and (symbol? pat) (not (eq? pat '_)))\n2. pat\n;Optimization that works in conjunction\ni. ;with variable case for EXPAND-\nPATTERN\n3. (scheme+/gensym 'temp)))\nii. (cdr pat)))\nc. )\n656.\n`(\n657.\nscheme+/deconstruct-carefully\n658.\n,(car pat)\n659.\n',(cdr pat)\n660.\n,number-of-sub-patterns\n661.\n,thing\n\n662.\n(LAMBDA ,names\na. ,(let expand-sub-patterns ((pats (cdr pat))\na. (names names))\nb. (if (null? pats)\ni. succ-exp\nii. (expand-pattern (car pats)\na. (car names)\nb. (expand-sub-patterns (cdr pats) (cdr names))\nc. fail-name))))\n663.\n,fail-name)))\n664.\n; This is JAR's quasiquote pattern handler, which is exceptionally clever.\n665.\n; It tries to avoid the desugaring into CONS~\n666.\n; unless it absolutely has to. Here are some examples:\n667.\n;\n668.\n; `(a b) -> '(a b)\n669.\n; `(,a b) -> (list->sexp~ (cons~ a '(b)))\n670.\n; `(a ,b) -> (list->sexp~ (cons~ 'a (cons~ b '())))\n671.\n; `(,a ,b) -> (list->sexp~ (cons~ a (cons~ b '())))\n672.\n; `(,a ,@b) -> (list->sexp~ (cons~ a b))\n673.\n;;----------------------------------------------------------------------\n674.\n;; LYN'S NOTES ON QUOTATION\n675.\n;\n676.\n; What I had in mind is expressed by the following rewrite rules\n677.\n;\n678.\n; (quasiquote (unquote ?a)) => ?a\n679.\n;\n680.\n; (quasiquote ((unquote-splicing ?a) ?extra ?rest ...) => Error! illegal ,@\n681.\n;\n682.\n; (quasiquote ((unquote-splicing ?a)) => ?a\n683.\n;\n684.\n; (quasiquote (unquote-splicing ?a)) => Error! illegal ,@\n685.\n;\n686.\n; (quasiquote (?a . ?b)) => (cons (quasiquote ?a) (quasiquote ?b))\n687.\n;\n688.\n; (quasiquote ?a) => (quote ?a)\n689.\n;\n690.\n; (These rules must be applied in the order shown to get the precedence\n691.\n; right.)\n692.\n;\n693.\n; These rules treat UNQUOTE and UNQUOTE-SPLICING specially in\nthe\n694.\n; context of a quasiquote. Granted, this can give some weird effects;\n\n695.\n; the following are transcripts of the pattern matching implementation of\n696.\n; Scheme+:\n697.\n;\n698.\n; ;;;--------------------------------------------------\n699.\n; (define x 17)\n700.\n; (define y '(23))\n701.\n;\n702.\n; (match '(1 . 2)\n703.\n;\n(`(,x . ,y) (list y x)))\n704.\n; ;Value 56: (2 1)\n705.\n;\n706.\n; (match '(1 . 2)\n707.\n;\n(`(,x unquote y) (list y x)))\n708.\n; ;Value 57: (2 1)\n709.\n;\n710.\n; (match '(1 . 2)\n711.\n;\n(`(,x unquote y) (list y x)))\n712.\n; ;Value 57: (2 1)\n713.\n;\n714.\n; (match '(1 unquote y)\n715.\n;\n(`(,x unquote y) (list y x)))\n716.\n; ;Value 58: (,y 1)\n717.\n;\n718.\n; (match '(1 . 2)\n719.\n;\n(`(,x unquote y z) (list y x)))\n720.\n; ;No pattern matched!\n721.\n; ;To continue, call RESTART with an option number:\n722.\n;\n723.\n; (match '(1 unquote y z)\n724.\n;\n(`(,x unquote y z) (list y x)))\n725.\n; ;Value 64: ((23) 1) ; The (23) comes from definition of Y at top.\n726.\n;\n727.\n; (match '(1 2)\n728.\n;\n(`(,x ,@y) (list y x)))\n729.\n; ;Value 75: ((2) 1)\n730.\n;\n731.\n; (match '(1 2)\n732.\n;\n(`(,x . ,@y) (list y x)))\n733.\n; ;Illegal use of ,@ in pattern\n734.\n; ;To continue, call RESTART with an option number:\n735.\n; ; (RESTART 1) => Return to read-eval-print level 1.\n736.\n;\n737.\n; (match '(1 2)\n738.\n;\n(`(,x unquote-splicing y) (list y x)))\n739.\n; ;Illegal use of ,@ in pattern\n740.\n; ;To continue, call RESTART with an option number:\n\n741.\n;\n742.\n; (match '(1 unquote-splicing y z)\n743.\n;\n(`(,x unquote-splicing y z) (list y x)))\n744.\n; ;Value 76: ((23) 1) ; The (23) comes from definition of Y at top.\n745.\n;\n746.\n;\n747.\n; ;;;--------------------------------------------------\n748.\n;\n749.\n; The quirkiness is exhibited only with the symbols UNQUOTE and\n750.\n; UNQUOTE-SPLICING in a QUASIQUOTE context; all other symbols\nbehave as\n751.\n; expected. This is OK (IMHO) because these are part of the quasiquote\n752.\n; language. Even more convincing, the above interpretation is consistent\n753.\n; with what Scheme (at least MIT Scheme) does with QUASIQUOTE in a\n754.\n; non-pattern context. Observe:\n755.\n;\n756.\n; ;; Assume X is 17 and Y is (23)\n757.\n;\n758.\n; `(,x . ,y)\n759.\n; ;Value 81: (17 23)\n760.\n;\n761.\n; `(,x unquote y)\n762.\n; ;Value 78: (17 23)\n763.\n;\n764.\n; `(,x unquote y z)\n765.\n; ;Value 77: (17 unquote y z)\n766.\n;\n767.\n; `(,x ,@y)\n768.\n; ;Value 79: (17 23)\n769.\n;\n770.\n; `(,x . ,@y)\n771.\n; ;Syntax error: ,@ in illegal context: y\n772.\n; ;To continue, call RESTART with an option number:\n773.\n;\n774.\n; `(,x unquote-splicing y)\n775.\n; ;Syntax error: ,@ in illegal context: y\n776.\n; ;To continue, call RESTART with an option number:\n777.\n;\n778.\n; `(,x unquote-splicing y z)\n779.\n; ;Value 80: (17 unquote-splicing y z)\n780.\n;\n781.\n;\n782.\n; The only inconsistent usage is the treatment of ,@ in a pattern context\n783.\n; to avoid backtracking.\n784.\n;\n785.\n;;----------------------------------------------------------------\n\n786.\n;; NOTE: these procedures are all written with names using 'deconstructor'\n787.\n;; which is an out-of-date term -- the correct terminology is 'unbunlder'.\n788.\n(define (expand-quasiquote x level)\n789.\n(descend-quasiquote x level finalize-quasiquote))\n790.\n(define (descend-quasiquote x level return)\n791.\n(cond ((not (pair? x))\n; Includes null?\na. (return 'quote x))\nb. ((and (not (null? (cdr x))) (null? (cddr x))) ; List of length 2\nc. (case (car x)\nd. ((unquote)\ne. (if (= level 0)\ni. (return 'unquote (cadr x))\nii. (descend-interesting x (- level 1) unquoted->sexp return)))\nf. ((unquote-splicing)\ng. (if (= level 0)\ni. (return 'unquote-splicing (cadr x))\nii. (descend-interesting x (- level 1) unquoted-splicing->sexp return)))\nh. ((quasiquote)\ni. (descend-interesting x (+ level 1) quasiquoted->sexp return))\nj. ((quote)\nk. (descend-interesting x level quoted->sexp return))\nl. (else\nm. (descend-quasiquote-list x level return))))\nn. (else (descend-quasiquote-list x level return))))\n792.\n(define (descend-interesting x level inject return)\n793.\n(descend-quasiquote (cadr x) level\n794.\n(lambda (mode arg)\n795.\n(if (eq? mode 'quote)\na. (return 'quote x)\nb. (return 'unquote `(,inject ,(finalize-quasiquote mode arg)))))))\n796.\n(define (descend-quasiquote-list x level return)\n797.\n(descend-quasiquote-tail x level\n798.\n(lambda (mode arg)\n799.\n(if (eq? mode 'quote)\na. (return 'quote x)\nb. ;;BJR: list-sexp is identity and only needed for typing concerns\nc. ;; (return 'unquote `(,list->sexp ,arg))\nd. (return 'unquote arg)))))\n800.\n; Modified below to handle dotted pairs.\n801.\n; (define (descend-quasiquote-tail x level return)\n\n802.\n;\n(if (null? x)\n803.\n;\n(return 'quote x)\n804.\n;\n(descend-quasiquote-tail (cdr x) level\n805.\n;\n(lambda (cdr-mode cdr-arg)\n806.\n;\n(descend-quasiquote (car x) level\n807.\n;\n(lambda (car-mode car-arg)\n808.\n;\n(cond ((and (eq? car-mode 'quote) (eq? cdr-mode 'quote))\n809.\n;\n(return 'quote x))\n810.\n;\n((eq? car-mode 'unquote-splicing)\n811.\n;\n(cond ((and (eq? cdr-mode 'quote) (null? cdr-arg))\n812.\n;\n;; (,@mumble)\n813.\n;\n(return 'unquote car-arg)) ;Type must be a list!\n814.\n;\n(else (scheme+/syntax-error \"Illegal use of @ in\na quasiquoted pattern.\"))))\n815.\n;\n; JAR allowed the following, but doesn't make sense\n816.\n;\n; without backtracking.\n817.\n;\n; (else\n818.\n;\n; ;; (,@mumble ...)\n819.\n;\n; (return 'unquote\n820.\n;\n;\n`(,append-word ,car-arg\n821.\n;\n;\n,(finalize-quasiquote\n822.\n;\n;\ncdr-mode cdr-arg))))\n823.\n;\n(else\n824.\n;\n(return 'unquote\n825.\n;\n;; what is cons-word supposed to be?\n826.\n;\n`(,cons ,(finalize-quasiquote car-mode car-arg)\n827.\n;\n,(finalize-quasiquote cdr-mode\ncdr-arg)))))))))))\n828.\n(define (descend-quasiquote-tail x level return)\n829.\n(if (null? x)\n830.\n(return 'quote x)\n831.\n;; BJR&LYN: This handles dotted-pair too!\n832.\n(descend-quasiquote (cdr x) level\na. (lambda (cdr-mode cdr-arg)\nb. (descend-quasiquote (car x) level\nc. (lambda (car-mode car-arg)\ni. (cond ((and (eq? car-mode 'quote) (eq? cdr-mode 'quote))\nii. (return 'quote x))\niii. ((eq? car-mode 'unquote-splicing)\niv. (cond ((and (eq? cdr-mode 'quote) (null? cdr-arg))\n1. ;; (,@mumble)\n2. (return 'unquote car-arg)) ;Type must be a list!\n3. (else (scheme+/syntax-error \"Illegal use of @ in a\nquasiquoted pattern.\"))))\nv. ((and (eq? cdr-mode 'unquote-splicing)\n\n1. (not (pair? (cdr x))))\nvi. ;; (foo . ,@x)\nvii. (scheme+/syntax-error\n1. \"Illegal use of @ in a quasiquoted pattern.\"))\nviii. ; JAR allowed the following, but doesn't make sense\nix. ; without backtracking.\nx. ; (else\nxi. ; ;; (,@mumble ...)\nxii. ; (return 'unquote\nxiii. ;\n`(,append-word ,car-arg\nxiv. ;\n,(finalize-quasiquote\nxv. ;\ncdr-mode cdr-arg))))\nxvi. (else\nxvii. (return 'unquote\na. `(,cons ,(finalize-quasiquote car-mode car-arg)\ni. ,(finalize-quasiquote cdr-mode cdr-\narg)))))))))))\n833.\n(define (finalize-quasiquote mode arg)\n834.\n(case mode\n835.\n((quote) `',arg)\n836.\n((unquote) arg)\n837.\n((unquote-splicing)\n838.\n(scheme+/syntax-error \",@ in illegal context: \" arg)) ;`,@x or ``,,@x or `(y\n. ,@x)\n839.\n(else\n840.\n(scheme+/syntax-error \"quasiquote bug: \" (list mode arg)))))\n841.\n(define (non-atomic-deconstructors clauses)\n842.\n(remove-duplicates\n843.\n(mapcan (lambda (c)\ni. (filter\nii. pair?\niii. (deconstructors (match-clause-pattern c))))\nb. clauses)))\n844.\n(define (deconstructors pat)\n845.\n(cond ((not (pair? pat)) '())\na. ((quote? pat) '())\nb. ((quasiquote? pat)\nc. (mapcan deconstructors\ni. (quasiquote-embedded-expressions (quasiquote-text pat))))\nd. (else\ne. (cons (car pat)\ni. (mapcan deconstructors (cdr pat))))))\n\n846.\n(define (filter pred lst)\n847.\n(cond ((null? lst) '())\na. ((pred (car lst))\nb. (cons (car lst) (filter pred (cdr lst))))\nc. (else (filter pred (cdr lst)))))\n848.\n(define (mapcan proc lst)\n849.\n(if (null? lst)\n850.\n'()\n851.\n(append (proc (car lst))\ni. (mapcan proc (cdr lst)))))\n852.\n(define (remove-duplicates lst)\n853.\n(if (null? lst)\n854.\n'()\n855.\n(let ((result (remove-duplicates (cdr lst))))\na. (if (member (car lst) result)\nb. result\nc. (cons (car lst) result)))))\n856.\n(define (quasiquote-embedded-expressions exp)\n857.\n(let descend-quasiquote ((exp exp)\n1. (level 0))\n858.\n(cond ((not (pair? exp)) '())\na. ((quote? exp) '())\nb. ((quasiquote? exp)\nc. (descend-quasiquote (quasiquote-text exp) (+ level 1)))\nd. ((unquote? exp)\ne. (if (= level 0)\ni. (list (unquote-text exp))\nii. (descend-quasiquote (unquote-text exp) (- level 1))))\nf. ((unquote-splicing? exp)\ng. (if (= level 0)\ni. (list (unquote-splicing-text exp))\nii. (descend-quasiquote (unquote-splicing-text exp) (- level 1))))\nh. (else (mapcan (lambda (e) (descend-quasiquote e level)) exp))\ni. )))\n859.\n(define (clauses-deconstructor-subst clauses subst)\n860.\n(map (lambda (clause)\na. (cons (pattern-deconstructor-subst (car clause) subst)\ni. (cdr clause)))\nb. clauses))\n861.\n(define (pattern-deconstructor-subst pat subst)\n\n862.\n(cond ((not (pair? pat)) pat)\na. ((quote? pat) pat)\nb. ((quasiquote? pat)\nc. (quasiquote-deconstructor-subst (quasiquote-text pat) subst))\nd. (else (cons (subst (car pat))\ni. (map (lambda (p)\n1. (pattern-deconstructor-subst p subst))\n2. (cdr pat))))))\n863.\n(define (quasiquote-deconstructor-subst pat subst)\n864.\n(let descend-quasiquote ((exp pat)\n1. (level 0))\n865.\n(cond ((not (pair? exp)) exp)\na. ((quote? exp) exp)\nb. ((quasiquote? exp)\nc. (quasiquote-make\nd. (descend-quasiquote (quasiquote-text exp) (+ level 1))))\ne. ((unquote? exp)\nf. (unquote-make\ng. (if (= level 0)\ni. (pattern-deconstructor-subst\nii. (unquote-text exp)\niii. subst)\niv. (descend-quasiquote (unquote-text exp) (- level 1)))))\nh. ((unquote-splicing? exp)\ni. (unquote-splicing-make\nj. (if (= level 0)\ni. (pattern-deconstructor-subst\nii. (unquote-splicing-text exp)\niii. subst)\niv. (descend-quasiquote (unquote-splicing-text exp) (- level 1)))))\nk. (else (map (lambda (e) (descend-quasiquote e level)) ex)))))\n866.\n(define match-clause-pattern first)\n867.\n(define (predicate sym)\n868.\n(lambda (exp)\n869.\n(if (pair? exp)\na. (eq? (car exp) sym)\nb. #f)))\n870.\n; Quoting\n871.\n(define quote? (predicate 'quote))\n872.\n(define (quote-make text) (list 'quote text))\n873.\n(define quote-text second)\n874.\n(define quasiquote? (predicate 'quasiquote))\n\n875.\n(define (quasiquote-make text) (list 'quasiquote text))\n876.\n(define quasiquote-text second)\n877.\n(define unquote? (predicate 'unquote))\n878.\n(define (unquote-make text) (list 'unquote text))\n879.\n(define unquote-text second)\n880.\n(define unquote-splicing? (predicate 'unquote-splicing))\n881.\n(define (unquote-splicing-make text) (list 'unquote-splicing text))\n882.\n(define unquote-splicing-text second)\n883.\n;; Main body of the MATCH macro\n884.\n(expand thing clauses)\n885.\n) ; End MATCH macro expander\n\n886.\n(define (scheme+/match-clauses disc match-exp . rest)\n887.\n(let loop ((clauses rest))\n888.\n(if (null? clauses)\n889.\n(scheme+/runtime-error \"MATCH -- no pattern matched to disc.\"\na. disc match-exp)\n890.\n((car clauses)\na. (lambda ()\nb. (loop (cdr clauses)))))))\n891.\n;; Procedure for doing deconstruction out-of-line\n892.\n(define (scheme+/deconstruct-carefully\na. constr sub-patterns nargs thing succ-cont fail-cont)\n893.\n((unbundler constr)\n894.\nthing\n895.\n(lambda success-args\n896.\n(if (not (= (length success-args) (length sub-patterns)))\na. (scheme+/success-number-of-args-mismatch sub-patterns\n1. success-args)\nb. (apply succ-cont success-args)))\n897.\nfail-cont))\n898.\n(define (scheme+/handle-with-fail fail-acceptor fail-cont)\n899.\n(let ((token (list 'fail-token)))\n900.\n;; fail-acceptor is the body of the with-fail\n901.\n;; fail-cont is the failure continuation for this clause\n902.\n;;OLD: fail-body is a failure acceptor, so just apply it to the\n903.\n;;\ncurrent failure: (fail-acceptor fail-cont)\n904.\n;;BJR: need to really abort clause so grab continuation\n905.\n(let ((return-value\na. (call-with-current-continuation\nb. (lambda (k)\nc. (fail-acceptor\ni. ;; abort by returning failure continuation\nii. (lambda () (k token)))))))\n906.\n(if (eq? return-value token)\na. ;; we're aborting\nb. (fail-cont)\nc. return-value))))\n907.\n;;; MATCH End\n908.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n\n909.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n910.\n;;; SCHEME+/GENSYM\n911.\n(define scheme+/gensym\n912.\n(let ((counter 0))\n913.\n(lambda (sym)\n914.\n(let ((result (string->symbol\ni. ;; Symbols beginning with # aren't recognized by reader,\nii. ;; so this can't conflict with a user-specified name.\niii. (string-append \"#\"\na. (symbol->string sym)\nb. \"-\"\nc. (number->string counter)))))\n915.\n(set! counter (+ counter 1))\n916.\nresult))))\n917.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n\n918.\n(define (scheme+/success-number-of-args-mismatch patterns exps)\n919.\n(scheme+/runtime-error\n920.\n(string-append \"the number of sub-patterns in a match clause (\"\ni. (number->string (length patterns))\nii. \") is not equal to \\nthe number of fields in a deconstructed datatype\nobject (\"\niii. (number->string (length exps))\niv. \"). \\nTried to match the following patterns and expressions:\\n\")\n921.\n(list 'patterns: patterns 'exps: exps)))\n\n922.\n;;---------------------------------------------------\n923.\n;; top-level.scm\n924.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n925.\n;;;\n926.\n;;; Scheme+ Top-Level\n927.\n;;;\n928.\n;;; Author:\nLyn\n929.\n;;; Creation Date: 6/23/94\n930.\n;;; Log:\n931.\n;;; * 8/19/94 (reistad): Reworked to use low level macros.\n932.\n;;; * 8/11/94 (lyn): Adapted Mini-FX SF, CF, and path stuff to Scheme+\n933.\n;;; Also added an explicit Scheme+ interactive environment.\n934.\n;;;\n935.\n;;; Documentation:\n936.\n;;; * Controls the integration of Scheme+ within MIT Scheme.\n937.\n;;; * Based on the Mini-FX top level.\n938.\n;;; * Ignores the deep issues of interactions between syntactic definitions\n939.\n;;; and first-class environments. (According to CPH, this is why\n940.\n;;; SYNTAX-RULES aren't standard in MIT Scheme.)\n941.\n;;;\n942.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n943.\n;;;\n944.\n;;; History\n945.\n;;;\n946.\n;;;\n947.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n948.\n;;;----------------------------------------------------------------------------\n949.\n;;; TOP-LEVEL EVALUATION\n950.\n;;; Loading files in Scheme+ requires special handling of unsyntaxed files.\n951.\n(define (scheme+/load filename)\n952.\n(load filename scheme+/interactive-environment scheme+/syntax-table))\n953.\n(define (scheme+/eval exp env)\n954.\n(eval (syntax exp scheme+/syntax-table) env))\n955.\n;; Currently unsupported\n956.\n;\n957.\n(define (scheme+/sf filename . rest)\n958.\n;; (sf/set-file-syntax-table! (->pathname filename) scheme+/syntax-table)\n959.\n;; (apply sf filename rest)\n960.\n(error \"SF for Scheme+ files is currently unsupported\")\n961.\n)\n\n962.\n(define (scheme+/cf filename . rest)\n963.\n;; (sf/set-file-syntax-table! (->pathname filename) scheme+/syntax-table)\n964.\n;; (apply cf filename rest)\n965.\n(error \"CF for Scheme+ files is currently unsupported\")\n966.\n)\n967.\n;;;----------------------------------------------------------------------------\n968.\n;;; Installation of evaluator\n969.\n(define (scheme+/enter-top-level)\n970.\n;; Change the emacs interface\n971.\n;; Doesn't seem to work.\n972.\n;; (scheme-runtime/install-mfx-emacs-interface!)\n973.\n;; No longer needed -- reistad 8/19/94\n974.\n; (scheme-runtime/install-evaluator! (lambda (sexp env st)\n975.\n;\n(scheme+/eval sexp env)))\n976.\n(scheme-runtime/install-environment! scheme+/interactive-environment)\n977.\n(display (string-append\na. \"\\nYou are now typing at the Scheme+ interpreter (version \"\nb. scheme+/version\nc. \")\"\nd. ))\n978.\n)\n979.\n(define (scheme+/exit-top-level)\n980.\n;; No longer needed -- reistad 8/19/94\n981.\n; (scheme-runtime/install-default-evaluator!)\n982.\n(scheme-runtime/install-environment! user-initial-environment)\n983.\n(display \"\\nYou are now typing at the Scheme interpreter.\")\n984.\n)\n985.\n;; A new version of EQUAL? that provides equality checking of datatype\ninstances\n986.\n;;\n987.\n(define (scheme+/equal? obj1 obj2)\n988.\n(cond ((eq? obj1 obj2) #t)\n989.\n((pair? obj1)\na. (if (pair? obj2)\n\nb. (and (scheme+/equal? (car obj1) (car obj2))\ni. (scheme+/equal? (cdr obj1) (cdr obj2)))\nc. #f))\n990.\n((datatype-instance? obj1)\na. (if (datatype-instance? obj2)\nb. (scheme+/datatype-instance-equal? obj1 obj2)\nc. #f))\n991.\n((number? obj1)\na. (if (number? obj2)\nb. (= obj1 obj2)\nc. #f))\n992.\n((string? obj1)\na. (if (string? obj2)\nb. (string=? obj1 obj2)\nc. #f))\n993.\n((char? obj1)\na. (if (char? obj2)\nb. (char=? obj1 obj2)\nc. #f))\n994.\n((vector? obj1)\na. (if (vector obj2)\nb. (and (= (vector-length obj1) (vector-length obj2))\ni. (let loop ((i (- (vector-length obj1) 1)))\nii. (if (< i 0)\n1. #t\n2. (and (scheme+/equal? (vector-ref obj1 i)\ni. (vector-ref obj2 i))\n3. (loop (- i 1))))))\nc. #f))\n995.\n(else #f)\n996.\n))\n997.\n(define (scheme+/datatype-instance-equal? dinst1 dinst2)\na. (and (eq? (datatype-instance-descriptor dinst1)\ni. (datatype-instance-descriptor dinst2))\nb. (eq? (datatype-instance-constructor dinst1)\ni. (datatype-instance-constructor dinst2))\nc. (scheme+/equal? (datatype-instance-args dinst1)\n1. (datatype-instance-args dinst2))))\n998.\n;; Handy synonyms\n999.\n(define (scheme+) (scheme+/enter-top-level))\n1000.\n(define (scheme)\n1001.\n(display \"\\nYou are already typing at the Scheme interpreter.\"))\n\n1002.\n(define (scheme+/pp . args)\n1003.\n;; Version of PP that prints everything as code (nothing as tables).\n1004.\n(if (version-7.1.3?)\n1005.\n(apply pp args)\n1006.\n(fluid-let ((*pp-lists-as-tables?* #f))\n1007.\n(apply pp args))))\n1008.\n;;;----------------------------------------------------------------------------\n1009.\n;;; The Scheme+ Environment\n1010.\n;;;\n1011.\n;;; This creates a new environment on top of user-initial-environment\n1012.\n;;; that contains a few Scheme+ specific bindings.\n1013.\n(define scheme+/interactive-environment\n1014.\n(make-environment\n1015.\n(define load scheme+/load)\n1016.\n(define eval scheme+/eval)\n1017.\n(define sf scheme+/sf)\n1018.\n(define cf scheme+/cf)\n1019.\n(define equal? scheme+/equal?)\n1020.\n(define user-initial-environment 'later)\n1021.\n(define global-eval\n1022.\n(lambda (exp) (eval exp scheme+/interactive-environment)))\n1023.\n(define scheme scheme+/exit-top-level)\n1024.\n(define scheme+\n1025.\n(lambda ()\n1026.\n(display \"\\nYou are already typing at the Scheme+ interpreter.\")))\n1027.\n(define pp scheme+/pp)\n1028.\n))\n1029.\n(eval `(set! user-initial-environment ,scheme+/interactive-environment)\n1030.\nscheme+/interactive-environment)\n\n1031.\n;;;----------------------------------------------------------------------------\n1032.\n;;; Version Handling\n1033.\n;;; Scheme version stuff\n1034.\n(define (runtime-system)\n1035.\n(let ((answer '*))\n1036.\n(begin\n1037.\n(for-each-system!\n1038.\n(lambda (sys)\na. (if (string=? (system/name sys)\ni. \"Runtime\")\nb. (set! answer (list (system/version sys)\na. (system/modification sys))))))\n1039.\n(if (eq? answer '*)\na. (error \"SCHEME+ INITIALIZATION ERROR: CAN'T FIND SCHEME\nRUNTIME VERSION\")\nb. answer))))\n1040.\n(define runtime-version first)\n1041.\n(define runtime-modification second)\n1042.\n(define (version-7.1.3?)\n1043.\n(equal? (runtime-system) '(14 104)))\n1044.\n(define (version-7.2?)\n1045.\n;; This is a hack. This also returns #t for 7.3 systems.\n1046.\n;; To discriminate for 7.3, explicitly test for it first!\n1047.\n; (or (equal? (runtime-system) '(14 155))\n1048.\n;\n(equal? (runtime-system) '(14 156))\n1049.\n;\n(equal? (runtime-system) '(14 157)))\n1050.\n(and (= (first (runtime-system)) 14)\n1051.\n(>= (second (runtime-system)) 155)))\n1052.\n(define (version-7.3?)\n1053.\n(and (= (first (runtime-system)) 14)\n1054.\n(>= (second (runtime-system)) 166)))\n1055.\n(define (version-error)\n1056.\n(error\n1057.\n(string-append\n1058.\n\"SCHEME-+ VERSION ERROR\\nScheme+ doesn't know how to handle\nruntime \"\n1059.\n(number->string (runtime-version (runtime-system)))\n1060.\n\".\"\n\n1061.\n(number->string (runtime-modification (runtime-system)))\n1062.\n\"\\nContact 6821@psrg.lcs.mit.edu for help.\")))\n1063.\n(define scheme-runtime/version-7.1.3/install-evaluator!\n1064.\n(let ((repl-env (->environment '(runtime rep))))\n1065.\n(lambda (evaluator) ; evaluator is SEXP x ENV x ST ->\n1066.\n(set! (access hook/repl-eval repl-env)\na. ;; Version 7.1.3 evaluators take an extra first arg\nb. ;; that is ignored.\nc. (lambda (repl sexp env st)\nd. (evaluator sexp env st))))))\n1067.\n(define scheme-runtime/version-7.2/install-evaluator!\n1068.\n(let ((repl-env (->environment '(runtime rep))))\n1069.\n(lambda (evaluator) ; evaluator is SEXP x ENV x ST ->\n1070.\n(set! (access hook/repl-eval repl-env)\na. evaluator))))\n1071.\n(define scheme-runtime/install-evaluator!\n1072.\n(cond\n1073.\n((version-7.3?) scheme-runtime/version-7.1.3/install-evaluator!) ; kludge!\n1074.\n((version-7.1.3?) scheme-runtime/version-7.1.3/install-evaluator!)\n1075.\n((version-7.2?) scheme-runtime/version-7.2/install-evaluator!)\n1076.\n(else (version-error))))\n1077.\n;;; This is written to be independent of version\n1078.\n(define scheme-runtime/install-default-evaluator!\n1079.\n(eval '(lambda () (set! hook/repl-eval default/repl-eval))\n1080.\n(->environment '(runtime rep))))\n1081.\n;;; Patch for 7.1.3\n1082.\n(define (scheme-runtime/map proc . lsts)\n1083.\n(define (map proc . lsts)\n1084.\n(cond ((null? lsts) '())\na. ((null? (car lsts)) '())\nb. ((null? (cdr lsts));; only one list to map over\nc. (cons (proc (caar lsts))\ni. (map proc (cdar lsts))))\nd. (else\ne. (cons (apply proc (map car lsts))\ni. (apply map proc (map cdr lsts))))))\n1085.\n(apply map proc lsts))\n1086.\n(if (version-7.1.3?)\n1087.\n(set! map scheme-runtime/map)\n\n1088.\n'nop)\n1089.\n;;; Environments\n1090.\n(define scheme-runtime/version-7.1.3/install-environment!\n1091.\n(eval '(lambda (env)\na. (let ((repl (nearest-repl))\ni. (environment (->environment env)))\nb. (set-repl-state/environment! (cmdl/state repl) environment)\nc. (if (not (cmdl/parent repl))\ni. (set! user-repl-environment environment))))\n1092.\n(->environment '(runtime rep))))\n1093.\n(define scheme-runtime/version-7.2/install-environment! ge)\n1094.\n(define scheme-runtime/install-environment!\n1095.\n(cond\n1096.\n((version-7.1.3?) scheme-runtime/version-7.1.3/install-environment!)\n1097.\n((version-7.2?) scheme-runtime/version-7.2/install-environment!)\n1098.\n(else (version-error))))\n1099.\n(define (scheme-runtime/fasload-file? pathname)\n1100.\n(let* ((port (open-input-file pathname))\na. (fasl-marker (peek-char port))\nb. (result (and (not (eof-object? fasl-marker))\ni. (= 250 (char->ascii fasl-marker)))))\n1101.\n(begin\n1102.\n(close-input-port port)\n1103.\nresult)))\n1104.\n;;; Dump/load\n1105.\n(define scheme-runtime/fasdump fasdump)\n1106.\n(define scheme-runtime/fasload fasload)\n1107.\n;;; Path stuff\n1108.\n(define scheme+/scheme+-ext \"scm\")\n1109.\n(define scheme+/bin-ext \"bin\")\n1110.\n(define scheme+/com-ext \"com\")\n1111.\n;; Get pathname of existing file ending in \".scm\"\n1112.\n(define scheme-runtime/version-7.1.3/scheme+-pathname\n\n1113.\n(eval `(lambda (filename)\na. (find-true-pathname (->pathname filename)\na. '(,scheme+/scheme+-ext)))\n1114.\n(->environment '(runtime load))))\n1115.\n(define scheme-runtime/version-7.2/scheme+-pathname\n1116.\n(eval `(lambda (filename)\na. (find-pathname filename '(,scheme+/scheme+-ext)))\n1117.\n(->environment '(runtime load))))\n1118.\n(define scheme-runtime/version-7.3/scheme+-pathname\n1119.\n(eval `(lambda (filename)\na. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\nii. ,',load/internal))))\nb. (lambda (pathname loader) pathname)))\n1120.\n(->environment '(runtime load))))\n1121.\n(define scheme-runtime/scheme+-pathname\n1122.\n(cond\n1123.\n((version-7.3?) scheme-runtime/version-7.3/scheme+-pathname)\n1124.\n((version-7.2?) scheme-runtime/version-7.2/scheme+-pathname)\n1125.\n((version-7.1.3?) scheme-runtime/version-7.1.3/scheme+-pathname)\n1126.\n(else (version-error))))\n1127.\n;; Get pathname of existing file ending in either \".bin\" or \".scm\"\n1128.\n(define scheme-runtime/version-7.1.3/bin-pathname\n1129.\n(eval `(lambda (filename)\na. (find-true-pathname (->pathname filename)\na. '(,scheme+/bin-ext\nb. ,scheme+/scheme+-ext)))\n1130.\n(->environment '(runtime load))))\n1131.\n(define scheme-runtime/version-7.2/bin-pathname\n1132.\n(eval `(lambda (filename)\na. (find-pathname filename '(,scheme+/bin-ext\na. ,scheme+/scheme+-ext)))\n1133.\n(->environment '(runtime load))))\n1134.\n(define scheme-runtime/version-7.3/bin-pathname\n1135.\n(eval `(lambda (filename)\na. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\n\nii. ,',load/internal)\niii. (,scheme+/bin-ext\niv. ,',load/internal))))\nb. (lambda (pathname loader) pathname)))\n1136.\n(->environment '(runtime load))))\n1137.\n(define scheme-runtime/bin-pathname\n1138.\n(cond\n1139.\n((version-7.3?) scheme-runtime/version-7.3/bin-pathname)\n1140.\n((version-7.2?) scheme-runtime/version-7.2/bin-pathname)\n1141.\n((Version-7.1.3?) scheme-runtime/version-7.1.3/bin-pathname)\n1142.\n(else (version-error))))\n1143.\n;; Get pathname for existing file ending in \".scm\" and return a pathname\n1144.\n;; for the same file, but ending in \".bin\"\n1145.\n(define scheme-runtime/version-7.1.3/sf-name\n1146.\n(eval `(lambda (filename)\na. (pathname->string\nb. (pathname-new-type\nc. (find-true-pathname (->pathname filename)\na. '(,scheme+/scheme+-ext))\nd. ,scheme+/bin-ext)))\n1147.\n(->environment '(runtime load))))\n1148.\n(define scheme-runtime/version-7.2/sf-name\n1149.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\nc. (find-pathname filename\n1. '(,scheme+/scheme+-ext))\nd. ,scheme+/bin-ext)))\n1150.\n(->environment '(runtime load))))\n1151.\n(define scheme-runtime/version-7.3/sf-name\n1152.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\nc. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\nii. ,',load/internal))))\nii. (lambda (pathname loader) pathname))\nd. \"bin\")))\n1153.\n(->environment '(runtime load))))\n\n1154.\n(define scheme-runtime/sf-name\n1155.\n(cond\n1156.\n((version-7.3?) scheme-runtime/version-7.3/sf-name)\n1157.\n((version-7.2?) scheme-runtime/version-7.2/sf-name)\n1158.\n((version-7.1.3?) scheme-runtime/version-7.1.3/sf-name)\n1159.\n(else (version-error))))\n1160.\n;; Get pathname for existing file ending in \".scm\" or \".bin\" and return a\n1161.\n;; pathname for the same file, but ending in \".com\"\n1162.\n(define scheme-runtime/version-7.1.3/cf-name\n1163.\n(eval `(lambda (filename)\na. (pathname->string\nb. (pathname-new-type\nc. (find-true-pathname (->pathname filename)\na. '(,scheme+/scheme+-ext\nb. ,scheme+/bin-ext))\nd. ,scheme+/com-ext)))\n1164.\n(->environment '(runtime load))))\n1165.\n(define scheme-runtime/version-7.2/cf-name\n1166.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\nc. (find-pathname filename '(,scheme+/scheme+-ext\ni. ,scheme+/bin-ext))\nd. ,scheme+/com-ext)))\n1167.\n(->environment '(runtime load))))\n1168.\n(define scheme-runtime/version-7.3/cf-name\n1169.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\nc. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\nii. ,',load/internal)\niii. (,scheme+/bin-ext\niv. ,',load/internal))))\nii. (lambda (pathname loader) pathname))\nd. ,scheme+/com-ext)))\n1170.\n(->environment '(runtime load))))\n1171.\n(define scheme-runtime/cf-name\n1172.\n(cond\n1173.\n((version-7.3?) scheme-runtime/version-7.3/cf-name)\n\n1174.\n((version-7.2?) scheme-runtime/version-7.2/cf-name)\n1175.\n((version-7.1.3?) scheme-runtime/version-7.1.3/cf-name)\n1176.\n(else (version-error))))\n1177.\n;; Compile a syntaxed file\n1178.\n(define (scheme-runtime/compile-bin-file . args)\n1179.\n(error \"scheme-runtime/compile-bin-file not currently supported\")\n1180.\n(cond ((version-7.2?)\na. (if (environment-bound? system-global-environment 'compile-bin-file)\nb. compile-bin-file\nc. (lambda (filename)\ni. (display \"Compile not loaded, unable to compile: \")\nii. (display filename)\niii. (newline))))\n1181.\n(else (version-error)))\n1182.\n)\n1183.\n(define (scheme-runtime/file-modification-time file)\n1184.\n;; Return a 0 rather than null if file not present\n1185.\n(let ((t (file-modification-time file)))\n1186.\n(if (null? t) 0 t)))\n1187.\n;;---------------------------------------------------\n1188.\n;; Start up Scheme+\n1189.\n(scheme+)"
    },
    {
      "category": "Resource",
      "title": "scheme12workswithscheme75.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-821-programming-languages-fall-2002/c4218462daca49ef476687beddce000d_scheme12workswithscheme75.pdf",
      "content": "1. ;; This Scheme+ Version 1.2\n2. ;; Built on Wed Sep 14 16:47:44 EDT 1994\n3. ;; Includes:\n4. ;; macros.scm\n5. ;; constructor.scm\n6. ;; datatype.scm\n7. ;; match.scm\n8. ;; top-level.scm\n9. (declare (usual-integrations))\n10. (define scheme+/version \"1.2\")\n11. ;;---------------------------------------------------\n12. ;; macros.scm\n13. ;;; ---------------------------------------------------------------------------\n14. ;;; Macro definitions\n15. ;;; Create the syntax table to be used by the compiler\n16. (define scheme+/syntax-table\n17. (make-syntax-table system-global-syntax-table))\n18. ;;; Scheme+ macros need to be visible both at run-time and a compile-time\n19. ;;;\n20. ;;; BJR: put define-scheme+-macro in user-initial-syntax-table so that\n21. ;;; we can load datatype.scm and match.scm independently.\n22. ;;;\n23. (syntax-table-define\n24. user-initial-syntax-table\n25. 'define-scheme+-macro\n26. (macro (pattern . body)\n27. `(begin\na. (syntax-table-define\nb. user-initial-syntax-table\nc. ',(car pattern)\nd. (macro ,(cdr pattern) ,@body))\ne. (syntax-table-define\nf. scheme+/syntax-table\ng. ',(car pattern)\nh. (macro ,(cdr pattern) ,@body)))))\n28. ;;Also need it in this file so it's visible when we concat everything together.\n29. (define-macro (define-scheme+-macro pattern . body)\n30. `(begin\n31. (syntax-table-define\na. user-initial-syntax-table\n\nb. ',(car pattern)\n32. (macro ,(cdr pattern) ,@body))\n33. (syntax-table-define\na. scheme+/syntax-table\nb. ',(car pattern)\n34. (macro ,(cdr pattern) ,@body))))\n35. ;;; Get real scheme value in expanded code\n36. (define-scheme+-macro (get-real identifier)\n37. `(access ,identifier ()))\n38. ;;; ---------------------------------------------------------------------\n39. ;;; Error handling macros - need to be visible both in this file\n40. ;;; and at run time.\n41. ;; BJR - These are now scheme procedures\n42. ; (define-macro (define-macro-both pattern . body)\n43. ; `(begin\n44. ;\n(define-macro ,pattern ,@body)\n45. ;\n(syntax-table-define\n46. ;\nuser-initial-syntax-table\n47. ;\n',(car pattern)\n48. ;\n(macro ,(cdr pattern) ,@body))))\n49. ;\n50. ; (define-macro-both (syntax-error string . rest)\n51. ; `(error (string-append \"\\nSCHEME+ SYNTAX ERROR: \" ,string)\n52. ;\n,@(if rest rest '())))\n53. ;\n54. ; (define-macro-both (runtime-error string . rest)\n55. ; `((get-real error)\n56. ;\n((get-real string-append) \"\\nSCHEME+ RUN-TIME TYPE ERROR!\\n\"\n57. ;\n,string)\n58. ;\n,@(if rest rest '())))\n59. (define (scheme+/syntax-error msg . rest)\n60. (error (apply error-string \"\\nSCHEME+ SYNTAX ERROR: \" msg rest)\na. rest))\n61. (define (scheme+/runtime-error msg . rest)\n62. (error (apply error-string \"\\nSCHEME+ RUN-TIME TYPE ERROR!\\n\" msg rest)\na. rest))\n\n63. ;; From mini-fx/version-4.2.7.scm\n64. (define (error-string str msg . objs )\n65. (string-append\n66. str\n67. msg\n68. \"\\n\"\n69. (objects->string objs)\n70. \"\\n\"\n71. ))\n72. (define objects->string\n73. (let ((separator \"------------------------------------------------------------\"))\n74. (lambda (objs)\n75. (if (null? objs)\na. \"\"\nb. (string-append\nc. separator\nd. (apply\ne. string-append\nf. (map\ng. (lambda (obj)\ni. (string-append\nii. (with-output-to-string (lambda () (pp obj)))\niii. \"\\n\"\niv. separator\nv. ))\nh. objs)))))))\n\n76. ;;---------------------------------------------------\n77. ;; constructor.scm\n78. ;;;----------------------------------------------------------------------------\n79. ;;; Constructors\n80. ;;; reistad 8/19/94 -- added quote and quasiquote s-expression consructors\n81. ;;\nfrom mini-fx.scm (1991)\n\n82. (define constructor-tag '(constructor))\n83. (define (scheme+/make-constructor bundler unbundler)\n84. (make-apply-hook bundler\ni. (list constructor-tag unbundler)))\n85. (define make-constructor scheme+/make-constructor)\n86. (define (constructor? obj)\n87. (and (apply-hook? obj)\n88. (let ((extra (apply-hook-extra obj)))\na. (and (list? extra)\nb. (= (length extra) 2)\nc. (eq? (first extra) constructor-tag)))))\n89. (define (bundler obj)\n90. (if (constructor? obj)\n91. obj\n92. (error \"bundler: Not a constructor!\" obj)))\n93. (define (unbundler obj)\n94. (if (constructor? obj)\n95. (second (apply-hook-extra obj))\n96. (error \"unbundler: Not a constructor!\" obj)))\n97. ;;;----------------------------------------------------------------------------\n98. ;;; Simulated LIST datatype\n99. (define null\n100.\n(make-constructor\n101.\n(lambda () '())\n102.\n(lambda (obj succ fail)\n103.\n(if (null? obj)\na. (succ)\nb. (fail)))))\n\n104.\n(define cons\n105.\n(make-constructor\n106.\n(access cons system-global-environment)\n107.\n(lambda (obj succ fail)\n108.\n(if (pair? obj)\na. (succ (car obj) (cdr obj))\nb. (fail)))))\n109.\n; (define null\n110.\n; (make-constructor\n111.\n; (lambda () '())\n112.\n; (lambda (obj succ fail)\n113.\n;\n(if *datatype-paranoid-match?* ; See DATATYPE.SCM\n114.\n;\n(if (not (or (null? obj) (pair? obj)))\n115.\n;\n(error \"Deconstructor for NULL given a non list\")))\n116.\n;\n(if (null? obj)\n117.\n;\n(succ)\n118.\n;\n(fail)))))\n119.\n;\n120.\n; (define cons\n121.\n; (make-constructor\n122.\n; (access cons ())\n123.\n; (lambda (obj succ fail)\n124.\n;\n(if *datatype-paranoid-match?* ; See DATATYPE.SCM\n125.\n;\n(if (not (or (null? obj) (pair? obj)))\n126.\n;\n(error \"Deconstructor for CONS given a non list\")))\n127.\n;\n(if (pair? obj)\n128.\n;\n(succ (car obj) (cdr obj))\n129.\n; This can't work without the deconstructor being passed the\n130.\n; number of args given to the deconstructor (or a datum from\n131.\n; which that number could be constructed).\n132.\n;\n133.\n; (define list\n134.\n; (make-constructor\n135.\n; (access list ())\n136.\n; (lambda (obj succ fail)\n137.\n;\n(if (list? obj)\n138.\n;\n(apply succ obj)\n139.\n;\n(fail)))))\n140.\n;;;----------------------------------------------------------------------------\n141.\n;;; Simulated S-EXPRESSION datatype\n\n142.\n(define (make-sexp-constructor sym pred)\n143.\n(make-constructor\n144.\n(lambda (sexp)\n; Constructor does a type check with PRED\n145.\n(if (pred sexp)\na. sexp\nb. (error \"Sexp constructor -- incorrect type:\" sym sexp)))\n146.\n(lambda (sexp succ fail) ; Deconstructor does a type check with PRED\n147.\n(if (pred sexp)\na. (succ sexp)\nb. (fail)))))\n148.\n(define int->sexp (make-sexp-constructor 'int integer?))\n149.\n(define real->sexp (make-sexp-constructor 'real real?))\n150.\n(define bool->sexp (make-sexp-constructor 'bool boolean?))\n151.\n(define char->sexp (make-sexp-constructor 'char char?))\n152.\n(define string->sexp (make-sexp-constructor 'string string?))\n153.\n(define symbol->sexp (make-sexp-constructor 'symbol symbol?))\n154.\n(define list->sexp (make-sexp-constructor 'list list?))\n155.\n(define vector->sexp (make-sexp-constructor 'vector vector?))\n\n156.\n;; reistad 8/24/94 -- added for orthogonality/uniformity with Scheme\n157.\n(define (scheme+/make-check-type-constructor sym pred?)\n158.\n(make-constructor\n159.\n(lambda (obj) (if (pred? obj)\ni. obj\nii. (error \"Object was not of correct type:\" sym obj)))\n160.\n(lambda (obj succ fail)\n161.\n(if (pred? obj)\na. (succ obj)\nb. (fail)))))\n162.\n(define a-number (scheme+/make-check-type-constructor 'number\nnumber?))\n163.\n(define an-integer (scheme+/make-check-type-constructor 'integer\ninteger?))\n164.\n(define a-real\n(scheme+/make-check-type-constructor 'real real?))\n165.\n(define a-complex (scheme+/make-check-type-constructor 'complex\ncomplex?))\n166.\n(define a-rational (scheme+/make-check-type-constructor 'rational\nrational?))\n167.\n(define a-char\n(scheme+/make-check-type-constructor 'char char?))\n168.\n(define a-boolean (scheme+/make-check-type-constructor 'boolean\nboolean?))\n169.\n(define a-symbol (scheme+/make-check-type-constructor 'symbol\nsymbol?))\n170.\n(define a-procedure (scheme+/make-check-type-constructor 'procedure\nprocedure?))\n171.\n(define a-vector (scheme+/make-check-type-constructor 'vector\nvector?))\n172.\n(define a-list\n(scheme+/make-check-type-constructor 'list list?))\n173.\n(define a-string (scheme+/make-check-type-constructor 'string string?))\n\n174.\n;;; reistad 8/19/94 -- taken from mini-fx (1991) for low level macro system\n175.\n;;;\n176.\n;;; Additional procedures for manipulating s-expressions with QUOTE,\n177.\n;;; QUASIQUOTE, UNQUOTE, and UNQUOTE-SPLICING.\n178.\n(define (scheme+/make-quote-constructor sym)\n179.\n(make-constructor\n180.\n(lambda (x) (list sym x))\n181.\n(let ((pred (lambda (thing)\ni. (and (pair? thing)\nii. (eq? (car thing) sym)\niii. (pair? (cdr thing))\niv. (null? (cddr thing))))))\n182.\n(lambda (thing succ fail)\n183.\n(if (pred thing)\na. (succ (cadr thing))\nb. (fail))))))\n;; Constructor tags item\n;; Deconstructor checks tag\n184.\n(define quoted->sexp\n(scheme+/make-quote-constructor 'quote))\n185.\n(define quasiquoted->sexp\n(scheme+/make-quote-constructor\n'quasiquote))\n186.\n(define unquoted->sexp\n(scheme+/make-quote-constructor\n'unquote))\n187.\n(define unquoted-splicing->sexp (scheme+/make-quote-constructor\n'unquote-splicing))\n\n188.\n;;---------------------------------------------------\n189.\n;; datatype.scm\n190.\n;;;----------------------------------------------------------------------------\n191.\n;;; DATATYPE.SCM\n192.\n;;;\n193.\n;;; Author: Lyn\n194.\n;;; Log:\n195.\n;;; * 8/19/94 - reistad: Eliminated use of define-syntax so define-datatype\n196.\n;;;\nmacro is now in match.scm. Also dropped use of dtyp-desc\nas\n197.\n;;;\nScheme+ ingnores all type crap.\n198.\n;;;\nDefine-Datatype now defines the constructor name to be a package\n199.\n;;;\nof both a bundler and unbundler as we've eliminated ~. The\n200.\n;;;\nconstructor is behaves just like the bundler but has a way to\n201.\n;;;\nget to the unbundler.\n202.\n;;; * 8/11/94 - Updated\n203.\n;;; * 6/20/94 - Created\n204.\n;;;\n205.\n;;; Notes:\n206.\n;;; Implements datatypes for Scheme+. There is a design choice here that\n207.\n;;; doesn't exist for Mini-FX: what should an unbundler do when not given\n208.\n;;; a discriminant of the expected type? E.g., suppose BAR is a constructor\n209.\n;;; for datatype FOO, and P is an instance of the CONS datatype. Should\n210.\n;;;\n211.\n;;; ((unbundler bar) p <succeed> <fail>)\n212.\n;;;\n213.\n;;; signal an error, or merely call <fail>? The latter is more in the\n214.\n;;; \"Scheme tradition\", but the former provides superior error messages\n215.\n;;; (otherwise, the only error is the largely unuseful \"No pattern\nmatched!\").\n216.\n;;; The latter makes sense if we view MATCH as being instantiated to a\n217.\n;;; particular datatype before we apply it.\n218.\n;;;\n219.\n;;; Since its not clear which version is The Right Thing, I provide a flag\n220.\n;;; *DATATYPE-PARANOID-MATCH?* that controls how this situation\nis handled.\n221.\n;;; By default, this is #t -- i.e., all desconstructors in a given match\n222.\n;;; are assumed to be for the same datatype.\n223.\n;;;\n224.\n;;;----------------------------------------------------------------------------\n225.\n;; see NOTES above\n226.\n(define *datatype-paranoid-match?* #t)\n\n227.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n228.\n;;; DEFINE-DATATYPE Begin\n229.\n;;;\n230.\n;;; DEFINE-DATATYPE declares a sum-of-products data structure\n231.\n;;; and creates the associated constructors.\n232.\n;;;\n233.\n;;; NOTE: the implementation below uses the same name for both the\nconstructor\n234.\n;;; and deconstructor. (Actually uses application hooks to store the\n235.\n;;; deconstructor on the constructor.) -- ACTUALLY, renamed so that\n236.\n;;; always use constructor to refer to bundler/unbundler pair.\n237.\n;;;\n238.\n;;; E.g.\n239.\n;;;\n240.\n;;; (define-datatype int-tree\n241.\n;;;\n(int-leaf int)\n242.\n;;;\n(int-node int-tree int-tree))\n243.\n;;;\n244.\n;;; expands into\n\n245.\n;;;\n246.\n;;; (define int-leaf (make-constructor\n247.\n;;;\n(lambda (i) ...)\n;; constructor\n\n248.\n;;;\n(lambda (t succ fail) ...)))\n;; deconstructor\n249.\n;;; (define int-node (make-constructor\n250.\n;;;\n(lambda (t1 t2) ...)\n;; constructor\n251.\n;;;\n(lambda (t succ fail) ...)))\n;; deconstructor\n252.\n;;;\n253.\n;;; where\n254.\n;;;\n255.\n;;; (int-leaf 0) -> #[int-tree:int-leaf 0]\n256.\n;;;\n257.\n;;; (int-node (int-leaf 0) (int-leaf 1)) ->\n258.\n;;;\n#[int-tree:int-node\n259.\n;;;\n#[int-tree:int-leaf 0]\n260.\n;;;\n#[int-tree:int-leaf 1]]\n261.\n;;;\n262.\n;;; Here's a sample procedure using INT-TREE. Note the use of\n263.\n;;; deconstructors in the patterns of MATCH (eventhough there's no ~s)\n264.\n;;;\n265.\n;;; (define (int-tree-sum t)\n266.\n;;;\n(match t\n\n267.\n;;;\n((int-leaf n) n)\n268.\n;;;\n((int-node left right) (+ (tree-sum left) (tree-sum right)))))\n269.\n;;;\n270.\n;;;\n271.\n;;; DEFINE-DATATYPE can be parameterized by type as well:\n272.\n;;; (Yeah, but all types are ignored -- documentation only.\n273.\n;;;\n274.\n;;; (define-datatype (tree t)\n275.\n;;;\n(leaf t)\n276.\n;;;\n(node (tree t) (tree t)))\n277.\n;;;\n278.\n;;;DROP THIS?\n279.\n;;; These type parameters are (conceptually) parameters of the constructors\n280.\n;;; and deselectors, but can be thought of as being removed by\n281.\n;;; implicit projection. E.g. the above \"expands\" into\n282.\n;;;\n283.\n;;; ; Constructors\n284.\n;;; (define leaf (plambda (t) (lambda (i) ...)\n285.\n;;; (define node (plambda (t) (lambda (t1 t2) ...)\n286.\n;;; ; Deconstructors\n287.\n;;; (define leaf~ (plambda (t) (lambda (t success-cont fail-cont) ...))\n288.\n;;; (define node~ (plambda (t) (lambda (t success-cont fail-cont) ...))\n289.\n;;;\n290.\n;;; but the t's never have to be specified:\n291.\n;;;\n292.\n;;; (define (tree-depth t)\n293.\n;;;\n(match t\n294.\n;;;\n((leaf t) 0)\n295.\n;;;\n((node left right) (1+ (max (tree-depth left) (tree-depth right))))\n296.\n;;;\n297.\n;;;\n((node left right) (1+ (max (tree-depth left) (tree-depth right))))))\n298.\n;;;\n299.\n;;;\n300.\n;;; ---------------------------------------------------------------------------\n301.\n;;; Begin DEFINE-DATATYPE code\n302.\n;;; ---------------------------------------------------------------------------\n303.\n;;; The DEFINE-DATATYPE macro\n304.\n;;; There are two possible forms for DEFINE-DATATYPE:\n305.\n;;;\n306.\n;;; (define-datatype I (I D*)*)\n; Straightforward datatype\n307.\n;;; (define-datatype (I I*) (I D*)*)\n; Parameterized datatype\n308.\n;;;\n309.\n;;; Here we ignore any params if they occur.\n\n310.\n;;;\n311.\n;;; In this implementation we ignore types altogether and simply simulate\nthe\n312.\n;;; run-time behavior of DEFINE-DATATYPE.\n313.\n;;; Begin DEFINE-DATATYPE macro\n314.\n(define-scheme+-macro (define-datatype name-or-name+params . sum-of-\nproducts)\n315.\n(define (datatype-name header)\n316.\n(cond\n317.\n((symbol? header)\nheader)\n; (define-datatype I (I D*)*)\n318.\n((and (pair? header)\n; (define-datatype (I I*) (I D*)*)\na. (every? symbol? header))\n319.\n(car name-or-name+params))\n320.\n(else\n; otherwise is not a legal define-datatype\n321.\n(scheme+/syntax-error \"Ill-formed DEFINE-DATATYPE header: \"\nheader))\n322.\n))\n323.\n(define (datatype-clause-names-and-params clause-list receiver)\n324.\n(if (null? clause-list)\n325.\n(receiver '() '())\n326.\n(let ((first-clause (car clause-list)))\na. (if (and (list? first-clause)\ni. (>= (length first-clause) 1))\nb. (datatype-clause-names-and-params\ni. (cdr clause-list)\nii. (lambda (names params)\niii. (receiver\niv. (cons (check-clause-name (car (car clause-list)))\n1. names)\nv. (cons (map check-clause-param (cdr (car clause-list)))\n1. params))))\nc. (scheme+/syntax-error\ni. (string-append\nii. \"Ill-formed DEFINE-DATATYPE clause.\\n\"\niii. \"(Clauses must be of the form: (<constructor-name> <type_1> ...\n<type_n>) ):\\n\"\niv. )\nv. first-clause)))))\n327.\n(define (check-clause-name obj)\n328.\n(if (symbol? obj)\n329.\nobj\n\n330.\n(scheme+/syntax-error\na. \"Non-symbolic constructor name within a DEFINE-DATATYPE\nclause:\\n\"\nb. obj)))\n331.\n;; *** Need to have this do real error checking in future\n332.\n(define (check-clause-param type) type)\n333.\n(define (every? test lst)\n334.\n(if (null? lst)\n335.\n#t\n336.\n(and (test (car lst))\na. (every? test (cdr lst)))))\n337.\n; Main body of DEFINE-DATATYPE macro\n338.\n(let ((dname (datatype-name name-or-name+params)))\n339.\n(datatype-clause-names-and-params sum-of-products\n340.\n(lambda (clause-names clause-params)\n341.\n`(begin\na. ;; Since Scheme+ has a single namespace, we must bind the datatype\nb. ;; name to *some* kind of object in order to preserve the semantics\nc. (DEFINE ,dname ,(make-datatype-descriptor dname)) ;;? clause-names\nd. ,@(map (lambda (cname cparams)\ni. `(DEFINE ,cname\nii. (scheme+/make-constructor\n1. (scheme+/make-datatype-bundler ',dname\na. ',cname\nb. ,(length cparams))\n2. (scheme+/make-datatype-unbundler ',dname\na. ',cname))))\niii. clause-names\niv. clause-params)\ne. ,dname))))\n342.\n)\n343.\n;;; End DEFINE-DATATYPE macro\n344.\n;;; ---------------------------------------------------------------------------\n345.\n;;; DEFDATATYPE is a synonym for DEFINE-DATATYPE\n346.\n(define-scheme+-macro (defdatatype name-or-name+params . sum-of-\nproducts)\n347.\n`(DEFINE-DATATYPE ,name-or-name+params ,@sum-of-products))\n\n348.\n;; helper procedures\n349.\n(define (scheme+/make-datatype-bundler dtyp-name cnstr-name nargs)\n350.\n(lambda args\n351.\n(if (= nargs (length args))\n352.\n(make-datatype-instance dtyp-name dtyp-name cnstr-name args)\n353.\n(error \"Incorrect number of arguments given to bundler\"\ni. cnstr-name\nii. args))))\n354.\n(define make-datatype-bundler scheme+/make-datatype-bundler)\n355.\n(define (scheme+/make-datatype-unbundler dtyp-name cnstr-name)\n356.\n(lambda (obj succ fail)\n357.\n(if *datatype-paranoid-match?* ; Could move this outside if\n1. ; wanted creation-time choice.\n358.\n;; This case signals an error if OBJ isn't exactly right.\n359.\n(scheme+/ensure-datatype dtyp-name cnstr-name obj)\n360.\nobj)\n361.\n(if (and (datatype-instance? obj)\na. (eq? dtyp-name (datatype-instance-descriptor obj))\nb. (eq? cnstr-name (datatype-instance-constructor obj)))\n362.\n(apply succ (datatype-instance-args obj))\n363.\n(fail))))\n364.\n(define make-datatype-unbundler scheme+/make-datatype-unbundler)\n365.\n(define (scheme+/ensure-datatype dtyp-name cnstr-name obj)\n366.\n(cond\n367.\n((not (datatype-instance? obj))\n368.\n(error (string-append \"Unbundler \"\n1. (symbol->string cnstr-name)\n2. \" for datatype \"\n3. (symbol->string dtyp-name)\n4. \" applied to non-datatype instance: \")\nb. obj))\n369.\n((not (eq? dtyp-name (datatype-instance-descriptor obj)))\n370.\n(error (string-append \"Unbundler \"\n1. (symbol->string cnstr-name)\n2. \" for datatype \"\n3. (object->string dtyp-name)\n4. \" applied to instance of datatype \"\n5. (object->string (datatype-instance-descriptor obj))\n6. \": \")\nb. obj))\n371.\n(else obj)))\n\n372.\n(define (print-datatype-descriptor state desc)\n373.\n(unparse-string state \"#[datatype \")\n374.\n(unparse-object state (datatype-descriptor-name desc))\n375.\n(unparse-string state \"]\"))\n376.\n(define (print-datatype-instance state instance)\n377.\n(let ((type-name (datatype-instance-type-name instance))\n378.\n(constructor (datatype-instance-constructor instance))\n379.\n(args (datatype-instance-args instance)))\n380.\n(unparse-string state \"#[\")\n381.\n(unparse-object state type-name)\n382.\n(unparse-string state \":\")\n383.\n(unparse-object state constructor)\n384.\n(for-each (lambda (arg)\ni. (unparse-string state \" \")\nii. (unparse-object state arg))\nb. args)\n385.\n(unparse-string state \"]\")\n386.\n))\n387.\n(define (object->string obj)\n388.\n(with-output-to-string\n389.\n(lambda () (display obj))))\n390.\n;;; Structures\n391.\n(define-structure (datatype-descriptor\ni. (print-procedure print-datatype-descriptor))\n392.\nname)\n393.\n(define-structure (datatype-instance\ni. (print-procedure print-datatype-instance))\n394.\ndescriptor\n395.\ntype-name\n396.\nconstructor\n397.\nargs)\n\n398.\n;;---------------------------------------------------\n399.\n;; match.scm\n400.\n;;; DEFINE-DATATYPE and MATCH\n401.\n;;; Log:\n402.\n;;;\n403.\n;;; reistad 8/19/94 -- Taken from /zu/lyn/6821/fall-91/code/mini-fx.scm\n404.\n;;;\nto replace original Scheme+ implementation with define-syntax.\n405.\n;;;\nNow use low level macros like in the past.\n406.\n;;;\nAll global refs in macro output code protected with (get-real <id>)\n407.\n;;;\nwhich ensures that they cannot be shadowed by user definitions.\n408.\n;;;\n409.\n;;; reistad & lyn 8/23/94 (or thereabouts) Redesigned the MATCH\ndesugaring\n410.\n;;;\nto look a lot nicer. Previous version was verbose and\n411.\n;;;\ntended to shift to the right a lot.\n412.\n;;;\n413.\n;;; reistad & lyn 8/24/94 Designed and implemented a WITH-FAIL\nconstruct\n414.\n;;;\nthat captures the failure continuation at the beginning of\n415.\n;;;\na MATCH clause. Brian extends to handle duplicated pattern\n416.\n;;;\nby doing a renaming prepass on the pattern and using WITH-FAIL.\n417.\n;;;\n418.\n;;; lyn 9/09/94 -- Fixed RENAME-IN-QUASIQUOTE to handle `_'\ncorrectly\n419.\n;;;\nwithin QUASIQUOTED patterns. They were getting renamed when\n420.\n;;;\nthey shouldn't have been.\n421.\n;;;\n422.\n;;; lyn 9/10/94 -- Fixed RENAME-IN-QUASIQUOTE to correctly handle\n423.\n;;;\n+ non-symbol atoms (e.g., null, numbers, strings, etc.)\n424.\n;;;\n+ deconstructions (i.e., applications of constructors in\n425.\n;;;\npattern position)\n426.\n;;;\nPrevious version would try to rename these and barf if it\n427.\n;;;\nfound duplicates!\n428.\n;;;\nI'm still somewhat confused because I don't understand why\n429.\n;;;\nrenamer seems to get called twice on every pattern!\n430.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n431.\n;;; MATCH Begin\n432.\n;;; This is not the most efficient possible strategy for implementing\n433.\n;;; ML-style pattern matching.\n\n434.\n;;;\n435.\n;;; (match foo ((make-foo x y) ...) ...)\n436.\n;;; ==> (~match-make-foo foo 2 (lambda (x y) ...) (lambda () ...))\n437.\n;;;\n438.\n;;; JAR sez: Don't try to understand the implementation of this macro\nwithout\n439.\n;;; proper supervision.\n440.\n;;; Here are the desugaring rules used below\n441.\n;;;\n442.\n;;; -------------------------------------------------------\n443.\n;;; (match e (pat_1 e_1) ... (pat_n e_n))\n444.\n;;;\n445.\n;;; -> expand(e,\n446.\n;;;\npat_1, ..., pat_n\n447.\n;;;\ne_1, ... e_n)\n448.\n;;;\n449.\n;;; -------------------------------------------------------\n450.\n;;; expand(e,\n451.\n;;;\npat_1, ..., pat_n\n452.\n;;;\ne_1, ... e_n)\n453.\n;;;\n454.\n;;;\n455.\n;;; -> (error \"Match -- no pattern matched\"), n = 0\n456.\n;;;\n457.\n;;; -> (let ((id e))\n; id is fresh\n458.\n;;;\nexpand-pattern(pat_1\n459.\n;;;\nid\n460.\n;;;\ne_1\n461.\n;;;\nexpand(id,\n462.\n;;;\npat_2, ... pat_n\n463.\n;;;\ne_2, ..., e_n))) else\n464.\n;;;\n465.\n;;; -------------------------------------------------------\n466.\n;;;\n467.\n;;; expand-pattern(pat, v, succ-exp, fail-exp) ; Note v is always an id\n468.\n;;;\n469.\n;;; -> succ-exp, pat = _\n470.\n;;;\n471.\n;;; -> (if (=pat v) succ-exp fail-exp), pat a literal\n472.\n;;;\n; Note this is *only* place where failure\nexpression\n473.\n;;;\n; can be evaluated, which makes sense, since\n474.\n;;;\n; it's the only place that can really detect\n475.\n;;;\n; a mismatch\n476.\n;;;\n\n477.\n;;; -> (let ((pat v)) succ-exp), pat a variable\n478.\n;;;\n479.\n;;; -> (e v (lambda (id_1 ... id_n) ; where id_i = pat_i, pat_i is a variable\n480.\n;;;\n;\nis fresh, otherwise\n481.\n;;;\nexpand-sub-patterns(pat_1, ..., pat_n,\n482.\n;;;\nid_1, ... id_n,\n483.\n;;;\nsucc-exp,\n484.\n;;;\nfail-exp))\n485.\n;;;\n(lambda () ,fail-exp)), pat = (e pat_1 ... pat_n)\n486.\n;;;\n487.\n;;; -------------------------------------------------------\n488.\n;;;\n489.\n;;; expand-sub-patterns(pat_1, ..., pat_n,\n490.\n;;;\nid_1, ... id_n,\n491.\n;;;\nsucc-exp,\n492.\n;;;\nfail-exp)\n493.\n;;;\n494.\n;;; -> succ-exp, n = 0\n495.\n;;;\n496.\n;;; -> expand-pattern(pat_1\n497.\n;;;\nid_1\n498.\n;;;\nexpand-sub-patterns(pat_2, ..., pat_n,\n499.\n;;;\nid_2, ..., id_n,\n500.\n;;;\nsucc-exp,\n501.\n;;;\nfail-exp)\n502.\n;;;\n(fail-exp))\n503.\n;;;\n504.\n;;;-------------------------------------------------------------------\n505.\n;;; Example (note extra error checking and space-saving code\n506.\n;;;\noptimizations not necessarily implied by above rules:\n507.\n;;;\n508.\n;;; (match x\n509.\n;;; ((foo~ a (bar~ b)) (list a b))\n510.\n;;; (_ '())))\n511.\n;;;\n512.\n;;; -- desugars to -->\n513.\n;;;\n514.\n;;; (let\n515.\n;;; ((#fail-254 (lambda () ()))) ; Why isn't the second () quoted here?\n516.\n;;; (foo~\n517.\n;;; x\n518.\n;;; (lambda\n519.\n;;; #success-arg-256\n520.\n;;; (if\n521.\n;;;\n(not (= (*mini-fx-length* #success-arg-256) 2))\n522.\n;;;\n(*mini-fx-success-number-of-args-mismatch* '(a (bar~ b)) 2)\n\n523.\n;;;\n(apply\n524.\n;;;\n(lambda\n525.\n;;;\n(a #temp-255)\n526.\n;;;\n(bar~\n527.\n;;;\n#temp-255\n528.\n;;;\n(lambda\n529.\n;;;\n#success-arg-257\n530.\n;;;\n(if\n531.\n;;;\n(not (= (*mini-fx-length* #success-arg-257) 1))\n532.\n;;;\n(*mini-fx-success-number-of-args-mismatch* '(b) 1)\n533.\n;;;\n(apply (lambda (b) (list a b)) #success-arg-257)))\n534.\n;;;\n#fail-254))\n535.\n;;;\n#success-arg-256)))\n536.\n;;; #fail-254))\n\n537.\n;;; ---------------------------------------------------------------------------\n538.\n;;; The MATCH macro\n539.\n(define-scheme+-macro (match thing . clauses)\n540.\n(define (expand thing clauses)\n541.\n(if (null? clauses)\n542.\n`(scheme+/runtime-error \"MATCH -- no pattern matched to disc.\" ,thing)\n543.\n(let ((clause (car clauses)))\na. (define (make-matcher disc clauses)\nb. `(scheme+/match-clauses ,disc\na. '(match ,thing ,@clauses)\nb. ,@(map (expand-clause disc) clauses)))\nc. (if (not (pair? thing))\nd. ;; Optimization where discriminant is a literal or variable\ne. (make-matcher thing clauses)\nf. ;; Name discriminate so that only evaluate once\ng. (let ((thing-gensym (scheme+/gensym 'thing)))\ni. `(LET ((,thing-gensym ,thing))\nii. ,(make-matcher thing-gensym clauses)))))))\n544.\n(define (expand-clause thing)\n545.\n(lambda (clause)\n546.\n;; should return a failure acceptor\n547.\n(let* ((failure (scheme+/gensym 'fail))\na. (make-failure-acceptor (lambda (body)\na. `(lambda (,failure) ,body))))\n548.\n(cond ((with-fail? clause)\ni. (make-failure-acceptor (expand-with-fail thing clause failure)))\nb. ((and (pair? clause)\ni. (pair? (cdr clause))\nii. (null? (cddr clause)))\niii. (make-failure-acceptor\niv. (expand-pattern-top (car clause) thing (cadr clause) failure)))\nc. (else (scheme+/syntax-error \"Invalid match clause syntax: \" clause))))))\n549.\n;; Original version without user-level capture of the failure continuation\n550.\n; (define (expand-clause thing clause fail-exp)\n551.\n;\n(if (and (pair? clause)\n552.\n;\n(pair? (cdr clause))\n553.\n;\n(null? (cddr clause)))\n554.\n;\n(expand-pattern (car clause) thing (cadr clause) fail-exp)\n555.\n;\n(scheme+/syntax-error \"Invalid match clause syntax\" clause)))\n\n556.\n;; With-fail allows the user to capture the failure continuation. Ie,\n557.\n;; (match <foo>\n558.\n;; ((add e e) <body>))\n559.\n;;\n560.\n;; would be written:\n561.\n;;\n562.\n;; (match <foo>\n563.\n;; ((add e e.2)\n564.\n;; (with-fail\n565.\n;;\n(lambda (fail)\n566.\n;;\n(if (equal? e e.2)\n567.\n;;\n<body>\n568.\n;;\n(fail))))))\n569.\n;;\n570.\n;; Idea for new sugar on-top of with-fail (trevor)\n571.\n;; (<pat> (where <exp_test> <exp_body))\n572.\n;; ==> (<pat> (with-fail (lambda (fail) (if <exp_test> <exp_body>\n(fail)))))\n573.\n;;\n574.\n(define (with-fail? clause)\n575.\n(and (pair? clause)\na. (pair? (cdr clause))\nb. (null? (cddr clause))\nc. (let ((body (cadr clause)))\nd. (and (pair? body)\ni. (pair? (cdr body))\nii. (null? (cddr body))\niii. (eq? (car body) 'with-fail)))))\n576.\n(define (fail-body clause)\n577.\n(cadr (cadr clause)))\n578.\n(define (expand-with-fail thing clause fail-name)\n579.\n;; Be sure to call expand-pattern-top to handle\n580.\n;; duplicate pattern variables.\n581.\n(expand-pattern-top (car clause)\n1. thing\n2. `(scheme+/handle-with-fail ,(fail-body clause)\n1. ,fail-name)\n3. fail-name))\n582.\n;; End with-fail.\n583.\n;; expand-pattern-top: entry point for pattern expansion\n584.\n;; First grovell pat to find duplicate pattern variables so we can\n585.\n;; use with-fail to make them do the right thing.\n\n586.\n(define (expand-pattern-top pat thing succ-exp fail-name)\n587.\n(with-values (lambda () (rename-pattern-variables pat empty-dict))\n588.\n(lambda (new-pat dict)\n589.\n(let ((dict (list-transform-negative dict used-once?)))\na. (if (null? dict)\nb. (expand-pattern pat thing succ-exp fail-name)\nc. ;; Note: could just call expand-pattern directly as fail-name\nd. ;; is in scope:\ne. ;; (expand-pattern new-pat thing\nf. ;;\n(if (and ,@(gen-check-dups dict))\ng. ;;\n,succ-exp\nh. ;;\n(,fail-name))\ni. ;;\nfail-name)\nj. (expand-with-fail\ni. thing\nii. (let ((fail-gensym (scheme+/gensym 'fail)))\niii. `(,new-pat (with-fail\n1. (lambda (,fail-gensym)\na. (if (and ,@(gen-check-dups dict))\nb. ,succ-exp\nc. (,fail-gensym))))))\niv. fail-name))))))\n590.\n(define (rename-pattern-variables pat dict)\n591.\n;; Rename duplicate pattern variables and\n592.\n;; use values to return new pattern and a dictionary of pattern variables\n593.\n;; Eg. (mul (add e e) (var x)) ==> (values (add e e.2) ((e e.2) (x)))\n594.\n(cond ((eq? pat '_) (values pat dict))\na. ((symbol? pat)\nb. (if (in-dict? pat dict)\ni. (let ((new-var (scheme+/gensym pat)))\nii. (extend-entry! pat new-var dict)\niii. (values new-var dict))\niv. (values pat (add-entry pat dict))))\nc. ((not (pair? pat)) (values pat dict))\n;; constant pattern\nd. ((or (eq? (car pat) 'symbol)\ni. (eq? (car pat) 'quote))\ne. (values pat dict))\nf. ((eq? (car pat) 'quasiquote)\ng. (with-values (lambda () (rename-in-quasiquote (cadr pat) dict))\nh. (lambda (new-cadr dict)\ni. (values `(,'quasiquote ,new-cadr) dict))))\ni. (else\nj. ;; (constructor pat1 pat2 ... patn)\nk. (with-values (lambda () (rename-list (cdr pat) dict))\n\nl. (lambda (patterns dict)\ni. (values `(,(car pat) ,@patterns) dict))))\nm. ))\n595.\n(define empty-dict '())\n596.\n(define (in-dict? x dict) (assoc x dict))\n597.\n(define (add-entry x dict) `((,x) ,@dict))\n598.\n(define (extend-entry! x new dict)\n599.\n(let ((entry (assoc x dict)))\n600.\n(set-cdr! entry (cons new (cdr entry)))\n601.\n))\n602.\n(define (used-once? dict-entry)\n603.\n(= (length dict-entry) 1))\n604.\n(define (gen-check-dups dict)\n605.\n(if (null? dict)\n606.\n'()\n607.\n`(,(gen-ensure-equal (car dict)) ,@(gen-check-dups (cdr dict)))))\n608.\n(define (gen-ensure-equal lst)\n609.\n(let ((first (car lst)))\n610.\n`(and ,@(let loop ((rest (cdr lst)))\ni. (if (null? rest)\nii. '()\niii. ;;; Lyn changed on 9/10/94 to install scheme+/equal?\niv. ; `(((get-real equal?) ,first ,(car rest))\nv. ; ,@(loop (cdr rest)))\nvi. `((scheme+/equal? ,first ,(car rest))\nvii. ,@(loop (cdr rest))))))))\n611.\n(define (rename-list lst dict)\n612.\n(if (null? lst)\n613.\n(values '() dict)\n614.\n(with-values (lambda () (rename-pattern-variables (car lst) dict))\na. (lambda (new-head dict)\nb. (with-values (lambda () (rename-list (cdr lst) dict))\nc. (lambda (new-tail dict)\ni. (values (cons new-head new-tail) dict)))))))\n615.\n(define (rename-in-quasiquote body dict)\n616.\n(define (descend-quasi x level dict)\n617.\n(cond ((eq? x '_)\n; Handle _ specially -- don't rename!\na. (values x dict))\nb. ((symbol? x)\n; Level 0 symbols get added to dict\nc. (if (= level 0)\ni. (if (in-dict? x dict)\nii. (let ((tmp (scheme+/gensym x)))\n\niii. (extend-entry! x tmp dict)\niv. (values tmp dict))\nv. (values x (add-entry x dict)))\nvi. (values x dict)))\nd. ((not (pair? x))\n; Other atomic data (including empty list)\ne. (values x dict))\n; are treated as constants.\nf. ((and (not (null? (cdr x))) (null? (cddr x))) ; List of length 2\ng. (case (car x)\ni. ((unquote)\nii. (if (= level 0)\niii. (scheme+/syntax-error \"unquote too deep\")\niv. (with-values (lambda ()\na. (descend-quasi (cadr x) (- level 1) dict))\nv. (lambda (new dict)\n1. (values `(,'unquote ,new) dict)))))\nvi. ((unquote-splicing)\nvii. (if (= level 0)\nviii. (scheme+/syntax-error \"unquote-splicing too deep\")\nix. (with-values (lambda ()\na. (descend-quasi (cadr x) (- level 1) dict))\nx. (lambda (new dict)\n1. (values `(,'unquote-splicing ,new) dict)))))\nxi. ((quasiquote)\nxii. (with-values (lambda ()\na. (descend-quasi (cadr x) (+ level 1) dict))\nxiii. (lambda (new dict)\nxiv. (values `(,'quasiquote ,new) dict))))\nxv. ((quote)\nxvi. (with-values (lambda ()\na. (descend-quasi (cadr x) level dict))\nxvii. (lambda (new dict)\nxviii. (values `(,'quote ,new) dict))))\nxix. (else\nxx. (descend-quasi-deconstruction x level dict))))\nh. (else (descend-quasi-deconstruction x level dict))))\n618.\n(define (descend-quasi-deconstruction lst level dict)\n619.\n;;\n620.\n;; LST must be non-empty.\n621.\n;;\n622.\n;; If LEVEL is 0, then LST is a deconstruction and the car of LST\n623.\n;; is a constructor. The constructor should not be renamed, but\n624.\n;; its arguments should be.\n625.\n;;\n626.\n;; If LEVEL is not 0, treat LST as a regular list.\n627.\n;;\n628.\n(if (= level 0)\n\na. (with-values (lambda () (descend-quasi-list (cdr lst) level dict))\nb. (lambda (new-args dict)\nc. (values (cons (car lst) ; The constructor\n1. new-args)\nii. dict)))\nd. (descend-quasi-list lst level dict)))\n629.\n(define (descend-quasi-list x level dict)\n630.\n(if (null? x)\na. (values '() dict)\nb. (with-values (lambda () (descend-quasi (car x) level dict))\nc. (lambda (first dict)\nd. ;BJR: change to descend-quasi to handle dotted pairs\ne. ;(with-values (lambda() (descend-quasi-list (cdr x) level dict)))\nf. (with-values (lambda () (descend-quasi (cdr x) level dict))\ni. (lambda (rest dict)\nii. (values (cons first rest) dict)))))))\n631.\n; (trace-entry descend-quasi)\n632.\n; (trace-entry descend-quasi-list)\n633.\n; (trace-entry descend-quasi-deconstruction)\n634.\n(descend-quasi body 1 dict)\n635.\n)\n636.\n;; End rename-pattern-variables\n637.\n; succ-exp is an expressions\n638.\n; fail-name is a symbol -- name of the current failure continuation\n639.\n(define (expand-pattern pat thing succ-exp fail-name)\n640.\n(let ((fail-exp `(,fail-name)))\n641.\n(cond ((eq? pat '_) succ-exp)\na. ((symbol? pat)\nb. (if (eq? pat thing)\ni. succ-exp\n;Optimization for same variable that works\na. ;in conjunction with optimization for naming\nb. ;success lambda args below\nii. `(let ((,pat ,thing)) ,succ-exp)))\nc. ;; Don't make any assumptions about thing.\n642.\n;\n((number? pat)\n643.\n;\n`(if ((get-real =) ,thing ,pat) ,succ-exp ,fail-exp))\n644.\n;\n((boolean? pat)\n645.\n;\n`(if ((get-real eq?) ,thing ,pat) ,succ-exp ,fail-exp))\n646.\n;\n((char? pat)\n647.\n;\n`(if ((get-real char=?) ,thing ,pat) ,succ-exp ,fail-exp))\n648.\n;\n((string? pat)\n649.\n;\n`(if ((get-real string=?) ,thing ,pat) ,succ-exp ,fail-exp))\n\na. ((number? pat)\nb. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\nc. ((boolean? pat)\nd. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\ne. ((char? pat)\nf. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\ng. ((string? pat)\nh. `(if ((get-real equal?) ,thing ,pat) ,succ-exp ,fail-exp))\ni. ((not (pair? pat))\nj. (scheme+/syntax-error \"unrecognized MATCH pattern: \" pat))\nk. ((eq? (car pat) 'symbol)\nl. `(if ((get-real eq?) ,thing ,pat) ,succ-exp ,fail-exp))\nm. ((eq? (car pat) 'quote)\nn. (let ((pred (if (symbol? (cadr pat))\n1. '(get-real eq?) ;Optimization\n2. '(get-real equal?))))\nii. `(if (,pred ,thing ,pat) ,succ-exp ,fail-exp)))\no. ((eq? (car pat) 'quasiquote)\np. (expand-pattern (expand-quasiquote (cadr pat) 0)\n1. thing succ-exp fail-name))\nq. (else\nr. (expand-compound-pattern pat thing succ-exp fail-name)))))\n650.\n; Expand a pattern of the form (op arg ...).\n651.\n; op is assumed to be an injection or construction procedure.\n652.\n; If it's not, you'll get a Scheme error of the form\n653.\n; \"unbound variable ~MATCH-OP\".\n654.\n(define (expand-compound-pattern pat thing succ-exp fail-name)\n655.\n(let ((number-of-sub-patterns (length (cdr pat)))\na. (success-arg-gensym (scheme+/gensym 'success-arg))\nb. (names (map (lambda (pat)\n1. (if (and (symbol? pat) (not (eq? pat '_)))\n2. pat\n;Optimization that works in conjunction\ni. ;with variable case for EXPAND-\nPATTERN\n3. (scheme+/gensym 'temp)))\nii. (cdr pat)))\nc. )\n656.\n`(\n657.\nscheme+/deconstruct-carefully\n658.\n,(car pat)\n659.\n',(cdr pat)\n660.\n,number-of-sub-patterns\n661.\n,thing\n\n662.\n(LAMBDA ,names\na. ,(let expand-sub-patterns ((pats (cdr pat))\na. (names names))\nb. (if (null? pats)\ni. succ-exp\nii. (expand-pattern (car pats)\na. (car names)\nb. (expand-sub-patterns (cdr pats) (cdr names))\nc. fail-name))))\n663.\n,fail-name)))\n664.\n; This is JAR's quasiquote pattern handler, which is exceptionally clever.\n665.\n; It tries to avoid the desugaring into CONS~\n666.\n; unless it absolutely has to. Here are some examples:\n667.\n;\n668.\n; `(a b) -> '(a b)\n669.\n; `(,a b) -> (list->sexp~ (cons~ a '(b)))\n670.\n; `(a ,b) -> (list->sexp~ (cons~ 'a (cons~ b '())))\n671.\n; `(,a ,b) -> (list->sexp~ (cons~ a (cons~ b '())))\n672.\n; `(,a ,@b) -> (list->sexp~ (cons~ a b))\n673.\n;;----------------------------------------------------------------------\n674.\n;; LYN'S NOTES ON QUOTATION\n675.\n;\n676.\n; What I had in mind is expressed by the following rewrite rules\n677.\n;\n678.\n; (quasiquote (unquote ?a)) => ?a\n679.\n;\n680.\n; (quasiquote ((unquote-splicing ?a) ?extra ?rest ...) => Error! illegal ,@\n681.\n;\n682.\n; (quasiquote ((unquote-splicing ?a)) => ?a\n683.\n;\n684.\n; (quasiquote (unquote-splicing ?a)) => Error! illegal ,@\n685.\n;\n686.\n; (quasiquote (?a . ?b)) => (cons (quasiquote ?a) (quasiquote ?b))\n687.\n;\n688.\n; (quasiquote ?a) => (quote ?a)\n689.\n;\n690.\n; (These rules must be applied in the order shown to get the precedence\n691.\n; right.)\n692.\n;\n693.\n; These rules treat UNQUOTE and UNQUOTE-SPLICING specially in\nthe\n694.\n; context of a quasiquote. Granted, this can give some weird effects;\n\n695.\n; the following are transcripts of the pattern matching implementation of\n696.\n; Scheme+:\n697.\n;\n698.\n; ;;;--------------------------------------------------\n699.\n; (define x 17)\n700.\n; (define y '(23))\n701.\n;\n702.\n; (match '(1 . 2)\n703.\n;\n(`(,x . ,y) (list y x)))\n704.\n; ;Value 56: (2 1)\n705.\n;\n706.\n; (match '(1 . 2)\n707.\n;\n(`(,x unquote y) (list y x)))\n708.\n; ;Value 57: (2 1)\n709.\n;\n710.\n; (match '(1 . 2)\n711.\n;\n(`(,x unquote y) (list y x)))\n712.\n; ;Value 57: (2 1)\n713.\n;\n714.\n; (match '(1 unquote y)\n715.\n;\n(`(,x unquote y) (list y x)))\n716.\n; ;Value 58: (,y 1)\n717.\n;\n718.\n; (match '(1 . 2)\n719.\n;\n(`(,x unquote y z) (list y x)))\n720.\n; ;No pattern matched!\n721.\n; ;To continue, call RESTART with an option number:\n722.\n;\n723.\n; (match '(1 unquote y z)\n724.\n;\n(`(,x unquote y z) (list y x)))\n725.\n; ;Value 64: ((23) 1) ; The (23) comes from definition of Y at top.\n726.\n;\n727.\n; (match '(1 2)\n728.\n;\n(`(,x ,@y) (list y x)))\n729.\n; ;Value 75: ((2) 1)\n730.\n;\n731.\n; (match '(1 2)\n732.\n;\n(`(,x . ,@y) (list y x)))\n733.\n; ;Illegal use of ,@ in pattern\n734.\n; ;To continue, call RESTART with an option number:\n735.\n; ; (RESTART 1) => Return to read-eval-print level 1.\n736.\n;\n737.\n; (match '(1 2)\n738.\n;\n(`(,x unquote-splicing y) (list y x)))\n739.\n; ;Illegal use of ,@ in pattern\n740.\n; ;To continue, call RESTART with an option number:\n\n741.\n;\n742.\n; (match '(1 unquote-splicing y z)\n743.\n;\n(`(,x unquote-splicing y z) (list y x)))\n744.\n; ;Value 76: ((23) 1) ; The (23) comes from definition of Y at top.\n745.\n;\n746.\n;\n747.\n; ;;;--------------------------------------------------\n748.\n;\n749.\n; The quirkiness is exhibited only with the symbols UNQUOTE and\n750.\n; UNQUOTE-SPLICING in a QUASIQUOTE context; all other symbols\nbehave as\n751.\n; expected. This is OK (IMHO) because these are part of the quasiquote\n752.\n; language. Even more convincing, the above interpretation is consistent\n753.\n; with what Scheme (at least MIT Scheme) does with QUASIQUOTE in a\n754.\n; non-pattern context. Observe:\n755.\n;\n756.\n; ;; Assume X is 17 and Y is (23)\n757.\n;\n758.\n; `(,x . ,y)\n759.\n; ;Value 81: (17 23)\n760.\n;\n761.\n; `(,x unquote y)\n762.\n; ;Value 78: (17 23)\n763.\n;\n764.\n; `(,x unquote y z)\n765.\n; ;Value 77: (17 unquote y z)\n766.\n;\n767.\n; `(,x ,@y)\n768.\n; ;Value 79: (17 23)\n769.\n;\n770.\n; `(,x . ,@y)\n771.\n; ;Syntax error: ,@ in illegal context: y\n772.\n; ;To continue, call RESTART with an option number:\n773.\n;\n774.\n; `(,x unquote-splicing y)\n775.\n; ;Syntax error: ,@ in illegal context: y\n776.\n; ;To continue, call RESTART with an option number:\n777.\n;\n778.\n; `(,x unquote-splicing y z)\n779.\n; ;Value 80: (17 unquote-splicing y z)\n780.\n;\n781.\n;\n782.\n; The only inconsistent usage is the treatment of ,@ in a pattern context\n783.\n; to avoid backtracking.\n784.\n;\n785.\n;;----------------------------------------------------------------\n\n786.\n;; NOTE: these procedures are all written with names using 'deconstructor'\n787.\n;; which is an out-of-date term -- the correct terminology is 'unbunlder'.\n788.\n(define (expand-quasiquote x level)\n789.\n(descend-quasiquote x level finalize-quasiquote))\n790.\n(define (descend-quasiquote x level return)\n791.\n(cond ((not (pair? x))\n; Includes null?\na. (return 'quote x))\nb. ((and (not (null? (cdr x))) (null? (cddr x))) ; List of length 2\nc. (case (car x)\nd. ((unquote)\ne. (if (= level 0)\ni. (return 'unquote (cadr x))\nii. (descend-interesting x (- level 1) unquoted->sexp return)))\nf. ((unquote-splicing)\ng. (if (= level 0)\ni. (return 'unquote-splicing (cadr x))\nii. (descend-interesting x (- level 1) unquoted-splicing->sexp return)))\nh. ((quasiquote)\ni. (descend-interesting x (+ level 1) quasiquoted->sexp return))\nj. ((quote)\nk. (descend-interesting x level quoted->sexp return))\nl. (else\nm. (descend-quasiquote-list x level return))))\nn. (else (descend-quasiquote-list x level return))))\n792.\n(define (descend-interesting x level inject return)\n793.\n(descend-quasiquote (cadr x) level\n794.\n(lambda (mode arg)\n795.\n(if (eq? mode 'quote)\na. (return 'quote x)\nb. (return 'unquote `(,inject ,(finalize-quasiquote mode arg)))))))\n796.\n(define (descend-quasiquote-list x level return)\n797.\n(descend-quasiquote-tail x level\n798.\n(lambda (mode arg)\n799.\n(if (eq? mode 'quote)\na. (return 'quote x)\nb. ;;BJR: list-sexp is identity and only needed for typing concerns\nc. ;; (return 'unquote `(,list->sexp ,arg))\nd. (return 'unquote arg)))))\n800.\n; Modified below to handle dotted pairs.\n801.\n; (define (descend-quasiquote-tail x level return)\n\n802.\n;\n(if (null? x)\n803.\n;\n(return 'quote x)\n804.\n;\n(descend-quasiquote-tail (cdr x) level\n805.\n;\n(lambda (cdr-mode cdr-arg)\n806.\n;\n(descend-quasiquote (car x) level\n807.\n;\n(lambda (car-mode car-arg)\n808.\n;\n(cond ((and (eq? car-mode 'quote) (eq? cdr-mode 'quote))\n809.\n;\n(return 'quote x))\n810.\n;\n((eq? car-mode 'unquote-splicing)\n811.\n;\n(cond ((and (eq? cdr-mode 'quote) (null? cdr-arg))\n812.\n;\n;; (,@mumble)\n813.\n;\n(return 'unquote car-arg)) ;Type must be a list!\n814.\n;\n(else (scheme+/syntax-error \"Illegal use of @ in\na quasiquoted pattern.\"))))\n815.\n;\n; JAR allowed the following, but doesn't make sense\n816.\n;\n; without backtracking.\n817.\n;\n; (else\n818.\n;\n; ;; (,@mumble ...)\n819.\n;\n; (return 'unquote\n820.\n;\n;\n`(,append-word ,car-arg\n821.\n;\n;\n,(finalize-quasiquote\n822.\n;\n;\ncdr-mode cdr-arg))))\n823.\n;\n(else\n824.\n;\n(return 'unquote\n825.\n;\n;; what is cons-word supposed to be?\n826.\n;\n`(,cons ,(finalize-quasiquote car-mode car-arg)\n827.\n;\n,(finalize-quasiquote cdr-mode\ncdr-arg)))))))))))\n828.\n(define (descend-quasiquote-tail x level return)\n829.\n(if (null? x)\n830.\n(return 'quote x)\n831.\n;; BJR&LYN: This handles dotted-pair too!\n832.\n(descend-quasiquote (cdr x) level\na. (lambda (cdr-mode cdr-arg)\nb. (descend-quasiquote (car x) level\nc. (lambda (car-mode car-arg)\ni. (cond ((and (eq? car-mode 'quote) (eq? cdr-mode 'quote))\nii. (return 'quote x))\niii. ((eq? car-mode 'unquote-splicing)\niv. (cond ((and (eq? cdr-mode 'quote) (null? cdr-arg))\n1. ;; (,@mumble)\n2. (return 'unquote car-arg)) ;Type must be a list!\n3. (else (scheme+/syntax-error \"Illegal use of @ in a\nquasiquoted pattern.\"))))\nv. ((and (eq? cdr-mode 'unquote-splicing)\n\n1. (not (pair? (cdr x))))\nvi. ;; (foo . ,@x)\nvii. (scheme+/syntax-error\n1. \"Illegal use of @ in a quasiquoted pattern.\"))\nviii. ; JAR allowed the following, but doesn't make sense\nix. ; without backtracking.\nx. ; (else\nxi. ; ;; (,@mumble ...)\nxii. ; (return 'unquote\nxiii. ;\n`(,append-word ,car-arg\nxiv. ;\n,(finalize-quasiquote\nxv. ;\ncdr-mode cdr-arg))))\nxvi. (else\nxvii. (return 'unquote\na. `(,cons ,(finalize-quasiquote car-mode car-arg)\ni. ,(finalize-quasiquote cdr-mode cdr-\narg)))))))))))\n833.\n(define (finalize-quasiquote mode arg)\n834.\n(case mode\n835.\n((quote) `',arg)\n836.\n((unquote) arg)\n837.\n((unquote-splicing)\n838.\n(scheme+/syntax-error \",@ in illegal context: \" arg)) ;`,@x or ``,,@x or `(y\n. ,@x)\n839.\n(else\n840.\n(scheme+/syntax-error \"quasiquote bug: \" (list mode arg)))))\n841.\n(define (non-atomic-deconstructors clauses)\n842.\n(remove-duplicates\n843.\n(mapcan (lambda (c)\ni. (filter\nii. pair?\niii. (deconstructors (match-clause-pattern c))))\nb. clauses)))\n844.\n(define (deconstructors pat)\n845.\n(cond ((not (pair? pat)) '())\na. ((quote? pat) '())\nb. ((quasiquote? pat)\nc. (mapcan deconstructors\ni. (quasiquote-embedded-expressions (quasiquote-text pat))))\nd. (else\ne. (cons (car pat)\ni. (mapcan deconstructors (cdr pat))))))\n\n846.\n(define (filter pred lst)\n847.\n(cond ((null? lst) '())\na. ((pred (car lst))\nb. (cons (car lst) (filter pred (cdr lst))))\nc. (else (filter pred (cdr lst)))))\n848.\n(define (mapcan proc lst)\n849.\n(if (null? lst)\n850.\n'()\n851.\n(append (proc (car lst))\ni. (mapcan proc (cdr lst)))))\n852.\n(define (remove-duplicates lst)\n853.\n(if (null? lst)\n854.\n'()\n855.\n(let ((result (remove-duplicates (cdr lst))))\na. (if (member (car lst) result)\nb. result\nc. (cons (car lst) result)))))\n856.\n(define (quasiquote-embedded-expressions exp)\n857.\n(let descend-quasiquote ((exp exp)\n1. (level 0))\n858.\n(cond ((not (pair? exp)) '())\na. ((quote? exp) '())\nb. ((quasiquote? exp)\nc. (descend-quasiquote (quasiquote-text exp) (+ level 1)))\nd. ((unquote? exp)\ne. (if (= level 0)\ni. (list (unquote-text exp))\nii. (descend-quasiquote (unquote-text exp) (- level 1))))\nf. ((unquote-splicing? exp)\ng. (if (= level 0)\ni. (list (unquote-splicing-text exp))\nii. (descend-quasiquote (unquote-splicing-text exp) (- level 1))))\nh. (else (mapcan (lambda (e) (descend-quasiquote e level)) exp))\ni. )))\n859.\n(define (clauses-deconstructor-subst clauses subst)\n860.\n(map (lambda (clause)\na. (cons (pattern-deconstructor-subst (car clause) subst)\ni. (cdr clause)))\nb. clauses))\n861.\n(define (pattern-deconstructor-subst pat subst)\n\n862.\n(cond ((not (pair? pat)) pat)\na. ((quote? pat) pat)\nb. ((quasiquote? pat)\nc. (quasiquote-deconstructor-subst (quasiquote-text pat) subst))\nd. (else (cons (subst (car pat))\ni. (map (lambda (p)\n1. (pattern-deconstructor-subst p subst))\n2. (cdr pat))))))\n863.\n(define (quasiquote-deconstructor-subst pat subst)\n864.\n(let descend-quasiquote ((exp pat)\n1. (level 0))\n865.\n(cond ((not (pair? exp)) exp)\na. ((quote? exp) exp)\nb. ((quasiquote? exp)\nc. (quasiquote-make\nd. (descend-quasiquote (quasiquote-text exp) (+ level 1))))\ne. ((unquote? exp)\nf. (unquote-make\ng. (if (= level 0)\ni. (pattern-deconstructor-subst\nii. (unquote-text exp)\niii. subst)\niv. (descend-quasiquote (unquote-text exp) (- level 1)))))\nh. ((unquote-splicing? exp)\ni. (unquote-splicing-make\nj. (if (= level 0)\ni. (pattern-deconstructor-subst\nii. (unquote-splicing-text exp)\niii. subst)\niv. (descend-quasiquote (unquote-splicing-text exp) (- level 1)))))\nk. (else (map (lambda (e) (descend-quasiquote e level)) ex)))))\n866.\n(define match-clause-pattern first)\n867.\n(define (predicate sym)\n868.\n(lambda (exp)\n869.\n(if (pair? exp)\na. (eq? (car exp) sym)\nb. #f)))\n870.\n; Quoting\n871.\n(define quote? (predicate 'quote))\n872.\n(define (quote-make text) (list 'quote text))\n873.\n(define quote-text second)\n874.\n(define quasiquote? (predicate 'quasiquote))\n\n875.\n(define (quasiquote-make text) (list 'quasiquote text))\n876.\n(define quasiquote-text second)\n877.\n(define unquote? (predicate 'unquote))\n878.\n(define (unquote-make text) (list 'unquote text))\n879.\n(define unquote-text second)\n880.\n(define unquote-splicing? (predicate 'unquote-splicing))\n881.\n(define (unquote-splicing-make text) (list 'unquote-splicing text))\n882.\n(define unquote-splicing-text second)\n883.\n;; Main body of the MATCH macro\n884.\n(expand thing clauses)\n885.\n) ; End MATCH macro expander\n\n886.\n(define (scheme+/match-clauses disc match-exp . rest)\n887.\n(let loop ((clauses rest))\n888.\n(if (null? clauses)\n889.\n(scheme+/runtime-error \"MATCH -- no pattern matched to disc.\"\na. disc match-exp)\n890.\n((car clauses)\na. (lambda ()\nb. (loop (cdr clauses)))))))\n891.\n;; Procedure for doing deconstruction out-of-line\n892.\n(define (scheme+/deconstruct-carefully\na. constr sub-patterns nargs thing succ-cont fail-cont)\n893.\n((unbundler constr)\n894.\nthing\n895.\n(lambda success-args\n896.\n(if (not (= (length success-args) (length sub-patterns)))\na. (scheme+/success-number-of-args-mismatch sub-patterns\n1. success-args)\nb. (apply succ-cont success-args)))\n897.\nfail-cont))\n898.\n(define (scheme+/handle-with-fail fail-acceptor fail-cont)\n899.\n(let ((token (list 'fail-token)))\n900.\n;; fail-acceptor is the body of the with-fail\n901.\n;; fail-cont is the failure continuation for this clause\n902.\n;;OLD: fail-body is a failure acceptor, so just apply it to the\n903.\n;;\ncurrent failure: (fail-acceptor fail-cont)\n904.\n;;BJR: need to really abort clause so grab continuation\n905.\n(let ((return-value\na. (call-with-current-continuation\nb. (lambda (k)\nc. (fail-acceptor\ni. ;; abort by returning failure continuation\nii. (lambda () (k token)))))))\n906.\n(if (eq? return-value token)\na. ;; we're aborting\nb. (fail-cont)\nc. return-value))))\n907.\n;;; MATCH End\n908.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n\n909.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n910.\n;;; SCHEME+/GENSYM\n911.\n(define scheme+/gensym\n912.\n(let ((counter 0))\n913.\n(lambda (sym)\n914.\n(let ((result (string->symbol\ni. ;; Symbols beginning with # aren't recognized by reader,\nii. ;; so this can't conflict with a user-specified name.\niii. (string-append \"#\"\na. (symbol->string sym)\nb. \"-\"\nc. (number->string counter)))))\n915.\n(set! counter (+ counter 1))\n916.\nresult))))\n917.\n;;;\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$\n\n918.\n(define (scheme+/success-number-of-args-mismatch patterns exps)\n919.\n(scheme+/runtime-error\n920.\n(string-append \"the number of sub-patterns in a match clause (\"\ni. (number->string (length patterns))\nii. \") is not equal to \\nthe number of fields in a deconstructed datatype\nobject (\"\niii. (number->string (length exps))\niv. \"). \\nTried to match the following patterns and expressions:\\n\")\n921.\n(list 'patterns: patterns 'exps: exps)))\n\n922.\n;;---------------------------------------------------\n923.\n;; top-level.scm\n924.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n925.\n;;;\n926.\n;;; Scheme+ Top-Level\n927.\n;;;\n928.\n;;; Author:\nLyn\n929.\n;;; Creation Date: 6/23/94\n930.\n;;; Log:\n931.\n;;; * 8/19/94 (reistad): Reworked to use low level macros.\n932.\n;;; * 8/11/94 (lyn): Adapted Mini-FX SF, CF, and path stuff to Scheme+\n933.\n;;; Also added an explicit Scheme+ interactive environment.\n934.\n;;;\n935.\n;;; Documentation:\n936.\n;;; * Controls the integration of Scheme+ within MIT Scheme.\n937.\n;;; * Based on the Mini-FX top level.\n938.\n;;; * Ignores the deep issues of interactions between syntactic definitions\n939.\n;;; and first-class environments. (According to CPH, this is why\n940.\n;;; SYNTAX-RULES aren't standard in MIT Scheme.)\n941.\n;;;\n942.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n943.\n;;;\n944.\n;;; History\n945.\n;;;\n946.\n;;;\n947.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n948.\n;;;----------------------------------------------------------------------------\n949.\n;;; TOP-LEVEL EVALUATION\n950.\n;;; Loading files in Scheme+ requires special handling of unsyntaxed files.\n951.\n(define (scheme+/load filename)\n952.\n(load filename scheme+/interactive-environment scheme+/syntax-table))\n953.\n(define (scheme+/eval exp env)\n954.\n(eval (syntax exp scheme+/syntax-table) env))\n955.\n;; Currently unsupported\n956.\n;\n957.\n(define (scheme+/sf filename . rest)\n958.\n;; (sf/set-file-syntax-table! (->pathname filename) scheme+/syntax-table)\n959.\n;; (apply sf filename rest)\n960.\n(error \"SF for Scheme+ files is currently unsupported\")\n961.\n)\n\n962.\n(define (scheme+/cf filename . rest)\n963.\n;; (sf/set-file-syntax-table! (->pathname filename) scheme+/syntax-table)\n964.\n;; (apply cf filename rest)\n965.\n(error \"CF for Scheme+ files is currently unsupported\")\n966.\n)\n967.\n;;;----------------------------------------------------------------------------\n968.\n;;; Installation of evaluator\n969.\n(define (scheme+/enter-top-level)\n970.\n;; Change the emacs interface\n971.\n;; Doesn't seem to work.\n972.\n;; (scheme-runtime/install-mfx-emacs-interface!)\n973.\n;; No longer needed -- reistad 8/19/94\n974.\n; (scheme-runtime/install-evaluator! (lambda (sexp env st)\n975.\n;\n(scheme+/eval sexp env)))\n976.\n(scheme-runtime/install-environment! scheme+/interactive-environment)\n977.\n(display (string-append\na. \"\\nYou are now typing at the Scheme+ interpreter (version \"\nb. scheme+/version\nc. \")\"\nd. ))\n978.\n)\n979.\n(define (scheme+/exit-top-level)\n980.\n;; No longer needed -- reistad 8/19/94\n981.\n; (scheme-runtime/install-default-evaluator!)\n982.\n(scheme-runtime/install-environment! user-initial-environment)\n983.\n(display \"\\nYou are now typing at the Scheme interpreter.\")\n984.\n)\n985.\n;; A new version of EQUAL? that provides equality checking of datatype\ninstances\n986.\n;;\n987.\n(define (scheme+/equal? obj1 obj2)\n988.\n(cond ((eq? obj1 obj2) #t)\n989.\n((pair? obj1)\na. (if (pair? obj2)\n\nb. (and (scheme+/equal? (car obj1) (car obj2))\ni. (scheme+/equal? (cdr obj1) (cdr obj2)))\nc. #f))\n990.\n((datatype-instance? obj1)\na. (if (datatype-instance? obj2)\nb. (scheme+/datatype-instance-equal? obj1 obj2)\nc. #f))\n991.\n((number? obj1)\na. (if (number? obj2)\nb. (= obj1 obj2)\nc. #f))\n992.\n((string? obj1)\na. (if (string? obj2)\nb. (string=? obj1 obj2)\nc. #f))\n993.\n((char? obj1)\na. (if (char? obj2)\nb. (char=? obj1 obj2)\nc. #f))\n994.\n((vector? obj1)\na. (if (vector obj2)\nb. (and (= (vector-length obj1) (vector-length obj2))\ni. (let loop ((i (- (vector-length obj1) 1)))\nii. (if (< i 0)\n1. #t\n2. (and (scheme+/equal? (vector-ref obj1 i)\ni. (vector-ref obj2 i))\n3. (loop (- i 1))))))\nc. #f))\n995.\n(else #f)\n996.\n))\n997.\n(define (scheme+/datatype-instance-equal? dinst1 dinst2)\na. (and (eq? (datatype-instance-descriptor dinst1)\ni. (datatype-instance-descriptor dinst2))\nb. (eq? (datatype-instance-constructor dinst1)\ni. (datatype-instance-constructor dinst2))\nc. (scheme+/equal? (datatype-instance-args dinst1)\n1. (datatype-instance-args dinst2))))\n998.\n;; Handy synonyms\n999.\n(define (scheme+) (scheme+/enter-top-level))\n1000.\n(define (scheme)\n1001.\n(display \"\\nYou are already typing at the Scheme interpreter.\"))\n\n1002.\n(define (scheme+/pp . args)\n1003.\n;; Version of PP that prints everything as code (nothing as tables).\n1004.\n(if (version-7.1.3?)\n1005.\n(apply pp args)\n1006.\n(fluid-let ((*pp-lists-as-tables?* #f))\n1007.\n(apply pp args))))\n1008.\n;;;----------------------------------------------------------------------------\n1009.\n;;; The Scheme+ Environment\n1010.\n;;;\n1011.\n;;; This creates a new environment on top of user-initial-environment\n1012.\n;;; that contains a few Scheme+ specific bindings.\n1013.\n(define scheme+/interactive-environment\n1014.\n(make-environment\n1015.\n(define load scheme+/load)\n1016.\n(define eval scheme+/eval)\n1017.\n(define sf scheme+/sf)\n1018.\n(define cf scheme+/cf)\n1019.\n(define equal? scheme+/equal?)\n1020.\n(define user-initial-environment 'later)\n1021.\n(define global-eval\n1022.\n(lambda (exp) (eval exp scheme+/interactive-environment)))\n1023.\n(define scheme scheme+/exit-top-level)\n1024.\n(define scheme+\n1025.\n(lambda ()\n1026.\n(display \"\\nYou are already typing at the Scheme+ interpreter.\")))\n1027.\n(define pp scheme+/pp)\n1028.\n))\n1029.\n(eval `(set! user-initial-environment ,scheme+/interactive-environment)\n1030.\nscheme+/interactive-environment)\n\n1031.\n;;;----------------------------------------------------------------------------\n1032.\n;;; Version Handling\n1033.\n;;; Scheme version stuff\n1034.\n; (define (runtime-system)\n1035.\n; (let ((answer '*))\n1036.\n;\n(begin\n1037.\n;\n(for-each-system!\n1038.\n;\n(lambda (sys)\n1039.\n;\n(if (string=? (system/name sys)\n1040.\n;\n\"Runtime\")\n1041.\n;\n(set! answer (list (system/version sys)\n1042.\n;\n(system/modification sys))))))\n\n1043.\n;\n(if (eq? answer '*)\n1044.\n;\n(error \"SCHEME+ INITIALIZATION ERROR: CAN'T FIND\nSCHEME RUNTIME VERSION\")\n1045.\n;\nanswer))))\n1046.\n(define (runtime-system)\n1047.\n(if (environment-bound? system-global-environment 'get-subsystem-\nversion)\n1048.\n(get-subsystem-version \"Runtime\")\n1049.\n(let ((answer '*))\n1050.\n(begin\na. (for-each-system!\nb. (lambda (sys)\nc. (if (string=? (system/name sys)\n1. \"Runtime\")\nii. (set! answer (list (system/version sys)\na. (system/modification sys))))))\nd. (if (eq? answer '*)\ne. (error \"SCHEME+ INITIALIZATION ERROR: CAN'T FIND SCHEME\nRUNTIME VERSION\")\nf. answer)))))\n1051.\n(define runtime-version first)\n1052.\n(define runtime-modification second)\n1053.\n(define (version-7.1.3?)\n1054.\n(equal? (runtime-system) '(14 104)))\n1055.\n(define (version-7.2?)\n1056.\n;; This is a hack. This also returns #t for 7.3 systems.\n\n1057.\n;; To discriminate for 7.3, explicitly test for it first!\n1058.\n; (or (equal? (runtime-system) '(14 155))\n1059.\n;\n(equal? (runtime-system) '(14 156))\n1060.\n;\n(equal? (runtime-system) '(14 157)))\n1061.\n(and (= (first (runtime-system)) 14)\n1062.\n(>= (second (runtime-system)) 155)))\n1063.\n(define (version-7.3?)\n1064.\n(and (= (first (runtime-system)) 14)\n1065.\n(>= (second (runtime-system)) 166)))\n1066.\n(define (version-error)\n1067.\n(error\n1068.\n(string-append\n1069.\n\"SCHEME-+ VERSION ERROR\\nScheme+ doesn't know how to handle\nruntime \"\n1070.\n(number->string (runtime-version (runtime-system)))\n1071.\n\".\"\n1072.\n(number->string (runtime-modification (runtime-system)))\n1073.\n\"\\nContact 6821@psrg.lcs.mit.edu for help.\")))\n1074.\n(define scheme-runtime/version-7.1.3/install-evaluator!\n1075.\n(let ((repl-env (->environment '(runtime rep))))\n1076.\n(lambda (evaluator) ; evaluator is SEXP x ENV x ST ->\n1077.\n(set! (access hook/repl-eval repl-env)\na. ;; Version 7.1.3 evaluators take an extra first arg\nb. ;; that is ignored.\nc. (lambda (repl sexp env st)\nd. (evaluator sexp env st))))))\n1078.\n(define scheme-runtime/version-7.2/install-evaluator!\n1079.\n(let ((repl-env (->environment '(runtime rep))))\n1080.\n(lambda (evaluator) ; evaluator is SEXP x ENV x ST ->\n1081.\n(set! (access hook/repl-eval repl-env)\na. evaluator))))\n1082.\n(define scheme-runtime/install-evaluator!\n1083.\n(cond\n1084.\n((version-7.3?) scheme-runtime/version-7.1.3/install-evaluator!) ; kludge!\n1085.\n((version-7.1.3?) scheme-runtime/version-7.1.3/install-evaluator!)\n1086.\n((version-7.2?) scheme-runtime/version-7.2/install-evaluator!)\n1087.\n(else (version-error))))\n1088.\n;;; This is written to be independent of version\n1089.\n(define scheme-runtime/install-default-evaluator!\n1090.\n(eval '(lambda () (set! hook/repl-eval default/repl-eval))\n\n1091.\n(->environment '(runtime rep))))\n1092.\n;;; Patch for 7.1.3\n1093.\n(define (scheme-runtime/map proc . lsts)\n1094.\n(define (map proc . lsts)\n1095.\n(cond ((null? lsts) '())\na. ((null? (car lsts)) '())\nb. ((null? (cdr lsts));; only one list to map over\nc. (cons (proc (caar lsts))\ni. (map proc (cdar lsts))))\nd. (else\ne. (cons (apply proc (map car lsts))\ni. (apply map proc (map cdr lsts))))))\n1096.\n(apply map proc lsts))\n1097.\n(if (version-7.1.3?)\n1098.\n(set! map scheme-runtime/map)\n1099.\n'nop)\n1100.\n;;; Environments\n1101.\n(define scheme-runtime/version-7.1.3/install-environment!\n1102.\n(eval '(lambda (env)\na. (let ((repl (nearest-repl))\ni. (environment (->environment env)))\nb. (set-repl-state/environment! (cmdl/state repl) environment)\nc. (if (not (cmdl/parent repl))\ni. (set! user-repl-environment environment))))\n1103.\n(->environment '(runtime rep))))\n1104.\n(define scheme-runtime/version-7.2/install-environment! ge)\n1105.\n(define scheme-runtime/install-environment!\n1106.\n(cond\n1107.\n((version-7.1.3?) scheme-runtime/version-7.1.3/install-environment!)\n1108.\n((version-7.2?) scheme-runtime/version-7.2/install-environment!)\n1109.\n(else (version-error))))\n1110.\n(define (scheme-runtime/fasload-file? pathname)\n1111.\n(let* ((port (open-input-file pathname))\na. (fasl-marker (peek-char port))\nb. (result (and (not (eof-object? fasl-marker))\ni. (= 250 (char->ascii fasl-marker)))))\n1112.\n(begin\n\n1113.\n(close-input-port port)\n1114.\nresult)))\n1115.\n;;; Dump/load\n1116.\n(define scheme-runtime/fasdump fasdump)\n1117.\n(define scheme-runtime/fasload fasload)\n1118.\n;;; Path stuff\n1119.\n(define scheme+/scheme+-ext \"scm\")\n1120.\n(define scheme+/bin-ext \"bin\")\n1121.\n(define scheme+/com-ext \"com\")\n1122.\n;; Get pathname of existing file ending in \".scm\"\n1123.\n(define scheme-runtime/version-7.1.3/scheme+-pathname\n1124.\n(eval `(lambda (filename)\na. (find-true-pathname (->pathname filename)\na. '(,scheme+/scheme+-ext)))\n1125.\n(->environment '(runtime load))))\n1126.\n(define scheme-runtime/version-7.2/scheme+-pathname\n1127.\n(eval `(lambda (filename)\na. (find-pathname filename '(,scheme+/scheme+-ext)))\n1128.\n(->environment '(runtime load))))\n1129.\n(define scheme-runtime/version-7.3/scheme+-pathname\n1130.\n(eval `(lambda (filename)\na. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\nii. ,',load/internal))))\nb. (lambda (pathname loader) pathname)))\n1131.\n(->environment '(runtime load))))\n1132.\n(define scheme-runtime/scheme+-pathname\n1133.\n(cond\n1134.\n((version-7.3?) scheme-runtime/version-7.3/scheme+-pathname)\n1135.\n((version-7.2?) scheme-runtime/version-7.2/scheme+-pathname)\n1136.\n((version-7.1.3?) scheme-runtime/version-7.1.3/scheme+-pathname)\n1137.\n(else (version-error))))\n1138.\n;; Get pathname of existing file ending in either \".bin\" or \".scm\"\n\n1139.\n(define scheme-runtime/version-7.1.3/bin-pathname\n1140.\n(eval `(lambda (filename)\na. (find-true-pathname (->pathname filename)\na. '(,scheme+/bin-ext\nb. ,scheme+/scheme+-ext)))\n1141.\n(->environment '(runtime load))))\n1142.\n(define scheme-runtime/version-7.2/bin-pathname\n1143.\n(eval `(lambda (filename)\na. (find-pathname filename '(,scheme+/bin-ext\na. ,scheme+/scheme+-ext)))\n1144.\n(->environment '(runtime load))))\n1145.\n(define scheme-runtime/version-7.3/bin-pathname\n1146.\n(eval `(lambda (filename)\na. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\nii. ,',load/internal)\niii. (,scheme+/bin-ext\niv. ,',load/internal))))\nb. (lambda (pathname loader) pathname)))\n1147.\n(->environment '(runtime load))))\n1148.\n(define scheme-runtime/bin-pathname\n1149.\n(cond\n1150.\n((version-7.3?) scheme-runtime/version-7.3/bin-pathname)\n1151.\n((version-7.2?) scheme-runtime/version-7.2/bin-pathname)\n1152.\n((Version-7.1.3?) scheme-runtime/version-7.1.3/bin-pathname)\n1153.\n(else (version-error))))\n1154.\n;; Get pathname for existing file ending in \".scm\" and return a pathname\n1155.\n;; for the same file, but ending in \".bin\"\n1156.\n(define scheme-runtime/version-7.1.3/sf-name\n1157.\n(eval `(lambda (filename)\na. (pathname->string\nb. (pathname-new-type\nc. (find-true-pathname (->pathname filename)\na. '(,scheme+/scheme+-ext))\nd. ,scheme+/bin-ext)))\n1158.\n(->environment '(runtime load))))\n1159.\n(define scheme-runtime/version-7.2/sf-name\n1160.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\n\nc. (find-pathname filename\n1. '(,scheme+/scheme+-ext))\nd. ,scheme+/bin-ext)))\n1161.\n(->environment '(runtime load))))\n1162.\n(define scheme-runtime/version-7.3/sf-name\n1163.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\nc. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\nii. ,',load/internal))))\nii. (lambda (pathname loader) pathname))\nd. \"bin\")))\n1164.\n(->environment '(runtime load))))\n1165.\n(define scheme-runtime/sf-name\n1166.\n(cond\n1167.\n((version-7.3?) scheme-runtime/version-7.3/sf-name)\n1168.\n((version-7.2?) scheme-runtime/version-7.2/sf-name)\n1169.\n((version-7.1.3?) scheme-runtime/version-7.1.3/sf-name)\n1170.\n(else (version-error))))\n1171.\n;; Get pathname for existing file ending in \".scm\" or \".bin\" and return a\n1172.\n;; pathname for the same file, but ending in \".com\"\n1173.\n(define scheme-runtime/version-7.1.3/cf-name\n1174.\n(eval `(lambda (filename)\na. (pathname->string\nb. (pathname-new-type\nc. (find-true-pathname (->pathname filename)\na. '(,scheme+/scheme+-ext\nb. ,scheme+/bin-ext))\nd. ,scheme+/com-ext)))\n1175.\n(->environment '(runtime load))))\n1176.\n(define scheme-runtime/version-7.2/cf-name\n1177.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\nc. (find-pathname filename '(,scheme+/scheme+-ext\ni. ,scheme+/bin-ext))\nd. ,scheme+/com-ext)))\n1178.\n(->environment '(runtime load))))\n\n1179.\n(define scheme-runtime/version-7.3/cf-name\n1180.\n(eval `(lambda (filename)\na. (->namestring\nb. (pathname-new-type\nc. (with-values (lambda ()\n1. (find-pathname filename\ni. '((,scheme+/scheme+-ext\nii. ,',load/internal)\niii. (,scheme+/bin-ext\niv. ,',load/internal))))\nii. (lambda (pathname loader) pathname))\nd. ,scheme+/com-ext)))\n1181.\n(->environment '(runtime load))))\n1182.\n(define scheme-runtime/cf-name\n1183.\n(cond\n1184.\n((version-7.3?) scheme-runtime/version-7.3/cf-name)\n1185.\n((version-7.2?) scheme-runtime/version-7.2/cf-name)\n1186.\n((version-7.1.3?) scheme-runtime/version-7.1.3/cf-name)\n1187.\n(else (version-error))))\n1188.\n;; Compile a syntaxed file\n1189.\n(define (scheme-runtime/compile-bin-file . args)\n1190.\n(error \"scheme-runtime/compile-bin-file not currently supported\")\n1191.\n(cond ((version-7.2?)\na. (if (environment-bound? system-global-environment 'compile-bin-file)\nb. compile-bin-file\nc. (lambda (filename)\ni. (display \"Compile not loaded, unable to compile: \")\nii. (display filename)\niii. (newline))))\n1192.\n(else (version-error)))\n1193.\n)\n1194.\n(define (scheme-runtime/file-modification-time file)\n1195.\n;; Return a 0 rather than null if file not present\n1196.\n(let ((t (file-modification-time file)))\n1197.\n(if (null? t) 0 t)))\n1198.\n;;---------------------------------------------------\n1199.\n;; Start up Scheme+\n1200.\n(scheme+)"
    }
  ]
}