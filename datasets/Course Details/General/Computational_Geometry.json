{
  "course_name": "Computational Geometry",
  "course_description": "Topics in surface modeling: b-splines, non-uniform rational b-splines, physically based deformable surfaces, sweeps and generalized cylinders, offsets, blending and filleting surfaces. Non-linear solvers and intersection problems. Solid modeling: constructive solid geometry, boundary representation, non-manifold and mixed-dimension boundary representation models, octrees. Robustness of geometric computations. Interval methods. Finite and boundary element discretization methods for continuum mechanics problems. Scientific visualization. Variational geometry. Tolerances. Inspection methods. Feature representation and recognition. Shape interrogation for design, analysis, and manufacturing. Involves analytical and programming assignments.\nThis course was originally offered in Course 13 (Department of Ocean Engineering) as 13.472J. In 2005, ocean engineering subjects became part of Course 2 (Department of Mechanical Engineering), and this course was renumbered 2.158J.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Algorithms and Data Structures",
    "Graphics and Visualization",
    "Mathematics",
    "Computation",
    "Topology and Geometry",
    "Engineering",
    "Computer Science",
    "Algorithms and Data Structures",
    "Graphics and Visualization",
    "Mathematics",
    "Computation",
    "Topology and Geometry"
  ],
  "syllabus_content": "This course was originally offered in Course 13 (Department of Ocean Engineering) as 13.472J. In 2005, ocean engineering subjects became part of Course 2 (Department of Mechanical Engineering), and this course was renumbered 2.158J.\n\nCourse Meeting Times\n\nLectures: 2 sessions / week, 1.5 hours / session\n\nCourse Prerequisites\n\nPermission of instructor (Subject requires typical undergraduate mathematics, eg. ordinary differential equations, introductory linear algebra and numerical analysis, and a high level programming language.)\n\nCourse Grading (Individual Effort)\n\nPS1 on Differential Geometry: 15%\n\nPS2 on B-splines and NURBS: 25%\n\nPS3 on Blends, GCs and Intersections: 20%\n\nPS4 on Non-Linear Solver and Offsets: 25%\n\nPS5 on Solid Modeling: 15%\n\nRequired Textbook\n\nPatrikalakis, N. M., T. Maekawa, and W. Cho.\nShape Interrogation for Computer Aided Design and Manufacturing\n. New York, NY: Springer Verlag, 2010. ISBN: 978-3642040733. (Available from Springer & ResearchGate:\nprinted\n,\nelectronic\n)\n\nAdditional lecture notes will be handed out in class.",
  "files": [
    {
      "category": "Resource",
      "title": "ps1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/49a351e7c87b6064323044aef7069925_ps1.pdf",
      "content": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY\n13.472J/1.128J/2.158J/16.940J\nComputational Geometry\nSpring Term, 2003\nProblem Set 1 on Differential Geometry\nIssued:Day2\nDue:Day6\nWeight:\n15% of total grade\nIndividual Effort\n1. Show that the curvature of a planar curve is independent of the parametrization. Namely, if\nr(t) = [x(t), y(t)]\n(1)\nis the curve then a change of variables\nt = w(u) with w′(u) = 0\n(2)\ndoes not affect the curvature. (Problem 18 in the textbook)\n2. Let a curve X be defined by\nX(t) = a\n\ng(t) × g′(t)dt,\na = const = 0,\n(3)\nwhere g(t) is a vector function satisfying |g(t)| = 1 and [gg′g′′] = 0. Show that the curvature\nand the torsion of the curve are κ = 0 and τ = 1/a, respectively.\n3. Find the parametric equation of a curve whose curvature κ and torsion τ are respectively\nκ =\na\na2 + b2,\nτ =\nb\na2 + b2,\n(4)\nwhere a > 0 and b are constants.\n4. A curve C1 is called an involute of a given curve C if tangents of C are normal to C1. The\ncurve C is called an evolute of C1. Show that the curvature κ1 of C1 is given by\nκ2\n1 =\nκ2 + τ 2\nκ2(c -s)2,\n(5)\nwhere c is a constant, s is the arc length of C measured from a fixed point on C, and κ and τ\nare the curvature and torsion of C.\n\n5. Let E, F, G be the coefficients of the first fundamental form of a regular surface R = R(u, v).\nLet f(u, v) = c and g(u, v) = d be two families of regular curves defined in the parameter space\nu -v of the surface with images in 3D space obtained for various constants c and d. Prove\nthat the 3D images of these two families of curves are orthogonal (i.e. whenever two curves of\ndistinct families meet, their tangents are orthogonal) if and only if\nEfvgv -F(fugv + fvgu) + Gfugu = 0\n(6)\nwhere E = Ru · Ru, F = Ru · Rv, G = Rv · Rv, and subscripts u, v denote partial derivatives.\n6. Consider a torus parametrized as follows:\nr(u, v) = [(R + a cos u)cos v, (R + a cos u)sin v, a sin u]\n(7)\nwhere 0 ≤u ≤2π, 0 ≤v ≤2π, and R and a are constants such taht R > a. Derive formulae for\nthe Gauss, mean and principal curvatures. Sketch the torus and subdivide it into hyperbolic,\nparabolic and elliptic regions. In a follow-up sketch illustrate the lines of curvature of the torus.\nExplain the above subdivision and sketches. (Problem 17 in the textbook)\n7. Show that the surface area on a Monge patch X(u, v) = ue1 + ve2 + f(u, v)e3 is given by the\nintegral\nA =\n\nW\n\n1 + f 2u + f 2v dudv,\n(8)\nwhere W is the parameter domain, and e1, e2 and e3 the unit coordinate vectors.\n8. Show that the second fundamental form on a Monge patch X(u, v) = ue1 + ve2 + f(u, v)e3 is\nII = (f 2\nu + f 2\nv + 1)-1\n\nfuudu2 + 2fuvdudv + fvvdv2\n,\n(9)\nwhere e1, e2 and e3 are the unit coordinate vectors.\n9. Show that the principal curvatures of the surface f(x, y, z) = x sin(z) -y cos(z) = 0 are\n±(x2 + y2 + 1)-1.\n10. Consider the parametrized surface\nr(u, v) =\n\nu -u3\n3 + uv2, v -v3\n3 + vu2, u2 -v2\n\n.\n(10)\nShow that\n(a) The coefficients of the first fundamental form are\nE = G = (1 + u2 + v2)2, F = 0.\n(11)\n(b) The coefficients of the second fundamental form are\nL = 2, M = -2, N = 0.\n(12)\n(c) The principal curvatures are\nκ1 =\n(1 + u2 + v2)2,\nκ2 = -\n(1 + u2 + v2)2.\n(13)"
    },
    {
      "category": "Resource",
      "title": "ps2.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/41395d35e3a708782edfbb8b6a0974df_ps2.pdf",
      "content": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY\n13.472J/1.128J/2.158J/16.940J\nComputational Geometry\nSpring Term, 2003\nProblem Set 2 on Spline Curves and Surfaces\nIssued:Day5Due:Day12Weight:\n25% of total grade\nIndividual Effort\nThe following problems do not need computer programming.\n1. A cubic planar B ezier curve:\nR(t) =\ni=0\nRiBi,3(t)\n0 ≤t ≤1\n(1)\nhas the following control points\nR0 = [0, 0], R1 = [2, 2], R2 = [3, 2], R3 = [3, 0].\nA designer decides to subdivide (split) the curve at t0 = 1/2 and t1 = 2/3 in order to modify\nthe curve in the interval [t0, t1] and generate a particular shape feature required by his design.\n(a) Compute the coordinates of the control points of the three curve segments generated by\nthe above subdivision.\n(b) After the above subdivision, the middle segment of the three curve segments created by\nsubdivision is permitted to be modified by changing the coordinates of its control points.\nDetermine the conditions that the control points must obey so that this curve segment\nmaintains position continuity at its ends with the end and the beginning of the other two\ncurve segments.\n(c) Assuming position continuity is maintained as in (b), determine the additional necessary\nconditions to maintain unit tangent vector continuity at the ends of the middle curve\nsegment.\n(d) Assuming conditions (b) and (c) are satisfied, determine the coordinates of the vertices\nof the polygonal boundary of the convex hull of the middle curve segment. You need to\ndistinguish several special cases.\n2. Derive the Ferguson (or monomial or power basis), the Hermite-Coons, and the Lagrange forms\nof curve R(t) of problem 1 prior to any subdivision. For the Lagrange form use interpolation\nat the nodes τi = i/3, for i = 0, 1, 2, 3.\n\n3. Derive the (uniform) B-spline form of curve R(t) of problem 1 prior to any subdivision. Make a\nrough plot of the curve (by hand) together with its B ezier and B-spline polygon illustrating the\nprincipal features of the curve (such as tangencies at the ends etc.). Compare the convex hulls\nof the curve in the B ezier and the B-spline form in terms of the area they enclose (i.e. determine\nthe ratio of the two areas). Note: Transformation of a cubic curve from the B ezier to the B-\nspline form allows the user to easily attach additional cubic curve spans with second order\nderivative continuity without explicit use of the constraints of composite B ezier curves.\n4. Show that the derivative of a Be zier curve (also called hodograph ) of the form:\nR(t) =\nn\ni=0\nRiBi,n(t)\n0 ≤t ≤1\n(2)\nis given by:\nR′(t) =\nn-1\ni=0\nn(Ri+1 -Ri)Bi,n-1(t)\n0 ≤t ≤1\n(3)\nSketch a cubic Be zier curve and its hodograph and their control polygons.\n5. A cusp on a parametric curve R(t) occurs at t = t0 when R′(t0) = 0. Can a non-planar cubic\nBe zier curve have a cusp? Give an example of a cubic Be zier curve with a cusp and identify\nthe cusp.\n6. Show how an explicit polynomial curve y = y(x), where a ≤x ≤b can be converted into a\nBe zier curve. Provide the control points of the resulting B ezier curve. Apply this to the case\ny(x) = 1 + x + x2 + x3, a = 0, b = 2, (also using reparametrization t = x/2 to make the interval\n[0, 1]).\n7. Given a B-spline curve with a non-uniform knot vector, the control polygon of which is sym-\nmetric with respect to the y-axis, find if the curve is also symmetric about the y-axis.\nπ\n8. Express the paraboloid r(φ, t) = (t cos φ, t sin φ, t2), where 0 ≤φ ≤2, 0 ≤t ≤1 in terms of a\nrational Be zier surface.\nThe following problems need computer programming.\n9. Make plots of the B-spline basis functions of the following order n (degree = n -1) and knot\nvector T:\n- n = 4,\nT = [0, 0, 0, 0, 1, 1, 1, 1]\n\n- n = 4,\nT = [0, 0, 0, 0, 2, 4, 4, 4, 4]\n- n = 4,\nT = [0, 0, 0, 0, 3, 3, 6, 6, 6, 6]\n- n = 4,\nT = [0, 0, 0, 0, 2, 2, 2, 6, 6, 6, 6]\n- n = 4,\nT = [0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 7, 7, 7]\n- n = 3,\nT = [0, 0, 0, 3, 6, 9, 9, 9]\n- n = 2,\nT = [0, 0, 2, 4, 4]\nYou may use MATLAB or Tecplot on Athena (or OpenGL or another package) for your plots.\n10. Given a list of Cartesian points in 3-D space which represent a non-periodic curve, construct\na cubic Be zier curve using least squares approximation of the points using Numerical Recipes\nroutines. Also, construct a cubic B-spline curve with non-uniform knots using least squares\napproximation of these points using Numerical Recipes routines. A user should be able to\naccess your program with an arbitrary number of points and coordinates of points. Include a\nsimple visualization of the results as in problem 9."
    },
    {
      "category": "Resource",
      "title": "ps3.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/0006f0f34eb20e67e3e2a2df887eb53b_ps3.pdf",
      "content": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY\n13.472J/1.128J/2.158J/16.940J\nComputational Geometry\nSpring Term, 2003\nProblem Set 3 on Blends, GCs and Intersections\nIssued:Day12Due:Day16Weight:\n20% of total grade\nIndividual Effort\nProblem 1: Blending Surfaces\nAn active area of research is in creating blending surfaces -- smooth joins between two objects. As\nan example we will consider developing a blending surface between the plane z = 0 and the right\ncircular cylinder x2 + y2 = 1, 0 ≤z ≤2. Because the cylinder is a surface of revolution, we will, for\nsimplicity, consider the cross-section of the objects obtained by setting y = 0 as shown in the figure\nbelow. Our problem is to develop a smooth surface between the cylinder and the plane by creating\na cross-section curve starting at height 1 on the cylinder and terminating on the plane 2 units away\nfrom the origin.\na. As a first effort, consider using a quadratic Bezier curve (i.e. a parabola) as a blend cross-section.\nThe curve should have the starting and ending points indicated on the diagram, and to ensure a\nsmooth blend, the tangent to the curve at the start (end) point should have the same direction\nas the tangent to the cylinder (plane). Give the control points of this curve.\nb. Using the results of part a, express the blending surface (i.e. the surface of revolution charac-\nterized by the cross section obtained in a) as rational B-spline (NURBS) surface.\nc. Now suppose we want a cubic Bezier curve as the cross-section of our blending surface. Give\nthe control points of a cubic Bezier curve which generates a \"good\" blend. To be \"good\", the\ncurve not only has to satisfy the boundary conditions indicated in part a, but also the area\nunder the curve on one side of the cylinder should be between 0.2 and 0.3.\nd. Now suppose we want to maintain curvature continuity at the blending surface linkage curves in\naddition to position and tangent plane continuity. Determine a sufficiently high degree Bezier\ncurve cross section to accomplish this. Among the possible options, choose the curve with the\nminimum degree possible to accomplish the above.\n\nZ\nX\nFigure 1: Blends\nProblem 2: Intersection of an Algebraic surface with a Parametric Curve\na. Give the implicit polynomial equation of a torus whose section circle has radius 2, and whose\ncenter circle has radius 4. Assume the torus is situated so that it is centered at the origin and\nthe center circle lies on the (x, y)-plane.\nb. Using the implicit equation in a, compute all intersections of the torus with the cubic B ezier\ncurve having control points r0 = (0, 6, 0), r1 = (-5, 2, -0.5), r2 = (2, -3, 0.5), r3 = (6, 0, 0).\nGive both the Cartesian coordinates of the intersection points and their associated parameter\nvalues on the B ezier curve. Indicate which method you used to solve this problem, and give all\nanswers to at least 5 significant digits.\n(You may use Maple or another symbolic manipulation program to do the substitution and\nsolution.)\nProblem 3: Planar curve intersections\nConsider the following curves:\na. An implicit planar algebraic curve:\nf(u, v) = -\n64v4 + 128v3 -96u2v2 + 140uv2 -139v2 + 96u2v -140uv + 75v\n-\n96u4 + 276u3 -313u2 + 165u -36 = 0\nand\nb. A (parametric) planar B ezier curve (in the same u -v plane as the above implicit curve)\nr(t) = [u(t), v(t)] =\nriBi,3(t)\ni=0\nwhere Bi,3 denotes the ith cubic Bernstein polynomial and r0 = (0.5, 0.5), r1 = (0.7, 0.6), r2 =\n(0.95, 0.1), r3 = (0.55, 0.25).\n\na. Compute all turning and singular points of f(u, v) to the highest possible accuracy, as well as\nthe tangent lines at all these points.\nb. Using the results of a as a guide, sketch f(u, v). Clearly indicate the turning and singular points\non your sketch.\nc. Using the results of a and an ODE solver (eg. from Matlab) construct an accurate polygonal\napproximation of f(u, v) = 0 that exactly interpolates the points found in a, plot the results,\nand provide the corresponding polygonal curve vertices in a file (send to the TA) and a printout.\nYou may use the ODE system resulting from df = fudu + fvdv = 0, i.e. u = -fv, v = fu.\nd. Compute the intersections of the two curves given above to the highest possible accuracy. In ad-\ndition to giving the Cartesian coordinates of the intersection points, also include the parameter\nvalues of the points on the B ezier curve and their multiplicity.\n(You may use Maple or another symbolic manipulation program to do the substitution and\nsolution.)"
    },
    {
      "category": "Resource",
      "title": "ps4.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/99f6986087aedf3fd7e2b85fa992aeb0_ps4.pdf",
      "content": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY\n13.472J/1.128J/2.158J/16.940J\nComputational Geometry\nSpring Term, 2003\nProblem Set 4 on Non-Linear Solver and Offsets\nIssued:Day15Due:Day19Weight:\n25% of total grade\nIndividual Effort\nProblem 1: Planar parametric curve intersections (15% of total grade)\nWrite a program which determines all intersections of two integral planar cubic B ezier curves as\naccurately as possible, given the control points of the two curves as input and the desired accuracy in\nparametric and Cartesian space. Your program should report the parametric values of all intersection\npoints as well as the corresponding Cartesian coordinates. Give three examples to show that your\nprogram works accurately. Your examples should include several transversal and near \"tangent\"\nintersections (carefully constructed). Transversal intersections are intersections at which the curves\nmeet with their tangents at those points having an angle considerably different from zero.\nThe\nimplementation language can be C or C++ or any other language you are comfortable with.\nHint : A good approach involves binary subdivision using the de Casteljau algorithm and bounding\nbox. In addition to bounding box comparisons, you may also consider using the concept of hodograph\nof a planar B ezier curve. If the angular sectors of the hodographs of the two B ezier curves (translated\nso they have the same apex) do not intersect, then the two curves intersect in at most one point.\nThis criterion can be used to distinguish single transversal intersections from other more complex\ncases.\nProblem 2: Offsets of Curves (5% of total grade)\nLet r(s) be a planar, closed and convex curve ( e.g. a circle, an ellipse, etc.) where the arc length s\nvaries in the range [0, l] so that the length of the curve is l. Let\nˆr(s) = r(s) + dn(s)\nbe another curve, where d is a positive distance and n(s) is the unit normal vector of the curve r(s)\ndefined by n = t × ez. ˆr is called the interior normal offset at distance d.\na.\nShow that the total length of the curve ˆr(s) exceeds the total length of the curve r(s) by 2πd.\nb.\nShow that the area enclosed between the two curves is given by\nA = d(l + πd)\n\nc.\nShow that the curvatures of the two curves are related by\nκ\nˆκ = 1 + dκ\nwhere κ is the curvature of r(s) and ˆ\nr(s).\nκ is the curvature of the offset curve ˆ\nd.\nVerify your results for questions a to c for a circle of radius R.\nProblem 3: Regularity of Offsets of Planar Curves (5% of total grade)\nThis problem focuses on the identification of cusps, extraordinary points and self-intersections of\noffsets of planar curves. Consider the ellipse x2 + 4y2 = 1 or x = cosθ, y = 2sinθ and its offset at\n\"distance\" d, where d is any real number.\na. Determine all the values of θ for which there can be an extraordinary point on some offset of the\nellipse and the values of d at such points. Sketch the offsets at all such values of d.\nb. For what range of values of d, are offsets of the ellipse regular curves? Sketch a few such offset\ncurves.\nc. Determine a specific offset of the ellipse which includes several cusps and self-intersections but\nno extraordinary points. Infinite such cases exist. Give the parameter values and coordinates\nof these cusps and self-intersections.\n(Hint : Note that self-intersections are on the axes of symmetry of the ellipse.)\nProblem 4: Offsets of Surfaces [OPTIONAL, 5% EXTRA CREDIT]\nGiven a progenitor surface r = (u, v, -1.75u2 + 2v2), which is a hyperbolic paraboloid.\nˆ\na. Find the unit normal vector n of the offset surface for offset distance d in terms of n, the unit\nnormal vector of r.\nb.\nExplain when ˆn switches sign at (0, 0, 0).\nc. Assuming d > 0, what is the critical offset distance knowing that both principal curvatures have\nextrema at (0, 0, 0)?\nd. When the offset distance is larger than the critical offset distance, a self-intersection occurs.\nObtain the equations for the self-intersection curve.\n(Hint : See Chapter 11 of book.)"
    },
    {
      "category": "Resource",
      "title": "ps5.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/df6ad36fd3f74455b75341023a441e8f_ps5.pdf",
      "content": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY\n13.472J/1.128J/2.158J/16.940J\nComputational Geometry\nSpring Term, 2003\nProblem Set 5 on Solid Modeling\nIssued:Day18Due:Day23Weight:\n15% of total grade\nIndividual Effort\nProblem 1. Can this incidence graph be a valid two-manifold solid's boundary? If yes, sketch a\n3-D figure satisfying the incidence graph, otherwise explain. Below, Fi are planar faces, ej are edges,\nand Vk are vertices.\nF1\nF2\nF3\nF4\ne1\ne2\ne3\ne4\ne5\ne6\nV1\nV2\nV3\nV4\nProblem 2. Can this incidence graph be a valid two-manifold solid's boundary? If yes, sketch a\n3-D figure satisfying the incidence graph, otherwise explain. Below, Fi are planar faces, ej are edges,\nand Vk are vertices.\nF1\nF2\nF3\nF4\ne1\ne2\ne3\ne4\ne5\ne6\nV1\nV2\nV3\nV4\nF5\ne7\ne8\nV5\n\nProblem 3. Given a cube, which has one solid volume, six faces, twelve edges, and eight vertices,\nplease develop a procedure, using Euler operators, to subdivide it so that each subdivided 3-D solid\nis a tetrahedron and every tetrahedron is connected to one point. Draw a figure that demonstrates\nyour result.\nProblem 4. Verify the fact that a complete binary tree with depth k has 2k+1 -1 nodes. How many\nnodes are there in a complete quadtree and a complete octree?\nProblem 5. Show that for the octree representation of a homogeneous object, the storage require-\nments are a function of the surface area of boundary, rather than volume."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes1_fixed.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/d64e5ea96af50644936365c71c26eeeb_lecnotes1_fixed.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 1\nNicholas M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nc\nCopyright 2003 Massachusetts Institute of Technology\nContents\n1 Introduction and classification of geometric modeling forms\n1.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2 Geometric modeling forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.1\nWireframe modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.2\nSurface modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.3\nSolid modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.4\nNon-two-manifold modeling . . . . . . . . . . . . . . . . . . . . . . . . .\n1.3 Basic classification of solid modeling methods . . . . . . . . . . . . . . . . . . .\n1.3.1\nDecomposition models . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.3.2\nConstructive solid geometry (CSG) . . . . . . . . . . . . . . . . . . . . .\n1.3.3\nBoundary representation (B-Rep) . . . . . . . . . . . . . . . . . . . . . .\n1.4 Alternate classification of geometric modeling forms . . . . . . . . . . . . . . .\n1.4.1\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.4.2\nUnevaluated representation systems . . . . . . . . . . . . . . . . . . . .\n1.4.3\nEvaluated representation systems . . . . . . . . . . . . . . . . . . . . . .\nBibliography\n\nLecture 1\nIntroduction and classification of\ngeometric modeling forms\n1.1\nMotivation\nGeometric modeling deals with the mathematical representation of curves, surfaces, and solids\nnecessary in the definition of complex physical or engineering objects. The associated field of\ncomputational geometry is concerned with the development, analysis, and computer implemen\ntation of algorithms encountered in geometric modeling. The objects we are concerned with in\nengineering range from the simple mechanical parts (machine elements) to complex sculptured\nobjects such as ships, automobiles, airplanes, turbine and propeller blades, etc. Similarly, for\nthe description of the physical environment we need to represent objects such as the ocean\nbottom as well as three-dimensional scalar or vector physical properties, such as salinity, tem\nperature, velocities, chemical concentrations (possibly as a function of time as well).\nSculptured objects play a key role in engineering because the shape of such objects (e.g.\nfor aircraft, ships and underwater vehicles) is designed in order to reduce drag or increase the\nthrust (eg. for propeller blades). At the same time these objects need to satisfy other design\nconstraints to permit them to fulfill certain design requirements (e.g. carry a certain payload,\nbe stable in perturbations, etc). Similarly, there are objects which have significant aesthetic\nrequirements, eg. cars, yachts, consumer products.\nTypically, engineers deal with the definition of complex shapes such as engines, automobiles,\naircraft, ships, submarines, underwater robots, offshore platforms, etc. The shape of these\nobjects is usually not fully known in advance (except when a baseline design is available).\nConsequently, the usual design procedure is iterative, involving:\n- Shape creation based on certain design requirements;\n- Analysis to evaluate the performance of the object; and,\n- Shape modification to improve the shape, followed by analysis (and so on in an iterative\nloop) until a satisfactory (and in simple cases, an optimal) design is reached, which\nsatisfies all the design requirements and minimizes a certain cost function.\nGeometric modeling attempts to provide a complete, flexible, and unambiguous represen\ntation of the object, so that the shape of the object can be:\n\n- Easily visualized (rendered)\n- Easily modified (manipulated)\n- Increased in complexity\n- Converted to a model that can be analyzed computationally\n- Manufactured and tested\nComputer graphics is an important tool in this process as visualization and visual inspection\nof the object are fundamental parts of the design iteration. Computer graphics and geometric\nmodeling have evolved into closely linked fields within the last 30 years, especially after the in\ntroduction of high-resolution graphics workstations, which are now pervasive in the engineering\nenvironment.\nThe remainder of this lecture introduces many of the different approaches to geometric\nmodeling representations that have evolved over the last four decades.\n1.2\nGeometric modeling forms\nSeveral different geometric modeling forms have evolved over the last forty years. For the\ndefinition of model, we can say that an abstract entity M is a model of an object O if M can\nbe used to answer specific questions about O.\nDifferent forms of geometric modeling can be distinguished based on exactly what is being\nrepresented, the amount and type of information directly available without derivation, and\nwhat other information can and cannot be derived.\n1.2.1\nWireframe modeling\nFigure 1.1: Wire frame model of a cube.\nWireframe modeling, developed in the early 1960's, is one of the earliest geometric modeling\ntechniques. It represents objects by edge curves and vertices on the surface of the object,\nincluding the geometric equations of these entities (and also possibly but not always adjacency\ninformation), as shown in Figure 1.1. The traditional drawings of a ship's lines (Figure 1.2 [4])\nis a form of a wireframe model of a ship hull. It is created by intersecting the hull surface with\nthree sets of orthogonal planes. Usually the hull surface is taken as the molded hull surface\nwhich is the inner side of the hull plating. Intersections of the hull surface with vertical planes\n(from bow to stern) are called buttock lines. Intersections of the hull surface with horizontal\n\nplanes (parallel to keel) are the waterlines, while intersections with transverse vertical planes\nare called sections. Wireframes are rather incomplete and possibly ambiguous representations\nthat were superseded by surface models.\n1.2.2\nSurface modeling\nSurface modeling techniques, developed in the late 1960's, go one step further than wireframe\nrepresentations by also providing mathematical descriptions of the shape of the surfaces of\nobjects, as shown in Figure 1.3.\nSurface modeling techniques allow graphic display and numerical control machining of care-\nfully constructed models, but usually offer few integrity checking features (e.g. closed volumes).\nThe surfaces are not necessarily properly connected and there is no explicit connectivity infor\nmation stored. These techniques are still used in areas where only the visual display is required,\ne.g. flight simulators.\n1.2.3\nSolid modeling\nSolid modeling, first introduced in the early 1970's, explicitly or implicitly contains information\nabout the closure and connectivity of the volumes of solid shapes. Solid modeling offers a\nnumber of advantages over previous wireframe and surface modeling techniques. In principle,\nit guarantees closed and bounded objects and provides a fairly complete description of an object\nmodelled as a rigid solid in 3D space [7, 6, 8].\nFigure 1.4 illustrates that for a boundary based solid model of a single homogeneous object,\nevery surface boundary is always directly adjacent to one other surface boundary, guaranteeing\na closed volume. Solid models, unlike surface models, enable a modeling system to distinguish\nthe outside of a volume from the inside. This capability, in turn, allows integral property\nanalysis for the determination of volume, center of volume or gravity, moments of inertia, etc.\nAn example is Baumgart's winged edge data structure [1, 2], where every edge has a start\nand end point, a face on either side, and at least two edges from each vertex bounding the\nfaces. This information can be put in tabular form (perhaps using a relational database) or in\na graph like data structure and used to ensure adjacency.\nTypical solid modeling systems also offer tools for the creation and manipulation of complete\nsolid shapes, while maintaining the integrity of the representations.\nSolid modeling techniques exclude the two previous modeling forms (wireframe and surface\nmodeling). The reason is that the solid modeling forms are traditionally constrained to work\nonly with two-manifold solids.\nIn a two-manifold solid representation, every point on the surface has a neighborhood on\nthe surface which is topologically equivalent to a two-dimensional disk. In other words, even\nthough the surface exists in three dimensional space, it is topologically flat when the surface is\nexamined closely in a small enough area around any given point, as illustrated by the cube in\nFigure 1.5.\n1.2.4\nNon-two-manifold modeling\nNon-two-manifold modeling [1, 9, 5, 10] is a new modeling form which removes constraints\nassociated with two-manifold solid modeling forms by embodying all of the capabilities of\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.2: Wire frame model of a ship hull.\n\nFigure 1.3: Surface model of a cube.\nFigure 1.4: Solid model of a cube.\nthe previous three modeling forms in a unified representation. The following diagrams (in\nFigure 1.6) demonstrate non-two-manifold situations.\nIn an environment which allows non-two manifold situations, the surface area around a\ngiven point on a surface might not be flat in the sense that the neighborhood of the point\nneed not be equivalent to a simple two-dimensional disk. This allows topological conditions\nsuch as a cone touching another surface at a single point, more than two faces meeting along\na common edge, and wire edges emanating from a point on a surface. A non-two-manifold\nrepresentation therefore allows a general wire frame mesh with surfaces and enclosed volumes\nembedded in space. Overall, non-two-manifold representations have superior flexibility, can\nrepresent a larger variety of objects, and can support a wider variety of applications than\ntwo-manifold representations, but at a cost of a larger size and more complex data structure.\nApplications of the non-two-manifold representation include:\n- Distinguish between two different solids, such as a beam welded to a plate (Figure 1.7).\n- Represent a solid volume with a cutout and the volume that was cut out (Figure 1.8).\n- Distinguish between the components of a composite plate (Figure 1.9).\n- Represent a finite element mesh embedded in a solid object (Figure 1.10).\n- Represent different dimensions simultaneously, such as a volume with a cut plane and an\naxis of revolution (Figure 1.11).\n\n(\nP2\nP1\nFigure 1.5: The cube is a two manifold object.\n1.3\nBasic classification of solid modeling methods\nCurrent computer-aided design and manufacturing (CAD/CAM) systems used for solid object\nrepresentation are generally based on three different types of modeling methods:\n1. Decomposition models that represent solids in terms of a subdivision of space. - p.7\n2. Constructive models that represent solids by Boolean (set) operations on primitive solids\nsuch as rectangular boxes, cylinders, spheres, cones, torii (appropriately sized, positioned\nand oriented). - p.14\n3. Boundary models that represent solids in terms of their bounding faces, which are them-\nselves bounded by edges and the edges by vertices. - p.16\nA more detailed description of these models follows.\n1.3.1\nDecomposition models\nExhaustive enumeration\nExhaustive enumeration is a representation by means of cubes of uniform size, orientation, and\nwhich are nonoverlapping, see Figure 1.12. An object is represented by a three dimensional\nBoolean array. Each cell represents a cubic volume of space. If a cell intersects with the\nregion of interest it has a true value. Otherwise, the value is false. This can be pictured as\na box divided into 3D cubical pixels, with 0 assigned if empty and 1 assigned if full. This\nrepresentation involves:\n- Regular subdivision of space.\n- It stores just one corner of each cube.\n- For fixed space of interest we need just a 3-D array, Cijk of binary data, and overall\nbox/space coordinates:\n1 if the cube i, j, k intersects the solid\nCijk =\n0 if the cube i, j, k is empty\n(1.1)\n\ncommon edge\nface\nFigure 1.6: Examples of non-two manifold models.\n\nbeam\nplate\nFigure 1.7: Beam welded to a plate.\ncutout\nblock\nFigure 1.8: Block with cutout.\nApplications of exhaustive enumeration methods include:\n- Underwater environment representation.\n- Finite elements meshing (first step in an algorithm to build such a mesh).\n- Medical 3D data representation.\n- Preprocessing representation for speeding up operations on other representations (eg.\napproximating integral properties such as volume, center of gravity, moments of inertia,\ndistance transforms).\nProperties of exhaustive enumeration methods include:\nA\ncomposite plate\nB\nC\nFigure 1.9: Composite plate.\n\nFigure 1.10: Finite element mesh.\ncenter line\ncenter line\ncutting plane\nsolid volume\nFigure 1.11: Representation of dimensions.\nFigure 1.12: Exhaustive enumeration.\n\nfull\nempty\npartially full\nFigure 1.13: Quadtree representation.\n- Expressive power: approximation scheme.\n- Unambiguous and unique for fixed space and resolution. There do not exist different\nrepresentations for the same object.\n- Memory intensive: eg. 2563 → 16M bits and this is a bare minimum.\n- Closure1 of operations (eg. Booleans).\n- Computational ease for algorithms: VLSI implementation for volume rendering. However,\nfor high resolution the algorithm slows down.\nBoundary cell enumeration\nThis is a boundary based version of the above technique. Only the cells that intersect region\nboundaries have true values.\nSpace subdivision\nSome of the motivations behind space subdivision methods include:\n- Smaller memory requirements if adaptive subdivision is used;\n- Octree/quadtree representations lead to a recursive subdivision into 8 octants (or 4 quad-\nrants) that can be represented as an 8-ary tree (or 4-ary tree).\nIn an octree representation a solid region is represented by hierarchically decomposing a\nusually cubic volume of space into successively smaller cubes (8 of them). Hierarchical division\nand cube orientation usually follows the spatial coordinate system. An example of quadtree,\nthe two dimensional analogue, is shown Figure 1.13.\n1 Closure means that an operation such as Boolean results in an object of the same topological type that can\nbe represented by the same type of data structure.\n\nThis is a trivial example. The method can continue to many more levels for a much more\ncomplex model. Some tolerance for minimum size blocks is required. In addition, this very\nconcise representation would become very large if the coordinate system was changed; for\nexample, rotated 45 degrees.\nThis method leads to a quick way to compute the area and other integral properties of a\nregion. It is often used in data analysis in fields such as medical applications and sonar imaging.\nTo create an octree, we apply a classification procedure to a given solid (represented in\nBoundary Representation, Constructive Solid Geometry, Exhaustive Enumeration, etc.) and\ndecide if a given node of the octree is:\n- Exterior to solid (white);\n- Interior to solid (black);\n- Partially interior to solid (grey).\nThe classification procedure is used recursively. It could be based on Boolean solid opera\ntions, especially intersection. Figure 1.14 provides an example of octree representation.\nFigure 1.14: An octree model.\nSome of the properties of octrees include:\n- Expressive power: they are an approximation scheme;\n- Validity: if no special connectivity is required, all octrees are valid;\n\n- Unambiguous and unique: for a fixed resolution there is only one compacted2 octree;\n- Memory: not as large as Exhaustive Enumerations, yet much larger than Boundary\nRepresentation and Constructive Solid Geometry models;\n- Closure of operations: for example Boolean operations and transformations;\n- Computational ease: somewhat more complex than exhaustive enumeration.\nCell decompositions\nThe motivation for cell decomposition methods is:\n- Use of elements other than cubes, see Figure 1.15 for an example.\n- Application: finite element method, scientific visualization.\n- Cells are parametrized instances of a generic cell type, eg. a cell bounded by quadratic\ncurves and surfaces.\n- Cells are homeomorphic to spheres.\n- Cells meet at a vertex, edge, face otherwise the representation is invalid.\n- Cells are disjoint and non-overlapping.\n- Cells may belong to different cell types, eg. box-like, tetrahedra-like, etc.\nFigure 1.15: A cell decomposition (finite element mesh).\nA cell decomposition can be represented using the cell-tuple data structure [3]. See Figure\n1.16 for a 2D example.\nThe properties of cell decomposition methods are:\n- Expressive power: very general and accurate;\n2 Algorithms such as set operations can create octrees with unnecessary nodes (eg. an internal nodes whose\nchildren are all black). Such nodes can be removed with a relatively simple tree traversal algorithm.\n\nFigure 1.16: Cell data structure.\n- Validity: requires an intersection test for verification;\n- Unambiguous representation;\n- Nonunique: Similar to the Constructive Solid Geometry method we will see below, the\nsame object can be represented at different resolutions or with different types of mesh\n(eg. hexahedral, tetrahedral, etc.);\n- Generation: by conversion from other representations;\n- Concise: memory utilization is less than octrees, yet more than Boundary Representation;\n- Applicability: finite element meshing, multimaterial non-homogeneous objects, visualiza\ntion of fields, etc.\n1.3.2\nConstructive solid geometry (CSG)\nConstructive Solid Geometry (CSG) is the Boolean combination of primitive volumes that\ninclude the surface and the interior. For example, primitives including rectangular box, sphere,\ncylinder, cone and torus can be combined using intersection, union and difference operators to\nform complex solids. Positioning operators (position, orientation) and size operators are applied\nto the primitives before the Boolean operators are invoked, see Figure 1.17 for an example.\nTerminal nodes on the binary tree are primitive volumes; other nodes are Boolean operators.\nThis representation has a direct manufacturing analogue, where difference indicates drilling or\nmachining and union indicates for example welding.\nAnother example of a related representation is sweeps, where more general primitives are\nobtained by sweeping a solid along a space curve or sweeping a planar curve through a revolution\n\n(U)\n(-)\nP(sphere)\nP(box)\nP(cylinder)\nFigure 1.17: Boolean operations and primitives.\n\nabout an axis in its plane. Sweeps are useful in the representation of blends, volumes swept by\nmachine tools, and in robotics.\nIn a survey of machine elements, 90 to 95% of parts could be represented accurately using\nthe CSG method with the above simple primitive solids.\n1.3.3\nBoundary representation (B-Rep)\nObjects are represented in terms of their boundary elements (e.g. vertices, edges, faces) which\nare related through adjacency. ++ This is the most generally used representation today due to its\nflexibility. In these notes, we develop the theory of curves and surfaces which form the edges\nand faces of B-Rep models.\nFigures 1.18 and 1.19 show an example of a tetrahedron and its B-Rep model.\nV1\nf2\nV4\nV3\ne1\ne2\ne3\ne5\ne6\ne4\nf4\nf3\nf2\nV2\nV4\nV1\nV2\ne1\ne3\ne2\nf3\nf4\ne4\ne5\ne6\nV3\nTop View\nf1\nFigure 1.18: A tetrahedron\n++Two boundary elements, which are bounded by next lower dimension boundary elements, are called adjacent,\nif they share one common next lower dimension boundary element. For instance, two surfaces having a common\nedge are adjacent, or two edges having a common vertex are adjacent.\n\nObject definition (region)\nBoundary definition\nFaces:\nf1\nf2\nf3\nf4\nLoops:\nEdges:\nVertices:\nTopological Information\nL1\nL2\nL3\nL4\ne1\ne2\ne3\ne4\ne5\ne6\nV1\nV2\nV3\nV4\nVertex assignment\n(x1,y1,z1)\n(x2,y2,z2)\n(x3,y3,z3)\n(x4,y4,z4)\n(Geometry)\nFigure 1.19: Boundary representation model for a tetrahedron\n\n1.4\nAlternate classification of geometric modeling forms\n1.4.1\nIntroduction\nThe wide variety of representation techniques developed (many of which were identified above)\ncan be differentiated on the basis of at least three independent criteria concerning the repre\nsentation:\n- boundary based or volume based\n- object based or spatially based\n- evaluated or unevaluated in form\nA representation is boundary based if the solid volume is specified by its surface boundary.\nIf the solid is specified directly by its volume it is volume based.\nA representation is object based if it is fundamentally organized according to the charac\nteristics of the actual geometric shape itself. It is spatially based when the representation is\norganized around the characteristics of the spatial coordinate system it uses.\nEvaluated or unevaluated characterization is roughly a measure of the amount of work\nnecessary to obtain information about the objects being represented with respect to a specific\ngoal.\nWhat is best depends on the application! A good system should support multiple repre\nsentational techniques to ensure their efficiency over a broad range of applications.\nWe have three different criteria with two choices, so eight categories result. The following\nTable 1.1 gives examples in each category:\nUnevaluated Class\nboundary based\nvolume based\nspatial based\nHalf Space\nOctree\nobject based\nEuler Operators\nCSG\nEvaluated Class\nboundary based\nvolume based\nspatial based\nBoundary Cell Enumeration\nCell Enumeration\nobject based\nBoundary Representation\nNon-parametric Primitives\nTable 1.1: Classification of geometric modeling forms\n1.4.2\nUnevaluated representation systems\nUnevaluated representation systems require some form of procedural interpretation to be used\nwith respect to the specified application.\n\nSpatial, boundary based: half space technique A solid is represented by successively\ndividing space in half with usually infinite surface descriptions and selecting the half space on\na specified side of the surface, eventually enclosing the solid region. The intersection of the half\nspaces represents the solid. Only convex regions can thus be described unless unions are also\nemployed. Figure 1.20 demonstrates the half space technique in a two dimensional format.\nFigure 1.20: Half space technique of model representation.\nThis technique is classified as spatial based because the surface descriptions are positioned\nin spatial coordinate space rather than being relative to the object.\nSpatial, volume based: octree representation A solid region is represented by hierarchi\ncally decomposing a usually cubic volume of space into successively smaller cubes (8 of them).\nHierarchical division and cube orientation usually follows the spatial coordinate system.\nObject, boundary based: Euler operators The object is procedurally described as a\nsequence of \"Euler Operators,\" as in Figure 1.21. An (amorphous) topological sphere is topo\nlogically modified using the Euler Operators such as:\n- msv = make shell, vertex\n- mev = make edge, vertex\n- mef = make edge, face\nv1\nv2\nv3\nv4\nf1\ne1\ne2\ne3\ne4\nf2\nFigure 1.21: Boundary based representation Using Euler operations.\n\nThese operators ensure that Euler's Formula is always satisfied:\nV - E + F - Li = 2(S - G)\nwhere:\n- V = number of vertices\n- E = number of edges\n- F = number of faces\n- Li = number of internal loops\n- S = number of surfaces (shells)\n- G = genus (number of handles or through holes)\nObject, volume based: constructive solid geometry (CSG) Constructive Solid Geom\netry (CSG) is the Boolean combination of primitive volumes that include the surface and the\ninterior. For example, a box, sphere, cylinder, torus and cone can be combined using intersec\ntion, union and difference operators to form many surfaces. In addition, positioning operators\nsuch as position, orientation and size are applied to the primitives before the Boolean operators\nare applied.\nAnother example of an object, volume based representation is sweeps, where more general\nprimitives are obtained by sweeping a solid along a space curve or sweeping a planar curve\nthrough a revolution.\n1.4.3\nEvaluated representation systems\nEvaluated representation systems usually require substantially less computation to be useful in\nspecific applications.\nSpatial, volume based: cell enumeration An object is represented by a three dimensional\nBoolean array. Each cell represents a cubic volume of space. If a cell intersects with the region\nof interest it has a true value. Otherwise, the value is false. This can be pictured as a box\ndivided into pixels, with 0 assigned if empty and 1 assigned if full.\nSpatial, boundary based: boundary cell enumeration This is a boundary based version\nof the above technique. Only the cells which intersect region boundaries have true values.\nObject, Boundary Based: Boundary Representation (b-rep) Objects are represented\nin terms of their boundary elements (e.g. vertices, edges, faces) which are related through\nincidence and adjacency. This is the most generally used representation today, and will be\ndiscussed in detail in further lectures.\nObject, volume based: non-parametric primitives Simple fixed position objects. This\nis not a particularly flexible representation.\n\nBibliography\n[1] L. Bardis and N. M. Patrikalakis. Topological structures for generalized boundary repre\nsentations. MITSG 94-22, MIT Sea Grant College Program, Cambridge, Massachusetts,\nSeptember 1994.\n[2] B. G. Baumgart. Winged edge polyhedron representation. Technical Report STAN-CS-\n320, Computer Science Department, Stanford University, 1972.\n[3] E. Brisson. Representing geometric structures in d dimensions: Topology and order.\nDiscrete and Computational Geometry, 9:387-426, 1993.\n[4] J. P. Comstock, editor. Principles of Naval Architecture. The Society of Naval Architects\nand Marine Engineers, New York, 1967.\n[5] E. L. G oz and F. B. Prinz. Node-based representation of non-manifold surface bound\nurs\naries in geometric modeling. In M. Wozny, J. Turner, and K. Preiss, editors, Geometric\nModeling for Product Engineering. North-Holland, 1989.\n[6] C. M. Hoffmann. Geometric and Solid Modeling: An Introduction. Morgan Kaufmann\nPublishers, Inc., San Mateo, California, 1989.\nantyl\n[7] M. M\na. An Introduction to Solid Modeling. Computer Science Press, Rockville,\nMaryland, 1988.\n[8] M. E. Mortenson. Geometric Modeling. John Wiley and Sons, New York, 1985.\n[9] J. Rossignac and M. O'Connor. SGC: A dimension-independent model for pointsets with\ninternal structures and incomplete boundaries. In M. Wosny, J. Turner, and K. Preiss,\neditors, Geometric Modeling for Product Engineering, pages 145-180. North-Holland, 1989.\n[10] K. Weiler. Edge-based data structures for solid modeling in curved surface environments.\nIEEE Computer Graphics and Applications, 5(1):21-40, January 1985."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes2.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/dd2e0ef6278218b74dd1709065814109_lecnotes2.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 2\nKwanghee Ko\nT. Maekawa\nN. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\nDifferential geometry of curves\n2.1\nDefinition of curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.1.1\nPlane curves\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.1.2\nSpace curves\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.2\nArc length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.3\nTangent vector\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.4\nNormal vector and curvature\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.5\nBinormal vector and torsion . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.6\nSerret-Frenet Formulae . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\nReading in the Textbook\n- Chapter 1, pp.1 - pp.3\n- Chapter 2, pp.36 - pp.48\n\nLecture 2\nDifferential geometry of curves\n2.1\nDefinition of curves\n2.1.1\nPlane curves\n- Implicit curves f(x, y) = 0\nExample: x2 + y2 = a2\n- It is difficult to trace implicit curves.\n- It is easy to check if a point lies on the curve.\n- Multi-valued and closed curves can be represented.\n- It is easy to evaluate tangent line to the curve when the curve has a vertical or near\nvertical tangent.\n- Axis dependent. (Difficult to transform to another coordinate system).\nExample: x3 + y3 = 3xy : Folium of Descartes (see Figure 2.1a)\nLet f(x, y)\n=\nx3 + y3 -3xy = 0,\nf(0, 0)\n=\n0 ⇒(x, y) = (0, 0)\nlies on the curve\nExample: If we translate by (1,2) and rotate the axes by θ = atan( 3\n4), the hyperbola\nx2\n4 -y2\n2 = 1, shown in Figure 2.1(b), will become 2x2 -72xy +23y2 +140x-20y +50 = 0.\n- Explicit curves y = f(x)\nOne of the variables is expressed in terms of the other.\nExample: y = x2\n- It is easy to trace explicit curves.\n- It is easy to check if a point lies on the curve.\n- Multi-valued and closed curves can not be easily represented.\n- It is difficult to evaluate tangent line to the curve when the curve has a vertical or\nnear vertical tangent.\n\n-3\n-2\n-1\n-3\n-2\n-1\nX\nY\nasymptote line\nx+y+1=0\nmulti-valued\n-3\n-2\n-1\n-2\n-1\nX\nY\nFigure 2.1: (a) Descartes; (b) Hyperbola.\n- Axis dependent. (Difficult to transform to another coordinate system).\nExample: If the circle is represented by an explicit equation, it must be divided into\ntwo segments, with y = +\n√\nr2 -x2 for the upper half and y = -\n√\nr2 -x2 for the lower\nhalf, see Figure 2.2. This kind of segmentation creates cases which are inconvenient in\ncomputer programming and graphics.\ny = + r - x\ny = - r - x\nx\ny\no\nFigure 2.2: Description of a circle with an explicit equation.\nNote: The derivative of y = √x at the origin x = 0 is infinite, see Figure 2.3.\n- Parametric curves x = x(t), y = y(t), t1 ≤t ≤t2\n2D coordinates (x, y) can be expressed as functions of a parameter t.\nExample: x = a cos(t), y = a sin(t), 0 ≤t < 2π\n\ny\nx\ny = √x; y′ = 1/2√x; as x →0, y′ →inf\nFigure 2.3: Vertical slopes for explicit curves involve non-polynomial functions.\n- It is easy to trace parametric curves.\n- It is relatively difficult to check if a point lies on the curve.\n- Closed and multi-valued curves are easy to represent.\n- It is easy to evaluate tangent line to the curve when the curve has a vertical or near\nvertical tangent.\n- Axis independent. (Easy to transform to another coordinate system)\nExample: Folium of Descartes, see Figure 2.1, can be expressed as:\nr(t) =\n\n3t\n1+t3 , 3t2\n1+t3\n\n-inf< t < inf\n⇒easy to trace\nx(t) = x0 ⇒solve for t ⇒plug t into y(t) = y0\n⇒need to solve a nonlinear equation\nto check if a point lies on the curve.\nExplicit curve y = √x can be expressed as x = t2, y = t (t ≥0).\nr = (t2, t),\nr = (2t, 1)\nunit tangent vector\nt =\n(2t, 1)\n√\n4t2 + 1\nat t = 0, t = (0, 1)\nTherefore there is no problem representing a vertical tangent computationally.\n2.1.2\nSpace curves\n- Implicit curves\nIn 3D, a single equation generally represents a surface. For example x2 + y2 + z2 = a2 is\na sphere.\n\nThus, the curve appears as the intersection of two surfaces.\nF(x, y, z) = 0 ∩G(x, y, z) = 0\nExample: Intersection of the two quadric surfaces z = xy and y2 = zx gives cubic\nparabola. (These two surfaces intersect not only along the cubic parabola but also along\nthe x-axis.)\n- Explicit curves\nIf the implicit equations can be solved for two of the variables in terms of the third, say\nfor y and z in terms of x, we get\ny = y(x), z = z(x)\nEach of the equations separately represents a cylinder projecting the curve onto one of\nthe coordinate planes. Therefore intersection of the two cylinders represents the curve.\nExample: Intersection of the two cylinders y = x2, z = x3 gives a cubic parabola.\n- Parametric curves x = x(t), y = y(t), z = z(t), t1 ≤t ≤t2\nThe 3D coordinates (x, y, z) of the point can be expressed on functions of parameter t.\nHere functions x(t), y(t), z(t) have continuous derivatives of the rth order, and the\nparameter t is restricted to some interval called the parameter space (i.e., t1 ≤t ≤t2).\nIn this case the curve is said to be of class r, denoted as C r.\nIn vector notation:\nr = r(t)\nwhere\nr = (x, y, z),\nr(t) = (x(t), y(t), z(t))\nExample: Cubic parabola\nx = t,\ny = t2,\nz = t3\nExample: Circular helix, see Fig. 2.4.\nx = a cos(t),\ny = a sin(t),\nz = bt,\n0 ≤t ≤π\nUsing v = tan t\nv = tan t\n2 =\ns\n1 -cos t\n1 + cos t ⇒v2 = 1 -cos t\n1 + cos t\n⇒cos t = 1 -v2\n1 + v2 ⇒sin t =\n2v\n1 + v2\nTherefore the following parametrization will give the same circular helix.\nr =\n\na1 -v2\n1 + v2 ,\n2av\n1 + v2 ,\n2btan-1v\n!\n,\n0 ≤v < inf\n\n>> ylabel('Y');\n>> zlabel('Z');\n>> print('circHelix.ps')\n>> plot3(a * cos(u), a * sin(u), b * u)\n>> xlabel('X');\n>>\n>> a= 2;\n>> b = 3;\n>> u = [0 : 6 * pi / 100 : 6 * pi];\n-2\n-1\n-2\n-1\nX\nY\nZ\nFigure 2.4: Circular helix plotted using MATLAB.\n\ny\nz\nr(t)\np\nq\nr(t + ∆t)\n∆r\nx\nFigure 2.5: A segment ∆r connecting two point p and q on a parametric curve r(t).\n2.2\nArc length\nFrom Figure 2.5, we will derive an expression for the differential arc length ds of a parametric\ncurve. First, let us express the vector ∆r connecting two points p and q on an arc at parametric\nlocations t and t + ∆t, respectively, as\n∆r = p -q = r(t + ∆t) -r(t).\nAs p and q become infinitesimally close, the length of the segment connecting the two points\napproaches the arc length between the two points along the curve, r(t) and r(t+∆t). Or using\nTaylor's expansion on the norm (length) of the segment ∆r and letting ∆t →0, we can express\nthe differential arc length as\n∆s ≃|∆r| = |r(t + ∆t) -r(t)| = |dr\ndt ∆t + O(∆t2)| ≃|dr\ndt |∆t.\nThus as ∆t →0\nds = |dr\ndt |dt = | r|dt.\nDefinitions\nd\ndt ≡\nd\nds ≡′\nHence the rate of change ds\ndt of the arc length s with respect to the parameter t is\nds\ndt =\nq\nx2(t) + y2(t) + z2(t)\n(2.1)\n\nds\ndt is called the parametric speed. It is, by definition, non-negative (s being measured always\nin the sense of increasing t).\nIf the parametric speed does not vary significantly, parameter values t0, t1, · · · , tN corre-\nsponding to a uniform increment ∆t = tk -tk-1, will be evenly distributed along the curve, as\nillustrated in Figure 2.6.\nParameter Space\nt0\nt3\nt4\nt5\nt1\nt2\nt0\nt1\nt2\nt3\nt4\nt5\nx\ny\nt\nds\ndt\nFigure 2.6: When parametric speed does not vary, parameter values are uniformly spaced along\na parametric curve.\nThe arc length of a segment of the curve between points r(to) and r(t) can be obtained as\nfollows:\ns(t) =\nZ t\nto\nq\nx2(t) + y2(t) + z2(t)dt =\nZ t\nto\n√\nr · rdt\n(2.2)\nDerivatives of arc length s w.r.t. parameter t and vice versa :\ns\n=\nds\ndt = | r| =\n√\nr · r\n(2.3)\ns\n=\nd s\ndt =\nr · r\n√\nr · r\n(2.4)\n···s\n=\nd s\ndt = ( r · r)( r·\n···r + r · r) -( r · r)2\n( r · r)\n(2.5)\nt′\n=\ndt\nds = 1\n| r| =\n√\nr · r\n(2.6)\nt′′\n=\ndt′\nds = -\nr · r\n( r · r)2\n(2.7)\nt′′′\n=\ndt′′\nds = -( r · r + r·\n···r)( r · r) -4( r · r)2\n( r · r)\n(2.8)\n2.3\nTangent vector\nThe vector r(t+∆t)-r(t) indicates the direction from r(t) to r(t+∆t). If we divide the vector\nby ∆t and take the limit as ∆t →0, then the vector will converge to the finite magnitude\nvector r(t).\nr(t) is called the tangent vector.\nMagnitude of the tangent vector\n| r| = ds\ndt\n(2.9)\n\nUnit tangent vector\nt = r\n| r| =\ndr\ndt\nds\ndt\n= dr\nds ≡r′\n(2.10)\nDefinition : A parametric curve is said to be regular if | r(t)| = 0 for all t ∈I. The points\nwhere | r(t)| = 0 are called irregular (singular) points.\nNote that at irregular points the parametric speed is zero.\nExample: semi-cubical parabola r(t) = (t2, t3), see Figure 2.7\nr(t)\n=\n(2t, 3t2)\n| r(t)|\n=\np\n4t2 + 9t4 =\nq\nt2(4 + 9t2)\nwhen t = 0, | r(t)| = 0\nt>0\nt<0\nx\ny\nFigure 2.7: A singular point occurs on a semi-cubical parabola in the form of a cusp.\nHere are some useful formulae for computing the unit tangent vector:\n- 3D Parametric curve r(t)\nt\n=\nr′ = dr\nds = dr\ndt\ndt\nds = r\n| r| =\n( x, y, z)\np\nx2 + y2 + z2\n- 2D Implicit curve f(x, y) = 0\nt = (fy, -fx)\nq\nf 2x + f 2y\n\n- 2D Explicit curve y = f(x)\nt =\n(1, f)\nq\n1 + f 2\nExample: For a circular helix r(t) = (a cos t, a sin t, bt)\n- Parametric speed\nds\ndt\n=\n| r(t)| =\nq\nx2(t) + y2(t) + z2(t)\nr(t)\n=\n(-a sin t, a cos t, b)\n| r(t)|\n=\np\na2 + b2 = c = const ⇒\n(\nThe curve is regular and has\ngood parametrization\n- Unit tangent vector\nt = r\n| r| = (-a\nc sin t, a\nc cos t, b\nc)\n(2.11)\n- Arc length\ns(t) =\nZ t\n| r|dt =\nZ t\np\na2 + b2dt = ct\n(2.12)\n- Arc length parametrization\nt\n=\ns\nc\n(2.13)\nr(s)\n=\n(a cos s\nc, a sin s\nc, bs\nc )\n(2.14)\ncheck\n(2.15)\ndr\nds\n=\n(-a\nc sin s\nc, a\nc cos s\nc, b\nc) = t\n(2.16)\n2.4\nNormal vector and curvature\nLet us consider the second derivative r′′(s), see Figure 2.8.\nr′′(s) = lim\n∆s→0\nr′(s + ∆s) -r′(s)\n∆s\n(2.17)\nAs ∆s →0 r′(s + ∆s) -r′(s) becomes perpendicular to the tangent vector i.e. normal\ndirection.\nAlso |r′(s + ∆s) -r′(s)| = ∆θ · 1 = ∆θ as ∆s →0.\nThus\n|r′′(s)| = lim\n∆s→0\n∆θ\n∆s = lim\n∆s→0\n∆θ\nρ\n∆θ = 1\nρ ≡κ\n(2.18)\n\nr'(s)\nr'(s+∆s)\n∆s\nρ\n∆θ\n∆θ\nr'(s)\nr'(s+∆s)\nn\nr'(s+∆s)-r'(s)=∆θ\ncenter of\ncurvature\nFigure 2.8: Derivation of the normal vector of a curve.\nκ is called the curvature. It follows that\nκ2 = r′′ · r′′.\n(2.19)\nConsequently\nr′′(s) = t′ = κn\n(2.20)\nThus using equations (2.6) and (2.7), we obtain\nκn\n=\nd2r\nds2 = dt\nds = d\nds( rt′) = r(t′)2 + rt′′ = ( r · r) r -( r · r) r\n( r · r)2\n(2.21)\nκ2\n=\n(κn) · (κn) =\n( r · r) r -( r · r) r\n( r · r)2\n\n·\n( r · r) r -( r · r) r\n( r · r)2\n\n= ( r × r) · ( r × r)\n( r · r)3\n(2.22)\nwhere the identity (a × b) · (a × b) = (a · a)(b · b) -(a · b)2 is used.\nHere are some useful formulae for computing the normal vector and curvature:\n- 2D parametric curve r(t), see Figure 2.9\nn\n=\nez × t =\n(- y, x)\np\nx2 + y2 ,\nez = (0, 0, 1)\n(2.23)\nκ\n=\nx y - y x\n( x2 + y2)\n(2.24)\n- 2D implicit curve f(x, y) = 0\nn\n=\nez × t =\n(fx, fy)\nq\nf 2x + f 2y\n= ∇f\n|∇f|\n(2.25)\nκ\n=\n-fxxf 2\ny -2fxyfxfy + f 2\nxfyy\n(f 2x + f 2y )\n(2.26)\n\nx\ny\nz\nez\nt\nn\nn\nt\nn\nt\nκ<0\nκ>0\nκ=0\ninflection\npoint\nFigure 2.9: Normal and tangent vectors along a 2D curve.\n- 2D Explicit curve y = f(x)\nn\n=\nez × t = (- y, 1)\np\n1 + y2\n(2.27)\nκ\n=\ny\n(1 + y2)\n(2.28)\n2.5\nBinormal vector and torsion\nx\ny\nz\nb\nn\nt\nr(t)\nn t : osculating plane\nb n : normal plane\nb t : rectifying plane\nFigure 2.10: The tangent, normal, and binormal vectors define an orthogonal coordinate system\nalong a space curve.\nLet us define a unit binormal vector, see Figure 2.10\nb = t × n\n(2.29)\nWe have\nt · n = 0\nn · b = 0\nb · t = 0\nb = t × n\nt = n × b\nn = b × t\n\nThe osculating plane can be defined as the plane passing through three consecutive points\non the curve. The rate of change of the osculating plane is expressed by the vector\nb′ = d\nds(t × n) = dt\nds × n + t × dn\nds = t × n′\n(2.30)\nwhere we used the fact that dt\nds = r′′ = κn.\nFrom n · n = 1 →differentiate w.r.t. s →2n′ · n = 0 →n′ ⊥n\nThus n′ is parallel to the rectifying plane (b, t), and n′ can be expressed as a linear com-\nbination of b and t.\nn′ = μt + τb\n(2.31)\nSubstitute (2.31) into (2.30)\nb′ = t × (μt + τb) = τt × b = -τb × t = -τn\n(2.32)\nτ is called the torsion.\nConsequently\nτ = -n · b′ = -n · (t × n)′ = (r′r′′r′′′)\nr′′ · r′′\n=\n( r r\n···r)\n( r × r) · ( r × r)\n(2.33)\nTriple scalar product\n(abc) = a · (b × c) = (a × b) · c\n(2.34)\nalso\n(abc) = (bca) = (cab)\ncyclic permutation\n(2.35)\nGeometrically, (abc) equals to the volume of a parallelepiped having the edge vectors\na, b, c, as in Figure 2.11.\nax ay az\na (bxc)= bx by bz\ncx cy cz\na\nb\nc\nFigure 2.11: The computation of the volume of a parallelepiped\n2.6\nSerret-Frenet Formulae\nFrom equations (2.20) and (2.32), we found that\nt′\n=\nκn\n(2.36)\nb′\n=\n-τn\n(2.37)\n\nHow about n′?\nn′ = (b × t)′ = b′ × t + b × t′ = -τn × t + b × (κn) = -κt + τb\n(2.38)\nIn matrix form we can express the differential equations as\n\nt′\nn′\nb′\n\n=\n\nκ(s)\n-κ(s)\nτ(s)\n-τ(s)\n\nt\nn\nb\n\n(2.39)\nThus, the curve is completely determined by its curvature and torsion as a function of\nparameter s.\nThe equations κ = κ(s), τ = τ(s) are called intrinsic equations.\nThe for-\nmulae 2.39 are known as the Serret-Frenet Formulae and describe the motion of moving a\ntrihedron (t, n, b) along the curve.\nExample: Determining the shape of a curve from curvature information and boundary\nconditions only.\nGiven:\nκ = 1\nR = const\nWe find\ndt\nds = n\nR\n(2.40)\ndn\nds = -t\nR\n(2.41)\nIf we diffrentiate Equation 2.40 with respect to s,\nd2t\nds2 = 1\nR\ndn\nds .\n(2.42)\nNow, substitute Equation 2.42 into Equation 2.41\nd2t\nds2 + t\nR2 = 0.\n(2.43)\nRecognizing that t = dr\nds, we can change variables from t to r, transforming Equation 2.43\ninto\nd3r\nds3 +\nR2 dr\nds = 0\nor\nd3\nds3\n\nx(s)\ny(s)\n!\n+\nR2 d\nds\n\nx(s)\ny(s)\n!\n=\n\n!\n(2.44)\nThe solution to Equation 2.44 is\nx(s)\n=\nC1 + C2 cos\n\ns\nR\n!\n+ C3 sin\n\ns\nR\n!\n(2.45)\ny(s)\n=\nC′\n1 + C′\n2 cos\n\ns\nR\n!\n+ C′\n3 sin\n\ns\nR\n!\n(2.46)\n\nAssume we are given suitable initial conditions or boundary conditions. For this example,\nwe will use:\nx(0) = R\nx′(0) = 0\nx′′(0) = -1\nR\n(2.47)\ny(0) = 0\ny′(0) = 1\ny′′(0) = 0\n(2.48)\nSolving for the constants in the general solution gives\nC1 = C3 = 0\nC2 = R\n(2.49)\nC′\n1 = C′\n2 = 0\nC′\n3 = R\n(2.50)\nThus, we find our solution is given by\nx(s) = R cos\ns\nR\n\n(2.51)\ny(s) = R sin\ns\nR\n\n(2.52)\nwhich is precisely a circle of radius R satisfying the conditions (2.47) and (2.48).\nExample: A circular helix r = (a cos s\nc, a sin s\nc, bs\nc )\nr′(s)\n=\n(-a\nc sin s\nc, a\nc cos s\nc, b\nc)\nr′′(s)\n=\n(-a\nc2 cos s\nc, -a\nc2 sin s\nc, 0)\nr′′′(s)\n=\n( a\nc3 sin s\nc, -a\nc3 cos s\nc, 0)\nκ2\n=\nr′′ · r′′ = a2\nc4 (cos2 s\nc + sin2 s\nc) = a2\nc4 = constant\nτ\n=\n(r′r′′r′′′)\nr′′ · r′′\n= (r′r′′r′′′)\nκ2\n=\nc4\na2\n\n-a\nc sin s\nc\na\nc cos s\nc\nb\nc\n-a\nc2 cos s\nc\n-a\nc2 sin s\nc\na\nc3 sin s\nc\n-a\nc3 cos s\nc\n\n=\nc4\na2\nb\nc(a2\nc5 (cos2 s\nc + sin2 s\nc))\n=\nb\nc2 = constant\nNote: when b > 0, it is a right-handed helix;\nwhen b < 0, it is a left-handed helix.\n\nBibliography\n[1] P. M. do Carmo. Differential Geometry of Curves and Surfaces. Prentice-Hall, Inc., Engle-\nwood Cliffs, NJ, 1976.\n[2] E. Kreyszig. Differential Geometry. University of Toronto Press, Toronto, 1959.\n[3] M. M. Lipschutz. Theory and Problems of Differential Geometry. Schaum's Outline Series:\nMcGraw-Hill, 1969.\n[4] D. J. Struik. Lectures on Classical Differential Geometry.\nAddison-Wesley, Cambridge,\nMA, 1950.\n[5] T. J. Willmore. An Introduction to Differential Geometry. Clarendon Press, Oxford, 1959."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes3.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/d58b916199e8b0bdaf6d52ecd0213dc5_lecnotes3.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 3\nKwanghee Ko\nT. Maekawa\nN. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\nDifferential geometry of surfaces\n3.1\nDefinition of surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.2\nCurves on a surface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.3\nFirst fundamental form (arc length)\n. . . . . . . . . . . . . . . . . . . . . . . .\n3.4\nTangent plane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.5\nNormal vector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.6\nSecond fundamental form II (curvature) . . . . . . . . . . . . . . . . . . . . . .\n3.7\nPrincipal curvatures\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\nReading in the Textbook\n- Chapter 3, pp.49 - pp.72\n\nLecture 3\nDifferential geometry of surfaces\n3.1\nDefinition of surfaces\n- Implicit surfaces\nF(x, y, z) = 0\nExample:\nx2\na2 + y2\nb2 + z2\nc2 = 1 Ellipsoid, see Figure 3.1.\nx\ny\nz\nFigure 3.1: Ellipsoid.\n- Explicit surfaces\nIf the implicit equation F(x, y, z) = 0 can be solved for one of the variables as a function\nof the other two, we obtain an explicit surface, as shown in Figure 3.2. Example:\nz =\n2(αx2 + βy2)\n- Parametric surfaces\nx = x(u, v), y = y(u, v), z = z(u, v)\nHere functions x(u, v), y(u, v), z(u, v) have continuous partial derivatives of the rth order,\nand the parameters u and v are restricted to some intervals (i.e., u1 ≤u ≤u2, v1 ≤v ≤v2)\nleading to parametric surface patches.\nThis rectangular domain D of u, v is called\nparametric space and it is frequently the unit square, see Figure 3.3. If derivatives of the\nsurface are continuous up to the rth order, the surface is said to be of class r, denoted\nCr.\n\nFigure 3.2: Explicit quadratic surfaces z =\n2(αx2 + βy2). (a) Left: Hyperbolic paraboloid\n(α = -3, β = 1). (b) Right: Elliptic paraboloid (α = 1, β = 3).\nIn vector notation:\nr = r(u, v)\nwhere\nr = (x, y, z),\nr(u, v) = (x(u, v), y(u, v), z(u, v))\nExample:\nr = (u + v, u -v, u2 + v2)\nx = u + v\ny = u -v\nz = u2 + v2\n\n⇒eliminate u, v ⇒z = 1\n2(x2 + y2) paraboloid\n3.2\nCurves on a surface\nLet r = r(u, v) be the equation of a surface, defined on a domain D (i.e., u1 ≤u ≤u2,\nv1 ≤v ≤v2). Let β(t) = (u(t), v(t)) be a curve in the parameter plane. Then r = r(u(t), v(t))\nis a curve lying on the surface, see Figure 3.3.\nA tangent vector of curve β(t) is given by\nβ(t) = ( u(t), v(t)) A tangent vector of a curve on a surface is given by:\ndr(u(t), v(t))\ndt\n(3.1)\nBy using the chain rule:\ndr(u(t), v(t))\ndt\n= ∂r\n∂u\ndu\ndt + ∂r\n∂v\ndv\ndt = ru u(t) + rv v(t)\n(3.2)\n\nu\nv\nx\ny\nz\nD\nr(u,v)\nr(u(t),v(t))\nβ(t)=(u(t),v(t))\nParametric Space D\n3D Space\nFigure 3.3: The mapping of a curve in 2D parametric space onto a 3D biparametric surface\n.\n3.3\nFirst fundamental form (arc length)\nConsider a curve on a surface r = r(u(t), v(t)). The arc length of the curve on a surface is\ngiven by\nds\n=\n|dr\ndt |dt = |ru\ndu\ndt + rv\ndv\ndt |dt\n=\nq\n(ru u + rv v) · (ru u + rv v)dt\n=\nq\n(ru · ru)du2 + 2rurvdudv + (rv · rv)dv2\n=\np\nEdu2 + 2Fdudv + Gdv2\n(3.3)\nwhere\nE\n=\nru · ru,\nF = ru · rv,\nG = rv · rv\n(3.4)\nThe first fundamental form is defined as\nI\n=\ndr · dr = (rudu + rvdv) · (rudu + rvdv)\n=\nEdu2 + 2Fdudv + Gdv2\n(3.5)\nE, F, G are called first fundamental form coefficients Note that E = ru · ru > 0 and G =\nrv ·rv > 0 if ru = 0 and rv = 0. The first fundamental form I is positive definite. That is I ≥0\nand I = 0 if and only if du = 0 and dv = 0 since\nI = 1\nE (E du + F dv)2 + EG -F 2\nE\ndv2 and EG -F 2 = |ru × rv|2 > 0.\nI depends only on the surface and not on the parametrization.\nThe area of the surface can be derived as follows:\n\nr(u0+δu,v0)-r(u0,v0)\nr(u0,v0+δv)-r(u0,v0)\nr(u0+δu,v0)\nr(u0,v0+δv)\nr(u0,v0)\nδA\nFigure 3.4: Area of an infinitessimal surface patch.\nr(u0, v0 + δv) -r(u0, v0) ≃∂r\n∂v δv\nr(u0 + δu, v0) -r(u0, v0) ≃∂r\n∂uδu\nδA = |ruδu × rvδv| = |ru × rv|δuδv\n|ru × rv|2\n=\n(ru × rv) · (ru × rv)\nUsing the vector identity (a × b) · (c × d) = (a · c)(b · d) -(a · d)(b · c), we get\n|ru × rv|2\n=\n(ru · ru)(rv · rv) -(ru · rv)2\n(3.6)\n=\nEG -F 2\n(3.7)\nδA =\np\nEG -F 2 δuδv,\nA =\nZ Z p\nEG -F 2 dudv\n(3.8)\nExample:\nFor the hyperbolic paraboloid r(u, v) = (u, v, u2 -v2), let us derive an expression\nfor the area of a region of its surface corresponding to a the circle u2 +v2 ≤1 in the parametric\ndomain D.\nWe begin by forming expressions for the derivatives of the position vector r and the first\nfundamental form coeffients.\nru\n=\n(1, 0, 2u)\nrv\n=\n(0, 1, -2v)\nE\n=\nru · ru = 1 + 4u2\nF\n=\nru · rv = -4uv\nG\n=\nrv · rv = 1 + 4v2\nUsing Equation (3.8), we find\nEG -F 2\n=\n(1 + 4u2)(1 + 4v2) -16u2v2 = 1 + 4u2 + 4v2 > 0\nA\n=\nZ Z\nD\np\n1 + 4u2 + 4v2dudv\n\nTo compute the area, we need to evaluate the double integral over the unit disk u2 +v2 ≤1\nin the parametric domain D;\nA =\nZ Z\nu2+v2≤1\np\n1 + 4u2 + 4v2 du dv.\nTo perform the integration, let us change variables.\nu\n=\nr cos(θ), v = r sin(θ), and du dv = r dr dθ\nA\n=\nZ Z\nr≤1\np\n1 + 4r2 r dr dθ\n=\nZ 2π\nZ 1\np\n1 + 4r2 r dr dθ\n=\nπ\n6 (5\n√\n5 -1)\n3.4\nTangent plane\nTangent plane at a point r(uo, vo) is the union of tangent vectors of all curves on the surface pass\nthrough r(uo, vo), as shown in Figure 3.5. Since the tangent vector of a curve on a parametric\nsurface is given by dr\ndt = ru\ndu\ndt + rv dv\ndt , the tangent plane lies on the plane of the vectors ru and\nrv. The equation of the tangent plane is\nTp(u, v) = r(u, v) + λru(u, v) + μrv(u, v)\n(3.9)\nwhere λ and μ are real variables parameterizing the plane.\nx\ny\nz\nr=ruu+rvv\nr(u0,v0)\nTp\nFigure 3.5: The tangent plane at a point on a surface.\n3.5\nNormal vector\nThe surface normal is the vector at point r(uo, vo) perpendicular to the tangent plane, see\nFigure 3.6. And therefore\nN = ru × rv\n|ru × rv|\n(3.10)\nNote that ru and rv are not necessarily perpendicular.\n\nx\ny\nz\nTp\nN\nru\nrv\nFigure 3.6: The normal to the point on a surface.\nA regular (ordinary) point P on the surface is defined as one for which ru ×rv = 0. A point\nwhere ru × rv = 0 is called a singular point. The condition ru × rv = 0 requires that at that\npoint P the vectors ru and rv do not vanish and have different directions.\nExample:\nElliptic Paraboloid r(u, v) = (u + v, u -v, u2 + v2)\nru\n=\n(1, 1, 2u)\nrv\n=\n(1, -1, 2v)\nru × rv\n=\n\nex\ney\nez\n2u\n-1\n2v\n\n=\n2(u + v)ex + 2(u -v)ey -2ez = 0\n|ru × rv|\n=\nq\n(u + v)2 + (u -v)2 + 1\n=\np\n2u2 + 2v2 + 1 > 0 ⇒Regular !\nN\n=\n(2(u + v), 2(u -v), -2)\n√\n2u2 + 2v2 + 1\n=\n(u + v, u -v, -1)\n√\n2u2 + 2v2 + 1\nat (u, v) = (0, 0), N = (0, 0, -1)\nExample:\nCircular Cone r(u, v) = (u sin α cos v, u sin α sin v, u cos α), see Figure 3.7\nru\n=\n(sin α cos v, sin α sin v, cos α)\nrv\n=\n(-u sin αsinv, u sin αsinv, 0)\nru × rv\n=\n\nex\ney\nez\nsin α cos v\nsin α sin v\ncos α\n-u sin α sin v\nu sin α cos v\n\np\nα\nv\nu\ny\nx\nz\nusinαcosv\nusinαsinv\nsingular\nu\nα\nusinα\nFigure 3.7: Circular cone.\n=\n-u sin α cos α cos vex -u sin α cos α sin vey + u sin2 αez\nAt the origin n = 0,\nru × rv\n=\nTherefore, the apex of the cone is a singular point.\n3.6\nSecond fundamental form II (curvature)\nS\nP\nN\nk\nkg\nkn\nn\nC\nt\nFigure 3.8: Definition of normal curvature\nIn order to quantify the curvatures of a surface S, we consider a curve C on S which passes\nthrough point P as shown in Figure 3.8. t is the unit tangent vector and n is the unit normal\nvector of the curve C at point P.\ndt\nds\n=\nκn = kn + kg\n(3.11)\nkn\n=\nκnN\n(3.12)\nwhere kn is the normal curvature vector normal to the surface, kg is the geodesic curvature\nvector tangent to the surface, and k = κn is the curvature vector of the curve C at point P.\nκn is called the normal curvature of the surface at P in the direction t.\n\nMeusnier's Theorem : All curves lying on a surface S passing through a given point\np ∈S with the same tangent line have the same normal curvature at this point.\nSince N · t = 0, differentiate w.r.t. s\nd\nds(N · t)\n=\nN′ · t + N · t′\ndt\nds · N\n=\n-t · dN\nds = -dr\nds · dN\nds\n(3.13)\nRecoginizing that ds · ds = dx2 + dy2 + dz2 = dr · dr, we can rewrite Equation 3.13 as:\ndt\nds · N\n=\n= -dr · dN\ndr · dr\nwhile dt\nds · N\n=\nκn · N ≡κn\ncenter of curvature\ncenter of curvature\nN\nN\nP\nP\n(a)\n(b)\nFigure 3.9: Definition of positive normal: (a) κn · N = κn; (b) κn · N = -κn.\nII\n=\n-dr · dN = -(rudu + rvdv) · (Nudu + Nvdv)\n=\nLdu2 + 2Mdudv + Ndv2\n(3.14)\nwhere\nL\n=\nN · ruu,\nM = N · ruv,\nN = N · rvv\n(3.15)\nTherefore the normal curvature is given by\nκn = II\nI = L + 2Mλ + Nλ2\nE + 2Fλ + Gλ2\n(3.16)\nwhere λ = dv\ndu.\nSuppose P is a point on a surface and Q is a point in the neighborhood of P, as in\nFigure 3.10. Taylor's expansion gives\nr(u + du, v + dv) = r(u, v) + rudu + rvdv + 1\n2(ruudu2 + 2ruvdudv + rvvdv2) + H.O.T. (3.17)\n\nN\nP\nQ\nd\nTp\nr=r(u,v)\nFigure 3.10: Geometrical illustration of the second fundamental form.\nTherefore\nPQ = r(u + du, v + dv) -r(u, v) = rudu + rvdv + 1\n2(ruudu2 + 2ruvdudv + rvvdv2) + H.O.T.\nThus, the projection of PQ onto N\nd = PQ · N = (rudu + rvdv) · N + 1\n2II\nand since ru · N = rv · N = 0, we get\nd = 1\n2II = 1\n2(Ldu2 + 2Mdudv + Ndv2)\nWe want to observe in which situation d is positive and negative. When d = 0\nLdu2 + 2Mdudv + Ndv2 = 0\nSolve for du\ndu = -M ±\np\n(Mdv)2 -LNdv2\nL\n= -M ±\n√\nM 2 -LN\nL\ndv\n(3.18)\nN\nN\nN\nP\nP\nP\nTp\nTp\nTp\nFigure 3.11: (a) Elliptic point; (b) Parabolic point; (c) Hyperbolic point.\n- If M 2-LN < 0, there is no real root. That means there is no intersection between the surface\nand its tangent plane except at point P. P is called elliptic point (Figure 3.11(a)).\n- If M 2 -LN = 0, there is a double root. The surface intersects its tangent plane with one line\ndu = -M\nL dv, which passes through point P. P is called parabolic point (Figure 3.11(b)).\n- If M 2 -LN > 0, there are two roots. The surface intersects its tangent plane with two\nlines du =\n-M±\n√\nM2-LN\nL\ndv, which intersect at point P.\nP is called hyperbolic point\n(Figure 3.11(c)).\n\n3.7\nPrincipal curvatures\nThe extreme values of κn can be obtained by evaluating dκn\ndλ = 0 of Equation 3.16, which gives:\n(E + 2Fλ + Gλ2)(Nλ + M) -(L + 2Mλ + Nλ2)(Gλ + F) = 0\n(3.19)\nSince\nE + 2Fλ + Gλ2\n=\n(E + Fλ) + λ(F + Gλ),\nL + 2Mλ + Nλ2\n=\n(L + Mλ) + λ(M + Nλ)\nequation (3.19) can be reduced to\n(E + Fλ)(M + Nλ) = (L + Mλ)(F + Gλ)\n(3.20)\nThus\nκn = L + 2Mλ + Nλ2\nE + 2Fλ + Gλ2 = M + Nλ\nF + Gλ = L + Mλ\nE + Fλ\n(3.21)\nTherefore κn satisfies the two simultaneous equations\n(L -κnE)du + (M -κnF)dv = 0\n(M -κnF)du + (N -κnG)dv = 0\n(3.22)\nThese equations can be simultaneously satisfied if and only if\n\nL -κnE\nM -κnF\nM -κnF\nN -κnG\n= 0\n(3.23)\nwhere | | denotes the determinant of a matrix. Expanding and defining K and H as\nK\n=\nLN -M 2\nEG -F 2\n(3.24)\nH\n=\nEN + GL -2FM\n2(EG -F 2)\n(3.25)\nwe obtain a quadratic equation for κn as follows:\nκ2\nn -2Hκn + K = 0\n(3.26)\nThe values K and H are called Gauss (Gaussian) and mean curvature respectively. The\ndiscriminant D can be expressed as follows:\nD\n=\nH2 -K\n=\n(EN + GL -2FM)2 -4(EG -F 2)(LN -M 2)\n4(EG -F 2)2\nThe denominator is always positive, so we only need to investigate the numerator. The numer-\nator can be written as:\n(EN + GL -2FM)2 -4(EG -F 2)(LN -M 2)\n= 4\n\nEG -F 2\nE2\n!\n(EM -FL)2 + [EN -GL -2F\nE (EM -FL)]2 ≥0\n\nThus, D ≥0.\nUpon solving Equation (3.26) for the extreme values of curvature, we have:\nκmax = H +\np\nH2 -K\n(3.27)\nκmin = H -\np\nH2 -K\n(3.28)\nFrom Equations (3.27), (3.28), it is readily seen that\nK\n=\nκmaxκmin\n(3.29)\nH\n=\nκmax + κmin\n(3.30)\nFrom Equation (3.24) (since EG -F 2 > 0, see Equation 3.6).\nK > 0\n⇒\nLN > M 2 ⇒Elliptic point\nK = 0\n⇒\nLN = M 2 ⇒Parabolic point\nK < 0\n⇒\nLN < M 2 ⇒Hyperbolic point\nK=0\nK>0\nK<0\nFigure 3.12: Curvature map of a torus showing elliptic, parabolic, and hyperbolic regions.\n\nBibliography\n[1] P. M. do Carmo. Differential Geometry of Curves and Surfaces. Prentice-Hall, Inc., Engle-\nwood Cliffs, NJ, 1976.\n[2] E. Kreyszig. Differential Geometry. University of Toronto Press, Toronto, 1959.\n[3] M. M. Lipschutz. Theory and Problems of Differential Geometry. Schaum's Outline Series:\nMcGraw-Hill, 1969.\n[4] D. J. Struik. Lectures on Classical Differential Geometry.\nAddison-Wesley, Cambridge,\nMA, 1950.\n[5] T. J. Willmore. An Introduction to Differential Geometry. Clarendon Press, Oxford, 1959."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes6.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/e58d71723e462b96821a8351d8e729ba_lecnotes6.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 6\nN. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\nB-splines (Uniform and Non-uniform)\n6.1\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.2\nDefinition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.2.1\nKnot vector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.2.2\nProperties and definition of basis function Ni,k(u)\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.2.3\nExample: 2nd order B-spline basis function\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.2.4\nExample: 3rd order B-spline basis function\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.2.5\nExample: 4th order basis function\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.2.6\nSpecial case n = k -1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.3\nDerivatives\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.4\nApproaches to design with B-spline curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.5\nInterpolation of data points with cubic B-splines\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.6\nEvaluation and subdivision of B-splines\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.6.1\nDe Boor algorithm for B-spline curve evaluation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.6.2\nKnot insertion: Boehm's algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.7\nTensor product piecewise polynomial surface patches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.7.1\nExample: B ezier patch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.7.2\nExample: B-Spline patch\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.7.3\nExample: Composite B ezier patches\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.8\nGeneralization of B-splines to NURBS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.8.1\nCurves and Surface Patches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.8.2\nExample: Representation of a quarter circle as a rational polynomial . . . . . . . . . . . . . . . . . . . . . .\n6.8.3\nTrimmed patches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6.9\nComparison of free-form curve/surface representation methods\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\nReading in the Textbook\n- Chapter 1, pp. 6 - 33\n\nLecture 6\nB-splines (Uniform and Non-uniform)\n6.1\nIntroduction\nThe formulation of uniform B-splines can be generalized to accomplish certain objectives.\nThese include\n- Non-uniform parameterization.\n- Greater general flexibility.\n- Change of one polygon vertex in a B ezier curve or of one data point in a cardinal (or\ninterpolatory) spline curve changes entire curve (global schemes).\n- Remove necessity to increase degree of B ezier curves or construct composite B ezier curves\nusing previous schemes in order to increase degrees of freedom.\n- Obtain a \"local\" approximation scheme.\nThe development extends the B ezier curve formulation to a piecewise polynomial curve with\neasy continuity control.\n\n6.2\nDefinition\nA parametric non-uniform B-spline curve is defined by\nP(u) =\nn\nX\ni=0\nPiNi,k(u)\n(6.1)\nwhere, Pi are n + 1 control points; Ni,k(u) are piecewise polynomial B-spline basis functions\nof order k (or degree k -1) with n ≥k -1.\nTherefore n, k are independent, unlike B ezier curves. The parameter u obeys the inequality\nto ≤u ≤tn+k\n(6.2)\n6.2.1\nKnot vector\nFor open (non-periodic) curves, it is usual to define a set T of non-decreasing real numbers\nwhich is called the knot vector, as follows:\nT = {to = t1 = · · · = tk-1\n|\n{z\n}\nk equal values\n< tk ≤tk+1 ≤· · · ≤tn\n|\n{z\n}\nn-k+1 internal knots\n< tn+1 = · · · = tn+k\n|\n{z\n}\nk equal values\n}\n(6.3)\nAt each knot value, the curve P(u) has some degree of discontinuity in its derivatives above\na certain order as we will see later. The total number of knots is n + k + 1 which equals the\nnumber of control points in the curve plus the curve's order.\n6.2.2\nProperties and definition of basis function Ni,k(u)\n1. Pn\ni=0 Ni,k(u) = 1 (partition of unity).\n2. Ni,k(u) ≥0 (positivity).\n3. Ni,k(u) = 0 if u ∈[ti, ti+k] (local support).\n4. Ni,k(u) is (k -2) times continuously differentiable at simple knots.\nIf a knot tj is of multiplicity ρ(≤k), ie. if\ntj = tj+1 = · · · = tj+ρ-1\n(6.4)\nthen Ni,k(u) is (k -ρ -1) times continuously differentiable, ie. it is of class Ck-ρ-1.\n\n5. Recursive definition (Cox-de Boor algorithm)\nNi,1(u) =\n(\nu ∈[ti, ti+1)\nu ∈[ti, ti+1)\n(6.5)\nNi,k(u) =\nu -ti\nti+k-1 -ti\nNi,k-1(u) +\nti+k -u\nti+k -ti+1\nNi+1,k-1(u)\n(6.6)\n(set 0\n0 = 0 above when it occurs)\nProperties 1-4 or property 5 by itself (given a known knot vector T) define the B-spline\nbasis.\n6.2.3\nExample: 2nd order B-spline basis function\n(Piecewise linear case- see Figure 6.1)\nk = 2, Ck-2 = C2-2 = C0\nti-1\nti+1\nti+2\nti+3\nti\nNi,2(u)\nFigure 6.1: Plot of 2nd order B-spline basis functions.\nNi,2(u) consists of two piecewise linear polynomials:\nNi,2(u) =\n(\nu-ti\nti+1-ti\nti ≤u ≤ti+1\nti+2-u\nti+2-ti+1\nti+1 ≤u ≤ti+2\n\n6.2.4\nExample: 3rd order B-spline basis function\n(Piecewise quadratic case- See Figure 6.2)\nk = 3, Ck-2 = C3-2 = C1\nNi,3(ti) consists of three piecewise quadratic polynomials y1(u), y2(u) and y3(u). We want\nto find y1(u), y2(u) and y3(u) such that\nFigure 6.2: Plot of 3rd order B-spline basis function.\nNi,3(ti)\n=\nN ′\ni,3(ti) = 0.\nNi,3(ti+3)\n=\nN ′\ni,3(ti+3) = 0.\n(6.7)\nPosition continuity:\ny1(u)\n=\nA\nu -ti\nti+1 -ti\n!2\n(6.8)\ny3(u)\n=\nB\nti+3 -u\nti+3 -ti+2\n!2\n(6.9)\ny2(u)\n=\nA(1 -s)2 + Bs2 + C2s(1 -s)\n(6.10)\ns\n=\nu -ti+1\nti+2 -ti+1\n(6.11)\nNote that\ny1(ti+1) = y2(ti+1) = A\ny3(ti+2) = y2(ti+2) = B\n\nat s = 0, s = 1(u = ti+1, u = ti+2).\nFirst derivative continuity:\n2(C -A)\nti+2 -ti+1\n=\n2A\nti+1 -ti\n(6.12)\n2(B -C)\nti+2 -ti+1\n=\n-2B\nti+3 -ti+2\n(6.13)\nhence,\nA\n\"\nti+1 -ti\n+\nti+2 -ti+1\n#\n= C\nti+2 -ti+1\n(6.14)\nB\n\"\nti+2 -ti+1\n+\nti+3 -ti+2\n#\n= C\nti+2 -ti+1\n(6.15)\nwhere\nA, B = functions(C)\nNeed one more condition (normalization):\nZ ti+k or +inf\nti or -inf\nNi,k(u)du = 1\nk(ti+k -ti)\nWe obtain\nA(ti+2 -ti) + B(ti+3 -ti+1) + C(ti+2 -ti+1) = ti+3 -ti\n(6.16)\nFrom Equation 6.14 to 6.16, we obtain\nA = ti+1 -ti\nti+2 -ti\n,\nB = ti+3 -ti+2\nti+3 -ti+1\n,\nC = 1\n(6.17)\nFinally,\nNi,3(u)\n=\ny1(u)Ni,1(u) + y2(u)Ni+1,1(u) + y3(u)Ni+2,1(u)\n=\nu -ti\nti+2 -ti\nNi,2(u) +\nti+3 -u\nti+3 -ti+1\nNi+1,2(u)\n(6.18)\n\n6.2.5\nExample: 4th order basis function\n(Cubic B-spline case- K = 4 see Figure 6.3)\nn = 6 →7 control points\nn + k + 1 = 11 knots\nt\no\nt1\nt2\nt3\nt4\nt7\nt8\nt9\nt10\nt6\nt5\nN0,4\nN1,4\nN2,4\nN3,4\nN4,4\nN5,4\nN6,4\nN0,4 is C-1\nN0,4 is C2\nN1,4 is C2\nN5,4 is C2\nN2,4 is C2\nN6,4 is C0\nN1,4 is C2\nN4,4 is C2\nN1,4 is C0\nN2,4 is C1\nN3,4 is C2\nN3,4 is C2\nN4,4 is C1\nN5,4 is C0\nN6,4 is C-1\nFigure 6.3: Cubic B-spline functions.\nFrom property 1:\nN0,4(t0) + N1,4(t0) = 0\n(6.19)\nTherefore,\nP(t0) = (P1 -P0) N1,4(t0)\n(6.20)\nSimilarly,\nP(t10) = (P6 -P5) N6,4(t10)\n(6.21)\n\nu=t0=t1=t2=t3\nt4\nt5\nt6\nP0\nP1\nP2\nP3\nP4\nP5\nu=t7=t8=t9=t10\nP6\nspan 1 affected by\nP0,P1,P2,P3\nspan 2 affected by\nspan 3 affected by\nspan 4 affected by\nP1,P2,P3,P4\nP2,P3,P4,P5\nP3,P4,P5,P6\nFigure 6.4: Example of local convex hull property of B-spline curve\n\nProperties:\n- Local support (eg. P6 affects span 4 only), see Figure 6.4\ni.e. Pi affects [ti, ti+k] (k spans)\n- Convex hull (stronger that B ezier) let u ∈[ti, ti+1], then Nj,k(u) = 0 for j ∈i -k + 1, · · ·, i\n(k values)\ni\nX\nj=i-k+1\nNj,k(u) = 1, Nj,k(u) ≥0\n- Each span is in the convex hull of the k vertices contributing to its definition\n- Consequence: k consecutive vertices are collinear →span is a straight line segment\n- Variation diminishing property as for B ezier curves\n- Exploit knot multiplicity to make complex curves\n6.2.6\nSpecial case n = k -1\nThe B-spline curve is also a B ezier curve in this case.\nT = {to = t1 = · · · = tk-1\n|\n{z\n}\nk equal knots\n< tk = tk+1 = · · · = t2k-1\n|\n{z\n}\nk equal knots\n}\n6.3\nDerivatives\nP(u)\n=\nn\nX\ni=0\nPiNi,k(u)\n(6.22)\nP′(u)\n=\nn\nX\ni=1\ndiNi,k-1(u)\n(6.23)\ndi\n=\n(k -1) Pi -Pi-1\nti+k-1 -ti\n(6.24)\n\n6.4\nApproaches to design with B-spline curves\nDesign procedure A\n1. Designer chooses knot vector and control points.\n2. Designer displays curve and tweaks control points to improve curve.\nDesign procedure B\n1. Designer starts with data points on or near curve.\n2. Construct an interpolating/approximating B-spline curve.\n3. Display curve and tweak control points to improve curve.\n\n6.5\nInterpolation of data points with cubic B-splines\nGiven N data points: Pi, i = 1, 2, · · ·, N, and no other derivative data at the boundaries. The\nproblem is to construct a cubic B-spline curve which interpolates (precisely matches) these\ndata points.\nConstruction of knot vector\nLet\nˆu1 = 0\nˆui+1 = ˆui + di+1\ndi+1 = |Pi+1 -Pi|\ni = 1, 2, · · ·, N -1\nd =\nN\nX\ni=2\ndi →ui = ˆui\nd\ni = 1, 2, · · ·, N -1\nRemove two knot values u2 and uN-1 from knot vector to obtain proper number of degrees\nof freedom (instead of having to prescribe boundary conditions, which could be done if needed)\nT = {u1 = u1 = u1 = u1\n|\n{z\n}\n4 times\n< u3 ≤u4 ≤· · · ≤uN-2\n|\n{z\n}\ninternal knots=N-4\n< uN = uN = uN = uN\n|\n{z\n}\n4 times\n}\nknots = n + 4 + 1 = (N -4) + 4 + 4 = N + 4 →n = N -1\nR(u) =\nn\nX\ni=0\nRiBi,4(u)\n0 ≤u ≤1\n(6.25)\nn = N -1\nRequire that\nR(uj) =\nN-1\nX\ni=0\nRiBi,4(uj) = Pj\nj = 1, 2, · · ·, N\n(6.26)\nSolve for Ri (system is banded).\nThere are also other more sophisticated ways to choose knot vector and parameterization\nattempting to make u proportional to arc length.\n\n6.6\nEvaluation and subdivision of B-splines\n6.6.1\nDe Boor algorithm for B-spline curve evaluation\nP1\nP2\nP3\nt4-t\nt4-t1\nP1\nP0\nP1\nP2\nP3\nP1\nt-t1\nt4-t1\nt5-t\nt5-t3\nt-t3\nt5-t3\nt4-t\nt4-t3\nt-t3\nt4-t3\nt-t2\nt4-t2\nt5-t\nt5-t2\nt-t2\nt5-t2\nt6-t\nt6-t3\nt-t3\nt6-t3\nt4-t\nt4-t2\nP3\nFigure 6.5: Diagram of de Boor subdivision algorithm over a cubic spline segment, where\nt ∈[t3, t4].\nEvaluation of B-spline curves can be performed as follows (de Boor's algorithm):\nP(u) =\nn\nX\ni=0\nPiNi,k(u)\nt0 ≤u ≤tn+k\n(6.27)\nLet u ∈[tl, tl+1) be a particular span. Ni,k(u) = 0 for i = l -k + 1, · · ·, l\nLet\nP0\ni = Pi\n(6.28)\nDe Boor's recursive formula:\nPj\ni = (1 -αj\ni)Pj-1\ni-1 + αj\niPj-1\ni\n,\ni ≥l -k + 2\n(6.29)\n\nwhere,\nαj\ni =\nu -ti\nti+k-j -ti\n(6.30)\n⇒Pk-1\nk-1 = P(t)\nThis algorithm is shown graphically in Figure 6.5. An example of the evaluation of a point\non an cubic (k = 4, l = 3) B-spline curve is shown in Figure 6.6.\nP1\nP2\nP3\nP3\nP3\nP3\nP2\nP1\nP2\nP0\nt0=t1=t2=t3\nt4\nt5\nt6\nu\nFigure 6.6: Evaluation of a point on a B-spline curve with the de Boor algorithm.\nThe algorithm shown in Figure 6.5 also permits the splitting of the segment into two smaller\nsegments of the same order:\nleft polygon:\nP 0\n0 P 1\n1 P 2\n2 P 3\nright polygon:\nP 3\n3 P 2\n3 P 1\n3 P 0\n\n6.6.2\nKnot insertion: Boehm's algorithm\nn\nX\ni=0\nPiNi,k(t)\n|\n{z\n}\nover [ti]=[t0,···,tl,tl+1,···]\n=\nn+1\nX\ni=0\nˆPi ˆNi,k(t)\n|\n{z\n}\nover [ti]=[t0,···,tl,ˆt,tl+1,···]\n(6.31)\nˆPi = aiPi + (1 -ai)Pi-1\n(6.32)\nai =\n\ni ≤l -k + 1\nl + 1 ≤i\nt-ti\nti+k-1-ti\nl -k + 2 ≤i ≤l\nP0 = ˆP0\nP3 = ˆP4\nˆP3\nP2\nˆP1\nt2\nt3 ≤ˆt < t4\nP1\nˆP2\nt4\nˆt\nt3\nt5\nFigure 6.7: Control polygon of B-spline curve before and after knot insertion in interval [t3, t4].\nBy repeatedly applying knot insertion algorithm, multiple knots within the knot vector can\nbe created.\nP1\nP2\nP3\nP0\nP1\nP2\nP3\nt -t\nt -t\nt -t1\nt -t\nt -t\nt -t\nt -t2\nt -t\nt -t\nt -t\nt -t\nt -t\nFigure 6.8: Boehm's algorithm diagram with added knot t in interval [t3, t4].\n\n6.7\nTensor product piecewise polynomial surface patches\nLet\nR(u) =\nn\nX\ni=0\nRiFi(u)\nA ≤u ≤B\n(6.33)\nbe 3-D (or 2-D) curve expressed as linear combinations of basis functions Fi(u).\nLet this curve sweep a surface by moving and possibly deforming. This can be described\nby letting each Ri trace a curve\nRi(v) =\nm\nX\nk=0\naikGk(v)\nC ≤v ≤D\n(6.34)\nThe resulting surface is a tensor product surface (see Figure 6.9).\nR(u, v) =\nn\nX\ni=0\nm\nX\nk=0\naikFi(u)Gk(v)\n(u, v) ∈[A, B] × [C, D]\n(6.35)\nA\nB\nu\nv\nC\nD\n(u,v)\nv=D\nu=A\nu=B\nR(u,v)\nPatch\nv=C\nFigure 6.9: A tensor product patch.\n\nMatrix (tensor) form:\nR(u, v) = [F0(u) · · ·Fn(u)][aik][G0(v) · · ·Gm(v)]T\n(6.36)\nThe basis functions can be:\n- Monomials →Ferguson patch\n- Hermite →Hermite-Coons patch\n- Bernstein →B ezier patch\n- Lagrange →Lagrange patch\n- Uniform B-splines →Uniform B-spline patch\n- Non-uniform B-splines →Non-uniform B-spline patch.\n\n6.7.1\nExample: B ezier patch\nR(u, v) =\nn\nX\ni=0\nm\nX\nj=0\nRijBi,n(u)Bj,m(v)\n0 ≤u, v ≤1\n(6.37)\nwhere Rij are the control points creating a control polyhedron (net), see Figure 6.10.\nv\nu\nR00\nR10\nR30\nR33\nFigure 6.10: A B ezier patch.\nProperties:\n- Lines of v= v = constant (isoparameter lines) are B ezier curves of degree n with control\npoints\nQi =\nm\nX\nj=0\nRijBj,m( v).\n(6.38)\n- The boundary isoparameter lines have the same control points as the corresponding\npolyhedron points.\n- The relation between the patch and B ezier net is affinely invariant (translation, rotation,\nscaling).\n- Convex hull.\n- No known variation diminishing property.\n- The procedure to create piecewise continuous surfaces with B ezier patches is complex.\n\n6.7.2\nExample: B-Spline patch\nR(u, v) =\nn\nX\ni=0\nm\nX\nj=0\nRijNi,k(u)Qj,l(v)\nn ≥k -1 and m ≥l -1\nU = {u0 = u1 = · · · = uk-1\n|\n{z\n}\nk equal knots\n< uk ≤uk+1 ≤· · · ≤un < un+1 = · · · = un+k\n|\n{z\n}\nk equal knots\n}\nV = {v0 = v1 = · · · = vl-1\n|\n{z\n}\nl equal knots\n< vl ≤vl+1 ≤· · · ≤vm < vm+1 = · · · = vm+l\n|\n{z\n}\nl equal knots\n}\nProperties:\n- Obeys same properties as a B ezier patch to which it reduces for n = k -1 and m = l -1\n(isoparameter lines, boundaries, affine invariance, convex hull).\n- Easy construction of complex piecewise continuous geometries.\n- Local control:\n1. Rij affects [ui, ui+k] × [vj, vj+l];\n2. Subpatch [ui, ui+1] × [vj, vj+1] affected by Rp,q where (p, q) ∈[i -k + 1, · · · i] ×\n[j -l + 1, · · · j].\n- Strong convex hull - each subpatch lies in the convex hull of the vertices contributing to\nits definition.\n\n6.7.3\nExample: Composite B ezier patches\nu\nv\nR\n(1)(u,v)\n(u,v)\nR\n(2)\n0 ≤u,v ≤1\nFigure 6.11: Composite B ezier patches.\n1. Positional continuity\nR(1)(1, v)\n=\nR(2)(0, v)\n(6.39)\nR(1)\n3i\n=\nR(2)\n0i\ni = 0, 1, 2, 3\n(6.40)\n2. Tangent plane (or normal) continuity\nR(2)\nu (0, v) × R(2)\nv (0, v) = λ(v)R(1)\nu (1, v) × R(1)\nv (1, v)\n(6.41)\n(direction of surface normal continuous for λ(v) > 0)\nSince\nR(2)\nv (0, v) = R(1)\nv (1, v),\n(6.42)\nuse\nR(2)\nu (0, v)\n|\n{z\n}\ncubic in v\n= λ(v)\n| {z }\nconstant\nR(1)\nu (1, v)\n|\n{z\n}\ncubic in v\n(6.43)\nto show\nR(2)\n1i -R(2)\n0i = λ(R(1)\n3i -R(1)\n2i ).\n(6.44)\nTherefore, collinearity of above polyhedron edges is required\n\n6.8\nGeneralization of B-splines to NURBS\nThe acronym NURBS stands for non-uniform rational B-splines. These functions have the\n- Same properties as B-splines, and\n- Are capable of representing a wider class of geometries.\n6.8.1\nCurves and Surface Patches\nNURBS curves are defined by\nR(u) =\nPn\ni=0 wiRiNi,k(u)\nPn\ni=0 wiNi,k(u)\n(6.45)\nwhere weights wi > 0; if all wi = 1, the integral piecewise polynomial spline case is recovered.\nThis formulation permits exact representation of conics, eq. circle, ellipse, hyperbola.\nNURBS surface patches are defined by\nR(u, v) =\nPn\ni=0\nPm\nj=0 wijRijNi,k(u)Qj,l(v)\nPn\ni=0\nPm\nj=0 wijNi,k(u)Qj,l(v)\n(6.46)\nwhere weights wij ≥0. This formulation allows for exact representation of quadrics, tori,\nsurfaces of revolution and very general free-form surfaces. If all wij = 1, the integral piecewise\npolynomial case is recovered.\n6.8.2\nExample:\nRepresentation of a quarter circle as a rational\npolynomial\ny\nx\nθ\nR\nFigure 6.12: Quarter circle.\nConsider a quarter circle (see Figure 6.12) described in terms of trigonometric functions by\nx = R cos(θ)\ny = R sin(θ)\n)\nfor 0 ≤θ ≤π\n2 .\n\nSetting t = tan( θ\n2) and using basic identities from trigonometry, we can express x and y as\nfunctions of t:\nx(t) = R 1-t2\n1+t2\ny(t) = R\n2t\n1+t2\n\nfor 0 ≤t ≤1.\n(6.47)\nFor the conversion of Equation 6.47 to the B ezier representation, apply\n[t2 t 1]\n\nc2\nc1\nc0\n\n= [t2 t 1]\n\n-2\n-2\n\nb0\nb1\nb2\n\nseparately to numerators and denominators to obtain the B ezier form.\n6.8.3\nTrimmed patches\n- R(u, v) is an untrimmed patch in the parametric domain (u, v) ∈[A, B] × [C, D].\n- Describe external loop as a set of edges (ie. curves in parameter space ri(t) = [ui(ti)vi(ti)]\n- eg. external loop the Figure 6.13 if made up of {r1, r2, r3, r4, r5}, while the internal\nloop is made up of curve {r6}.\nr6\nTrimming lines\nr2\nr4\nr3\nr5\nr1\nC\nA\nB\nD\nFigure 6.13: Trimmed surface patch.\n\n6.9\nComparison of free-form curve/surface representa-\ntion methods\nSingle span/patch\nComposite\nFerguson (monomial or power basis)\nB ezier\nHermite\nCardinal or interpolatory spline\nB ezier\nB-spline\nLagrange\nTable 6.1: Classification of free-form curve/surface representation.\nProperty\nFerguson\nHermite-\nB ezier\nLagrange\nComposite\nCardinal\nCoons\nB ezier\nSpline\nB-Splines\nNURBS\nEasy geometric\nrepresentation\nlow\nmed\nhigh\nmed\nhigh\nMedium\nhigh\nhigh\nConvex hull\nno\nno\nyes\nno\nyes\nno\nyes\nyes\nVariation\ndiminishing ∗\nno\nno\nyes\nno\nyes\nno\nyes\nyes\nEasiness for\ncreation\nlow\nmed\nmed\ninappr.\nmed\nhigh\nhigh\nhigh\nLocal\nyes but\ncontrol\nno\nno\nno\nno\ncomplex\nno\nyes\nyes\nApproximation\nease\nmed\nmed\nhigh\nlow\nhigh\nmedium\nhigh\nhigh\nInterpolation\nhigh but\nease\nmed\nmed\nmed\ninappr.\nmed\nhigh\nhigh\nhigh\nGenerality\nmed\nmed\nmed\nmed\nmed\nmed\nmed\nhigh\nPopularity ∗∗\nlow\nlow\nmed\nlow\nmed\nmed\nhigh\nvery high\nTable 6.2: Comparison of curve/surface representation methods.\n∗Variation diminishing property does not apply to surfaces.\n∗∗Popularity in industry and STEP/PDES standards.\n\nBibliography\n[1] G. Farin. Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide.\nAcademic Press, Boston, MA, 3rd edition, 1993.\n[2] I. D. Faux and M. J. Pratt. Computational Geometry for Design and Manufacture. Ellis\nHorwood, Chichester, England, 1981.\n[3] J. Hoschek and D. Lasser. Fundamentals of Computer Aided Geometric Design. A. K. Pe-\nters, Wellesley, MA, 1993. Translated by L. L. Schumaker.\n[4] J. Owen. STEP: An Introduction. Information Geometers, Winchester, UK, 1993.\n[5] L. A. Piegl and W. Tiller. The NURBS Book. Springer, New York, 1995.\n[6] F. Yamaguchi. Curves and Surfaces in Computer Aided Geometric Design. Springer-Verlag,\nNY, 1988."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes8_fixed.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/c205cbea93b169c670142063307687c5_lecnotes8_fixed.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 8\nN. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nc\nCopyright ≥2003 Massachusetts Institute of Technology\nContents\n8 Fitting, Fairing and Generalized Cylinders\n8.1 Least Squares Method of Curve Fitting . . . . . . . . . . . . . . . . . . . . . .\n8.2 Fairing of Curves and Surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8.2.1\nProperties and Definition . . . . . . . . . . . . . . . . . . . . . . . . . .\n8.2.2\nCurve Interrogation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8.2.3\nFairing Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8.2.4\nSurface Fairing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8.3 Generalized Cylinders: Motivation and Definitions . . . . . . . . . . . . . . . .\n8.3.1\nApplications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8.3.2\nDefinition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8.4 Degeneracies of Generalized Cylinders . . . . . . . . . . . . . . . . . . . . . . .\n8.5 Properties of Generalized Cylinders . . . . . . . . . . . . . . . . . . . . . . . .\n8.6 Discrete Generalized Cylinders . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\nReading in the Textbook\n- Chapter 11, pp. 353 - 365\n\nX\nX\nLecture 8\nFitting, Fairing and Generalized\nCylinders\n8.1\nLeast Squares Method of Curve Fitting\nExample problem\nGiven N points Pi, i = 1, 2, ..., N (N 4), construct an approximating cubic B ezier\ncurve that interpolates P1 and PN (end points).\nSolution\n1. Parametrization by chord-length method\nLet\nˆu1 = 0;\nˆ\nˆ\nui+1 = ui + di+1, i = 1, 2, ..., N - 1\n(8.1)\nwhere di+1 = |Pi+1 - Pi| is the chord length between two consecutive points. The\noverall chord length is\nN\nd =\ndi\n(8.2)\ni=2\nThe parametric value associated with point Pi\nˆ\nui = ui/d\n(8.3)\nwhich is normalized as ui 2 [0, 1] with u1 = 0 and uN = 1.\n2. Linear equations\nA cubic B ezier curve is defined as\nQ(u) =\nQiBi,3(u), 0 u 1\n(8.4)\ni=0\nwhere Bi,3(u) are the cubic Bernstein polynomials.\n\nX\nObviously, the boundary conditions require Q0 = P1, Q3 = PN . The problem is\nthen represented as a linear system with N - 2 equations and 2 unknowns:\nQiBi,3(uj )\n= Pj - P1B0,3(uj ) - PN B3,3(uj )\ni=1\n= Lj ,\nj = 2, 3, ..., N - 1\n(8.5)\nB\nor in matrix form\n(N -2)×2 · q2×1 = l(N -2)×1\n(8.6)\n3. Least Squares Method\nDefine the mean square error as\nE2 = |B · q - l|2\n(8.7)\nthen\nE2 =\n(B · q - l)T (B · q - l)\n= q T BT Bq - 2q T BT l + lT l\n(8.8)\nis a function of q and is minimized if we set\nθE2\n= 0 ≤ BT Bq - BT l = 0\n(8.9)\nθq\n≤ BT Bq = BT l\n(normal equations)\n(8.10)\n≤ q = (BT B)-1BT l (formal solution)\n(8.11)\nThe extension to fitting with B-splines is similarly formulated.\nNotes:\n1. The choice of internal knots in the B-spline basis should reflect any knowledge of deriva\ntive discontinuity in the data, as shown in Figure 8.1.\n2. Greater density of knots is needed in rapidly changing parts of the shape.\n3. NAG routines for approximate fitting of cubic B-splines [9]\n(a) Curves: E02BAF\n(b) Surfaces: E02DAF & E02ZAF\n4. NAG routines on least square problems provide more flexibility.\n\nDouble knot for cubics\nFigure 8.1: Set of data reflecting a possible discontinuity of tangent vector.\n8.2\nFairing of Curves and Surfaces\n8.2.1\nProperties and Definition\nMotivation:\n1. Spline curves resulting from\n(a) interpolation of points;\n(b) manipulation of polygon, usually need fairing.\n2. Screen plots ( small resolution ) are misleading concerning curve quality.\n3. Full scale plots.\n4. Curvature plots are useful as they allow isolation of problem areas on raster devices.\nProperties of fair curves: [3, 4]\n1. Curvature continuity ( C2 ).\n2. Curvature is almost piecewise linear with as few spans as possible.\nFor cubics with simple knots, property (1) is automatically satisfied. If R(t) is reasonably\nparametrized, |R0(t)| is constant, and the curvature\nρ(s) = |R0(t) × R00(t)|\n|R0(t)|3\n∈|R00(t)|\n(8.12)\nProperty (2) thus requires that |R00(t)| be almost piecewise linear. That means that\nR000(t) needs to be constant, which leads to the following definition of fairness.\nQ\nDefinition: Q, R are two C2 cubic splines in t 2 [a, b]. Q is fairer than R if for r 2 [a, b],\n+) -Q000\n+) -R000\n[\n(r\n(r -)]2 [R000(r\n(r -)]2\n(8.13)\nIf r is a knot at which interpolation of data occurs, the above expression means that\nreducing \"shear\" forces from supports increases the fairness of splines, if we consider\ngeometric splines as approximations of physical splines.\n\n8.2.2\nCurve Interrogation\nWe interrogate the fairness of a spline curve by looking into the planar projection of their\ncurvature. The signed curvature is defined as\nx00y0 - x y\nρ(u) =\n(8.14)\n(x02 + y02) 2\nand it is easy to point out the changes of sign ( inflections ). The curve is fair if a plot of ρ(u),\nwhich is made up of a few monotone segments, is continuous. The aim of the fairing process is\nto locate the places of maximum discontinuity of ρ0(u) and fair those places (see figure (8.2)).\nκ(u)\nu\nFair here\nFigure 8.2: Plot of curvature ρ(u) along curve as a function of u.\n8.2.3\nFairing Methods\nAssume that we have a spline curve obtained by interpolation of measured data. The curve\ngenerally has unwanted behavior. Curve fairing eliminates imperfections by changing data\nwithin a measurement tolerance.\n1. Kjellander's Method [7]\nProcedure\n(a) Obtain data points Pj (tj ), 1 j N .\n(b) Fit the points with a spline R(t).\n+\nj )-R000(t-\n(c) Find the knot where max|R000(t\nj )| occurs and attempt fairing at PJ where\nj = J corresponds to the worst jump.\n(d) Using Hermite or B ezier, construct cubic interpolation Q(t), which interpolates\nR(tJ -1) = PJ -1\n(8.15)\nR(tJ +1) = PJ +1\n(8.16)\nR0(tJ -1)\n,\nR0(tJ +1)\n(8.17)\n\nX\nX\nh\ni\n<\nPj-1\nPj\nPj+1\nR(t)\npoint to\nbe faired\nRnew(tj)\nFigure 8.3: Kjellander's fairing method\n(e) Determine new curve\n⎟\nR(t) if t ⇒2 [tJ -1, tJ +1]\n(8.18)\nRnew(t) =\nQ(t) if t 2 [tJ -1, tJ +1]\n(f) Compute Rnew(tJ ). Notice that Rnew(t) is infinitely differentiable there.\n(g) Construct a spline curve on P1, · · · , PJ -1, Rnew(tJ ), PJ +1, · · · , PN .\n(h) The resulting curve is usually fairer at tJ .\nDisadvantages\n- Global scheme.\n- Repeated interpolation.\n2. Farin's Method [4]\nRecall Boehm's knot insertion method\nn\nn+1\nˆ ˆ\nPiNi,4(t) =\nPiNi,4(t)\n(8.19)\ni=0\ni=0\nˆ\n[t0, t1, · · ·] ≤ t0, · · · , tl, t, tl+1, · · ·\n(8.20)\nand the control points are\nˆPi = τiPi + (1 - τi)Pi-1\n(8.21)\nwhere\n⎧ 1\n0 i l - 3\n⎧\nτi =\nl + 1 i n + 1\n(8.22)\n⎧\n⎧\ntˆ-ti\n⎠\nl - 2 i l\nti+3 -ti\nHence\nˆPi = Pi\n0 i l - 3\nˆPi = Pi-1\nl + 1 i n + 1\nˆPi = τiPi + (1 - τi)Pi-1\nl - 2 i l\n(8.23)\n\n- Idea of Farin's method\n(a) Remove a knot first to make curve infinitely differentiable at that location such that\nthe curve is fairer now in that area.\n(b) Insert the removed knot back so as to have the same knot vector (if needed; not\nusually necessary).\n- Knot removal\nKnot removal is an inverse process of knot insertion. From Equations (8.23), we have\nˆ\nPi = Pi,\ni = 0, 1, · · · , l - 3\nˆ\nτiPi + (1 - τi)Pi-1 = Pi, i = l - 2, l - 1, l\nˆ\nPi = Pi+1,\ni = l, l + 1, · · · , n\n(8.24)\nHere we have n + 2 equations and n + 1 unknowns, therefore, an approximate solution\ncan be obtained by the least squares method.\nA sample solution using Farin's method:\nˆ\nPi = Pi,\ni = 0, 1, · · · , l - 3\nˆ\nPi = Pi+1, i = l, l + 1, · · · , n\n(8.25)\nand from the least squares method, we have the following equations for Pl-2, Pl-1\n⎨\n⎛\n⎨\n⎛\nˆ\nPl-3\nτl-2\n⎝\n⎞\nPl-2 - (1 - τl-2) ˆ\n⎩\n⎜\n⎩\nτl-1\n⎜\nPl-2\n= ⎩ ˆ\n⎪ 1 - τl-1\nA\n⎜\n(8.26)\n⎪ Pl-1\nA\n1 - τl\nPl-1\nˆ\nˆ\nPl - τlPl+1\nor in the matrix form\nA · p = f ≤ AT Ap = AT f\n(8.27)\nwhich yields\np = (AT A)-1AT f\n(8.28)\nThis should be followed by knot insertion to complete the fairing process (if necessary).\n- Knot insertion\nˆ\nT = [t0, · · · , tl, t, tl+1, · · ·] = [T0, · · · , Tl, Tl+1, Tl+2, · · ·]\n(8.29)\nwhere the removed knot tˆ is inserted as the knot Tl+1. Hence the control points of the\nfaired curve can be determined by the knot insertion method ( Equation 8.23), where\ntˆ- tl\nTl+1 - Tl\nt\nτl =\n=\nl+3 - tl\nTl+4 - Tl\ntˆ- tl-1\nTl+1 - Tl-1\nt\nτl-1 =\n=\nl+2 - tl-1\nTl+3 - Tl-1\ntˆ- tl-2\nTl+1 - Tl-2\nt\nτl-2 =\n=\n(8.30)\nl+1 - tl-2\nTl+2 - Tl-2\n\nX\nX\nX\nIf we remove all or many of the knots as in Figure 8.5, the other constraints (such as\ndeviation) will dominate the problem.\nLet the curve obtained by either interpolation or approximation be\nn\nR(t) =\nRiNi,4(t)\n(8.31)\ni=0\nand the curve after knot removal be\nm\n\nR0(t) =\nQiNi,4(t)\n(8.32)\ni=0\nwhere m < n. Then, (n - m) knots removed before are inserted to make R0(t) have the\nsame knot vector as R(t), such that\nn\nR0(t) =\nQiNi,4(t)\n(8.33)\ni=0\nwhere Qi, 0 i n, are new control points determined by knot insertion, and Ni,4(t)\nare B-spline basis function over the same knot vector as that of R(t).\nThe deviation of two B-spline curves\nn\nX\n|R(t) - R0(t)| = |\n(Ri - Qi)Ni,4(t)|\n(8.34)\ni=0\nn\nX\nmax\ni |Ri - Qi|\ni=0\nNi,4(t)\n(8.35)\n= max\ni |Ri - Qi|\n(8.36)\nremove all\nthe knots\nFigure 8.5: Deviation of fair curve.\n\n8.2.4\nSurface Fairing\n- Differential Geometry Review\nLet ρ1, ρ2 be principal curvatures, then\nGaussian curvature G = ρ1ρ2\n(8.37)\nmean curvature H = 2 (ρ1 + ρ2)\n(8.38)\nabsolute curvature K = |ρ1| + |ρ2|\n(8.39)\nLocal Taylor expansion is\n1(ρ1x 2\nz =\n+ ρ2y 2) + h.o.t.\n(8.40)\n1. Elliptic case: G = ρ1ρ2 > 0, see Figure 8.6(a).\n- convex surface\n- one side of tangent plane\n- no inflection\n2. Hyperbolic case: G = ρ1ρ2 < 0, see Figure 8.6(b).\n- non-convex surface (locally)\n- intersection with tangent plane\n- surface inflection\nZ\nκ1\nκ2\nY\nZ\nY\nX\nX\nFigure 8.6: (a) Elliptic case; (b) Hyperbolic case.\nDefinition 1 Surface inflection at a point P exists iff the surface crosses the tangent plane at\nP.\nIf G < 0, surface inflection at P.\nIf G = 0 in a region ( e.g., a \"cylinder\" ), then surface inflection exists in the region if H\nchanges sign in the region ( not one point).\n\nDefinition 2 Surface curve inflection exists at a point P of a surface iff a planar surface curve\nthrough P changes sign of its curvature at P.\nSurface curve inflection ≤ Surface inflection\n- Surface Interrogation\n1. Gaussian curvature is not useful in \"cylinders\" where G = 0.\n2. Mean curvature is zero for minimal surfaces where ρ1 = ρ2.\n3. Absolute curvature does not have such problems. Its curvature plots are useful in study\ning surface imperfections ( e.g., small oscillations ).\n4. Reflection lines for parallel line light source ( on raster screen, mark points where normal\npasses through source ) are useful for global imperfection detection.\nSurface fairing may be performed by fairing auxiliary curves defined for each of the columns\nand rows of the control polyhedron.\n\nGeneralized Cylinders\n8.3\nGeneralized Cylinders: Motivation and Definitions\nGeneralized cylinders [12, 13, 15, 8] or sweeps provide greater generality for shape representa\ntion than tensor product surfaces. A generalized cylinder is a representation of an elongated\nobject viewed as having a main axis (directrix or spine) and a smoothly varying cross section\n(generatrix), as defined in Figure 8.7. Both directrix and generatrix can be open or closed\n(periodic) curves.\n8.3.1\nApplications\nSome of the more common applications of generalized cylinders are\n- Representation of measured data (e.g. CAT scans, deformed solids).\n- Representation of manufacturing processes.\n- Representation of blends.\n- Object recognition and scene interpretation in robotics and computer vision.\n- Representation of human and animal shapes.\n\nGeneratrix\nDirectrix (Spine)\nFigure 8.7: Generalized cylinder.\n\n8.3.2\nDefinition\n- Given:\n1. A bounded 3-D curve serving as spine.\n2. A cross-sectional plane swept along the spine perpendicular to it so that the spine\npasses through the origin of the 2-D coordinate system on the plane.\n3. A cross-sectional curve on the cross-section plane defined locally in the cross-section\ncoordinate system, where the size and shape of the curve may vary with the param\neter along the spine curve.\n- The surface swept by the curve is a generalized cylinder.\n- Some examples of generalized cylinders and the resulting surfaces are:\n1. Spine = straight line, generatrix = circle =≤ CYLINDER\n2. Spine = circle, generatrix = circle =≤ TORUS\n3. Spine = straight line segment, generatrix = linearly tapering circles =≤ CONE\nMathematical description of generalized cylinders:\n- Directrix (spine): A = A(s), 0 s 1.\n- Generatrix: C = C(t; s) = [x(t; s), y(t; s), 0], 0 t 1.\n- Generalized cylinder surface patch: R(s, t) = A(s) + x(t; s)X(s) + y(t; s)Y(s),\nwhere X, Y, Z are orthogonal 3-D unit vectors with the Z tangent to A(s), i.e.\nA0(s)\nZ(s) = |A0(s)|\nAs an example, X(s), Y(s) could be chosen equal to the normal and binormal vectors of\nthe spine curve A(s) or by rotation of those by some angle, see Figure 8.8.\nProblems with generalized cylinder representation\nWhen A(s) is straight line, X(s), Y(s), Z(s) should be defined independent of the Frenet\ntrihedron, eg. using X(s), Y(s) as constants.\n\n∂C(t; s)\nˆk\n∂Y (s)\nO\nˆi\nˆj\n∂Z(s)\n∂X(s)\n∂A(s)\nt\nFigure 8.8: Components of a generalized cylinder.\nExamples:\na. Generalized Cylinders with B-Spline Spine and Generatrix Curves\nk\nX\nA(s) =\nAiNi,K (s)\ni=0\nl\nq\nX X\nC(t; s) =\nCij Ni,L(t)Nj,Q(s)\ni=0 j=0\n= [x(t; s), y(t; s), 0]\nwhere Ni,K (s), Ni,L(t) and Nj,Q(s) are B-spline basis functions or the Bernstein special\nizations.\nb. Pipe Surfaces (See also Section 11.6 of textbook [11])\nWhen the generatrix is a circle, the resulting generalized cylinder is a pipe surface.\nThe pipe surface PC(r) with radius r can be parametrized using the Frenet trihedron\n(t(t), n(t), b(t)) of the spine curve C(t) as follows:\nP(t, ) = C(t) + r[cos n(t) + sin b(t)]\n(8.41)\nwhere t 2 [0, 1] and 2 [0, 2].\n\n8.4\nDegeneracies of Generalized Cylinders\na. Local Self-Intersection\nb. Global Self-Intersection\nFigure 8.9: Types of self-intersection of generalized cylinders.\n∂X(s)\nˆn\n∂Y (s)\nˆt = ∂Z(s)\n[x(t; s)\n(t; s), 0]\nπ\nxi\ni\nplane\ncross-section\n, y\nstraight line\ncurvature\ncenter of\n, y\nFigure 8.10: Criterion to avoid local self-intersection of generalized cylinders.\nThere are two types of the degeneracies of generalized cylinders illustrated in Figure 8.9,\nnamely local self-intersection and global self-intersection. A condition to avoid local self-\nintersection of generalized cylinders is illustrated in Figure 8.10. The condition is\nmaxt (x 2 + y ) π2(s)\nfor all s, where π(s) is the radius of curvature of the spine.\n\nAs a special case, we consider local self-intersection of pipe surfaces (see also Maekawa et\nal. (1998) for details). The partial derivative of the pipe surface with respect to t is given by\nPt(t, ) = C0(t) + r[cos n (t) + sin b0(t)].\n(8.42)\nEquation (8.42) can be rewritten using the Frenet formulae ( n0(t) = |C0(t)|(-ρ(t)t + δ(t)b),\nb0(t) = -|C0(t)|δ(t)n ) as\nPt(t, ) = |C0(t)|(1 - ρ(t)r cos )t - r|C0(t)| sin δ(t)n + r|C0(t)| cos δ(t)b\n(8.43)\nP\nwhere ρ(t) and δ(t) are the curvature and torsion of the spine curve. Similarly we can derive\nas\nP (t, ) = r[- sin n(t) + cos b(t)].\n(8.44)\nThe surface normal of the pipe surface can be obtained by taking the cross product of equations\n(8.43) and (8.44) yielding\nPt × P = -|C0(t)|r[1 - ρ(t)r cos ][sin b(t) + cos n(t)].\n(8.45)\nIt is easy to observe that the pipe surface becomes singular (the normal vector vanishes) when\n1 - ρ(t)r cos = 0. Since cos varies between -1 and 1, there will be no local self-intersection if\nρ(t)r < 1. Therefore, to avoid local self-intersection we need to find the largest curvature ρmax\nof the spine curve and set the radius of the pipe surface such that r < 1/ρmax. Figure 8.11\nshows an example of local self-intersection.\nThe curvature ρ(t) of a space curve C(t), is given by\n|C0(t) × C00(t)|\nρ(t) =\n.\n(8.46)\n|C0(t)|3\nThus, to find the largest curvature ρmax we need to locate the critical points of ρ(t), i.e. solve\nthe equation ρ0(t) = 0, and decide whether they are local maxima. Then we compare these\nlocal maxima with the curvature at the end points, i.e. ρ(0) and ρ(1), and obtain the global\nlargest curvature. This problem can be solved by elementary calculus. If the spine curve is\ngiven by a rational B ezier curve, equation ρ0(t) = 0 reduces to a single univariate nonlinear\npolynomial equation. In the case where the spine curve is a rational B-spline, we can extract\nthe rational B ezier segments by knot insertion. Cho et al. [1] describe in detail how to obtain\nρ0(t) = 0 for integral B ezier curves.\nGlobal self-intersection of a pipe surface involves the following types of intersections:\n1. End circle to end circle: Two end circles of the pipe surface touch each other, see Fig\nure 8.12.\n2. Body to body: Two different body portions of the pipe surface touch each other, see\nFigure 8.13.\n3. End circle to body: One of the end circles touches the body, see Figure 8.14.\n\n-4\n-2\n-0.5\n0.5\nFigure 8.11: Local self-intersection\nThe theory of intersections and nonlinear solvers is needed to handle these global intersec-\ntion problems and we will discuss these later.\nLet ρmax be the maximum curvature of the spine curve, and ree, rbb, reb be the maximum\npossible upper limit radius of the pipe surface such that it does not globally self-intersect\nbetween end circle to end circle, body to body and end circle to body of the pipe surface,\nrespectively. Then we have\nTheorem Let p(r) be the pipe surface with spine curve c(t) and radius r. Then p(r) is\nnonsingular if and only if r < = min{1/ρmax, ree, rbb, reb}.\n2.2\n2.4\n2.6\n2.8\n3.2\n3.4\n3.6\n0.5\n1.5\n2.5\n2.5\n3.5\nFigure 8.12: End circle to end circle global self-intersection\n\n-0.2\n0.2\n0.4\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n-0.6\n-0.4\n-0.2\n0.2\n0.4\nFigure 8.13: Body to body tangential intersection and local self-intersection\n-0.3\n-0.2\n-0.1\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n-0.2\n0.2\n0.4\n0.6\nFigure 8.14: End circle to body tangential global and local self-intersections\n\n8.5\nProperties of Generalized Cylinders\n1. Unit normal vector\nRs × Rt\nˆn = |Rs × Rt|\n2. Radius of curvature of spine-\nA(s) = [x, y, z]\n|As|3\n= π(s)\n|As × Ass|\n(x2 + y + zs )\ns\ns\n=\n[(xsyss - ysxss)2 + (yszss - zsyss)2 + (zsxss - xszss)2]\n\n8.6\nDiscrete Generalized Cylinders\nUseful in the interpretation of measured data. The constructive definition for discrete gener\nalized cylinders is:\n1. Define a piecewise continuous spine.\n2. Obtain point measurements on cross-section curves on planes perpendicular to spine at\na discrete set of points on spine.\n3. Construct a local system of coordinates on each cross-section with origin on spine.\n4. Interpolate each cross-section with splines and establish parametric correspondence be\ntween cross-sections, see Figure 8.15.\n5. Establish an interpolation rule between cross-sections, x(t; si), y(t; si), z(t; si), (si), see\nFigure 8.15.\nb1\nt\nn\nt\nb\nn\nt\nb\nn\nb2\n'\nn 2\n'\nθ2\nθ1\nθ3\n= 0\n'\nb3\nn ' 3\nFigure 8.15: Cross sections along the spine curve\n\nBibliography\n[1] W. Cho, T. Maekawa, and N. M. Patrikalakis. Topologically reliable approximation of\ncomposite B ezier curves. Computer Aided Geometric Design, 13(6):497-520, August 1996.\n[2] Q. Ding and B. J. Davies. Surface Engineering Geometry for Computer-Aided Design and\nManufacture. Ellis Horwood, Chichester, UK, 1987.\n[3] G. Farin. Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide.\nAcademic Press, Boston, MA, 3rd edition, 1993.\n[4] G. Farin, G. Rein, N. Sapidis, and A. J. Worsey. Fairing cubic B-spline curves. Computer\nAided Geometric Design, 4(1-2):91-103, July 1987.\n[5] I. D. Faux and M. J. Pratt. Computational Geometry for Design and Manufacture. Ellis\nHorwood, Chichester, England, 1981.\n[6] J. Hoschek and D. Lasser. Fundamentals of Computer Aided Geometric Design. A.\nK. Peters, Wellesley, MA, 1993. Translated by L. L. Schumaker.\n[7] J. A. Kjellander. Smoothing of cubic parametric splines. Computer-Aided Design, 15:175-\n179, 1983.\n[8] T. Maekawa, N. M. Patrikalakis, T. Sakkalis, and G. Yu. Analysis and applications of\npipe surfaces. Computer Aided Geometric Design, 15(5):437-458, May 1998.\n[9] Numerical Algorithms Group, Oxford, England. NAG Fortran Library Introductory Guide,\nMark 18 edition, 2000.\n[10] J. Owen. STEP: An Introduction. Information Geometers, Winchester, UK, 1993.\n[11] N. M. Patrikalakis and T. Maekawa. Shape Interrogation for Computer Aided Design and\nManufacturing. Springer-Verlag, Heidelberg, February 2002.\n[12] J. Pegna. Variable Sweep Geometric Modeling. PhD thesis, Stanford University, Stanford,\nCA, 1987.\n[13] J. Pegna and D. J. Wilde. Spherical and circular blending of functional surfaces. In\nProceedings of the 7th International Conference on Offshore Mechanics and Arctic Engi\nneering, volume 7, pages 73-82, Houston, Texas, February 1988. New York:ASME, 1988.\n\n[14] L. A. Piegl and W. Tiller. The NURBS Book. Springer, New York, 1995.\n[15] U. Shani and D. H. Ballard. Splines as embeddings for generalized cylinders. Computer\nVision, Graphics and Image Processing, 27:129-156, 1984.\n[16] F. Yamaguchi. Curves and Surfaces in Computer Aided Geometric Design. Springer-\nVerlag, NY, 1988."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes9_fixed.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/71fa96c0e5276c09c49003b35a106c0c_lecnotes9_fixed.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 9\nN. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\nBlending Surfaces\n9.1\nExamples and motivation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n9.2\nBlending surface approximation in terms of B-splines . . . . . . . . . . . . . .\n9.2.1\nBlend construction through a procedural \"lofted\" surface . . . . . . . .\n9.3\nSpherical and circular blending in terms of generalized cylinders . . . . . . . .\n9.4\nBlending of implicit algebraic surfaces . . . . . . . . . . . . . . . . . . . . . . .\n9.5\nBlending as a boundary value problem\n. . . . . . . . . . . . . . . . . . . . . .\n9.5.1\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n9.5.2\nExample: 2nd order (Laplace) equation . . . . . . . . . . . . . . . . . .\n9.5.3\nMapping - boundary value problem . . . . . . . . . . . . . . . . . . . .\n9.5.4\nPosition and tangent plane continuity . . . . . . . . . . . . . . . . . . .\n9.5.5\nCurvature continuity . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n9.5.6\nMultisided blending surfaces . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\n\nLecture 9\nBlending Surfaces\n9.1\nExamples and motivation\nBlending surfaces, providing a smooth connection between various primary or functional sur-\nfaces, are very common in CAD. Examples include blending surfaces between:\n- Fuselage and wings of airplanes\n- Propeller or turbine blade and hub\n- Bulbous bow and ship hull\n- Primary faces of solid models.\nBlending (or filleting) surfaces are also byproducts of manufacturing processes such as NC\nmilling with a ball or disk cutter.\nAs a result of continuity conditions, blending surfaces are of higher order, or involve a more\ncomplex formulation than the underlying surfaces to be joined. For a detailed review, see\nWoodwark [15], and Hoschek and Lasser [9] (chapter 14).\n\nExample\nJoin bicubic patches along arbitrary cubic linkage curves in parametric space (see Figure 9.1).\nR(u , v )\nQ (w , s )\nv = v (t )\nu = u (t )\nw = w (t )\ns = s (t )\nFigure 9.1: Bicubic patches joined along arbitrary cubic linkage curves.\nLinkage curve 1 is:\nR1(t) ≡R(t) = R(u3, v3) ≡R(t18), if u = u(t3), v = v(t3)\n(9.1)\nSimilarly, curve 2 is:\nR2(t) ≡Q(t) = Q(w3, s3) ≡Q(t18), if w = w(t3), s = s(t3)\n(9.2)\nSo position continuity alone requires a high degree surface in the t parameter direction\n(of degree 18 in this example). High degree surfaces are expensive to evaluate (e.g. the de\nCasteljau or Cox-de Boor algorithms have quadratic complexity in the degree of the curve\nor surface), may lead to greater inaccuracy of evaluation (as the degree increases), and are\ndifficult to process in a solid modeling environment (e.g. through intersections). Consequently,\nresearchers have developed:\n- Approximations of blending surfaces with low order B-spline surfaces\n- Procedural definitions of blending surfaces (e.g. \"lofted\" surfaces, generalized cylinders)\nin order to reduce some of these problems.\n\n9.2\nBlending surface approximation in terms of B-splines\nLet us consider two parametric surface patches rm1n1(u, v), rm2n2(x, y) and linkage curves\nR1(t) = [u(t), v(t)], R2(t) = [x(t), y(t)] defined in the parameter spaces of the two patches,\nrespectively.\nThe unit normal to R1 that is tangent to the patch (see Figure 9.2):\nr1(t) = N × S1\n|N × S1|\n\nu = u(t)\nv = v(t)\n(9.3)\nwhere N = ru × rv is the normal to the patch, and S1 = u(t)ru(u(t), v(t)) + v(t)rv(u(t), v(t))\nwhere r = rm1n1(u, v). In general, N and S1 are high order polynomials. For example, when\nthe patch is bicubic and the linkage curve is cubic in the parameter space, we have\nN ∼ru × rv ∼u2v3u3v2 ∼u5v5 ∼t30\nS1 ∼ uru ∼t2u2v3 ∼t2t6t9 ∼t17\nNext, we introduce bias functions b1(t), b2(t) to control the shape of the blending surface\nand define:\nq1(t)\n=\nb1(t)r1(t)\n(9.4)\nq2(t)\n=\nb2(t)r2(t)\n(9.5)\nto be used as parametric derivatives of the patch in the direction between the linkage curves.\nFor details, see Bardis and Patrikalakis [1].\nN\n1(t)\nR\nr\nS\nFigure 9.2: N, S1 r1 frame\n\n9.2.1\nBlend construction through a procedural \"lofted\" surface\nHere we use cubic Hermite polynomials as blending functions in the direction between the\nlinkage curves:\nH1(w)\n=\n1 -3w2 + 2w3\n(9.6)\nH2(w)\n=\n3w2 -2w3\n(9.7)\nH3(w)\n=\nw -2w2 + w3\n(9.8)\nH4(w)\n=\nw3 -w2\n(9.9)\nThese obey the following boundary conditions:\nH1(0) = 1\n,\nH1(1) = H′\n1(0) = H′\n1(1) = 0\n(9.10)\nH2(1) = 1\n,\nH2(0) = H′\n2(0) = H′\n2(1) = 0\n(9.11)\nH′\n3(0) = 1\n,\nH3(0) = H3(1) = H′\n3(1) = 0\n(9.12)\nH′\n4(1) = 1\n,\nH4(0) = H′\n4(0) = H4(1) = 0\n(9.13)\nThen the blending surface is:\nB(w, t) = R1(t)H1(w) + R2(t)H2(w) + q1(t)H3(w) + q2(t)H4(w)\n(9.14)\nwhere R1, R2 are evaluated using a composition mapping (due to high degree, explicit expres-\nsions are avoided, e.g. degree 18 for cubics), and q1, q2 are similarly evaluated procedurally\n(to avoid explicit expressions), given that:\nr1\n∼\nt47/\n√\nt47\n(9.15)\nq1\n∼\nt50/\n√\nt47\n(9.16)\nNext, we construct cubic B-spline approximations to R1, R2, q1, q2:\nR1(t)\n∼=\nn\nX\nl=0\nR(1)\nlNl,4(t)\n(9.17)\nR2(t)\n∼=\nn\nX\nl=0\nR(2)\nlNl,4(t)\n(9.18)\nq1(t)\n∼=\nn\nX\nl=0\nQ(1)\nlNl,4(t)\n(9.19)\nq2(t)\n∼=\nn\nX\nl=0\nQ(2)\nlNl,4(t)\n(9.20)\nwhere Nl,4(t) are cubic non-uniform B-spline basis functions and the same knot vector and\nnumber of control points is used in all four equations.\nThis approximation involves a process for the insertion of knots until errors are less than\nspecified tolerances for the previous four vector functions.\n\nThe equation for the resulting blending surface is:\nB(w, t)\n=\nX\nk=0\nn\nX\nl=0\nBk,l\nB ezier\nz\n}|\n{\nBk,4(w)\nAbove\nB-spline\nz }| {\nNl,4(t)\n(9.21)\nBw(w, t)\n=\nn\nX\nl=0\nX\nk=1\n(Bk,l-Bk-1,l)Bk,3(w)Nl,4(t)\n(9.22)\nFrom position and derivative continuity we get:\nB0,l\n=\nR(1)\nl\n(9.23)\nB3,l\n=\nR(2)\nl\n(9.24)\nB1,l\n=\nR(1)\nl\n+ Q(1)\nl/3\n(9.25)\nB2,l\n=\nR(2)\nl\n-Q(2)\nl/3\n(9.26)\nThe disadvantage of approximation is the increase in data and the resulting storage re-\nquirements. The advantage is that the same class of functions is used which makes it easy to\ninclude in a geometric modeler and easy to transfer between CAD/CAM systems.\nSpecial attention needs to be given to the correspondence of parametrization of linkage\ncurves and this may necessitate reparametrization of linkage curves.\nSee Bardis and Pa-\ntrikalakis [1], and Hansmann [7] for more details on these issues.\nt\nt\nFigure 9.3: Blending surface cross-link curves.\n\n9.3\nSpherical and circular blending in terms of general-\nized cylinders\nFor a detailed reference on this topic, see Pegna [12].\ne\ne\ne\nΠ\nψ\nφ\nO'\nO\nE\nC\na\nu\nRs\nFigure 9.4: Model of milling via a spherical ball cutter (3-axis milling) or a disk cutter (5-axis).\nThe center of the sphere (or spherical cutter) moves on the intersection curve of the offsets\nof the plane Π and cylinder C of radius Rc by an offset amount equal to Rs, i.e. ellipse E (see\nFigure 9.4).\nLet a be a unit vector along the cylinder axis, e3 a unit vector perpendicular to plane Π,\nand O the intersection of the cylinder axis and the plane. Also,\ne1\n=\ne3 × a\n|e3 × a|\n(9.27)\ne2\n=\ne3 × e1\n(9.28)\na\ne2\ns\nR\nO\nO'\ne3\nφ\nRc\nR + R\nc\ns\ne\nO\nR\nψ\ne1\n(R + R )/cos φ\ns\nc\nR + R\ns\nc\n'\nFigure 9.5: Definition of the ellipse.\nFind the directrix E, an ellipse. The center of E is [0, -Rs tan φ, Rs] = RO′. The major\naxis is (Rs + Rc)/ cos φ along e2. The minor axis is Rs + Rc in the direction parallel to e1.\na = [0, -sin φ, cos φ]\n(9.29)\n\n- The equation of the ellipse is (see Figure 9.5):\nR(ψ) = RO′ + e1(RC + Rs) cos ψ + e2\nRc + Rs\ncos φ\nsin ψ\n(9.30)\n- The projection of the center of the sphere (or projection of the ellipse) on the plane is:\ntp = (Rc + Rs) cos ψe1 +\n\"Rc + Rs\ncos φ\nsin ψ -Rs tan φ\n#\ne2\n(9.31)\n- tc: Projection of R (equation of the ellipse that is the center of the sphere) to the\ncylinder.\nP: Projection of R onto the axis a.\nv = P -R\n|P -R|\n(unit normal)\n(9.32)\nΠ\na\nR O'\nP\ntc\nRs\nRs\nR\nRc\nv\npt\nFigure 9.6: Side view.\nObserve that:\nP -RO′\n=\n((R -RO′) · a)a\n(9.33)\n=\na(-1) tan φ sin ψ(Rc + Rs)\n(9.34)\nP -R\n=\n(P -RO′) -(R -RO′)\n(9.35)\n=\n-(Rc + Rs) tan φ sin ψ[0, -sin φ, cos φ] -\n(9.36)\n(Rc + Rs)[cos ψ, sin ψ\ncos φ, 0]\n(9.37)\nP -R\n=\n(Rc + Rs)[-cos ψ, -sin ψ cos φ, -sin φ sin ψ]\n(9.38)\nv\n=\nP -R\n|P -R|\n=\n-[cos ψ, sin ψ cos φ, sin φ sin ψ]\n(9.39)\nHence,\ntc = R + Rsv\n(9.40)\n\nwhere\nR(ψ)\n=\n\"\n(Rc + Rs) cos ψ, Rc + Rs\ncos φ\nsin ψ -Rs tan φ, Rs\n#\n(9.41)\ntc\n=\n\"\nRc cos ψ, Rc sin ψ\ncos φ\n+ RS\nsin ψ\ncos φ -tan φ -sin φ cos φ\n!\n,\n(9.42)\nRs(1 -sin φ sin ψ)\n#\nwhich simplifies to\ntc\n=\n\"\nRc cos ψ, Rc sin ψ\ncos φ\n+ Rs tan φ(sin ψ sin φ -1), Rs(1 -sin φ sin ψ)\n#\n(9.43)\nNotice that v is in the normal plane to the directrix:\nv · Rψ = 0\n(9.44)\nwhere\nRψ =\n\"\n-(Rc + Rs) sin ψ, Rc + Rs\ncos φ\ncos ψ, 0\n#\n(9.45)\nHence, the generatrix is the arc of a great circle of the sphere on the plane tc -R, tp -R\nbetween tc and tp. The angle of the arc is\nθ = cos-1(-e3 · v) = cos-1(sin φ sin ψ)\n(9.46)\nin the local n, b system of the directrix.\nq(v, ψ) = Rs[sin θvn -cos θvb]\nfor v ∈[0, 1]\n(9.47)\nwhere\nb\n=\ne3\n(9.48)\nt\n=\nRψ\n|Rψ|\n(9.49)\nn\n=\ne3 × t\n(9.50)\nSetting ψ = 2πu for u ∈[0, 1], the blending surface is:\nB(u, v) = R(ψ(u)) + q(v, ψ(u))\n(9.51)\nNote that the surface is not a rational polynomial surface.\nThis result generalizes to spherical blends of general surfaces.\nA schematic diagram of\nspherical blends of surfaces is shown in Figure 9.7. The implementation is procedural and\ninvolves intersections of offset surfaces [11, 10] to define the directrix and the projection of a\npoint on a surface to define the generatrix [14].\n\nOffsets\nIntersection of offsets\nFigure 9.7: Spherical blends of surfaces\n\n9.4\nBlending of implicit algebraic surfaces\nFor a detailed reference, see Hoffmann and Hopcroft [8].\nGiven the implicit algebraic surfaces G, H defined as:\nG(x, y, z) -s\n=\nH(x, y, z) -t\n=\n)\npotential surfaces\n(9.52)\ndefine f(s, t) = 0, e.g:\nf(s, t)\n=\nb2s2 + a2t2 + a2b2 -2ab2s -2a2bt + 2λst\n(9.53)\nfs\n=\n2sb2 -2ab2 + 2λt\n(9.54)\nft\n=\n2ta2 -2ba2 + 2λs\n(9.55)\nn\n=\n(fs, ft)\n(9.56)\nn(a, 0)\n=\n[0, 2λs -2ba2] // t\n(9.57)\nb(0, b)\n=\n[2λb -2ab2, 0] // s\n(9.58)\nt\ns\nb\na\nAlso,\nf(a, 0)\n=\n2b2a2 -2a2b2\n=\n(9.59)\nf(0, b)\n=\n(9.60)\nor\nf\n=\nis tangent to s axis at (a, 0)\n(9.61)\nf\n=\nis tangent to t axis at (0, b)\n(9.62)\nTheorem: f(G, H) = 0 is tangent to H = 0 on the curve G-a = H = 0, and it is tangent\nto G = 0 on the curve H -b = G = 0.\nExample: If G, H are quadrics, then the blend is quartic.\nHigher order continuity can be achieved by selecting appropriate f = 0.\nNote: For well-formed \"elliptical blend\" -ab < λ < ab (circle for a = b and λ = 0).\nApplicability: Low order algebraics need ray tracing, and generally lack parametrization.\n\n9.5\nBlending as a boundary value problem\n9.5.1\nIntroduction\nThe motivation for blending surfaces is the need to generate a \"secondary\" surface as a bridge\nbetween primary surfaces, not just for manufacturing purpose, but also for functional, aesthetic,\nor design purposes. We can view this as a problem where:\n- The boundaries are specified;\n- The conditions to be met at the boundaries are also specified.\nWe need to find a smooth surface over some domain that satisfies the boundary conditions. In\nother words, we want a smoothing or averaging process.\nThe problem suggests itself as a boundary value problem in which an elliptic partial dif-\nferential equation (PDE) needs to be solved subject to imposed boundary conditions. This\napproach was proposed and developed by Bloor and Wilson and their students at the Univer-\nsity of Leeds, UK, [2, 3, 4, 5].\nSuppose L is a linear partial differential operator over the domain shown in Figure 9.8.\nLφ = f\nΩ\nconditions\non φ, φn etc.\nΩ\nn\nFigure 9.8: Linear partial differential operator.\n\n9.5.2\nExample: 2nd order (Laplace) equation\n(2-D)\n∂2φ\n∂x2 + ∂2φ\n∂y2 ≡∇2φ = 0\n(9.63)\nWe can see this as averaging process from analysis.\nAnalytic approach\ndl\nΩ\nP\nφ = φ 0\n2φ = 0\nΩ\nFigure 9.9: Analytic approach.\nφp = -1\n2π\nZ\n∂Ω\n∂G\n∂n φ0dl\n(9.64)\nwhere φ = φ0 on ∂Ω, G is the Green's function (source like) that satisfies (see Figure 9.9):\nG = 0 on ∂Ω\n(9.65)\nExcept at P,\n∂2G = 0\nin\nΩ\n(9.66)\nG ∼ln r\nat\nP\n(9.67)\n\nNumerical approach\nh\nh\nX\nY\nφ1\nφ2\nφ3\nφ4\nP\nCover region\nwith mesh\nFigure 9.10: Numerical approach.\nIf we use finite differences to solve Laplace's equation, then (see Figure 9.10):\nφp = 1\n4(φ1 + φ2 + φ3 + φ4)\n(9.68)\nAnother example PDE is the 4th order biharmonic equation:\n∇4φ = 0\n(9.69)\nwhere\n∇4φ = ∇2(∇2φ) = φxxxx + 2φxxyy + φyyyy\nwhich we do not study in these notes.\n\nNumerical Example\nWe now give a specific numerical example, where x, y are independent variables, z is a depen-\ndent variable (φ), and Ω\n0 ≤x ≤2 : 0 ≤y ≤2.\nZ\nY\nX\nsemi-circles\nO\nFigure 9.11: Boundary conditions for Laplace equation example.\nBoundary conditions - function only (position) because PDE is 2nd order, see Figure 9.11.\nz = [1 -(1 -y)2]\nx = 0, 0 ≤y ≤2\n(9.70)\nz = [1\n4 -(y -1\n2)2]\nx = 2, 0 ≤y ≤1\n(9.71)\nz = [1\n4 -(y -3\n2)2]\nx = 2, 1 ≤y ≤2\n(9.72)\nz = 0\ny = 0\ny = 2\n)\n0 ≤x ≤2\n(9.73)\nLimitations:\n- inappropriate continuity at boundaries\n- multi-valued surfaces would prove difficult (and involve awkward division of region).\nHigher order continuity =⇒higher order PDE. The function and 1st normal derivative -→\n4th order (tangent plane continuity). The function and 1st and 2nd derivatives -→6th order\n(curvature continuity).\nRather than use physical coordinates (e.g. x, y) as independent variables, introduce para-\nmetric coordinates u, v embedded in the surface with x, y, z as dependent variables.\nThe surface given parametrically as:\nx = x(u, v)\nx = (x, y, z)\n(9.74)\nThis mapping is determined as a solution to three boundary value problems (one for each\ncoordinate).\nNote that this mapping is not given explicitly in terms of polynomials or B-splines.\n\nTrimlines\nPrimary surface\nBlend surface\nu = constant\nv = constant\nPhysical space\nmapping\nParametric space\nv\nu\nFigure 9.12: Typical blending problem.\n\n9.5.3\nMapping - boundary value problem\nu = constant\nv= constant\nu = constant\nv=constant\nu = constant\nu = constant\nperiodic in v\nFigure 9.13: Diagrammatic representation of trimlines for non-periodic and periodic cases.\nTo determine the mapping we need to specify the partial differential equation and the\nboundary conditions. Both depend on degree of continuity required in the blend.\nPosition continuity\nWe specify the value of function x at the boundary. Hence, we require 2nd order PDE. Consider\na modification of the Laplacian operator:\nD2 = ∂2\n∂u2 + a2 ∂2\n∂v2\n(9.75)\nAt this stage, restrict a to be a constant. This parameter controls relative \"smoothing.\" To\nobtain the surface in parametric form (mapping), solve:\nD2x = 0\n(9.76)\n(zero RHS in u, v space (Ω) at this stage) subject to x given on boundary ∂Ω.\nExample\nu = 0\n2π\nv\nu\nPeriodic\nin V\nParameter space\ncylinder radius 1\nz\ny\nx\nu = 1 is x + y = R (R>1)\non plane z=0\nR\nFigure 9.14: Cylinder and plane blending using PDE method.\n\nWe need x as a function of v on the trimlines. Parameterize on arc length:\nx(0, v) =\n\ncosv\nsinv\nH\n\nx(1, v) =\n\nRcosv\nRsinv\n\n(9.77)\nSolution by separation of variables:\nx =\n\nh\ncosh au + R-cosh a\nsinh a\nsinh au\ni\ncos v\nh\ncosh au + R-cosh a\nsinh a\nsinh au\ni\nsin v\nH(1 -u)\n\n(9.78)\nEffect of a\nFor small a (see Figure 9.15):\n[cosh au + R -cosh a\nsinh a\nsinh au] ∼1 + (R -1)u + O(a2)\n(9.79)\nFigure 9.15: Effect of small a.\nFor large a (see Figure 9.16):\n[cosh au + R -cosh a\nsinh a\nsinh au] ∼e-au + Rea(u-1) + O(e-a)\n(9.80)\nFigure 9.16: Effect of large a.\nNote that for some value of a, the blend is tangent to the cylinder. In fact, this occurs for\nR = cosh a.\n\nFigure 9.17: Blends between circular cylinder and inclined plane, with continuity of slope\nbetween blend and primary surfaces. Adapted from Bloor and Wilson [2]\n9.5.4\nPosition and tangent plane continuity\nWe know the value of the function x at the boundary and also we know the normal to the\nsurface at the boundary. With x = x(u, v) the normal is xu × xv. Hence we impose a normal\nderivative condition at the boundary in u, v space.\nHence, we use a 4th order PDE.\nIn particular, solve\nD4x = 0\nin Ω\n(9.81)\nwith\nx\n=\nxo\non ∂Ω\n(9.82)\nxn\n=\nxno\non ∂Ω\n(9.83)\nwhere xn is the directional partial derivative of x in the direction normal to the boundary, see\nFigure 9.18.\n\nΩ\nv\nu\nx(v)\nx (v)\nu\nx(u), x (u)\nv\nFigure 9.18: Normal derivative condition at the boundary.\n\n9.5.5\nCurvature continuity\nSurface curvature continuity has been studied theoretically, see Pegna and Wolter [13].\nPegna and Wolter derive a criterion for guaranteeing second-order smoothness or curvature\ncontinuity for blending surfaces. Curvature continuity across a linkage curve generally means\nthat the normal curvatures agree in every direction at every point along the linkage curve.\nThey prove the Linkage Curve Theorem which states that two surfaces joined with first-order\nor tangent plane continuity along a first-order continuous linkage curve can be shown to be\nsecond-order smooth if the normal curvatures on each surface agree in one direction other than\nthe tangent direction to the linkage curve, see Figure 9.19.\nN\nt\nFigure 9.19: Condition for curvature continuity\nFor a detailed review and a blending surface algorithm for G1 and G2 continuity, see Filkins\n[6].\n9.5.6\nMultisided blending surfaces\nBlending surfaces do not have to be topologically quadrilateral in shape. The following figures\nillustrate these general blending surfaces.\n\nFigure 9.20: Blends in geometric modelling [15]\nFigure 9.21: Generating n-sided patches with partial differential equations [2]\n\nBibliography\n[1] L. Bardis and N. M. Patrikalakis. Blending rational B-spline surfaces. In Eurographics\n'89, European Computer Graphics Conference and Exhibition, pages 453-462, Hamburg,\nF. R. of Germany, September 1989.\n[2] M. I. G. Bloor and M. J. Wilson. Generating blend surfaces using partial differential\nequations. Computer-Aided Design, 21(3):165-171, 1989.\n[3] M. I. G. Bloor and M. J. Wilson.\nRepresenting pde surfaces in terms of b-splines.\nComputer-Aided Design, 22(6):324-330, July/August 1990.\n[4] M. I. G. Bloor and M. J. Wilson. Local control of surfaces generated as the solutions to\npartial differential equations. Computers and Graphics, 18(2):161-169, 1994.\n[5] M. I. G. Bloor, M. J. Wilson, and H. Hagen. The smoothing properties of variational\nschemes. Computer Aided Geometric Design, 12(4):381-394, 1995.\n[6] P. C. Filkins, S. T. Tuohy, and N. M. Patrikalakis. Computational methods for blending\nsurface approximation. Engineering with Computers, 9(1):49-61, 1993.\n[7] W. Hansmann. Interaktiver entwurf und geometrische Beschreibung Glatter Uberg ange\nzwischen r aumlich gekr ummten Fl achenstrukturen. PhD thesis, University of Hamburg,\nGermany, 1985.\n[8] C. Hoffmann and J. Hopcroft. The potential method for blending surfaces and corners.\nIn Geometric Modeling: Algorithms and New Trends, pages 347-365. SIAM, 1987.\n[9] J. Hoschek and D. Lasser.\nFundamentals of Computer Aided Geometric Design.\nA.\nK. Peters, Wellesley, MA, 1993. Translated by L. L. Schumaker.\n[10] T. Maekawa.\nAn overview of offset curves and surfaces.\nComputer-Aided Design,\n31(3):165-173, March 1999.\n[11] T. Maekawa, W. Cho, and N. M. Patrikalakis. Computation of self-intersections of offsets\nof B ezier surface patches.\nJournal of Mechanical Design, Transactions of the ASME,\n119(2):275-283, June 1997.\n[12] J. Pegna. Variable Sweep Geometric Modeling. PhD thesis, Stanford University, Stanford,\nCA, 1987.\n\n[13] J. Pegna and F. E. Wolter. Geometrical criteria to guarantee curvature continuity of\nblend surfaces. Journal of Mechanical Design, Transactions of the ASME, 114(1):201-\n210, March 1992.\n[14] J. Pegna and F.-E. Wolter. Surface curve design by orthogonal projection of space curves\nonto free-form surfaces. Journal of Mechanical Design, ASME Transactions, 118(1):45-52,\nMarch 1996.\n[15] J. R. Woodwark. Blends in geometric modelling. In R. R. Martin, editor, The Mathematics\nof Surfaces II, pages 255-297. Clarendon Press, Oxford, 1987."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes10.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/f8dab768bd5cd00fe9ab304be34c6258_lecnotes10.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLectures 10 - 12\nN. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\n10.1 Overview of intersection problems . . . . . . . . . . . . . . . . . . . . . . . . .\n10.2 Intersection problem classification . . . . . . . . . . . . . . . . . . . . . . . . .\n10.2.1\nClassification by dimension . . . . . . . . . . . . . . . . . . . . . . . .\n10.2.2 Classification by type of geometry . . . . . . . . . . . . . . . . . . . . .\n10.2.3 Classification by number system . . . . . . . . . . . . . . . . . . . . . .\n10.3 Point/point \"intersection\" . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.4 Point/curve intersection\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.4.1 Point/Implicit curve intersection\n. . . . . . . . . . . . . . . . . . . . .\n10.4.2 Point/Parametric curve intersection . . . . . . . . . . . . . . . . . . . .\n10.4.3 Point/Procedural parametric (offset, evolute, etc.) curve intersection\n.\n10.5 Point/surface intersection\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.5.1 Point/Implicit (usually algebraic) surface intersection . . . . . . . . . .\n10.5.2 Point/Rational polynomial surface intersection . . . . . . . . . . . . . .\n10.5.3 Point/Procedural surface intersection . . . . . . . . . . . . . . . . . . .\n10.6 Curve/curve intersection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.6.1 Case D3: RPP/IA curve intersection . . . . . . . . . . . . . . . . . . .\n10.6.2 Case D1: RPP/RPP Curve Intersection\n. . . . . . . . . . . . . . . . .\n10.6.3 Case D2/D5: RPP/PP and PP/PP Curve Intersections . . . . . . . . .\n10.6.4 Case D6: PP/IA Curve Intersection . . . . . . . . . . . . . . . . . . . .\n10.6.5 Case D8: IA/IA Curve Intersection . . . . . . . . . . . . . . . . . . . .\n10.7 Curve/surface intersection . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.7.1 Case E3: RPP Curve/IA Surface Intersection\n. . . . . . . . . . . . . .\n10.7.2 Case E1: RPP Curve/RPP Surface Intersection . . . . . . . . . . . . .\n10.7.3 Case E2/E6: RPP/PP, PP/PP Curve/Surface Intersection . . . . . . .\n10.7.4 Case E7: PP Curve/IA Surface Intersection\n. . . . . . . . . . . . . . .\n\n10.7.5 Case E11: IA Curve/IA Surface Intersection . . . . . . . . . . . . . . .\n10.7.6 IA Curve/RPP Surface Intersection . . . . . . . . . . . . . . . . . . . .\n10.8 Surface/Surface Intersections . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.8.1 Case F3: RPP/IA Surface Intersection . . . . . . . . . . . . . . . . . .\n10.8.2 Case F1: RPP/RPP Surface Intersection . . . . . . . . . . . . . . . . .\n10.8.3 Case F8: IA/IA Surface Intersection\n. . . . . . . . . . . . . . . . . . .\n10.9 Nonlinear Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.9.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.10Local Solution Methods\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.11Classification of Global Solution Methods . . . . . . . . . . . . . . . . . . . . .\n10.12Subdivision Method (Projected Polyhedron Method)\n. . . . . . . . . . . . . .\n10.13Interval Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.13.1Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.13.2Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.13.3Interval Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.13.4Algebraic Properties\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10.13.5Rounded Interval Arithmetic and its Implementation . . . . . . . . . .\n10.14Interval Projected Polyhedron Algorithm . . . . . . . . . . . . . . . . . . . . .\n10.15Interval Newton method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\nReading in the Textbook\n- Chapters 4 and 5, pp. 73 - 160\n\nLectures 10 - 12\nIntersection Problems, Nonlinear\nSolvers and Robustness Issues\n10.1\nOverview of intersection problems\nIntersections are fundamental in computational geometry, geometric modeling and design,\nanalysis and manufacturing applications. Examples of intersection problems include:\n- Shape interrogation (eg. visualization) through contouring (intersection with a series of\nparallel planes, coaxial cylinders, and cones etc.)\n- Numerical control machining (milling) involving intersection of offset surfaces with a\nseries of parallel planes, to create machining paths for ball (spherical) cutters.\n- Representation of complex geometries in the \"Boundary Representation\" scheme; for\nexample, the description of the internal geometry and of structural members of cars,\nairplanes, ships, etc, involves\n- Intersections of free-form parametric surfaces with low order algebraic surfaces\n(planes, quadrics, torii).\n- Intersections of low order algebraic surfaces.\nin a process called boundary evaluation, in which the Boundary Representation is cre-\nated by \"evaluating\" the Constructive Solid Geometry model of the object. During this\nprocess, intersections of the surfaces of primitives (see Figure 10.1) must be found during\nBoolean operations.\nBoolean opertations on point sets A, B include (see Figure 10.2)\n- Union: A ∪B,\n- Intersection: A ∩B, and\n- Difference: A -B.\n\nFigure 10.1: Primitive solids.\n⇒⇒⇒\nFigure 10.2: Example of a Boolean operation: union.\nAll such operations involve intersections of surfaces to surfaces. In order to solve general\nsurface to surface intersection problems, the following auxiliary intersection problems (similar\nto distance computation problems used in CAM for inspection of manufactured objects) need\nto be considered\n- point/point (P/P)\n- point/curve (P/C)\n- point/surface (P/S)\n- curve/curve (C/C)\n- curve/surface (C/S)\nAll above types of intersection problems are also useful in geometric modeling, robotics,\ncollision avoidance, manufacturing simulation, scientific visualization, etc.\nWhen the geometric elements involved in intersections are nonlinear (curved), intersection\nproblems typically reduce to solving complex systems of nonlinear equations, which may be\neither polynomial or more general in character. Solution of nonlinear systems is a very com-\nplex process in general in numerical analysis and there are specialized textbooks on the topic.\nHowever, geometric modeling applications pose severe robustness, accuracy, automation, and\nefficiency requirements on solvers of a nonlinear systems as we will see later. Therefore, geo-\nmetric modeling researchers have developed specialized solvers to address these requirements\nexplicitly using geometric formulations.\n\n10.2\nIntersection problem classification\nIntersection problems can be classified according to the dimension of the problems and ac-\ncording to the type of geometric equations involved in defining the various geometric elements\n(points, curves and surfaces). The solution of intersection problems can also vary according to\nthe number system in which the input is expressed and the solution algorithm is implemented.\n10.2.1\nClassification by dimension\n- P/P, P/C, P/S\n- C/C, C/S\n- S/S\n10.2.2\nClassification by type of geometry\npolynomial\nProcedural\nPolynomial\n(algebraic)\n(eg. f(x, y) = 0, z = 0)\nImplicit\nRational\nParametric\n(eg. R = R(t) )\nFigure 10.3: Curve geometry classification\n1. Points\n- Explicit: R = R0; R = [x, y, z]\n- Procedural: Intersection of two procedural curves, procedural curve and surface, or\nthree procedure surfaces, eg. offset or blending surfaces.\n- Algebraic: f(R) = g(R) = h(R) = 0; where f, g, and h are polynomials.\n2. Curves\nA classification of curves is illustrated in Figure 10.3.\n- Parametric: R = R(t) A ≤t ≤B\n(a) Rational Polynomials (eg: NURBS, rational B ezier).\n(b) Procedural, eg: offsets, evolutes, ie. the locus of the centers of curvature of a\ncurve.\n- Implicit: These require solution of (usually nonlinear) equations\n\n(a) Algebraics (polynomial)\nf(R) = g(R) = 0\nspace\ncurves\nz = 0, f(x, y) = 0\nplanar\ncurves\n(b) Procedural offsets (eg. non-constant distance offsets involving convolution, see\nPottmann 1997)\n3. Surfaces\n- Parametric R = R(u, v) where u, v vary in some finite domain, the parametric\nspace.\n(a) (Rational) Polynomial (eg: NURBS, B ezier, rational B ezier etc.)\n(b) Procedural\n- offsets\n- blends\n- generalized cylinders\n- Implicit: Algebraics\nf(R) = 0\nwhere f is a polynomial.\n10.2.3\nClassification by number system\nIn our discussion of intersection problems, we will refer to various classes of numbers:\n- integer numbers;\n- rational numbers, m/n, n = 0, where m, n are integers;\n- floating point numbers in a computer (which are a subset of the rational numbers);\n- radicals of rational numbers, eg.\nq\nm/n, n = 0, where m, n are integers;\n- algebraic numbers (roots of polynomials with integer coefficients);\n- transcendental (e, π, trigonometric, etc.) numbers.\n- real numbers;\n- interval numbers, [a, b], where a, b are real numbers;\n- rounded interval numbers, [c, d], where c, d are floating point numbers.\nIssues relating to floating point and interval numbers affecting the robustness of intersection\nalgorithms are addressed in the next section on nonlinear solvers.\n\n10.3\nPoint/point \"intersection\"\n- Check if |R1 -R2| < ε, where ε represents the maximum allowable tolerance.\n- Choice of \"tolerances\" in a geometric modeller is difficult-an open question.\n- Lack of transitivity, see Figure 10.4:\nR1 = R2\nR2 = R3 ⇒R1 = R3\nR2\nR3\nε\nε\n.\n.\n.\nR1\nFigure 10.4: Intersections of points within a tolerance is intransitive.\n- What should ε reflect?\n\n10.4\nPoint/curve intersection\n10.4.1\nPoint/Implicit curve intersection\nR0 ∩{z = 0, f(x, y) = 0}\nwhere f(x, y) is usually a polynomial (and f(x, y) = 0 represents an algebraic curve). In an\nexact arithmetic context, we can substitute R0 in {z, f(x, y) = 0} and verify if the results are\nzero. Similarly, we could handle:\nR0 ∩{f(R) = g(R) = 0}\nwhere f(R) = g(R) = 0 represents an implicit 3D space curve.\nWhat does verify mean in \"floating point\" arithmetic?\n- Example A:\nLet z0 = 0 and x0, y0 satisfy\n|f(x0, y0)| < ε ≪1\n(10.1)\nwhere ε is a small constant and |f(x, y)| ≤1 in the domain of interest including (x0, y0),\nthen a \"distance\" check can be performed by:\n|f(x0, y0)|\n| ▽f(x0, y0)| < δ ≪1\n(10.2)\nprovided | ▽f(x0, y0)| = 0. Equation 10.1 is called the \"algebraic distance\" and Equa-\ntion 10.2 is called the \"non-algebraic distance\". The true geometric distance is given\nby:\nd = min|R -R0|;\nwhere R = (x, y),\nf(R) = 0\n(10.3)\nThe true geometric distance is difficult and expensive to compute (particularly for implicit\nf(R) = 0 and involves computing the global minimum of |R-R0|. Equation 10.2 results\nfrom the first order approximation of Equation 10.3 as derived by Taylor expansion and\nis exact when f(R) is represents a plane.\n\n.\nR0\ng(R) = 0\nf(R) = 0\nFigure 10.5: Curves meet at small angle.\n- Example B:\nR0 ∩{f(R) = g(R) = 0}\nWhen curves f = 0, g = 0 meet at a small angle ( ▽f\n|▽f| · ▽g\n|▽g| ∼= 1), then the condition\n|f| < ε and\nδ1 =\n|f|\n|▽f| < δ\n|g| < ε and\nδ2 =\n|g|\n|▽g| < δ\n(where |f|, |g|, δ1, δ2 are evaluated with R = R0 and ε, δ ≪1) are not enough to guarantee\nproximity of R0 to the intersection of f, g, see Figure 10.5.\nδ\nδ\nδ\nφ\ng\nf\nFigure 10.6: Approximate curves with straight lines.\nUsing a linear approximation, and letting\nφ = cos-1 | ▽f\n| ▽f| ·\n▽g\n| ▽g||\nbe the angle of intersection as in Figure 10.6 near the intersection point, a better criterion\nfor evaluating if R0 is near the intersection of f and g is\nδ3 = φ-1{ |f|\n| ▽f| +\n|g|\n| ▽g|} < δ ≪1\n\n10.4.2\nPoint/Parametric curve intersection\n1. Rational polynomial curves\nR0 ∩R = R(t)\nA ≤t ≤B\n- Brute force elementary method:\nWe solve each of the following three nonlinear polynomial equations separately and\nwe search for common real roots in A ≤t ≤B.\nx(t) -x0 = 0\n→\nt′\n1, · · · , t′\nn\ny(t) -y0 = 0\n→\nt′′\n1, · · · , t′′\nn\nz(t) -z0 = 0\n→\nt′′′\n1 , · · · , t′′′\nn\nIn principle, this elementary approach is \"easy\" for polynomials. However, in prac-\ntice, this process is complex and inefficient and prone to numerical inaccuracies.\n- Preprocessing and subdivision method\n- Use bounding box of R(t) to eliminate easily resolvable cases, with some level\nof subdivision (splitting) to reduce box size.\n- Concept of subdivision in rational arithmetic: To eliminate numerical error\nin the subdivision process (which can lead to erroneous decisions), rational\narithmetic may be employed (if the input coefficients of R(t) are rational or\nfloating point numbers). This can be easily done in object-oriented languages\nsuch as C++ using operator overloading.\n- Continue subdivision until box is small.\n- Then, we could use a numerical technique , such as:\nF(t) = min{|R0 -R(t)|2}\nt ∈D1 ⊂[A, B]\nand use some t from the interval D1 as the initial approximation. Use of the\nsquare of the distance function is necessary to avoid possible divergence of the\nderivative of the distance function, if it approaches zero.\n- If the minimization process converges to t0 and\nq\nF(t0) < δ, t = t0 is the desired\nsolution.\n- Implicitization (perhaps with box preprocessing) such as\n(x0, y0) ∩{x = x(t), y = y(t)}\nLet us consider an example where x(t), y(t) are quadratic polynomials (the curve is\na parabola). We will attempt to eliminate t to get a polynomial f(x, y) = 0 which\nthe x, y coordinates of all points on the curve satisfy. We start with the system\nx = a0t2 + b0t + c0\ny = a′\n0t2 + b′\n0t + c′\n⇒\na0t2 + b0t + c0 -x = 0\na′\n0t2 + b′\n0t + c′\n0 -y = 0\n\nwhich can be rewritten in matrix form as follows:\n⇒\n\nc0 -x\nb0\na0\nc0 -x\nb0\na0\nc′\n0 -y\nb′\na′\nc′\n0 -y\nb′\na′\n\nt\nt2\nt3\n\n=\n\n(10.4)\nThe maximum degree of t in the above vector is determined by the degree m of the\nx polynomial and the degree n of the y polynomial, and is given by m + n -1. In\nthis case m + n -1 = 3.\nA necessary and sufficient condition for the above system to be solvable is\n\nc0 -x\nb0\na0\nc0 -x\nb0\na0\nc′\n0 -y\nb′\na′\nc′\n0 -y\nb′\na′\n\n= f(x, y) = 0\nThe equation f(x, y) = 0 is the implicit equation of the curve. Consequently in an\nexact arithmetic context, we need to check if f(x0, y0) = 0, to verify if (x0, y0) is on\nthe initial curve.\nIn general, if\nx = x(tn),\ny = y(tn) ⇒F(xn, yn) = 0\nwhere n is the total degree.\n- Inversion: If f(x, y) = 0 then we could use the first 3 equations 10.4:\n\nb0\na0\nc0 -x0\nb0\na0\nb′\na′\n\nt\nt2\nt3\n\n= -\n\nc0 -x0\nc′\n0 -y0\n\n⇒t = φ(x0, y0)\nψ(x0, y0)\nWhere φ and ψ are polynomials in x0 and y0, and x0, y0 satisfy\nf(x0, y0) = 0\n- The method is efficient and (usually) accurate for n ≤3 (but no real guaran-\ntees on accuracy and robustness exist if the method is implemented in floating\npoint).\n- Subdivision methods are preferable for higher n, and as we will see later when\ncoupled with rounded interval arithmetic are robust, accurate and efficient.\nIntersection of points (x0, y0, z0) and 3D polynomial curves R = R(t) via implicit-\nization of such curves involves a process of projection on x, y plane and finding t0\nby inversion and verification of z0 = z(t0).\n\n10.4.3\nPoint/Procedural parametric (offset, evolute, etc.)\ncurve\nintersection\nR0 ∩R = R(t)\nA ≤t ≤B\n- In general there is no known and easily computable convex box decreasing arbitrarily\nwith subdivision!\n- An approximate solution method may involve minimization of\nF(t) = |R(t) -R|2\nwhere t ∈[A, B]. This would involve\n- Checking end points, ie. if F(A), F(B) are very small.\n- Initial estimate for the possible minima, perhaps using linear approximation of R(t)\nto start the process.\nHowever,\n- Convergence of the above minimization processes is not guaranteed in general.\n- There may exist more than one minima.\n- Convergence to local and not global minimum (where F(t) = 0 ) is possible.\nFor certain classes of procedural curves such as offsets and evolutes of rational curves\ninvolving radicals of polynomials, it is possible to use the \"auxiliary variable method\" to reduce\nthe point to curve intersection (or minimum distance) problem to a set of (a larger number\nof) nonlinear polynomial equations. Such systems can be solved robustly and efficiently using\nthe nonlinear solver describe in the next section.\n\n10.5\nPoint/surface intersection\n10.5.1\nPoint/Implicit (usually algebraic) surface intersection\nThe condition for R0 ∩{f(R) = 0}, where f(R) = 0 is an implicit surface, is:\n|f(R0)| < ε,\n|f(R0)|\n| ▽f(R0)| < δ\nwhere ε, δ are small constants.\n10.5.2\nPoint/Rational polynomial surface intersection\n1. Implicitization is possible for all such surfaces but computationally expensive and possi-\nbly inaccurate. For a tensor product rational polynomial surface with maximum degrees\nin u and v equal to m and n, of the form\nR = R(um, vn),\nthe implicit equation is\nf(xq, yq, zq) = 0\nwhere q ≤2mn\nTherefore, for m = n = 3 -→q ≤18, m = n = 2 -→q ≤8\nThe above method is useful for special surfaces such as cylindrical and conical ruled\nsurfaces, surfaces of revolution, etc.\nExamples:\n(a) Implicitization of a surface of revolution.\ny\nx\nz\nr\nr\nR(t)\nFigure 10.7: Surface of revolution.\n\nLet us consider a profile curve to be a rational polynomial of degree n, see Figure 10.7\nR(t) = [r(t), z(t)]\nBy simple implicitization of R = R(t), we get:\nfn(r, z) = 0\n(10.5)\nwhere n is the maximum total degree of f. Also,\nr2 = x2 + y2\n(10.6)\nNext we eliminate r from equations 10.5 - 10.6 by rewriting equations 10.5 - 10.6 as\nfollows:\nfn(r, z)\n=\na0(z)rn + a1(z)rn-1 + · · · + an(z) = 0\n⇒\n-r2 + (x2 + y2) = 0\nThe resultant of eliminating r from these two equations is\nD =\n\na0(z)\na1(z)\n· · ·\nan-1(z)\nan(z)\na0(z)\n· · ·\nan-2(z)\nan-1(z)\nan(z)\n-1\nx2 + y2\n· · ·\n-1\nx2 + y2\n...\n-1\nx2 + y2\n\n= 0\nand the degree of D ≡f(x, y, z) = 0 is 2n. An example is a torus (degree 4 algebraic\nsurface).\n(b) Implicitization of a cylindrical ruled surface\nx\ny\nˆn\nR(t)\nˆt\na\nz\nFigure 10.8: Cylindrical ruled surface.\n\nLet\nR(t) = [X(t), Y (t)]\nbe a degree n planar rational polynomial curve in the x, y plane. The resulting\nimplicit equation of the curve\nf(X, Y ) = 0\nis a polynomial of degree n. Let\na = [a1, a2, a3]\nbe a direction vector. Then the three equations\nx\n=\nX + ua1\ny\n=\nY + ua2\nz\n=\nua3\ndescribe a cylindrical ruled surface. Hence, the implicit surface equation becomes:\nf(x -z\na3\na1, y -z\na3\na2) = 0\nThis equation can be transformed to the standard form using a symbolic manipu-\nlation program such as Macsyma.\n(c) Implicitization of a conical ruled surface\nx\ny\nz\nR(t)\nu\nR0\nˆt\nFigure 10.9: Conical ruled surface.\nLet\nR0 = [x0, y0, z0]\nbe the apex of the conical ruled surface and\nR(t) = [X(t), Y (t)]\n\na degree n planar rational polynomial curve on the x, y plane. Its implicit equation\nf(x, y) = 0\nis a degree n polynomial. The equation of the resulting conical ruled surface is\nx\n=\nx0(1 -u) + Xu\ny\n=\ny0(1 -u) + Y u\nz\n=\nz0(1 -u)\nEliminating u = 1 -z\nz0 and solving for X, Y yields:\nf\n\nz0\nz0 -zx -\nx0\nz0 -z z,\nz0\nz0 -z y -\ny0\nz0 -z z\n\n= 0\nThis equation can be transformed to the standard form using a symbolic manipu-\nlation program such as Macsyma.\n2. Newton's method:\nSolve x0 = x0(u, v), y0 = y0(u, v) and verify the third equation. Use a linear approxi-\nmation to start the process. Preprocessing using convex bounding box should always be\nused, coupled with some level of subdivision.\n3. Convex box and possibly subdivision followed by minimization in 0\n≤\nu, v\n≤\n1 or\nwithin a rectangular subdomain of the following function (see Figure 10.10).\nF(u, v) = |R(u, v) -R0|2 ≥0\nA point u0, v0 where F(u0, v0) = 0 yields the solution.\nu\nv\nF(u,v)\nO\nFigure 10.10: Distance function squared\nIn order to solve this minimization problem, we need to compute\n- Minimum of all local minima of F(u, v) (Fu = Fv = 0) in domain;\n\n- Minimum of all local minima of boundary \"curves\" eg. F(0, v) (i.e. Fv = 0);\n- Values of F(u, v) at corners, ie. F(0, 0), F(0, 1), F(1, 0), F(1, 1);\nand then choose u0, v0 from above solutions where F(u0, v0) = 0.\nThe disadvantages of a minimization method are:\n(a) Initial approximation is required;\n(b) Possibility of divergence;\n(c) No guarantee that all minima are located.\n(We need to enhance confidence by\nsubdivision.)\n(d) First and second derivativers of F(u, v) are required.\nNote: When R = R(u, v) is a polynomial parametric surface patch, it is helpful to\nreformulate F(u, v) to\nF(u, v) =\nk\nX\ni=0\nm\nX\nj=0\nwijBi,k(u)Bj,m(n)\n(10.7)\nIf wij > 0 for all i, j then there is no solution. We could use wij to construct initial\napproximations for the various local minima to be computed by usual descent numerical\nmethods. These initial approximation may be obtained by discrete sampling or subdivi-\nsion.\nLet F(u, v) be expressed in the Bernstein basis, as in equation (10.7). Then, let us also\nexpress Fu, Fv in the Bernstein basis:\nFu(u, v)\n=\nk-1\nX\ni=0\nm\nX\nj=0\nAijBi,k-1(u)Bj,m(v) = 0\nFv(u, v)\n=\nk\nX\ni=0\nm-1\nX\nj=0\nBijBi,k(u)Bj,m-1(v) = 0\n(10.8)\nThe equations Fu(u, v) = 0 and Fv(u, v) = 0 represent planar algebraic curves illustrated\nin Figure 10.11. Their intersection are the required extrema from which the minima can be\nselected using elementary calculus.\nA geometrically motivated solution of the system 10.8 is possible using the convex hull\nproperty and subdivision to isolate an area where convex hulls intersect.\nTaking G(u, v) = Fu(u, v) and n = k -1 for example, we can write\nw = G(u, v) =\nn\nX\ni=0\nm\nX\nj=0\nAijBi,n(u)Bj,m(v)\nWe can reformulate this \"height\" function into a parametric surface as follows:\nw = [u, v, G]\n=\nX X\nLijBi,m(u)Bj,n(v)\nLij\n=\n[ i\nm, i\nn, Aij]\n\nv\nFv = 0\nFu = 0\nu\nFigure 10.11: Intersection of algebraic curves.\nw=0 curve\nw=1-u -v\n2 = 0\nw\nu\nv\nFigure 10.12: Control net\nTo solve Fu = Fv = 0, we find the projection of convex hulls of w(u, v) and of the corre-\nsponding surface for Fv on the coordinate planes u = 0, v = 0 , then intersect them with the\nlines w = 0, see Figure 10.12 for an example. A more detailed description of this procedure is\ngiven in the next section where a nonlinear solver is described.\n\n10.5.3\nPoint/Procedural surface intersection\nA procedural surface may be an offset surface or a generalized cylinder surface or a blending\nsurface. The typical solution method is minimization. In this case, no convex box assistance\nis possible in general, and we need a dense sampling for an initial approximation (which may\nbe expensive) and no rigorous guarantees for the solution's reliability are generally available.\nFor certain classes of procedural surfaces such as offsets and evolutes of rational surfaces\ninvolving radicals of polynomials, it is possible to use the \"auxiliary variable method\" to reduce\nthe point to surface intersection (or minimum distance) problem to a set of (a larger number\nof) nonlinear polynomial equations. Such systems can be solved robustly and efficiently using\nthe nonlinear solver describe in the next section.\n\n10.6\nCurve/curve intersection\nThe curve types we will consider can be classified as follows:\n- Rational polynomial parametric (RPP)\n- Procedural parametric (PP)\n- Implicit algebraic (IA)\n- Implicit procedural (IP)\nProcedural curves may be general offsets, evolutes, etc.\nCurve to curve intersection cases are identified in table 10.1.\nRPP\nPP\nIA\nIP\nRPP\nD1\nD2\nD3\nD4\nPP\nD5\nD6\nD7\nIA\nD8\nD9\nIP\nD10\nTable 10.1: Curve to curve intersection cases\nConceptually, D3 (RPP/IA curve intersection) is the \"simplest\" of the above cases of inter-\nsection to describe and use for illustrating various general difficulties of intersection problems.\n10.6.1\nCase D3: RPP/IA curve intersection\nWe start with a planar RPP curve (which is conceptually the simplest case).\nR(t)\n=\n[x(t), y(t)] = [X(t)\nw(t) , Y (t)\nw(t)]\n=\nPn\ni=0 RihiBi,n(t)\nPn\ni=0 hiBi,n(t)\n0 ≤t ≤1\nwhere hi > 0 are weights and Bi,n(t) are Bernstein basis functions.\nThe implicit algebraic curve fm(x, y) = 0 of total degree m is described by\nfm(x, y) =\nm\nX\ni=0\nm-i\nX\nj=0\ncijxiyj = 0\nFor convenience, we convert it to homogeneous form, by setting x = X\nw , y = Y\nw and multiplying\nby wm, which leads to\nfm(X, Y, w) =\nm\nX\ni=0\nm-i\nX\nj=0\ncijXiY jwm-i-j = 0\n\nEvery term of the above sum has a total degree m. Substituting R(t) into fm(X, Y, w) leads\nto a polynomial of degree up to mn\nF(t) = 0\nTherefore, now the problem of intersection is equivalent to finding the real roots of F(t) in\n0 ≤t ≤1. The most usual form of F(t) is the power basis. The coefficients ai can be evaluated\nsymbolically by substitution and collection of terms. This can be readily done in a standard\nsymbolic manipulation program (such as Macsyma, Reduce, Maple etc.). Such programs are\noriented to processing rational numbers exactly.\nExample:\nLet the algebraic curve be an ellipse x2\n4 + y2 -1 = 0, as illustrated in Figure 10.13. Let the\nparametric curve be a cubic B ezier curve with control points:\n\"\n#\n,\n\"\n-4\n#\n,\n\"\n#\n, and\n\"\n#\nx\ny\nFigure 10.13: Ellipse and cubic B ezier curve polygon\nUsing Macsyma (or any similar symbolic manipulation program) and simplifying, we get\n(in exact arithmetic mode):\nF(t) = 1025t6 -3840t5 + 5514t4 -3728t3 + 1149t2 -120t = 0\nNext we find the (real) roots of F(t) in t ∈[0, 1] using Macsyma's factoring capability over\nintegers, which leads to\nF(t) ≡t(t -1)2G(t)\nwhere\nG(t) = [1025t3 -1790t2 + 909t -120]\n\nUsing a standard numerical solver for polynomials in floating point (such as NAG C02AEF\nroutine), we obtain the following numbers as solutions of G(t) = 0 (reported with four decimal\ndigits)\nt = 0.9228, 0.61843, 0.2051\nAlternately solving F(t) = 0 using the same routine leads to the following roots t = tR +itI\ntR\n0.9228\n0.6183\n0.2051\ntI\n-0.22 × 10-6\n0.22 × 10-6\nNotice the sensitivity to errors for the 6th degree polynomial, especially for multiple roots\nas t = 1. In floating point arithmetic, such roots split into a number of roots (complex or real).\nObviously, complex roots are not usable (as we require only the real intersection points). The\nconsequence is lost roots, which implies an erroneous solution of the intersection problem.\nAn alternate basis for the representation of F(t) = 0 is the Bernstein basis, which has better\nstability of its real roots under perturbations of its coefficients than the power form. We will\nintroduce the concept of condition numbers for polynomial roots later in this subsection.Such\nrepresentation can be obtained without first converting to a power basis and using a symbolic\nmanipulation program. It rather requires polynomial arithmetic involving products such as\nBi,k(t)Bj,l(t) =\n\nk\ni\n!\nl\nj\n!\nk + l\ni + j\n!-1\nBi+j,k+l(t)\nIn this way we obtain the representation:\nF(t) =\nmn\nX\ni=0\nciBi,mn(t) = 0\nIn the above example of the ellipse and cubic B ezier curve,\nc0 = 0, c1 = -20, c2 = 36.6, c3 = -16.6, c4 = 1.6, c5 = 0, and c6 = 0\nUsing the linear precision property\nt =\nmn\nX\ni=0\ni\nmnBi,mn(t)\nwe can construct\nf(t) = [t, F(t)] =\nmn\nX\ni=0\n\ni\nmn\nci\n!\nBi,mn(t)\nwhich is now a standard degree mn B ezier curve as in Figure 10.14\nNotice that in our example c0 = 0 which implies that t = 0 is a root. Also c5 = c6 = 0\nimplies that t = 1 is a double root. Note that\n- If all ci > 0 or ci < 0 then there are not roots in [0, 1].\n- We can use subdivision (split in half) to identify subintervals of [0, 1] where coefficients\nchange sign once. Variation diminishing property implies one root in such areas. The\nNewton method can be used for fast convergence within such subintervals.\n\n-15\n-30\n-45\n1/6\n2/6\n3/6\n4/6\n5/6\nt\n0.21\n0.61\n0.92\nFigure 10.14: Intersection of a B ezier curve/straight line.\nAnother solution method is illustrated in Figure 10.15 for a quadratic curve (parabola). In this\nmethod the curve's convex hull is intersected with the axis w = 0 to give the [A, B] interval\nas in Figure 10.15. The part of the [0, 1] interval outside [A, B] does not contain roots. By\ncurve subdivision at A and B a smaller curve segment can be obtained in the B ezier form and\nthe process can be continued. In this case, we use binary subdivision of AB when the rate of\ndecrease of AB slows. See paper by Sherbrooke and Patrikalakis for details and also the next\nsection on the nonlinear solver.\nA\nB\nw\nw = 0\nFigure 10.15: Subdivision at A, B.\nNumerical condition of polynomials in Bernstein form\n1. Condition numbers for polynomial roots\nConsider the displacement δx of a real root xo of a polynomial in the basis {φk(x)}:\nP(x) =\nn\nX\nk=0\nλkφk(x),\n\ndue to a perturbation δλr in a single coefficient λr in this basis. Since xo + δx is a root\nof the perturbed polynomial, it satisfies:\nP(xo + δx) = -δλrφr(xo + δx).\nPerforming a Taylor series expansion about xo on both sides of the above equation and\nnoting that P(xo) = 0, we obtain:\nn\nX\nk=1\n(δx)k\nk!\nP (k)(xo) = -δλr\nn\nX\nk=0\n(δx)k\nk!\nφ(k)\nr (xo).\nIf xo is a simple root of P(x), then P ′(xo) = 0, and in the limit of infinitesimal pertur-\nbations the above equation gives:\nlim\nδλr→0\nδx\nδλr/λr\n= -λrφr(xo)\nP ′(xo) .\nWe define\nC = |λrφr(xo)/P ′(xo)|\nthe condition number of the root xo with respect to the single coefficient λr.\nIf xo is an m-fold root, m ≥2, then we define a multiple-root condition number C(m) in\nthe form\nC(m) = [\nm!\n|P (m)(xo)|\nn\nX\nr=0\n|λrφr(xo)|]1/m.\nTheorem For an arbitrary polynomial P(x) with a simple root xo ∈[0, 1], let Cp(xo) and\nCb(xo) denote the condition numbers of the root in the power and Bernstein bases on [0, 1],\nrespectively. Then Cb(xo) ≤Cp(xo) for all xo ∈[0, 1]. In particular Cb(0) = Cp(0) = 0,\nwhile for xo ∈(0, 1] we have the strict inequality Cb(xo) < Cp(xo).\n2. Example - Wilkinson polynomial\nConsider the polynomial with the linear distribution of real roots xo = k/n, k = 1, 2, ..., n,\non the unit interval [0, 1] for n = 20:\nP(x) =\nY\nk=1\n(x -k/20).\nThe condition numbers for each root with respect to a perturbation in the single co-\nefficient a19 are shown in Table 10.2. It is evident from Table 10.2 that the Bernstein\nform affords a dramatic inprovement in root condition numbers compared to the power\nform in this example, the condition number of the most unstable root being reduced by\na factor of about 107.\nWe now perturb the single power coefficient a19 = -21\n2 by an amount -2-23/20. This\ncorresponds to a fractional perturbation ε = 2-23/210 ∼= 5.7 × 10-10. The roots of the\n\nTable 10.2: Condition numbers for Wilkinson polynomial\nk\nCp(xo)\nCb(xo)\n2.100 × 101\n3.413 × 100\n4.389 × 103\n1.453 × 102\n3.028 × 105\n2.335 × 103\n1.030 × 107\n2.030 × 104\n2.059 × 108\n1.111 × 105\n2.667 × 109\n4.153 × 105\n2.409 × 1010\n1.115 × 106\n1.566 × 1011\n2.215 × 106\n7.570 × 1011\n3.321 × 106\n2.775 × 1012\n3.797 × 106\n7.822 × 1012\n3.321 × 106\n1.707 × 1013\n2.215 × 106\n2.888 × 1013\n1.115 × 106\n3.777 × 1013\n4.153 × 105\n3.777 × 1013\n1.111 × 105\n2.833 × 1013\n2.030 × 104\n1.541 × 1013\n2.335 × 103\n5.742 × 1012\n1.453 × 102\n1.310 × 1012\n3.413 × 100\n1.378 × 1011\n\npertured polynomials are shown in Table 10.3. For comparison, we now perturb the\ncoefficient\nc19 = -\nof the Bernstein form by the same fractional amount, and obtain approximations to the\nroots of this perturbed polynomial, which are shown in Table 10.3.\nTable 10.3: Roots of perturbed polynomials\nk\npower\nBernstein\n0.05000000\n0.0500000000\n0.10000000\n0.1000000000\n0.15000000\n0.1500000000\n0.20000000\n0.2000000000\n0.25000000\n0.2500000000\n0.30000035\n0.3000000000\n0.34998486\n0.3500000000\n0.40036338\n0.4000000000\n0.44586251\n0.4500000000\n0.50476331±\n0.5000000000\n0.03217504i\n0.5499999997\n0.58968169±\n0.6000000010\n0.08261649i\n0.6499999972\n0.69961791±\n0.7000000053\n0.12594150i\n0.7499999930\n0.83653687±\n0.8000000063\n0.14063124i\n0.8499999962\n0.97512197±\n0.9000000013\n0.09701652i\n0.9499999998\n1.04234541\n1.0000000000\n3D-Space geometry: Case D3: RPP/IA (continued)\nR(t) = [x(t), y(t), z(t)] ∩f(R) = g(R) = 0\n1. Substitute\nf(R(t)) ≡F1(t) = 0\ng(R(t)) ≡F2(t) = 0\n2. Compute the resultant of F1(t), F2(t) by eliminating t.\n3. If R(F1(t), F2(t)) ≡0, then there is a common root between the two equations.\n4. Use the inversion algorithm to find t.\n\n10.6.2\nCase D1: RPP/RPP Curve Intersection\n(\nR1 = R1(t),\n0 ≤t ≤1\nR2 = R2(v),\n0 ≤v ≤1\nSetting R1(t) = R2(v) leads to 3 nonlinear equations with 2 unknowns (overdetermined\nsystem). A possible approach is to choose 2 equations to solve for t, v, and then substitute the\nresults into the third equation for verification. Alternatively the subdivision-based nonlinear\nsolver described in the next section can directly solve such systems without the above 2 step\napproach.\nPreprocessing idea in 3D:\nCheck bounding boxes for intersection. If there is such intersection, examine x, y projection.\nMethod 1 .\n1. Implicitize, e.g., x2 = x2(v), y2 = y2(v), to get f(x, y) = 0.\n2. Substitute x1(t), y1(t) into f(x, y) to get F(t) = 0 and solve it for real roots in [0, 1].\n3. Use the inversion algorithm: v = φ(x,y)\nq(x,y)\nMethod 2 Recursive subdivision and use of bounding boxes.\nSome issues:\nMethod 1 is more efficient for n ≤3 but its robustness is unclear in the presence of ill-\nconditioned (tangent) intersections.\nMethod 2 is more efficient for n ≥4 and its robustness with respect to missing roots can\nbe guaranteed if the method is inplemented in rounded interval arithmetic (see next\nsection). If two bounding boxes intersect, and they are of finite size, we can find roots\nusing linear approximation.\nIn Figure 10.16(a), the boxes intersect, the linear approximation do not, and the curves\nintersect. Similar behavior is observed in (b) where polygon is used as the curve approx-\nimation.\n(a)\n(b)\nFigure 10.16: Ill-conditioned curve intersections.\n\nUse hodograph (as in Figure 10.17) to find the range of tangent variation. Construct\nbounding angular sectors of hodographs of two curves and make vertices coincident. If\nthe sectors do not intersect, then there is at most one root; otherwise, subdivide the two\ncurves. For a precisely \"tangent\" root, this method would lead to infinite subdivision\nsteps.\n(1)\n(2)\n(1)\n(2)\nangular sector\nFigure 10.17: Hodograph concept.\n10.6.3\nCase D2/D5: RPP/PP and PP/PP Curve Intersections\n3 equations with 2 unknowns\n(\nR1 = R1(t),\n0 ≤t ≤1\nR2 = R2(v),\n0 ≤v ≤1\nPossible Approach\nMinimize\nF(t, v) = |R(t) -R(v)|2,\n0 ≤t, v ≤1\nSee comments on Point/RPP surface intersection.\n- More difficult to compute derivatives of F(t, v) exactly. May need numerical techniques\n(slower and usually more inaccurate).\n10.6.4\nCase D6: PP/IA Curve Intersection\n(\nR1 = R1(t), 0 ≤t ≤1\ng(R) = f(R) = 0\nIt could be reduced to PP Curve/IA Surface intersection and comparison of solutions for g = 0\nand f = 0.\n\n10.6.5\nCase D8: IA/IA Curve Intersection\nThe planar case is of interest in processing trimmed patches.\nf(u, v) = 0\ng(u, v) = 0\n)\n(u, v) ∈Parametric domain\nMethod 1\nEliminate v to form the resultant F(u), then solve F(u) = 0 for u and use the inversion\nalgorithm to get v.\n- Example: Let us consider an ellipse and a circle\nf\n=\nx2\n4 + y2 -1 = 0\ng\n=\n(x -1)2 + y2 -1 = 0\nas in Figure 10.18.\nx\ny\nFigure 10.18: Ellipse and circle intersection\nLet us eliminate y from these two equations. This leads to\n3x2 -8x + 4 = 0\nwhich has as roots x = 2 and x = 2\n3. Each of these leads to y2 = 0 and y2 = 8\n9 respectively.\nHowever there are possible numerical problems at the \"tangent\" solution x = 2, y = 0.\nLet us assume that due to error\nx = 2 + ε\nhence\ny2 = -ε(1 + ε\n4) < 0\nThis implies that y is imaginary and that no real roots exist. This would have as a\nconsequence missing an intersection solution, leading to a robustness problem.\nMethod 2\nAfter tracing of f(u, v) = 0 and g(u, v) = 0, linear approximation is available. Find\nintersections of linear approximations and minimum distance points between them. Use\nthis to drive a Newton Method on f = g = 0 or a minimization of F = f 2 + g2.\n\n10.7\nCurve/surface intersection\nSuch intersections are classified as in Table 10.4. We will start with case E3 which is quite\nrepresentative.\nSurface Type\nCurve Type\nRPP\nPP\nIA\nIP\nRPP\nE1\nE2\nE3\nE4\nPP\nE5\nE6\nE7\nE8\nIA\nE9\nE10\nE11\nE12\nIP\nE13\nE14\nE15\nE16\nTable 10.4: Curve/Surface Intersections\nCurve to surface intersection involves the intersection of straight line to surface of all cases.\nSuch intersection is useful for\n- ray tracing\n- point classification\n- for procedural surface interrogation\n10.7.1\nCase E3: RPP Curve/IA Surface Intersection\nLet us consider an (implicit) algebraic surface of total degree m\nfm(x, y, z) =\nm\nX\ni=0\nm-i\nX\nj=0\nm-i-j\nX\nk=0\ncijkxiyjzk = 0\nWe first convert it to a degree homogeneous form by setting x = X/W, y = Y/W, z = Z/W\nand multiply by W m leading to\nfm(X, Y, Z, W) =\nm\nX\ni,j,k,q=0\ni+j+k+q=m\ncijkXiY jZkW q = 0\nLet us also consider a rational curve of degree n\nR(t) = [x(t), y(t), z(t)] = [ X(t)\nW(t), Y (t)\nW(t), Z(t)\nW(t)],\n0 ≤t ≤1\nWe can easily substitute R(t) in fm(X, Y, Z, W) to obtain a polynomial equation F(t) = 0 of\ndegree ≤mn. We then find its (real) roots in [0, 1], see comments under section 10.6.1.\n\n10.7.2\nCase E1: RPP Curve/RPP Surface Intersection\n3 nonlinear equations in 3 unknowns t, u, v, R(t) = Q(u, v) where\nR = R(t), 0 ≤t ≤1\nQ = Q(u, v), 0 ≤u, v ≤1\nA Preprocessing step is to check bounding boxes for absence of intersection to eliminate\neasy cases.\nMethod 1 Implicitization of Q(u, v) for simple surface forms and reduction to Case E3.\nMethod 2 Recursive subdivision and use of bounding boxes. See also next section for nonlin-\near solver. Eventual use of a linear approximation technique for R and Q to obtain ap-\nproximate solution, which is to be used to initiate a Newton method on R(t)-Q(u, v) = 0\nor a minimization method on F(t, u, v) = |R -Q|2. See section 10.6.2 for problem areas\nfor Ft = Fu = Fv = 0 (3 equations.)\n10.7.3\nCase E2/E6: RPP/PP, PP/PP Curve/Surface Intersection\n3 nonlinear equations in 3 unknowns t, u, v, R(t) = Q(u, v) where\n(\nR = R(t), 0 ≤t ≤1\n∩\nQ = Q(u, v), 0 ≤u, v ≤1\nPossible Approach\nMinimize\nF(t, u, v) = |R(t) -Q(u, v)|2\nin a cube 0 ≤t, u, v ≤1. See comments under point-surface intersection (e.g. examine vertices,\nedges, etc.)\n10.7.4\nCase E7: PP Curve/IA Surface Intersection\n4 non-linear equations in 4 unknowns t, R\n(\nR = R(t), 0 ≤t ≤1\nf(R) = 0\nPossible approach\nCould use a Newton method initiated by a linear approximation of R = R(t), which can be\nintersected more easily with f(R) = 0 using the method of Case E3.\nProblems\n1. All roots?\n2. Convergence?\n\n3. Efficiency?\nIn case of convergence problems, embedding or continuation methods are normally helpful.\nFor example,\n1. Let\nQ(t) = Q0 + (Q1 -Q0)t -a\nb -a,\nt ∈[a, b]\nwhere [a, b] ⊂[0, 1], be an approximation of R(t) within [a, b] interval.\n2. Compute Q(t) ∩f(R) = 0 in t ∈[a, b] using the method of Case E3.\n3. Define sequence of problems\nR(t; ε) = Q(t) + ε(R(t) -Q(t))\nwhere ε = ε1, ε2, · · · , εN such that 0 = ε1 < ε2 < · · · < εN = 1.\n4. Solve R(t; εi) ∩f(R) = 0 using as initial approximation the solution for ε = εi-1.\nSuch a method does not by itself provide initial approximations of all possible solutions; rather,\nit assists in the computation of a particular solution.\n10.7.5\nCase E11: IA Curve/IA Surface Intersection\n3 equations in 3 unknowns\nf(R) = g(R)\n|\n{z\n}\ncurve\n= h(R)\n| {z }\nsurface\n= 0\nPossible approaches\n1. Elimination Methods\n2. Newton Methods\n3. Minimization Methods\nF(R) = f 2 + g2 + h2\nPossible reformulation in a box Π\nF(R) =\nM\nX\ni=0\nN\nX\nj=0\nQ\nX\nk=0\nwijkBi,M( x)Bj,N( y)Bk,Q( z)\n(x, y, z) ∈Π = [a1, a2] × [b1, b2] × [c1, c2]\nand x = (x -a1)/(a2 -a1) and similarly for y and z. If wijk > 0 for all i, j, k, there is no\nsolution is Π.\nInitial approximation: find mini,j,k wijk < 0 and start at ( i\nM , j\nN , k\nQ).\n4. Approximate f(R) = g(R) = 0 curve with a linear spline, reduce to E3 and refine using\nminimization.\n\n10.7.6\nIA Curve/RPP Surface Intersection\n(\ncurve\nf(R) = g(R) = 0\nsurface\nR = R(u, v), 0 ≤u, v ≤1\nSubstitute R = R(u, v) in f(R) = 0, g(R) = 0 to obtain two algebraic curves f(u, v) =\n0, g(u, v) = 0, as in Figure 10.19. This formulation reduces to Case D8 in Section 10.6.5:\nIA/IA curve intersection. Algebraic curves are treated under intersections of algebraic and\nRPP surfaces.\nf=0\ng=0\nu\nv\nFigure 10.19: Intersection of two algebraic curves\n\n10.8\nSurface/Surface Intersections\nThe surface types we will consider can be classified as follows:\n- Rational polynomial parametric (RPP)\n- Procedural parametric (PP)\n- Implicit algebraic (IA)\n- Implicit procedural (IP)\nProcedural surfaces may include general offsets, focal surfaces, etc.\nSurface to surface intersection cases are identified in table 10.5.\nSurface Type\nSurface Type\nRPP\nPP\nIA\nIP\nRPP\nF1\nF2\nF3\nF4\nPP\nF5\nF6\nF7\nIA\nF8\nF9\nIP\nF10\nTable 10.5: Classification of Surface/Surface Intersections\nThe solution of a surface/surface intersection problem may be empty, or include a curve\n(possibly made of several branches), a surface patch, or a point. Conceptually, F3 (RPP/IA\nsurface intersection) is the \"simplest\" of the above cases of intersection to describe and use for\nillustrating general difficulties of surface intersection problems.\n10.8.1\nCase F3: RPP/IA Surface Intersection\nWe start with a RPP surface patch\nR(u, v) = [ X(u, v)\nW(u, v), Y (u, v)\nW(u, v), Z(u, v)\nW(u, v)]\n(10.9)\nwhere X, Y, Z are all of degree p in u, q in v, (u, v) ∈[0, 1] × [0, 1].\nNext we consider an implicit algebraic surface fm(x, y, z) = 0 of total degree m described\nby\nfm(x, y, z) =\nm\nX\ni=0\nm-i\nX\nj=0\nm-i-j\nX\nk=0\ncijkxiyjzk\n(10.10)\nExamples of such surfaces in practical use are low order surfaces such as planes (degree 1), the\nnatural quadrics (cylinder, sphere, cone) (degree 2), and torii (degree 4). In fact in a survey of\nmechanical parts (mechanical elements), over 90% of all surfaces involved are of these types. It\nis also well known that all these surfaces also have a low degree rational polynomial parametric\n\nrepresentation, so that when two surfaces of the above types are intersected, the methods of\nthis section may be used.\nFor convenience, we convert fm(x, y, z) = 0 to its homogeneous form by setting\nx = X\nW ,\ny = Y\nW ,\nz = Z\nW\n(10.11)\nand multiplying by W m, which leads to\nfm(X, Y, Z, W) =\nX\ni, j, k, q ≥0\ni + j + k + q = m\ncijkXiY jZkW q = 0\n(10.12)\nConsequently, the intersection problem\nfm(X, Y, Z, W) = 0\n(10.13)\nX = X(u, v), Y = Y (u, v), Z = Z(u, v), W = W(u, v)\n(10.14)\nmay be thought of as a nonlinear system of 5 equations in 6 unknowns. A reduction of the di-\nmensionality of the system may be obtained by substituting equations 10.14 in equation 10.13,\nwhich since all functions involved are polynomial leads to an algebraic curve\nf(u, v) = 0\n(10.15)\nof degree M = mp and N = mq in u, v, respectively. Consequently, the problem of intersection\nreduces to the problem of tracing f(u, v) = 0 without omitting any special features of the curve,\ne.g., small loops, singularities, and accurately computing all its branches. This is a fundamental\nproblem in algebraic geometry and much work has been done to understand its solution. In the\ncontext of algebraic geometry the coefficients of f(u, v) = 0 are integers. In the context of CAD\nand computer implementation, the coeffficients of fm = 0, and R = R(u, v) are floating point\nnumbers. Consequently, if the above substitution is performed in floating point arithmetic the\ncoefficients of f(u, v) = 0 involve error. To avoid such error, rational arithmetic may be used\nfor robustness. These issues will also be discussed in the next section.\nThe algebraic curve\nf(u, v) =\nM\nX\ni=0\nN\nX\nj=0\naijuivj = 0\n(10.16)\ncan be reformulated as\nf(u, v) =\nM\nX\ni=0\nN\nX\nj=0\nwijBi,M(u)Bj,N(v) = 0\n(10.17)\nwhere (u, v) ∈[0, 1]2.\nAs an example consider a plane in homogeneous form\nAX + BY + CZ + DW = 0\n(10.18)\n\nu\nv\nborder\npoints\nsingular\npoints\nloop\nFigure 10.20: Parameter space of R(u, v) and resulting algebraic curve f(u, v) = 0\nand a rational B ezier patch of degree p in u, q in v\nR(u, v) =\nPp\ni=0\nPq\nj=0 hijRijBi,p(u)Bj,q(v)\nPp\ni=0\nPq\nj=0 hijBi,p(u)Bj,q(v)\n(10.19)\nwhere Rij = [xij, yij, zij] and weights hij ≥0.\nThe resulting algebraic curve is of the form of equation 10.17 with\nwij = (Axij + Byij + Czij + D)hij\n(10.20)\nIn fact the power basis form of f(u, v) = 0 need not be computed at all, if polynomial arithmetic\nfor Bernstein polynomials is used.\nThe advantage of the Bernstein form is its numerical stability and convex hull property.\nIf wij > 0 or < 0 for all i, j, there is no solution and the two surfaces do not intersect.\nMore precisely, the (entire) algebraic surface fm(R) = 0 does not intersect the surface patch\nR = R(u, v) for (u, v) ∈[0, 1]2.\nWhat happens when all wij = 0 (or αij = 0)? Obviously, the two surfaces coincide in\ntheir entirety.\nA somewhat complex algebraic curve f(u, v) = 0 is shown in Figure 10.20\ninvolving various branches (from border to border), internal loops, and singularities, see also\nFigure 10.24.\nGiven a point on every branch (connected component) of an algebraic curve, tracing the\ncurve using differential curve properties is an effective procedure (marching method).\nMarching Method:\nLet us expand f(u, v) as a Taylor series\n\nδvL\nδv\nδu\n(u,v)\nNewton\nFigure 10.21: A zoomed view of an algebraic curve near a point (u, v)\nf(u + δu, v + δv)\n=\nf(u, v) + fuδu + fvδv\n+1\n2(fuuδu2 + 2fuvδuδv + fvvδv2) + · · ·\n(10.21)\n- To first order and if f 2\nu + f 2\nv > 0, in order to have f(u, v) = 0 and f(u + δu, v + δv) = 0,\nfuδu + fvδvL = 0 ⇒δvL = -fu\nfv\nδu\n(10.22)\nsee also Figure 10.21.\n- The Newton method on f(u + δu, v) = 0 with initial approximation vI = v + δvL may be\nused to compute vF = v + δv with high accuracy and in an efficient manner.\n- For \"vertical\" branches, ie. when |fv| is very small, we may use δuL = -fv\nfuδv.\nTo avoid these special stepping procedures the equation fuδu + fvδv = 0 may be converted\nto\nfu u + fv v = 0\n(10.23)\nwhere u, v are considered functions of a parameter t, u = u(t), v = v(t). This equation is\nsatisfied if\nu\n=\n-ξfv(u, v)\n(10.24)\nv\n=\nξfu(u, v)\n(10.25)\nwhere ξ is an arbitrary constant. For example, ξ can be chosen to be equal to [f 2\nu + f 2\nv ]-1\n2, in\norder that t is an arc length parameter in the [u, v] ∈[0, 1]2 parameter space. This is a system\n\nof two first order nonlinear differential equations which can be solved by the Runge-Kutta or\nother methods with adaptive step size.\nProblems of Marching Methods\n1. Starting points on all branches need to be provided in advance.\n2. Marching through singularities (f 2\nu + f 2\nv ≃0) is problematic.\n3. Step size selection is complex and too large a step size may lead to straying or looping,\nas in Figure 10.22.\nstraying\nlooping\nFigure 10.22: Step size problems in marching method\nComputation of starting points\nStarting points for tracing algebraic curves are certain \"characteristic\" points defined below:\n1. Border points, ie. the intersections of f(u, v) = 0 with the boundary of the parameter\nspace [0, 1]2, e.g., f(0, v) = 0, 0 ≤v ≤1.\n2. Turning points f = fu = 0 or f = fv = 0, which are illustrated in Figure 10.23. If f is of\ndegree (M, N) in (u, v), then fu is of degree (M -1, N) and fv is of degree (M, N -1). It\ncan be seen that the total number of roots of two simultaneous bivariate polynomials of\ndegree (m, n) and (p, q), respectively, is mq + np.Thus, there can be at most 2MN -M\nu-turning points and 2MN -N v-turning points.\n3. Singular points f = fu = fv = 0. Notice fu = ∇f · Ru, fv = ∇f · Rv, and therefore\nfu = fv = 0 means that ∇f ∥Ru × Rv or that the normals of two surfaces are parallel\nand since f(u, v) = 0 at these points the two surfaces intersect tangentially. If f is of\ndegree (M, N) in (u, v), fu is of degree (M -1, N) and fv is of degree (M, N -1), there\ncan be at most 2MN -M -N + 1 singular points.\n\nf = fu = 0\nf = f = 0\nv\nFigure 10.23: Turning points\nFrom the above discussions we can get upper bounds for the maximum number of u-turning,\nv-turning and singular points, see table 10.6. These bounds refer to the maximum possible\nnumber of solutions (u, v) in the entire complex plane. It turns out that the number of such\npoints in the real square [0, 1]2 is much smaller, but still quite large. Consequently methods\nwhich focus on the possible solutions only in the [0, 1]2 are advantageous. The subdivision\nmethod of Section 10 is one such method. Interval Newton methods are also potentially useful\nin this context.\nalgebraic curve\nmax number\nmax number\nmax number\nS1\nS2\nf(u, v) degree\nu-turning pts\nv-turning pts\nsingular points\nM, N\n2MN -M\n2MN -N\n2MN -M -N + 1\nplane\nbiquadratic\n2, 2\nplane\nbicubic\n3, 3\nquadric\nbiquadratic\n4, 4\nquadric\nbicubic\n6, 6\ntorus\nbiquadratic\n8, 8\ntorus\nbicubic\n12, 12\nbiquadratic\nbiquadratic\n16, 16\nbicubic\nbiquadratic\n36, 36\nbicubic\nbicubic\n54, 54\nTable 10.6: Number of turning and singular points in various cases\nAnalysis of singular points:\nLet (u0, v0) satisfy f(u0, v0) = 0. We construct a straight line L\nu = u0 + αt, v = v0 + βt\n(10.26)\nand we find its intersections with the algebraic curve f(u, v) = 0 by substitution as follows:\n=\nf(u0 + αt, v0 + βt)\n=\nf(u0, v0) + αtfu(u0, v0) + βtfv(u0, v0)\n+1\n2(α2t2fuu + 2αβt2fuv + β2t2fvv)|(u=u0,v=v0)\n\n+h.o.t. (up to tλ, λ is finite)\n=\nt(αfu + βfv) + t2\n2 (α2fuu + 2αβfuv + β2fvv) + h.o.t.\n(10.27)\n(1) Case A:\nf 2\nu + f 2\nv > 0, f = 0 at (u0, v0).\nL is tangent to f = 0 at (u0, v0) if t = 0 is a double root. Thus\nαfu + βfv = 0\nα = ∓fv\nβ = ±fu\nThis is also a proof of fact that ∇f is ⊥to curve.\n(2) Case B:\nfu = fv = f = 0 at (u0, v0).\nt = 0 is a triple root if f 2\nuu + f 2\nuv + f 2\nvv > 0 and at least one of the 3rd derivatives is\nnonzero and\nα2fuu + 2αβfuv + β2fvv|u=u0\nv=v0 = 0\n(10.28)\nWe can solve this quadratic equation for α\nβ or β\nα and there are three possiblities:\n(1) 2 real distinct roots ⇒2 distinct tangents (self-intersection)\n(2) 1 real double root ⇒1 tangent (cusp)\n(3) 2 complex roots ⇒no real tangents (isolated point)\nSee also Figure 10.24 for illustration of the three cases.\nExample 1: Let f(u, v) = u3 + u2 + v2 = 0 so that\nfu = u(3u + 2), fv = 2v, fuu = 6u + 2, fvv = 2, fuv = 0\nTurning points:\n(1)\nf = fu = 0, fv = 0 ⇒u = -2\nf = 0 ⇒v2 = -u2(1 + u) < 0 ⇒no real solution\n(2)\nf = fv = 0, fu = 0 ⇒v = 0, u = -1\nSingular points:\nf = fu = fv = 0 ⇒u = v = 0\nTangents at u = v = 0 can be obtained from 2α2 + 2β2 = 0, ( α\nβ)2 + 1 = 0, which has no real\nsolution, so u = v = 0 is an isolated point.\n\n(1)self-intersection\n(2)cusp\n(2)cusp\n(3)isolated point\n(2)cusp\nL\nL\nL\nL\nL\nFigure 10.24: Singularities of planar algebraic curves\nu\nv\n-1\n-1\n-2\nFigure 10.25: Example 1 algebraic curve with an isolated point\nIf the domain of interest is [-2, 1] × [-1, 1], border points are (-1.465, ±1).\nExample 2: Let f(u, v) = v2 -u3 = 0. This curve has a cusp at u = v = 0 with tangent\nv = 0, see Figure 10.26.\nExample 3: Let us consider the equation\nf(u, v) = (u + 1)u(u -1)(v + 1)v(v -1) + 1\n20 = 0\n(10.29)\nwithin the domain [-2, 2]2. This is a degree 6 algebraic curve illustrated in Figure 10.27.\nOn every border line segment, there are three border points.\nThe curve has no singular\npoints, but involves two (internal) loops and six border-to-border branches. The algebraic\ncurve f(u, v) = 0 in this example has degrees M = 3, N = 3 in u and v. Consequently,\nusing the previous formulas the number of u turning points, v turning points and singular\n\n-1\n-1\nu\nv\nFigure 10.26: Example 2 algebraic curve with a cusp at (u, v) = (0, 0)\npoints (in the entire complex plane) is bounded by 2MN -M = 15, 2MN -N = 15, and\n2MN -M -N + 1 = 13.\nHowever, as we can be seen in Figure 10.27, these numbers\noverestimate the actual number of such points in the real square [-2, 2]2.\nComputing starting points for all branches\n1. Border points: This involves solution of a polynomial, eg.\nf(0, v) =\nN\nX\nj=0\nw0jBj,N(v) = 0\nA robust and efficient solution of this type of equation is addressed in Section 10.\n2. Turning and singular point computation: Here we use the fact that\nfu(u, v)\n=\nM\nM-1\nX\ni=0\nN\nX\nj=0\n(wi+1,j -wij)Bi,M-1(u)Bj,N(v)\n(10.30)\nfv(u, v)\n=\nN\nM\nX\ni=0\nN-1\nX\nj=0\n(wi,j+1 -wij)Bi,M(u)Bj,N-1(v)\n(10.31)\nConsequently, computing turning points (f = fu = 0 and f = fv = 0) is equivalent to\nsolving a system of two nonlinear polynomial equations in two variables, and computing\nsingularities f = fu = fv = 0 is equivalent to solving a system of three nonlinear\npolynomial equations in two variables. Robust and efficient solution of these systems of\nnonlinear polynomial equations is addressed in Section 10.\n10.8.2\nCase F1: RPP/RPP Surface Intersection\nIn this case we have two rational polynomial surface patches\n(\nR1 = R1(u, v)\nR2 = R2(s, t)\n(10.32)\n\n-2\n-2\nFigure 10.27: Example 3 algebraic curve\neg. two rational B ezier patches and by setting R1 = R2 we obtain three nonlinear polynomial\nequations for four unknowns u, v, s, t. This system can be solved by the nonlinear solver of\nSection 10. However, as the solutions are typically not isolated points but curves, such approach\nis inefficient. There are three major techniques for solving RPR/RPP surface intersections.\nMethod 1: Lattice method\nIn this method, one of the two surface patches is discretized to a grid of isoparameter\ncurves at some fixed resolution. Each of the resulting curves is intersected with the other\npatch (using a technique as in Section 9.7). The resulting solution points are connected\nto form various curve branches based on empirical distance-based criteria. The method\nis typically inefficient (because it does not use the convex hull properties of RPP surface\npatches to their full extent) and generally not robust, leading to missing of small features\nof the intersection such as small loops, singularities. Also the connection of the points\nto form curves near constrictions and singularities is not robust as it is empirical.\nMethod 2: Subdivision method\nTypically, subdivision methods involve the follwing steps, see Figure 10.28,\n- Preprocessing by bounding boxes to eliminate subpatches that do not intersect.\n- Subdivision (typically in four subpatches by multiple knot insertion at the mid point\nof parameter axes in NURBS patches)\n\n- Approximation of the surface with triangular facets (either from the polyhedron or\na grid on the subdivided surface)\n- Intersections of triangular facets.\nQuadtree\nFigure 10.28: Subdivision method\nIssues:\n- Robust: resolution of loops and isolated points (under finite subdivision) is not guar-\nanteed.\n- Efficiency is typically better than lattice methods but usually inferior to marching\nmethods.\nMethod 3: Marching along tangent to intersection curve\nt = (R1u × R1v) × (R2s × R2t)\n(10.33)\nIssues:\n- Finding starting points on all branches.\n- Straying, looping, singularities\n\nu\nv\ns\nt\nFigure 10.29: Parameter spaces of R1(u, v) and R2(s, t)\nLet us consider the intersection, R1(u, v) = R2(s, t), eg. as illustrated in the parameter\nspaces of R1, R2 in Figure 10.29. A resulting intersection curve branch can be expressed\nas a parameter curve in terms of the parameter τ, as follows\nu = u(τ), v = v(τ), s = s(τ), t = t(τ)\n(10.34)\nThe intersection curve tangent can be obtained as the tangent along the curve on the\nsurfaces R1(u(τ), v(τ)) and R2(s(τ), t(τ)) using the chain rule of differentiation as follows\nR1\n=\nR1u u + R1v v\n(10.35)\nR2\n=\nR2s s + R2t t\n(10.36)\nwhere ( ) denotes derivatives with respect to τ. However, R1 = R2 and this leads to\nR1u u + R1v v = R2s s + R2t t\n(10.37)\nThis is a system of three linear equations with four unknowns u, v, s, t, which can be\nsolved to provide the following system of first order nonlinear ordinary differential equa-\ntions (ODE):\nds\ndτ\n=\nζ\n\nx(2)\nt\nx(1)\nu\nx(1)\nv\ny(2)\nt\ny(1)\nu\ny(1)\nv\nz(2)\nt\nz(1)\nu\nz(1)\nv\n\n= ζ|A1|\n(10.38)\ndt\ndτ\n=\n-ζ\n\nx(2)\ns\nx(1)\nu\nx(1)\nv\ny(2)\ns\ny(1)\nu\ny(1)\nv\nz(2)\ns\nz(1)\nu\nz(1)\nv\n\n= -ζ|A2|\n(10.39)\ndu\ndτ\n=\n-ζ\n\nx(2)\ns\nx(2)\nt\nx(1)\nv\ny(2)\ns\ny(2)\nt\ny(1)\nv\nz(2)\ns\nz(2)\nt\nz(1)\nv\n\n= -ζ|A3|\n(10.40)\ndv\ndτ\n=\nζ\n\nx(2)\ns\nx(2)\nt\nx(1)\nu\ny(2)\ns\ny(2)\nt\ny(1)\nu\nz(2)\ns\nz(2)\nt\nz(1)\nu\n\n= ζ|A4|\n(10.41)\nwhere\nR1(u, v)\n=\nh\nx(1)(u, v), y(1)(u, v), z(1)(u, v)\ni\n,\n(10.42)\nR2(s, t)\n=\nh\nx(2)(s, t), y(2)(s, t), z(2)(s, t)\ni\n.\n(10.43)\n\nHere ζ is an arbitrary non-zero factor that can be chosen to provide arc-length parametriza-\ntion in the s, t domain as follows:\ndτ =\n√\nds2 + dt2 =\nq\nζ2(|A1|2 + |A2|2)dτ\nhence\nζ = ±\nq\n|A1|2 + |A2|2.\nThis ODE system (10.38) to (10.41) can be solved using the Runge-Kutta method or a\nmultistep method.\nIn order to compute approximate starting points for the above marching method we need\nto identify first the possible presence of (internal) loops. This can be done using the\nconcept of collinear normal points.\nSederberg et al first recognized the importance of collinear normals in detecting the\nexistence of closed intersection loops in intersection problems of two distinct parametric\nsurface patches. Two points on two surfaces are said to be collinear normal points if\ntheir associated normal vectors lie on the same line.\nTheoremIf two regular tangent plane continuous surface patches, R1 and R2, intersect\nin a closed loop, then there exists a line that is perpendicular to both R1 and R2 if\nthe dot product of any two normal vectors (on the same patch or on different patches)\nis never zero. This means that the total range of normal directions for both patches\nconsidered simultaneously can not deviate more than 90*.\nIn other words, if the two surfaces do not contain a collinear normal (and do not turn\nmore than 90*), then there are no closed loops of surface intersection. Denoting the two\nsurfaces by R1(u, v) and R2(s, t), collinear normal points satisfy the following equations\n(R2 -R1) · R2s = 0,\n(R2 -R1) · R2t = 0,\n(R2s × R2t) · R1u = 0,\n(R2s × R2t) · R1v = 0.\n(10.44)\nIf R1, R2 are RPP surface patches, equation (10.44) form a system of four nonlinear\npolynomial equations that can be solved using the method of Section 10.\nNow we split the patches in (at least) one parametric direction at these collinear normal\npoints. Consequently, starting points are only border points on the boundaries of all\nsubdomains created. Border points are intersections of the border curves of each patch\nwith the other patch. Their computation involves a system of three nonlinear polynomial\nequations in three unknowns, which can be solved with the method of Section 10.\n10.8.3\nCase F8: IA/IA Surface Intersection\nf(R) = g(R) = 0\n(10.45)\n\nwhere f, g are polynomials. Here we have two equations and three unknowns R.\nOne intersection method for low order f, g is to eliminate one variable (e.g. z) to find\nprojection of intersection curves on plane of other two variables (e.g. x, y), then trace the\nalgebraic curve and use the inversion algorithm to find z. A more complete analysis of this\nproblem is beyond the scope of these notes.\nExample 1: See Figure 10.30\nf\n=\nx2 + y2 + z2 -1 = 0\ng\n=\nx2 + (y -1\n2)2 -1\n4 = 0\nx\ny\nz\nx\ny\ng=0\ny\nz\n-1\n-1\nx\nz\nz=0 plane\ny=0 plane\nx + z - z =0\nx=0 plane\ny=1-z2\nFigure 10.30: Intersection of two implicit quadrics (sphere and cylinder) from example 1\n\nAppendix A\nTracing tangent intersection\nLet an algebraic curve be such that\nf(u, v) = fu(u, v) = fv(u, v) = 0\n(10.46)\non all points, and that\nf 2\nuu + f 2\nvv + f 2\nuv = 0\n(10.47)\nand at least one of the 3rd derivative is nonzero.\nThen at a point (u0, v0) on f(u0, v0) = 0, the tangent u = u0 + αt, v = v0 + βt is defined by\nα2fuu + 2αβfuv + β2fvv = 0\n(10.48)\nNow assume there is a single real tangent direction on all points of the curve. This occurs\nwhen\nf 2\nuv -fuufvv = 0\n(10.49)\nThe concept of turning points generalizes to α = 0 or β = 0, because\nα = 0 ⇒f = fv = fvv = 0\nβ = 0 ⇒f = fu = fuu = 0\n)\ndefinition of turning points\n(10.50)\nu\nv\nα=0\nβ=0\nFigure 10.31: Turning points\nFrom (10.49), fuufvv ≥0, so that\nfuv = ±\nq\nfuufvv\nHence, (10.48) becomes\nα2fuu + ±2\nq\nfuufvvαβ + β2fvv = 0\n\nCase 1 fuu = 0\n⇒\nfuu(α\nβ )2 ± 2\nq\nfuufvv(α\nβ ) + fvv = 0\nα\nβ = ±\n√fuufvv\nfuu\n= ±\ns\nfvv\nfuu\nsgn(fuu)\nCase 2 fvv = 0\n⇒\nfvv(β\nα)2 ± 2\nq\nfuufvv(β\nα) + fuu = 0\nβ\nα = ±\n√fuufvv\nfvv\n= ±\ns\nfuu\nfvv\nsgn(fvv)\nWe may choose\nα\n=\nq\n|fvv| = u\nβ\n=\nq\n|fuu| = v\nNormalize so that α2 + β2 = 1\nu = K\nq\n|fvv|\nv = K\nq\n|fuu|\n\n⇒ u2 + v2 = K2(|fuu| + |fvv|) = 1\nK\n=\n±\nq\n|fuu| + |fvv|\nu(t)\n=\n±\nq\n|fvv|\nq\n|fuu| + |fvv|\nv(t)\n=\n±\nq\n|fuu|\nq\n|fuu| + |fvv|\n- Example: f(u, v) = (u2 + v2 -1)2\nfu = 4u(u2 + v2 -1)\nfv = 4v(u2 + v2 -1)\n)\n⇒\nif f = 0 ⇒fu = fv = 0\nfuu = 4(3u2 + v2 -1)\nfvv = 4(3v2 + u2 -1)\nfuv = 8uv\n\n⇒\nif f = 0 ⇒\n\nfuu = 8u2\nfvv = 8v2\nf 2\nuv = fuufvv\n⇒\nu = ±|v|\nv = ±|u|\n)\non f = 0\n\nfuu=0\nfvv=0\nfuu=0\nfvv=0\nu\nv\nu\nA\nv\nFigure 10.32: Tangent intersections\nCase of infinite turning points\nf(u, v) = (u -A)kg(u, v) = 0\n1.\nf(u, 0) = 0\nf(u, 1) = 0\n)\n⇒common solution u = A,\n2. On which fv = (u -A)kgv(u, v) = 0.\nTry factoring (u -A) sequentially until the v derivative of ratio is nonzero.\nCondition (a) and (b) are necessary but not sufficient. However, subdivision would work\nin the limit, in determining f = fv = 0.\n\nNonlinear solvers and robustness issues\n10.9\nNonlinear Solvers\n10.9.1\nMotivation\nAs we have seen in earlier chapters, the geometric shape of curves and surfaces is usually\nrepresented by polynomial equations of various types (eg., implicit or parametric).\nAs we\nhave seen in Chapter 9, intersection problems reduce to solving systems of nonlinear equations\nwhich are usually polynomial if the geometries involved are polynomial.\nOccassionally, the governing equations for general interrogation problems (intersections,\ncurvature extrema, etc.) reduce to systems of nonlinear equations, involving also square roots\nof polynomials, which arise from normalization of the normal vector and analytical expressions\nof the curvatures.\nExample 1 : Intersection between two planar implicit polynomial (algebraic) curves, eg.\ntwo circles, is shown in Figure 10.33. Their equations are\nx2 + y2 -9\n=\n(x -1)2 + y2 -1\n=\nwhich form a nonlinear polynomial system. The roots can be obtained by eliminating y, solving\nfor x and then backsubstituting and solving for y, leading to\n(x, y) = (21\n32, ±\n√\n) ≃(0.65625, ±0.36309)\nExample 2 : Self-intersection of offset of a parabola is shown in Figure 10.34.\nSuch\nintersections are needed in planning NC machining. Self-intersections of a parametric offset\ncurve can be obtained by seeking pairs of distinct parameter values s = t such that\nr(s) + dn(s) = r(t) + dn(t)\n(10.51)\nwhere r(s) is a planar (progenitor) parametric curve, d is an offset distance and n(s) is a unit\nnormal vector to r(s) given by\nn = t × ez =\n( y(s), - x(s))\nq\nx2(s) + y2(s)\n(10.52)\n\ny\nx\n-1\n-1\nFigure 10.33: Intersection between two circles.\nwhere t is the unit tangent vector and ez the unit normal to the plane of the progenitor curve.\nFigure 10.34: Self-intersection of an offset of a parabola.\nSubstituting equation (10.52) into equation (10.51) yields\nx(s) +\ny(s)d\nq\nx2(s) + y2(s)\n= x(t) +\ny(t)d\nq\nx2(t) + y2(t)\ny(s) -\nx(s)d\nq\nx2(s) + y2(s)\n= y(t) -\nx(t)d\nq\nx2(t) + y2(t)\n(10.53)\nIf r(s) is a polynomial function, equations 10.53 form a system of two nonlinear equations\ninvolving polynomials and radicals of polynomials. But if we set τ 2(s) = x2(s) + y2(s), we\nobtain 3 polynomial equations in which τ is the auxiliary variable.\n\n10.10\nLocal Solution Methods\nThey are designed to compute roots based on initial approximations.\n- Newton's Method in one variable [6]\nWe want to find roots for f(x) = 0. Iteration formula is given by\nxn+1 = xn -f(xn)\nf ′(xn),\nn = 0, 1, 2.....\n(10.54)\nThis is illustrated in Figure 10.35(a). A modified Newton's method for one variable is\nshown in Figure 10.35(b), where we take a fractional step as follows in order to reduce the\npossibility of divergence in Figure 10.35(b) of the full step method given by equation 10.54\nxn+1 = xn -μ f(xn)\nf ′(xn)\n(10.55)\nwhere μ = max[1, 1\n2, 1\n4, ...] such that |f(xn+1)| < |f(xn)|.\nf(x)\nx\nx\nx\nn\nn+1\nf(x )\nn\nf(x )\nn+1\n(a)\n( b)\nxn\nxn+1\nFigure 10.35: Newton's method for f(x) = 0\n- Newton's Method for m equations in m unknowns\nWe want to find the roots of the system\nf(r) = 0\n(10.56)\nwhere r = [r1, r2, ..., rm]T, and f = [f1, f2, ..., fm]T.\nIteration formula is given by\nr(n+1) = r(n) + ∆r(n)\n(10.57)\nwhere\nJ(r(n)) · ∆r(n) = -f(r(n))\n(10.58)\nand J = [ ∂fi\n∂rj (r(n))] is the Jacobian matrix [6].\n\n- Advantages\nQuadratic convergence.\nStraightforward to program.\n- Disadvantages\nNeeds good initial approximations for each root, otherwise it may diverge.\nCannot provide full assurance that all roots have been found.\nExample Two intersecting circles x2 + y2 =\n16, (x -1)2 + y2 = 1\n4. Let\nf(x, y) = x2 + y2 -9\n16 = 0\n(10.59)\ng(x, y) = (x -1)2 + y2 -1\n4 = 0\n(10.60)\nThen, the Jacobian matrix is evaluated as follows:\n[J] = 2\n\"\nx\ny\nx -1\ny\n#\n(10.61)\n10.11\nClassification of Global Solution Methods\nGlobal solution methods are designed to compute all roots in some area of interest. In recent\ncomputational geometry related research, three classes of methods for the computation of\nsolutions of nonlinear polynomial systems have been favored:\n- Algebraic techniques [4] [5]\nAdvantages: Theoretically elegant, and well-suited for implementation in symbolic math-\nematical systems. They determine all roots with arbitrary precision if the coefficients of\nthe polynomials involved are integers or rational numbers.\nDisadvantages: Inefficient in memory and processing time requirements and therefore\nunattractive except for very low degree or dimensionality systems.\n- Homotopy methods [9] [28]\nThey tend to be numerically ill-conditioned for high degree polynomials and similarly\ninefficient because they are exhaustive.\n- Subdivision methods [18] [10] [23] [27]\nAdvantages: Subdivision methods are generally efficient and stable. Therefore, they are\nlikely to be the most successful methods in practice. They can be combined with interval\nmethods to numerically guarantee that certain subdomains do not contain solutions.\nDisadvantages: They are not as general as algebraic methods, since they are only capable\nof isolating zero-dimensional solutions.\nFurthermore, although the chances, that all roots have been found, increase as the res-\nolution tolerance is lowered, there is no certainty that each root has been extracted.\nSubdivision methods typically do not provide a guarantee as to how many roots there\nmay be in the remaining subdomains. However, if these subdomains are very small the\n\nexistence of a (single) root within these subdomains is a typical assumption.\nLastly, subdivision techniques provide no explicit information about root multiplicities\nwithout additional computation.\n10.12\nSubdivision Method (Projected Polyhedron Method)\nWe want to find roots of degree m polynomial equation f(x) = co +c1x+c2x2 +· · ·+cmxm = 0\nover the region a ≤x ≤b.\n- The procedure is to first make the affine parameter transformation x = a + t(b -a) such\nthat 0 ≤t ≤1. The transition from the interval a ≤x ≤b to the interval 0 ≤x ≤1 is\nan affine map, and the polynomials are invariant under affine parameter transformation.\n- Now the polynomial equation is given by the monomial form\nf(t) =\nm\nX\ni=0\ncM\ni ti\n(10.62)\n- Change the basis from monomial to Bernstein.\nf(t) =\nm\nX\ni=0\ncB\ni Bi,m(t)\n(10.63)\nwith cB\ni =\ni\nX\nj=0\n(i\nj)\n(m\nj )cM\nj\nwhere Bi,m(t) is the ith Bernstein polynomial given by\nBi,m(t) = (m\ni )ti(1 -t)m-i\n(10.64)\n- Use linear precision property of the Bernstein polynomial\nt =\nm\nX\ni=0\ni\nmBi,m(t)\n(10.65)\nIn other words, the monomial t can be expressed as the weighted sum of Bernstein\npolynomials with coefficients evenly spaced in the interval [0, 1].\n- Create a graph of function f(t). Then the graph will become a B ezier curve\nf(t) =\n\nt\nf(t)\n!\n=\nM\nX\ni=0\n\ni\nm\ncB\ni\n!\nBi,m(t)\n(10.66)\nwhere ( i\nm, cB\ni )T are control points.\n- Now the problem of finding roots of the univariate polynomial has been transformed into\na problem of finding the intersection of the B ezier curve with the parameter axis.\n\n- Using the convex hull property, we discard the regions which do not contain the roots\nby applying the de Casteljau subdivision algorithm and find a sub-region of [0,1] which\ncontain the root.\n- If the sub-region is sufficiently small, we conclude that there is a root inside and return\nit.\n- But when there are more than one root in the sub-region, the sub-region will not be\nreduced. In such case we split the region evenly.\n- Scale the sub-region so that it will become [0,1] using affine parameter transformation\nand go back to *.\nExample 1: Projected Polyhedron Method in one variable\nFind the roots of f(x) = -1.1x2 + 1.4x -0.2 = 0 where 0 ≤x ≤2.\nThe roots are\napproximately, 0.164 and 1.108.\n- Affine parameter transformation\nPlug x = 0 + (2 -0)t = 2t into f(x)\nf(t) = -4.4t2 + 2.8t -0.2 = 0 where 0 ≤t ≤1\n- Monomial to Bernstein basis\nWe have cM\n0 = -0.2, cM\n1 = 2.8 and cM\n2 = -4.4, thus using\ncB\ni =\ni\nX\nj=0\n(i\nj)\n(m\nj )cM\nj\n(10.67)\nwe obtain cB\n0 = -0.2, cB\n1 = 1.2 and cB\n2 = -1.8\n- Use linear precision property of the Bernstein polynomial\nt =\nX\ni=0\ni\n2Bi,2(t)\n(10.68)\n- Create a graph of function f(t). Then the graph will become a B ezier curve\nf(t) =\n\nt\nf(t)\n!\n=\nX\ni=0\n\ni\ncB\ni\n!\nBi,2(t)\n(10.69)\n- Now the control points of the B ezier curve is as follows:\n(0, -0.2), (0.5, 1.2) and (1, -1.8).\n- * Construct a convex hull of the B ezier curve. In this example it is a triangle whose\nvertices are the control points (0, -0.2), (0.5, 1.2) and (1, -1.8).\n\n- The convex hull intersects the t-axis with t = 0.0714 and t = 0.7.\n- Discard the regions 0 ≤t ≤0.0714 and 0.7 ≤t ≤1, which do not contain roots by\nappling the de Casteljau algorithm.\n- Now we have a smaller convex hull which contains the roots.\n(Shaded triangular in\nFigure 10.36)\n- Since there are two roots in the convex hull the sub-region will not reduce much. There-\nfore we split the region evenly and scale the two boxes so that it will become [0,1] using\nthe affine parameter transformation and repeat the process until the two sub-regions\nbecome small enough.\nt\nf(t)\nt=0.0714\nt=0.7\n(0.5, 1.2)\n(0, -0.2)\n(1, -1.8)\nFigure 10.36: de Casteljau Algorithm applied to the quadratic B ezier curve\nExample 2: Projected Polyhedron Method in two variables\nTwo intersecting circles x2 + y2 =\n16, (x -1)2 + y2 = 1\n4, see Figure 10.33. Let\nf(x, y) = x2 + y2 -9\n16 = 0,\n-1 ≤x, y ≤1\n(10.70)\ng(x, y) = (x -1)2 + y2 -1\n4 = 0,\n-1 ≤x, y ≤1\n(10.71)\n- Affine parameter transformation\ns = x -(-1)\n1 -(-1) = x + 1\n(10.72)\nt = y -(-1)\n1 -(-1) = y + 1\n(10.73)\n(10.74)\nPlug x = 2s -1 and y = 2t -1 into equations (10.70) (10.71), then we have\nf(s, t) = 4s2 -4s + 4t2 -4t + 23\n16 = 0\n(10.75)\ng(s, t) = 4s2 -8s + 4t2 -4t + 19\n4 = 0\n(10.76)\n\n- Monomial to Bernstein basis\ncB\nij =\ni\nX\nk=0\nj\nX\nl=0\n(i\nk)(j\nl )\n(m\nk )(n\nl )cM\nkl\n(10.77)\nWe obtain\nf(s, t) =\nX\ni=0\nX\nj=0\nf B\nij Bi,2(s)Bi,2(t)\n(10.78)\ng(s, t) =\nX\ni=0\nX\nj=0\ngB\nijBi,2(s)Bi,2(t)\n(10.79)\nwhere\nf B\n00 = 1.4375,\nf B\n01 = -0.5625,\nf B\n02 = 1.4375\nf B\n10 = -0.5625,\nf B\n11 = -2.5625,\nf B\n12 = -0.5625\nf B\n20 = 1.4375,\nf B\n21 = -0.5625,\nf B\n22 = 1.4375\nand\ngB\n00 = 4.75,\ngB\n01 = 2.75,\ngB\n02 = 4.75\ngB\n10 = 0.75,\ngB\n11 = -1.25,\ngB\n12 = 0.75\ngB\n20 = 0.75,\ngB\n21 = -1.25,\ngB\n22 = 0.75\n- Use linear precision property of the Bernstein polynomial and create a graph.\nf(s, t) =\n\ns\nt\nf(s, t)\n\n=\nX\ni=0\n\ni\n2j\nf B\nij\n\nBi,2(s)Bi,2(t)\n(10.80)\ng(s, t) =\n\ns\nt\ng(s, t)\n\n=\nX\ni=0\n\ni\n2j\ngB\nij\n\nBi,2(s)Bi,2(t)\n(10.81)\nThe two B ezier surfaces are shown in Figure 10.37.\nNow we will find the intersections of three surfaces, f(s, t), g(s, t) and xy-plane. Figure\n10.38 shows the intersection between the plane and both B ezier surfaces. We can easily\nobserve that the two intersection curves are the circles in Figure 10.33.\n- Project the control points of f(s, t) and g(s, t) into xz and yz planes.\n- For each xz and yz plane, construct the 2D convex hulls. Solid line corresponds to f(s, t)\nand the dotted line corresponds to g(s, t).\n\nx\ny\nz\nx\ny\nz\nFigure 10.37: B ezier surfaces and their control points\nFigure 10.38: B ezier surfaces intersecting with xy-plane\nFigure 10.39: Projections of Control Points\n\n- Intersect the convex hull with horizontal axis. Because the polygon is convex, the inter-\nsection may be either a closed interval (which may degenerate to a point) or empty. If\nit is empty, then no root of the system exists within the given search box.\n- Intersect the intervals with one another. Again, if the result is empty, no root exists\nwithin the given search box.\n10.13\nInterval Methods\n10.13.1\nMotivation\nNonlinear solvers operating in rational arithmetic are robust, but are generally time-consuming.\nOn the other hand, nonlinear solvers operating in float point arithmetic are faster, but not\nrobust. Interval methods solve the two problems, namely, nonlinear solvers operating in interval\narithmetic are inexpensive compared to rational arithmetic, and they are robust.\nx\ny\no\nFigure 10.40: Curves y = x4 and y = 0 contact tangentially at the origin.\nExample\nSuppose we have a degree four planar B ezier curve whose control points are given by\n(-0.5, 0.0625),\n(-0.25, -0.0625),\n(0, 0.0625),\n(0.25, -0.0625),\n(0.5, 0.0625) (10.82)\nas shown in Figure 10.40. This B ezier curve is equivalent to the explicit curve y = x4 (-0.5 ≤\nx ≤0.5). Apparently the curve intersects with x-axis tangentially at (x, y) = (0, 0). However,\nif the curve has been translated by +1 in the y direction and translated back to the original\nposition by moving by -1\n3 three times during a geometric processing session, the curve will\ngenerally not be the same as the original curve if floating point arithmetic (FPA) is used for the\ncomputation. For illustration, let us assume a decimal computer with a four-digit normalized\nmantissa, and the computer rounds offintelligently rather than truncating. Then the rational\nnumber -1\n3 will be stored in the decimal computer as -0.3333 × 100 and after the processing\nthe new control points will be\n(-0.5, 0.0631),\n(-0.25, -0.0624),\n(0, 0.0631),\n(0.25, -0.0624),\n(0.5, 0.0631) (10.83)\n\nIf we evaluate the curve at parameter value t = 0.5, we obtain (0, 0.00035) instead of (0,0).\nTherefore there exists a numerical gap which could later lead to inconsistency between topo-\nlogical structures and geometric equations. For example, if these new control points are used\nfor computing intersections with the x-axis, the computer will return no solutions when the\ntolerance is smaller than 0.00035. The above problem illustrates the case when the error is\ncreated during the formulation of the governing equations by various algebraic transformations.\n10.13.2\nDefinitions\nAn interval is a set of real numbers defined below [21]:\n[a, b] = {x|a ≤x ≤b}\n(10.84)\nTwo intervals [a, b] and [c, d] are said to be equal if\na = c\nand\nb = d\n(10.85)\nThe intersection of two intervals is empty or [a, b] ∩[c, d] = ∅, if either\na > d\nor\nc > b\n(10.86)\nOtherwise,\n[a, b] ∩[c, d] = [max(a, c), min(b, d)]\n(10.87)\nThe union of the two intersecting intervals is\n[a, b] ∪[c, d] = [min(a, c), max(b, d)].\n(10.88)\nAn order of intervals is defined by\n[a, b] < [c, d] if and only if b < c.\n(10.89)\nThe width of an interval [a, b] is b -a.\nThe absolute value is\n|[a, b]| = max(|a|, |b|).\n(10.90)\nExamples\n[2, 4] ∩[3, 5] = [max(2, 3), min(4, 5)] = [3, 4]\n[2, 4] ∪[3, 5] = [min(2, 3), max(4, 5)] = [2, 5]\n|[-7, -2]| = max(| -7|, | -2|) = 7\n\n10.13.3\nInterval Arithmetic\n[a, b] *[c, d] = {x *y | x ∈[a, b] and y ∈[c, d]}.\n(10.91)\nwhere *represents an arithmetic operation *∈{+, -, ·, /}. Using the end points of the two\nintervals, we can rewrite equation (10.91) as follows\n[a, b] + [c, d] = [a + c, b + d]\n[a, b] -[c, d] = [a -d, b -c]\n[a, b] · [c, d] = [min(ac, ad, bc, bd), max(ac, ad, bc, bd)]\n[a, b]/[c, d] = [min(a/c, a/d, b/c, b/d), max(a/c, a/d, b/c, b/d)]\n(10.92)\nprovided 0 ∈[c, d] in the division relation.\nExamples\n[2, 4] + [3, 5] = [2 + 3, 4 + 5] = [5, 9]\n[2, 4] -[3, 5] = [2 -5, 4 -3] = [-3, 1]\n[2, 4] · [3, 5] = [min(2 · 3, 2 · 5, 4 · 3, 4 · 5), max(2 · 3, 2 · 5, 4 · 3, 4 · 5)] = [6, 20]\n[2, 4]/[3, 5] = [min(2/3, 2/5, 4/3, 4/5), max(2/3, 2/5, 4/3, 4/5)] = [2/5, 4/3]\n10.13.4\nAlgebraic Properties\nInterval arithmetic is commutative and associative.\n[a, b] + [c, d] = [c, d] + [a, b]\n[a, b] · [c, d] = [c, d] · [a, b]\n[a, b] + ([c, d] + [e, f]) = ([a, b] + [c, d]) + [e, f]\n[a, b] · ([c, d] · [e, f]) = ([a, b] · [c, d]) · [e, f]\nBut it is not distributive, however, it is subdistributive.\nExamples\n[1, 2]([1, 2] -[1, 2]) = [1, 2]([-1, 1]) = [-2, 2]\n[1, 2][1, 2] -[1, 2][1, 2] = [1, 4] -[1, 4] = [-3, 3]\n10.13.5\nRounded Interval Arithmetic and its Implementation\nOne has to keep in mind that any sequence of operations on a digital computer is essentially\nequivalent to a finite sequence of manipulations on a discrete grid of points. For example, a\nfloating point number in the general form is given by [11]\n(±).d1d2 · · · dp · 2exp,\n\nwhere d1d2 · · ·dp is mantissa with d1 = 0, and p is the number of significant digits, and exp\nis the integer exponent. If p = 2 and -2 ≤exp ≤3 then a list of positive numbers in this\nsystem is\n.10 ∗2-2\n=\n.11 ∗2-2 = 3\n.10 ∗2-1\n=\n.11 ∗2-1 = 3\n.10 ∗20\n=\n.11 ∗20 = 3\n.10 ∗21\n=\n.11 ∗21 = 3\n.10 ∗22\n=\n.11 ∗22 = 3\n.10 ∗23\n=\n.11 ∗23 = 6\n0 1\n-\n-\n-\n-\n-\n-\n-\nFigure 10.41: Nonnegative floating-point numbers on the interval [0,6], adapted from [11]\nIf floating-point arithmetic is used to evaluate these interval arithmetic equations there is\nno guarantee that the roundings of the bounds are performed conservatively. 1.\nMost commercial processors implement floating-point arithmetic using the representation\ndefined by ANSI/IEEE Std 754-1985, Standard for Binary Floating-Point Arithmetic [2]. This\nstandard defines the binary representation of the floating-point number X in terms of a sign\nbit s, an integer exponent E, for Emin ≤E ≤Emax, and a p-bit significand (or mantissa) B,\nwhere:\nX = (-1)s2EB\n(10.93)\nThe significand B is a sequence of p bits b0b1 · · ·bp-1, where bi = 0 or 1, with an implied\nbinary point (analogous to a decimal point) between bits b0 and b1. Thus, the value of B is\ncalculated as:\n1This statement is true only for the default IEEE-754 rounding mode of round towards nearest\n\nB = b0.b1b2 · · · bp-1 = b020 +\np-1\nX\nbi2-i\n(10.94)\nFor double precision arithmetic, the standard defines p = 53, Emin = -1022, and Emax =\n1023. The number X is represented as a 64-bit quantity with sign bit s, an 11-bit biased ex-\nponent e = E +1023, and a 52-bit fractional mantissa m composed of the bit string b1b2 · · ·b52.\nSince the exponent can always be selected such that b0 = 1 (and thus, 1 ≤B < 2), the value\nof b0 is constant and it does not need to be stored in the binary representation.\n· · ·\n· · ·\ns\ne\nm\nThe integer value of the 11-bit biased exponent e is calculated as:\ne = e0e1 · · · e10 =\nX\nei210-i\n(10.95)\nULP (One Unit in the Last Place)\nIf x and x′ are consecutive positive double-precision numbers, they differ by an amount ε\ncalled ulp. To calculate ulp it is necessary to extract the integer value of the exponent from the\nbinary representation. Recall that the value of the significand B of a double precision number\nX is:\nB = 1 + b12-1 + b22-2 + · · · + b522-52\n(10.96)\nand that the double precision value X = (-1)s2EB. The value of the least significant bit b52\nis 2-52. Thus, the value of ulp is 2E2-52 = 2E-52.\nRounded interval arithmetic [19, 20] ensures that the computed end points always contain\nthe exact interval as follows:\n[a, b] + [c, d]\n≡\n[a + c -εl, b + d + εu]\n[a, b] -[c, d]\n≡\n[a -d -εl, b -c + εu]\n[a, b] · [c, d]\n≡\n[min(a·c, a·d, b·c, b · d) -εl, max(a·c, a·d, b·c, b·d) + εu]\n[a, b] / [c, d]\n≡\n[min(a/c, a/d, b/c, b/d) -εl, max(a/c, a/d, b/c, b/d) + εu]\n(10.97)\nwhere εland εu are the units-in-last-place and are denoted by ulpland ulpu. When per-\nforming standard operations for interval numbers using RIA, the lower bound is extended to\ninclude its previous consecutive floating-point number, which is smaller than the lower bound\nby ulpl. Similarly, the upper bound is extended by ulpu to include its next consecutive num-\nber. Thus, the width of the result is enlarged by ulpl+ ulpu and the result will be reliable in\nsubsequent operations.\nExample\n\nmain()\n{\ndouble a = 1.5;\nInterval b = 1.5;\ndouble dresult = pow(a, 20.);\nInterval iresult = pow(b, 20.);\n}\ndresult 3325.2567300796509\niresult [3325.2567300796404,3325.2567300796613]\n10.14\nInterval Projected Polyhedron Algorithm\nWe extend the de Casteljau subdivision method to operate in rounded interval arithmetic in\norder to find all the roots of a polynomial system robustly. We illustrate the concept for a\nsingle polynomial equation.\n(x - 0.1)(x - 0.6)(x - 0.7) = 0\n\nFloating Point Arithmetic\nIter\nBounding Box (FPA)\nMessage\n[0,1]\n[0.0763636363636364, 0.856]\n[0.098187732239346, 0.770083868323999]\n[0.0999880766853688, 0.72387404781026]\nBinary Sub.\n[0.402239977003124, 0.704479954527487]\n[0.550441290533288, 0.700214508664293]\n[0.591018492648952, 0.700000534482207]\n[0.599458794784619, 0.700000000003332]\nBinary Sub.\n[0.649998841568898, 0.699999999999999]\nNo Root\n[0.599997683137796, 0.649998841568898]\nRoot Found\n[0.099999999478761, 0.402239977003124]\nRoot Found\nt\nf(t)\n[P1]\n[P2]\n[P0]\nt=tA\nL\nt=tB\nU\nFigure 10.42: Interval Projected Polyhedron Method\nRounded Interval Arithmetic\nIter\nBounding Box (RIA)\nMessage\n[0, 1]\n[0.076363636363635, 0.856000000000001]\n[0.0981877322393447, 0.770083868324001]\n[0.0999880766853675, 0.723874047810262]\nBinary Sub.\n[0.402239977003124, 0.704479954527489]\n[0.550441290533286, 0.700214508664294]\n[0.591018492648947, 0.700000534482208]\n[0.599458794784611, 0.700000000003333]\nBinary Sub.\n[0.649998841568894, 0.7]\nRoot Found\n[0.599997683137788, 0.649998841568895]\nRoot Found\n[0.0999999994787598, 0.402239977003124]\nRoot Found\nMost applications mentioned above result in n nonlinear polynomial equations with n\nunknowns, referred to as balanced systems.\nHowever, there exist some problems such as\n\ntangential and overlapping intersection or implicit curve/surface rendering consisting of n\nnonlinear polynomial equations with m unknowns, where n could be larger or smaller than m.\nWhen n > m the system is called overconstrained and when n < m it is called underconstrained.\nHere is an algorithm (the interval n-dimensional Projected-Polyhedron algorithm) such that\nit can effectively handle overconstrained problems [15].\nSuppose we solve a system of nonlinear interval polynomial equations [f] = ([f1], [f2], . . . , [fn]) =\n0 over the box S ∈Rm (n > m, n = m, n < m) where S is defined by\nS = [a1, b1] × [a2, b2] × . . . × [am, bm].\n(10.98)\nand each [fi] is an interval polynomial in m variables. That is, we wish to find all u ∈S such\nthat\n[f1](u) = [f2](u) = . . . = [fn](u) = 0.\n(10.99)\nBy making the affine parameter transformation [13] ui = ai + xi(bi -ai) for i = 1, · · ·m, we\nsimplify the problem to the problem of determining all x ∈[0, 1]m such that\n[f1](x) = [f2](x) = . . . = [fn](x) = 0.\n(10.100)\nNow furthermore suppose that each of the [fk] is polynomial in the independent parameters\nx1, x2, . . . , xm. Let d(k)\ni\ndenote the degree of [fk] in the variable xi; then [fk] can be written in\nthe multivariate Bernstein basis:\n[fk](x) =\nd(k)\n1X\ni1=0\nd(k)\n2X\ni2=0\n. . .\nd(k)\nm\nX\nim=0\n[w(k)\ni1i2...im]Bi1,d(k)\n1 (x1)Bi2,d(k)\n2 (x2) . . . Bin,d(k)\nm (xm).\n(10.101)\nwhere Bi,m is the ith Bernstein polynomial. The notation in (10.101) may be simplified by\nletting I = (i1, i2, . . . im), D(k) = (d(k)\n1 ,d(k)\n2 ,. . .,d(k)\nm ) and writing (10.101) in the equivalent form\n[27]\n[fk](x) =\nD(k)\nX\nI\n[w(k)\nI ]BI,D(k)(x).\n(10.102)\nHere we have merely rewritten the product of Bernstein polynomials as a single Bernstein\nmultinomial BI,D(k)(x). Bernstein polynomials have a useful identity called linear precision\nproperty [13], in other words, the monomial t can be expressed as the weighted sum of Bernstein\npolynomials with coefficients evenly spaced in the interval [0, 1]. Using this property, we can\nrewrite equations (10.102) as follows:\n[Fk](x) =\nD(k)\nX\nI\n[v(k)\nI ]BI,D(k)(x)\n(10.103)\nwhere\n[v(k)\nI ] = ([ i1\nd(k)\n], [ i2\nd(k)\n], . . . , [ im\nd(k)\nm\n], [w(k)\nI ]).\n(10.104)\nThese [v(k)\nI ] are called the interval control points of [Fk]. Now the algebraic problem of finding\nroots of systems of polynomials has been transformed to the geometric problem involving the\n\nintersection of the hypersurfaces. Because the problem is now phrased geometrically, we can\nuse the convex hull property of the multivariate Bernstein basis to bound the set of roots. We\ncan structure a root-finding algorithm as follows:\n1. Start with an initial box of search.\n2. Scale the box and, as we did in converting between equations (10.99) and (10.100),\nperform an appropriate affine parameter transformation to the functions fk, so that the\nbox becomes [0, 1]m. However, keep track of the scaling relationship between this box\nand the initial box of search. This transformation can be performed with multivariate\nDe Casteljau subdivision.\n3. Using the convex hull property, find a sub-box of [0, 1]m which contains all the roots.\nThe essential idea behind the box generation scheme in this algorithm is to transform\na complicated m + 1-dimensional problem into a series of m two-dimensional problems.\nSuppose Rm+1 can be coordinatized with the x1, x2, . . . , xm+1 axes; we can then employ\nthese steps:\n(a) Project the [v(k)\nI ] of all of the [Fk] into m different coordinate planes; specifically,\nthe (x1, xm+1)-plane, the (x2, xm+1)-plane, and so on, up to the (xm, xm+1) plane.\n(b) In each one of these planes,\ni. Construct n two-dimensional convex hulls. The first is the convex hull of the\nprojected control points of [F1], the second is from [F2] and so on.\nii. Intersect each convex hull with the horizontal axis (that is, xm+1 = 0). Because\nthe polygon is convex, the intersection may be either a closed interval (which\nmay degenerate to a point) or empty. If it is empty, then no root of the system\nexists within the given search box.\niii. Intersect the intervals with one another. Again, if the result is empty, no root\nexists within the given search box.\n(c) Construct an m-dimensional box by taking the Cartesian product of each one of\nthese intervals in order.\nIn other words, the x1 side of the box is the interval\nresulting from the intersection in the (x1, xm+1)-plane, and so forth.\n4. Using the scaling relationship between our current box and the initial box of search, see\nif the new sub-box represents a sufficiently small box in Rm. If it does not, then go to\nstep 5. If it does, then check the convex hulls of the hypersurface in the new box. If\nthe convex hulls cross each variable axis, conclude that there is a root or at least an\napproximate root in the new box, and put the new box into a root list. Otherwise the\nnew box is discarded (see Appendix for elaboration of this point).\n5. If any dimension of this sub-box are not much smaller than 1 unit in length (i.e., the\nbox has not decreased much in size along one or more sides), split the box evenly along\neach dimension which is causing trouble. Continue on to the next iteration with several\nindependent sub-problems.\n\n6. If none of the boxes is left, then the root-finding process is over. Otherwise, go back to\nstep 2, and perform it once for each new box.\nIf we assume that each equation 10.99 is degree m in each variable and the system is n-\ndimensional, then the total asymptotic time per step is of O(n2mn+1). The number of steps\ndepends primarily on the accuracy required [27].\nThe Projected Polyhedron Algorithm achieves quadratic convergence in one dimension,\nwhile for higher dimensions, it exhibits at best linear convergence.\n10.15\nInterval Newton method\nInterval Newton methods 2 have been the focus of significant attention in numerical analysis.\nA thorough review of various types of interval Newton methods is presented in [3]. In the\nsequel we briefly review the interval Newton method. The interval Newton method solves a\nsystem of nonlinear equations in a numerically verifiable manner.\nfi(x1, x2, · · ·, xn) = 0,\n1 ≤i ≤n\n(10.105)\nwithin boxes\nai ≤xi ≤bi,\n1 ≤i ≤n\n(10.106)\nIf we denote the n-vector whose ith component is xi by X and the n-vector whose ith component\nis fi by F(X), the interval Newton methods can be described as finding a box Xk that contains\nall the solutions of the interval linear system\nJ(Xk)( Xk -Xc\nk) = -F(Xc\nk)\n(10.107)\nwhere the subscript k denotes the kth iteration, J(Xk) is the Jacobian matrix of F over the\nbox Xk, and Xc\nk is some point in Xk. There is a theorem about unique solution in the box\ngiven by [16]:\nTheorem\nIf Xk is strictly contained in Xk, then the system of equations in (10.105) has a unique\nsolution in Xk, and Newton's method starting from any point in Xk will converge to that\nsolution. Conversely, if Xk ∩ Xk is empty, then there are no solutions of the system in\n(10.105).\nThe next iteration Xk+1 is evaluated by\nXk+1 = Xk ∩ Xk\n(10.108)\nAccording to the mean value theorem, the solutions in the Xk must be in Xk+1.\nIf the\ncoordinate intervals of Xk+1 are smaller than those of Xk, equations (10.107) and (10.108)\n2When we use the term \"interval Newton method\", we assume that bisection is included in the process\nwhen interval reduction is not substantial by the pure interval Newton step.\n\nare iterated until the bounding boxes are smaller than a specified tolerance. If the coordinate\nintervals of Xk+1 are not smaller than those of Xk, then one of these intervals is bisected to\nform two new boxes. The boxes are pushed into a stack and iteration is continued until the\nstack becomes empty. The first interval Newton method introduced by Moore [21] involves\ncomputing the inverse of the interval matrix J(Xk). Hansen [12] introduced the Gaussian\nelimination procedure to solve the linear equation system in an interval Newton method.\nKrawczyk [12] introduced a variation of the interval Newton method which avoids the Gaussian\nelimination of an interval matrix by not attempting to obtain a sharp solution of (10.107). He\ncomputes the new box Xk as follows\nXk = K(Xk) = Xc\nk -YkF(Xc\nk) + (I -YkJ(Xk))(Xk -Xc\nk)\n(10.109)\nwhere Yk is a preconditioned matrix of midpoints of the elements of the interval Jocobian\nmatrix. Hansen and Sengupta [12] introduced a box which is generally smaller than K(Xk).\nThey simply solve the ith equation for the ith variable and replace the others by bounding\nintervals, which is the non-linear version of the Gauss-Seidel operator for linear systems. Let xc\ni\nbe the ith component of Xc\nk and ki be the ith component of YkF(Xk) and Gij be the entry in\nthe ith row and jth column of YkJ(Xk) then, the step for the ith row of the Hansen-Sengupta\noperator becomes\nxi\n=\nxi -[Gii]-1[ki +\ni-1\nX\nj=1\nGij(ˆxj -xc\nj) +\nn\nX\nj=i+1\nGij(xj -xc\nj)]\n(10.110)\nˆxi\n=\nxi ∩ xi\nfor i = 1, · · · , n.\n\nBibliography\n[1] S. L. Abrams, W. Cho, C.-Y. Hu, T. Maekawa, N. M. Patrikalakis, E. C. Sherbrooke, and\nX. Ye. Efficient and reliable methods for rounded-interval arithmetic. Computer-Aided\nDesign, 30(8):657-665, July 1998.\n[2] ANSI/IEEE Std 754-1985. IEEE Standard for Binary Floating-Point Arithmetic. IEEE,\nNew York, 1985. Reprinted in ACM SIGPLAN Notices, 22(2):9-25, February 1987.\n[3] C. Bliek. Computer Methods for Design Automation. PhD thesis, Massachusetts Institute\nof Technology, Cambridge, MA, July 1992.\n[4] B. Buchberger. Gr obner bases: An algorithmic method in polynomial ideal theory. In\nN. K. Bose, editor, Multidimensional Systems Theory: Progress, Directions and Open\nProblems in Multidimensional Systems, pages 184-232. Dordrecht, Holland: D. Reidel\nPublishing Company, 1985.\n[5] J. F. Canny. Generalized characteristic polynomials. Journal of Symbolic Computation,\n9:241-250, 1990.\n[6] G. Dahlquist and A. Bj orck. Numerical Methods. Prentice-Hall, Inc., Englewood Cliffs,\nNJ, 1974.\n[7] R. T. Farouki and V. T. Rajan. Algorithms for polynomials in Bernstein form. Computer\nAided Geometric Design, 5(1):1-26, June 1988.\n[8] I. D. Faux and M. J. Pratt. Computational Geometry for Design and Manufacture. Ellis\nHorwood, Chichester, England, 1987.\n[9] C. B. Garcia and W. I. Zangwill. Global continuation methods for finding all solutions\nto polynomial systems of equations in n variables. In A. V. Fiacco and K. O. Kortanek,\neditors, Extremal Methods and Systems Analysis, pages 481-497. Springer-Verlag, New\nYork, NY, 1980.\n[10] A. Geisow. Surface Interrogations. PhD thesis, School of Computing Studies and Accoun-\ntancy, University of East Anglia, Norwich NR47TJ, U. K., July 1983.\n[11] C. F. Gerald and P. O. Wheatley. Applied Numerical Analysis. Addison-Wesley, Reading,\nMA, 4th edition, 1990.\n\n[12] E. Hansen and S. Sengupta. Bounding solutions of systems of equations using interval\nanalysis. BIT, 21:201-211, 1981.\n[13] J. Hoschek and D. Lasser.\nFundamentals of Computer Aided Geometric Design.\nA.\nK. Peters, Wellesley, MA, 1993. Translated by L. L. Schumaker.\n[14] C. Y. Hu, T. Maekawa, N. M. Patrikalakis, and X. Ye. Robust interval algorithm for\nsurface intersections. Computer-Aided Design, 29(9):617-627, September 1997.\n[15] C. Y. Hu, T. Maekawa, E. C. Sherbrooke, and N. M. Patrikalakis. Robust interval algo-\nrithm for curve intersections. Computer-Aided Design, 28(6/7):495-506, June/July 1996.\n[16] R. B. Kearfott and M. Novoa. INTBIS, a portable interval Newton/bisection package\n(algorithm 681). ACM Transactions on Mathematical Software, 16(2):152-157, June 1990.\n[17] G. A. Kriezis, P. V. Prakash, and N. M. Patrikalakis. Method for intersecting algebraic\nsurfaces with rational polynomial patches. Computer-Aided Design, 22(10):645-654, De-\ncember 1990.\n[18] J. M. Lane and R. F. Riesenfeld. Bounds on a polynomial. BIT: Nordisk Tidskrift for\nInformations-Behandling, 21(1):112-117, 1981.\n[19] T. Maekawa and N. M. Patrikalakis. Computation of singularities and intersections of\noffsets of planar curves. Computer Aided Geometric Design, 10(5):407-429, October 1993.\n[20] T. Maekawa and N. M. Patrikalakis. Interrogation of differential geometry properties for\ndesign and manufacture. The Visual Computer, 10(4):216-237, March 1994.\n[21] R. E. Moore. Interval Analysis. Prentice-Hall, Englewood Cliffs, NJ, 1966.\n[22] M. E. Mortenson. Geometric Modeling. John Wiley and Sons, New York, 1985.\n[23] T. Nishita, T. W. Sederberg, and M. Kakimoto. Ray tracing trimmed rational surface\npatches. ACM Computer Graphics, 24(4):337-345, August 1990.\n[24] N. M. Patrikalakis. Surface-to-surface intersections. IEEE Computer Graphics and Ap-\nplications, 13(1):89-95, January 1993.\n[25] N. M. Patrikalakis and P. V. Prakash.\nSurface intersections for geometric modeling.\nJournal of Mechanical Design, Transactions of the ASME, 112(1):100-107, March 1990.\n[26] H. Pottmann.\nGeneral offset surfaces.\nNeural, Parallel and Scientific Computations,\n5:55-80, 1997.\n[27] E. C. Sherbrooke and N. M. Patrikalakis.\nComputation of the solutions of nonlinear\npolynomial systems. Computer Aided Geometric Design, 10(5):379-405, October 1993.\n[28] W. I. Zangwill and C. B. Garcia.\nPathways to solutions, fixed points, and equilibria.\nPrentice-Hall, Englewood Cliffs, NJ, 1981."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes13.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/3a77ce2173073840510f548601cd36b4_lecnotes13.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 13\nN. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\n13 Offsets of Parametric Curves and Surfaces\n13.1 Motivation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13.2 Parametric offset curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13.2.1 Differential geometry of parametric offset curves\n. . . . . . . . . . . . .\n13.2.2 Singularities of parametric offset curves\n. . . . . . . . . . . . . . . . . .\n13.2.3 Approximations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13.3 Parametric offset surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13.3.1 Differential geometry of parametric offset surfaces\n. . . . . . . . . . . .\n13.3.2 Singularities of parametric offset surfaces\n. . . . . . . . . . . . . . . . .\n13.3.3 Tracing algorithm\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13.3.4 Self-intersections of offsets of explicit quadratic surfaces . . . . . . . . .\n13.3.5 Approximations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\nReading in the Textbook\n- Chapter 11, pp. 293 - 353\n\nLecture 13\nOffsets of Parametric Curves and\nSurfaces\n13.1\nMotivation\nOffsets are defined as the locus of points at a signed distance d along the normal of a planar\ncurve or surface. A literature survey on offset curves and surfaces up to 1992 was carried out\nby Pham [24], while the overview of the literature after 1992 and those which were not cited in\n[24] is given by Maekawa [14]. Offset curves and surfaces are widely used in various engineering\napplications, such as\n- Tool path generation for pocket(2.5D), 3D and 5D NC machining [9, 1]. (See Figure 13.1).\nGenerator Surface\nTool Driving Plane\nCenter of Ball\nEndmill\nBall Endmill\nTool Path\nOffset Surface\nFigure 13.1: NC machining.\n\n- Definition of tolerance regions [4, 26, 21]. (See Figure 13.2).\nFigure 13.2: Definition of tolerance regions.\n- Access space representations in robotics [12]. (See Figure 13.3)\nFigure 13.3: Access space representations in robotics.\n\n- Curved plate (shell) representation in solid modeling [23]. (See Figure 13.4)\nFigure 13.4: Plate representation.\n- Feature recognition through construction of skeletons or medial axes of geometric models\n[22, 29]. (See Figure 13.5). The medial axis is made up of boundary offset intersections.\nFigure 13.5: Medial Axis.\nThe concept of offset curves generalizes to\n- pipe surfaces when the progenitor is a general 3D curve [18].\n- geodesic offsets when the progenitor is curve on a surface [20] [25] [11].\n\n13.2\nParametric offset curves\n13.2.1\nDifferential geometry of parametric offset curves\n- A planar parametric curve r(t) is given by\nr(t) = [x(t), y(t)] ,\nt ∈[0, 1]\n(13.1)\nwhere x and y are differentiable functions of a parameter t.\n- The unit normal vector of a plane curve, which is orthogonal to t, is given by\nn = t × ez =\n( y(t), - x(t))\np\nx2(t) + y2(t)\n(13.2)\nwhere ez = (0, 0, 1) is a unit vector perpendicular to the plane of the curve, see Figure\n13.6.\n- For a plane curve, the Frenet formulae reduce to\ndt\nds = -κn,\ndn\nds = κt\n(13.3)\nwhere κ is the signed curvature of the curve given by\nκ = ( r × r) · ez\nv3\n=\nx y - y x\n( x2 + y2)\n(13.4)\nwhere v = | r(t)| is the parametric speed. The curvature κ of a curve at point P is positive\nwhen the direction of n and\n\nPC are opposite where C is the center of the curvature of\nthe curve at point P, see Figure 13.6.\nC\nP\nr(t)\nn\nt\nx\ny\nez\nFigure 13.6: Definitions of unit tangent and normal vectors.\n\n- A planar offset curve ˆr(t) with signed offset distance d to the progenitor r(t) is defined\nby\nˆr(t) = r(t) + dn(t)\n(13.5)\nwhere d > 0 corresponds to positive (\"exterior\") and d < 0 corresponds to negative\n(\"interior\") offsets.\n- The unit tangent vector of the offset curve (see Figure 13.7 for illustration)\nˆt =\nˆr\n| ˆr|\n= 1 + κd\n|1 + κd|t\n(13.6)\n- The unit normal vector of the offset curve (see Figure 13.7 for illustration)\nˆn = ˆt × ez = 1 + κd\n|1 + κd|n\n(13.7)\n- Curvature of the offset curve\nˆκ =\nκ\n|1 + κd|\n(13.8)\n13.2.2\nSingularities of parametric offset curves\nThere are two kinds of singularities on the offset curves, irregular points and self-intersections.\n- Irregular points\nIsolated points: This point occurs when the progenitor curve with radius R is a circle and\nthe offset is d = -R.\nCusps: This point occurs at a point t where the tangent vector vanishes.\nκ(t) = -1\nd\n(13.9)\nA cusp at t = tc can be further subdivided into [7]:\n1. Ordinary cusps when κ(tc) = 0\n2. Extraordinary points when κ(tc) = 0 and κ(tc) = 0.\nNote that (1 + κd)/|1 + κd| in equations (13.6) and (13.7) changes abruptly from -1 to 1\nwhen the parameter t passes through t = tc at an ordinary cusp, while at extraordinary\npoints (1 + κd)/|1 + κd| does not change its value, see Figure 13.7.\nEquation (13.9) for r(t) = {x(t), y(t)} can be reduced to\nd [ x(t) y(t) - x(t) y(t)] -\nq\nx2(t) + y2(t)\nh\nx2(t) + y2(t)\ni\n= 0\n(13.10)\n\nFigure 13.7: Offsets to a parabola r = [t, t2] (thick solid line) with offsets d=-0.3, -0.5, -0.8,\nadapted from [5]. At d = -0.3 the tangent and normal vectors of the offset have the same\nsense that of the progenitor, while at d = -0.8 they flip directions.\nBy setting τ 2 = x2 + y2 and if r(t) is a rational polynomial curve, the computation of\ncusps can be reduced to system of two nonlinear polynomial equations that can be solved\nusing the methods of Chapter 10.\nExamples (see Figures 13.7 and 13.8)\nGiven a parabola r = (t, t2), the unit tangent and principal normal vectors are given by\nt = dr\nds = dr\ndt\ndt\nds =\n(1, 2t)\n√\n1 + 4t2 ,\nn = t × ez = (2t, -1)\n√\n1 + 4t2\nThe curvature and its derivative are given by\nκ(t) = ( r × r) · ez\n| r|3\n=\n(1 + 4t2)\n,\nκ(t) = -24t(1 + 4t2)\n(1 + 4t2)3\nSince κ(0) = 0, κ(t) reaches an extremum at t = 0 and furthermore as κ(0) < 0, κ(0) is\na maximum with a curvature value κ(0) = 2. Therefore when d > -1\n2 the offset is non-\ndegenerate, while when d = -1\n2, t = 0 is an extraordinary point. Let us solve κ(t) = -1/d\nfor t which yields\nt = ±\nq\n3√\n4d2 -1\n.\nWe can easily see that if d > -1/2, there is no real root. This means that there is no\nsingularity as long as radius of curvature is smaller than 2. If d = -1/2, there exists a\nsingle root t = 0, while if d < -1/2 there exist two symmetric values t1, t2.\n- Self-intersections\n\nSelf-intersections of an offset curve (see also Figures 13.7 and 13.8) can be obtained by\nseeking pairs of distinct parameter values s = t such that\nr(s) + dn(s) = r(t) + dn(t).\n(13.11)\nSubstitution of equation (13.2) in (13.11) yields the system [17]\nx(s) +\ny(s)d\np\nx2(s) + y2(s) = x(t) +\ny(t)d\np\nx2(t) + y2(t)\ny(s) -\nx(s)d\np\nx2(s) + y2(s) = y(t) -\nx(t)d\np\nx2(t) + y2(t)\n(13.12)\nIf r(t) is a rational polynomial curve, this system can be converted to a nonlinear poly-\nnomial system of four equations in four variables s, t, τ and σ where\nτ 2 = x2(s) + y2(s)\n(13.13)\nσ2 = x2(t) + y2(t).\n(13.14)\nSuch a system can be solved using the IPP algorithm, see also [17].\nHowever s = t\nare trivial solutions, and we must exclude them from the system, otherwise a Bernstein\nsubdivision-based algorithm would attempt to solve for an infinite number of roots. In\nthis case we have addressed the problem by dividing out the common factor by some\nalgebraic manipulations [17].\nFigure 13.8: Self-intersection of the offset curve of a parabola. Left: Interior offsets to the\nparabola r(t) = [t, t2] with d = -0.8 and cutter path; Right: Trimmed interior offsets to the\nparabola r(t) = [t, t2] with d = -0.8 and cutter path\n\n13.2.3\nApproximations\n- In general, an offset curve is functionally more complex than its progenitor curve because\nof the square root involved in the expression of the unit normal vector. L u [13] for example\nhas shown that offset of a parabola is a rational curve and its singular point at infinity\nwas studied by Farouki and Sederberg [8]. However, this result has not been generalized\nto higher order curves.\nFarouki and Neff[6] have shown that the two-sided offsets of planar rational polynomial\ncurves are high-degree implicit algebraic curves fo(x, y) = 0 of potentially complex shape.\nThese equations can not typically be separated into two equations describing interior and\nexterior offsets individually. The degree of this implicit offset curve is no = 4n -2 -2m,\nwhere n is the degree of polynomial generator curve r = [x(t), y(t)] and m is the degree\nof φ(t) = GCD(x′(t), y′(t)). For example the degree of the two-sided offset curve of a\nparabola r(t) = (t, t2) is 6 and of a general polynomial cubic curve is 10 with φ(t) a\nconstant.\n- If the progenitor surface is a NURBS curve, then its offset is usually not a NURBS curve,\nexcept for straight lines and circles.\n- Because of the wide application of offset surfaces and the difficulty in directly incorpo-\nrating such entities in geometric modeling systems, due to their potential analytic and\nalgebraic complexity, a number of researchers have developed approximation algorithms\nfor these types of geometries in terms of piecewise polynomial or rational polynomial\nfunctions [27, 10].\n- Summary of an Approximation Algorithm [27], see also Figure 13.9:\n1. Input is a NURBS curve.\n2. Offset each leg of polygon by d.\n3. Intersect consecutive legs of polygon to find new vertices.\n4. Check deviation of the approximate offset with the true offset using as weights (for\nrational function) the weights of the progenitor curve.\n5. If the deviation is larger than the given tolerance subdivide the curve into two and\ngo back to step 1. If the deviation is smaller than the given tolerance stop.\nd\nd\nd\nApproximated Offset Curve\nProgenitor Curve\nFigure 13.9: Offset curve approximation.\n\n13.3\nParametric offset surfaces\n13.3.1\nDifferential geometry of parametric offset surfaces\n- Definition\nA parametric offset surface ˆr(u, v) is a continuum of all points at a constant distance d\nalong normal to another parametric surface r(u, v) and defined as\nˆr(u, v) = r(u, v) + dn(u, v)\n(13.15)\nwhere d may be a positive or negative real number and n is the unit normal vector of\nr(u, v).\n- Sign convention for normal curvature\nThe normal curvature is typically considered positive if its associated center of curvature\nis opposite to the direction of the surface normal.\n- Relation between n and ˆn [28]\nIf ˆn(u, v) is the unit normal vector of ˆr(u, v), then the relation between n and ˆn is given\nby\nˆSˆn = (1 + dκmax)(1 + dκmin)Sn\n(13.16)\nwhere ˆS = |ˆru ×ˆrv| and S = |ru ×rv| or expanding the right hand side of equation (13.16)\nand using the definitions of Gaussian curvature K and mean curvature H\nK = κmaxκmin,\nH = κmax + κmin\n(13.17)\nequation (13.16) can be rewritten as follows:\nˆSˆn = S(1 + 2Hd + Kd2)n\n(13.18)\nIf we take the norm of equation (13.16), we obtain\nˆS = S|(1 + dκmax)(1 + dκmin)|\n(13.19)\nand substituting ˆS into equation (13.16) yields\nˆn = (1 + dκmax)(1 + dκmin)\n|(1 + dκmax)(1 + dκmin)|n\n(13.20)\nFrom this relation n and ˆn are collinear but may be directed in opposite directions, if\ndκmax < -1 or dκmin < -1. This occurs when the offset is taken towards the concave\nregion of the progenitor.\n- Offsetting towards concave region of a surface is equivalent to taking the offset d > 0\nwhere κmin < 0 and d < 0 where κmax > 0, provided the above sign convention is used.\n\n- Gaussian and Mean Curvatures\nˆK =\nK\n1 + 2Hd + Kd2\n(13.21)\nˆH =\nH + Kd\n|1 + 2Hd + Kd2|\n(13.22)\n- Principal Curvatures\nˆκmax =\n(1 + dκmin)κmax\n|1 + dκmax||1 + dκmin|\n(13.23)\nˆκmin =\n(1 + dκmax)κmin\n|1 + dκmax||1 + dκmin|\n(13.24)\nGiven an offset distance d, the critical curvature is defined as κcrit = -1/d then three\ncategories arise [5]:\nκmax > κmin > κcrit: The normal vector of the progenitor and its offset are directed in the\nsame direction. Also the sign of Gaussian and principal curvatures of the offset are the same\nthat of the progenitor.\nκmax > κcrit > κmin: The normal vector of the progenitor and its offset are directed in the\nopposite direction. Also the sign of Gaussian and maximum principal curvatures of the offset\nare opposite to that of the progenitor, while the sign of the minimum principal curvature of\nthe offset is the same to that of the progenitor.\nκmin < κmax < κcrit: The normal vector of the progenitor and its offset are directed in the\nsame direction, while the sign of both principal curvatures of the offset are opposite that of the\nprogenitor and thus the sign of Gaussian curvature of an offset remains the same as that of the\nprogenitor.\n13.3.2\nSingularities of parametric offset surfaces\nFigure 13.10:\nOffset surface (left), region bounded by self-intersection curve (center) and\ntrimmed offset surface (right) of elliptic paraboloid z = 1\n2(1.75x2 + 2y2) with d = 0.6.\n- In NC machining, the cutter radius must not exceed the smallest concave principal\nradius of curvature of the surface to avoid gouging [9].\n\nx\ny z\nFigure 13.11: Self-intersection curves of elliptic paraboloid (α = 2, β = 4) with d = 0.3. The\ndot dashed line in the figure is a set of points of self-intersection curve in the xy-plane mapped\nonto the progenitor surface. A pair of thin solid straight lines emanating from two distinct\npoints on the surface r(s, t), r(u, v) and intersecting along the parabola are the pairs of vectors\ndn(s, t) and dn(u, v).\n- Critical Offset Distance:\nThe largest magnitude of offset distance without degeneracy is called critical offset dis-\ntance dcrit.\nWhen the offset is positive, in the absence of degeneracy due to global\nproperties, the maximum absolute value of the negative minimum principal curvature\non the surface determines dcrit =\nmax(|κmin|). When the offset is negative, in the ab-\nsence of degeneracy due to global properties, the minimum absolute value of the positive\nmaximum principal curvature on the surface determines dcrit =\nmax(κmax). versa.\n- Ridges:\nIt is apparent from equation (13.20) that offset surfaces become singular at points called\nridges. They are defined as a vector-valued mapping of two implicit curves in the uv-\nparametric space to 3D space via the mapping (13.15), which satisfy κmax(u, v) = -1\nd or\nκmin(u, v) = -1\nd [9].\n- Self-intersections:\nSelf-intersections of an offset surface are defined by finding pairs of distinct parameter\nvalues (s, t) = (u, v) such that\nr(s, t) + dn(s, t) = r(u, v) + dn(u, v)\n(13.25)\nsee also Figures 13.10, 13.11.\nFor parametric surfaces r(u, v) = [x(u, v), y(u, v), z(u, v)]\nx(s, t) + ys(s, t)zt(s, t) -yt(s, t)zs(s, t)\nS(s, t)\nd = x(u, v) + yu(u, v)zv(u, v) -yv(u, v)zu(u, v)\nS(u, v)\nd(13.26)\n\ny(s, t) + xt(s, t)zs(s, t) -xs(s, t)zt(s, t)\nS(s, t)\nd = y(u, v) + xv(u, v)zu(u, v) -xu(u, v)zv(u, v)\nS(u, v)\nd(13.27)\nz(s, t) + xs(s, t)yt(s, t) -xt(s, t)ys(s, t)\nS(s, t)\nd = z(u, v) + xu(u, v)yv(u, v) -xv(u, v)yu(u, v)\nS(u, v)\nd(13.28)\nSince we can fix one of the four variables (s, t, u, v), the system of equations (13.26) to\n(13.28) yields three equations with three unknowns.\nWe can replace S(s, t) and S(u, v) by auxiliary variables σ and ω such that σ2 = S2(s, t)\nand ω2 = S2(u, v).\nConsequently the system involving polynomials and square root of polynomials has been\nreduced to a nonlinear polynomial system consisting of five equations with five unknowns\nas follows:\nσω[x(s, t) -x(u, v)] + d[ωNx(s, t) -σNx(u, v)] = 0\n(13.29)\nσω[y(s, t) -y(u, v)] + d[ωNy(s, t) -σNy(u, v)] = 0\n(13.30)\nσω[z(s, t) -z(u, v)] + d[ωNz(s, t) -σNz(u, v)] = 0\n(13.31)\nσ2 -N 2\nx(s, t) -N 2\ny (s, t) -N 2\nz (s, t) = 0\n(13.32)\nω2 -N 2\nx(u, v) -N 2\ny (u, v) -N 2\nz (u, v) = 0\n(13.33)\nwhere\nNx(s, t)\n=\nys(s, t)zt(s, t) -yt(s, t)zs(s, t)\n(13.34)\nNx(u, v)\n=\nyu(u, v)zv(u, v) -yv(u, v)zu(u, v)\n(13.35)\nNy(s, t)\n=\nxt(s, t)zs(s, t) -xs(s, t)zt(s, t)\n(13.36)\nNy(u, v)\n=\nxv(u, v)zu(u, v) -xu(u, v)zv(u, v)\n(13.37)\nNz(s, t)\n=\nxs(s, t)yt(s, t) -xt(s, t)ys(s, t)\n(13.38)\nNz(u, v)\n=\nxu(u, v)yv(u, v) -xv(u, v)yu(u, v).\n(13.39)\nSince s = u, t = v are trivial solutions, we must exclude them from the system, otherwise a\nBernstein subdivision-based algorithm would attempt to solve for an infinite number of roots.\nFor the self-intersections of a normal offset of a planar polynomial curve case we have addressed\nthis problem by dividing out the common factor by some algebraic manipulations [17]. However,\nfor the surface case we can not divide out these factors from the system directly, since terms\nx(s, t)-x(u, v), y(s, t)-y(u, v) and z(s, t)-z(u, v) do not necessarily exactly involve the factors\ns -u and t -v. See [16] for details for how to exclude trivial solutions.\n13.3.3\nTracing algorithm\nFinding the starting points for tracing the self-intersection curve is very similar to the same\nproblem for surface-surface intersection in Section 9.8.2. By considering that the self-intersection\ncurve is a function of another parameter τ, s = s(τ), t = t(τ), u = u(τ), v = v(τ), and by\ndifferentiating the equation for self-intersection curves of an offset with respect to τ yields\nˆrs\nds\ndτ + ˆrt\ndt\ndτ = ˆru\ndu\ndτ + ˆrv\ndv\ndτ\n(13.40)\n\nIf we denote ˆr(s, t) = [ˆx(s, t), ˆy(s, t), ˆz(s, t)] and ˆr(u, v) = [ˆx(u, v), ˆy(u, v), ˆz(u, v)], we can solve\nvector equation (13.40) for\nds\ndτ ,\ndt\ndτ , du\ndτ and dv\ndτ . This is a linear system of 3 equations in 4\nunknowns s, t, u, v. The solution of this underconstrained problem is given by\nds\ndτ\n=\nζ\n\nˆxt\nˆxu\nˆxv\nˆyt\nˆyu\nˆyv\nˆzt\nˆzu\nˆzv\n\n= ζ|A1|\n(13.41)\ndt\ndτ\n=\n-ζ\n\nˆxs\nˆxu\nˆxv\nˆys\nˆyu\nˆyv\nˆzs\nˆzu\nˆzv\n\n= -ζ|A2|\n(13.42)\ndu\ndτ\n=\n-ζ\n\nˆxs\nˆxt\nˆxv\nˆys\nˆyt\nˆyv\nˆzs\nˆzt\nˆzv\n\n= -ζ|A3|\n(13.43)\ndv\ndτ\n=\nζ\n\nˆxs\nˆxt\nˆxu\nˆys\nˆyt\nˆyu\nˆzs\nˆzt\nˆzu\n\n= ζ|A4|.\n(13.44)\nHere ζ is an arbitrary non-zero factor that can be chosen to provide arc-length parametrization\nin the parameter domain as follows:\ndτ =\np\nds2 + dt2 =\nq\nζ2(|A1|2 + |A2|2)dτ\n(13.45)\nhence\nζ = ±\np\n|A1|2 + |A2|2 .\n(13.46)\nThe points of the self-intersection curves are computed successively by integrating the initial\nvalue problem for a system of nonlinear differential equations (13.41) to (13.44) using the\nvariable step size and variable order Adams method [2]. The sign of ζ determines the direction\nin which the solution proceeds. See Figures 13.12 and 13.13 for illustrations.\n13.3.4\nSelf-intersections of offsets of explicit quadratic surfaces\nAlthough offset surfaces are widely used in various engineering applications, their degenerating\nmechanism is not well known in a quantitative manner. We know that any regular surface can\nbe locally approximated in the neighborhood of a point p by the explicit quadratic surface of\nthe form r(x, y) = [x, y, 1\n2(αx2 +βy2)]T to the second order where -α and -β are the principal\ncurvatures at point p. Therefore investigations of the self-intersecting mechanisms of the offsets\nof explicit quadratic surfaces due to differential geometry properties lead to an understanding\nof the self-intersecting mechanisms of offsets of regular parametric surfaces.\n- Locally any surface can be expressed as a graph of a differentiable function [3]. Given\na point p on the parametric surface S, we can set an orthogonal Cartesian coordinate\nsystem xyz such that xy-plane coincides with the tangent plane of S at p and z-axis is\nalong the normal at p. It follows that in the neighborhood of p any parametric surface\nS can be represented in the form r(x, y) = [x, y, h(x, y)]T , where h is a differentiable\nfunction with h(0, 0) = hx(0, 0) = hy(0, 0) = 0.\n\nt (v)\ns (u)\n(a)\nx\ny\nz\n(b)\nx\ny\nz\n(c)\nFigure 13.12: Self-intersection curves of the offset of bicubic patch when d=0.09. Figure (a)\nshows the pre-images of the self-intersection curves in parameter domain. The same symbols\nare mapped to the same points in the offset surface. Figure (b) shows the mapping of the\nself-intersection curves in the parameter domain onto the progenitor surface. Figure (c) shows\nthe offset surface and the self-intersection curves.\n\ns (u)\nt (v)\n(a)\nx\ny\nz\n(b)\nx\ny\nz\n(c)\nFigure 13.13: Self-intersection curves of the offset of bisextic patch when d=-0.08. Figure (a)\nshows the pre-images of the self-intersection curves in parameter domain. The same symbols\nare mapped to the same points in the offset surface. Figure (b) shows the mapping of the\nself-intersection curves in the parameter domain onto the progenitor surface. Figure (c) shows\nthe offset surface and the self-intersection curves.\n\n- We can Taylor expand h(x, y) about (0, 0) as follows\nh(x, y)\n=\nh(0, 0) + [hx(0, 0)x + hy(0, 0)y] + 1\n2![hxx(0, 0)x2 + 2hxy(0, 0)xy + hyy(0, 0)y2]\n+\n3![hxxx(0, 0)x3 + 3hxxy(0, 0)x2y + 3hxyy(0, 0)xy2 + hyyy(0, 0)y3] + R (13.47)\nwhere lim(x,y)→(0,0) R(x2 + y2)-3\n2 = 0.\n- If we take into account that h(0, 0) = hx(0, 0) = hy(0, 0) = 0, we can consider\nh(x, y) = 1\n2[hxx(0, 0)x2 + 2hxy(0, 0)xy + hyy(0, 0)y2]\n(13.48)\nas the second order approximation of h(x, y).\n- Let us denote E, F, G and L, M, N as coefficients of the first and second fundamental\nforms of the surface.\nIf we assume further that x and y axes are directed along the\nprincipal directions at (0, 0, 0), assuming (0, 0, 0) is not an umbilic, then F = M = 0 [3].\nIt follows that hxy(0, 0) = 0, since M = hxy/\nq\n1 + h2x + h2y. Although we have assumed\n(0, 0) is not an umbilic, we can show that hxy(0, 0) will also vanish when the point is an\numbilic [19]. Also the principal curvatures at p can be expressed as follows [3]:\nif hxx(0, 0) > hyy(0, 0); κmin = -L\nE = -hxx(0, 0), κmax = -N\nG = -hyy(0, 0)(13.49)\nif hxx(0, 0) < hyy(0, 0); κmax = -L\nE = -hxx(0, 0), κmin = -N\nG = -hyy(0, 0)(13.50)\n- If we set α = hxx(0, 0) and β = hyy(0, 0) (thus -α = and -β = are principal curvatures)\nand assuming that p is a nonplanar point, the surface can be written locally as a second\norder approximation in the nonparametric form given by\nz = 1\n2(αx2 + βy2)\n(13.51)\nIts corresponding parametric form is\nr(x, y) = [x, y, 1\n2(αx2 + βy2)]T\n(13.52)\nIn the sequel we assume that d > 0, β > 0 and α ≤β without loss of generality. It follows\nthat at (0,0,0) equation (13.50) holds and the x-axis will be the direction of maximum\nprincipal curvature and y-axis will be the direction for the minimum principal curvature.\nIf α and β vanish at the same time, then the surface is part of a plane. Equation (13.51)\nor (13.52) represents explicit quadratic surfaces which can be categorized into four\ntypes according to combinations of α and β as listed in Table 13.1.\n- The four types of explicit quadratic surfaces are depicted in Figure 13.14.\nTheorem [15] Self-intersection curves of offsets of the explicit quadratic surfaces r(x, y) =\n[x, y, 1\n2(αx2 + βy2)]T and their corresponding curves in the xy-plane are as follows:\n\nSigns of α and β\nTypes of Surfaces\nTypes of Points at p\nαβ < 0\nHyperbolic Paraboloid\nHyperbolic Point\nαβ > 0 and α = β\nElliptic Paraboloid\nElliptic Point\nα = β\nParaboloid\nUmbilical Point\nα = 0 or β = 0\nParabolic Cylinder\nParabolic Point\nTable 13.1: Four types of explicit quadratic surfaces according to α and β\nFigure 13.14: Explicit quadratic surfaces z = 1\n2(αx2+βy2). (a) Top left: Hyperbolic paraboloid\n(α = -3, β = 1). (b) Top right: Elliptic paraboloid (α = 1, β = 3). (c) Bottom left: Paraboloid\n(α = β = 3). (d) Bottom right: Parabolic cylinder (α = 0, β = 3).\n\n1. An offset of hyperbolic paraboloid (α < 0 < β) self-intersects only in the y-direction when\nβ < d. The resulting self-intersection curve is a parabola given by\nz =\nαβ\n2(β -α)x2 + (βd)2 + 1\n2β\n,\ny = 0\n(13.53)\n\n-β -α\nαβ\nq\n(βd)2 -1 ≤x ≤β -α\nαβ\nq\n(βd)2 -1\n\nand its corresponding curve in the parameter space (i.e., xy-plane) is an ellipse when\n|α| = β or a circle when |α| = β, (see Figure 13.15 (a)) given by\nx2\n√\n(βd)2-1\nα\n2 +\ny2\n√\n(βd)2-1\nβ\n2 = 1\n(13.54)\n2. An offset of an elliptic paraboloid (0 < α < β) self-intersects only in the y-direction\nwhen 1\nβ < d < 1\nα and self-intersects in both x and y-directions when\nα < d. The self-\nintersection curve which self-intersects in the y-direction is a parabola (see Figure 13.11)\ngiven by equation (13.54) and the corresponding curve in the xy-plane is an ellipse (see\nFigures 13.11, 13.15 (b)) given by equation (13.54). The self-intersection curve which\nself-intersects in the x-direction is also a parabola given by\nz =\nαβ\n2(α -β)y2 + (αd)2 + 1\n2α\n,\nx = 0\n(13.55)\n\n-α -β\nαβ\nq\n(αd)2 -1 ≤x ≤α -β\nαβ\nq\n(αd)2 -1\n\nits corresponding curve in the xy-plane is an ellipse (see Figures 13.15 (c), (d)) given by\nx2\n√\n(αd)2-1\nα\n2 +\ny2\n√\n(αd)2-1\nβ\n2 = 1\n(13.56)\n3. An offset of a paraboloid (0 < α = β) self-intersects in all directions, when 1\nβ = 1\nα < d.\nThe self-intersection curve is a point (0, 0, (βd)2-1\n2β\n), and its corresponding curve in the\nxy-plane is a circle (see Figure 13.15 (e)) given by\nx2 + y2 =\np\n(βd)2 -1\nβ\n!2\n(13.57)\n4. An offset of a parabolic cylinder (α = 0 < β) self-intersects only in the y-direction when\nβ < d. The resulting self-intersection curve is a straight line in the xz-plane\nz = (βd)2 -1\n2β\n, y = 0\n(13.58)\nand its corresponding curves in the xy-plane (see Figure 13.15 (f)) are two straight lines\ngiven by\ny = ±\np\n(βd)2 -1\nβ\n(13.59)\n\n(a)\nx\ny\n-0.67\n-0.33\n0.00\n0.33\n0.67\n-0.50\n-0.17\n0.17\n0.50\n\n(b)\nx\ny\n-0.67\n-0.33\n0.00\n0.33\n0.67\n-0.50\n-0.17\n0.17\n0.50\n\n(c)\nx\ny\n-0.67\n-0.33\n0.00\n0.33\n0.67\n-0.50\n-0.17\n0.17\n0.50\n\n(d)\nx\ny\n-0.67\n-0.33\n0.00\n0.33\n0.67\n-0.50\n-0.17\n0.17\n0.50\n\n(e)\nx\ny\n-0.67\n-0.33\n0.00\n0.33\n0.67\n-0.50\n-0.17\n0.17\n0.50\n\n(f)\nx\ny\n-0.67\n-0.33\n0.00\n0.33\n0.67\n-0.50\n-0.17\n0.17\n0.50\nFigure 13.15: Self-intersection and ridge curves of offsets of explicit quadratic surfaces. The\nsolid lines correspond to self-intersection curves which degenerates in y-direction. The dashed\nlines correspond to κmin(x, y) = -1\nd. The dot dashed lines correspond to self-intersection curves\nwhich degenerates in x-direction. The dot dot dashed lines correspond to κmax(x, y) = -1\nd.\nSymbols × and ∗represent the locations of generic lemon type umbilic and non-generic umbilic.\n(a) hyperbolic paraboloid (α = -2, β = 2, d = 0.6) (b) elliptic paraboloid (α = 1.75, β = 2,\nd = 0.55) (c) elliptic paraboloid (α = 1.75, β = 2, d = 0.6) (d) elliptic paraboloid (α = 1.75,\nβ = 2, d = 0.65) (e) paraboloid (α = β = 2, d = 0.6) (f) parabolic cylinder (α = 0, β = 2,\nd = 0.6)\n\n13.3.5\nApproximations\nParametric Offset Surface Approximation Algorithm [23]. (See Figure 13.16)\n1. Input: NURBS surface patch.\n2. Offset each vertex of polygon by d with unit normal vector given by\nNij = 1\nX\ni=1\nni\n(13.60)\n3. Check deviation of the approximate offset with the true offset (using the same weights\nfor rational functions as the progenitor).\n4. If the deviation is larger than the given tolerance subdivide the surface into four and go\nback to step 1. If the deviation is smaller than the given tolerance stop.\nNij\nn k\nNij = (1/8)Σ n\nk=1\nk\nFigure 13.16: Offset surface approximation.\n\nBibliography\n[1] Y. J. Chen and B. Ravani. Offset surface generation and contouring in computer-aided\ndesign. Journal of Mechanisms, Transmissions, and Automation in Design, Transactions\nof the ASME, 109(3):133-142, March 1987.\n[2] G. Dahlquist and A. Bj orck. Numerical Methods. Prentice-Hall, Inc., Englewood Cliffs,\nNJ, 1974.\n[3] P. M. do Carmo.\nDifferential Geometry of Curves and Surfaces.\nPrentice-Hall, Inc.,\nEnglewood Cliffs, NJ, 1976.\n[4] R. T. Farouki.\nExact offset procedures for simple solids.\nComputer Aided Geometric\nDesign, 2(4):257-279, 1985.\n[5] R. T. Farouki.\nThe approximation of non-degenerate offset surfaces. Computer Aided\nGeometric Design, 3(1):15-43, May 1986.\n[6] R. T. Farouki and C. A. Neff. Algebraic properties of plane offset curves. Computer Aided\nGeometric Design, 7(1 - 4):101-127, 1990.\n[7] R. T. Farouki and C. A. Neff. Analytic properties of plane offset curves. Computer Aided\nGeometric Design, 7(1 - 4):83-99, 1990.\n[8] R. T. Farouki and T. W. Sederberg. Analysis of the offset to a parabola. Computer Aided\nGeometric Design, 12(6):639-645, September 1995.\n[9] I. D. Faux and M. J. Pratt. Computational Geometry for Design and Manufacture. Ellis\nHorwood, Chichester, England, 1981.\n[10] R. Klass. An offset spline approximation for plane cubic splines. Computer-Aided Design,\n15(4):297-299, September 1983.\n[11] R. Kunze, F.-E. Wolter, and T. Rausch. Geodesic Voronoi diagrams on parametric sur-\nfaces.\nIn Proceedings of Computer Graphics International, CGI '97, June 1997, pages\n230-237. IEEE Computer Society Press, 1997.\n[12] T. Lozano-Perez and M. A. Wesley. An algorithm for planning collision-free paths amongst\npolyhedral obstacles. Communications of the ACM, 25(9):560-570, October 1979.\n[13] W. L u.\nRational offsets by reparametrization.\nTechnical report, Zhejiang University,\nDecember 1992.\n\n[14] T. Maekawa. An overview of offset curves and surfaces. Design Laboratory Memorandum\n98-2, MIT, Department of Ocean Engineering, Cambridge, MA, March 1998.\n[15] T. Maekawa. Self-intersections of offsets of quadratic surfaces: Part I, explicit surfaces.\nEngineering with Computers, 14:1-13, 1998.\n[16] T. Maekawa, W. Cho, and N. M. Patrikalakis. Computation of self-intersections of offsets\nof B ezier surface patches.\nJournal of Mechanical Design, Transactions of the ASME,\n119(2):275-283, June 1997.\n[17] T. Maekawa and N. M. Patrikalakis. Computation of singularities and intersections of\noffsets of planar curves. Computer Aided Geometric Design, 10(5):407-429, October 1993.\n[18] T. Maekawa, N. M. Patrikalakis, T. Sakkalis, and G. Yu. Analysis and applications of pipe\nsurfaces. Computer Aided Geometric Design, 15(5):437-458, May 1998.\n[19] T. Maekawa, F.-E. Wolter, and N. M. Patrikalakis. Umbilics and lines of curvature for\nshape interrogation. Computer Aided Geometric Design, 13(2):133-161, March 1996.\n[20] N. M. Patrikalakis and L. Bardis. Offsets of curves on rational B-spline surfaces. Engi-\nneering with Computers, 5:39-46, 1989.\n[21] N. M. Patrikalakis and L. Bardis. Localization of rational B-spline surfaces. Engineering\nwith Computers, 7(4):237-252, 1991.\n[22] N. M. Patrikalakis and H. N. Gursoy. Shape interrogation by medial axis transform. In\nB. Ravani, editor, Proceedings of the 16th ASME Design Automation Conference: Ad-\nvances in Design Automation, Computer Aided and Computational Design, Vol. I, pages\n77-88, Chicago, IL, September 1990. New York: ASME.\n[23] N. M. Patrikalakis and P. V. Prakash. Free-form plate modeling using offset surfaces.\nJournal of OMAE, Transactions of the ASME., 110(3):287-294, 1988.\n[24] B. Pham. Offset curves and surfaces: a brief survey. Computer-Aided Design, 24(4):223-\n229, April 1992.\n[25] T. Rausch, F.-E. Wolter, and O. Sniehotta. Computation of medial curves on surfaces.\nIn T. Goodman and R. Martin, editors, The Mathematics of Surfaces VII, pages 43-68.\nInformation Geometers, 1997.\n[26] J. R. Rossignac and A. G. Requicha. Offsetting operations in solid modelling. Computer\nAided Geometric Design, 3(2):129-148, 1986.\n[27] W. Tiller and E. G. Hanson. Offsets of two-dimensional profiles. IEEE Computer Graphics\nand Applications, 4(9):36-46, September 1984.\n[28] T. J. Willmore. An Introduction to Differential Geometry. Clarendon Press, Oxford, 1959.\n[29] F.-E. Wolter. Cut locus and medial axis in global shape interrogation and representation.\nMemorandum 92-2, Cambridge MA: MIT Ocean Engineering Design Laboratory, January\n1992."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes14_fixed.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/f04f923ac8e0af56d19095b4de8dea3c_lecnotes14_fixed.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLectures 14 and 15\nProf. N. M. Patrikalakis\nMassachusetts Institute of Technology\nCambridge, MA 02139-4307, USA\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\nConstructive Solid Geometry (CSG)\n14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.2 Primitives of CSG\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.3 Boolean operators\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.3.1 Regularized Boolean operators\n. . . . . . . . . . . . . . . . . . . . . . .\n14.4 Set membership classification . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.5 Properties of CSG\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBoundary Representation\n14.6 Two-manifold B-rep\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.6.1 Information contained in a B-rep . . . . . . . . . . . . . . . . . . . . . .\n14.6.2 Characteristics of domain for two-manifold solid object representations .\n14.6.3 Euler-Poincar e equation . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.6.4 Sufficiency of a geometric modeling representation\n. . . . . . . . . . . .\n14.6.5 Boundary representation model . . . . . . . . . . . . . . . . . . . . . . .\n14.7 Data structures for manifold representations . . . . . . . . . . . . . . . . . . . .\n14.7.1 Winged-edge data structure . . . . . . . . . . . . . . . . . . . . . . . . .\n14.7.2 Vertex-edge data structure (V-E) . . . . . . . . . . . . . . . . . . . . . .\n14.7.3 Face-edge data structure (FE)\n. . . . . . . . . . . . . . . . . . . . . . .\n14.8 Operators for manipulating manifold topologies . . . . . . . . . . . . . . . . . .\n14.8.1 Basic operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.8.2 Building high level functions on the Euler operators\n. . . . . . . . . . .\n14.9 Non Two-Manifold B-rep\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.9.1 Topological elements in NTM topologies . . . . . . . . . . . . . . . . . .\n14.9.2 Topological sufficiency . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14.10Radial edge data structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\n\nConstructive Solid Geometry (CSG)\n14.1\nIntroduction\nCSG is a method in which an object is constructed from the standard primitives using regu-\nlarized Boolean operations. The model is represented in the data structure as a CSG tree, see\nFigure 14.1, whose terminal nodes are primitives and non-terminal nodes are Boolean operators\n( intersection, union and difference). Primitives are sized, positioned and oriented first.\ndiff.\nun.\ncy.\nbl1\nbl2\nFigure 14.1: An example of CSG tree\n14.2\nPrimitives of CSG\nTypical primitives are the rectangular box, the circular cylinder of finite height, the sphere, the\ncone of finite height and the torus. Figure 14.2 shows two collections of CSG primitives. These\nprimitives may be defined as intersections of halfspaces (defined by algebraic inequalities of the\nform f(x, y, z) ≥0).\n\n(a)\n(b)\nFigure 14.2: Two collections of CSG primitives.\n14.3\nBoolean operators\nDefinition: A set S is regular if S = (int(S))cl, where int means the interior, and cl means\nclosure. Taking the interior of S means constructing a subset of S where all points in the subset\nhave an ε-neighborhood homeomorphic to a ball. Closure means adding the limit points (or\nboundary) to the interior points to produce a new set.\nLet A, B denote regular sets in R3, then\nb(A ∪B)\n=\n(bA ∩cB) ∪(bB ∩cA)\nb(A ∩B)\n=\n(bA ∩iB) ∪(bB ∩iA)\n(14.1)\nb(A -B)\n=\n(bA ∩cB) ∪(bB ∩iA)\nwhere bX is the boundary of the set X, iX is its interior and cX is its complement.\nSee\nFigure 14.3. Obviously, Boolean operators require the execution of surface intersections, and\npostprocessing to evaluate the correct boundary of the resulting set using (14.1).\nA\nB\nA\nB\nb (A B )\nA\nB\nb (A B )\nA\nB\nb (A B )\n-\nFigure 14.3: Boolean operators\n\n14.3.1\nRegularized Boolean operators\nManifold objects are not closed under Boolean operations. Regularized set operations make it\nso, see Figure 14.4 for example.\n\nA\nB\nA\nB\nset-theoretic\nintersection\nregularized\nintersection\nFigure 14.4: Regularized set operations.\nLet ∩∗be a regularized set operation, and C∗= A ∩∗B, then to compute C∗, we proceed\nconceptually as follows:\n1. C = A ∩B\n2. Ci = interior C\n3. C∗= closure Ci\nFigure 14.5 shows the procedure with an example.\nStep1\nStep2\nStep3\nA B\nA B\ninterior\n(A B)\nclosure\n(A B)\nFigure 14.5: Procedure for regularized intersection.\n\n14.4\nSet membership classification\nGiven a CSG model M and an object X in the scene, the function Classify(M, X) will indicate\nif (see Figure 14.6):\n- X is in M, or\n- X is on M, or\n- X is out of M.\nM\nX1\nX2\nX3\nX1 out of M\nX2 in M\nX3 on M\nFigure 14.6: Membership classification.\nDivide-and-conquer paradigm\nCLASSIFY(M,X)\nif\nM is a primitive\nthen PRIM-CLASSIFY(M,X)\nelse COMBINE(CLASSIFY(left-subtree(M),X),\nCLASSIFY(right-subtree(M),X), operation of M)\nFor the example shown in Figure 14.7,\nCLASSIFY(M,X)\n=\nCOMBINE(PRIM-CLASSIFY(A,X), PRIM-CLASSIFY(B,X),\nintersection)\n=\nCOMBINE(X-in-A, X-in-B, intersection)\n=\nX-in-M\nSimilarly, classifying a line with respect a CSG model M = A T B typically involves inter-\nsections of the line with A and B, and then checking to see if the intersections which are line\nsegments have a common segment, see Figure 14.8.\n\nM = A B\nA\nB\nA\nB\nX\nX\nX\nFigure 14.7: Example of membership classification for point\n\nA\nB\nFigure 14.8: Example of membership classification for line\n\n14.5\nProperties of CSG\nHere are the basic properties of CSG models\n- Advantages:\n- validity: CSG model is always valid;\n- conciseness: CSG tree is in principle concise;\n- computational ease: primitives are easy to handle;\n- unambiguity: every CSG tree unambiguously models a rigid solid (maybe more than\none).\n- Disadvantages:\n- non-uniqueness: a solid could have more than one CSG representation,\n- limit on primitives: free-form surfaces are excluded, and primitives are typically\nbounded by a number of simple low order algebraic surfaces.\n- redundancy of CSG tree: it may have redundant primitives that do not contribute\nto final solid.\n- no explicit boundary information: CSG tree needs to be evaluated (eg. rendered\nto evaluate surface, such as ray trace it, etc.)\n\nBoundary Representation\n14.6\nTwo-manifold B-rep\n- Definition:\nBoundary models describe solids in terms of their bounding entities, such as faces, loops,\nedges and vertices.\n- Examples:\npolygon =⇒bounding edges\nsolid volume =⇒bounding faces\n- The bounding relations shown in Figure 14.9 are:\ncube\n=⇒\n6 faces (squares)\nsquare\n=⇒\n4 edges (line segment)\nline segment\n=⇒\n2 vertices (points in 3-D space)\n\nFigure 14.9: Boundary of a cube.\nA two-manifold B-rep is an explicit representation of a single object (volume) by its bound-\nary which is assumed to be:\n- Compact (closed and bounded),\n- Orientable, and\n- Two-manifold.\nDefinitions\n\n1. A surface is closed if it is bounded and has no boundary (eg. a plane is unbounded, a\npatch is bounded but has boundary and a sphere is closed as its surface is bounded and\nhas no boundary).\n2. A surface is orientable if it is two sided (not like M obius strip\nand Klein bottle\n3. A two-manifold surface is topologically two dimensional connected surface where each\npoint on the surface has a neighborhood which is topologically equivalent to an open\ndisk.\n- Orientable and closed surfaces are required to distinguish inside and outside.\n- Counter examples of two-manifold surfaces are shown in Figure 14.11.\n4. Topological equivalence (Homeomorphism): A homeomorphism is a one-to-one topologi-\ncal transformation which is continuous and has a continuous inverse (intuitively, elastic\ndeformations which preserve adjacency properties). Or, more strictly, if there is a one-\nto-one correspondence between the points of a surface and those of another surface, so\nthat the topological properties of any figure in one of the surfaces are shared by its im-\nage in the other, the two surfaces are said to be homeomorphic to each other, and the\nmapping from one surface to the other established by the one-to-one correspondence is a\nhomeomorphism.\n5. Open disk, portion of a 2-D space (surface) which is within a circle of positive radius,\nexcluding circle. See Figure 14.12.\n).\n\nFigure 14.11: Non two-manifold surfaces.\n\nDisk\nFigure 14.12: Neighborhood of point on two-manifold object is a disk.\n14.6.1\nInformation contained in a B-rep\nThere are two different kinds of information necessary in a B-rep, geometrical information\nand topological information, see Figure 14.13. Geometrical information provides a complete\nspecification of the object and topological information is an abstraction, which provides a\n\"fuzzy\" definition of the object correct within \"genus\" specification (number of through holes)\nand subdivision into faces together with their adjacency.\nA geometrical entity S1 is incident to another geometrical entity S2, if S1 has dimension-\nality one higher than S2, and S2 is a bounding entity of S1. Two geometrical entities S1 and\nS2 are adjacent, if they have the same dimensionality and share a common bounding entity.\nGeometrical information\nComplete geometry can be considered to represent all information about the geometric shape\nof an object including where it lies in space and the precise location of all aspects of its various\nelements:\n- points,\n- curves: eg. line segments, circular arcs, B-spline, and B ezier curves, NURBS curves and\n- surfaces: e.g. bounded planes, quadrics, B-spline and B ezier surfaces, NURBS patches,\ni.e. geometry deals with the relationships between surfaces, curves, points and the coordinate\nspace.\n\nTopology\nGeometry\ncomplete information\nNo Information\n\"fuzzy\" definition of an object without geometry\nFigure 14.13: B-rep model idealization\nTopological information\nTopology is an abstraction, and it contains the incidence information of various elements. It is\nincomplete information which can \"ideally\" be derived from the complete geometric specifica-\ntion. Topology deals with the adjacency relationships between corresponding entities, namely\nphysical proximity or order of a group of topological elements of one type (such as vertices,\nedges or faces) around some other specific single topological elements. Adjacency relationships\nare illustrated in Figure 14.14.\nThe typical topological elements are:\n- Vertex: A unique point in space. A vertex lies in one or more faces.\n- Edge: A finite, non-self-intersecting curve bounded by two not necessarily distinct ver-\ntices. An edge lies on the boundaries of exactly two faces of a two-manifold object.\n- Loop: An ordered alternating sequence of vertices and edges defining a unique point or\ndirected non-self-intersecting, closed space curve.\n- Face: A finite connected non-self-intersecting oriented piece of a surface bounded by one\nor more loops. A loop lies in a single face and forms a bound of the face. The number of\nfaces is equal to the number of peripheral loops.\n- Shell: The collection of consistently oriented faces forming the boundary of a single,\nconnected, closed volume (region).\n- Region: Unique, identifiable volume in space. There is one region with infinite extent,\nall others are finite.\n- Model: 3-D modeling space, consisting of one or more regions.\nIn a two-manifold representation there is a one-to-one correspondence between a region and\nits bounding shell. Therefore it is sufficient to have just one of them represented explicitly. In\ngeneral regions are not represented explicitly in most existing B-rep data structures.\n\nv\nv(E)\nv\nv(F)\ne\ne(V)\ne\ne(F)\nf\nf(E)\nf(F)\n\nf\nv\nV(V)\ne(E)\ne\n\nf\nf(V)\nFigure 14.14: Adjacency relationships.\n14.6.2\nCharacteristics of domain for two-manifold solid object representa-\ntions\n- Surfaces: compact, orientable, two-manifold embedded in the 3-D Euclidean space.\n- Faces: no self-intersection is permitted but they are allowed to intersect with each other\nat edges or vertices.\nRemarks:\n- Adjacency topology explicitly carries all surface intersection information through adja-\ncency information.\n- No non two-manifold situations are allowed. Therefore, in a traversal of edges bounding\nfaces, every edge is traversed exactly twice.\n- Orientability guarantees that the interior of a solid volume is distinguishable from its\nexterior (See Figure 14.15).\nThe orientability guarantees that the interior of a solid\nvolume is distinguishable from its exterior.\n14.6.3\nEuler-Poincar e equation\nThis equation is a relationship between topological elements for a single two-manifold shell:\nV -E + F -Li = 2(1 -G)\n(14.2)\n\norientable surface\nFigure 14.15: Orientable surface.\nwhere,\nV : Number of vertices.\nE: Number of edges.\nF: Number of faces.\nLi: Number of interior loops.\nG: Genus, the number of closed paths on a surface which do not separate the surface into\nmore than one region. Or, genus is the number of handles to be added to a sphere to make it\nhomeomorphic to the object.\ngenus = 1\ngenus = 0\nFigure 14.16: Torus and sphere.\nAnother form of the Euler equation is\nV -E + 2F -L = 2(1 -G)\n(14.3)\n( using the relations L = Lp + Li and Lp = F, Lp: number of peripheral loops )\nFor multiple shelled objects (objects with cavities), the Euler equation becomes\nV -E + F -Li = 2(S -G)\n(14.4)\nS: number of shells.\nEuler equation is a necessary but not sufficient condition for validity of a B-rep.\n\nConditions for topological validity\n1. V, E, F, Li, S, G ≥0,\n2. If V = E = F = Li = 0 =⇒S = 0, G = 0,\n3. If S ≥0 =⇒V ≥S and F ≥S, and\n4. For a shell to exist, there must be at least one vertex and one face on the shell.\nExamples\n- Example 1: A tetrahedron (see Figure 14.17)\nFigure 14.17: Tetrahedron.\nV = 4, E = 6, F = 4, Li = G = 0\n4 -6 + 4 -0 = 2 = 2(1 -0)\n- Example 2: A cube with or without a hole (see Figure 14.18)\n(a)\n(b)\nFigure 14.18: (a) Cube;\n(b) Cube with a hole.\n(a) Without hole V = 8, E = 12, F = 6, Li = G = 0\n8 -12 + 6 -0 = 2\n(b) With a hole V = 10, E = 15, F = 7, Li = 2, G = 1\n10 -15 + 7 -2 = 2(1 -1) = 0\n\nFigure 14.19: Cube with a loop\n- Example 3: A cube with a loop, (see Figure 14.19)\n- Original case\nV = 12, E = 16, F = 7, Li = 1, S = 1, G = 0\n12 -16 + 7 -1 = 2 = 2(1 -0)\n- Connecting the interior loop with one corner vertex of the cube\nV = 12, E = 16 + 1 = 17, F = 7, Li = 1 -1 = 0, S = 1, G = 0\n12 -17 + 7 = 2 = 2(1 -0)\n- Example 4: A sphere with a handle, (see Figure 14.20)\nFigure 14.20: Sphere with a handle.\n- Original case\nV = 2, E = 2, F = 2, Li = 2, S = 1, G = 1\n2 -2 + 2 -2 = 0 = 2(1 -1)\n- Add one more edge on the handle (namely connect the two loops)\nV = 2, E = 3, F = 2, Li = 1, S = 1, G = 1\n2 -3 + 2 -1 = 0 = 2(1 -1)\n\n14.6.4\nSufficiency of a geometric modeling representation\nSufficiency of a geometric modeling representation is the ability to completely and unambigu-\nously represent all adjacency topological relationships of elements.\nTheoretical sufficiency is the absolute minimum information required to reproduce un-\nambiguously a complete adjacency topology.\nIn general, adjacency relationship informations V(E) (cyclicly ordered edges around ver-\ntices) and F(E) (cyclicly ordered edges around faces) are individually sufficient to represent all\nadjacency relationships.\nSome combinations of single insufficient adjacency relationships are sufficient under certain\nconditions.\n14.6.5\nBoundary representation model\nV1\nV2\nV3\nV4\ne1\ne2\ne3\ne5\ne6\ne4\nf4\nf3\nf1\nf2\nV4\nV1\nV2\nV3\ne1\ne3\ne2\nf2\nf3\nf4\ne4\ne5\ne6\nTop View\nFigure 14.21: Boundary representation model.\nFigure 14.21 shows an example of a tetrahedron. The boundary representation model for\nthis example is shown in Figure 14.22. See also Table 14.1.\n14.7\nData structures for manifold representations\nThree different edge-based data structures for representing manifold topologies useful in solid\nmodeling are:\n1. the winged-edge data structure\n2. the vertex-edge data structure\n3. the face-edge data structure\nThe winged edge data structure keeps the edge information as a single unit while the face-edge\nand vertex-edge structures split the information related to each edge into two parts based on\nthe specific usage of the edge in the adjacency relationships.\n\nObject definition (region)\nBoundary definition\nFaces:\nf1\nf2\nf3\nf4\nLoops:\nEdges:\nVertices:\nTopological Information\nVertex assignment\n(Geometry)\nL1\nL2\nL3\nL4\ne1\ne2\ne3\ne4\ne5\ne6\nV1\nV2\nV3\nV4\n(x1,y1,z1)\n(x2,y2,z2)\n(x3,y3,z3)\n(x4,y4,z4)\nFigure 14.22: Boundary representation model for a tetrahedron\n\nV(V)\nV(E)\nV(F)\nV1(V ) = (V2 V3 V4)\nV1(E) = (e1 e3 e2)\nV1(F) = (f2 f3 f4)\nV2(V ) = (V3 V1 V4)\nV2(E) = (e5 e3 e4)\nV2(F) = (f1 f3 f2)\nV3(V ) = (V1 V2 V4)\nV3(E) = (e6 e2 e5)\nV3(F) = (f1 f4 f3)\nV4(V ) = (V2 V1 V3)\nV4(E) = (e4 e1 e6)\nV4(F) = (f1 f2 f4)\nE(V)\nE(E)\nE(F)\ne1(V ) = (V1 V4)\ne1(E) = [(e3 e2)(e6 e4)]\ne1(F) = (f2 f4)\ne2(V ) = (V1 V3)\ne2(E) = [(e1 e3)(e5 e6)]\ne2(F) = (f3 f4)\ne3(V ) = (V1 V2)\ne3(E) = [(e2 e1)(e4 e5)]\ne3(F) = (f2 f3)\ne4(V ) = (V2 V4)\ne4(E) = [(e5 e3)(e1 e6)]\ne4(F) = (f1 f2)\ne5(V ) = (V2 V3)\ne5(E) = [(e3 e4)(e6 e2)]\ne5(F) = (f1 f3)\ne6(V ) = (V3 V4)\ne6(E) = [(e2 e5)(e4 e1)]\ne6(F) = (f1 f4)\nF(v)\nF(E)\nF(F)\nf1(V ) = (V2 V4 V3)\nf1(E) = (e4 e6 e5)\nf1(F) = (f3 f2 f4)\nf2(V ) = (V4 V2 V1)\nf2(E) = (e4 e3 e1)\nf2(F) = (f1 f3 f4)\nf3(V ) = (V1 V2 V3)\nf3(E) = (e3 e5 e2)\nf3(F) = (f2 f1 f4)\nf4(V ) = (V1 V3 V4)\nf4(E) = (e2 e6 e1)\nf4(F) = (f2 f3 f1)\nTable 14.1: Adjacency relationships for boundary representation of tetrahedron.\nev ptr [1]\nev ptr [2]\nee cw ptr [1]\nee cw ptr [2]\nee ccw ptr [1]\nee ccw ptr [2]\nef ptr [1]\nef ptr [2]\ne ptr (edge attribute)\nTable 14.2: Winged-edge data structure.\n14.7.1\nWinged-edge data structure\n(1) Data structure\nTopological information stored for each edge is composed of the adjacencies of that edge\nwith four other edges, two faces, and two vertices, see Figure 14.23.\n(2) Application of winged-edge data structure, see Figure 14.24 and Table 14.3.\nQuestion: adjacency relationship f4(E)?\nStart with edge \"e1\" and traverse data structure\ne1(CCW[2]) -→e6, check f4 = f[2] and\ne6(CCW[2]) -→e2, check f4 = f[2] and\ne2(CCW[2]) -→e1\n(3) Supporting data structure (see Figure 14.25)\n- \"Shell\"\nshell attribute ptr\nface ptr (doubly linked list of faces)\n\nee_cw_ptr [1]\nee_ccw_ptr [2]\nev_ptr [2]\nf2\nf1\nev_ptr [1]\nee_ccw_ptr [1]\nee_cw_ptr [2]\nef_ptr [2]\nef_ptr [1]\nFigure 14.23: Winged-edge data structure.\nV1\nV2\nV3\nV4\ne1\ne2\ne3\ne5\ne6\ne4\nf4\nf3\nf1\nf2\nf [1]\nf [2]\nV[2]\nV[1]\nCW[1]\nCCW[2]\nCCW[1]\nCW[2]\nFigure 14.24: Application of winged-edge data structure.\n\nedge\nV [1]\nV [2]\nf[1]\nf[2]\nCW[1]\nCCW[1]\nCW[2]\nCCW[2]\ne1\nV1\nV4\nf2\nf4\ne4\ne3\ne2\ne6\ne2\nV3\nV1\nf3\nf4\ne3\ne5\ne6\ne1\ne3\nV1\nV2\nf3\nf2\ne5\ne2\ne1\ne4\ne4\nV2\nV4\nf1\nf2\ne6\ne5\ne3\ne1\ne5\nV2\nV3\nf3\nf1\ne2\ne3\ne4\ne6\ne6\nV4\nV3\nf1\nf4\ne5\ne4\ne1\ne2\nTable 14.3: Application of winged-edge data structure.\nShell\nface list\nf1\nf2\n...\nfn\nφ\n...\nφ\nedge list\nedge\n...\n...\nem\nφ\nφ\nWinged-edge data structure\nFigure 14.25: Supporting data structure.\n- \"face\"\nnext face ptr\nprevious face ptr\nedge ptr or vertex ptr\n- vertex\nvertex attribute (geometry)\n14.7.2\nVertex-edge data structure (V-E)\nV-E data structure represents the adjacency information of the edge by splitting it into two\nstructures, each of which is related to one of the two edge end vertices, see Figure 14.26 and\nTable 14.4. Each edge is used exactly twice in opposite directions by two adjacent faces. This\nresults in the concept of \"edge-use\"\nev ptr\nee cw ptr\nee ccw ptr\nef ptr\nee mate ptr (other end of edge)\ne ptr (edge attribute)\nTable 14.4: Vertex-edge data structure.\n\nee_ccw_ptr\nee_cw_ptr\nedge use\nface\nef_ptr\nev_ptr\nf1\nf2\ntwo edge uses\n(\"mates\")\nother part\nFigure 14.26: Vertex-edge data structure.\nev ptr\nee cwe ptr\nee ccwe ptr\nef ptr\nee mate ptr (other half of the edge)\ne ptr (edge attribute)\nTable 14.5: Face-edge data structure.\n14.7.3\nFace-edge data structure (FE)\nThe F-E structure represents the adjacency information of the edge by splitting it into two\nstructures, each of which is related to one of the two edge sides as found around the periphery\nof faces, see Figure 14.27 and Table 14.5. This results in the concept of \"edge-use\" .\n14.8\nOperators for manipulating manifold topologies\nThe Euler operators are a set of operators which can manipulate manifold boundary based\ntopology representations in a low level, incremental and systematic fashion, constructing a\ntopology primarily edge by edge. They can be used with any of the previously described edge\nbased data structures.\nThey are, relatively speaking, low level operators since they act on topological primitive\nelements (vertices, edges and faces). We can also see them as high level operators because they\nallow us to construct a manifold adjacency topology without getting into the details of the\nunderlying data structures. Indeed while implementation of the Euler operators is specific to\nthe data structure actually used, the external interface to the operators can remain the same,\nand the implementation of all higher level operations can be identical regardless of the data\nstructure chosen, see Figure 14.28.\n\nee_cwe_ptr\nedge use\nef_ptr\nev_ptr\ntwo edge uses\n(\"mates\")\nV\nee_ccwe_ptr\nface\nother part\nFigure 14.27: Face-edge data structure.\nFive basic Euler operators presented below are sufficient to create any topology but others\nare also defined to add convenience and flexibility to the surface construction process.\n- MSFLV: make-shell-face-loop-vertex\n- MEV : make-edge-vertex\n- ME : make-edge\n- GLUE : glue faces (merge two simple loop faces together)\n- KE : kill-edge\nExamples of Euler operators are shown in Figure 14.29 and Figure 14.30. Figure 14.31 shows\nan application of Euler operators in the construction of a box. At every step, V -E +F -Li =\n2(S -G), or in this case V -E + F = 2\nUser Level\nApplications\nEuler Operators\nQueries\nData Structure\nFigure 14.28: Abstraction levels using Euler operators.\n\nMSFLV\nNew Vertex\nMEV\ne\nV\ne\nV\nnew V\nnew e\nME\ne1\ne2\nV1\nV2\ne1\ne2\nV1\nV2\nnew e\nmefl\nmekl\nV1\nV2\nV1\nV2\nnew e\nmeksfl\nS1\nV1\nV2\nS2\nS1\nV1\nV2\nnew e\ndir\ndir1\ndir2\nFigure 14.29: Euler operators (I)\n\nGLUE\nkflevmg: kill-face-loop-edge-vertex-make-genus\nkflevs\nV1\nV2\nV1\nV2\nkefl\nkeml\nV1\nV2\nkemsfl\nS1\nV1\nV2\nS1\nV1\nV2\ne1\ne2\ne1\ne1\nf1\nf2\ne2\ne1\nf\nKE\ne\ne\ns2\nKSFLEV: delete an object from model\nFigure 14.30: Euler operators (II)\n\n(a) msflv\n[V=1, E=0, F=1]\n(b) mev\n[V=2, E=1, F=1]\n(c) mev, mev\n[V=4, E=3, F=1]\n(d) mef\n[V=4, E=4, F=2}\n(e) mev\nmev\nmev\nmev\n[V=8, E=8, F=2]\n(f) mef\nmef\nmef\nmef\n[V=8, E=12, F=6]\nFigure 14.31: Making a box using Euler operators\n14.8.1\nBasic operators\n- Constructive\n- MSFLV\n- MEV\n- ME\n∗mefl\n∗mekl\n∗meksfl\n- GLUE\n∗kflevmg\n∗kflevs\n- Destructive\n- KSFLEV\n- KEV\n- KE\n∗kefl\n∗keml\n\n∗kemsfl\n- UNGLUE\n∗mflevkg\n∗mflevs\nA brief description of these operators follows:\n1. MSFLV (new-face, new-loop, new-vertex)\n\"Make shell, face, loop, vertex\" creates a new manifold surface in the topology and it is\nthe first operator used in any topology construction. MSFLV creates a new shell, the face\n\"new-face\", the loop \"new-loop\", and the vertex \"new-vertex\". The single vertex created,\n\"new-vertex\" can be used as a starting point for subsequent construction of additional\ntopological features on the manifold surface.\n2. MEV (vertex, edge, direction, new-edge, new-vertex)\n\"Make edge, vertex\" creates a new edge and vertex. The new edge, \"new-edge\", starts\nat the existing vertex \"vertex\", and ends at the new vertex \"new-vertex\". If the optional\nplacement arguments \"edge\" and \"direction\" are specified, \"new-edge\" will be positioned\nin direction \"direction\" from \"edge\" about \"vertex\" as seen when looking towards the\nmanifold surface from outside above \"vertex\".\n3. ME (ver1, edge1, dir1, ver2, edge2, dir2, new-edge, new-face, new-loop)\n\"Make edge\" creates an edge between existing vertices ver1 and ver2. If optional place-\nment is specified, the new edge, \"new-edge\", will be direction \"dir1\" from \"edge1\" about\nvertex \"ver1\" and direction \"dir2\" from \"edge2\" about vertex \"ver2\".\n- mefl: \"make edge, face, loop\" occurs when the new edge will close offone portion of\nthe face it is on from the rest of the face. In this case, the new face \"new-face\" and\nloop \"new-loop\" will lie to the \"dir1\" side of \"new-edge\" about \"ver1\".\n- mekl: \"make edge, kill loop\" occurs when the new edge will not close offone portion\nof the face it is on from the rest of the face. In this case, the vertices \"ver1\" and\n\"ver2\" were on different loops of the same face, but afterwards will be located on\nthe same loop. The surviving loop is the loop associated with \"ver1\".\n- meksfl: \"make edge, kill shell, face, loop\" occurs when the two specified vertices are\non different shells. The new edge links together the two shells into a single shell.\nThe shell of \"ver1\" is the surviving shell.\n4. GLUE (face1, edge1, face2, edge2)\n\"Glue faces\" merges two single loop faces (simply connected faces) together, deleting both\nfaces and vertices, with the effect of joining together the volumes which the two faces are\nbounding. Both loops must have the same number of edges and vertices, and must have\nno edges in common. The merge is performed so that edge1 of face1 and edge2 of face2\nare merged into the same edge. The surviving set of edges and vertices are those of face1.\n- kflevmg: \"Kill face, loop, edge, vertex, make genus\" occurs when both faces exist\non the same shell. The glue operation increases the genus of the shell by one.\n\n- kflevs: \"kill face, loop, edge, vertex, shell\" occurs when the two faces exist on\ndifferent shells. The glue operation merges the two shells together into a single shell,\nwith the shell of face1 being the survivor.\n5. KE (edge, vertex, new-loop)\n\"Kill edge\", deletes the specified edge \"edge\".\n- kefl: \"kill edge, face, loop\" occurs when the edge to be deleted separates two different\nfaces. In this case, the edges of the two loops using the deleted edge are merged\nand one face and loop are deleted. The surviving face and loop are those found to\nthe right of the edge to be deleted, when transversing the edge from the optionally\nspecified vertex \"vertex\" to the other vertex. Any other loops of the deleted face\nare moved to the surviving face.\n- keml: \"kill edge, make loop\" occurs when the edge to be deleted occurs twice on a\nloop of a single face. In this case a new loop, \"new loop\" will be generated on the\nsame face.\n- kemsfl(edge, vertex, new-face, new-loop): \"kill edge, make shell, face, and loop\"\ndeletes the specified edge, \"edge\", which is required to have the same face on both\nsides. The two disconnected graph components that result are treated as separate\nshells.\n- ksflev (vertex): \"kill shell, face, loop, edge, vertex\" determines the shell of the\nspecified vertex and deletes the shell and all its topological elements.\n- kev (edge, vertex, vsurvivor): \"kill edge, vertex\" squeezes the ends of the speci-\nfied edge \"edge\" together, deleting the edge and a vertex \"vertex\" while preserving\nadjacencies. The topological parameter \" vertex\", if specified, designates which ver-\ntex of the edge will survive. In any case, the surviving vertex is indicated by the\n\"vsurvivor\" return parameter.\n6. UNGLUE (edge, face, newf1, newf2, loop, newl1, newl2)\n\"Unglue faces\" takes a single loop of edges starting with edge \"edge\", separates the\nmodel along the loop.\nThe process creates two new faces \"newf1\" and \"newf2\" and\ntheir respective loops \"newl1\" and \"newl2\". The loop marked for the UNGLUE must be\ncomplete and must not cross itself.\n- mflevkg: \"make face, loop, edge, vertex, kill genus\" occurs when the separation\ninduced by the operation leaves the object still connected. In this case the specified\nloop lies on a handle of the shell which has a genus of one or more. The handle is\nremoved and the single shell with genus reduced by one in the result.\n- mflevs: \"make face, loop, edge, vertex, shell\" occurs when the separation induced by\nthe operation creates disconnected shells. Each component of the result is treated\nas a separate shell. Thus two separate volumes are created.\nThe effects of the basic Euler operators on topological elements are summarized in Ta-\nble 14.6.\n\nOperator\nChange in number of topological elements\nShells\nFaces\nLoops\nEdges\nVertices\nGenus\nMSFLV\n+1\n+1\n+1\n+1\nMEV\n+1\n+1\nME\nmefl\n+1\n+1\n+1\nmekl\n-1\n+1\nmeksfl\n-1\n-1\n-1\n+1\nGLUE\nkflevmg\n-2\n-2\n-ne\n-nv\n+1\nkflevs\n-1\n-2\n-2\n-ne\n-nv\nKSFLEV\n-1\n-nf\n-nl\n-ne\n-nv\n-ng\nKEV\n-1\n-1\nKE\nkefl\n-1\n-1\n-1\nkekl\n+1\n-1\nkemsfl\n+1\n+1\n+1\n-1\nUNGLUE\nmflevkg\n+2\n+2\n+ne\n+nv\n-1\nmflevs\n+1\n+2\n+2\n+ne\n+nv\nTable 14.6: Effects of basic Euler operators on topological elements\n14.8.2\nBuilding high level functions on the Euler operators\nEuler operators provide a flexible basis for higher level operators while insulating those new\noperators from the details and complexities of the actual data structures used. They are flexible,\nbecause they are fairly low level operators which systematically manipulate the model on an\nedge by edge basis. They also provide automatic topological integrity checking. Almost any\nother kind of commonly found modeling operator or procedure can be built on top of the Euler\noperators, including parametric primitives and sweeps.\n14.9\nNon Two-Manifold B-rep\nNon two-manifold (NTM) representations are geometric modeling representations which allow\nvolume, both manifold and non-manifold surface, curve and point elements in a single uniform\nenvironment. This allows topological surfaces which are not constrained to be homeomorphic\nto a two-dimensional topological disk at every point, such as the objects in Figure 14.32.\nA NTM representation therefore allows a general wire mesh with surfaces and volumes\nembedded in space and can be a superset of wireframe, surface and traditional manifold solid\nmodeling forms.\nThis section will discuss a representation of NTM topologies and introduce the Radial Edge\nData Structure, a data structure developed for NTM topologies.\n\n(a) FE meshing\n(b) Design\n(c) Mixed-dimension\nmodel\nFigure 14.32: Examples of non-two manifold models.\n14.9.1\nTopological elements in NTM topologies\nAt least seven distinct element types, including six basic topological element types are involved\nin a NTM topology representation.\nA model is a single 3D topological modeling space, consisting of one or more distinct regions\nof space. A model is not strictly a topological element but acts as a repository for all topological\nelements contained in a geometric model, allowing the naming and manipulation of multiple\nmodels by a geometric modeling system.\nA region is a volume of space. There is always at least one in a model. Only one region\nin a model may have infinite extent; all others have a finite extent, and when more than one\nregion exists in a model, all regions have a boundary.\n\nsolid\nregion with\ninfinite extent\nA shell is an oriented boundary surface of a region. A single region may have more than\none shell (such as a solid object with a void contained within the solid). A shell may consist of\na connected set of faces which form a closed volume or may be an open set of adjacent faces,\na wire frame or a combination of these or even a single point.\nA face is a bounded portion of a shell. It is orientable, though not oriented, as two region\nboundaries (shells) may use different sides of the same face. Thus only the \"use of a face\" by\na shell is oriented.\nA loop is a connected boundary of a single face. A face may have one or more loops. Loops\nnormally consist of an alternating sequence of edges and vertices in a complete circuit, but\nmany consist of only a single vertex. Loops are also orientable but not oriented as they bound\na face which may be used by up to two different shells. Thus the \"use of a loop\" is oriented.\nAn edge is a portion of a loop boundary between two vertices. Topologically an edge is\na bounding curve segment which may serve as part of a loop boundary for one or more faces\n\nwhich meet at that edge. Every edge is bounded by a vertex at each end (possibly the same\none). An edge is orientable, though not oriented. The \"use of an edge\" is oriented.\nA vertex is simply a topologically unique point in space. Single vertices may also serve as\nboundaries of faces and as complete shell boundaries.\nAt least four additional types of topological element adjacency \"uses\" associated with the\nface, loop, edge and vertex elements may be defined.\nA face-use is one of two sides of a face. Face-uses, ie. the uses of a face by a shell, are\noriented with respect to the face geometry.\nA loop-use is one of the uses of a loop associated with one of the two uses of a face. It is\noriented with respect to the associated face use.\nAn edge-use is an oriented bounding curve segment on a loop-use of a face-use and represents\nthe use of an edge by that loop-use or if a wire frame edge by the point vertices. Orientation is\nspecified with respect to edge geometry. There may be many uses of a single edge in a model,\nbut there will always be an even number of edge-uses (since each use by a face produces two\nedge uses with one for each side). A wireframe edge produces two edge-uses, one for each end\nof the edge.\nA vertex use is a structure representing the adjacency use of a vertex by an edge as an end\npoint, by a loop in the case of a single vertex loop or by a shell in the case of a single vertex\nshell.\n14.9.2\nTopological sufficiency\nThirty six topological element adjacency relationships are possible in a NTM boundary rep-\nresentation with respect to six basic topological elements (vertex, edge, loop, face, shell and\nregion). There is no complete theory available yet concerning the identification and proof of the\ntheoretical minimal amount of topological information required to reconstruct a NTM topology.\nThe radial edge data structure developed for NTM topologies has been proven to be sufficient\nand complete.\n14.10\nRadial edge data structure\nThe radial edge data structure explicitly represents eleven topological element types. A hi-\nerarchical representation of topological elements in the radial edge structure is shown in Fig-\nure 14.33. Key ideas in design of the Radial Edge data structure are:\n- Top-down and bottom-up hierarchical relationships are represented.\n- Face-use, loop-use, edge-use and vertex-use are utilized to represent the adjacencies of\ntopological elements.\n- Radial ordering of faces around common edges is represented directly (this information\nallows representation of a NTM condition along an edge, see Figure 14.34).\n- Adjacency information pointing from vertex level to higher levels is represented (this\ninformation allows representation of a NTM condition at a point, see Figure 14.34 ).\nThe radial edge data structure can be implemented in terms of a set of doubly linked lists\n(DLL) and supporting data structures, see Figures 14.35- 14.38. The Euler-Poincare formula is\n\nshell\nface-use\nloop-use\nedge-use\nvertex-use\nface\nloop\nedge\nvertex\n(wireframe case)\n(single vertex loop case)\n(single vertex shell case)\nmodel\nregion\nFigure 14.33: Radial edge data structure (up-down point for boundary and ownership relation-\nships; left-right pointer for definition and attributes of an element).\n(a) NTM condition at a point\n(b) NTM condition along an edge\nFigure 14.34: NTM conditions.\n\nno longer valid for NTM topologies. NTM topology operators similar to Euler operators have\nbeen specified and defined by Weiler.A minimal sufficient set of NTM operators to construct\nany model are:\n- M-MR = create the model and initial region\n- M-SV = make shell vertex (for every vertex)\n- M-E = make edge\n- M-F = make face\n- K-E = kill edge.\n\n(1)\nmodel\nattributes\nregion list\nprevious\nmodel\nnext model\ntwo adjacenct elements in a DLL:\n\"next\" element = next item in a\nDLL with respect to an item\n\"previous\" element = previous\nitem in a DLL with respect\nto an item\n(2)\nregion\nattributes\nnext\nregion\nowning\nmodel\nshell list\nprevious\nregion\nface\nattributes\n(3)\nshell\nattributes\nnext\nshell\nowning\nregion\nface list\nprevious\nshell\nedge-use\nvertex-use\nor\nor\n(shell is wireframe)\n(shell is single vertex)\n(4)\n(a)\nface-use list\n(b)\nface-use\nowning\nshell\nnext\nface-use\nprevious\nface-use\nattributes\nface\norientation\nmate face-use\nloop-use list\n(opposite side\nof a face)\nList head\ne1\ne2\neN\nφ\nφ\ntail\nFigure 14.35: Implementation of radial edge structure.\n\nloop\nattributes\n(5)\n(a)\nloop-use list\n(b)\nloop-use\nowning\nface-use\nnext\nloop-use\nprevious\nloop-use\nattributes\nloop\nmate loop-use\nedge-use list\n(loop-use on the\nother side of a face)\nor\nvertex-use\n(loop is one vertex only)\nedge\nattributes\n(6)\n(a)\nedge-use list\n(b)\nedge-use\nattributes\nvertex-use\nowning shell\nor\nloop-use\nmate edge-use\nedge\ncw-edge-use\nccw-edge-use\nradial-edge-use\nowning-loop\norientation\n(7) (a)\nvertex\nattribute\nvertex-use list\n(b)\nvertex-use\nattribute\nvertex\nshell\nnext\nvertex-use\nprevious\nvertex-use\nor\nloop-use\nor\nedge-use\n(wireframe edge)\nFigure 14.36: Implementation of radial edge structure (continued).\n\neu1\neu2\nmate\nf1\nf2\neu3\neu4\nmate\nradial\nradial\nFigure 14.37: Radial edge representation of two faces joining along a common edge showing how\nthe four edge uses of the common edge (each side of each face uses the edges) are connected.\n\nfu1\nfu2\nface-use\nmate\npointers\nedge- use\nmate\npointers\ne1\ne1\nf1\nf2\nf3\nedge use\nradial\npointer\nf3\nf2\nfu3\nfu4\nfu5\nfu6\nFigure 14.38: Cross-section of three faces sharing a common edge in the radial edge represen-\ntation\n\nBibliography\n[1] L. Bardis and N. M. Patrikalakis. Topological structures for generalized boundary repre-\nsentations. MITSG 94-22, MIT Sea Grant College Program, Cambridge, Massachusetts,\nSeptember 1994.\n[2] B. G. Baumgart. Winged edge polyhedron representation. Technical Report STAN-CS-\n320, Computer Science Department, Stanford University, 1972.\n[3] E. Brisson.\nRepresenting geometric structures in d dimensions: Topology and order.\nDiscrete and Computational Geometry, 9:387-426, 1993.\n[4] E. L. G urs oz and F. B. Prinz. Node-based representation of non-manifold surface bound-\naries in geometric modeling. In M. Wozny, J. Turner, and K. Preiss, editors, Geometric\nModeling for Product Engineering. North-Holland, 1989.\n[5] C. M. Hoffmann. Geometric and Solid Modeling: An Introduction. Morgan Kaufmann\nPublishers, Inc., San Mateo, California, 1989.\n[6] M. M antyl a.\nAn Introduction to Solid Modeling.\nComputer Science Press, Rockville,\nMaryland, 1988.\n[7] M. E. Mortenson. Geometric Modeling. John Wiley and Sons, New York, 1985.\n[8] J. Rossignac and M. O'Connor. SGC: A dimension-independent model for pointsets with\ninternal structures and incomplete boundaries. In M. Wosny, J. Turner, and K. Preiss,\neditors, Geometric Modeling for Product Engineering, pages 145-180. North-Holland, 1989.\n[9] V. Shapiro. Solid modeling. Invited paper in Handbook of Computer Aided Geometric\nDesign, Chapter 20, pages 473-518, July 2002.\n[10] K. Weiler. Edge-based data structures for solid modeling in curved surface environments.\nIEEE Computer Graphics and Applications, 5(1):21-40, January 1985.\n[11] K. Weiler. Topological Structures for Geometric Modeling. PhD thesis, Rensselaer Poly-\ntechnic Institute, Troy, NY, 1986.\n[12] P. R. Wilson. Euler formulas and geometric modeling. IEEE Computer Graphics and\nApplications, 5(8):45-60, August 1985."
    },
    {
      "category": "Lecture Notes",
      "title": "lecnotes19.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/2-158j-computational-geometry-spring-2003/873e9c989a41417580a26266c43b9dca_lecnotes19.pdf",
      "content": "13.472J/1.128J/2.158J/16.940J\nCOMPUTATIONAL GEOMETRY\nLecture 19\nProf. N. M. Patrikalakis\nCopyright c⃝2003 Massachusetts Institute of Technology\nContents\nDecomposition models\n19.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.2 Exhaustive enumeration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.2.1 Definition and construction methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.2.2 Applications\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.2.3 Properties of exhaustive enumeration methods\n. . . . . . . . . . . . . . . . . . . . . . .\n19.3 Space subdivision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.3.1 Motivation and definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.3.2 Construction of octrees\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.3.3 Algorithms for octrees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.3.4 Properties of octrees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.3.5 Binary space subdivision\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.4 Cell decompositions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.4.1 Motivation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.4.2 Cell tuple data structure\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.4.3 Properties of cell decompositions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nIntegral properties of geometric models\n19.5 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.6 Integral properties of curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.6.1 Planar curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.6.2 3D curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.7 Integral properties of surface patches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.7.1 Planar regions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.7.2 Curved surface patch\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.8 Solids\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.9 Example: solid of revolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.10Appendix: Review of numerical integration methods . . . . . . . . . . . . . . . . . . . . .\n19.10.1 Trapezoidal rule of integration\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.10.2 Simpson's rule of integration\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.10.3 Romberg integration\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19.10.4 Double integrals\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nBibliography\n\nDecomposition models\n19.1\nIntroduction\nDecomposition models are representations of solids via combinations (unions) of basic special\nbuilding blocks glued together. Alternatively, decomposition models may be considered to\nrepresent solids in terms of a subdivision of space (see also Lecture 1 for more details on the\nclassification of these models). Various types of decomposition models are created by:\n- various building blocks\n- various combination methods used to create the model.\nIn order of increasing complexity, decomposition models are classified as follows:\n1. Exhaustive enumeration\n2. Space subdivision\n3. Cell decomposition\n\n19.2\nExhaustive enumeration\n19.2.1\nDefinition and construction methods\nExhaustive enumeration is a representation by means of nonoverlapping cubes of uniform size\nand orientation, see Figure 19.1. An object is represented by a three dimensional Boolean array.\nEach cell represents a cubic volume of space. If a cell intersects with the region of interest it\nhas a true value. Otherwise, the value is false. This can be pictured as a box divided into 3D\ncubical pixels, with 0 assigned if empty and 1 assigned if full. This representation involves:\n- A regular subdivision of 3D space within a cube of given size which is partitioned and\noriented in a certain way within a global coordinate system. The subdivision is made up\nof sub-cubes (3D pixels) of given size. Reference and access to each sub-cube is made by\nthree integer indices i, j, k.\n- For fixed space of interest we need a 3-D array, Cijk of binary data:\nCijk =\n(\nif the sub-cube i, j, k intersects the solid\nif the sub-cube i, j, k is empty\n(19.1)\nConstruction of exhaustive enumeration models requires an alternate representation or\nmeasurements (eg. digital tomograghy, medical scanning, sonar data, acoustic tomography\ndata, etc). Usually the primary data type for such construction is a B-Rep or a CSG model\nor another exhaustive enumeration model at different resolution, and cube location and orien-\ntation.\nOperations on exhaustive enumeration models are easy. Boolean operations for example\n(especially for models within the same cube at the same resolution) are direct.\nSimilarly\nvisualization and integral computations are very easy. However, for higher quality rendering,\nfiltering methods to estimate accurate surface normals may be involved [16].\nThe binary matrix (19.1) typically represents a valid solid. However disconnected cells or\ncells with low degree of connectivity as in Figure 19.2 are undesirable. For the results of Boolean\noperations, filtering may be needed to maintain connectivity of cells. Strict connectivity occurs\nwhen each full cell has at least one full neighbor across a face.\n19.2.2\nApplications\nApplications of exhaustive enumeration methods include:\n- Underwater environment representation.\n- Finite element meshing (first step in an algorithm to build such a mesh).\n- Medical 3D data representation.\n- Preprocessing representation for speeding up operations on other representations (eg.\napproximating integral properties such as volume, center of gravity, moments of inertia).\n\nFigure 19.1: Exhaustive enumeration.\nFigure 19.2: Various connectivities of cells in exhaustive enumeration models\n\n19.2.3\nProperties of exhaustive enumeration methods\nProperties of exhaustive enumeration methods include:\n- Expressive power: these methods are an approximation scheme and do not form a primary\nrepresentation, especially within CAD/CAM applications.\n- Unambiguity and uniqueness for fixed space (size, location and orientation of primary\ncube) and resolution. There do not exist different representations for the same object\nunder these conditions (which is not true of many other representation methods such as\nB-rep or CSG described before).\n- Memory intensive: eg. for a linear resolution of 256, 2563 integer elements for Cijk in\nequation 19.1 leading to 16M bits and this is a bare minimum.\n- Closure 1 of operations (eg. Booleans).\n- Computational ease for algorithms: VLSI implementation for volume rendering is possi-\nble. However, for high resolution the algorithm slows down.\n1Closure means that an operation such as Boolean results in an object that can be represented by the same\ntype of data structure.\n\nempty\nfull\npartially full\nFigure 19.3: Quadtree representation.\n19.3\nSpace subdivision\n19.3.1\nMotivation and definitions\nSome of the motivations behind space subdivision methods include:\n- Exhaustive enumeration is memory intensive and typically has low accuracy.\n- Smaller memory requirements are possible, if adaptive subdivision is used;\n- Octree/quadtree representations lead to a recursive subdivision into 8 octants (or 4 quad-\nrants) that can be represented as an 8-ary tree (or 4-ary tree) for which efficient algo-\nrithms are also known.\nIn an octree representation a solid region is represented by hierarchically decomposing a usually\ncubic volume of space into successively smaller cubes (8 of them). Hierarchical division and\ncube orientation usually follows the spatial coordinate system. An example of quadtree, the\ntwo dimensional analogue, is shown Figure 19.3.\nThis is a trivial example. The method can continue to many more levels for a much more\ncomplex model. Some tolerance for the minimum size block is required. In addition, this\nvery concise representation would become very large if the coordinate system was changed; for\nexample, rotated 45 degrees.\nThis method leads to a quick way to compute the area and other integral properties of\na region. It is often used in data analysis in fields such as medical applications and sonar\nimaging.\n\n19.3.2\nConstruction of octrees\nTo create an octree, we apply a classification procedure to a given solid (represented using the\nBoundary Representation, Constructive Solid Geometry, or Exhaustive Enumeration methods,\netc.) and decide if a given node of the octree is:\n- Exterior to solid (white);\n- Interior to solid (black);\n- Partially interior to solid (grey).\nThe classification procedure is used recursively. It is based on Boolean solid operations,\nespecially intersection. Figure 19.4 provides an simple example of octree representation.\nIn general, the decision if a given node of the octree is white, black, or grey is not an\neasy task. For the simple case of a convex solid object, it is sufficient to classify the eight\nvertices of the given node of the octree (which is a cube) with respect to the solid.\nThis\ncan be accomplished by for example casting a half-infinite ray from the point intersecting\nthe solid's surfaces in a number of (multiplicity one) intersection points. If the number of\nsuch intersection points is even/odd, the point is outside/in (or on the surface of the solid).\nHowever, for a concave solid object, classification of the six faces of the cube with respect to\nthe solid is necessary, see Figure 19.5 for an illustration in the 2-D case. This requires surface\nintersections with a planar patch. The memory and processing computation required for a 3-D\nobject is on the order of the surface area of the object [12] [9]. Depending on the object and\nthe resolution, this can still represent a large storage requirement.\n19.3.3\nAlgorithms for octrees\nVarious algorithms for octrees are developed in Meagher [12] and are summarized here:\n1. Tree generation or conversion from other representation methods were discussed above\nin Section 19.3.2.\n2. Set operators (union, intersection, difference): A low resolution tree could be an effective\npreprocessor for a B-rep model in processes like interference checking.\n3. Geometric transformations (translation, rotation, scaling).\n4. Analysis procedures (integral, volume properties, connected components).\n5. Rendering [16].\nAs an example we consider set or Boolean operations. Set operations lead to simple tree\ntraversal\nIntersection(Tree A, Tree B) = Tree C\nTrees are traversed in synchronous fashion and a case analysis for the types of nodes is\nperformed.\nWe use the terms \"black\"= in-solid,\"white\" = out-of-solid.\nAt each level of\nsubdivision there are three cases [11]:\n\nFigure 19.4: An octree model.\nFigure 19.5: Classification of an quadtree node with respect to a concave object\n\n1. If nodes n1 and n2 are both leaves, then the resulting node n3 is black if n1 and n2 are\nboth black; otherwise n3 is white.\n2. Either n1 or n2 is a leaf. If the leaf node is black, then the subtree of the non-leaf node\nis copied to the resultant octree; otherwise the resulting node is white.\n3. If nodes n1 and n2 are non-leaves, then the algoritm considers recursively their children\nas above.\nThe complexity of such an intersection algorithm is proportional to the size of the smaller\ntree.\nNot all algorithms are in the form of a simple tree traversal. Some algorithms may require at\nworst, a traversal up to the root and back down to a neighbor. Examples of such algorithms are\nsurface rendering (shading), transparency rendering, and extraction of connected components.\n19.3.4\nProperties of octrees\nSome of the properties of octrees include:\n- Expressive power: they are an approximation scheme and do not form a primary repre-\nsentation.\n- Validity: if no special connectivity is required, all octrees are valid.\n- Unambiguity and uniqueness: for a fixed resolution there is only one compacted2 octree;\n- Memory requirements: not as large as exhaustive enumeration models, yet typically much\nlarger than Boundary Representation and Constructive Solid Geometry models;\n- Closure of operations: for example for Boolean operations and transformations;\n- Computational ease: octrees are somewhat more complex than exhaustive enumeration.\n2Algorithms such as set operations can create octrees with unnecessary nodes (eg. an internal nodes whose\nchildren are all black). Such nodes can be removed with a relatively simple tree traversal algorithm.\n\n19.3.5\nBinary space subdivision\nFigure 19.6: Binary subdivision tree.\nBeyond octrees, an alternative type of tree representation involves dividing nodes into 2\nrather than 8 components, see M antyl a [11] and Figure 19.6. Subdivisions are performed in the\nX, Y, and Z coordinate directions sequentially. Binary trees are typically somewhat smaller\nthan octrees and they can be converted to linear arrays containing special symbols [11].\n\n19.4\nCell decompositions\n19.4.1\nMotivation\nThe motivation for cell decomposition methods is:\n- Use of elements other than cubes, see Figure 19.7 for an example.\n- Applications such as design of inhomogeneous (eg. composites) and functionally graded\nmaterials, finite element analysis methods, scientific visualization of scalar and vector\nfields.\n- Cells are parametrized instances of a generic cell type, eg. a cell bounded by quadratic\ncurves and surfaces.\n- Cells are homeomorphic to spheres.\n- Cells meet at a vertex, edge, face otherwise the representation is invalid.\n- Cells are disjoint and non-overlapping.\n- Cells may belong to different cell types, eg. box-like, tetrahedra-like, etc.\nFigure 19.7: A cell decomposition (finite element mesh).\n19.4.2\nCell tuple data structure\nA cell decomposition can be represented using the cell-tuple data structure [2] which applies for\nn-D models, see also [1] for a review and summary of other related data structures such as the\nQuad-edge structure [6] for 2D models and the Facet-edge pair structure [4, 5] for 3-D models.\nFigures 19.8 and 19.9 present 2D and 3D examples. This data structure can be mapped into\na relational database or a graph structure.\n\nFigure 19.8: Cell data structure for a 2D model\nVolume\nFace\nEdge\nVertex\nFigure 19.9: Cell data structure for a 3D model\n\n19.4.3\nProperties of cell decompositions\nThe properties of cell decomposition methods are:\n- Expressive power: they are very general and accurate, not necessarily requiring approxi-\nmations;\n- Validity: they require an intersection test for verification;\n- Unambiguity: they provide an unambiguous representation;\n- Nonuniqueness: Similarly to the Constructive Solid Geometry method, the same object\ncan be represented at different resolutions or with different types of mesh (eg. hexahedral,\ntetrahedral, etc.);\n- Generation: It typically is done by conversion from other representations with or without\ngeometric approximation;\n- Conciseness: memory utilization is less than octrees, yet more than Boundary Represen-\ntation;\n- Applicability: finite element meshing, multimaterial non-homogeneous objects, visualiza-\ntion of fields, etc.\n\nIntegral properties of geometric models\n19.5\nIntroduction\nOne of the important advantages of using a CAD model for representing and designing an\nobject is that we can easily compute the integral properties of such models such as edge curves,\nfaces and volumes. Integral properties include length, area, centroid, moment of inertia, and\nvolume. These are very useful in preliminary design. For example, surface area affects drag,\nvolume affects the carrying capacity of a vehicle, centroids are useful in hydrostatic balance,\nmoments of inertia are used in dynamics and in hydrostatic stability calculation (for ships).\nComputation of the integral properties of curves, surface patches and solids involves eval-\nuation of single, double and triple integrals of the form\nφcurve =\nZ\ncurve f(P)dL,\nφsurface =\nZ\nsurface f(P)dS,\nφsolid =\nZ\nsolid f(P)dV\n(19.2)\nwhere φ is the required property, P is a point and f is a real-valued function, which depends on\nthe type of property required. We have studied three classes of solid representation methods in\nthe previous chapters, namely Decomposition methods, Constructive Solid Geometry (CSG)\nmethods, and Boundary Representation (B-rep) methods.\nFor decomposition methods, the integral over the solid reduces to a sum of integrals\nZ\nsolid fdV =\nX\ni\nZ\ncelli\nfdV\n(19.3)\nwhere celli is the i -th cell which is either full or partially full. For the case of exhaustive\nspatial enumeration the cells are constant-sized cubes and for the octree decompositions they\nare variable-sized cubes [10, 13]. For high resolution models it is enough to consider all the\ncelli to be full entirely and for those cases the resulting integrals are elementary and can be\ncomputed using simple analytic forms.\nAs we have studied in the previous chapters, CSG is a tree whose nodes represent the\nBoolean operators and the leaves are the primitive solids. Therefore the computation of integral\nproperties of CSG solids consists of applying the following formula recursively [10]:\nZ\nA∪B fdV\n=\nZ\nA fdV +\nZ\nB fdV -\nZ\nA∩B fdV\n(19.4)\nZ\nA-B fdV\n=\nZ\nA fdV -\nZ\nA∩B fdV.\n(19.5)\n\nConsequently we need to compute integrals over primitives (which can be evaluated analyti-\ncally) and integrals involving intersections of primitives\nR\nA∩B fdV which can be approximated\nusing a ray casting, ray classification and integral approximation method.\nBoundary representation, which is the most generally used representation today, represents\nthe object in terms of their boundary elements (e.g. vertices, edges, faces). For evaluating the\nintegral properties for B-rep solids, the following theorems from vector calculus are useful [7]:\n1. Green's Theorem\nIf C is a piecewise smooth, simple closed curve that bounds a region R, and if P(x, y)\nand Q(x, y) are continuous functions which have continuous partial derivatives along C\nand throughout R, then\nI\nC(Pdx + Qdy) =\nZZ\nR\n∂Q\n∂x -∂P\n∂y\n!\ndA\n(19.6)\n2. Divergence Theorem (also called Gauss' Theorem)\nThe flux of vector field F flowing outward through a closed surface S equals the integral\nof the divergence of F over the region R bounded by S;\nZZ\nS F · ndA =\nZZZ\nR ∇FdV\n(19.7)\nwhere n is the outward unit normal vector and\n∇· F = ∂F\n∂x · i + ∂F\n∂y · j + ∂F\n∂z · k.\n(19.8)\nwhere i, j, k are the unit coordinate vectors.\nIn the sequel we will apply these theorems to compute the integral properties of geometric\nmodels represented by the B-rep method (in 1-3 dimensions).\n19.6\nIntegral properties of curves\n19.6.1\nPlanar curves\nLet a planar curve be defined by\nr = (x(t), y(t)) , to ≤t ≤t1\n(19.9)\n- Length\nL\n=\nZ s1\ns0\nds =\nZ t1\nt0\nq\nr(t) · r(t)dt\n(19.10)\n=\nZ t1\nt0\nq\nx2(t) + y2(t)dt\n\n- \"Centroid\"\nrc\n=\n(xc, yc) =\nR s1\ns0 rds\nR s1\ns0 ds\n(19.11)\n=\nL\nZ t1\nt0\nr(t)\nq\nx2(t) + y2(t)dt\n- \"Moments of inertia\"\nIxx\n=\nZ s1\ns0\ny2ds =\nZ t1\nt0\ny2(t)\nq\nx2(t) + y2(t)dt\n(19.12)\nIyy\n=\nZ s1\ns0\nx2ds =\nZ t1\nt0\nx2(t)\nq\nx2(t) + y2(t)dt\n(19.13)\nIxy\n=\nZ s1\ns0\nxyds =\nZ t1\nt0\nx(t)y(t)\nq\nx2(t) + y2(t)dt\n(19.14)\n19.6.2\n3D curves\nLet a 3D curve be defined by\nr = (x(t), y(t), z(t)) , to ≤t ≤t1\n(19.15)\n- Length\nL\n=\nZ s1\ns0\nds =\nZ t1\nt0\nq\nr(t) · r(t)dt\n(19.16)\n=\nZ t1\nt0\nq\nx2(t) + y2(t) + z2(t)dt\n- \"Centroid\"\nrc\n=\n(xc, yc, zc) =\nR s1\ns0 rds\nR s1\ns0 ds\n(19.17)\n=\nL\nZ t1\nt0\nr(t)\nq\nx2(t) + y2(t) + z2(t)dt\n- \"Moments of inertia\"\nIxx\n=\nZ s1\ns0\n(y2 + z2)ds =\nZ t1\nt0\n\ny2(t) + z2(t)\nq\nx2(t) + y2(t) + z2(t)dt\n(19.18)\nIyy\n=\nZ s1\ns0\n(x2 + z2)ds =\nZ t1\nt0\n\nx2(t) + z2(t)\nq\nx2(t) + y2(t) + z2(t)dt\n(19.19)\nIzz\n=\nZ s1\ns0\n(x2 + y2)ds =\nZ t1\nt0\n\nx2(t) + y2(t)\nq\nx2(t) + y2(t) + z2(t)dt\n(19.20)\nIxy\n=\nZ s1\ns0\nxyds =\nZ t1\nt0\nx(t)y(t)\nq\nx2(t) + y2(t) + z2(t)dt\n(19.21)\nIyz\n=\nZ s1\ns0\nyzds =\nZ t1\nt0\ny(t)z(t)\nq\nx2(t) + y2(t) + z2(t)dt\n(19.22)\nIxz\n=\nZ s1\ns0\nxzds =\nZ t1\nt0\nx(t)z(t)\nq\nx2(t) + y2(t) + z2(t)dt\n(19.23)\n\n19.7\nIntegral properties of surface patches\n19.7.1\nPlanar regions\nLet us consider a planar region as in Figure 19.10\nC:r(t)\nA\nFigure 19.10: Planar region A\n- Area\nA =\nZZ\nA dA\n(19.24)\nUsing Green's theorem with Q(x, y) = x and P(x, y) = -y, then\n2(Qx -Py) = 1\n2(1 + 1) = 1\n(19.25)\nwhere subscripts x, y denote partial derivatives. We can rewrite equation (19.24) using\nGreen's theorem as\nA\n=\nZZ\nA\n2(Qx -Py)dxdy\n=\nI\nC(Pdx + Qdy)\n=\nI\nC(-ydx + xdy)\n=\nI\nC(x y -y x)dt\n(19.26)\nIf x(t), y(t) are piecewise polynomial functions, the above integral can be evaluated from\na symbolic/analytic integration formula but this is typically tedious. By contrast, nu-\nmerical integration methods may be used more easily (see Appendix).\n- Centroid\nrc = (xc, yc) =\nRR\nA rdA\nRR\nA dA ,\n\nwhere A is the shaded area, and\nZZ\nA rdA =\nZZ\nA xdA,\nZZ\nA ydA\n\n.\n(19.27)\nLet Q(x, y) = x2\n2 , P(x, y) = 0, then\nQx -Py = x -0 = x\n(19.28)\nTherefore\nZZ\nA xdA =\nI\nC Pdx + Qdy =\nI\nC x2dy\n(19.29)\nwhere C is the complete boundary of A. Thus,\nxc\n=\nRR\nA xdA\nRR\nA dA\n=\nA\nZZ\nA xdA\n=\nA\nI\nC x2 ydt\n(19.30)\nLet Q(x, y) = 0, P(x, y) = -y2\n2 , then\nQx -Py = 0 + y = y\n(19.31)\nSimilarly,\nyc\n=\nRR\nA ydA\nRR\nA dA\n=\nA\nZZ\nA ydA\n=\n-1\nA\nI\nC y2 xdt\n(19.32)\n- Moments of inertia\n1. Ixx =\nRR\nA y2dA\nLet Q(x, y) = 0, P(x, y) = -y3\n3 , then\nQx -Py = y2\n(19.33)\nUsing Green's Theorem,\nIxx\n=\nZZ\nA(Qx -Py)dxdy =\nI\nC -y3dx\n=\n-\nI\nC y3 xdt\n(19.34)\n\n2. Iyy =\nRR\nA x2dA\nLet Q(x, y) = x3\n3 , P(x, y) = 0, then\nQx -Py = x2\n(19.35)\nUsing Green's Theorem,\nIyy\n=\nZZ\nA(Qx -Py)dxdy = 1\nI\nC\nx3\n3 dy\n=\nI\nC x3 ydt\n(19.36)\n3. Ixy =\nRR\nA xydA\nLet Q(x, y) = x2y\n2 , P(x, y) = 0, then\nQx -Py = xy + 0 = xy\n(19.37)\nUsing Green's Theorem,\nIxy\n=\nZZ\nA(Qx -Py)dxdy\n=\nI\nC x2y ydt\n(19.38)\nIf x(t), y(t) are piecewise polynomial functions, the above integrals can be evaluated\nfrom a symbolic/analytic integration formula but this is typically tedious. By contrast,\nnumerical integration methods may be used more easily (see Appendix).\n19.7.2\nCurved surface patch\nLet us consider a curved surface patch r = r(u, v), with (u, v) ∈A, where A is a given\nparametric domain, as in Figure 19.11.\nr(u,v)\nv\nu\nFigure 19.11: Curved surface patch\n\n- Area\nA\n=\nZZ\nA dA\n=\nZZ\nA |ru × rv|dudv =\nZZ\nA\n√\nEG -F 2dudv\n(19.39)\nwhere E, F and G are the first fundamental form coefficients E = ru·ru, F = ru·rv, G =\nrv · rv. (see Chapter 2).\n- \"Centroid\"\nrc\n=\n(xc, yc, zc) =\nRR\nA rdA\nRR\nA dA\n=\nA\nZZ\nA[x(u, v), y(u, v), z(u, v)]\n√\nEG -F 2dudv\n(19.40)\n- \"Moments of inertia\"\nIxx\n=\nZZ\nA[y2(u, v) + z2(u, v)]\n√\nEG -F 2dudv\n(19.41)\nIyy\n=\nZZ\nA[x2(u, v) + z2(u, v)]\n√\nEG -F 2dudv\n(19.42)\nIzz\n=\nZZ\nA[x2(u, v) + y2(u, v)]\n√\nEG -F 2dudv\n(19.43)\nIxy\n=\nZZ\nA[x(u, v)y(u, v)]\n√\nEG -F 2dudv\n(19.44)\nIxz\n=\nZZ\nA[x(u, v)z(u, v)]\n√\nEG -F 2dudv\n(19.45)\nIyz\n=\nZZ\nA[y(u, v)z(u, v)]\n√\nEG -F 2dudv\n(19.46)\nIntegrals 19.39-19.46 may be evaluated numerically as in the Appendix.\n19.8\nSolids\nFor solids described by the B-rep method it is convenient to transform volume integrals into\nsurface integrals by means of the divergence theorem.\n- Volume\nV =\nZZZ\nV dV\n(19.47)\nChoose\nr = xi + yj + zk\n(19.48)\nthen\n∇· r = ∂r\n∂x · i + ∂r\n∂y · j + ∂r\n∂z · k = 3\n(19.49)\n\nUsing the Divergence (or Gauss') Theorem,\nV\n=\nZZZ\nV dV = 1\nZZZ\nV ∇· rdV\n=\nZZ\nA r · ndA = 1\nZZ\nA r · n|ru × rv|dudv\n=\nZZ\nA r · (ru × rv)dudv\n(19.50)\ngiven that\nn = ru × rv\n|ru × rv|\n(19.51)\n- Centroid\nrc = (xc, yc, zc) =\nRRR\nV rdV\nRRR\nV dV\n(19.52)\nChoose\nr = 1\n2x2i\n(19.53)\nthen\n∇· r\n=\n∂r\n∂x · i + ∂r\n∂y · j + ∂r\n∂z · k = x\n(19.54)\nxc\n=\nV\nZZZ\nV xdV = 1\nV\nZZZ\nV ∇· rdV\n=\nV\nZZ\nA\n2x2(i · n)dA\n=\nV\nZZ\nA\n2x2(i · (ru × rv))dudv\n(19.55)\nSimilarly, expressions are obtained for yc, zc:\nyc\n=\nV\nZZ\nA\n2y2(j · (ru × rv))dudv\n(19.56)\nzc\n=\nV\nZZ\nA\n2z2(k · (ru × rv))dudv\n(19.57)\n- Moments of inertia\nIxx =\nZZZ\nV (y2 + z2)dV\n(19.58)\nChoose\nr = (y2 + z2)xi\n(19.59)\n\nthen\n∇· r\n=\n∂r\n∂x · i + ∂r\n∂y · j + ∂r\n∂z · k = y2 + z2\n(19.60)\nThus\nIxx\n=\nZZZ\nV (y2 + z2)dV =\nZZZ\nV ∇· rdV\n=\nZZ\nA(y2 + z2)x(i · n)dA\n=\nZZ\nA(y2 + z2)x(i · (ru × rv))dudv\n(19.61)\nSimilarly,\nIyy\n=\nZZ\nA(x2 + z2)y(j · (ru × rv))dudv\n(19.62)\nIzz\n=\nZZ\nA(x2 + y2)z(k · (ru × rv))dudv\n(19.63)\nIxy\n=\nZZ\nA xyz(k · (ru × rv))dudv\n(19.64)\nIxz\n=\nZZ\nA xzy(j · (ru × rv))dudv\n(19.65)\nIyz\n=\nZZ\nA yzx(i · (ru × rv))dudv\n(19.66)\n19.9\nExample: solid of revolution\nr(t)=x(t)i+y(t)j\nx\ny\ny\nz\nθ\nend1\nend2\nx(t1)\nx(t2)\nFigure 19.12: Solid of revolution\nLet a solid of revolution be defined by\nr(t, θ) = x(t)i + y(t) sin θj + y(t) cos θk,\n(19.67)\nt1 ≤t ≤t2,\n0 ≤θ ≤2π.\nand we assume that the two end caps are closed offwith planar disks (see Figure 19.12).\n\n- Surface area of surface of revolution (with end caps)\nrt\n=\n( x, y sin θ, y cos θ)\n(19.68)\nrθ\n=\n(0, y cos θ, -y sin θ)\n(19.69)\nrt × rθ\n=\n\ni\nj\nk\nx\ny sin θ\ny cos θ\ny cos θ\n-y sin θ\n\n=\n(-y y sin2 θ -y y cos2 θ)i + xy sin θj + xy cos θk\n=\n-y yi + xy sin θj + xy cos θk\n(19.70)\n|rt × rθ|\n=\nq\ny2 y2 + x2y2 = y\nq\nx2 + y2\n(19.71)\nA\n=\nZZ\nA dA =\nZ t2\nt1\nZ 2π\ny\nq\nx2 + y2dθdt\n=\n2π\nZ t2\nt1\ny\nq\nx2 + y2dt\n(19.72)\n- Volume\nrt × rθ\n=\n(-y y, xy sin θ, xy cos θ)\n(19.73)\nr · (rt × rθ)\n=\n(x, y sin θ, y cos θ) · (-y y, xy sin θ, xy cos θ)\n=\n-xy y + xy2 sin2 θ + xy2 cos2 θ\n=\n-xy y + xy2\n(19.74)\nV\n=\nZ t2\nt1\nZ 2π\nr · (rt × rθ)dtdθ -1\nZZ\nAend1\nxdxdy + 1\nZZ\nAend2\nxdxdy\n=\nZ t2\nt1\nZ 2π\n(-xy y + xy2)dθdt -π\n3 x(t1)y2(t1) + π\n3x(t2)y2(t2)\n=\n2π\nZ t2\nt1\n(-xy y + xy2)dt -π\n3x(t1)y2(t1) + π\n3x(t2)y2(t2)\n(19.75)\nUsing integration by parts,\n-\nZ t2\nt1\nxy ydt\n=\n-[xy2]t2\nt1 +\nZ t2\nt1\n(xy)′ydt\n=\n-x(t2)y2(t2) + x(t1)y2(t1) +\nZ t2\nt1\n( xy2 + xy y)dt\n(19.76)\nThus\n-2\nZ t2\nt1\nxy ydt = -x(t2)y2(t2) + x(t1)y2(t1) +\nZ t2\nt1\nxy2dt\n(19.77)\n\nThe volume, therefore, is\nV\n=\n2π\nZ t2\nt1\nxy2dt -2π\nZ t2\nt1\n(-xy y)dt -π\n3 x(t1)y2(t1) + π\n3 x(t2)y2(t2)\n=\nπ\nZ t2\nt1\nxy2dt\n(19.78)\n(corroborating the obvious formula from elementary calculus)\n- Centroid\n1. i · (rt × rθ) = -y y\nxc\n=\nV\nZ t2\nt1\nZ 2π\n2x2(-y y)dtdθ -π\n2V x2(t1)y2(t1) + π\n2V x2(t2)y2(t2)\n=\nπ\nV\nZ t2\nt1\n(-x2y y)dt + π\n2V (x2(t2)y2(t2) -x2(t1)y2(t1))\n(19.79)\nIntegrate by parts\n-\nZ t2\nt1\nx2y ydt\n=\n-[x2y2]t2\nt1 +\nZ t2\nt1\n(x2y)′ydt\n=\n-x2(t2)y2(t2) + x2(t1)y2(t1) +\nZ t2\nt1\n(2x xy + x2 y)ydt (19.80)\nThus\n-2\nZ t2\nt1\nx2y ydt = -x2(t2)y2(t2) + x2(t1)y2(t1) + 2\nZ t2\nt1\nx xy2dt\n(19.81)\nand\nxc = π\nV\nZ t2\nt1\nx xy2dt\n(19.82)\n(corroborating the obvious formula from elementary calculus)\n2. j · (rt × rθ) = xy sin θ\nyc\n=\nV\nZZ\nA\n2y2 xy sin θdtdθ\n=\n2V\nZ t2\nt1\nZ 2π\ny3 x sin θdθdt\n=\n2V\nZ t2\nt1\ny3 x[-cos θ]2π\n0 dt\n=\n(19.83)\n3. k · (rt × rθ) = xy cos θ\nzc\n=\nV\nZZ\nA\n2z2 xy cos θdtdθ\n=\n2V\nZ t2\nt1\nZ 2π\nxyz2 cos θdθdt\n=\n2V\nZ t2\nt1\nxyz2[sin θ]2π\n0 dt\n=\n(19.84)\n\n19.10\nAppendix: Review of numerical integration meth-\nods\n19.10.1\nTrapezoidal rule of integration\nHere we compute\nR b\na f(x)dx as in Figure 19.13 by decomposing the integral into n subintervals\n[3]. The area over each subinterval is approximated by the area of the trapezoid. The integral\nis then obtained by the sum of areas over all the subintervals.\n- Area in each subinterval [xi, xi+1]\nZ xi+1\nxi\nf(x)dx ≈(f(xi) + f(xi+1)) ∆x\n= h\n2 (fi + fi+1)\n(19.85)\nwhere ∆x = xi+1 -xi.\n- [a, b] subdivided into n-subintervals\nZ b\na f(x)dx =\nn\nX\ni=1\nh\n2(fi + fi+1) = h\n2(f1 + 2f2 + 2f3 + · · · + 2fn + fn+1)\n(19.86)\nx1=a x2 x3 x4 ... xn xn+1=b\nf(x)\nFigure 19.13: Trapezoidal rule of integration\n- Error in Trapezoidal rule [3]\nLocal error\n-h3\n12f ′′(ξ), xi < ξ < xi+1\nGlobal error\n-h2\n12(b -a)f ′′(ξ), a < ξ < b\n\n19.10.2\nSimpson's rule of integration\nFor the trapezoidal rule, we approximate the curve by n straight line segments, while in\nSimpson's rule of integration we approximate it with a parabola in a piecewise manner [3].\ny = ax2 + bx + c.\n(19.87)\nTherefore, this rule requires the use of three base points.\n- Area in two subintervals [-h, h]\nLet the three points be x = -h, 0, h, and the corresponding y values be f1, f2, and f3,\nsee Figure 19.14. Then,\nf1\n=\nah2 -bh + c\n(19.88)\nf2\n=\nc\n(19.89)\nf3\n=\nah2 + bh + c\n(19.90)\nIf we solve for a, b, and c, we obtain\n-h\nx\ny\nf2\nf1\nf3\nh\nFigure 19.14: Simpson's rule\na\n=\nf1 -2f2 + f3\n2h2\n(19.91)\nb\n=\nf3 -f1\n2h\n(19.92)\nc\n=\nf2\n(19.93)\nThus,\nZ h\n-h(ax2 + bx + c)dx\n=\na\n3[x3]h\n-h + b\n2[x2]h\n-h + c[x]h\n-h\n=\n2a\n3 h3 + 2ch\n=\nh\n3[f1 + 4f2 + f3]\n(19.94)\n- Area in [a, b] subdivided into n-subintervals\nZ b\na f(x)dx = h\n3(f1 + 4f2 + 2f3 + 4f4 + 2f5 + · · · + 2fn-1 + 4fn + fn+1)\n(19.95)\n\n- Error in Simpson's rule [3]\nLocal error\n-h5\n90f (4)(ξ), xi < ξ < xi+1\nGlobal error\n-b -a\n180 h4f (4)(ξ), a < ξ < b\n19.10.3\nRomberg integration\nLet us compute the integration of f(x) using the trapezoidal rule over the interval [a, b] with\n∆x = h. If we denote the output of the trapezoidal rule as T0,1, then\nTrue value = T0,1 + O(h2)\n(19.96)\nNow let us assume that O(h2) = C1h2, where C1 is constant. Then,\nTrue value = T0,1 + C1h2\n(19.97)\nIf we double the number of subintervals such that ∆x = h\n2, then,\nTrue value ≈T1,1 + C1\nh\n!2\n(19.98)\nThere are two unknowns in equation (19.97) and (19.98), True value and constant C1. Sub-\ntracting (19.97) from four times (19.98) yields\nTrue value ≈T0,2 ≡T1,1 + 1\n3(T1,1 -T0,1)\n(19.99)\nSimilarly, we can obtain for ∆x = h\nTrue value ≈T2,1 + C1\n16 h2\n(19.100)\nFrom (19.98) and (19.100), we obtain\nT1,2 = T2,1 + 1\n3(T2,1 -T1,1)\n(19.101)\nWe can make a further improvement by using T0,2 and T1,2 and setting up the relations\nTrue value\n=\nT0,2 + C2h4\n(19.102)\nTrue value\n≈\nT1,2 + C2\nh\n!4\n(19.103)\nand hence\nT0,3 = T1,2 + 1\n15(T1,2 -T0,2)\n(19.104)\n\nT0,1\nT0,2\nT0,3\nT1,1\nT1,2\nT2,1\nWe can arrange procedures in a matrix form as\nWe can also summarize the rule as\nImproved value = more accurate +\n\n2n -1\n\n(more accurate -less accurate)\nwhere n is the exponent on h in the error term O(hn).\nExamples:\nR 1\n0 cos(x)dx = sin(1) = 0.841470985\nT0,1\n=\n2(cos(0) + cos(1)) = 0.770151153\nT1,1\n=\n2T0,1 + 1\n2 cos(0.5) = 0.823866857\nT2,1\n=\n2T1,1 + 1\n4(cos(0.25) + cos(0.75)) = 0.837083751\nT0,2\n=\nT1,1 + 1\n3(T1,1 -T0,1) = 0.841651966\nT1,2\n=\nT2,1 + 1\n3(T2,1 -T1,1) = 0.841489382\nT0,3\n=\nT1,2 + 1\n16(T1,2 -T0,2) = 0.841479221\nwhich is accurate to 5 significant digits.\n19.10.4\nDouble integrals\nZZ\nA f(x, y)dA\n(19.105)\n1. Over a rectangular domain\nx\ny\na\nb\nc\nd\nI =\nZZ\nA f(x, y)dA =\nZ b\na\nZ d\nc f(x, y)dy\n!\ndx =\nZ d\nc\nZ b\na f(x, y)dx\n!\ndy\n(19.106)\n\nWe will use the trapezoid rule in x and y directions. Let\nhx\n=\nb -a\nn\n(19.107)\nhy\n=\nd -c\nn\n(19.108)\nwe start with y = c,\ny = c : I1\n=\nZ b\na f(x, c)dx\n=\nhx\n2 (f1(c) + 2f2(c) + · · · + 2fn(c) + fn+1(c))\n(19.109)\nwhere fi(c) = f(xi, c). Similarly,\ny = c + hy : I2\n=\nZ b\na f(x, c + hy)dy\n=\nhx\n2 (f1(c + hy) + 2f2(c + hy) + · · · + 2fn(c + hy) + fn+1(c + hy))\n(19.110)\n· · ·\ny = d : In+1\n=\nZ b\na f(x, d)dy\n=\nhx\n2 (f1(d) + 2f2(d) + · · · + 2fn(d) + fn+1(d))\n(19.111)\nWe now sum I1, I2, · · ·, In+1 in y direction in terms of the trapezoidal rule\nI = hy\n2 (I1 + 2I2 + · · · + 2In + In+1)\n(19.112)\n2. Over a curved boundary domain, see Figure 19.15\nFirst we need to find ai, bi. We equate y(t) with c+(i-1)hy, where c = min y(t). Then\nwe solve for t, leading to two (or more) intersections. Plugging the resulting t into x(t)\nyields ai and bi.\nSimilar to the rectangular domain case, we use the trapezoidal rule in both x and y\ndirections.\nLet\nhi\nx\n=\nbi -ai\nn\n(19.113)\nhy\n=\nd -c\nn\n(19.114)\n\nx\ny\na1\na2\nan+1\nb1 b2\nbn+1\nC(t)=(x(t),y(t))\nd\nc\nFigure 19.15: A curved boundary domain\nWe start with y = c:\ny = c : I1\n=\nZ b1\na1\nf(x, c)dx\n=\nh1\nx\n2 (f1(c) + 2f2(c) + · · · + 2fn(c) + fn+1(c))\n(19.115)\ny = c + hy : I2\n=\nZ b2\na2\nf(x, c + hy)dx\n=\nh2\nx\n2 (f1(c + hy) + 2f2(c + hy) + · · · + 2fn(c + hy) + fn+1(c + hy))\n(19.116)\n· · ·\ny = d : In+1\n=\nZ bn+1\nan+1\nf(x, d)dx\n=\nhn+1\nx\n(f1(d) + 2f2(d) + · · · + 2fn(d) + fn+1(d))\n(19.117)\nThese formulae can be extended to curved domain boundaries bounding multiply con-\nnected domains.\n\nBibliography\n[1] L. Bardis and N. M. Patrikalakis. Topological structures for generalized boundary repre-\nsentations. MITSG 94-22, MIT Sea Grant College Program, Cambridge, Massachusetts,\nSeptember 1994.\n[2] E. Brisson.\nRepresenting geometric structures in d dimensions: Topology and order.\nDiscrete and Computational Geometry, 9:387-426, 1993.\n[3] G. Dahlquist and A. Bj orck. Numerical Methods. Prentice-Hall, Inc., Englewood Cliffs,\nNJ, 1974.\n[4] D. P. Dobkin and M. J. Laszlo. Primitives for the manipulation of three-dimensional\nsubdivisions. In Proceedings of the Third ACM Symposium on Computational Geometry,\npp. 86-99, Waterloo, Canada, June 1987.\n[5] D. P. Dobkin and M. J. Laszlo. Primitives for the manipulation of three-dimensional\nsubdivisions. Algorithmica, 4:3-32, 1989.\n[6] L. Guibas and J. Stolfi. Primitives for the manipulation of general subdivisions and the\ncomputation of Voronoi diagrams. ACM Transactions on Graphics, 4(2):74-123, April\n1985.\n[7] F. B. Hildebrand. Advanced Calculus for Applications. Prentice-Hall, Inc., Englewood\nCliffs, New Jersey, 1976.\n[8] C. M. Hoffmann. Geometric and Solid Modeling: An Introduction. Morgan Kaufmann\nPublishers, Inc., San Mateo, California, 1989.\n[9] G. M. Hunter and K. Steiglitz. Operations on images using quad trees. IEEE Transactions\non Pattern Analysis and Machine Intelligence, 1(2):145-153, 1979.\n[10] Y. T. Lee and A. A. G. Requicha. Algorithms for computing the volume and other integral\nproperties of solid objects, I: Known methods and open issues. Communications of the\nACM, 25(9):635-641, September 1982.\n[11] M. M antyl a.\nAn Introduction to Solid Modeling.\nComputer Science Press, Rockville,\nMaryland, 1988.\n[12] D. Meagher. Geometric modeling using octtree encoding. Computer Graphics and Image\nProcessing, 19:129-147, June 1982.\n\n[13] M. E. Mortenson. Geometric Modeling. John Wiley and Sons, New York, 1985.\n[14] A. A. G. Requicha. Representations of solid objects - theory, methods and systems. ACM\nComputing Surveys, 12(4):437-464, December 1980.\n[15] V. Shapiro.\nSolid modeling.\nIn G. Farin et al., editor, Handbook of Computer Aided\nGeometric Design, Chapter 20, pp. 473-518. Elsevier, Amsterdam, 2002.\n[16] R. Yagel, D. Cohen, and A. Kaufman. Context sensitive normal estimation for volume\nimaging. In N. M. Patrikalakis, editor, Scientific Visualization of Physical Phenomena,\npp. 211-232. Tokyo: Springer-Verlag, 1991."
    }
  ]
}