{
  "course_name": "A Gentle Introduction to Programming Using Python",
  "course_description": "This course will provide a gentle introduction to programming using Pythonâ„¢ for highly motivated students with little or no prior experience in programming computers. The course will focus on planning and organizing programs, as well as the grammar of the Python programming language. Lectures will be interactive featuring in-class exercises with lots of support from the course staff.\nThis course is offered during the Independent Activities Period (IAP), which is a special 4-week term at MIT that runs from the first week of January until the end of the month.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 5 sessions / week for 2 weeks, 3 hours / session\n\nCalendar\n\nSES #\n\nTOPICS\n\nVariables and types\n\nFunctions, basic recursion\n\nControl flow: Branching and repetition\n\nIntroduction to objects: Strings and lists\n\nProject 1: Structuring larger programs\n\nPython modules, debugging programs\n\nIntroduction to data structures: Dictionaries\n\nFunctions as a type, anonymous functions and list comprehensions\n\nProject 2: Working in a team\n\nQuiz, wrap-up\n\nAdministrative Details\n\nGrading\n\nThis is a pass/fail course -- attend the classes, do the homework. Attendance is important; email us in advance if you have to miss a class.\n\nOptional Assignment(s)\n\nThere is an optional assignment that you can work on when you have free time, e.g. if you finish the class lab period early. This assignment is completely optional -- it was designed to give you a better intuition for programming and to help in later course 6 studies.\n\nTextbook\n\nThis class uses readings from the online textbook\nHow to Think Like a Computer Scientist\n-- it's always nice to have two perspectives on concepts. You can find this textbook\nhere\n.\n\nPython Installation\n\nYou can get the latest version\nhere\n.\n\nLinux and Mac OS X users: You should already have Python installed -- to test this, run the command\nPython\nin console mode. Note that the first line tells you the version number; you may want to upgrade your installation if you have a version earlier than 2.3.\n\nWindows users: Grab the Windows installer from the Downloads section. After installation, you can run the IDLE\n(Python GUI)\ncommand from the Start menu.",
  "files": [
    {
      "category": "Resource",
      "title": "collision.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/1780c0319d1cefe0339a511f77bec244_collision.py",
      "content": "# collision.py\n# Example solution for Lab 6, problem 1\n#\n# Aseem Kishore\n#\n# 6.189 - Intro to Python\n# IAP 2008 - Class 4\n\n# Imports should usually go at the top of a program instead of in the main code.\n\nfrom math import *\n\n# These helper functions let me \"abstract away\" the syntax of getting a ball's\n# x- and y- coordinates, or its radius. This makes my code more readable and\n# also helps prevent bugs where I use x instead of y, etc.\n\ndef get_x(ball):\nreturn ball[0]\n\ndef get_y(ball):\nreturn ball[1]\n\ndef get_r(ball):\nreturn ball[2]\n\n# I got this function from the second day of class. We've been trying to tell\n# you guys the importance of functions; here's one -- reuse. There are many\n# applications for finding the distance between two points; detecting collision\n# is one, so we can reuse the function. This is also why we don't ask for input\n# or print our result inside the function.\n\ndef distance(x1, y1, x2, y2):\nreturn sqrt((x2-x1)**2 + (y2-y1)**2)\n\n# Here is my detect collision function. Note that I'm NOT taking six variables\n# like x1, y1, r1, x2, y2, r2 -- that's the purpose of combining x, y, r into a\n# tuple, as every ball has an x, y and r.\n\ndef collision(ball1, ball2):\nd = distance(get_x(ball1), get_y(ball1), get_x(ball2), get_y(ball2))\nsum_of_radii = get_r(ball1) + get_r(ball2)\nreturn d < sum_of_radii\n\n# My test cases\n\nprint \"First test case:\",\n\na = (0, 0, 1)\nb = (3, 3, 1)\n\nif collision(a, b):\nprint \"Oops, we detected a collision!\"\nelse:\nprint \"Passed!\"\n\nprint \"Second test case:\",\n\na = (5, 5, 2)\nb = (2, 8, 3)\n\nif collision(a, b):\nprint \"Passed!\"\nelse:\nprint \"Oops, we didn't detect a collision!\""
    },
    {
      "category": "Resource",
      "title": "genetic.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/bfea0c8b6483d4fc187edd3b4c93556e_genetic.py",
      "content": "A = \"gtggcaacgtgc\"\nB = \"gtagcagcgcgc\"\nC = \"gcggcacagggt\"\nD = \"gtgacaacgtgc\"\n\ndef method1(c1, c2):\ndiscreps = 0\nfor i in range(len(c1)):\nif c1[i] != c2[i]:\ndiscreps = discreps + 1\nreturn discreps\n\ndef method2(c1, c2):\ndiscreps_a = abs(c1.count('a') - c2.count('a'))\ndiscreps_c = abs(c1.count('c') - c2.count('c'))\ndiscreps_g = abs(c1.count('g') - c2.count('g'))\ndiscreps_t = abs(c1.count('t') - c2.count('t'))\nreturn discreps_a + discreps_c + discreps_g + discreps_t\n\ndef compare(c1, c2, name1, name2):\nprint name1, \"and\", name2, \":\"\nprint \"Method 1 says there are\", method1(c1, c2), \"differences.\"\nprint \"Method 2 says there are\", method2(c1, c2), \"differences.\"\nprint\n\ncompare(A, B, \"A\", \"B\")\ncompare(A, C, \"A\", \"C\")\ncompare(A, D, \"A\", \"D\")\ncompare(B, C, \"B\", \"C\")\ncompare(B, D, \"B\", \"D\")\ncompare(C, D, \"C\", \"D\")"
    },
    {
      "category": "Resource",
      "title": "htmltext.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/dbe6614af6419849c578107771134d09_htmltext.py",
      "content": "# htmltext.py\n# An HTML parser that captures *only* the text of the HTML.\n#\n# Author: Aseem Kishore\n#\n# No license -- free to use. Just give credit where it's due please. =)\n\nfrom sgmllib import SGMLParser\nfrom string import *\n\nclass HtmlTextParser(SGMLParser):\n\n\"\"\" An HTML parser that captures *only* the text of the HTML. \"\"\"\n\n## Constructor ##\n\ndef __init__(self):\n\"\"\" Initialize a new HtmlTextParser. \"\"\"\nSGMLParser.__init__(self)\nself.text_list = []\nself.inside_unwanted_tags = 0 # how many unwanted tags we're inside\n\n## Public methods ##\n\ndef parse(self, html):\n\"\"\" Parse the given html. \"\"\"\nassert type(html) is str,\\\n\"html must be a string, \" + str(type(html)) + \" given.\"\nself.feed(html)\nself.close()\n\ndef get_text(self):\n\"\"\" Return the text that has been parsed so far. \"\"\"\nreturn join(self.text_list)\n\n## Overridden methods ##\n\ndef start_script(self, attributes):\n\"\"\" Process a <script> tag and its attributes. Only used internally. \"\"\"\nself.inside_unwanted_tags += 1\n\ndef end_script(self):\n\"\"\" End a <script> tag. Only used internally. \"\"\"\nself.inside_unwanted_tags -= 1\n\ndef start_style(self, attributes):\n\"\"\" Process a <style> tag and its attributes. Only used internally. \"\"\"\nself.inside_unwanted_tags += 1\n\ndef end_style(self):\n\"\"\" End a <style> tag. Only used internally. \"\"\"\nself.inside_unwanted_tags -= 1\n\ndef start_img(self, attributes):\n\"\"\" Process an <img> tag and its attributes. Only used internally. \"\"\"\nfor name, value in attributes:\nif name == \"alt\": # we want to capture the alt text of imgs\ndata = value.strip()\nif data != \"\":\nself.text_list.append(data)\n\ndef end_img(self):\n\"\"\" End an <img> tag. Only used internally. \"\"\"\npass # doing nothing\n\ndef handle_data(self, data):\n\"\"\" Handle the given textual data. Only used internally. \"\"\"\n# we don't want to read data inside tags like <script> and <style>\nif self.inside_unwanted_tags > 0:\nreturn\n# we're going to strip the data first of leading/trailing spaces, and\n# only add it if the result is not the empty string\ndata = data.strip()\nif data != \"\":\nself.text_list.append(data)\n\n## Testing ##\n\ndef _test(url): # the _ means private to this module -- won't get imported\n\nprint \"Processing\", url, \". . .\"\nprint\n\nsite = urlopen(url)\nhtml = site.read()\nsite.close()\n\nparser = HtmlTextParser()\nparser.parse(html)\ntext = parser.get_text()\n\nprint text\nprint\n\nreturn text\n\nif __name__ == \"__main__\": # only do this if we're not being imported\n\nfrom urllib import urlopen\n\nt1 = _test(\"http://www.mit.edu/~mihirk/6.189/\")\nt2 = _test(\"http://web.mit.edu/\")\nt3 = _test(\"http://www.google.com/\")"
    },
    {
      "category": "Resource",
      "title": "inventory_soln.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/8838b497f701e8eb6381e5580eeb0c73_inventory_soln.py",
      "content": "# inventory.py\n# Stub file for lab 10, problem 1\n#\n# 6.189 - Intro to Python\n# IAP 2008 - Class 8\n\nCHEAP = \"cheap\" # less than $20\nMODERATE = \"moderate\" # between $20 and $100\nEXPENSIVE = \"expensive\" # more than $100\n\nHAMMER = \"hammer\"\nHAMMER_PRICE = 10\nHAMMER_COUNT = 100\n\nSCREW = \"screw\"\nSCREW_PRICE = 1\nSCREW_COUNT = 1000\n\nNAIL = \"nail\"\nNAIL_PRICE = 1\nNAIL_COUNT = 1000\n\nSCREWDRIVER = \"screwdriver\"\nSCREWDRIVER_PRICE = 8\nSCREWDRIVER_COUNT = 100\n\nDRILL = \"drill\"\nDRILL_PRICE = 50\nDRILL_COUNT = 20\n\nWORKBENCH = \"workbench\"\nWORKBENCH_PRICE = 150\nWORKBENCH_COUNT = 5\n\nHANDSAW = \"handsaw\"\nHANDSAW_PRICE = 15\nHANDSAW_COUNT = 50\n\nCHAINSAW = \"chainsaw\"\nCHAINSAW_PRICE = 80\nCHAINSAW_COUNT = 30\n\n# You should put the stuff logically into this dictionary.\n# You can just put it all in right here, like shown.\n# Try to use only one *variable*, called inventory here.\n\ninventory = {\nCHEAP : {\nHAMMER : (HAMMER_PRICE, HAMMER_COUNT),\nNAIL : (NAIL_PRICE, NAIL_COUNT),\nSCREW : (SCREW_PRICE, SCREW_COUNT),\nSCREWDRIVER : (SCREWDRIVER_PRICE, SCREWDRIVER_COUNT),\nHANDSAW : (HANDSAW_PRICE, HANDSAW_COUNT)\n},\nMODERATE : {\nDRILL : (DRILL_PRICE, DRILL_COUNT),\nCHAINSAW : (CHAINSAW_PRICE, CHAINSAW_COUNT)\n},\nEXPENSIVE : {\nWORKBENCH : (WORKBENCH_PRICE, WORKBENCH_COUNT)\n}\n}\n\ndef get_items(cheapness):\n\"\"\" Return a list of (item, (price, count)) tuples that are the given\ncheapness. Note that the second element of the tuple is another tuple. \"\"\"\nreturn inventory[cheapness].items()\n\n# Testing\n\ncheap = get_items(CHEAP)\nprint type(cheap) is list\nprint len(cheap) == 5\nprint (HAMMER, (HAMMER_PRICE, HAMMER_COUNT)) in cheap\nprint (NAIL, (NAIL_PRICE, NAIL_COUNT)) in cheap\nprint (SCREW, (SCREW_PRICE, SCREW_COUNT)) in cheap\nprint (SCREWDRIVER, (SCREWDRIVER_PRICE, SCREWDRIVER_COUNT)) in cheap\nprint (HANDSAW, (HANDSAW_PRICE, HANDSAW_COUNT)) in cheap\n\nmoderate = get_items(MODERATE)\nprint type(moderate) is list\nprint len(moderate) == 2\nprint (DRILL, (DRILL_PRICE, DRILL_COUNT)) in moderate\nprint (CHAINSAW, (CHAINSAW_PRICE, CHAINSAW_COUNT)) in moderate\n\nexpensive = get_items(EXPENSIVE)\nprint type(expensive) is list\nprint len(expensive) == 1\nprint (WORKBENCH, (WORKBENCH_PRICE, WORKBENCH_COUNT)) in expensive"
    },
    {
      "category": "Resource",
      "title": "inventory.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/4e37c0f7b3fb58af3fd896e37d088b1a_inventory.py",
      "content": "# inventory.py\n# Stub file for lab 10, problem 1\n#\n# 6.189 - Intro to Python\n# IAP 2008 - Class 8\n\nCHEAP = \"cheap\" # less than $20\nMODERATE = \"moderate\" # between $20 and $100\nEXPENSIVE = \"expensive\" # more than $100\n\nHAMMER = \"hammer\"\nHAMMER_PRICE = 10\nHAMMER_COUNT = 100\n\nSCREW = \"screw\"\nSCREW_PRICE = 1\nSCREW_COUNT = 1000\n\nNAIL = \"nail\"\nNAIL_PRICE = 1\nNAIL_COUNT = 1000\n\nSCREWDRIVER = \"screwdriver\"\nSCREWDRIVER_PRICE = 8\nSCREWDRIVER_COUNT = 100\n\nDRILL = \"drill\"\nDRILL_PRICE = 50\nDRILL_COUNT = 20\n\nWORKBENCH = \"workbench\"\nWORKBENCH_PRICE = 150\nWORKBENCH_COUNT = 5\n\nHANDSAW = \"handsaw\"\nHANDSAW_PRICE = 15\nHANDSAW_COUNT = 50\n\nCHAINSAW = \"chainsaw\"\nCHAINSAW_PRICE = 80\nCHAINSAW_COUNT = 30\n\n# You should put all of the stuff above logically into this dictionary.\n# You can just put it all in right here, like shown.\n# Try to use only one *variable*, called inventory here.\n\ninventory = { # key1 : value1, note how I can continue on the next line,\n# key2 : value2, I don't need a backslash or anything.\n# key3 : value3\n}\n\ndef get_items(cheapness):\n\"\"\" Return a list of (item, (price, count) tuples that are the given\ncheapness. Note that the second element of the tuple is another tuple. \"\"\"\n# your code here\nreturn [] # delete this\n\n# Testing\n\ncheap = get_items(CHEAP)\nprint type(cheap) is list\nprint len(cheap) == 5\nprint (HAMMER, (HAMMER_PRICE, HAMMER_COUNT)) in cheap\nprint (NAIL, (NAIL_PRICE, NAIL_COUNT)) in cheap\nprint (SCREW, (SCREW_PRICE, SCREW_COUNT)) in cheap\nprint (SCREWDRIVER, (SCREWDRIVER_PRICE, SCREWDRIVER_COUNT)) in cheap\nprint (HANDSAW, (HANDSAW_PRICE, HANDSAW_COUNT)) in cheap\n\nmoderate = get_items(MODERATE)\nprint type(moderate) is list\nprint len(moderate) == 2\nprint (DRILL, (DRILL_PRICE, DRILL_COUNT)) in moderate\nprint (CHAINSAW, (CHAINSAW_PRICE, CHAINSAW_COUNT)) in moderate\n\nexpensive = get_items(EXPENSIVE)\nprint type(expensive) is list\nprint len(expensive) == 1\nprint (WORKBENCH, (WORKBENCH_PRICE, WORKBENCH_COUNT)) in expensive"
    },
    {
      "category": "Resource",
      "title": "login.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/0308ce988bb2fc2fa3ecaf2a49b6aa69_login.py",
      "content": "# login.py\n# Example solution for Lab 4, problem 1\n#\n# Aseem Kishore\n#\n# 6.189 - Intro to Python\n# IAP 2008 - Class 3\n\n# Some constants...\n\nLARGE_PRIME = 541\n_KEY = 171 # to get this number, I used the password \"solution\"\nMAX_FAILURES = 3 # stop when we hit this many failures\n\n# The encrypt function. Remember, functions shouldn't be asking for input or\n# printing their result. Any input a function needs (in this case, a string to\n# encrypt) should be passed in, and the output should be returned.\n\ndef encrypt(text):\nreturn hash(text) % LARGE_PRIME\n\n# Main program code\n\nnum_failures = 0\n\n# We'll keep looping until we hit the max number of failures...\n# We need to break out of the loop when we get it correct also, see below.\n\nwhile num_failures < MAX_FAILURES:\n\nlogin = raw_input(\"Please enter the password: \")\n\nif encrypt(login) == _KEY:\nprint \"Correct!\"\nbreak # remember, this breaks out of the current loop\nelse:\nnum_failures = num_failures + 1\nprint \"Incorrect! You have failed\", num_failures, \"times.\"\n\n# When we get here, it's either because num_failures == MAX_FAILURES, or\n# because we hit the break statement (i.e. we got the correct login), so...\n\nif num_failures >= MAX_FAILURES:\nprint \"Sorry, you have hit the maximum number of failures allowed.\""
    },
    {
      "category": "Resource",
      "title": "namesages_soln.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/2a5cd1624ce64153031b6ca7cc4b87a3_namesages_soln.py",
      "content": "# namesages.py\n# Stub file for lab 9, problem 1\n#\n# 6.189 - Intro to Python\n# IAP 2008 - Class 8\n\nNAMES = [\"Alice\", \"Bob\", \"Cathy\", \"Dan\", \"Ed\", \"Frank\",\n\"Gary\", \"Helen\", \"Irene\", \"Jack\", \"Kelly\", \"Larry\"]\nAGES = [20, 21, 18, 18, 19, 20, 20, 19, 19, 19, 22, 19]\n\n# Put code here that will combine these lists into a dictionary\n\nages_to_names = {}\n\nfor i in range(len(NAMES)):\nname = NAMES[i]\nage = AGES[i]\nif age in ages_to_names:\nages_to_names[age].append(name)\nelse:\nages_to_names[age] = [name] # the LIST containing the name\n\n# You can rename this function\n\ndef people(age):\n\"\"\" Return the names of all the people who are the given age. \"\"\"\nif age in ages_to_names:\nreturn ages_to_names[age]\nreturn []\n\n# Testing\n\nprint people(18) == [\"Cathy\", \"Dan\"]\nprint people(19) == [\"Ed\", \"Helen\", \"Irene\", \"Jack\", \"Larry\"]\nprint people(20) == [\"Alice\", \"Frank\", \"Gary\"]\nprint people(21) == [\"Bob\"]\nprint people(22) == [\"Kelly\"]\nprint people(23) == []"
    },
    {
      "category": "Resource",
      "title": "namesages.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/78d40094f2007c2c261893871dceed51_namesages.py",
      "content": "# namesages.py\n# Stub file for lab 9, problem 1\n#\n# 6.189 - Intro to Python\n# IAP 2008 - Class 8\n\nNAMES = [\"Alice\", \"Bob\", \"Cathy\", \"Dan\", \"Ed\", \"Frank\",\n\"Gary\", \"Helen\", \"Irene\", \"Jack\", \"Kelly\", \"Larry\"]\nAGES = [20, 21, 18, 18, 19, 20, 20, 19, 19, 19, 22, 19]\n\n# Put code here that will combine these lists into a dictionary\n\n# You can rename this function\n\ndef people(age):\n\"\"\" Return the names of all the people who are the given age. \"\"\"\n\n# your code here\npass # delete this line when you write your code\n\n# Testing\n\nprint people(18) == [\"Cathy\", \"Dan\"]\nprint people(19) == [\"Ed\", \"Helen\", \"Irene\", \"Jack\", \"Larry\"]\nprint people(20) == [\"Alice\", \"Frank\", \"Gary\"]\nprint people(21) == [\"Bob\"]\nprint people(22) == [\"Kelly\"]\nprint people(23) == []"
    },
    {
      "category": "Resource",
      "title": "operator.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/6a1d24754b9b468c5dd9fdb42b56a16e_operator.pdf",
      "content": "Operator Cheat Sheet\nNumeric Operators\nOperator\nOperand 1 type\nOperand 2 type\nReturn type\nExamples\n+ (addition)\nint/float\nint/float\nint/float\n4 + 7 (11), 2 + 3.5 (5.5)\n- (subtraction)\nint/float\nint/float\nint/float\n12 - 15 (-3), 4 - 8.0 (-4.0)\n* (multiplication)\nint/float\nint/float\nint/float\n5 * 8 (40), 3.5 * 2 (7.0)\n/ (integer division)\nint\nint\nint\n12 / 4 (3), 8 / 9 (0)\n/ (division)\nint/float\nint/float\nfloat\n1 / 2.0 (0.5), 2.0 / 8 (0.25)\n(at least one operand must be a float)\n% (modulo)\nint\nint\nint\n100 % 9 (1), 2 % 5 (2)\n** (exponentiation)\nint/float\nint/float\nint/float\n2 ** 3 (8), 4 ** 0.5 (2)\nComparison Operators\nOperator\nOperand 1 type\nOperand 2 type\nReturn type\nExamples\n< (less than)\nint/float\nint/float\nboolean\n4 < 5 (True), -5.2 < -7.5 (False)\n> (greater than)\nint/float\nint/float\nboolean\n4 > 5 (False), -5.2 > -7.5 (True)\n<= (less or equal)\nint/float\nint/float\nboolean\n12 <= 12 (True), 18 <= 0 (False)\n>= (greater or equal)\nint/float\nint/float\nboolean\n0 >= 0 (True), 18 >= 0 (True)\nEquality Operators\nOperator\nOperand 1 type\nOperand 2 type\nReturn type\nExamples\n== (equal)\nanything\nanything\nboolean\n5 == 5 (True), \"sdf\" == \"s df\" (False)\n!= (not equal)\nanything\nanything\nboolean\n5 != \"5\" (True), \"sdf\" != \"sdf\" (False)\nLogical Operators\nOperator\nOperand 1 type\nOperand 2 type\nReturn type\nExamples\nand\nboolean\nboolean\nboolean\nTrue and True (true)\nor\nboolean\nboolean\nboolean\nTrue or False (true)\nnot\nboolean\nboolean\nnot True (false)"
    },
    {
      "category": "Exam",
      "title": "exam1_soln.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/240957e6932e85344f5894f3a9e8040a_exam1_soln.pdf",
      "content": "Page 1\n6.189 Exam\nAdministrivia\nName:\nMIT ID:\nInstructions:\n1. Err..complete the questions :). Warning: they do increase in difficulty.\n2. No calculators, no laptops, etc.\n3. When we ask for output, you DON'T have to write the spaces/newlines in.\nProgram Text:\nprint \"X\",\nprint \"X\",\nOutput:\nXX\nDay 1: Variables, Operators, and Expressions\nTips/Notes:\nVariables are typed (this is a string, that's an integer, etc.) type(x) is a function that returns the type\nof its parameter.\nYou can convert information from one type to another using the built-in conversion functions: int(x),\nstr(x), float(x), bool(x). These tend to fail for conversions that don't make sense, e.g. int(\"hello\")\ncrashes.\nEvery variable you create should have a meaning. Give your variables names that match their\nmeaning: don't just name all your variables a, b, c (exception: if you're writing a quiz to test your\nstudents, only use names like a, b, c)\nProblem 1: Neophyte (hey, this was just 4 days ago)\nWhat is the output of the following code?\nProgram Text:\na = 5\nb = a + 7\na = 10\nprint b\nSession 5\n\nPage 2\nOutput:\nProblem 2: Type Theory\nWhat is the type of each of the following expressions (within the type function)?\nProgram Text:\nprint type(5)\nProgram Text:\nprint type(\"abc\")\nProgram Text:\nprint type(True)\nProgram Text:\nprint type(5.5)\nProgram Text:\nprint type(12/27)\nProgram Text:\nprint type(2.0/1)\nProgram Text:\nprint type(12 ** 3)\nProgram Text:\nprint type(5 == \"5\")\nProgram Text:\nOutput:\nint\nstring\nOutput:\nOutput:\nOutput:\nboolean\nfloat\nint\nOutput:\nOutput:\nOutput:\nfloat\nint\nboolean\nOutput:\na = str((-4 + abs(-5) / 2 ** 3) + 321 - ((64 / 16) % 4) ** 2)\nprint type(a)\nOutput:\nstring\n\nPage 3\nOutput:\nTrue1\n0.0\nOutput:\nOutput:\n0.5\nOutput:\nOutput:\nfalse\nfalse\nOutput:\nfalse\n53true\nOutput:\nProblem 3: Expressive Expressions\nWhat is the output of the following code?\nProgram Text:\nprint 5 == 5.0\nProgram Text:\nprint float(1/2)\nProgram Text:\nprint float(1)/2\nProgram Text:\nprint 5 == \"5\"\nProgram Text:\nprint \"sdf\" != \"sdf\"\nProgram Text:\nprint True and (False or not True)\nProgram Text:\nprint str(53) + str(True)\nProgram Text:\na = 20\nprint 15-(a-15), \",\",\na = 10\nprint 15-(a-15),\nOutput:\n10,20\nDay 3: Conditionals\nTips/Notes:\nThe if statement executes a sequence of statements only if some condition is true. This condition\ncan be anything.\nScheme (the initial language taught at MIT before Python) took type to an extreme. 5.0 and 5 were not\nconsidered equal because one was an integer and the other was a float. You weren't even allowed to do (4 + 6.0.)\nPython is more rational - it treats the two values as equal.\n\nPage 4\nelif / else is optional. Remember that at most one block of statements is executed. else occurs if\nnone of the above conditions are satisfied.\nProblem 4: Basics\nConsider the following code\nProgram Text:\na = ?\nif a > 10 and a % 6 = 3:\nprint \"a\",\nelif a > 10 and a < 20:\nprint \"b\",\nelse:\nprint \"c\",\nGive a value for a that would produce the following outputs. If no value of a would produce that output,\nwrite none.\nValue of a:\nOutput:\nnone\na b\nValue of a:\nOutput:\n15,21,27,...\na\nValue of a:\nOutput:\n11,12,...,19 (except 15)\nb\nValue of a:\nOutput:\nAny other\nc\nValue of a:\nOutput:\nnone\nvictory is mine!\nProblem 5: Trickier Duet\nRemoved due to time constraints.\n\nPage 5\nDay 3: While loop\nTips/Notes:\nA while loop allows us to repeat a sequence of statements many times.\nYou can use almost anything for the condition. Not every while loop has to be a simple counter.\nProblem 6: This is not a loopy title\nWhat is the output of the following code? If the code does not terminate, write error.\nProgram Text:\na = 5\nwhile a < 8:\nprint \"X\",\nOutput:\nProgram Text:\nLoops forever\na = -1\nwhile a < 3:\nprint \"X\",\na = a + 1\nOutput:\nProgram Text:\nXXXX\na = 1\nwhile a % 7 != 0:\nif a % 2 == 0:\nprint \"O\"\nif a == 2:\nprint \"X\"\na = a + 1\nOutput:\nOXOO\n\nPage 6\nProblem 7: Subtle variants\nWe're going to show you variants of the same code. Write the output of each code snippet.\nProgram Text:\nkeep_going = True\na = 0\nb = 0\nwhile keep_going:\nprint \"O\"\na = a + 5\nb = b + 7\nif a + b >= 24:\nkeep_going = False\nOutput:\nOO\nWe rearranged the code within the while loop here.\nProgram Text:\nkeep_going = True\na = 0\nb = 0\nwhile keep_going:\nprint \"O\"\nif a + b >= 24:\nkeep_going = False\na = a + 5\nb = b + 7\nOutput:\nOOO\nThe remaining two variants are duplicates of the first two with >= replaced by >.\nProgram Text:\nkeep_going = True\na = 0\nb = 0\nwhile keep_going:\nprint \"O\"\na = a + 5\nb = b + 7\nif a + b > 24:\nkeep_going = False\n\nPage 7\nOutput:\nProgram Text:\nkeep_going = True\na = 0\nb = 0\nwhile keep_going:\nprint \"O\"\nif a + b > 24:\nkeep_going = False\na = a + 5\nb = b + 7\nOutput:\nOOO\nOOOO\nDay 3: Nested loops\nTips/Notes:\nThis isn't anything new, but we can put loops inside other loops. We can also do fairly crazy things:\nnest a while in an if in a while in another while.\nThe break keyword exits the innermost loop.\nProblem 8: Freebie!\nWhat is the output of the following code? If the code does not terminate, write error.\nProgram Text:\na = 0\nwhile a < 3:\nwhile True:\nprint \"X\",\nbreak\nprint \"O\",\na = a + 1\nOutput:\nXOXOXO\n\nPage 8\nProblem 9: (insert evil laugh) ..is what I'd like to say. Still not that bad, though\nWhat is the output of the following code? If the code does not terminate, write error.\nProgram Text:\na = 1\nwhile a < 3:\nwhile a < 3:\nprint \"O\",\na = a + 1\nOutput:\nLoops forever\nProgram Text:\na = 1\nwhile a < 3:\nif a % 2 == 0:\nb = 1\nwhile b < 3:\nprint \"X\",\nb = b + 1\nprint \"O\",\na = a + 1\nOutput:\nOXXO\nExtra Credit (mainly due to time constraints.) Solve this if you finish early!:\nProgram Text:\na = 1\nwhile a < 3:\nb = 1\nwhile b < 3:\nif a == 2:\nprint \"X\",\nprint \"O\",\nb = b + 1\nprint \"O\",\nOutput:\nLoops forever (due to typo.) Fixed, it would be\noooxoxoo\n\nPage 9\nDay 2: Functions\nTips/Notes:\nA function is just a named sequence of statements. We usually define functions at the beginning of\ncode - definitions just associate the name with the sequence of statements.\nFunctions can take parameters (within the parenthesis suffix) and can return information via return\nreturn is NOT a function. Like if, while, .. its a keyword: a basic command of the language.\nYou can find out more information about functions using the help(x) function, e.g. help(sqrt).\nRemember to write from math import * first.\nProblem 10: Sanity Check\nWhat is the output of the following code? If the code does not terminate, write error.\nProgram Text:\ndef f(a):\na = a + 5\nreturn a\nb = 0\nf(b)\nprint b, \",\",\nb = f(b)\nprint b\nOutput:\n0,5\nProblem 11: Last but not least (somewhere in the middle)\nYou know that functions can call other functions, right? Here's an interesting fact - functions can call\nthemselves!\nProgram Text:\ndef f(x):\nprint \"X\",\nif x <= 1:\nreturn 1\nelse:\nreturn x+f(x-1)\n\nPage 10\nFill out the following table for the return value and output of each function call.\nFunction call:\nReturn value:\nOutput:\nf(1)\nX\nFunction call:\nf(2)\nReturn value:\nOutput:\nXX\nFunction call:\nf(3)\nReturn value:\nOutput:\nXXX\nFunction call:\nf(4)\nReturn value:\nOutput:\nXXXX\n\nPage 11\nExtra stuff\nIf you were reasonably comfortable with this test, here is some extra stuff that you might find useful\n(you can rip this page out if you like.)\nDon't forget about using # to write notes/comments in your code!\nInstead of always writing a = a + 5 or a = a / 7, you can use the shorthand a += 5 and a /= 7. Be\ncareful not to get confused by this notation:\nProgram Text:\n\na = 5\nb = a\na += 3\nprint b #still 5\nString stuff\n- You can use either a single quotation mark (') or a double quotation mark for strings. The only\ndifference is either one can contain the other ('This is a \"test\"' is valid, \"This is a 'test'\" is valid,\n\"This is a \"test\"\" is not valid.)\n- You can use \"\\n\" to insert a newline (Enter key) in a string.\n- You can define multi-line strings using the triple-quotation \"\"\" operator.\nProgram Text:\n\nYou can write a description of a function by putting a string as the first line of the function.\nProgram Text:\n\nprint \"\"\"This is a sentence.\\nThis sentence is on the second line.\nThis sentence is on the third line.\nThis is on the fourth.\"\"\"\n\nTry calling help(hypo) on the function you just wrote!\nprint is a keyword, not a function (like if, while, return.) There's no particularly good reason why it's\na keyword - future versions of Python are changing it into a function.\ndef hypo(a,b):\n\"\"\"This function returns the length of the hypotenuse defined by\nthe right triangle with side lengths a,b\"\"\"\nreturn sqrt(a*a + b*b)"
    },
    {
      "category": "Resource",
      "title": "handout1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/87f5c450eb6ae3779b2b0198fedafbea_handout1.pdf",
      "content": "Handout 1 - Loops\n\n[...]\n\n- Don't understand loops (or at least while, or for)\n\nI'll review this at the beginning of the class, but quick reference: we use loops when we want to keep\nrepeating a set of statements.\n\nIf we know exactly how many times we'll be repeating it, we could just copy/paste the code that many\ntimes. We could even put the code into a function and just call that function that many times. Even in this\ncase, though, this is not good practice, and it's even impractical -- what if you have to call the function 100\ntimes? 1000? etc.\n\nSo that's why there is the concept of looping. There are two ways to loop that we've taught you: while and\nfor loops (although there was no need to use for in either of the lab problems yesterday).\n\nThe syntax is:\n\nwhile [expression that evaluates True or False]:\n[statements to be executed]\n\nfor [variable] in range([start], stop, [step] ):\n[statements to be executed]\n\nFor while, the computer first evaluates the expression. If it's true, it executes the statements. Then it\nreturns to the expression and evaluates it again -- if it's true again, it executes the statements again. And\nit keeps checking like this, and repeating as long as the expression is true.\n\nI mentioned this in office hours, it might be useful to think like this: if you think in terms of \"until\", e.g. \"play\nthe game until there are no stones\", then we can always write that in terms of \"while\" by just negating our\nexpression, e.g. \"play the game WHILE there ARE stones\".\n\nThe for and range statements are confusing to a lot of people. Play around with range in the shell to get\nan idea for what start, stop and step mean, e.g. range(1, 11, 2) returns the numbers 1, 3, 5, 7, 9.\nRemember that you never include the stop number. Once you understand range, then for just means\nthat through each iteration of the loop (\"iteration\" means a time that you're executing the statements\ninside), the variable after for is assigned to the next number in that range.\n\nKeep playing around with these, it'll start to make sense.\n\n[...]"
    },
    {
      "category": "Resource",
      "title": "notes1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/120773df723c51370dcc2f94aaf55435_notes1.pdf",
      "content": "6.189: Introduction to Programming in Python\nSession 1\nCourse Syllabus\n1. Administrivia. Variables and Types.\n2. Functions. Basic Recursion.\n3. Control Flow: Branching and Rep tition.\ne\n4. Introduction to Objects: Strings and Lists.\n5. Project 1: Structuring Larger Programs.\n6. Python Modules. Debugging Programs.\n7. Introduction to Data Structures: Dictionaries.\n8. Functions as a Type, Anonymous Functions and List Comprehensions\n9. Project 2: Working in a Team.\n10. Quiz. Wrap-up.\nAdministrivia\n1. Grading. Well, it's a pass/fail course - attend the classes, do the homework. Attendance is important:\nemail us in advance if you have to miss a class.\n2. Optional Assignment(s). There's an optional assignment that you can work on when you have free\ntime, e.g. if you finish the class lab period early. This assignment is completely optional - it was designed\nto give you a better intuition for programming and to help in later course 6 studies.\n3. Textbook. This class uses readings from the online textbook How to Think Like a Computer Scientist -\nits always nice to have two perspectives on concepts. You can find this textbook at the following link:\nhttp://www.openbookproject.net/thinkcs/python/english2e/index.xhtml\nNotes/Homework\n1. Install Python. You can get the latest version at www.python.org.\nLinux and OS X users: You should already have Python installed - to test this, run the command\npython in console mode. Note that the first line tells you the version number: you may want to\nupgrade your installation if you have a version earlier than 2.3.\nWindows users: Grab the windows installer from the Downloads section. After installation, you\ncan run the IDLE (Python GUI) command from the Start menu.\n\n2. Reading. Read 1.1-1.2, 1.8-1.9, and chapter 2 from the textbook.\n3. Writing Programs. Recall that a program is just a set of instructions for the computer to execute. Let's\nstart with a basic command:\nprint x: Prints the value of the expression x, followed by a newline.\nProgram Text:\nprint \"Hello World!\"\nprint \"How are you?\"\nOutput:\nHello World!\nHow are you?\n(The compiler needs those quotation marks to identify strings - we'll talk about this later.) Don't worry,\nwe'll be adding many more interesting commands later! For now, though, we'll use this to have you\nbecome familiar with the administrative details of writing a program.\nWrite a program that, when run, prints out a tic-tac-toe board.\nLinux and OS X users: To write your program, just create a text file with the contents of the\nprogram text (e.g. the program text above.) To run your program (pretend its named\nfirst_print.py), use the command python first_print.py at the shell.\nWindows users: The best way to program in Windows is using the IDLE GUI (from the shortcut\nabove.) To create a new program, run the command File->New Window (CTRL+N) - this will open\nup a blank editing window. In general, save your program regularly; after saving, you can hit F5 to\nrun your program and see the output.\nMake sure to write your program using the computer at least once! The purpose of this question is to\nmake sure you know how to write programs using your computing environment; many students in\nintroductory courses experience trouble with assignments not because they have trouble with the\nmaterial but because of some weird environment quirk.\nYou can write the answer to the question in the box below (I know its hard to show spaces while writing\n- just do your best)\nProgram Text:\n\n-----\n-----\nExpected Output:\n| |\n| |\n| |\n4. Interpreter Mode. Python has a write-as-you-go mode that's useful when testing small snippets of\ncode. You can access this by running the command python at the shell (for OS X and Linux) or by starting\nthe IDLE GUI (for Windows) - you should see a >>> prompt. Try typing a print command and watch what\nhappens.\nYou'll find that its much more convenient to solve a lot of the homework problems using the interpreter.\nWhen you want to write an actual, self-contained program (e.g. writing the game tic-tac-toe), follow the\ninstructions in section 3 above.\n5. Variables. Put simply, variables are containers for storing information. For example:\nProgram Text:\na = \"Hello World!\"\nprint a\nOutput:\nHello World!\nThe = sign is an assignment operator which says: assign the value \"Hello World!\" to the variable a.\nProgram Text:\na = \"Hello World!\"\na = \"and goodbye..\"\nprint a\nOutput:\nand goodbye..\nTaking this second example, the value of a after executing the first line above is \"Hello World!\", and\nafter the second line its \"and goodbye..\" (which is what gets printed)\n\nIn Python, variables are designed to hold specific types of information. For example, after the first\ncommand above is executed, the variable a is associated with the string type. There are several types of\ninformation that can be stored:\nBoolean. Variables of this type can be either True or False.\nInteger. An integer is a number without a fractional part, e.g. -4, 5, 0, -3.\nFloat. Any rational number, e.g. 3.432. We won't worry about floats for today.\nString. Any sequence of characters. We'll get more in-depth with strings later in the week.\nPython (and many other languages) are zealous about type information. The string \"5\" and integer 5 are\ncompletely different entities to Python, despite their similar appearance. You'll see the importance of\nthis in the next section.\nWrite a program that stores the value 5 in a variable a and prints out the value of a, then stores the\nvalue 7 in a and prints out the value of a (4 lines.)\nProgram Text:\nExpected Output:\n6. Operators. Python has the ability to be used as a cheap, 5-dollar calculator. In particular, it supports\nbasic mathematical operators: +, -, *, /.\nProgram Text:\na = 5 + 7\nprint a\nOutput:\nVariables can be used too.\nProgram Text:\na = 5\nb = a + 7\nprint b\n\nOutput:\nExpressions can get fairly complex.\nProgram Text:\na = (3+4+21) / 7\nb = (9*4) / (2+1) - 6\nprint (a*b)-(a+b)\nOutput:\nThese operators work on numbers. Type information is important - the following expressions would\nresult in an error.\n\"Hello\" / 123\n\"Hi\" + 5\n\"5\" + 7\nThe last one is especially important! Note that Python just sees that 5 as a string - it has no concept of it\npossibly being a number.\nSome of the operators that Python includes are\nAddition, Subtraction, Multiplication. a+b, a-b, and a*b respectively.\nInteger Division. a/b. Note that when division is performed with two integers, only the quotient\nis returned (the remainder is ignored.) Try typing print 13/6 into the interpreter\nExponentiation (ab). a ** b.\nOperators are evaluated using the standard order of operations. You can use parentheses to force\ncertain operators to be evaluated first.\nLet's also introduce one string operation.\nConcatenation. a+b. Combines two strings into one. \"Hel\" + \"lo\" would yield \"Hello\"\nAnother example of type coming into play! When Python sees a + b, it checks to see what type a and b\nare. If they are both strings then it concatenates the two; if they are both integers it adds them; if one is\na string and the other is an integer, it returns an error.\nWrite the output of the following lines of code (if an error would result, write error):\n\nprint 13 + 6\nOutput: _______________________________________\nprint 2 ** 3\nOutput: _______________________________________\nprint 2 * (1 + 3)\nOutput: _______________________________________\nprint 8 / 9\nOutput: _______________________________________\nprint \"13\" + \"6\"\nOutput: _______________________________________\nprint \"13\" + 6\nOutput: _______________________________________\n7. Review. Here are the important concepts covered today.\nWhat is a program? How does one write them.\nUsing the interpreter mode.\nVariables: containers for storing information. Variables are typed - each variable only holds\ncertain types of data (one might be able to store strings, another might be able to store numbers,\netc.)\nOperators: +, -, *, /, **, and parentheses."
    },
    {
      "category": "Resource",
      "title": "handout2.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/f14cc25f40fd15ab9bda49280569f69c_handout2.pdf",
      "content": "Handout 2 - Functions, Lists, For Loops and Tuples\n\n[...]\n\nFunctions -- parameters/arguments, \"calling\" functions, return values, etc.\n\nPlease make sure you understand this example:\n\ndef square(x):\nreturn x * x;\n\nThe x in parentheses is the input to my function. We call this a parameter or argument. We say we pass\nx as a parameter/argument to the function.\n\nWe use \"return\" whenever we want the function to evaluate to something. When we call something like\nsqrt(4), we expect it to evaluate to a number, in this case 2. Similarly, when we call encrypt(\"password\") in\nthe login program, we expect it to evaluate to something, in this case a number, so the function has to\nreturn something.\n\nFinally, this won't work:\n\nx = sqrt + 4\n\nWhy? You're trying to add a function to something, you can't do that. This is the difference between\nsimply referring to a function, and calling the function. To call a function, you always need to include the\nparentheses and give it input. It is only when you call a function that it gets evaluated.\n\nA lot of people make repeated mistakes of not calling their functions and getting errors. Make sure you're\ncalling your functions.\n\nCommon mistakes with and questions about lists.\n\nVariables are typed, right? A variable can be a string, an int, etc. Similarly, a variable can be a list. The\npoint of a list is to store a dynamic/indefinite number of things. A list is always written as stuff inside [ ]\nsquare brackets.\n\nL1 = ['A', 'B', 'C']\nL2 = [ ]\n\nWe can find the length of a list by doing len(L1)or len(L2) -- the first is 3 and the second is 0. But here's\nthe more important point: just like you can do:\n\nx = 10\nprint x <-- prints 10\nx = 5\nprint x <-- prints 5\n\nYou can also do the same thing with the individual elements in a list. Why? Because the individual\n\nelements are themselves variables. The list is just a way of tying all the variables together.\n\nWe access (read or write) these variables by using indices (plural of index) -- each element is numbered,\nstarting from 0. Remember, the first element is at index 0, second is at index 1, etc. This means that\nlen(L) is never a valid index. So a list with 5 elements does not have an element at index 5.\n\nWhen we refer to an element in list L at index i, we say it's L sub i, written as L[i]. Since this is a variable,\nwe can do the same thing:\n\nL[i] = 10 <-- assuming i is a valid index, i.e. from 0 up to (but not including) len(L)\nprint L[i] <-- prints 10\nL[i] = 5\nprint L[i] <-- prints 5\n\nThis is the way we change elements in a list. We can also add elements to a list by using L.append(x).\nThis adds the element to the end.\n\nL = [] <-- empty list\nL.append(10) <-- L is now [10]\nL.append(20) <-- L is now [10, 20]\n\nFinally, we can delete elements in a list by using the del keyword:\n\nL = ['A', 'B', 'C', 'D']\nL[2] <-- evaluates to 'C'\ndel L[2]\nL[2] <-- now evaluates to 'D'\n\nRemember that because the length of the list has changed, the indices have also changed -- everything\nto the right of the deleted element is shifted over to the left. So be careful -- L[3] was valid, but no longer\nis.\n\nOh, one last thing -- we can check whether an element is in a list really simply with the in keyword.\nSomething like 'A' in ['A', 'B'] returns True, but 'C' in ['A', 'B'] returns False. This is NOT to be confused\nwith the in that's part of for ... in ... as we'll see below.\n\nIf there is anything about lists above you don't understand, please make sure to read the textbook\n(chapter 9) and look over the labs.\n\nFor statements -- when to use range, when not to, etc.\n\nI think everyone understands while loops for the most part:\n\ni = 1\nwhile i <= 10:\nprint i,\ni = i + 1\n\nThis will print \"1 2 3 4 5 6 7 8 9 10\", easy. Now I'm going to make a subtle change:\n\ni = 0\nwhile i < 10:\nprint i,\n\ni = i + 1\n\nThis will now print \"0 1 2 3 4 5 6 7 8 9\". Make sure you understand the difference and are careful to look\nfor these things.\n\nOkay, so now for loops are another type of loop, and here's how they work. A lot of people misunderstand\nthis:\n\nfor [variable] in [something that evaluates to a LIST!!!]:\n[statements]\n\nPlease -- whenever you're confused with for statements, refer to this above template!! You must ALWAYS\nhave something that evaluates to a list. This is NOT legal:\n\nfor i in len(L):\n...\n\nWhy? What is len(L)? It's a number. What's it's type? int. What type does it need to be? list.\n\nOkay. Given that syntax, the for loop will execute [statements] some number of times, call it N. What is\nN? N is equal to the length of the list. And on each iteration (\"iteration\" means step of the loop), it will\nset [variable] to be an element in the list. The first iteration, [variable] will be the first element in the list.\nThe second iteration, the second element. And so on.\n\nSo when I say:\n\nL = ['W', 'X', 'Y', 'Z']\nfor holymoly in L:\nprint holymoly,\n\nWhat should it print? It should print \"W X Y Z\". It will NOT print \"0 1 2 3\". DON'T ASSUME that just\nbecause it's a for loop, it must be numbers, or it must be index values if we're doing a list. Stick to the\nabove definition!!\n\nNow how about range? This is extremely important -- many of you are completely missing this: range is\na function that returns a list. What does that mean? That means whenever you put range(...) , that\nexpression will evaluate to a list. Understand?\n\nrange(5) evaluates to a list that looks like this: [0, 1, 2, 3, 4]\nrange(0, 5) evaluates to the same list.\nrange(1, 5) evaluates to this list: [1, 2, 3, 4]\nrange(1, 10, 3) evaluates to this list: [1, 4, 7]\nrange(1, 10, 4) evaluates to this list: [1, 5, 9]\n\nIf L = [\"A\", \"B\", \"C\", \"D\", \"E\"], then:\nrange(len(L)) evaluates to this list: [0, 1, 2, 3, 4]\nrange(0, len(L)) evaluates to the same list.\nrange(1, len(L)) evaluates to this list: [1, 2, 3, 4]\nand so on.\n\nMake sure you understand these examples . So what will this do?\n\nfor i in range(1, 7):\nprint i,\n\nIt will print \"1 2 3 4 5 6\". Now, a lot of you make this mistake over and over:\n\nfor i in range(1, 7):\nprint i,\ni = i + 1\n\nWhy is the \"i = i + 1\" unnecessary? Because every time the [statements] (see template above) are\nfinished executing, the computer assigns [variable] to the next element in the LIST. Let's look at this\nexample:\n\nFirst, i becomes 1, because it's the first element in range(1, 7).\nWe print i (1), then we set i to i+1 (2).\nNext, i becomes 2, because it's the second element in range(1, 7).\n\nDo you see why the \"i = i + 1\" is unnecessary? Don't write it in your programs!! It might not cause a\nproblem in this snippet, but it can easily cause bugs other times. Here's an example:\n\nNAMES = [\"Alice\", \"Bob\", \"Cathy\", \"Doug\"]\n\nfor i in range(len(NAMES )):\nprint \"Hello\", NAMES [i]\ni = i + 1\n\nprint \"We're out of names!\"\nprint \"The last name we saw was\", NAMES[i]\n\nThat mistake now crashes our program at the end. Make sure you see and understand why.\n\nSo, if you want to iterate over numbers, then use range. If you want to iterate over the elements in a list\ndirectly, don't use range. Compare:\n\nfor i in range(len(L)) <-- i will now be the indexes of L, i.e. from 0 up to (but not including) len(L)\nfor i in L <-- i will now instead be L[0], then L[1], then... all the way to the last element\n\nMake sure you understand this!!\n\nWhy use tuples? How are strings like tuples?\n\nTuples are immutable variations of lists. By immutable, we mean that they cannot be changed:\n\n- can't be appended to\n- can't change elements, i.e. re-assign their values\n- can't delete elements\n\nOnce a tuple is created, it's final. So, it almost never makes sense to create an empty tuple. We create\nempty lists often when we don't know how long the list is going to be, so we create an empty list and keep\nappending to it for as long as we need to. But a tuple, if you create an empty tuple, it's useless.\n\nTuples are things in ( ) parentheses. However, we still index them with [ ] square brackets.\n\na = ('A', 'B', 'C')\na[1] <-- B\n\na(1) <-- error, Python thinks a is a function, and the function a doesn't exist. You'll get an error that says\nsomething like \"a is not callable\". Why? Because to be \"callable\" means you're a function -- we can call\nyou by putting parentheses.\n\nSo why do we use tuples? The answers aren't going to satisfy you guys yet... it's something you'll come to\nunderstand as you study more advanced topics, but it has to do with safety and security.\n\nSafety: in essence, everyone makes mistakes when they write programs, because we're all human.\nThese mistakes are bugs. When a program freezes or crashes, that's a bug, caused by some mistake in\nsome code somewhere. Bugs are inevitable, but we can use good programming practice to prevent as\nmany of them as we can.\n\nNow, how do tuples help? Well, let's say we're working with points. We're repeatedly calling functions,\nsending over points. Our points are 2D, they are (x,y) coordinates. All points should thus always have\nexactly 2 variables. By using a tuple instead of a list, the computer enforces this. If we used a list, we may\nhave a valid point that becomes invalid when we accidentally add an element, or remove an element. By\nusing a tuple, the computer will give us an error right away, letting us find exactly where we made the\nmistake, rather than letting it go unnoticed until it crashes the system later, when we have no idea where\nwe made the mistake.\n\nFurthermore, imagine that the points represent something. Let's say they represent the shape of a wing\nyour company has designed that's perfectly more aerodynamic. Now, you write a program that\nexperiments around with these points to try to come up with something better. If the points were mutable,\nyou might accidentally make the mistake of changing the points themselves.... let's say the wing tip\nmoves up by 2 inches and over by 3 inches. etc. If they're tuples, the computer enforces that you don't\nchange the actual points themselves -- you can copy the points and experiment with the copies, but you\ncan't change the original points.\n\nThis is even more important when you realize that almost every piece of code interacts with someone\nwho didn't write that code. If I write a function that returns a list of 10 numbers that i use for my encryption\nalgorithm, I don't want the person who calls that function to accidentally delete one of those numbers or\nchange one of them. So I send it as a tuple -- this guarantees that they can't change it. They can again\nsee it, copy them, whatever, but they can't change MY numbers.\n\nOkay, so strings as tuples. Careful -- I didn't mean that strings ARE actually tuples, I said they are very\nsimilar to tuples.\n\nWhat are tuples? They are an immutable collection of elements. Can't be deleted, added to, or changed.\nStrings are the same.\n\na = \"hello\"\nlen(a) <-- evaluates to 5\na[4] <-- evaluates to \"o\"\na.append(\"w\") <-- error, no append operation\na[4] = \"n\" <-- error, assignment not supported\ndel a[4] <-- error, deletion not supported\n\nI'm not sure how else to explain this. Take a look at the pig latin solution to see exactly how to work with\nstrings when you know they're indexable but immutable.\n\n[...]"
    },
    {
      "category": "Resource",
      "title": "handout3.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/351789772d3cd3ecabb53b4c56f81d64_handout3.pdf",
      "content": "Handout 3 - Objects\n\n[...]\n\nAssociate these words together:\n\n- variable\n- value\n- lookup table\n- assignment (the = operator)\n\ni.e. \"assigning a variable changes the value of the variable in the lookup table.\"\n\nAnd associate these words together:\n\n- object\n- memory address / id\n- heap\n- modification (through member functions mostly, and some operators, e.g. L[0] = 2)\n\ni.e. \"modifying an object changes the actual object in the heap.\"\n\nThe lookup table basically has two columns: one for the variable name, and one for the variable value.\nVariables can have two types of values:\n\n- primitive types: these are numbers (ints, floats) and booleans. We will not consider these as objects.\n- reference types: these are pointers to objects (lists, tuples, strings and more) in the heap. (precisely,\nthey are the memory addresses of the objects they point to.)\n\nWhen we say x = 5, the value of the variable x is a primitive (the number 5). When we say y = \"hello\", the\nvalue of the variable y is a reference, to an object in the heap (the string \"hello\").\n\nAliasing occurs when multiple variables point to the same object:\n\na = [1, 2, 3] <-- a is a pointer to a list object\nb = a <-- b is a pointer to the same list object that a points to\nc = a <-- same with c\nd = b <-- same with d\n\nIn the above example, we aliased manually/explicitly. So if we modified a (e.g. by calling append), we\nwould see the change in b, c and d.\n\nAliasing can also occur automatically, in the case of strings:\n\na = \"hello\" <-- all four of these have the same id\nb = \"hello\"\nc = \"hello\"\n\nd = \"hello\"\n\nSo even though we wrote \"hello\" four different times, Python automatically aliased all of them.\n\nAs pointed out in class, I was wrong in the notes for Lab 7 -- tuples do NOT automatically alias. If you did\nthe above example with (1, 2, 3) instead of \"hello\", you would indeed have four different objects. My\nmistake.\n\nScope refers to the frame you're looking at in the stack diagram. When inside a function, you're in a local\nscope, meaning any variables you create will only live inside the function -- they're local to the function.\n\nHowever, remember that variables can be references/pointers to objects in the heap, so if a local variable\nis pointing to the same object as a variable outside of the function, the variable outside of the function will\nstill see any modifications to the object.\n\nMake sure to review problem 3 of lab 7, all the subtle changes to the functions and understand why they\nhappen. Draw stack diagrams to help you. Keep considering whether a statement is an assignment (that\nchanges a variable) or a modification (that changes an object).\n\n[...]"
    },
    {
      "category": "Resource",
      "title": "handout4.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/4f9355b3f8f254d72109cf820629d6cc_handout4.pdf",
      "content": "Handout 4 - Dictionaries and Web Indexer Part 1\n\n[...]\n\n- Dictionaries are a table or map of key-value pairs. We say that each key maps to its value.\n\n- Whereas lists are indexed by their positions, e.g. L[0], L[1], L[2], ..., dictionaries are indexed by their\nkeys, i.e. D[key] returns the value mapped to by key.\n\n- If I have a sequence of 100 elements, let's say they're the top 100 baseball players today, a list is really\nuseful because I can quickly and easily access an element if I know its position. So if I want the 7th best\nbaseball player, it'll be something like players[i].\n\nDictionaries are useful when the order doesn't matter and there's no notion of position. In other words,\nwe wouldn't use a dictionary to store the top 100 baseball players, but we'd use a dictionary to store\nwhich players play for which teams. So if I know a team, the dictionary will let me quickly and easily\naccess the players on that team.\n\n- The general way to use dictionaries when solving a problem is to ask:\n\n1. What do I know? and\n2. What do I *want* to know?\n\nThe keys in your dictionary should be based on your answer to number 1, and the values should be the\nanswer to number 2.\n\nIn the names-ages example, we knew the age we cared about, and we wanted to know who all had that\nage. So the dictionary's keys were the various ages, and the values were a list of names.\n\n- On that note, we often use lists as values because we have no other way of saying \"this key maps to\nmultiple values\". So in the names-ages, example, we had multiple people with the age 20, but we can't\nkeep multiple key-value entries with the same key of 20. So we make the value a list.\n\nI think that for most people, syntax is not the worry. Syntax comes easy, and if you're having trouble, it's\nlikely that you'll learn quickly. Conceptual stuff seems to be the hurdle here for most people -- they aren't\nunderstanding when to use dictionaries or how to apply them.\n\nIf that's the case, stick to the above guidelines.\n\nSo now, the web indexing problem. What was the purpose of building an index? Because we want to be\nable to to quickly and easily know which sites have the words we care about. In this case, what do we\nknow? The words we care about. And what do we want to know? Which sites have those words.\n\nSo... our index (a dictionary) should have words as keys, and for each word, its value should be a list of\nsites which have that word in them. Make sure you understand this -- if you don't, ask us in class.\n\nReally, there's a reason I used the textbook analogy -- it's almost identical to the web problem. Think of\n\neach page in a textbook as a separate site. The index at the back of the textbook lets you quickly and\neasily see which pages (which sites) have the word in question.\n\nSo that's what we want to build. Now, I think some of the implementation stuff tripped people up. Some\nclarifications:\n\n- you don't have to worry about ANY -- I'm going to repeat that, ANY -- of the code in the files EXCEPT\nthe three functions you're asked to implement. You don't have to worry about how we connect to the sites\nand read them, how we parse their HTML, etc. You do NOT have to call ANY functions inside your\nthree functions. Everything is taken care of for you.\n\n- the function index_site is given two arguments, both are strings. The first is site -- this is just the site's\nURL. We need this for the index, to be able to say \"these sites have the word you're looking for.\" The\nsecond is text -- this is one giant string of all the text that was read on that site. Now, what do we need for\nour index? We need words. We have to get those words from the site. That's where we use split.\n\n- the function index_site is ONLY going to index ONE site. You are not going to be looping over\nmultiple sites in this function. Think of it as saying \"I'm going to add one more page into my textbook. I\nhave an existing index, so I want to ``index this site``, meaning I want to read each word and update the\nindex for each word I read.\"\n\n- as we've been trying to hammer into you guys over and over -- DO NOT PRINT INSIDE THESE\nFUNCTIONS. DO NOT ASK FOR INPUT INSIDE THESE FUNCTIONS. I kept seeing people print \"No\nsites found with the given word. Try a broader search\" inside their search_single_word function. No!\nWhat should that function return if no sites were found? To answer that question, what does it return\nwhen 3 sites are found? A list of 3 sites. When 1 site is found? A list of 1 site. So when no sites are\nfound? An empty list. Don't print anything!!!\n\n- once you can get the search at least working, pat yourself on the back. There are details which make\nthis a little tricky to polish, such as not having duplicate sites in your results, making sure that the site's\ntext is lowercased before you index it, and so on.\n\n[...]"
    },
    {
      "category": "Resource",
      "title": "handout5.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/4e4b3fa444d8220111333e74df4bca86_handout5.pdf",
      "content": "Handout 5 - Web Indexer Part 2\n\n[...]\n\nSo, what did our index look like in the previous part? Well, index was a dictionary that mapped words to a\nlist of sites that had that word:\n\n\"mit\" --> [ \"web.mit.edu \", \"csail.mit.edu\", ... ]\n\"google\" --> [ \"web.mit.edu\", \"google.com\", ... ]\n...\nword --> [ site1, site2, site3, ... ]\n\nAnd let's get straight what our types were:\n\nindex - dictionary, keys are words, values are lists of sites\nindex[word] - list of sites\n\nSo when we searched for a word, we got back something that looked like this:\n\n[ site1, site2, site3, ... ]\n\nNow, we want to retrieve not just a list of sites, but also how many times the word appeared on each of\nthose sites (the frequencies). We want something that looks like this:\n\n[ (site1, freq1), (site2, freq2), (site3, freq3), ... ]\n\nSo what we can do to get that instead of what we had before?\n\nOne thing we can do is change our index so that the values are lists of (site, freq) tuples. So now index\nwill look like:\n\n\"mit\" --> [ (\"web.mit.edu\", 3), (\"csail.mit.edu\", 2), ... ]\n\"google\" --> [ (\" web.mit.edu\", 1), (\"google.com\", 3), ... ]\n...\nword --> [ (site1, freq1), (site2, freq2), (site3 , freq3), ... ]\n\nLet's stick with this idea for now, and we'll see soon why we can't do this.\n\nHow do we implement the index_site function? Remember, we're given a site (like \" web.mit.edu\") and\nthe text on that site (one giant string). As usual, we're going to split it into a list of words. Then, we're\ngoing to look at each word, and update the index for that word.\n\nSo, last time, if we hadn't seen the word (if word was not in the index), then we had to create a new list,\nwith this site inside. So this time, we'll create a new list with a (site, freq) tuple inside. What's the\nfrequency? Well, if this is the first time we're seeing the word, it's 1. So the tuple will be (site, 1).\n\nIf we HAVE seen the word, then last time, we also checked if we had already included the site (if site was\n\nin the list index[word]). But what do we do this time? Because now index[word] is no longer a list of sites,\nit's a list of (site, freq) tuples.\n\nWe could check if (site, 1) is in the list. But what if the word's frequency in the site is more than 1? We\ndon't want to check for a specific frequency, we want to check for only the site. And we have no way of\ndoing that without looping through the list index[word].\n\nSo this is why we want to use a dictionary -- so that it's easier, and we don't have to loop through a list to\nfind the (site, freq) tuple we need to use.\n\nOkay, so let's back up. So what will each word map to in the index? Another dictionary. What will the keys\nof this dictionary be? The sites. And the values? The frequencies. So now the index will look something\nlike this:\n\n\"mit\" --> { \"web.mit.edu\": 3, \"csail.mit.edu\": 2, ... }\n\"google\" --> { \"web.mit.edu\": 1, \"google.com\": 3, ... }\n...\nword --> { site1 : freq1, site2 : freq2, site3 : freq3, ... }\n\nAnd let's get straight what our types are:\n\nindex - dictionary, keys are words, values are more dictionaries\nindex[word] - dictionary, keys are sites, values are frequencies\nindex[word][site] - int , the frequency of that word in that site\n\nSo let's get back to index_site. We're going to go through each word, and what should we do? If we\nhaven't seen that word before, then instead of making a new list like we did last time, we'll make a new\ndictionary. What should that dictionary contain? This site-freq entry. And again, the frequency initially is 1,\nsince we're seeing this word for the first time.\n\nIf we HAVE seen the word, then we know that the dictionary index[word] exists. Last time, this was a list,\nand we checked if site was already in the list. In this case, we're going to check if the key site is already in\nthe dictionary.\n\nLast time, if it WAS already in the list, we ignored it. This time, if it's already in the dictionary, should we\nignore it? No, we should increment its frequency.\n\nLast time, if it WASN'T already in the list, we appended it. This time, if it's not already in the dictionary, do\nwe append it? No, there's no such thing as append for dictionaries. We'll add a new entry for it instead.\nThe site is obvious, but what's the frequency? Again, if this is the first time we're seeing this word on THIS\nsite, then the frequency of the word is 1 for this site. So we'll make a new entry for this site mapping to 1.\n\nSo we have three cases:\n\nCase 1 -- we haven't seen the word on any site, i.e. it's not in the index. In this case, we make a new\nentry in index for word. And its value is a dictionary containing the single mapping site to 1.\n\nCase 2 -- we've seen the word on another site, but no on this site yet, i.e. index[word] exists, but this site\nis not in index[word]. In this case, we want to make a new entry to index[word] for this site. Its value is 1.\n\nCase 3 -- neither of the above, i.e. we've seen the word on this already, so index[word][site] exists. In this\ncase, we want to increment the frequency of the word on this site, so we increment index[word][site].\n\nGreat, so we've taken care of the indexing. So now, search_single_word. This should again be trivial like\nlast time, but there's just one catch. What is index[word]? It's a dictionary of site-freq entries. What do we\nneed to return? A list of (site, freq) tuples. Perfect for the items function! So index[word].items() will return\nwhat we need. And remember to return the empty list again if the word isn't part of the index.\n\nFinally, search_multiple_words. This is a little tricky. So last time, what we did was we made a new list,\ninitially an empty list, then we went through each word and called search_single_word on it. That function\nreturned a list of sites, so we went through each site, and if it wasn't already included in our new list, we\nappended it.\n\nThis time, we're going to apply the same big idea, but with a few changes. We're still going to go word by\nword and call search_single_word on each one. But now, what does search_single_word return? It\nreturns a list of (site, freq) tuples. And we need to return a similar list of (site, freq) tuples.\n\nThe only difference is, if we see a site more than once, we don't want to ignore it this time. Instead, we\nwant to return the sum of all its frequencies. (e.g. if we search for \"mit people\", the word \"mit\" may appear\n3 times on \" web.mit.edu\", and \"people\" 1 time on the same site, so we'd return (\"web.mit.edu\", 4)\nbecause there were 4 hits).\n\nSo, for similar reasoning above, we don't want to maintain a LIST like last time (of (site, freq) tuples like\nlast time). instead, we want to maintain a dictionary. So we'll set a variable to an empty dictionary initially.\nThe keys of this dictionary will be each site that we've seen, and the values will be the total frequency of\neach site.\n\nSo now, we're going to go through each word, like we said, search_single_word on it. This returns a list of\n(site, freq) tuples. Now we'll see if the current site is in our dictionary. If it is, we're going to increase the\nsite's frequency by freq, and if it's not, we're going to make a new entry in the dictionary, where site maps\nto freq.\n\nFinally, we need to return a list of (site, freq) tuples again, so remember to call items() on the dictionary\nlike last time.\n\nOh, one last thing -- your search engine will work now, but you'll see that the results aren't sorted. You'll\nsee a site with 5 hits, then 1 hit, then 3 hits, etc.\n\nTo sort it, remember to follow the instructions in the lab: before you return the dictionary.items() list in both\nyour search functions, assign it to a variable, let's say L, then call L.sort(...) like it shows in the lab. Then,\nreturn L. Note that sort doesn't return a new list, it modifies the list.\n\nGreat, you should have a working search engine now. Try using \"mitsites20.txt\" or \"mitsites50.txt\" to see\nsome cool results, and compare against Google. =) Just know that 20 will take a little more time to build\nthe index, and 50 will take a decent amount of time.\n\nAlso, it's best to not include words like \"and\" and \"the\" in your search, because almost every site will\nprobably have those words.\n\n[...]"
    },
    {
      "category": "Resource",
      "title": "notes6.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/a6cad15cd20526492757bc096a4a9d7f_notes6.pdf",
      "content": "Page 1\n6.189 - Notes/Homework\nAdministrivia\nName:\n\nInstructions:\n1. Err..complete the questions :). Putting a serious effort into this homework is mandatory for receiving\na passing grade in this course (note the word effort - getting them all wrong is ok, but skipping this\nhomework is not.)\n2. These notes (and homework problems) are a continuation of the notes from Exam 1.\n3. Some problems may be marked {alone} (it'll be in red and braces.) Work on those problems alone!\n4. When we ask for output, you DON'T have to write the spaces/newlines in.\n\nProgram Text:\n\nOutput:\n\nDay 4: List Basics\nNotes:\nThis section covers the basics of lists. We'll cover them in more detail after we cover objects and\nreferences.\nWe've used variables to store basic information such as numbers, strings, and boolean values. We can\nalso store more complex information. A list stores a sequence of elements [x1,x2,x3,...]. Note that\norder matters: [x1,x2] != [x2,x1]\nYou can store different types of variables in the same list: [1,3,\"test\",True]. You can even store\nlists in lists! (Note: For now, don't store lists in lists! You'll understand why when we talk about objects\nand mutability.)\nChapters 9.1-9.3 cover basic syntax on using lists. Here's a quick review:\n- You can create a list using square brackets [1,2,5,1,3,\"test\"].\n- To read an element from list some_list, use some_list[index]. The index of an element is just\nits position, but note that the first element is considered to have a position of 0!\nprint \"X\",\nprint \"X\",\nXX\nSession 6\n\nPage 2\n- The built-in function len(x) will find the length of any list passed in as a parameter. This works\nmore generally with any complex data structure (like dictionaries, which we'll cover later) as well as\nstrings.\nWe'll also be using the following syntax for adding something to the end of a list.\n\nProgram Text:\n\nOutput:\n\nFor now, just memorize the syntax -- you'll understand what's going on in a later section.\nProblem 12 {alone}:\nWhat is the output of the following code. The output of each program has at most two semi-colons.\n\nProgram Text:\n\nOutput:\n\nProgram Text:\n\nOutput:\n\nsome_list = [1,2,3,4]\nsome_list.append(5)\nprint some_list\n[1,2,3,4,5]\nsome_list = [3,6,2,5]\ni = 1\nwhile i < 3:\nprint some_list[i], \";\"\ni = i + 1\nprint some_list[3]\n\nlist1 = [2,5,6,3,7,8,12]\nlist2 = [1,2,6,5,7,3,12]\ni = 0\nwhile i < 6:\nif list1[i] == list2[i]:\nprint list1[i], \";\",\ni = i + 1\nprint len(list1)\n\nPage 3\nDay 6: Objects and References\nNotes:\nLists are fundamentally different than everything we've seen to date. They are the first example we've\nseen of an object.\nYou've learned that we can use variables to store information in a table. This works for simple things like\nnumbers, but not for complex information like a list. Instead, Python stores this information in an area\nof memory called the heap.\nUnderstanding what the heap is isn't important. What is important to know, however, is that instead of\nstoring objects in the variable table, Python stores a pointer or reference to the object.\nA reference is like an arrow. The easiest way to explain this is with an example:\n\nProgram Text:\n\nOutput:\n\nAt point 1, the variable table looks something like the following.\n\nAfter this, we pass the location of the list (which is the value stored in the variable) to the function. Thus,\nat point 2 both variables point to the same thing.\nexample_list = []\n\ndef append_one(my_list):\n\"This is a function that adds something to the end of a list\"\n#Point 2\nmy_list.append(1)\n#Point 3\n\n#Point 1\nappend_one(example_list)\nprint example_list\n#Point 4\n[1]\n\nPage 4\n\nWe change the list afterwards, and the table looks like the following at point 3.\n\nThe local variable disappears when the function ends, and at point 4 the variable table looks like the\nfollowing.\n\nHence the output of the code is [1]! This differs from problem 10 - since these variables are storing\narrows, any changes we make within the function are reflected outside of it too.\nThis arrow is literally stored as an integer in the table - think of it as a locker number. We can find out\nthe value of this number using the id(x) function.\n\nPage 5\n\nProgram Text:\n\nOutput:\n\nNote: Your numbers may differ from mine. The first and last numbers will still be the same, though.\nYou probably won't need to use the id function ever. Its really useful for figuring out whether two\nvariables are pointing to the same list or not, though.\nProblem 13:\nWhat is the output of the following code. Use single digits for the output of id(x).\n\nProgram Text:\n\nOutput:\n\ndef small_function(my_list):\nprint \"in function:\"\nprint id(my_list)\nmy_list.append(1)\n\nexample_list = []\nexample2_list = [3,6]\nprint id(example_list)\nprint id(example2_list)\n\nsmall_function(example_list)\nin function:\nsome_list = [1,3,2]\n\ndef f1(my_list):\nnew_list = [2]\nprint id(my_list), \"; \",\nprint id(new_list), \";\",\n\nprint id(some_list), \"; \",\nf1(some_list)\n\nPage 6\n\nProgram Text:\n\nOutput:\n\nDay 6: Mutability\nNotes:\nNow that you understand the true nature of a list, we can talk about the concept of mutability. Lists are\nan example of a mutable object. Mutability is a synonym for changable - in essence, we're saying that\nyou can change a list. Be careful -- while this sounds very simple, it can get quite tricky.\nFor the next problem, the references example will help a lot. Remember that statements like list1 =\n[1,2,5] change the reference (what the arrow is pointing to) and statements like list1.append(5)\nchange the list itself.\nProblem 14:\nWhat is the output of the following code.\n\nProgram Text:\n\nOutput:\n\nsome_list = [1,3,2]\n\ndef f1(my_list)\nmy_list.append(7)\nprint id(my_list), \";\",\nreturn [1,4,5]\n\nprint id(some_list), \";\",\nsome_list.append(5)\nprint id(some_list), \";\",\nsome_list = [4,3,7]\nprint id(some_list), \";\",\nsome_list = f1(some_list)\nprint id(some_list)\n\nlist1 = [1,2,4]\nlist2 = list1\nlist2.append(3)\nprint list1\n\nPage 7\n\nProgram Text:\n\nOutput:\n\nProgram Text:\n\nOutput:\n\nProgram Text:\n\nOutput:\n\nexample_list = [1,2,4]\n\ndef f1(my_list):\nmy_list.append(3)\n\nf1(example_list)\nprint example_list\n\nlist1 = [1,2,4]\nlist2 = [1,2,4]\nlist2.append(3)\nprint list1\n\nexample_list = [1,2,4]\n\ndef f1(my_list):\nmy_list = [1,2,4,3]\n\nf1(example_list)\nprint example_list\n\nPage 8\n\nProgram Text:\n\nOutput:\n\nWe'll talk about immutable objects later when we cover tuples and revisit strings.\nDay 6: Member functions\nNotes:\nWe saw at the append function earlier - this function had some unusual syntax. Objects have something\ncalled member functions. append is a member function of a list.\nIn essence, member functions are basically shorthand. Python could easily have made a general\nappend(some_list, element) function that appends the value of element to the list some_list.\nInstead, we use the member function of some_list: we write some_list.append(element) to\nappend an element to some_list.\nIn general, member functions have the syntax object_name.function(parameters) - the function\naffects or applies to the object object_name.\nDay 4: Lists Redux\nNotes:\nNow let's go over lists for real. Remember what you've just learned about them.\n- Lists are mutable objects. When you change a list somewhere, every other reference will still point\nto the now changed list.\n- Lists have member functions. For lists, these functions tend to change the list itself.\nBasics: You already know how to create a list and read its members. You can also use the\nexample_list[i] syntax to change values, e.g. example_list[1] = 5. Finally, you can write del\nexample_list[i] to delete the element at position i.\nLength: As mentioned earlier, you can use the built-in function len(x) to find the length of a list.\nlist1 = [1,2,4]\nlist2 = [1,2,4]\nlist3 = list2\nlist2.append(3)\nlist2 = list1\nlist2.append(3)\nlist1.append(3)\nlist1 = list3\nprint list1, \";\",\nprint list3\n\nPage 9\nMembership: The in operator can be used to determine whether an element is a member of a list or\nnot. 3 in [3,5,7] evaluates to True, while 6 in [3,4,1] evaluates to false.\nAnalogous to !=, you can use not in to check if an element is NOT a member of a list. 12 not in\n[3,5,7] returns True.\nWarning: Never use booleans for this operator unless the list consists ONLY of booleans. Recall that the\n== operator can compare different types; Python considers 0 == False and any other number equal to\nTrue. Hence, True in [0,3,5] evaluates to True because 3 == True is considered True by Python.\nMember functions: All of the following functions change the list they're called from. They have NO\nreturn values.\n- append(element). Appends element to the end of the list.\n- insert(index, element). Inserts element before the list element at index.\n- reverse(). Reverses the order of elements in the list.\n- remove(element). Removes the first instance of element from the list.\nThe following function(s) don't change the list. They return information about the list instead.\n- index(element). Returns the position of the first instance of element in the list.\n- count(element). Returns the number of times element appears in the list.\nDon't worry too much about memorizing all these functions. Just keep in mind that they exist.\nConcatenation: You can combine two lists into a new list with the concatenation operator +.\nProblem 15:\nWrite a definition for the following shift functions. shift takes a list and moves the first element to the\nvery end. reverse_shift does the opposite - it moves the last element to the beginning of the list.\nNeither function should return anything!\n\nProgram Text:\n\ndef shift(my_list):\n\"Shifts the list [x1,x2,...,xn] to [x2,x3,...,xn,x1].\"\n\nPage 10\n\nProgram Text:\n\nProblem 16:\nWrite a definition for the function last_index. last_index takes a list and an element and returns\nthe position of the last instance of element in list, e.g. last_index([3,4,3,7,9],3) returns 2. Be\nsure that list is in its original form when your function completes! (either create your own copy of the\nlist or reverse any changes you make.)\n\nProgram Text:\n\nDay 4: Advanced Positioning and Slicing\nNotes:\nYou've already learned about the notation for selecting an element some_list[i] by using its\nposition. You can also use negative numbers to select an element - the last element is considered to\nhave position -1.\ndef last_index(my_list, element):\n\"Returns the position of the last instance of element in my_list\"\n\ndef reverse_shift(my_list):\n\"Shifts the list [x1,x2,...,xn] to [xn,x1,x2,...,x(n-1)].\"\n\nPage 11\nYou can do even slicker things. some_list[start:end] creates a list slice - it returns a new list with\nall the elements between start and end - 1 from the original list. If you omit either start or end,\nit'll select all elements from the beginning / up until the end, e.g. some_list[1:] creates a slice\nincluding all but the first element.\nYou can change the values of slices the same way you change individual values, e.g. some_list[3:5]\n= [1,5,4,4,7]. Note that the new assignment doesn't have to be the same length as the list slice you\ncut out.\nNote, however, that if you assign the slice to a variable, that variable points to a new list.\n\nProgram Text:\n\nOutput:\n\nsome_list[:] creates a duplicate of the list. This is very useful - since most of our list techniques\ndestructively change the list, many times, it may be a good idea to create a duplicate of the list and mess\naround with that instead.\nProblem 17:\nWhat is the output of the following code.\n\nProgram Text:\n\nOutput:\n\nlist1 = [4,6,12]\nlist2 = list1[:]\nlist1.append(4)\nprint list2\n\nlist1 = [1,3,5,7]\nlist1[1:3] = [2,4,6]\nprint list1\nlist2 = list1[1:] #list2 points to a new list\nlist2.append(55)\nprint list1\nprint len(list1)\nlist1[3:5] = [8,8,8,8]\nprint list1\n[1, 2, 4, 6, 7]\n[1, 2, 4, 6, 7]\n[1, 2, 4, 8, 8, 8, 8]\n\nPage 12\n\nProgram Text:\n\nOutput:\n\nProgram Text:\n\nOutput:\n\nDay 4: Range function\nNotes:\nrange(x) is a built-in function that returns a list [0,1,...,x-1], e.g. range(3) returns [0,1,2].\nYou can also do range(start, finish), which creates the list [start, start+1, ...,\nfinish-1]. Its a very useful function.\nDay 4: For loop\nNotes:\nLike the while loop, the for loop is another control flow command - a way of executing a sequence of\nstatements multiple times. A for loop executes a sequence of statements once for each element in a\nlist.\n\nProgram Text:\n\nOutput:\n\nlist1 = [2,5,6,3]\ni = 1\nwhile i < len(list1):\nprint list1[-i], \";\",\ni = i + 1\nprint list1[-len(list1)]\n\nfor i in [1,2,4,6]:\nprint i, \";\",\nprint 8\n1;2;4;6;8\nlist1 = [1,2,3]\ni = 1\nwhile i < len(list1):\nprint list1[:i], \";\",\ni = i + 1\nprint list1\n\nPage 13\nThe for loop is incredibly useful. For example, you can combine the for loop and range(x) function\nto execute a statement a fixed number of times.\nProblem 18:\nWrite a definition for a function that takes a list and returns the sum of all elements in that list.\n\nProgram Text:\n\nDay 4: Basic Advanced Loops\nNotes:\nThis title is not a contradiction :p. For loops can be incredibly difficult to use correctly. This section will\ngive you a bunch of problems to give you practice in solving problems with for loops.\nProblem 19:\nEach of the following function definitions takes a list as a parameter and solves a specific problem.\nCorrectly fill the blanks in the following code to solve the problems.\nThere is a way to solve each problem by only filling in the blanks. Don't just add extra lines to force a\nsolution. Also, there may even be more elegant solutions that don't use all the blanks - feel free to use\nthose too.\n\nProgram Text:\n\ndef all_under_6(my_list):\n\"\"\"Returns True if ALL members in my_list are under 6 (False\notherwise). my_list must be list of integers.\"\"\"\nunder_6 = ___________\nfor i in my_list:\nif __________________:\n_________________________________________________________\nreturn under_6\ndef sum_elements(my_list):\n\"Returns the sum of all elements in my_list\"\n\nPage 14\n\nProgram Text:\n\nProgram Text:\n\ndef find_max_element(my_list):\n\"\"\"Finds and returns the maximum value contained in my_list.\nAssume my_list contains positive values only.\"\"\"\nmax_value = -1\nfor i in __________________:\nif ______________________:\n____________________________________________________________\nreturn max_value\ndef no_vowels(my_list):\n\"\"\"Returns True if my_list contains only consonants (no vowels).\nAssume that my_list only contains lowercase letters.\"\"\"\nvowels = ['a','e','i','o','u']\ncontains_vowels = _________\nfor i in __________________:\nif ______________________:\n____________________________________________________________\nreturn not contains_vowels"
    },
    {
      "category": "Resource",
      "title": "notes7.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/7fef0cb6f5a93e432e4f644cfa3de760_notes7.pdf",
      "content": "Page 1\n6.189 -Homework ONLY\nSession 7\nAdministrivia\nName:\nInstructions:\n1. Err..complete the questions :).\n2. When we ask for output, you DON'T have to write the spaces/newlines in.\nProgram Text:\nprint \"X\",\nprint \"X\",\nOutput:\nXX\nDay 4: More Loop Practice\nProblem 20:\nEach of the following function definitions takes a list as a parameter and solves a specific problem.\nCorrectly fill the blanks in the following code to solve the problems.\nThere is a way to solve each problem by only filling in the blanks. Don't just add extra lines to force a\nsolution. Also, there may even be more elegant solutions that don't use all the blanks - feel free to use\nthose too.\nProgram Text:\ndef swap_first_last(my_list):\n\"\"\"This function swaps the first and last elements in a list. It\nhas no return value.\"\"\"\ntemp = _____________\n_____________ = _____________\n_____________ = _____________\n\nPage 2\nProgram Text:\ndef second_biggest(my_list):\n\"\"\"This function returns the second biggest element in my_list. It\nassumes that my_list contains distinct, positive integers.\"\"\"\nsecond_biggest = -5\nbiggest = -1\nfor i in my_list:\nif i > _____________:\nsecond_biggest = ______________\nbiggest = _____________________\nelif i > second_biggest:\nsecond_biggest = ______________\nreturn second_biggest\nProblem 13:\nYou may recall the notion of a power series from Calculus. A power series is an infinite polynomial series\nthat approximation a continuous function. For example, the power series of sin(x) is\n\n3!\n5!\n7!\nThe more terms you calculate, the closer your expression will be to sin(x) - hence the reason we call it\nan approximation.\nWrite a function to calculate sin(x) using the above power series (well, fill in the blanks, at least.)\nNote: You've already seen the code for a function that can calculate the factorial of a number (Problem\n11.) Assume the existance of a factorial(x) function that calculates the factorial of x.\n\nPage 3\nProgram Text:\ndef calculate_sin(x, number_of_terms):\n\"Calculates the value of sin(x) using the power series.\"\nnumber_of_terms = min(20, number_of_terms) #do at most 20 terms\nsin_value = 0\nfor i in range(number_of_terms):\nnew_term = x ** _____________\nnew_term /= factorial(___________________)\nnew_term *= (-1) ** ___________________\nsin_value += new_term\nreturn sin_value"
    },
    {
      "category": "Resource",
      "title": "notes8.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/cba573ff35344d37c5c0d65e48281575_notes8.pdf",
      "content": "Page 1\n6.189 - Notes\nSession 8\nDay 6: Immutable Objects\nEarlier, we made a big deal about the fact that lists are mutable. The reason this is important is because\ncertain objects are immutable - once created, their value cannot be changed.\nStrings are a prime example of this. Although we treated strings the same as primitives like integers and\nbooleans earlier, strings are actually objects.\nWhy did we do this? Think about this: if an object is immutable, it doesn't matter whether two variables\nare pointing to the same string or two different strings with the same value! Thus, while strings are\nactually immutable objects, we can treat them as we have before - as primitives. The only new meaning\nthis revelation has is that like lists, strings have member functions.\nFor strings (and tuples, when we get to them), its easiest to think of them like primitives - directly\nstored in the variable table.\nDay 6: Strings Revisited\nMost of the member functions in lists modified the list and had no return value. Strings are immutable,\nthough - how do string member functions work? It turns out that member functions of strings tend to\nreturn a new string.\nProgram Text:\nmessage = \"Hello\"\nprint message\nmessage.lower() #no effect\nprint message\nmessage = message.lower()\nprint message\nOutput:\nHello\nHello\nhello\nNote: lower() is a function that converts a string into lowercase.\nHere is a list of some useful string functions. Don't try to memorize these! Even I don't remember them -\ninstead, when I need to look up a function I go to the Python Quick Reference website shown in class\n(and on the website.)\n\nPage 2\nA quick reminder before starting: remember that \"A\" and \"a\" are completely different characters!\nWhen writing functions that manipulate strings, its generally a good idea to deal with a single case\n(usually lowercase).\nFunctions that return a new string\nstr.capitalize() / str.lower(). Returns a copy of str with all letters converted to\nuppercase / lowercase.\nstr.strip(). Returns a copy of str with all whitespace (spaces/tabs/newlines) from the\nbeginning and end of the string removed.\nExample: \"\ntest\n\".strip() == \"test\".\nstr.replace(old,new). Returns a copy of str with all instances of old within the string\nreplaced with new.\nExample: \"hallo all!\".replace(\"al\", \"el\") == \"hello ell!\".\nFunctions which return information about a string\nstr.count(substring). Returns the number of times substring appears within str.\nstr.find(substring) / str.rfind(substring). Returns the position of the first instance of\nsubstring within str. rfind returns the position of the last instance of substring.\ns.startswith(substring) / str.endswith(substring). Returns True if the string starts\nwith / ends with substring.\nExample: \"Hello\".startswith(\"he\") == False, but \"Hello\".endswith(\"lo\") == True\nFunctions which transform the string into other types\nstr.split(separator). Returns a list of words in str, using separator as the delimiter string.\nExample: \"hello world, Mihir here\".split(\" \") returns\n[\"hello\",\"world,\",\"Mihir\",\"here\"].\nExample: \"mississippi\".split(\"s\") returns [\"mi\", \"\", \"i\", \"\", \"ippi\"].\nseparator.join(seq). This one is tricky. It takes a list of strings seq and combines them into a\nstring. Each element in seq is separated by separator in the returned string.\nExample: \" \".join([\"hello\",\"world\"]) == \"hello world\"\nDay 4: Tuples\nTuples are the immutable counterpart of lists. Unlike a list, tuples cannot be changed.\nWhy/where are tuples useful? Think of a tuple as multi-dimensional data -- just like you can store an\ninteger 5 in a variable, you can also store a two-dimensional coordinate (6,-3). You'll develop an\ninstinct for when to use tuples versus lists as you continue in course 6 - just remember that it tends to\nbe much easier to use tuples whenever you can get away with it.\nYou can create tuples by using parentheses: (1,3,8) creates the tuple with elements 1, 3, 8. As you\nshould expect, tuples are ordered: (1,3) != (3,1)\n\nPage 3\nIf you want to create a singleton ttuple (a tuple with one element), you can use tupple(5) or use the\nnotation (5,). Note that (5,) !== 5 - they have completely different types (the forrmer is a tuple and\nthe latter is an integer.\nAlso note that (4,6) != [4,6] - one is a tuple and the other is a list. Similarlyy, (\"a\",\"b\") !=\n\"ab\". You can convert between theese three formats using str(x), tuple(x), and liist(x), though.\nYou can nest tuples in tuples! Notee that ((1,2),3) != (1,2,3) - the former is a ttuple that contains\ntwo elements (one tuple and one innteger), whereas the latter is a tuple that contains thhree elements.\nNotation for using tuples will be covvered in the next section.\nDay ?: Sequence notation\nLists, strings and tuples are all exammples of sequences - a series of ordered items. In tthe case of strings,\nyou can think of them as a sequencce of characters.\nSequence isn't an official term or aanything - just an observation that all three of thesse are very similar.\nIn fact, they share much of the samme syntax.\nIndexing. seq[i] will return thhe item (or character) at the ith position.\nLength. len(seq) returns the length of a sequence.\nSlicing. You can slice sequencess the same way you sliced lists. \"hello\"[0:3] == \"hel\"\nin, not in operators. x in sseq is True if and only if an item of seq is equal to x. For strings, you\ncan check if a substring is in a sttring, e.g. \"ello\" in \"hello\" returns True.\nConcatenation. You can use thee plus operator to combine two sequences of the saame type. You can\nuse * to duplicate it n times forr some integer n, e.g. \"Yay! \" * 5\nFor loops. We learned that the for operator works on lists. for actually works on any sequence -\nfor strings, it iterates through eeach character in the string.\nDay 7: Dictionaries\nAnd so we come to the last major toopic of this class: dictionaries. Like lists, dictionariess are an mutable\nobject that we can use to store dataa. Where lists stored a sequence of items, dictionaries store a table.\n\nPage 4\nNote that dictionaries are considered to be unordered - it doesn't matter what order we list entries in.\nWe call the names on the left keys and the values on the right values.\nYou can store primitives and immutable objects (like strings and tuples) as keys. You can store anything\n(e.g. lists) as a value.\nAs we go through the dictionary notation, notice that a lot of it is consistent with the sequence notation\nabove - the notation below should seem intuitive to you. Remember that dictionaries are fundamentally\ndifferent from sequences, though - especially the fact that dictionaries are unordered.\nYou can create a new dictionary using curly braces.\nExample: example_dict = {} creates an empty dictionary\nExample: example_dict = {\"a\":5, \"test\":[1,2], 27:\"Test\"} creates the above table.\nThe amount of spacing around the colon : is irrelevant.\nlen(d) works on dictionaries too - use it to find the number of entries in the dictionary (the above\ndictionary has length 3.)\nTo access or change a value, use the same index notation.\nExample: print example_dict[\"a\"] prints 5\nExample: example_dict[\"a\"] = 7\nNote that this implies that a dictionary cannot contain two identical keys - writing\nexample_dict[\"a\"] = 7 would just change the value that a is mapped to. This should make\nsense, though - remember that dictionaries are unordered. Also, you can have a dictionary with\nidentical values.\nUse del example_dict[\"a\"] to remove that entry from the dictionary.\nk in d will return true if the dictionary d contains an entry with key k.\nExample: (27 in example_dict) == True\nExample: (5 in example_dict) == False\nDay 7: Dictionary Member functions\nLike other objects, dictionaries have member functions. You don't really need to use these much, though\n- here are a few that might be useful\nd.clear(). Removes all items from d.\nd.copy(). Returns a copy of the dictionary d.\nd.pop(k). Removes the entry with key k and returns its corresponding value. This is just like del\nd[k], except that the function also returns the value of d[k].\nDay 7: For loops and dictionaries\nRemember how k in d will return True if k is mapped to something? You can also use for loops with\ndictionaries. For loops will iterate over all the keys in the dictionary:\n\nPage 5\nProgram Text:\nexample_dict = {\"a\" : 5, \"b\" : True}\nfor k in example_dict:\nprint k, \";\", example_dict[k]\nOutput:\na ; 5\nb ; True"
    },
    {
      "category": "Resource",
      "title": "connectfour.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/e158cc0d1bac8d221523704ec177eb9a_connectfour.py",
      "content": "# connectfour.py\n# A two-player command-line implementation of Connect Four.\n#\n# Author: Aseem Kishore\n#\n# License: None -- free to use. Just give credit where it's due please! =)\n\nfrom string import lower, upper, join\nfrom random import randint\n\n## Constants ##\n\nNUM_ROWS = 6\nNUM_COLS = 7\n\nROWS = range(1, NUM_ROWS + 1)\nCOLS = [chr(i) for i in range(ord(\"A\"), ord(\"A\") + NUM_COLS)]\n\nEMPTY = \" \"\nPL_1 = \"x\"\nPL_2 = \"o\"\n\nNEEDED_TO_WIN = 4 # number in-a-row needed to win\n\n## Board implementation ##\n\n# The board is implemented as a list of columns. Each column is implemented\n# as a list of tokens. The length of each of these column lists is exactly\n# the number of tokens in that column. So initially, each column list is\n# empty. When a token is added, we'll append that to the end of that list,\n# so this means that the bottom token is always index 0.\n#\n# The abstract representation of the board is a grid with numbered rows and\n# lettered columns. The bottom row is row 1, then row 2, etc. The position\n# of a particular square is then a (row, col) tuple, so the position (1, A)\n# refers to the bottom-left square.\n\n_board = [ [] for i in range(NUM_COLS) ] # list of 7 columns, each list\n# initially empty\n\ndef _assert_valid_position(position):\nassert type(position) is tuple and len(position) == 2,\\\n\"position must be a (row, col) tuple, %s given\" % position\n_assert_valid_row(position[0])\n_assert_valid_col(position[1])\n\ndef _assert_valid_row(row):\nassert row in ROWS,\\\n\"row must be an integer in the range %i-%i, %s given\" %\\\n(ROWS[0], ROWS[-1], row)\n\ndef _assert_valid_col(col):\nassert type(col) is str and upper(col) in COLS,\\\n\"col must be a letter in the range %c-%c, %s given\" %\\\n(COLS[0], COLS[-1], col)\n\ndef _col_num(col):\n\"\"\"\nReturns the column number (1, 2, ...) of the given column (A, B, ...).\n\"\"\"\nreturn COLS.index(upper(col)) + 1\n\ndef position(row, col):\n\"\"\"\nReturns the position at the given row and column.\n\"\"\"\n_assert_valid_row(row)\n_assert_valid_col(col)\nreturn (row, col)\n\ndef row(position):\n\"\"\"\nReturns the row of the given position.\n\"\"\"\n_assert_valid_position(position)\nreturn position[0]\n\ndef col(position):\n\"\"\"\nReturns the column of the given position.\n\"\"\"\n_assert_valid_position(position)\nreturn position[1]\n\ndef get_square(position):\n\"\"\"\nReturns the square (EMPTY, PL_1 or PL_2) at the given position.\n\"\"\"\n_assert_valid_position(position)\nrow_i = row(position) - 1\ncol_i = _col_num(col(position)) - 1\ncolumn = _board[col_i]\nif row_i >= len(column):\nreturn EMPTY\nreturn column[row_i]\n\ndef get_row(row):\n\"\"\"\nReturns a list of squares (EMPTY, PL_1 or PL_2) in the given row.\nThe first square is at column A, the next at column B, etc.\n\"\"\"\n_assert_valid_row(row)\nrow_i = row - 1\nsquares = []\nfor col_i in range(NUM_COLS):\ncolumn = _board[col_i]\nif row > len(column):\nsquares.append(EMPTY)\nelse:\nsquares.append(column[row_i])\nassert len(squares) == NUM_COLS,\\\n\"INTERNAL ERROR: squares should be %i long, %i long instead\" %\\\n(NUM_COLS, len(squares))\nreturn squares\n\ndef get_column(col):\n\"\"\"\nReturns a list of squares (EMPTY, PL_1 or PL_2) in the given column.\nThe first square is at row 1, the next at row 2, etc.\n\"\"\"\n_assert_valid_col(col)\ncol_i = _col_num(col) - 1\nsquares = list(_board[col_i])\nwhile len(squares) < NUM_ROWS:\nsquares.append(EMPTY)\nreturn squares\n\ndef get_diagonal_TL_to_BR(tl_position):\n\"\"\"\nReturns the top-left to bottom-right diagonal that begins at the given\ntop-left position (meaning a position on the top or left edges).\n\"\"\"\n_assert_valid_position(tl_position)\nassert row(tl_position) == ROWS[-1] or col(tl_position) == COLS[0],\\\n(\"tl_position must be on the top (row %i) or left (col %c)\" +\\\n\" edges, %s given\") % (ROWS[-1], COLS[0], tl_position)\nsquares = []\nrow_i = row(tl_position) - 1\ncol_i = _col_num(col(tl_position)) - 1\nwhile row_i >= 0 and col_i < NUM_COLS:\ncolumn = _board[col_i]\nif row_i >= len(column):\nsquares.append(EMPTY)\nelse:\nsquares.append(column[row_i])\nrow_i -= 1 # moving down, i.e. row_i is decreasing\ncol_i += 1 # moving right, i.e. col_i is increasing\nassert len(squares) >= 1,\\\n\"INTERNAL ERROR: squares is empty\"\nassert len(squares) <= min(NUM_ROWS, NUM_COLS),\\\n\"INTERNAL ERROR: should have at most %i squares, have %i\" %\\\n(min(NUM_ROWS, NUM_COLS), len(squares))\nreturn squares\n\ndef get_diagonal_BL_to_TR(bl_position):\n\"\"\"\nReturns the bottom-left to top-right diagonal that begins at the given\nbottom-left position (meaning a position on the bottom or left edges).\n\"\"\"\n_assert_valid_position(bl_position)\nassert row(bl_position) == ROWS[0] or col(bl_position) == COLS[0],\\\n(\"bl_position must be on the bottom (row %i) or left (col %c)\" +\\\n\" edges, %s given\") % (ROWS[0], COLS[0], bl_position)\nsquares = []\nrow_i = row(bl_position) - 1\ncol_i = _col_num(col(bl_position)) - 1\nwhile row_i < NUM_ROWS and col_i < NUM_COLS:\ncolumn = _board[col_i]\nif row_i >= len(column):\nsquares.append(EMPTY)\nelse:\nsquares.append(column[row_i])\nrow_i += 1 # moving up, i.e. row_i is increasing\ncol_i += 1 # moving right, i.e. col_i is increasing\nassert len(squares) >= 1,\\\n\"INTERNAL ERROR: squares is empty\"\nassert len(squares) <= min(NUM_ROWS, NUM_COLS),\\\n\"INTERNAL ERROR: should have at most %i squares, have %i\" %\\\n(min(NUM_ROWS, NUM_COLS), len(squares))\nreturn squares\n\ndef drop_into_column(col, mark):\n\"\"\"\nDrops a token with the given mark into the given column. Raises an\nException if the given column is filled.\n\"\"\"\n_assert_valid_col(col)\ncol_i = _col_num(col) - 1\ncolumn = _board[col_i]\nif len(column) == NUM_ROWS:\nraise Exception, \"column %c is filled\" % col\ncolumn.append(mark)\n\ndef board_filled():\n\"\"\"\nReturns True iff the board has been completely filled.\n\"\"\"\nfor col_i in range(NUM_COLS):\nif len(_board[col_i]) < NUM_ROWS:\nreturn False\nreturn True\n\ndef clear_board():\n\"\"\"\nClears the board so that all squares are EMPTY.\n\"\"\"\nfor col_i in range(NUM_COLS):\n_board[col_i] = []\n\n## Game logic ##\n\ndef enough_to_win(mark):\n\"\"\"\nReturns True iff the board contains enough in-a-row of the given mark\nneeded to win. All rows, columns and diagonals are considered.\n\"\"\"\nN = NEEDED_TO_WIN # the number we need to win, e.g. 4\nwin = [mark for i in range(N)]\n\n# to compare win against a list of squares, we'll go square by square\n# and when we find one that is our mark, we'll slice it to look at the\n# next N-1 elements also, then compare that against win\ndef contains_win(squares):\nfor i in range(len(squares)):\nif squares[i] == mark:\nif squares[i:i+N] == win:\nreturn True\nreturn False\n\n# go row by row first\nfor row in ROWS:\nsquares = get_row(row)\nif contains_win(squares):\nreturn True\n\n# same for columns\nfor col in COLS:\nsquares = get_column(col)\nif contains_win(squares):\nreturn True\n\n# diagonals are a bitch. we'll try all the TL-to-BR diagonals first.\n# try all the left-edge positions first, then all the top-edge ones.\ncol = COLS[0]\nfor row in ROWS:\nsquares = get_diagonal_TL_to_BR(position(row, col))\nif contains_win(squares):\nreturn True\nrow = ROWS[-1]\nfor col in COLS:\nsquares = get_diagonal_TL_to_BR(position(row, col))\nif contains_win(squares):\nreturn True\n\n# and same for all the BL-to-TR diagonals. left then bottom edges.\ncol = COLS[0]\nfor row in ROWS:\nsquares = get_diagonal_BL_to_TR(position(row, col))\nif contains_win(squares):\nreturn True\nrow = ROWS[0]\nfor col in COLS:\nsquares = get_diagonal_BL_to_TR(position(row, col))\nif contains_win(squares):\nreturn True\n\n# nothing found in rows, columns or diagonals\nreturn False\n\n## Display ##\n\n#\n# a b c d e f g\n#\n# . . . . . . .\n# . . . . . . .\n# . . . . . . .\n# . . . . . . .\n# . . o x . . .\n# . o x o x . .\n#\n\ndef _get_simple_display():\n# see commented display above to understand the process\nlines = []\nlines.append(\"\")\n\n# column letters\ncol_letters = [lower(col) for col in COLS]\nlines.append(join(col_letters)) # space between each letter\nlines.append(\"\")\n\n# each row will display each square in that row, from top to bottom\nROWS_REVERSED = list(ROWS)\nROWS_REVERSED.reverse()\nfor row in ROWS_REVERSED:\nrow_letters = []\nfor square in get_row(row):\nif square == EMPTY:\nrow_letters.append(\".\")\nelse:\nrow_letters.append(square)\nlines.append(join(row_letters)) # space between each letter\n\nlines.append(\"\")\nreturn lines\n\n#\n# A B C D E F G\n# __ __\n# || | | | | | | ||\n# |+---+---+---+---+---+---+---+|\n# || | | | | | | ||\n# |+---+---+---+---+---+---+---+|\n# || | | | | | | ||\n# |+---+---+---+---+---+---+---+|\n# || | | | | | | ||\n# |+---+---+---+---+---+---+---+|\n# || | | | | | | ||\n# |+---+---+---+---+---+---+---+|\n# || o | o | x | o | x | x | o ||\n# |+---+---+---+---+---+---+---+|\n# ^^ ^^\n#\n\ndef _get_fancy_display():\n# see commented display above to understand the process\nlines = []\nlines.append(\"\")\n\n# column letters\ncol_letters = []\nfor col in COLS:\ncol_letters.append(\" %c \" % col) # space, letter, space\n\nlines.append(\" \" + join(col_letters) + \" \") # join here puts a space\n# between each element, but we also need a space for the first\n# column's left edge and the last column's right edge\nlines.append(\"__\" + join([\" \"] * NUM_COLS) + \"__\")\n\n# each row will now display its own left, right and bottom edges,\n# but we need to do it from top down instead of bottom up\nROWS_REVERSED = list(ROWS)\nROWS_REVERSED.reverse()\nfor row in ROWS_REVERSED:\n\n# each square will display its own left and bottom edges\nrow_letters_1 = [] # e.g. | X | | O | X ...\nrow_letters_2 = [] # e.g. +---+---+---+---\n\nrow_letters_1.append(\"|\") # for the left-most outer edge\nrow_letters_2.append(\"|\")\n\nsquares = get_row(row)\nfor square in squares:\nrow_letters_1.append(\"| %c \" % square)\nrow_letters_2.append(\"+---\")\n\nrow_letters_1.append(\"||\") # for the right-most outer edge\nrow_letters_2.append(\"+|\")\n\nlines.append(join(row_letters_1, \"\")) # no space between each\nlines.append(join(row_letters_2, \"\"))\n\nlines.append(\"^^\" + join([\" \"] * NUM_COLS) + \"^^\")\nlines.append(\"\")\n\nreturn lines\n\ndef get_display():\n\"\"\"\nReturns a list of lines that represent the display of the board.\n\"\"\"\n#return _get_simple_display()\nreturn _get_fancy_display()\n\n## Main game code ##\n\ndef play_game():\n\nclear_board()\ncurrent_player = randint(1, 2) # randomly decide who's first\n\n# quick helper function to get the given player's mark\ndef get_mark(player):\nif player == 1:\nreturn PL_1\nelse:\nreturn PL_2\n\nprint \"Connect Four!\"\nprint\n\nplayer1_name = raw_input(\"Player 1, what is your name? \")\nplayer2_name = raw_input(\"Player 2, what is your name? \")\n\n# quick helper function to get the given player's name\ndef get_name(player):\nif player == 1:\nreturn player1_name\nelse:\nreturn player2_name\n\nprint\nprint \"Welcome, %s and %s!\" % (player1_name, player2_name)\nprint \"%s will be %s, and %s will be %s.\" %\\\n(player1_name, PL_1, player2_name, PL_2)\nprint \"By coinflip, %s will go first.\" % get_name(current_player)\nprint\n\nraw_input(\"[Press enter when ready to play.] \")\n\n# quick helper function to print the board\ndef print_board():\nprint join(get_display(), \"\\n\\t\")\n\nprint_board()\n\nwhile not board_filled():\n\nname = get_name(current_player)\nmark = get_mark(current_player)\n\nprompt = \"%s (%c), which column? (e.g. A, a, B, b) \" % (name, mark)\nchoice = raw_input(prompt)\n\nif len(choice) != 1 or upper(choice) not in COLS:\nprint (\"A column is one letter, from %c to %c.\" %\\\n(COLS[0], COLS[-1])), \"Lowercase is fine.\"\nprint \"Please try again.\"\nprint\ncontinue\n\nif get_column(choice)[-1] != EMPTY:\nprint \"Sorry, column %c is already filled.\" % choice\nprint \"Please try again.\"\nprint\ncontinue\n\ndrop_into_column(choice, mark)\n\nprint_board()\n\nif enough_to_win(mark):\nprint \"Congratulations, %s -- you win!\" % name\nprint\nbreak\n\nif board_filled():\nprint \"The board is filled. The game ends in a draw.\"\nprint\nbreak\n\n# now switch players\ncurrent_player = 3 - current_player # sets 1 to 2 and 2 to 1\n\nprint \"Game Over\"\nprint\n\nif __name__ == \"__main__\":\n\nkeep_playing = True\n\nwhile keep_playing:\n\nprint \"+-\" * 37 + \"+\"\nprint\n\nplay_game()\nagain = lower(raw_input(\"Play again? (y/n) \"))\n\nprint\n\nif lower(again) != \"y\":\nkeep_playing = False\n\nprint \"Thanks for playing!\"\nprint"
    },
    {
      "category": "Resource",
      "title": "hangman_lib.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/5db9c3ed1a63646b2a39154bb98947d0_hangman_lib.py",
      "content": "# hangman_lib.py\n# A set of library functions for use with your Hangman game\n#\n# Author: Mihir Kedia\n#\n# The gallows image used by the print_hangman_image(..) function is\n# copyrighted! If you use that function, your program MUST appropriately\n# give credit to the internet artist sk. Have your program print out\n# something akin to \"Art created by sk\" at the beginning or end.\n\ndef print_hangman_image(mistakes = 6):\n\"\"\"Prints out a gallows image for hangman. The image printed depends on\nthe number of mistakes (0-6).\"\"\"\n\nif mistakes <= 0:\nprint''' ____________________\n| .__________________|\n| | / /\n| |/ /\n| | /\n| |/\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\n|\"|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\"|\n| | | |\n: : : :\n. . . .'''\n\nelif mistakes == 1:\nprint''' ___________.._______\n| .__________))______|\n| | / / ||\n| |/ / ||\n| | / ||.-''.\n| |/ |/ _ \\\\\n| | || `/,|\n| | (\\\\\\\\`_.'\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n| |\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\n|\"|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\"|\n| | | |\n: : : :\n. . . .'''\nelif mistakes == 2:\nprint''' ___________.._______\n| .__________))______|\n| | / / ||\n| |/ / ||\n| | / ||.-''.\n| |/ |/ _ \\\\\n| | || `/,|\n| | (\\\\\\\\`_.'\n| | -`--'\n| | |. .|\n| | | |\n| | | . |\n| | | |\n| | || ||\n| |\n| |\n| |\n| |\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\n|\"|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\"|\n| | | |\n: : : :\n. . . .'''\nelif mistakes == 3:\nprint''' ___________.._______\n| .__________))______|\n| | / / ||\n| |/ / ||\n| | / ||.-''.\n| |/ |/ _ \\\\\n| | || `/,|\n| | (\\\\\\\\`_.'\n| | .-`--'\n| | /Y . .|\n| | // | |\n| | // | . |\n| | ') | |\n| | || ||\n| |\n| |\n| |\n| |\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\n|\"|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\"|\n| | | |\n: : : :\n. . . .'''\nelif mistakes == 4:\nprint''' ___________.._______\n| .__________))______|\n| | / / ||\n| |/ / ||\n| | / ||.-''.\n| |/ |/ _ \\\\\n| | || `/,|\n| | (\\\\\\\\`_.'\n| | .-`--'.\n| | /Y . . Y\\\\\n| | // | | \\\\\\\\\n| | // | . | \\\\\\\\\n| | ') | | (`\n| | || ||\n| |\n| |\n| |\n| |\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\n|\"|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\"|\n| | | |\n: : : :\n. . . .'''\nelif mistakes == 5:\nprint''' ___________.._______\n| .__________))______|\n| | / / ||\n| |/ / ||\n| | / ||.-''.\n| |/ |/ _ \\\\\n| | || `/,|\n| | (\\\\\\\\`_.'\n| | .-`--'.\n| | /Y . . Y\\\\\n| | // | | \\\\\\\\\n| | // | . | \\\\\\\\\n| | ') | | (`\n| | ||'||\n| | ||\n| | ||\n| | ||\n| | / |\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\n|\"|\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"|\"|\n| | | |\n: : : :\n. . . .'''\nelse: #mistakes >= 6\nprint''' ___________.._______\n| .__________))______|\n| | / / ||\n| |/ / ||\n| | / ||.-''.\n| |/ |/ _ \\\\\n| | || `/,|\n| | (\\\\\\\\`_.'\n| | .-`--'.\n| | /Y . . Y\\\\\n| | // | | \\\\\\\\\n| | // | . | \\\\\\\\\n| | ') | | (`\n| | ||'||\n| | || ||\n| | || ||\n| | || ||\n| | / | | \\\\\n\"\"\"\"\"\"\"\"\"\"|_`-' `-' |\"\"\"|\n|\"|\"\"\"\"\"\"\"\\ \\ '\"|\"|\n| | \\ \\ | |\n: : \\ \\ : :\n. . `' . .'''\n\nimport random\ndef get_random_word():\n\"\"\"Returns a random word from the file word_list.txt in the same directory\"\"\"\ninput_file = open('word_list.txt','r')\nword_list = [word.strip().lower() for word in input_file.readlines() if word.strip().isalpha() and len(word) > 4]\ninput_file.close()\n\nreturn word_list[random.randint(0,len(word_list)-1)]"
    },
    {
      "category": "Resource",
      "title": "hangman_soln.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/477a7b86e8c50486b48c02363f720bef_hangman_soln.py",
      "content": "# hangman_soln.py\n# Example solution for Project 1: Hangman\n#\n# Aseem Kishore\n#\n# 6.189 - Intro to Python\n# IAP 2008 - Class 5\n\nfrom string import *\nfrom hangman_lib import *\n\n## Constants ##\n\nMAX_MISTAKES = 6\n\n## State variables ##\n\nsecret_word = get_random_word() # from hangman_lib\nletters_guessed = [] # empty list -- no letters guessed initially\nmistakes_made = 0\n\n## Helper functions ##\n\ndef word_guessed():\n\"\"\" Returns True iff the player has successfully guessed the word. \"\"\"\nfor letter in secret_word: # go through each letter in the secret word...\nif letter not in letters_guessed: # check if we've guessed it...\nreturn False # if not, we haven't guessed the word!\nreturn True # if we've gotten here, we've guessed every letter!\n\ndef print_guessed():\n\"\"\" Returns a string of the word with not-guessed letters as dashes. \"\"\"\nlist_of_letters = [] # we'll keep adding letters to this\nfor letter in secret_word: # go through each letter in the secret word...\nif letter in letters_guessed: # check if we've guessed it...\nlist_of_letters.append(letter) # if so, add it!\nelse:\nlist_of_letters.append('-') # otherwise, add a dash\nreturn join(list_of_letters, '') # remember to return the string!\n# to conver to string, use join(...)\n# the second argument means no spaces\n# between the different letters.\n\n## Main game code ##\n\n# Some intro stuff...\n\nprint \"Welcome to Hangman!\"\nprint\n\nfirst_time = lower(raw_input(\"Is this your first time playing Hangman? (y/n) \"))\n\nprint\n\nif first_time == \"y\":\n# it's their first time -- let's give them instructions.\nprint \"The objective of Hangman is to guess a secret word letter by letter.\"\nprint \"If you guess a letter in the word, we'll show you that letter.\"\nprint \"But if you guess wrong, we'll draw part of the hangman's body.\"\nprint \"Don't let his whole body get drawn, or else you lose!\"\nprint\n\nprint \"Great, so you're ready to play. Just two things that might help:\"\nprint \"1) The secret word has\", len(secret_word), \"letters.\"\nprint \"2) It takes\", MAX_MISTAKES, \"wrong guesses to lose.\"\nprint\nprint \"Good luck!\"\nprint\nprint \"[Press enter when ready to play.]\"\nraw_input() # this just waits for them to press enter... they can type\n# other stuff but it doesn't affect anything.\n\nprint_hangman_image(0)\nprint\n\n# On to our main game loop... we can exit out of our loop either by losing\n# (hitting MAX_MISTAKES), or by winning. Let's loop as long as we're under\n# MAX_MISTAKES, and if we win, we'll use the break statement.\n\nwhile mistakes_made < MAX_MISTAKES:\n\n# Each turn, let's display the hangman image, the word with dashes, the\n# letters they've guessed so far, and how many mistakes they have left.\n\nprint\nprint \"The word so far: \", print_guessed()\nprint \"Letters guessed so far:\",\n\n# to print the letters guessed, we'll have to loop over the list\nfor letter in letters_guessed:\nprint letter,\n\nprint\nprint \"Wrong guesses remaining:\", MAX_MISTAKES - mistakes_made\nprint\n\nguess = lower(raw_input(\"What letter will you guess? \"))\n\n# Now we'll only do one of the below actions...\n\nif guess == \"\":\nprint \"You have to guess something...\"\n\nelif len(guess) > 1:\nprint \"You can only guess one letter at a time!\"\n\nelif guess < \"a\" or guess > \"z\":\nprint \"You can only guess letters, not numbers or symbols!\"\n\nelif guess in letters_guessed:\nprint \"You've already guessed this letter!\"\n\nelse: # valid guess!\n\nletters_guessed.append(guess) # so add to our list of guessed letters\n\nif guess in secret_word: # check if letter is in the word...\nprint \"Good guess!\", guess, \"is in the word.\"\nif word_guessed(): # let's see if we've won with this guess...\nprint \"In fact, that's the last letter!\"\nbreak\n\nelse:\nmistakes_made = mistakes_made + 1\nprint \"Sorry, no luck.\", guess, \"is not in the word.\"\nprint\nprint_hangman_image(mistakes_made)\nprint\n\n# Now we're out of the main game loop. As we said above, this means either we\n# guessed wrong too many times, or we won. Let's check.\n\nprint\n\nif mistakes_made >= MAX_MISTAKES:\nprint \"Oh no, you guessed wrong too many times! You lose.\"\nprint \"The word was\", '\"' + secret_word + '\".'\nprint\nprint \"GAME OVER\"\nelse:\nprint \"Congratulations... you win!\"\nprint \"You correctly guessed the word\", '\"' + secret_word + '\".'\n\nprint"
    },
    {
      "category": "Resource",
      "title": "hangman.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/520ca17a052601b88e01377e0e2882ea_hangman.py",
      "content": "from hangman_lib import *\n\n#\n# This file is just a demo of the functions in hangman_lib.\n#\n\nhelp(print_hangman_image)\n\nprint_hangman_image(0)\nprint\nprint_hangman_image(1)\nprint\nprint_hangman_image(2)\nprint\nprint_hangman_image(3)\nprint\nprint_hangman_image(4)\nprint\nprint_hangman_image(5)\nprint\nprint_hangman_image(6)\n\nprint\nprint\n\nhelp(get_random_word)\n\nprint \"Here's a random word\"\nprint get_random_word()\n\nprint \"Here's another\"\nprint get_random_word()"
    },
    {
      "category": "Resource",
      "title": "tictactoe.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/991ff5e639895ef17e012df5cc59d6e0_tictactoe.py",
      "content": "# tictactoe.py\n# A simple two-player command-line implementation of Tic-Tac-Toe.\n#\n# Author: Aseem Kishore\n#\n# No license... free to use, etc.\n#\n#\n# Documentation:\n#\n# For this implementation, I numbered the rows 1, 2 and 3, and lettered the\n# columns A, B and C. Here are two example displays I can show the user:\n#\n# A B C A B C\n#\n# 1 | | 1 / /\n# ---+---+--- or ---/---/---\n# 2 | | 2 / /\n# ---+---+--- ---/---/---\n# 3 | | 3 / /\n#\n# Using this representation, I refer to each square as its (row, col) position.\n# The row must always be one of the integers 1, 2, or 3, and the col must always\n# be one of the strings 'A', 'B' or 'C'.\n#\n# As for the actual implementation of the board, there are a few choices. One is\n# to simply use nine variables, like A1 = ..., A2 = ..., etc. But this isn't\n# clean, and it will make the input cumbersome (e.g. a bunch of if-elif cases to\n# decide which variable to change, based on what the user entered.). A better\n# option is to use a list of 9 elements. The 9 can be numbered in any way, e.g.\n# top-bottom, left-to-right, so board[6] would be the equivalent of (2, 'C').\n# What I chose to go with was a list of three sub-lists, where each sub-list\n# represents a row and contains three elements. So, board[1][2] is the new\n# equivalent of (2, 'C').\n#\n# This implementation is not trivial. I can't easily recognize that board[1][2]\n# is the same as the user's (2, 'C'). Plus, my rows are numbered 1-3, and index\n# values always begin at 0, so there's the potential for an accidental bug. For\n# these reasons, it's always good to use *abstraction* -- hiding the actual\n# implementation, and instead using simple values everywhere rather than actual\n# implementation values (in this case, board[1][2] is an implementation value).\n#\n# To abstract this away, I have a few functions which take care of converting\n# between conceptual values like square 2C and implementation values like\n# board[1][2]:\n#\n# - square(row, col) takes a row and a col and makes a (row, col) tuple out of\n# them. If I use this function everywhere instead of directly making tuples,\n# I enforce that if I ever want to change the implementation (without having\n# to change the conceptual values like square 2C), I can do so here without\n# having to change all the places in my code where I directly made a tuple.\n#\n# - square_row(square) and square_col(col) take care of indexing the tuple and\n# returning the respective values. Again, if I use these functions everywhere\n# instead of directly writing square[0] and square[1], I have the flexibility\n# to do things like change squares' implementation, e.g. from (row, col)\n# tuples to (col, row) tuples, by only changing these functions.\n#\n# - get_square(square) and set_square(square) are the only two functions which\n# actually index board. Both functions convert the row 1-3 to an index 0-2,\n# then convert the column 'A'-'C' to an index 0-2. It's EXTREMELY important\n# that I never index the board directly ANYWHERE else.\n#\n# With these functions, I have taken care of a huge potential for bugs. Now, I\n# no longer have to worry about recognizing that the square (2, 'C') is actually\n# board[1][2]. I can just use the abstract concept of squares everywhere.\n#\n# I used the same abstraction idea for the graphics/display. All the functions\n# dealing with displaying the board are in one area. Moreover, I have multiple\n# functions (for multiple ideas), but only one function would actually be\n# considered \"visible\" or \"public\", and the rest are \"private\" or \"hidden\".\n# This visible function doesn't do anything on its own, only the hidden ones do.\n# But, the visible function serves as a middleman -- it calls one of the hidden\n# ones. By doing this, I am able to easily switch the style of display by only\n# changing one line in the visible function. Take a look to better understand.\n#\n# The rest of the code should be understandable -- it's all stuff you've seen\n# before. If you have any questions, feel free to email me. Enjoy!\n\nfrom random import *\nfrom string import *\n\n## Constants ##\n\nEMPTY = ' ' # the value of an empty square\nPL_1 = 'x' # player 1's mark\nPL_2 = 'o' # player 2's mark\n\nA = 'A' # these just make it easier to keep referring to 'A', 'B' and 'C'\nB = 'B'\nC = 'C'\n\n## State variables ##\n\nboard = [[EMPTY, EMPTY, EMPTY], # board is initially all empty squares,\n[EMPTY, EMPTY, EMPTY], # implemented as a list of rows,\n[EMPTY, EMPTY, EMPTY]] # three rows with three squares each\n\ncurrent_player = randint(1, 2) # randomly choose starting player\n\n## Coordinate system functions ##\n\ndef square(row, col): # squares are represented as tuples of (row, col).\nreturn (row, col) # rows are numbered 1 thru 3, cols 'A' thru 'C'.\n\ndef square_row(square): # these two functions save us the hassle of using\nreturn square[0] # index values in our code, e.g. square[0]...\n\ndef square_col(square): # from this point on, i should never directly use\nreturn square[1] # tuples when working with squares.\n\ndef get_square(square):\n\"\"\" Returns the value of the given square. \"\"\"\nrow_i = square_row(square) - 1 # from values of 1-3 to values of 0-2\ncol_i = ord(square_col(square)) - ord(A) # ord gives the ASCII number\n# (search ASCII on wikipedia!)\nreturn board[row_i][col_i] # note how this and set_square are the ONLY\n# functions which directly use board!\n\ndef set_square(square, mark):\n\"\"\" Sets the value of the given square. \"\"\"\nrow_i = square_row(square) - 1\ncol_i = ord(square_col(square)) - ord(A)\nboard[row_i][col_i] = mark # note how this and get_square are the ONLY\n# functions which directly use board!\n\ndef get_row(row):\n\"\"\" Returns the given row as a list of three values. \"\"\"\nreturn [get_square((row, A)), get_square((row, B)), get_square((row, C))]\n\ndef get_column(col):\n\"\"\" Returns the given column as a list of three values. \"\"\"\nreturn [get_square((1, col)), get_square((2, col)), get_square((3, col))]\n\ndef get_diagonal(corner_square):\n\"\"\" Returns the diagonal that includes the given corner square.\nOnly (1, A), (1, C), (3, A) and (3, C) are corner squares. \"\"\"\nif corner_square == (1, A) or corner_square == (3, C):\nreturn [get_square((1, A)), get_square((2, B)), get_square((3, C))]\nelse:\nreturn [get_square((1, C)), get_square((2, B)), get_square((3, A))]\n\n## Game logic functions ##\n\ndef get_mark(player):\n\"\"\" Returns the mark of the given player (1 or 2). \"\"\"\nif player == 1:\nreturn PL_1\nelse:\nreturn PL_2\n\ndef all_squares_filled():\n\"\"\" Returns True iff all squares have been filled. \"\"\"\nfor row in range(1, 4): # range(1, 4) returns the list [1, 2, 3]\nif EMPTY in get_row(row):\nreturn False # this row contains an empty square, we know enough\nreturn True # no empty squares found, all squares are filled\n\ndef player_has_won(player):\n\"\"\" Returns True iff the given player (1 or 2) has won the game. \"\"\"\n\n# we need to check if there are three of the player's marks in a row,\n# so we'll keep comparing against a list of three in a row.\nMARK = get_mark(player)\nwin = [MARK, MARK, MARK]\n\n# first check horizontal rows\nif get_row(1) == win or get_row(2) == win or get_row(3) == win:\nreturn True\n\n# no horizontal row, let's try vertical rows\nif get_column(A) == win or get_column(B) == win or get_column(C) == win:\nreturn True\n\n# no vertical either, let's try the diagonals\nif get_diagonal((1, A)) == win or get_diagonal((1, C)) == win:\nreturn True\n\nreturn False # none of the above, player hasn't won\n\n## Display functions ##\n\n# Display idea 1 -- straight representation\n#\n# A B C\n#\n# 1 | |\n# ---+---+---\n# 2 | |\n# ---+---+---\n# 3 | |\n#\n\ndef draw_board_straight():\n\"\"\" Returns a straight string representation of the board. \"\"\"\n\n# for ease, we'll define all the squares as constants\nA1, A2, A3 = get_square((1, A)), get_square((2, A)), get_square((3, A))\nB1, B2, B3 = get_square((1, B)), get_square((2, B)), get_square((3, B))\nC1, C2, C3 = get_square((1, C)), get_square((2, C)), get_square((3, C))\n\nlines = []\nlines.append(\"\")\nlines.append(\" \" + A + \" \" + B + \" \" + C + \" \")\nlines.append(\" \")\nlines.append(\"1 \" + A1 + \" | \" + B1 + \" | \" + C1 + \" \")\nlines.append(\" ---+---+---\")\nlines.append(\"2 \" + A2 + \" | \" + B2 + \" | \" + C2 + \" \")\nlines.append(\" ---+---+---\")\nlines.append(\"3 \" + A3 + \" | \" + B3 + \" | \" + C3 + \" \")\nlines.append(\"\")\n\nreturn join(lines, '\\n') # the '\\n' represents a newline\n\n# Display idea 2 -- slanted representation\n#\n# A B C\n#\n# 1 / /\n# ---/---/---\n# 2 / /\n# ---/---/---\n# 3 / /\n#\n\ndef draw_board_slanted():\n\"\"\" Returns a slanted string representation of the board. \"\"\"\n\n# for ease, we'll define all the squares as constants\nA1, A2, A3 = get_square((1, A)), get_square((2, A)), get_square((3, A))\nB1, B2, B3 = get_square((1, B)), get_square((2, B)), get_square((3, B))\nC1, C2, C3 = get_square((1, C)), get_square((2, C)), get_square((3, C))\n\nlines = []\nlines.append(\"\")\nlines.append(\" \" + A + \" \" + B + \" \" + C + \" \")\nlines.append(\" \")\nlines.append(\" 1 \" + A1 + \" / \" + B1 + \" / \" + C1 + \" \")\nlines.append(\" ---/---/--- \")\nlines.append(\" 2 \" + A2 + \" / \" + B2 + \" / \" + C2 + \" \")\nlines.append(\" ---/---/--- \")\nlines.append(\"3 \" + A3 + \" / \" + B3 + \" / \" + C3 + \" \")\nlines.append(\"\")\n\nreturn join(lines, '\\n') # the '\\n' represents a newline\n\n# And now the flexibility of being able to choose either style with one change!\n# This is the power of abstraction -- we abstracted away the task of drawing.\n\ndef draw_board():\n\"\"\" Returns a string representation of the board in its current state. \"\"\"\nreturn draw_board_slanted() # this is the only line we'd have to change.\n#return draw_board_straight() # in fact, if you want to change it, just\n# uncomment one line and comment the other!\n\n## Game functions ##\n\ndef reset_board():\nfor row in (1, 2, 3):\nfor col in (A, B, C):\nset_square(square(row, col), EMPTY)\n\ndef play_game():\n\nglobal current_player # we need the global statement to change variables\n# that are defined OUTSIDE of the current function\n\nreset_board()\ncurrent_player = randint(1, 2)\n\nprint \"Tic-Tac-Toe!\"\nprint\n\nplayer1_name = raw_input(\"Player 1, what is your name? \")\nplayer2_name = raw_input(\"Player 2, what is your name? \")\n\n# quick helper function to print the given player's name\ndef get_name(player):\nif player == 1:\nreturn player1_name\nelse:\nreturn player2_name\n\nprint\nprint \"Welcome,\", player1_name, \"and\", player2_name + \"!\"\nprint player1_name, \"will be\", PL_1 + \", and\", player2_name, \"will be\", PL_2 + \".\"\nprint \"By random decision,\", get_name(current_player), \"will go first.\"\nprint\n\nraw_input(\"[Press enter when ready to play.] \") # just waiting for them to press enter\n\nprint draw_board()\n\nwhile not all_squares_filled():\n\nchoice = raw_input(get_name(current_player) + \", which square? (e.g. 2B, 2b, B2 or b2) \")\n\nif len(choice) != 2:\nprint \"That's not a square. You must enter a square like b2, or 3C.\"\nprint\ncontinue\n\nif choice[0] not in [\"1\", \"2\", \"3\"] and upper(choice[0]) not in [A, B, C]:\nprint \"The first character must be a row (1, 2 or 3) or column (A, B or C).\"\nprint\ncontinue\n\nif choice[1] not in [\"1\", \"2\", \"3\"] and upper(choice[1]) not in [A, B, C]:\nprint \"The second character must be a row (1, 2 or 3) or column (A, B or C).\"\nprint\ncontinue\n\nif choice[0] in [\"1\", \"2\", \"3\"] and choice[1] in [\"1\", \"2\", \"3\"]:\nprint \"You entered two rows! You must enter one row and one column (A, B or C).\"\nprint\ncontinue\n\nif upper(choice[0]) in [A, B, C] and upper(choice[1]) in [A, B, C]:\nprint \"You entered two columns! You must enter one row (1, 2 or 3) and one column.\"\nprint\ncontinue\n\n# if we're here, we have one row and one column, figure out which is which\nif choice[0] in [\"1\", \"2\", \"3\"]:\nrow = int(choice[0])\ncol = upper(choice[1])\nelse:\nrow = int(choice[1])\ncol = upper(choice[0])\n\nchoice = square(row, col) # make this into a (row, col) tuple\n\nif get_square(choice) != EMPTY:\nprint \"Sorry, that square is already marked.\"\nprint\ncontinue\n\n# if we're here, then it's a valid square, so mark it\nset_square(choice, get_mark(current_player))\n\nprint draw_board()\n\nif player_has_won(current_player):\nprint \"Congratulations\", get_name(current_player), \"-- you win!\"\nprint\nbreak\n\nif all_squares_filled():\nprint \"Cats game!\", player1_name, \"and\", player2_name, \"draw.\"\nprint\nbreak\n\n# now switch players\ncurrent_player = 3 - current_player # sets 1 to 2 and 2 to 1\n\nprint \"GAME OVER\"\nprint\n\n## Main program code ##\n\nif __name__ == \"__main__\":\n\nkeep_playing = True\n\nwhile keep_playing:\n\nplay_game()\nagain = lower(raw_input(\"Play again? (y/n) \"))\n\nprint\nprint\nprint\n\nif again != \"y\":\nkeep_playing = False\n\nprint \"Thanks for playing!\"\nprint"
    },
    {
      "category": "Resource",
      "title": "project1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/6b3bd210f97d0a359b72cbacb174028c_project1.pdf",
      "content": "Project: Hangman\nWe're going to write the game of Hangman. This document provides a step-by-step approach to\nhelp you build the game. Use it as much or as little as you want. If you're uncertain, I\nrecommend sticking with the document; however, if you want to try attacking this program on\nyour own, that's great too. Actual coding starts in question 2.\nYou only have to pass in the Hangman code. You don't have to pass in answers to all the\nintermediate questions.\n1. Remember the maximum value trick we covered yesterday? Here's another problem along\nthe same vain:\nLet's say I want to check and see if a number of facts are ALL true. For example, is every\nelement in a list less than 6?\nUse what you learned from yesterday (and the homework) to write a for loop that will\ndetermine if all elements in a variable some_list are less than 6. Check your code using\nsome_list = [1,5,3,4] and on some_list = [5,3,7,5].\nWe can also test if AT LEAST ONE fact is true. Write a for loop that will determine if at least one\nelement in a list is less than 6. Test on [7,8,7,9] and [7,2,5,8]\nThe first is the equivalent of checking A and B and C and D and ... The second is the equivalent\nof checking A or B or C or D or ...\nThrow out this code when you've finished the problem - we just wanted to make sure you can\nsolve problems of this type (you'll need it for Hangman.)\n2. Create a new file hangman.py. We're going to start by storing the state of the game in\nvariables at the top of the program. The state is a complete description of all the information\nabout the game. In Nim, the state would be:\n- The current player\n- How many stones are in the pile\nFor Hangman, we need to store 3 pieces of information:\nsecret_word: The word they are trying to guess (string).\nletters_guessed: The letters that they have guessed so far (list).\nmistakes_made: The number of incorrect guesses they've made so far (int).\nYou can name these something else if you'd like, but use a descriptive name.\n\nFor now, set secret_word to be \"claptrap.\" Once we've finished our program and got it working,\nthen we'll add a prompt at the beginning of the program to let a friend of the user choose the\nword. (This is called incremental programming - instead of trying to get everything right the\nfirst time, we'll get the basic program working then incrementally add small portions of code.)\n\"claptrap\" was selected because it's reasonably long and has duplicate letters -- hopefully that\nwill allow us to catch any bugs we might make.\nQuestion -- why can't we use len(letters_guessed) for mistakes_made?\n1b. Also create a constant variable at the top:\nMax_guesses = 6.\nConstant just means that we won't change it. This isn't enforced by the compiler, so be careful\nnot to accidentally change the value of Max_guesses. My style is to begin variables that I don't\nplan to change with a capital letter -- other people do different things (some would have\nwritten MAX_GUESSES, for example.) Any way works.\nWe can decide what to do with this at the end (should we have an \"easy\", \"medium\", \"hard\"\nmode with different guesses?)\nIdea: At the end of the program, we should change \"claptrap\" to something with more than 6\ndistinct letters to make sure that the program doesn't accidentally increment the number of\nmistakes on a correct guess.\nPre-3. Quickie reminder: Enter the following lines of code in the prompt\nfor i in \"hello\":\nprint i\nfor i in ['a',True,123]:\nprint i\nJust a reminder on how for loops work.\n3. Let's start writing code! Here's our approach..we'll write functions to take care of smaller\ntasks that we need to do in hangman, then use them to write the actual game itself.\nFirst, write the function word_guessed(). word_guessed() will return True if the player has\nsuccessfully guessed the word, and False otherwise.\nExample:\nIf the letters_guessed variable has the value ['a','l','m','c','e','t','r','p','n'], word_guessed() will\nreturn True. If the letters_guessed variable has the value ['e','l','q','t','r','p','n'], word_guessed()\nwill return False.\n\nHint: Obviously, you'll use a loop. There are two things you could loop over -- the letters in\nsecret_word or the letters in letters_guessed. Which one do you want to loop over? Don't just\nguess here, think! One of them makes sense / will be a lot easier than the other. You'll also be\nusing the trick from the first problem.\n4. Try this: type the following commands into the prompt.\ndir()\na = 5\ndir()\nb = 3\nc = 7\na = 14\ndir()\nfrom string import *\ndir()\nWhat does the dir function do?\nWhile still at the prompt, type help(join) and help(lower).\n4b. What lines of code belong in the missing spaces to achieve the desired outcome?\nList1 = ['H','e','a','r']\nmissing\nmissing\nprint string1 #prints 'hear'\n5. Back to Hangman. So you'll want to use the string library. Add from string import * to the top\nof your program.\n6. Now write a function print_guessed() (or whatever you want to name it) that returns a string\nthat contains the word with a dash '-' in place of letters not guessed yet.\nExample:\nIf the letters_guessed variable has the value ['a','p'], the expression print print_guessed() will\nprint --ap--ap.\nIf the letters_guessed variable has the value [], the expression print print_guessed() will print\n--------.\nIf the letters_guessed variable has the value ['a','l','m','c','e','t','r','p','n'], the expression print\nprint_guessed() will print claptrap.\nHint: There are a lot of ways to go about this. One way is to iterate through secret_word and\nappend the character you want to print to a list. Then use the join function to change the list\ninto a string: your last line will look something like return join(character_list, \"\")\n\n7. Now write the main game code. It may help to informally sketch out the code you want to\nwrite, e.g\ncontinually loop {\nprint n guesses left\nprint word\nget letter in lowercase\nhas letter already been guessed?\nis letter in word?\nIf so, what should I do? If not, what should I do?}\n(remember the break statement if you use the continual loop)\n8. Congratulations! You've finished the game. Now we want to make it look pretty so everyone\nelse will be impressed as we are :p. Polish your game a bit (don't just use the word claptrap\nevery time)\nHint: If you put from random import * at the top of your code, you can use the randint(a,b)\nfunction - it returns a random number between a and b (inclusive.) This is optional, though\n(you could just prompt them too.)"
    }
  ]
}