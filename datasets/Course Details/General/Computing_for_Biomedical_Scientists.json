{
  "course_name": "Computing for Biomedical Scientists",
  "course_description": "This course introduces abstraction as an important mechanism for problem decomposition and solution formulation in the biomedical domain, and examines computer representation, storage, retrieval, and manipulation of biomedical data. As part of the course, we will briefly examine the effect of programming paradigm choice on problem-solving approaches, and introduce data structures and algorithms. We will also examine knowledge representation schemes for capturing biomedical domain complexity and principles of data modeling for efficient storage and retrieval. The final project involves building a medical information system that encompasses the different concepts taught in the course.\nComputer science basics covered in the first part of the course are integral to understanding topics covered in the latter part, and for completing the assigned homework.",
  "topics": [
    "Engineering",
    "Biological Engineering",
    "Computational Biology",
    "Computer Science",
    "Health and Medicine",
    "Biomedical Instrumentation",
    "Biomedicine",
    "Engineering",
    "Biological Engineering",
    "Computational Biology",
    "Computer Science",
    "Health and Medicine",
    "Biomedical Instrumentation",
    "Biomedicine"
  ],
  "syllabus_content": "Goals\n\nWith this course, we hope to provide a foundation for scientists interested in using computers for solving biomedical problems. Computing with biomedical data poses unique challenges with respect to data volume, complexity, and uncertainty in data and in domain knowledge. Students taking this course should come away with a grounding in abstraction for problem decomposition and solution formulation, data modeling, and information management. The latter are key to analysis, development, and proper design of information systems.\n\nPrerequisites\n\nBiomedical background and an interest in computing.\n\nProgramming will be done in Java(r); no prior familiarity with Java is assumed.\n\nTextbooks (Required)\n\nSavitch, Walter.\nJava, An Introduction to Computer Science and Programming.\n2nd edition, Prentice Hall, 2000.\n\nMcFadden, Fred R., and Jeffrey Hoffer, and Mary B. Prescott.\nModern Database Management.\n6th edition, Addison-Wesley, 2001.\n\nSupplementary Texts/Readings\n\nAho, Alfred, and Jeffrey Ullman.\nFoundations of Computer Science.\nW. H. Freeman & Co., 1995.\n\nvan Bemmel, Jan H., and Mark A. Musen Springer-Verlag.\nHandbook of Medical Informatics.\n1997.\n\nUllman, Jeffrey D.\nPrinciples of Database and Knowledge-Base Systems.\nVol. 1. W. H. Freeman & Co., 1988.\n\nRelevant papers or readings selected by instructors from: F. Sowa, John.\nKnowledge Representation: Logical, Philosophical, and Computational Foundations.\nBrooks/Cole Pub Co., 1999.\n\nAssignments, Exams and Grading\n\nThere will be weekly homeworks, consisting of programming assignments in Java. Assignments are generally due one week after they are distributed. Assignments submitted up to one week after the due date will get an automatic deduction of 10 points (i.e., if you submit your homework up to a week after the deadline, the maximum score you can receive is 90/100). Assignments submitted between one and two weeks after the deadline will get an automatic deduction of 20 points. Assignments submitted more than 2 weeks after the deadline will receive a score of 0 automatically. Please speak to the instructors if you believe you will need more than 3 weeks to complete an assignment.\n\nThe final grade will be based on homeworks (50%), a mid-term exam (20%) and a final project (30%). The midterm exam will be open book, open notes. Your class participation will also be considered in determining your final letter grade.",
  "files": [
    {
      "category": "Resource",
      "title": "homework1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/54f504cab9f803930b6a70e0c0284459_homework1.pdf",
      "content": "HST 952 Homework 1\n1. A physician with a small practice wants you to write a program that calculates the number of minutes\nhe can spend per appointment. He sees 20 patients each day and works an 8 hour day. He needs 20\nminutes for lunch, and 5 minutes after each patient visit to write up notes. You may assume for this\nexercise that each patient gets an equal amount of time with the physician. Write a simple Java\nprogram that prints out three lines:\na) the number of minutes the physician spends with a patient\nb) the total number of minutes the physician spends a day seeing all 20 patients\nc) the total number of minutes the physician spends a day writing notes\n2. A computer program is intended to take as input a spreadsheet/table (see illustration below for an idea\nof the spreadsheet/table's properties) containing 50 patient lab values. Lab values for different types\nof tests may be stored in the same table. The program should search the table for the potassium lab\nvalue of a patient with patient ID 1919, and if found, store the value to a variable called\npotassiumValue. Write out an algorithm in plain English that describes the steps the computer\nprogram should follow to find and store patient 1919's potassium value.\nPatient ID\nValue\n...\n3. Imagine that in designing a particular hospital's information system, you are asked to come up with an\nobject-oriented model for representing patients at the hospital. Name at least five attributes that a\npatient might have according to your OO model. For the same hospital information system, you are\nasked to come up with an object-oriented representation for nurses employed at the hospital. Name\nfive or more attributes that a nurse might have. You should have at least two attributes for a nurse that\nyou did not list as attributes for a patient. Which attributes of your nurses and patients are common to\nall people? If you were asked to add a representation of physicians to your OO design, how would\nyou do this in such a way that you avoid re-listing those attributes that are common to all people?\n4. The product of two numbers m and n, where m and n are both greater than or equal to 0 can be\ncalculated using addition by observing the following: m*n can be found by adding m n's together\n(e.g., 2*3 can be found by adding three 2's together: 2 + 2 + 2 = 6) or by adding n m's together.\nUsing the observation above, write in pseudo-code\na) an imperative programming style algorithm for determining the product of two numbers using\naddition (in your algorithm, you should make use of variables and assignment)\nb) a declarative programming style algorithm for determining the product of two numbers using\naddition (in this algorithm, you may not make use of variables or assignment)\n(Hint: you may want to review the factorial example shown in class)\nTest type\nSodium\nPotassium\nSodium\n...\n...\n...\nPotassium\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists"
    },
    {
      "category": "Resource",
      "title": "homework2.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/afbbfbfdfa9eee964e6f5d8254bf1744_homework2.pdf",
      "content": "HST 952 Homework 2\n1. rot13 is a simple encryption method that rotates the alphabet by 13 characters (so, for example, 'a'\nbecomes 'n', 'b' becomes 'o', and 'c' becomes 'p', etc.). It is used in some usenet newsgroups (such\nas rec.humor.funny) to encrypt messages that might be deemed offensive. There are other variations\non this simple encryption scheme such as rot10 (rotate by 10 characters) and rot19 (rotate by 19\ncharacters).\na) Write out encrypted versions of the following sentence using rot13 and rot19:\nFive weary quacking ducks hobble past a jinxed maltese shitzu\nb) Write a Java program that accepts as input:\n1. a line of text typed in by a user into a pop-up dialog box and\n2. an integer between 1 and 25 typed in by the user into another pop-up dialog box.\nIf the user types in an integer that is less than 1 or greater than 25, the program should keep\nprompting the user for a value in the right range until s/he inputs such a value. Use Java's built-in\nInteger class to handle the numeric input.\nThe output of the program should be:\n1. a pop-up box that displays an encrypted version of the line of text input by the user using\nrotn where n is the number between 1 and 25 that the user entered.\n2. a pop-up box that displays a decrypted version of the encrypted text using rot(26-n). (If\nyour algorithm is correct, this decrypted text should be the same as the original typed in by\nthe user).\nOnly lower and upper-case characters from the English alphabet ('a' to 'z' and 'A' to 'Z') should\nbe encrypted; spaces, punctuation marks, and all other characters should remain unchanged.\nPlease read section 2.5 of the Savitch text and make use of the JOptionPane class for displaying all\npop-up boxes. Please do not use Java's built-in Character class in solving this problem. To test\nthat your program works correctly, use the sentence from a):\nFive weary quacking ducks hobble past a jinxed maltese shitzu\nRotate it by 5 characters, by 13 characters and by 20 characters (i.e., rot5, rot13, and rot20). Also\ntest your program on the following sentences and write out the results:\n1. Jxu qhuq kdtuh jxu husuyluh-efuhqjeh sxqhqsjuhyijys skhlu yi 0.88.\n(rotate this by 10 characters)\n2. Ojlcxarju(w) = w * Ojlcxarju(w - 1)\n(rotate this by 17 characters)\n2. A hospital lab has a register that contains a list of all patients tested at the lab, their patient ID\nnumbers, first names, last names, dates of birth, addresses, and home telephone numbers. In\naddition, each lab technician (there are 15 in this lab) maintains a separate register for all the tests\ns/he does. Patient test results are stored in a lab technician's register, not in the main register.\nEach technician's register contains the patient ID numbers of all the patients the tech has\nperformed tests on. Next to the patient ID number, the tech writes the name of the administered\ntest, the test result, and the date on which the test was performed. Each lab tech is qualified to\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nperform any test the hospital lab requires. Over time, it is possible for a patient to have tests\nperformed by each of the different lab techs and consequently, have entries present in any or all of\nthe 15 lab technicians' registers.\ni) The lab gets a call from Mr. Daniel Norton asking for the results of his most recent serum\nsodium tests. The receptionist asks him for his demographics. Describe the steps she would\nhave to take to find this lab result for Mr. Norton (her algorithm for finding his most recent\nserum sodium test results), given the lab's record keeping methods. Do not assume that\ndemographics can uniquely identify a patient. However, each patient has a unique patient ID\nnumber.\nThe lab gets many such calls each day and the receptionist is going crazy. The lab director has\nasked you to create an object-oriented computer-based filing system to make record keeping and\nresponses to such calls more efficient. You are allowed to completely discard the current\nrecord keeping system and create a new, efficient design.\n(1) List the classes that you would use in creating this computer-based filing system, the\nattributes and methods of these classes and their types (note that Java has a built-in\nGregorianCalendar class for representing dates and times).\n(2) Write an algorithm that the computer-based filing system would use for finding a patient's\nlab results\n(3) Write out Java definitions of each class you listed in (1) (each class description in a\nseparate file). Store the information on the following three patients into your program code\nby instantiating objects of the appropriate classes:\nii) ID:\n9876BWH\nFirst name:\nDaniel\nLast Name:\nNorton\nDate of birth:\n5/4/1935\nAddress:\n422 Main Street, Anytown, MA 01001\nPhone:\n617-111-1111\nTest name\nDate performed\nResult\nSerum sodium\n9/6/2002\nSerum sodium\n5/15/2002\nSerum potassium\n5/15/2002\n4.5\nTotal cholesterol\n4/1/1999\nTotal cholesterol\n3/20/2001\niii) ID:\n3456MGH\nFirst name:\nJasmeet\nLast Name:\nSidhu\nDate of birth:\n11/30/1965\nAddress:\n95 Washington Street, Springfield, MA 01005\nPhone:\n617-111-2222\nTest name\nDate performed\nResult\nHemoglobin\n6/12/2002\n14.8\nINR\n7/22/2002\n3.6\niv) ID:\n6790TCH\nFirst name:\nAngela\nLast Name:\nSummertop\nDate of birth:\n11/30/1986\n\nAddress:\n815 South Pleasant Street, Amherst, MA 01002\nPhone:\n617-111-3333\nTest name\nDate performed\nResult\nHCG\n4/6/2002\nb) Implement the algorithm in c) using the Java classes you defined. Write a program with a main\nmethod that prints out the result of Mr. Norton's most recent serum sodium test using the classes\nand algorithms you created.\nNote: When we discuss databases later in the semester, other approaches to solving this record-keeping\nproblem will become apparent."
    },
    {
      "category": "Resource",
      "title": "homework3.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/77fb25d638579a01ac8fc711fd67f483_homework3.pdf",
      "content": "HST 952 Homework 3\n1. Complete the class definitions for the Person, Patient, Physician, LabTable, and LabTest classes\nby using the class definition stubs provided. Note that the Patient and Physician classes should be\nsub-classes of the Person class. Write a program that iterates through the lab values described\nbelow, tests whether lab value results require an action to be performed by the primary care\nproviders and alerts the primary care provider if they do by \"sending\" him/her a message (calling\nthe sendMessage method). In addition, it sends another message to the appropriate patients so that\nthey can call their primary care providers. Alerts must be sent in the following conditions:\nSerum sodium\nValue is greater than 140\nSerum potassium\nValue is greater than 5\nTotal cholesterol\nValue is greater than 200\nSerum HCG\nValue is greater than 200000\nHemoglobin\nValue is greater than 18 and less than 12\nINR\nValue is greater than 4.5 and less than 2.5\nBlood urea nitrogen\nValue is greater than 25 and less than 9\nStore the information on the following patients:\ni) ID:\n00-223-45\nFirst name:\nManuel\nLast Name:\nJones\nDate of birth:\n1/1/1938\nGender:\nMale\nPCP:\nCorbin Dallas (see below)\nTest name\nDate performed\nResult\nDate Reported\nSerum sodium\n1/1/2002\n1/2/2002\nSerum potassium\n1/1/2002\n5.1\n1/2/2002\nTotal cholesterol\n1/1/2002\n1/2/2002\nii) ID:\n00-345-12\nFirst name:\nSumeeta\nLast Name:\nSidhu\nDate of birth:\n11/30/1965\nGender:\nFemale\nPCP:\nCorbin Dallas (see below)\nTest name\nDate performed\nResult\nDate Reported\nHemoglobin\n1/1/2002\n10.0\n1/2/2002\nHemoglobin\n6/12/2002\n14.8\n6/13/2002\nINR\n7/22/2002\n3.6\n7/22/2002\niii) ID:\n00-679-56\nFirst name:\nAngela\nLast Name:\nWinterbottom\nDate of birth:\n11/30/1971\nGender:\nFemale\nPCP:\nAlicia Stone (see below)\nTest name\nDate performed\nResult\nDate Reported\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nHCG\n4/6/2002\n4/7/2002\niv) ID:\n00-543-27\nFirst name:\nNita\nLast Name:\nHassan\nDate of birth:\n7/28/1969\nGender:\nFemale\nPCP:\nCraig Abbott (see below)\nTest name\nDate performed\nResult\nDate Reported\nBlood Urea Nitrogen\n5/5/2002\n5/5/2002\nBlood Urea Nitrogen\n5/6/2002\n5/6/2002\nBlood Urea Nitrogen\n5/7/2002\n5/7/2002\nPhysicians\ni.\nFirst name:\nCraig\nLast Name:\nAbbott\nDate of birth: 6/9/1938\nGender:\nMale\nSpecialty:\nNephrologist\nii.\nFirst name:\nAlicia\nLast Name:\nStone\nDate of birth: 8/4/1967\nGender:\nFemale\nSpecialty:\nObstetrician\niii.\nFirst name:\nCorbin\nLast Name:\nDallas\nDate of birth: 2/28/1945\nGender:\nMale\nSpecialty:\nInternist\n2. Modify the program in number 1 so that the following conditions are satisfied:\na) The program can be run on a daily basis and the physicians and patients are not sent the same\nalerts for a particular lab more than once. That is, if they have been sent a message for an\nabnormal lab result once, they should not be sent another message again. Feel free to add any\nadditional attributes/methods to your classes.\nb) Make sure that all patients and physicians are not sent multiple messages in one day. Messages\nfor all abnormal lab values for each patient that are reported within the same day should be sent in\none combined message. Similarly, messages for all abnormal lab values for each patient that are\nreported within the same day should be sent to the physician in one combined message."
    },
    {
      "category": "Resource",
      "title": "homework3stub.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/316289d8714388365878a0e43346e0db_homework3stub.pdf",
      "content": "public class Patient { // make this a derived class of Person\n/* In addition to the attributes of a Person, a Patient has\na patient ID number and a primary care provider\n*/\n/*\ncreate a default constructor and a constructor that\nsets the value of the patient's name, gender, birthdate, and\npatient id number\n*/\n// put get and set methods for each attribute of Patient here\npublic void writeOutput()\n{\n/*\nThe writeOutput() method for a Patient should print values\nrelated to the patient attributes in addition to the original\nstatements from the parent Person class, e.g.:\nMs. Mona Chang is 20 years and 5 months old.\nHer primary care physician is Dr. Corbin Dallas and\nher patient ID number is 00-55-1212.\n*/\n}\n}\npublic class Person {\nprivate String firstName;\nprivate String lastName;\nprivate String gender;\nprivate GregorianCalendar dateOfBirth;\nPerson()\n{\n// set all instance variables to null\n}\nPerson(String fName, String lName, String gdr, GregorianCalendar\ndob)\n{\n// set values of each instance variable\n}\n// put get and set methods for each attribute here\npublic void writeOutput()\n{\n/* Print details about the person as follows:\nFor a person with first name Mona, last name Chang, whose gender\nis female, and date of birth is April 15th 1981, writeOutput()\nshould print the following:\nMs. Mona Chang is 20 years and 5 months old.\nThis implies that a person's title (Mr. or Ms.) in writeOutput()\ndepends on his/her gender.\n*/\n}\n}\npublic class Physician { // make this a derived class of Person\n/* In addition to the attributes of a Person, a Physician has\nan array of at most 15 patients, an array of at most 15\nmessages,\nand a specialty (e.g. surgeon, internist, neurologist, etc.)\n*/\n/*\ncreate a default constructor and a constructor that\nsets the value of the Physician's name, gender, birthdate, and\nspecialty\n*/\n// put get and set methods for each attribute of Physician here\npublic void writeOutput()\n{\n/*\nThe writeOutput() method for a Physician should print values\nrelated to the Physician's attributes and none from the original\nparent class e.g.:\nDr. Corbin Dallas is a neurologist and cares for 20 patients\n*/\n}\npublic void addMessage(String msg)\n{\n// add a message to the Physician's array of messages, making\n// sure that the total number of messages added does not exceed 15\n}\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\n}\npublic class LabTest {\n/*\nUse the tables provided in the homework question to come up\nwith\nattributes, constructors, and other methods for the LabTest\nclass. Make sure to include the patient ID to identify each lab test/result.\n*/\n// create set and get methods for each attribute\npublic void writeOutput()\n{\n/*\nThe writeOutput() method for a LabTest should print out the\ntest's name, date and value\n*/\n}\n}\npublic class LabTable {\n/* The Lab contains an array of all LabTests. Methods should be developed to add a LabTest into the LabTable and to get a LabTest using a Patient\nID#.\n*/\npublic void writeOutput()\n{\n/* This should print how many LabTests are in the table. */\n}\n}"
    },
    {
      "category": "Resource",
      "title": "homework4.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/b33df840e7aefc90426289971657130a_homework4.pdf",
      "content": "HST 952 Homework 4\nThe area under the Receiver Operating Characteristic (ROC) Curve is often used to measure a medical diagnostic test's\naccuracy.\nA medical diagnostic test's, sensitivity, or true positive rate gives the test's ability to detect the presence of a disease. The\ntrue positive rate for the diagnostic test is the total number of patients found to be positive by the diagnostic test divided by\nthe total number of patients who actually have the disease that is being tested for (e.g. if 100 people have a disease and a\nmedical diagnostic test for the disease positively identifies 90 of those people as having the disease, its true positive rate is\n90/100). The 10 misdiagnosed cases are termed false negatives.\nA medical diagnostic test's, specificity, or true negative rate gives the test's ability to detect the absence of a disease. The\ntrue negative rate for the diagnostic test is the total number of patients found to be negative by the diagnostic test divided by\nthe total number of patients who do not have the disease that is being tested for (e.g. if 100 people do not have a disease and\na medical diagnostic test for the disease indicates that only 80 of these people are free of the disease, its true negative rate is\n80/100). The 20 misdiagnosed cases are termed false positives.\nInstead of an absolute value of say 1 for the presence of a disease, and 0 for its absence, the measure of presence or absence\nof a disease in a patient may be given as a value between 0 and 1. When a diagnostic test or measuring device gives a value\non a scale of 0 to 1 instead of an absolute value, its performance becomes dependent on cut-off values. It is not\nimmediately apparent how to choose the right cut-off value for such a test. The area under the ROC curve is helpful in\nchoosing the right cut-off value and determining the performance of the test. A good diagnostic test is one that has few\nfalse positive and false negative rates across a reasonable range of cut-off values between 0 and 1. An ROC curve is a\ngraphical representation of the trade off between the false negative and false positive rates for every possible cut-off. By\ntradition, the plot shows the false positive rate on the X axis and 1 - the false negative rate (i.e., the true positive rate) on the\nY axis.\nFor more information on ROC Curves, see the following paper:\nHanley JA, McNeil BJ. The meaning and use of the area under a receiver operating characteristic (ROC) curve. Radiology.\n1982;143:29-36.\nThis homework involves writing a program to calculate the area under the ROC curve. Input to your program will be a file\ncontaining text corresponding to a medical diagnostic test's results for some patients and the gold standard (actual truth) for\npresence or absence of disease for those patients. The format of the text file's contents will be in two columns as follows\n(with column headings present as specified below):\nTest-result,\nGold-standard\n0.9,\n0.1,\n0.5,\n0.1,\n0.75,\nIn the gold-standard column, a value of 1 corresponds to the presence of disease (i.e., the tested patient actually has the\ndisease in question), and a value of 0 corresponds to the absence of disease (the patient does not have the disease being\ntested for). The output of your program should be the area under the ROC curve for the medical diagnostic test. You\nshould make use of the file I/O classes covered in lecture, the StringTokenizer class, and arrays or Vectors.\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nThe area under the ROC curve can be found geometrically by fitting several trapezoids under the curve, finding the area\nunder each trapezoid, and summing all the trapezoid areas. This often produces results that vary according to the size of the\ntrapezoids used to approximate the area. Since the area under the ROC curve is equivalent to the C-index (Mann-Whitney\nStatistic), we can use an approach other than the geometric one to find it. To find the C-index, we want to examine the test-\nresult and gold-standard columns to find all concordant pairs and ties. We'll refer to the different numbers in the test-\nresult column as predictedValues and the numbers in the gold-standard column as actualValues\nA concordant pair (rowx, rowy) is a pairing of table row numbers such that:\nactualValue(rowx) = 1 and actualValue(rowy) =0, and, predictedValue(rowx) > predictedValue (rowy)\nA tie (rowx, rowy) is a pairing of table row numbers such that:\nactualValue(rowx) = 1 and actualValue(rowy) =0, and, predictedValue(rowx) == predictedValue (rowy)\nIn order to find the area under the ROC curve (C-index), we need to count the number of concordant pairs and the number\nof ties as defined above. We also need to find the total number of pairs in the table. This is given by the number of 1's in\nthe gold standard column multiplied by the number of 0's in the gold-standard column. The equation for the C-index is:\n\nTies\nConcordantPairs + 2\nC - index =\nTotalNumberofPairs\nSteps you could follow for finding the C-index, given an input file as described on page 1, are outlined below:\n-\nCount the number of 1's (patients who have the disease) from the gold standard column\n-\nCount the number of 0's (patients who do not have the disease) from the gold standard column\n-\nDetermine the total number of pairs\n-\n(Let the number in a row of the test-result column be called predictedValue)\n-\n(Let the number in a row of the gold-standard column be called actualValue)\n-\nWhile there are unexamined rows with actualValue == 1\no Pick an unexamined row with actualValue == 1\no Set currentPredictedValue to the unexamined row's predictedValue\no For all rows in the table with actualValue == 0 do\n°\nIf the current row with actualValue == 0 has predictedValue < currentPredictedValue\n-\nIncrement concordantPairs\n°\nIf the current row with actualValue == 0 has predictedValue == currentPredictedValue\n-\nIncrement ties\no Mark the current row with actualValue == 1 as examined\n-\nCalculate the C-index according to the equation above\nYou should test this algorithm out by hand using the values in the table on page 1 to understand how it works. For that\ntable, you should get an area under the ROC curve of 0.3333333.\nNote: The algorithm above is an O(n2) /quadratic time algorithm. There are faster (linear time) but more complicated\nalgorithms (implementation-wise) for this problem. The approach taken above does not allow for calculation of the\nstandard error associated with the C-index."
    },
    {
      "category": "Resource",
      "title": "homework5.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/4ada05d4439d5a5eea7fd80b51664fb6_homework5.pdf",
      "content": "Homework 5\nProblem 1.\nThe following is an excerpt from a real clinical guideline. Please\nrepresent it as a SINGLE well-formed formula (WFF) in propositional logic.\nTesting for diabetes should be considered for all individuals age 45 and\nolder. Testing should be considered at a younger age, in individuals\nwho:\n_ are obese\n_ have a first-degree relative with diabetes\n_ are members of a high-risk ethnic population (African American,\nHispanic, Native American, Asian)\n_ are hypertensive\n_ have an HDL cholesterol level less than or equal to 40 mg/dl and /or a triglyceride level\ngreater than or equal to 150 mg/dl\nProblem 2.\nIf (A == true) {\nif (B == false) {\nC =true\n}\nelse {\nC=false\n}\nelse {\nC = false\n}\nWrite a WFF in propositional logic to represent the logical relation\nbetween A, B and C. (HINT: you may use a truth table.)\nProblem 3.\nUse truth table to determine which of the following formulas are\ntautologies: (see attachment 1)\nC: Congestive Heart Failure\nF: Heart Failure\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nProblem 4. Flow chart is often used to represent clinical algorithms.\nPlease complete the following flow chart base on this well-formed\nformula (WFF): (see attachment 2)\nHR: High risk of lung cancer\nMale: Being of the male gender\nSmoker: having smoked for more than 5 years in their life\nSF: lived with a smoker for more than 5 years in their life\nFH: having a family history of lung cancer\n* Please use each decision box to check only one variable. (as in attachment 3)"
    },
    {
      "category": "Resource",
      "title": "homework5attachments.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/eaef5158b18f7d1d15a95688ef56fa08_homework5attachments.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists"
    },
    {
      "category": "Resource",
      "title": "homework6.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/995a9f359aa69d61cae0090bcb3d45bd_homework6.pdf",
      "content": "Homework 6\nProblem 1.\na: All patients on drug x must have disease y, though not every patient with disease y are\ntreated with drug x.\nb. Disease y only occurs in women.\nc. If a patient is male, he can't be on drug x.\nUse proposition logic and Boolean algebra law to prove that statements a and b imply c.\nProblem 2.\nRepresent the following statement using predicate logic: A point x on a flow cytometry\nhistogram is considered to be a peak point, if and only if there is a point y on the same\nhistogram immediately before x and the value of y is smaller than that of x, and there is a\npoint z on the same histogram immediately after x and the value of z is smaller than that\nof x. Please clearly define all predicates that you use.\n(Hint: Make sure that you are comparing y and z to the same x and make use of the\nquantifiers.)\nProblem 3.\nPlease implement 2 versions of a java program (one bases on the WFF, another bases on\nthe flow chart, in HW5 problem 4) to evaluate if a patient has high risk of lung cancer.\nYour program can gather necessary patient data from a file or pop up dialog box.\nCompare and contrast the use of the 2 different representations of the same knowledge in\nthe context of your coding.\nProblem 4.\nThis problem is due in 2 weeks. You are REQUIRED to work on this problem with your\ngroup as modeling is often a group effort in real life. Each group should turn in only one\nsolution with all group members' names.\nPlease design an object-oriented data model to represent an outpatient visit for an\nelectronic medical record system. You should consider the events that enable an\nencounter, activities during the encounter itself, as well as events triggered by an\nencounter. You should also think about different participants.\nThe document of your model should at least specify the following:\n1. Name and type of Classes\n2. Name and type of attributes of the classes\n3. Description of 1. 2. (In natural language)\n4. Examples of instances\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nPlease include design rationale and open issues (if any) in your document. This is an open\nended problem; however, a set (5 -10) of well thought out classes with well defined\nattributes (5 - 10 per class) will be sufficient for the assignment."
    },
    {
      "category": "Resource",
      "title": "homework7.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/46c657e43855b6e169d4596e290641c2_homework7.pdf",
      "content": "Homework 7\nProblem 1. The follow is an excerpt from a case published on the Web\n(http://www.wits.ac.za/fac/med/pulmonology/case1.htm)\n\"Mrs Z.N. : 35 yr old farmer labourer from the Kwazulu-Natal province. She presented\nwith a one week history of right sided pleuritic chest pain. The onset was sudden. This\nwas associated with a warm flushing feeling and dizziness. There was also a pain in the\nright upper quadrant of her abdomen. There was no history of shortness of breath, cough\nor wheezing. There were no cardiac symptoms, no symptoms of malaise or loss of weight.\nNo history of fevers. She was not a smoker and drank no alcohol. Of note is that she\nadmitted to eating the entrails of the goats that she keeps. On examination, the patient\nwas not distressed. She was heamodynamically stable and apyrexial. She was not\ntachypnoeic. She was clinically pale. Examination of her head and neck showed no\nabnormalities. Her heart was normal. Her chest was tender to percussion and dull in the\nright base. On auscultation of the right lung, the breath sounds were reduced in the base\nwith a small area of amphoric breathing above the dullness. The examination of the\nabdomen was normal with no hepatosplenomegaly present. The neurological\nexamination was normal. There were no skin rashes.\"\na. Encode the case using UMLS concepts. You need to identify the concepts id (cui) and\ntheir semantic types. When a concept belongs to more than more semantic type, pick the\nmore specific category.\nSee UMLS Knowledge Source Server(http://umlsks5.nlm.nih.gov)\n\nPlease represent the concepts and their semantic types in the following format:\nTerm/Concept\nCui\nSemantic Type UI\nFarmer\nC0221460\nProfessional or Occupational\nGroup\n.......\nThe list of concepts does not need to be exhaustive; however, you can and should identify\nat least 25 concepts in the case description.\nb. Please pick 3 semantic types present in the case and, for each type, identify 3 or more\nattributes of concepts/data of each semantic type.\nc. Look up the sources of each concept from the UMLS Knowledge Source Server and\nsave the concepts and their corresponding sources in a file. Write a java program to\nprocess the file and create a summary report on which sources contain which concepts.\nBase on your report, which source vocabulary has the broadest coverage?\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nProblem 2. Read the article on thyroid disease at\n(http://www.medem.com/medlb/article_detaillb.cfm?article_ID=ZZZDMMPX77C&sub_\ncat=501).\na. Please represent the knowledge in the article using UMLS concepts and semantic\nrelations in the following format:\nKnowledge\nConcept\nSemantic Relation\nConcept\nThe thyroid gland\nmakes, stores, and\nreleases two\nhormones - T4\n(thyroxine) and T3\n(triiodothyronine).\nThyroid Gland\n(C0040132)\nProduces\nThyroxine\n(C0040165)\nYou only need to give one or two examples of knowledge involving each different\nsemantic relation; a total of 10 examples are expected. Look up and include CUIs of\nconcepts to ensure that they are UMLS concepts.\nThe definitions of UMLS semantic relations will be emailed to you. The hierarchies for\nsemantic relations in the UMLS semantic network can be found at\nhttp://www.nlm.nih.gov/research/umls/META3.HTML#s34 .\nb. Using the semantic relations of as predicates, select and represent 5 sentences in the\narticle in predicate logic. You can define extra predicates, but include at least one UMLS\nsemantic relation based predicate in each WFF. For example:\nThe thyroid gland makes, stores, and releases two hormones - T4 (thyroxine) and T3\n(triiodothyronine).\nDefine: produces(x,y) = x produces y.\nProduces(thyroid gland, thyroxine) and Produces(thyroid gland, triiodothyronine)"
    },
    {
      "category": "Resource",
      "title": "homework8.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/2e3f67bfb9c6900122e0a51ddc79ed96_homework8.pdf",
      "content": "Homework 8\n1. Design an entity relationship model of a clinical laboratory information system (LIS).\nThe lab is part of a hospital and performs blood and chemistry tests for in-patients\nonly. Physicians place orders using the lab order entry interface and receive a\nunique test request number. The interface provides a menu of tests that the\nphysician can pick from. Note that certain test names represent a collection of tests\nperformed together often (Complete Blood Count includes RBC count, WBC count,\nhemoglobin measurement, hematocrit, etc.).The physician can also specify how\nurgent a test is. The urgency level may be different for various tests in one order.\nThe specimens are collected in tubes at the patient's bedside, labeled with the test\nrequest number and dispatched to the lab. The lab receives the sample and a\ntechnician places it in the auto-analyzer that performs the tests. The auto-analyzer\nhas an interface to the LIS and writes the results of the tests to the LIS database\ndirectly. The results are then sent electronically to the clinical data repository of the\nhospital. When the results are dispatched to the clinical system, the normal ranges\nof all tests are also added to the results. In case of significantly abnormal values\n(such as a very high or very low serum potassium), the lab information system\nautomatically pages the physician with an alert.\nThe proposed lab information system's database is going to be largely independent\nof other clinical information systems. Billing is handled by a separate system so you\nneed not worry about it for this assignment. The E-R model should support the\nfollowing functions:\na. Online test-ordering by referring physicians\nb. Order status tracking such as test_ordered, specimen_received,\ntest_performed, result_reported, order_canceled, specimen_inappropriate.\nc. Test results storage and reporting to the clinical data repository.\nd. Alerts for significantly abnormal values\nRead the above description very carefully as you design the model. Please\ndocument your E-R model appropriately and specify any other constraints and\nbusiness rules. Indicate the unique identifiers for various entities. Grades for this\nassignment will be based on completeness of E-R model, clarity of model, and\nclarity and reasonable completeness of documentation. If you use non-standard\nnotation (I don't encourage it but do it if it makes diagramming easier) for your E-R\nmodel, you must provide a description for your notation. (50 points)\n2. Build a relational model for the E-R model you created in Question 1. Indicate\nprimary and foreign keys. Send me the relations. (25 points)\n3. In the Firebird DBMS, create a database called lab and add the relations you\ncreated in Question 2 as tables in that database. Send me the SQL statements you\nused to create these tables. (25 points)\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/c492d8dc0c036c06d5a4cbff320523ed_lecture1.pdf",
      "content": "HST 952\nComputing for Biomedical Scientists\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nIntroduction\nMedical informatics is interdisciplinary,\nand borrows concepts/ideas from:\n- medicine\n- computer science\n- information science\n- statistics\nThis course focuses mainly on computer science\nconcepts used in medical informatics\n\nIntroduction\nWhy learn computer science basics?\n- May need to design systems that others\nimplement\n- May need to implement prototypes\n- May need to oversee programmers\n- May need to analyze systems/products\n- May need to apply these concepts in your\nresearch projects/future job\n\nCourse overview\nCourse Aims\n- Present basic computer science concepts\nnecessary for understanding and solving\nmedical informatics problems (part 1)\n- Introduce important data and knowledge\nrepresentation methods (part 2)\n- Examine data storage and retrieval issues as\nthey relate to the medical domain (part 3)\n\nOutline\n- Overview of the computer\n- Programming languages and paradigms\n- Solving problems with a computer\n- abstraction\n- algorithms\n- Questionnaires\n\nOverview of the computer\n1) Processor (CPU)\n- Datapath (\"brawn\":\noperations)\n- Control (\"brain\": tells datapath, memory, I/O\ndevices what to do according to the wishes of a\nprogram)\n2) Memory\n(where programs are kept when they are running;\ncontains data needed by running programs)\nperforms arithmetic\n\nOverview of the computer\n3) Input\n(writes data to memory)\n4) Output\n(reads data from memory)\n\nOverview of the computer\nMemory\n(primary)\nInput\nControl\nDatapath\nOutput\nProcessor (CPU)\n\nOverview of the computer\n- Communication with a computer requires the\nuse of electrical signals\n- The easiest signals for a computer to understand\nare off and on\n- The \"alphabet\" for a computer (used in its\nmachine language) consists of two letters that\nrepresent the off and on signals: 0 and 1\n- Each letter is referred to as a binary digit or bit\n\nOverview of the computer\n- Computers respond to/act on instructions\n- Instructions are collections of bits that the\ncomputer understands\n- Early programmers communicated with a\ncomputer in its machine language using binary\nnumbers (very tedious)\n- Communication using symbolic notation that\nwas closer to the way humans think was soon\nadopted\n\nOverview of the computer\n- Programmers created a program called an\nassembler to translate from the new symbolic\nnotation to binary\n- This symbolic notation was called assembly\nlanguage\nThe symbolic instruction:\nadd A, B\nis translated by the assembler to a form the\ncomputer understands:\n\nOverview of the computer\n- Assembly language is still used today\n- It requires a programmer to write one line\nfor every instruction the computer will\nfollow (think like a machine)\n- Using the same ideas that led to assemblers,\nprogrammers created programs called\ncompilers\n\nOverview of the computer\n- Compilers translate a high-level programming\nlanguage (such as C++) to a low-level one (such\nas assembly language)\nHigh-level statement:\nA + B\nAssembly language:\nadd A, B\nMachine language:\n\nOverview of the computer\n- The most important program that runs on any\ncomputer is the operating system (e.g.,\nUnix/Linux, Mac OS, Windows XX, IBM OS/2)\n- The OS manages the execution of every other\nprogram that runs on a computer\n- It recognizes keyboard input, sends output to\ndisplay screens, keeps track of files on disk and\ncontrols peripheral devices such as printers, etc.\n\nSide note on Java\n- Assembly language varies from one type of\ncomputer to another (as does machine language)\n- Traditional compilers compile a program into\nthe version of assembly language that runs on a\nparticular type of computer\n- Running the same program on another type of\ncomputer may require rewriting some of its\nhigh-level code and usually requires recompiling\n\nSide note on Java\n- Time is often spent creating versions of programs\nthat are customized for a particular type of\ncomputer\n- Java compilers translate high-level Java\nstatements to bytecode\n- Bytecode is not customized to any specific type\nof computer (it is architecturally neutral)\n- The idea is that you can write a Java program on\none type of computer and run it on any other\n\nProgramming language paradigms\nMany high-level languages have the following\ncharacteristics:\n- Programming in these languages is issuing\ninstructions/commands (imperatives)\n- There is a notion of modifiable storage\n(variables)\n- Assignment is used to change the state of the\nvariables (and consequently of the program)\n\nProgramming language paradigms\n- Variables and assignment together serve as the\nprogramming language analog of hardware's\nmodifiable storage (computer main memory)\nThis paradigm/pattern of programming is called\nimperative programming\nExamples of imperative languages:\nC, Pascal, C++, Java, Fortran\n\nProgramming language paradigms\nSome other high-level languages have different\ncharacteristics:\n- Programming in these languages is defining or\ndeclaring a solution\n- A programming language analog of hardware's\nmodifiable storage is not an important feature\nThis paradigm is called declarative programming\nExamples of declarative languages:\nCommon Lisp, Scheme, Prolog\n\nExample Problem\nThe factorial problem (for numbers greater\nthan or equal to 0):\n- the factorial of 0 is 1\n- the factorial of any number, n, greater than 0\nis n multiplied by the factorial of n minus 1\n(finding the factorial of a number, n, larger\nthan 0 requires finding the factorial of all\nnumbers between n and 0)\n\nImperative Programming Example\nSolution to the factorial problem for a number n:\n- create a function called factorial-rec that takes n as an\nargument\n- create a variable within factorial-rec called factorial\n- create another variable within factorial-rec called temp\n- if n is 0 return a value of 1 (the factorial of 0 is 1)\notherwise (n is greater than 0)\n- assign the value of n to factorial\n- assign to temp the value of n minus 1\n- return factorial multiplied by factorial-rec(temp)\n\nImperative Programming Example\nPrevious imperative algorithm in Java:\nint factorial-rec(int n) // assume n is a number >= 0\n{\nint factorial;\nint temp;\nif (n = 0) return 1; // factorial of 0 is 1\nfactorial = n;\ntemp = n - 1; // temp stores the next number in the series\nreturn\n}\nfactorial * factorial-rec(temp);\n\nImperative Programming Example\nTrace of factorial of the number 4:\nfactorial-rec(4)\n4 * factorial-rec(3) =\n4 * 3 * factorial-rec(2) =\n4 * 3 * 2 * factorial-rec(1) =\n4 * 3 * 2 * 1 * factorial-rec(0) =\n4 * 3 * 2 * 1 * 1 =\nreturns:\n\nDeclarative Programming Example\nDeclarative version of factorial in Scheme:\n(define (factorial n)\n(if (= n 0) 1\n(* n (factorial (- n 1)))))\nTrace of solution for the number 4:\n(factorial 4) =\n(* 4 (* 3 (* 2 (* 1 1)))) =\n\nObservations\n- Declarative programming is often a more\nintuitive approach to solving a problem\n- Easier to use for certain classes of problems\n(theorem proving, etc.)\n- However, since it does not attempt to mirror real\nhardware storage allocation, memory\nmanagement and speed are sometimes problems\n\nSolving problems with computers\nIn order to create a computer program to solve\na particular problem we must:\n- create a concise description/model of the\nproblem, omitting details irrelevant to\nsolving it (this is an example of abstraction)\n- devise appropriate methods for solving this\nconcise description (create an algorithm)\n\nSolving problems with computers\n- The word algorithm is named for al-Khowarizmi,\na 9th century Persian mathematician\n- An algorithm is a step by step procedure for\nsolving a problem\n- You are all familiar with clinical algorithms or\nalgorithms for cooking (also known as recipes)\n- Creating \"elegant\" algorithms (algorithms that\nare simple and/or require the fewest steps\npossible) is a principal challenge in programming\n\nCreating a simple algorithm\nProblem:\nYou need to share a pizza with five of your\nfriends so that each of you gets a piece of the\nsame size\nSolution:\nVolunteer?\n\nAnother algorithm\nProblem:\nWrite out a step by step description of Euclid's algorithm for\nfinding the greatest common divisor of two non-negative integers,\nX and Y:\nAs long as the value of neither X nor Y is zero, continue\ndividing the larger of the values by the smaller and\nassigning to X and Y the values of the divisor and\nremainder respectively.\nremainder becomes 0 is the greatest common divisor.\nThe final value of X when the\n\nEuclid's GCD Algorithm\nIf x is less than or equal to 0 then stop\nIf y is less than or equal to 0 then stop\nAs long as y is greater than 0 repeat these steps:\nif x is greater than y then numerator = x and divisor = y\notherwise numerator = y and divisor = x\nremainder\nx\ny\nWhen y is equal to 0 the gcd is x\n= numerator modulo divisor\ndivisor\n=\n= remainder\n\nSolving problems with computers\n- The set of steps that define an algorithm must be\nunambiguous (no room for misinterpretation)\n- An algorithm must have a clear stopping point\n(a common mistake for programmers developing\nalgorithms for problems that involve repetitive\ntasks is producing a series of steps that never end\n-- an infinite loop)\n\nAnother problem\nA physician with a small practice wants you to\nwrite a program that calculates the number of\nminutes he can spend per appointment.\npatients each day and works an 8 hour day.\nneeds half an hour for lunch, and 10 minutes after\neach patient visit to write up notes. You may\nassume for this exercise that each patient gets an\nequal amount of time with the physician.\nHe sees 15\nHe\n\nQuestionnaires"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture2.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/23c4fbe7342a97be824b068a0ad1910e_lecture2.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\nHST 952\nComputing for Biomedical Scientists\nLecture 2\n\nObject Oriented Programming\n- In this course, we will examine imperative,\nobject-oriented programming (OOP) using Java\n- Imperative OOP: objects issue commands\n- Object: an entity (car, dog, house, person, etc.)\n- In OOP, data and the methods for manipulating\nthe data are grouped together in an object\n\nObject Oriented Programming\n- To create an OO program we need to identify\n- all the objects that we want to manipulate\n- the properties that these objects have\n- how these objects relate to/interact with each other\n- This process is called data modeling\nExample problem: scheduling mid-term exams\nfor four courses that have some of the same students\nso that no two students have an overlapping exam\n\nObject Oriented Programming\n- Objects are defined using classes -- an object\nis an instance of a class\n- Each class specifies attributes (properties) of\nan object and the object's behavior (via\nmethods)\n- An object can perform actions by invoking\nmethods defined in its class\n\nObject Oriented Programming\n- To perform a task, find an object and send it\na message (a message is a request to\nperform a method)\n- If no appropriate object is available, create\none using an already defined class\n- If no class is available that does what you\nwant, write a new class\n\nA simple Java class\nimport java.io.*;\n/* The SimpleProgram class implements an application\n* that displays \"Hello world!\" to the standard output\n*/\npublic class SimpleProgram {\npublic static void main(String[] args)\n{\n// Display the words \"Hello world!\"\nSystem.out.println(\"Hello world!\");\n}\n}\nMust be saved in a file called SimpleProgram.java\n\nObject Oriented Programming\nOOP follows three main design principles:\n1. Encapsulation (information hiding)\n- Users of an object see only what is absolutely\nnecessary for using that object\n- As an abstraction mechanism, encapsulation frees us\nfrom the details of a particular implementation of an\nobject\n- We can focus on what an object can do (its\ninterface) rather than how it does it\n\nObject Oriented Programming\n2. Polymorphism (e.g., method overloading)\n- an instruction (via a single method name) can be\nissued using different types of objects\n- different actions are performed depending on the\nobjects used\n\nObject Oriented Programming\n3. Inheritance - means by which classes that\nhave common or overlapping properties can\nhave those properties specified just once\n- can base a new class on an existing class with\nmore general properties: e.g., base \"student\" on\n\"person\"\n- common or base class is the superclass\n- new (derived) class is the subclass\n- subclass is usually a specialization of the\nsuperclass\n\nObject Oriented Programming\nHealth care\nprofessional\nPharmacist\nEMT\nNurse\nMedical\nPhysiotherapist\ndoctor\nSurgeon\nPediatrician\nRadiologist\n\nObject Oriented Programming\nProblem: Given a list of shapes, draw them\nNon-OO procedural programming approach (e.g. C,\nPascal):\nfor each shape, s in the list\nif s is a square\nspecify square drawing code\nelse if s is a rectangle\nspecify rectangle drawing code\nelse if s is a circle\nspecify circle drawing code\n\nObject Oriented Programming\nProblem: Given a list of shapes, draw them\nImperative OOP approach (e.g. Java, C++):\nfor each shape, s\ns.draw()\n- There is a base shape class with a draw method\n- Each subclass of shape implements its own\nversion of the draw method so it knows how to\ndraw itself\n\nObject Oriented Programming\nIf we add a new shape to the list using the\nprocedural approach, need to add another\nconditional statement and code for drawing it\nIf we add a new shape in the OOP approach,\nwe only need to implement its draw method\n\nOO Modeling Problem\nA bakery shop sells 5 different types of pastries and\norders common ingredients used to make all\npastry types each week. While all the pastries\nrequire flour, butter, sugar, and eggs, each of the\nfive types of pastries uses one additional\ningredient that the other four don't. All pastries\nare wrapped and the wrapper bar-coded according\nto the pastry type. The store would like you to\ncreate an automated re-ordering program for the\nspecial ingredient: When the store has only 10 of\na particular type of pastry left, an electronic order\nfor its special ingredient should be generated to\nthe particular store that sells this ingredient .\n\nNext Class\nRead Chapter 2 sections 2.1-2.4\nQuestionnaire 2"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture3.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/d2425ce6223526e9bb810dc17132b54f_lecture3.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\nHST 952\nComputing for Biomedical Scientists\nLecture 3\n\nRecap\nAlgorithm:\nA series of unambiguous steps for solving a\nproblem\nObject-oriented programming:\nApproach to programming that relies on\nobjects and interactions among objects\n\nRecap\nObject:\n- Has attributes (properties)\n- Has methods (methods define the way the object\ninteracts with \"the world\")\nEach method associated with an object\nimplements an algorithm that solves a\nparticular problem that is specific to the\nobject\n\nRecap\nClass definition:\n- Provides a template of the attributes and\nmethods associated with a kind of object\n- An object is a specific instantiation of a\nclass\n\nRecap\nExample class: Vehicle\nAttributes might include:\n- Number of wheels\n- Type\n- Color\n- Manufacturer\n- Mileage\nMethods might include:\n- getMileage()\n- setMileage(int miles)\n- setMileage(Vehicle otherv)\n\nRecap\nObjects (instances) of class Vehicle\nVolvoS60\nNumber of wheels : 4\nType: Car\nColor: Blue\nManufacturer: Volvo\nMileage: 5,000 miles\nDodgeNeon\nNumber of wheels : 4\nType: Car\nColor: Green\nManufacturer: Dodge\nMileage: 10,000 miles\n\nRecap\nObjects (instances) of class Vehicle\nHarleyDynaGlide\nNumber of wheels : 2\nType: Motorcycle\nColor: Black\nManufacturer: Harley-Davidson\nMileage: 1,000 miles\nMackVision\nNumber of wheels : 18\nType: Truck\nColor: Red\nManufacturer: Mack\nMileage: 50,000 miles\n\nRecap\nImagine that we want to keep track of how\nmany tons a truck can haul, but are not\ninterested in this for cars or motorcycles\nOne approach to doing this could involve\nmaking the Vehicle class a parent class\n(superclass) of the Car, Motorcycle, and\nTruck (sub)classes\n\nRecap\nAttributes and methods common to all vehicles\nwould be described in the Vehicle class\nAttributes that are specific to a Car, Truck, or\nMotorcycle would be specified in the\nappropriate subclass\nFor our example, the Truck class could have the\nattribute tonnage and methods getTonnage()\nand setTonnage() which the Car and\nMotorcycle classes would not have\n\nThis Lecture\nWe will examine some Java constructs that serve as\nbuilding blocks/tools for implementing an algorithm\nin Java\nJava constructs include:\n- Expressions (boolean, arithmetic, logical, etc.)\n- Operators (comparison, logical, arithmetic)\n- Statements (assignment, branch, loop, etc.)\nOur focus will be on constructs that are important for\ndetermining the flow of control in a program\n\nBoolean Expressions\n- Evaluate to true or false\n- May be used with other language constructs\nto determine the flow of control in a\nprogram\n- Involve comparison operators and/or logical\noperators\n\nComparison Operators\nSymbol\nDescription\n==\nis equal to\n!=\nis not equal to\n<\nis less than\n<=\nis less than or equal to\n>\nis greater than\n>=\nis greater than or equal to\n\nComparison Operators\n- The last four comparison operators may only\nbe used to compare values from ordered\nsequences (numbers, characters)\n- Examples of boolean expressions:\n'y' < 'z'\n(evaluates to true)\n5.9 >= 23\n(evaluates to false)\ntrue == false\n(evaluates to false)\n25 != 25\n(evaluates to false)\n\nLogical Operators\n- Binary operator (requires two operands)\n- Unary operator (requires just one operand)\nSymbol\nDescription\n&&\nand (binary operator)\n||\nor\n(binary operator)\n!\nnot (unary operator)\n\nLogical Operators\n- How the && operator works\ntrue && true evaluates to true\ntrue && false evaluates to false\nfalse && true evaluates to false\nfalse && false evaluates to false\n- Once one of its operands is false, a boolean\nexpression involving && evaluates to false\n\nLogical Operators\n- How the || operator works\ntrue || true evaluates to true\ntrue || false evaluates to true\nfalse || true evaluates to true\nfalse || false evaluates to false\n- Once one of its operands is true, a boolean\nexpression involving || evaluates to true\n\nLogical Operators\n- How the ! operator works\n! true evaluates to false\n! false evaluates to true\n- a boolean expression involving ! evaluates to\nthe opposite of the operand's truth value\n\nLogical Operators\n- ! has the highest precedence\n- && has the next highest precedence\n- || has the lowest precedence\n- may use parentheses to group parts of an\nexpression to force a particular order of\nevaluation\n\nLogical Operators\nWhat do the boolean expressions in these\nassignment statements evaluate to?\nboolean firstBool = true || false && false;\nboolean secondBool = (true || false) && false;\nboolean thirdBool = firstBool || secondBool;\nboolean fourthBool = !true || false;\nboolean fifthBool = !(true && false);\n\nFlow of control\n- May need to write methods that have to choose one\npath out of several possible paths\n(programs for an ATM machine have to choose how much\nmoney to dispense based on your input and balance)\n- May need to repeat an action several times to obtain\na desired result\n(e.g., solution to the GCD problem)\n\nBranching statements\n- Allow us to make a choice of an action given\ntwo or more options\n- Use implicit or explicit boolean expressions in\nmaking the choice\nExamples of Java branching statements:\n- if /if-else statement (uses explicit boolean expr.)\n- switch statement (uses implicit boolean expr.)\n\nif/if-else statement\nSyntax:\nif (boolean expression)\n{\n// perform action1\n}\nelse\n{\n// perform action2\n}\n\nif/if-else statement\n- The actions following the if part of the statement are\nperformed only when the boolean expression\nevaluates to true\n- If the boolean expression evaluates to false, the\nactions following the else part of the statement are\nexecuted (when an else is present)\n- The curly braces group together all the actions to be\nperformed\n- If only one action is to be performed, the curly\nbraces may be omitted\n\nif/if-else statement\nExample:\nif (score < 100)\nSystem.out.println(\"Score is less than 100);\nif (score < 90)\nSystem.out.println(\"Score is less than 90);\nif (score < 80)\nSystem.out.println(\"Score is less than 80);\nwhat happens when score is 50?\n\nif/if-else statement\nif (score < 80)\nSystem.out.println(\"Score is less than 80);\nelse {\nif (score < 90)\nSystem.out.println(\"Score is less than 90);\nelse {\nif (score < 100)\nSystem.out.println(\"Score is less than 100);\n}\n}\nwhat happens when score is 50?\n\nif/if-else statement\nEasier way to write the same sequence of statements:\nif (score < 80)\nSystem.out.println(\"Score is less than 80);\nelse if (score < 90)\nSystem.out.println(\"Score is less than 90);\nelse if (score < 100)\nSystem.out.println(\"Score is less than 100);\nwhat happens when score is 120?\n\nSwitch statement\n- Multi-way branching statement\n- Makes a decision on which branch to take\nbased on the value of an integer or character\nexpression (called the controlling expression)\n- Can be mapped to an equivalent if-else\nsequence (but not always the other way\naround)\n- Syntax next\n\nSwitch statement\nswitch(int or char expression) {\ncase int or char constant:\n// perform action1\nbreak;\ncase int or char constant:\n// perform action2\nbreak;\ndefault:\n// perform action3\nbreak;\n}\n\nSwitch statement\nNote:\n- there is an implicit equality comparison\nbetween the int or char expression in the\nswitch and the constant in a case\n- default case is optional\n- break statement ends each case and is\nnecessary to prevent fall-through\n\nSwitch statement\nExample (firstInitial is a variable of type char):\nswitch(firstInitial) {\ncase 'A':\nSystem.out.println(\"Instructor is Aziz\");\nbreak;\ncase 'O':\nSystem.out.println(\"Instructor is Omolola\");\nbreak;\nExample continued on next slide\n\nSwitch statement\ncase 'Q':\nSystem.out.println(\"Instructor is Qing\");\nbreak;\ndefault:\nSystem.out.println(\"Unknown instructor\");\nbreak;\n}\n\nSwitch statement\nAnother example (myNum is a variable of type int):\nswitch(myNum) {\ncase 1:\nSystem.out.println(\"The number is one\");\ncase 2:\nSystem.out.println(\"The number is two\");\ndefault:\nSystem.out.print(\"The number is neither\");\nSystem.out.println(\" one nor two\");\n}\nWhat happens when myNum is 1?\n\nSwitch statement\nAnother example (myNum is a variable of type int):\nswitch(myNum) {\ncase 1:\nSystem.out.println(\"The number is one\");\ncase 2:\nSystem.out.println(\"The number is two\");\ndefault:\nSystem.out.print(\"The number is neither\");\nSystem.out.println(\" one nor two\");\n}\nWhat happens when myNum is 3?\n\nSwitch statement\nExample: Cases with no breaks (firstInitial is a variable of type char):\nswitch(firstInitial) {\ncase 'A':\ncase 'a':\nSystem.out.println(\"Instructor is Aziz\");\nbreak;\ncase 'O':\ncase 'o':\nSystem.out.println(\"Instructor is Omolola\");\nbreak;\nExample continued on next slide\n\nSwitch statement\ncase 'Q':\ncase 'q':\nSystem.out.println(\"Instructor is Qing\");\nbreak;\ndefault:\nSystem.out.println(\"Unknown instructor\");\nbreak;\n}\nFall-through is desired in this example\n\nLoop Statements\n- Allow us to repeat an action/several\nactions until a particular condition is met\nExamples of Java loop statements:\n- while\n- do-while\n- for\n\nWhile Loop\nSyntax:\nwhile(boolean expression)\n{\n// perform action(s)\n}\n\nWhile Loop\n- The actions in the loop body are performed only\nwhen the boolean expression evaluates to true\n- If the boolean expression is true, the actions are\nperformed until it is false\n- If the boolean expression is never false, we may\nhave an infinite loop (actions performed until\nprogram runs out of memory resources, etc.)\n- This implies that there should be a statement in\nthe body of the loop that alters the loop's course\n\nWhile Loop\nExample:\nint iterator = 0;\nwhile(iterator < 10)\n{\nSystem.out.println(\"Iterator is \" + iterator);\niterator = iterator + 1;\n// another way of writing the line above is iterator += 1\n}\n\nDo-While Loop\nSyntax:\ndo\n{\n// perform action(s)\n} while(boolean expression);\n\nDo-While Loop\n- The actions in the loop body are performed until\nthe boolean expression evaluates to false\n- If the boolean expression is never false, we may\nalso have an infinite loop\n- This implies that there should be a statement in\nthe body of the loop that alters the loop's course\n(ensures that the boolean expression is\neventually false)\n\nDo-While Loop\nExample:\nint iterator = 0;\ndo\n{\nSystem.out.println(\"Iterator is \" + iterator);\niterator = iterator + 1;\n// another way of writing the line above is iterator++\n} while(iterator < 10);\nHow does this differ from the while loop example in terms of what\ngets printed?\n\nFor Loop\nSyntax:\nfor(initializer; boolean expression; update action)\n{\n// perform actions\n}\n\nFor Loop\nExample:\nint iterator;\nfor(iterator = 0; iterator < 10; iterator++)\n{\nSystem.out.println(\"Iterator is \" + iterator);\n}\n\nRead\nChapter 3"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture4.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/fba3452284edf60b021d66081db43bc5_lecture4.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\nHST 952\nComputing for Biomedical Scientists\nLecture 4\n\nOutline\n- Another look at Java built-in operators\n- String and StringBuffer built-in java classes\n- Classes, objects, and methods\n\nTwo Main Kinds of Types in Java\nprimitive data types\n- the simplest types\n- cannot decompose into\nother types\n- have values only, no\nmethods\n- Examples:\nint - integer\ndouble - floating point\nchar - character\nclass types\n- more complex\n- composed of other\ntypes (primitive or\nclass types)\n- have both data and\nmethods\n- Examples:\nString\nStringBuffer\n\nBuilt-in Operators for primitive types\n- Arithmetic (use with int, double, etc.):\n+, -, *, /, %\n- Comparison (use with int, double, char, etc.):\n==, !=, <, <=, >, >=\n- Logical (use with boolean):\n&&, ||, !\n\nSpecialized Assignment Operators\n- A shorthand notation for performing an operation\non and assigning a new value to a variable\n- General form: var <op>= expression;\n- equivalent to:\nvar = var <op> (expression);\n- <op> is +, -, *, /, or %\n- Examples:\namount += 25;\n//amount = amount + 25;\n\nSpecialized Assignment Operators\namount *= 1 + interestRate;\n/*\namount =\namount * (1 + interestRate);\n*/\n- Note that the right side is treated as a unit (as\nthough there are parentheses around the entire\nexpression)\n\nIncrement and Decrement Operators\n- Shorthand notation for common arithmetic operations on\ninteger variables used for counting\n- Some counters count up, some count down\n- The counter can be incremented (or decremented) before\nor after using its current value\nint count;\n++count; //preincrement count: count = count + 1 before using it\ncount++; //postincrement count: count = count + 1 after using it\n--count; //predecrement count: count = count -1 before using it\ncount--; //postdecrement count: count = count -1 after using it\n\nIncrement and Decrement Operators\nExample:\nint x = 5;\nint y = 5;\nint result;\nWhat will be the value of result after each of\nthese executes? (assume each line is independent of\nthe other)\n(a) result = x / ++y;\n(b) result = x / y++;\n(c) result = x + --y;\n(d) result = x + y--;\n\nReturned Values\n- Expressions return values: a number, character, etc.\nproduced by an expression is \"returned\", (it is the\n\"return value.\")\nint firstNumber, secondNumber,\nproductOfNumbers;\nfirstNumber = 5;\nsecondNumber = 9;\nproductOfNumbers = firstNumber *\nsecondNumber;\n(in the last line, firstNumber returns the value 5\nand secondNumber returns the value 9)\n\nReturned Values\nfirstNumber * secondNumber is an\nexpression that returns the integer value 45\n- Similarly, methods return values\nInteger.parseInt(str); is a method of the\nJava built-in class Integer that returns the integer value\nof a string such as \"12\", \"67\", etc.\n\nThe String Class\n- A string is a sequence of characters\n- The String class is used to store strings\n- The String class has methods to operate on strings\n- String constant: one or more characters in double\nquotes\n- Examples:\nchar charVariable = 'a'\nString stringVariable = \"a\";\nString sentence = \"Hello, world\";\n\nThe String Class\n- Individual characters in a variable of type\nString can be accessed but not modified\n- To modify individual characters in a string,\nneed to use a variable of type StringBuffer\n(more to come on class StringBuffer)\n- A complete interface specification of Java's\nbuilt-in classes and their methods (including\nthat of the String class) is at:\nhttp://java.sun.com/j2se/1.3/docs/api/index.html\n\nIndexing Characters within a String\n- The index of a character within a string is\nan integer starting at 0 for the first character\nand gives the position of the character\n- The charAt(Position)method returns\nthe char at the specified position\n- substring(Start, End)method\nreturns the string from position Start to\nposition End\n\nIndexing Characters within a String\n- Example:\nString greeting = \"Hi, there!\";\ngreeting.charAt(0)returns H\ngreeting.charAt(2)returns ,\ngreeting.substring(4,6)returns the\nH i\n,\nt h e r e !\n0 1 2 3 4 5 6 7 8 9\n\nThe StringBuffer Class\n- Implements a modifiable sequence of characters\n- the length and content of the sequence of characters can be\nmodified using its methods\n- has many of the same methods as the String class and a few\nmore (append, insert, replace)\n- To create a new StringBuffer object that initially\nrepresents the string \"rue\" and assign it to a variable\nstrBuffer, of type StringBuffer, write\nStringBuffer strBuffer = new StringBuffer(\"rue\");\n// illegal to write StringBuffer strBuffer = \"rue\"\nor write\nString str = \"rue\";\nStringBuffer strBuffer = new StringBuffer(str);\n\nThe StringBuffer Class\n- Modify the sequence:\nstrBuffer.append('s');\nSystem.out.println(strBuffer); // prints out rues\nSystem.out.println(strBuffer.length()); // prints out 4\nstrBuffer.insert(2, 's');\nSystem.out.println(strBuffer); // prints out ruses\nstrBuffer.insert(1, \"ef\");\nSystem.out.println(strBuffer); // prints out refuses\nSystem.out.println(strBuffer.length()); // prints out 7\nstrBuffer.replace(2, 3, \"-\");\nSystem.out.println(strBuffer); // prints out re-uses\n\nClasses, Objects, and Methods\n- Instance variables\n- Instantiating (creating) objects\n- A look at methods\n- Parameter passing (pass-by-value\nand pass-by-reference)\n- Static methods and static variables\n\nInstance Variables (Data Items)\n- Person class has the following instance variables/data\nitems: firstName, lastName, and age:\npublic String firstName;\npublic String lastName;\npublic double age;\n- public means that there are no restrictions on how\nan instance variable is used\n- private means that the instance variable cannot be\naccessed directly outside the class\n- In general, instance variables should be declared\nprivate instead of public\n\nInstance Variables (Data Items)\npublic class Person\n{\nprivate String firstName;\nprivate String lastName;\npublic double age;\npublic String getFirstName()\n{\nreturn(firstName);\n}\n// other method definitions ...\n}\n\nInstantiating (Creating) Objects\n- Syntax:\nClassName instanceName =\nnew ClassName();\n- Note the keyword new\n- Example: instantiate an object of class Person within the\ndefinition of another class\nPerson newPerson = new Person();\n- Public instance variables can be accessed and modified\nusing the dot operator:\nnewPerson.age = 35.5;\n\nInstantiating (Creating) Objects\n- Private instance variables cannot be modified/accessed in\nthis way:\nnewPerson.firstName = \"B'Elanna\"; //illegal\n- Define public get and set methods in class Person to\nretrieve and modify values of private instance variables:\n- public String getFirstName()\n- public void setFirstName(String fName)\n- public String getLastName()\n- public void setLastName(String lName)\n- To set first and last name instance variables:\n- newPerson.setFirstName(\"B'Elanna\");\n- newPerson.setLastName(\"Torres\");\n\nInstantiating (Creating) Objects\n- To retrieve values of first and last name instance\nvariables:\n- newPerson.getFirstName();\n//returns \"B'Elanna\"\n- newPerson.getLastName();\n//returns \"Torres\"\n- Instance variable age should also be private:\n- private double age;\n- public double getAge()\n- public void setAge(double ageValue)\n\nReturn Type of Methods\n- As seen in previous slides, some methods\nperform an action and return a single value\n- Some methods just perform an action (e.g. print\na message) and do not return a value\n- All methods require that the return type be\nspecified\n- Return types may be:\n- a primitive data type, such as char, int, double\n- a class, such as String, Person, etc.\n- void if no value is returned\n\nReturn Type of Methods\n- You can use a method wherever it is legal to use\nits return type, for example the\ngetFirstName() method of Person\nreturns a String, so this is legal:\nPerson anotherPerson =\nnew Person();\nString name =\nanotherPerson.getFirstName();\n- Also legal:\ndouble age =\nanotherPerson.getAge();\n\nReturn Statement\n- Methods that return a value must execute a return\nstatement that includes the value to return\n- For example:\npublic double getAge()\n{\nreturn age;\n//return(age); could be used instead\n}\nprivate double age = 79.6;\n- A return statement is not required in a method that does\nnot return a value (has a void return type)\n\nGood Programming Practice\n- Start class names with a capital letter\n- Start method names with a lower case\nletter\n- Include comments in your code that\ndescribe\n- what each class does\n- what each method does\n- any unusual/non-intuitive steps taken in\nsolving a problem\n\nThe main Method\n- A program written to solve a problem (rather than define\nan object) is written as a class with one method, main\n- Invoking the class name invokes the main method\n- Example: HelloWorld Class\n- Note the basic structure:\npublic class HelloWorld\n{\npublic static void main(String[] args)\n{\n<statements that define the main method>\n}\n}\n\nThe \"this.\" Operator\n- this. refers to the object that contains the\nreference (an object's way of referring to itself)\n- Methods called in a .java file that gives an\nobject's definition do not need to reference the\nobject\n- In such files, you may omit the use of \"this.\"\nin referring to a method, since it is presumed\n- For example, if answerOne() is a method\ndefined in the class Oracle:\n\nThe \"this.\" Operator\npublic class Oracle\n{\nprivate int firstNum = 5;\nprivate int secondNum = 10;\npublic int answerOne()\n{\nreturn(firstNum + secondNum);\n}\n// code stored in file Oracle.java\n\nThe \"this.\" Operator\npublic int getAnswer()\n{\n/* One way to invoke the answerOne\nmethod defined in this file\n(Oracle.java)is: answerOne();\n*/\n//Another way is to use \"this.\"\nint num = this.answerOne();\nreturn(num);\n}\n} // end class Oracle\n\nCalling an Object's Methods\n- To call a method outside its object definition file,\nin general, a valid object name should precede the\nmethod name\n- For example (in a file other than Oracle.java):\nOracle myOracle = new Oracle();\n//myOracle is not part of the definition\n//code for Oracle\n...\n//dialog is a method defined in Oracle class\nmyOracle.dialog();\n\nLocal Variables and Blocks\n- A block (also called a compound statement) is the set\nof statements between a pair of matching braces\n(curly brackets)\n- A variable declared inside a block is known only\ninside that block\n- it is local to the block, therefore it is called a local\nvariable\n- when the block finishes executing, local variables\ndisappear\n- references to it outside the block cause a compile\nerror\n\nLocal Variables and Blocks\n- Some programming languages (e.g. C and\nC++) allow a variable's name to be reused\noutside the local block\n- this is confusing and not recommended\n- In Java, a variable name can be declared\nonly once for a method\n- although the variable does not exist outside\nthe local block, other blocks in the same\nmethod cannot reuse the variable's name\n\nVariable Declaration\n- Declaring variables outside all blocks but within a\nmethod definition makes them available within all the\nblocks in that method:\npublic void printSomeValue(int n)\n{\nint i=0; // i is available in all blocks (including if and while)\nif (i < n) {\nint j = (i + n) * 50; // j is available only in the if block;\n}\nwhile (j < 50) { // illegal, j is not available outside if block\nSystem.out.println(\"j is \" + j);\nj++;\n}\n}\n\nVariable Declaration\nGood Programming Practice:\n- declare variables just before you use them\n- initialize variables when you declare them\n- do not declare variables inside loops\n- it takes time during execution to create and destroy\nvariables, so it is better to do it just once for loops\n- it is okay to declare loop counters in the\nInitialization field of for loops, e.g.\nfor(int i=0; i <10; i++)...\n- the Initialization field executes only once,\nwhen the for loop is first entered\n\nPassing Values to a Method: Parameters\n- Some methods can be more flexible (and useful) if we\npass them input values\n- Input values for methods are called passed values or\nparameters\n- Parameters and their data types must be specified\ninside the parentheses of the heading in the method\ndefinition\n- these are called formal parameters\n- The calling object must put values of the same data\ntype, in the same order, inside the parentheses of the\nmethod invocation\n- these are called arguments, or actual parameters\n\nParameter Passing Example\n//Definition of method to double an integer\npublic int doubleValue(int numberIn)\n{\nreturn 2 * numberIn;\n}\n//Invocation of the method... somewhere in main...\nint next = 55;\nSystem.out.println(\"Twice next = \" + doubleValue(next));\n- Formal parameter in the method definition:\n- numberIn\n- Argument in the method invocation:\n- next\n\nPass-By-Value:\nPrimitive Data Type Arguments\n- When the method is called, the value of\neach argument is copied (assigned) to its\ncorresponding formal parameter\n- The number of arguments must be the same\nas the number of formal parameters\n- The data types of the arguments must be the\nsame as the formal parameters and in the\nsame order\n\nPass-By-Value:\nPrimitive Data Type Arguments\n- Formal parameters are initialized to the\nvalues passed\n- Formal parameters are local to the method\nfor which they are defined\n- Variables used as arguments cannot be\nchanged by the method\n- the method only gets a copy of the variable's\nvalue\n\nVariables: Class Type vs. Primitive\nType\nWhat does a variable hold?\n- It depends on whether its type is a primitive type or\nclass type\n- A primitive type variable holds the value of the\nvariable\n- Class types are more complicated\n- classes have methods and instance variables\n\nVariables: Class Type vs. Primitive\nType\n- A class type variable holds the memory address\nof the object\n- the variable does not actually hold the value of the\nobject\n- in fact, as stated above, objects generally do not\nhave a single value and they also have methods, so it\ndoes not make sense to talk about an object's\n\"value\"\n\nVariables: Class Type vs. Primitive\nType\n- See handout\n\nAssignment with\nVariables of a Class Type\nklingon.set(\"Klingon ox\", 10, 15);\nearth.set(\"Black rhino\", 11, 2);\nearth = klingon;\nearth.set(\"Elephant\", 100, 12);\nSystem.out.println(\"earth:\");\nearth.writeOutput();\nSystem.out.println(\"klingon:\");\nklingon.writeOutput();\nWhat will the output be?\n(see the next slide)\n\nAssignment with\nVariables of a Class Type\nklingon.set(\"Klingon ox\", 10, 15);\nearth.set(\"Black rhino\", 11, 2);\nearth = klingon;\nearth.set(\"Elephant\", 100, 12);\nSystem.out.println(\"earth:\");\nearth.writeOutput();\nSystem.out.println(\"klingon:\");\nklingon.writeOutput();\nWhat will the output be?\nklingon and earth both print elephant.\nWhy do they print the same thing?\n(see the next slide)\nOutput:\nearth:\nName = Elephant\nPopulation = 100\nGrowth Rate = 12%\nklingon:\nName = Elephant\nPopulation = 100\nGrowth Rate = 12%\n\nklingon.set(\"Klingon ox\", 10, 15);\nearth.set(\"Black rhino\", 11, 2);\nearth = klingon;\nearth.set(\"Elephant\", 100, 12);\nSystem.out.println(\"earth:\");\nearth.writeOutput();\nSystem.out.println(\"klingon:\");\nklingon.writeOutput();\nWhy do they print the same thing?\nThe assignment statement makes earth and\nklingon refer to the same object.\nWhen earth is changed to \"Elephant\",\nklingon is changed also.\nBefore the assignment\nstatement, earth and\nklingon refer to two\ndifferent objects.\nearth\nklingon\nBlack rhino\nKlingon ox\nAfter the assignment\nstatement, earth and\nklingon refer to the\nsame object.\nearth\nklingon\nKlingon ox\n\nAssignment with\nVariables of a Class Type\n- A class variable returns a number\ncorresponding to the memory address where\nthe object with that variable name is stored\n- If two class variables are compared using ==,\nit is their addresses, not their values that are\ncompared!\n- This is rarely what you want to do!\n- Use the class's .equals() method to\ncompare the values of class variables\n\nComparing Class Variables\nPerson firstPerson = new Person();\nfirstPerson.setFirstName(\"Lisa\");\nPerson secondPerson = new Person();\nsecondPerson.setFirstName(\"Barry\");\nif(firstPerson == secondPerson)\n//this compares their addresses\n{\n<body of if statement>\n}\nif(firstPerson.equals(secondPerson)\n//this compares their variable values\n{\n<body of if statement>\n}\n\nPass-by-Reference:\nClass Types as Arguments\n- Class variable names used as parameters in a\nmethod call copy the argument's address\n(not the value) to the formal parameter\n- So the formal parameter name also contains\nthe address of the argument\n- It is as if the formal parameter name is an\nalias for the argument name\n\nPass-by-Reference:\nClass Types as Arguments\n- Any action taken on the formal parameter\nis actually taken on the original argument\n- Unlike the situation with primitive types, the\noriginal argument is not protected for class\ntypes\n\nClass Type as a Method Argument\n//Method definition with a DemoSpecies class\n//parameter\npublic void makeEqual(DemoSpecies otherObject)\n{\notherObject.name = this.name;\notherObject.population =\nthis.population;\notherObject.growthRate =\nthis.growthRate;\n}\n//Method invocation\nDemoSpecies s1 = new\nDemoSpecies(\"Crepek\", 10, 20);\nDemoSpecies s2 = new DemoSpecies();\ns1.makeEqual(s2);\n\nClass Type as a Method Argument\n//Method definition with a DemoSpecies class parameter\npublic void makeEqual(DemoSpecies otherObject)\n{\notherObject.name = this.name;\notherObject.population = this.population;\notherObject.growthRate = this.growthRate;\n}\n//Method invocation\nDemoSpecies s1 = new DemoSpecies(\"Crepek\", 10, 20);\nDemoSpecies s2 = new DemoSpecies();\ns1.makeEqual(s2);\n- The method call makes otherObject an alias\nfor s2, therefore the method acts on s2, the\nDemoSpecies object passed to the method!\n- This is unlike primitive types, where the\npassed variable cannot be changed.\n\nStatic Methods\n- Sometimes there is no obvious object to which a\nmethod should belong (e.g., a method to\ncompute the square root of a number)\n- Use the static keyword in defining such methods\n- Static methods can be called without first\ncreating an object\n- Use the class name instead of an object name to\ninvoke them\n- Static methods are also called class methods\n\nStatic Methods\n- Declare static methods with the static\nmodifier, for example:\npublic static double circleArea(double radius) ...\n- Since a static method doesn't need a calling\nobject, it cannot refer to a (nonstatic) instance\nvariable of its class.\n- Likewise, a static method cannot call a nonstatic\nmethod of its class (unless it creates an object of\nthe class to use as a calling object).\n\nUses for Static Methods\n- Static methods are commonly used to provide\nlibraries of useful and related functions\n- Examples:\n- The different read methods in the SavitchIn class`\n- the Math class\n- automatically provided with Java\n- functions include pow, sqrt, max, min, etc.\n- more details to come\n\nThe Math Class\n- Includes constants Math.PI (approximately\n3.14159) and Math.E (base of natural\nlogarithms which is approximately 2.72)\n- Includes three similar static methods: round,\nfloor, and ceil\n- All three return whole numbers (although they are\nof type double)\n- Math.round returns the whole number nearest its\nargument\n\nThe Math Class\nMath.round(3.3) returns 3.0 and\nMath.round(3.7) returns 4.0\n- Math.floor returns the nearest whole number\nthat is equal to or less than its argument\nMath.floor(3.3) returns 3.0 and\nMath.floor(3.7) returns 3.0\n- Math.ceil (short for ceiling) returns the nearest\nwhole number that is equal to or greater than its\nargument\nMath.ceil(3.3) returns 4.0 and\nMath.ceil(3.7) returns 4.0\n\nStatic Variables\n- Example of a static variable definition:\nprivate static int numTries = 0;\n- Similar to definition of a named constant,\nwhich is a special case of static variables.\n- Static variables may be public or private but\nare usually private for the same reasons\ninstance variables are.\n\nStatic Variables\n- Only one copy of a static variable exists for\na class and it can be accessed by any object\nof the class.\n- May be initialized (as in example above) or\nnot.\n- Can be used to let objects of the same class\ncoordinate (see 2nd handout).\n\nRead\n- Chapter 4"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture5.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/a3e515acfc44ae7d5a52493504e328a0_lecture5.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\nHST 952\nComputing for Biomedical Scientists\nLecture 5\n\nOutline\n- Recursion and iteration\n- Imperative and declarative programming\nrevisited (the factorial problem)\n- Encapsulation/information hiding and Abstract\nData Types (ADTs)\n- Classes, objects, and methods continued\n- Arrays\n\nRecursion and Iteration\n- Some methods have a \"fixed\" number of steps\n(e.g. a method that uses multiplication to square a\nnumber n will use one multiplication no matter how\nlarge n is)\n- Other methods have steps whose size depend on\nthe value of their parameters\n- Recursion strategy: do nearly all the work first;\nthen there will only be a little left to do\ne.g.: to find 52!, have to multiply 53 numbers together,\nwhich requires 52 multiplications. First find 51!\nmultiply 52 numbers - and there is only one\nmultiplication left to be done\n\nRecursion\n- Involves choosing a sub-problem that is of the\nsame form as the main problem\n- To avoid an infinite number of steps with a\nrecursive strategy, must define a base case\n- A base case is one for which there is no sub\nproblem, no further work needs to be done for a\nNote: may have more than one base case\nbase case\nas with the Fibonacci numbers problem\n(in the factorial example, the base case is finding the\nfactorial of 0 -- simply \"return\" the value 1)\n- Basis for recursion is mathematical induction\n\nIteration\n- Iteration strategy: By doing a little bit of work\nfirst, transform your problem into a smaller one\nwith the same solution. Then solve this smaller\nproblem\ne.g.: to find 52!, first multiply two of the 53 numbers to be\nmultiplied and store their product. Now there are only 52 numbers\nto multiply (including the stored product) and 51 multiplications\nleft to do. Multiply the stored product with another number from\nthe remaining 52. Now there are only 51 numbers to multiply.\nRepeat this process of multiplying the product to a number until\nthere is only one number remaining (the factorial) and there are\nzero multiplications left to do.\n\nFactorial example revisited (iteration)\n/* This class implements an imperative programming solution to the\nfactorial problem using iteration\nfactorial(n) = n * factorial(n - 1) and factorial(0) = 1 */\npublic class IterativeFactorial{\npublic static void main(String[] args)\n{\nint factorial = 1; // set initial value of factorial to factorial(0)\nint iterator = 1; // set initial value of loop iterator to 1\nint n = 5;\n// number whose factorial we are finding\nExample continued on next slide\n\nFactorial example revisited (iteration)\nwhile (iterator <= n) {\n/* set the new value of the variable factorial to its current\nfactorial = factorial * iterator++;\n} // end of while ()\niterator incremented after\nits old value has been used\nvalue times the value of the iterator */\n// print out the value of n factorial\nSystem.out.println(\"The factorial of \" + n + \" is \" + factorial);\n} // end of main\n} // end of class IterativeFactorial\n\nFactorial example revisited (iteration)\nTrace of solution for the number 5\n(factorial and iterator are initially 1):\nfactorial\niterator\nAfter first pass\nthrough while loop\nSecond time\nthrough while loop\nFifth time through\nwhile loop\nwhile (iterator <= n)\n{\n}\nfactorial = factorial * iterator++;\n\nFactorial example revisited (iteration)\npublic class IterativeFactorial2{\npublic static void main(String[] args)\n{\nint n = 5;\n// number whose factorial we are finding\nint factorial = n; // set initial value of factorial to n\nint iterator = n; // set initial value of loop iterator to n\nwhile (iterator > 1) {\n/* set the new value of factorial to its current value\ntimes the value of the iterator */\nfactorial = factorial * --iterator;\n} // end of while ()\nSystem.out.println(\"The factorial of \" + n + \" is \" + factorial);\n} // end of main\n} // end of class IterativeFactorial2\niterator decremented before\nits old value has been used\n\nFactorial example revisited (iteration)\nTrace of solution for the number 5\n(factorial and iterator are initially 5):\nfactorial\niterator\nAfter first pass\nthrough while loop\nSince we know that factorial(1) = 1, we could\nset the boolean expression in the while loop\nto (iterator >=2) and save two multiplications\nover the previous example\nwhile loop\nFourth time through\nwhile loop\nwhile (iterator > 1)\n{\nfactorial =\n}\nThird time through\nfactorial * --iterator;\n\nFactorial example revisited (recursion)\n/* This class implements an imperative programming solution to the\nfactorial problem using recursion.\nfactorial(n) = n * factorial(n - 1) and factorial(0) = 1 */\npublic class RecursiveFactorial{\nprivate int factorial = 1;\npublic int findFactorial(int number)\n{ // this method returns the value of the factorial of number\nif (number == 0) {\n// the factorial of 0 is 1 (base case)\nreturn factorial;\n}\nExample continued on next slide\n\nFactorial example revisited (recursion)\nelse {\n// the factorial of n is n * factorial(n - 1)\nfactorial = number * findFactorial(number - 1);\nreturn(factorial);\n}\n} // end of findFactorial method\npublic static void main(String[] args) {\nint n = 5;\n// number for which we are finding the factorial\n/* Since main is a static method, it cannot call findFactorial() directly\nCreate a new RecursiveFactorial object in order to call findFactorial() */\nRecursiveFactorial fact = new RecursiveFactorial();\nSystem.out.println(\"The factorial of \" + n + \" is \" + fact.findFactorial(n));\n}\n} // end of class RecursiveFactorial\n\nFactorial example revisited\n- Both examples shown above are imperative\nprogramming approaches to solving the factorial\nproblem (using recursion and iteration)\n- The declarative approach to the problem given\nin lecture 1 follows (uses recursion)\n\nFactorial example revisited (recursion)\nDeclarative approach (definition using Scheme):\n(define (factorial n)\n(if (= n 0) 1\n(* n (factorial (- n 1)))))\n; applying factorial to a particular number:\n(factorial 5)\n;Value: 120\n\nEncapsulation/Information Hiding\nOne of the 3 cornerstones of object-oriented programming\n- use classes and objects\nfor programming\n- objects include both\ndata items and methods\nto act on the data\n- protect data inside an\nobject (do not allow\ndirect access)\n- use private modifier\nfor instance variable\ndeclarations\n- use public methods to\naccess data\n\nFormalized Abstraction: ADTs\nADT: Abstract data type\n- A data type (in Java, a class) that is written using good\ninformation hiding/encapsulation techniques\n- This Object-Oriented approach is used by several\nlanguages\n- An ADT provides a public user interface so the user\nknows how to use the class\n- user interface has descriptions, parameters, and names of\nthe class's methods\n- Changes to a class implementation should not affect\ncode that uses the class\n\nFormalized Abstraction: ADTs\n- Method definitions are usually public but specific\nimplementation details are always hidden from the user\n- The user cannot see or change the implementation\n- The user only sees the interface, also called the\napplication programmer interface (API)\n- Prevents programming errors (e.g., user inadvertently\nchanging the value of a public instance variable by\nusing = instead of == for a comparison)\n- Sharing API spares an end user from having to read\nthrough source code to understand how a class's\nmethods work\n\nFormalized Abstraction: ADTs\nTo create ADTs in Java that are used by others via an API:\n- Use the private modifier when declaring instance\nvariables\n- Do not give the user the class definition (.java) file\n- Do give the user the interface - a file with just the class\nand method descriptions and headings\n- the headings give the names and parameters of the\nmethods\n- it tells the user how to use the class and its methods\n- it is all the user needs to know\n- the Java utility javadoc can be used to create the\ninterface description file\n\nProgramming Tips for\nWriting Methods\n- Use public and private modifiers judiciously\n- If a user will need the method, make it part of the\ninterface by declaring it public\n- If the method is used only within the class definition\n(i.e., it is a helper method, then declare it private)\n- Create a main method with diagnostic (test) code\nwithin a class's definition\n- run just the class to execute the diagnostic program\n(to make sure that it works the way it ought to)\n- when the class is used by another program the class's\nmain is ignored\n\nTesting a Method\n- Test programs are sometimes called driver programs\n- Keep it simple: test only one new method at a time\n- driver program should have only one untested\nmethod\n- If method A uses method B, there are two\napproaches:\n- Bottom up\n- test method B fully before testing A\n\nTesting a Method\n- Top down\n- test method A and use a stub for method B\n- A stub is a method that stands in for the final version\nand does little actual work. It usually does something\nas trivial as printing a message or returning a fixed\nvalue. The idea is to have it so simple you are nearly\ncertain it will work.\n\nMethod Overloading\n- The same method name has more than one\ndefinition within the same class\n- Each definition must have a different signature\n- different argument types, a different number of\narguments, or a different ordering of argument\ntypes\n- The return type is not part of the signature and\ncannot be used to distinguish between two\nmethods with the same name and parameter\ntypes\n\nSignature\n- The combination of method name and number and\ntypes of arguments, in order\n- equals(Person) has a different signature than\nequals(String)\n- same method name, different argument types\n- myMethod(1) has a different signature than\nmyMethod(1, 2)\n- same method name, different number of\narguments\n\nSignature\n- myMethod(10, 1.2) has a different signature\nthan myMethod(1.2, 10)\n- same method name and number of arguments,\nbut different order of argument types:\n(int, double) vs. (double, int)\n\nOverloading and Argument Type\n- Accidentally using the wrong datatype as an\nargument can invoke a different method than\ndesired\n- For example, say we have defined a Pet class\n(there's one defined in the Java text)\n-set(int) sets the pet's age in whole years\n-set(double) sets the pet's weight in\npounds\n-set(String, int, double) sets the\npet's name, age, and weight\n\nOverloading and Argument Type\n- You want to set the pet's weight to 6 pounds:\n-set(6.0) works as you want because the\nargument is type double\n-set(6) will set the age to 6, not the weight,\nsince the argument is type int\n- If Java does not find a signature match, it\nattempts some automatic type conversions,\ne.g. int to double\n- An unwanted version of the method may\nexecute\n\nOverloading and Argument Type\nStill using the Pet example of overloading:\n- What you want: name \"Scamp\", weight 2, and age 3\n- But you make two mistakes:\n1. you reverse the age and weight numbers, and\n2. you fail to make the weight a type double\n- Remember: set(String, int, double)\nsets the pet's name, age, and weight\n- set(\"Scamp\", 2, 3) does not do what you\nwant\n\nOverloading and Argument Type\n- set(String, int, double) sets the pet's\nname, age, and weight\n- set(\"Scamp\", 2, 3)\n- it sets the pet's age = 2 and the weight = 3.0\n- Why?\n- set has no definition with the argument types\nString, int, int\n- However, it does have a definition with String,\nint, double,\nso it promotes the last number, 3, to 3.0 and\nexecutes the method with that signature\n\nConstructors\n- A constructor is a special method designed to\ninitialize instance variables\n- Automatically called when an object is created using\nnew\n- Has the same name as the class\n- Often overloaded (more than one constructor for the\nsame class definition)\n- different versions to initialize all, some, or none\nof the instance variables\n- each constructor has a different signature (a\ndifferent number or sequence of argument types)\n\nDefining Constructors\n- Constructor headings do not include the word\nvoid\n- In fact, constructor headings do not include a\nreturn type\n- A constructor with no parameters is called a\ndefault constructor\n- If no constructor is provided by the class creator,\nJava automatically creates a default constructor\n- If any constructor is provided, then no constructors\nare created automatically\n\nDefining Constructors\nProgramming Tip\n- Include a constructor that initializes all\ninstance variables\n- Include a constructor that has no\nparameters (that is, include your own\ndefault constructor)\n\nConstructor Example\npublic class Person\n{\nprivate String firstName;\nprivate String lastName;\nprivate GregorianCalendar dateOfBirth;\n. . .\npublic Person(String fName)\n{\nfirstName = fName;\nlastName = null;\ndateOfBirth = null;\n}\nSample use:\nNull is a special constant that\nbe assigned to any variable of\nany class type. It is a place\nholder for an object's address\nPerson person1 = new Person(\"Eric\");\n\nConstructor Example\n{\ndateOfBirth = null;\n} Sample use:\npublic Person(String fName, String lName)\nfirstName = fName;\nlastName = lName;\nPerson person2 = new Person(\"Eric\",\"LeRouge\");\n{\ndateOfBirth = dob;\n}\nSample use:\nPerson person3 = new Person(\"Eric\",\"LeRouge\",\nnew GregorianCalendar(1965, 8, 21, 0, 0, 0));\npublic Person(String fName, String lName,\nGregorianCalendar dob)\nfirstName = fName;\nlastName = lName;\n\nConstructor Example\npublic Person()\n{\nfirstName = null;\nlastName = null;\ndateOfBirth = null;\n}\nSample use:\nPerson person4 = new Person();\nThis is the default constructor\n\nUsing Constructors\n- The keyword new must precede a call to a\nconstructor\n- If you want to change values of instance\nvariables after you have created an object using\na constructor, you must use other methods (e.g.\ndefined set methods) for the object\n- you cannot call a constructor for an object after it is\ncreated\n- set methods should be provided for the purpose of\nchanging values of instance variables\n\nArrays\n- An array: a single name for a collection of data values,\nall of the same data type\n(it is a collection of variables that have the same type)\n- Arrays are a carryover from earlier programming\nlanguages (e.g. C, C++)\n- Array: more than a primitive type, less than an object\n- they work like objects when used as method arguments\nand return types (i.e., arrays are reference types)\n- they do not have or use inheritance\n- they are sort of like a Java class that is not fully\nimplemented\n- Arrays are a natural fit for loops, especially for loops\n\nCreating Arrays\n- General syntax for declaring an array:\nBase_Type[] Array_Name = new\nBase_Type[Length];\n- Examples:\n80-element array with base type char:\nchar[] symbol = new char[80];\n100-element array of doubles:\ndouble[] realNums = new double[100];\n90-element array of type Person:\nPerson[] people = new Person[90];\n\nThree Ways to Use [ ] (Brackets)\nwith an Array Name\n1. To create a type name, e.g. int[] pressure; creates a name\npressure with the type \"int array\"\n- note that the types int and int array are different\n- int array is the type of the name pressure\n- the type of the data that can be stored in pressure is int\n2. To create a new array, e.g. pressure = new int[100];\n3. To name a specific element in the array\n- also called an indexed variable, e.g.\npressure[3] = 55;\nSystem.out.println(\"You entered\" +\npressure[3]);\n\nSome Array Terminology\ntemperature[n + 2]\ntemperature[n + 2]\ntemperature[n + 2]\nArray name\nIndex\nsubscript\nint,\nan int\nIndexed variable\nelement or subscripted variable\nValue of the indexed variable\n- also called a\n- must be an\n- or an expression that evaluates to\n- also called an\n- also called an element of the array\ntemperature[n + 2] = 32;\nNote that \"element\" may refer to either a single indexed\nvariable in the array or the value of a single indexed variable.\n\nArray Length\n- The length of an array is specified by the\nnumber in brackets when it is created with new\n- it determines the amount of memory allocated\nfor the array elements (values)\n- it determines the maximum number of elements\nthe array can hold\n- storage is allocated whether or not the elements\nare assigned values\n\nArray Length\n- The array length can be read with the instance\nvariable length, e.g. the following code\ndisplays the number 20 (the size, or length of the\nPerson array, morePeople):\nPerson[] morePeople = new Person[20];\nSystem.out.println(morePeople.length);\n- The length attribute is established in the\ndeclaration and cannot be changed unless the\narray is redeclared\n\nInitializing an Array's Values\nin Its Declaration\n- Array elements can be initialized in the declaration\nstatement by putting a comma-separated list in braces\n- Uninitialized elements will be assigned some default\nvalue, e.g. 0 for int arrays\n- The length of an array is automatically determined\nwhen the values are explicitly initialized in the\ndeclaration\n- For example:\ndouble[] realNums = {5.1, 3.02, 9.65};\nSystem.out.println(realNums.length);\n- displays 3, the length of the array realNums\n\nSubscript Range\n- Array subscripts use zero-numbering\n- the first element has subscript 0\n- the second element has subscript 1\n- etc. - the nth element has subscript n-1\n- the last element has subscript length-1\n- For example:\nint[] scores = {97, 86, 92, 71};\nSubscript: 0\nValue: 97 86 92 71\n\nSubscript out of Range Error\n- Using a subscript larger than length-1 causes\na run time (not a compiler) error\n- an ArrayOutOfBoundsException is thrown\n- you do not need to catch this exception\n- you need to fix the problem and recompile your code\n- Some programming languages, e.g. C and C++,\ndo not even cause a run time error\n- one of the most dangerous characteristics of these\nlanguages is that they allow out of bounds array\nindexes\n\nInitializing Array Elements in a Loop\n- Array processing is easily done in a loop\n- A for loop is commonly used to initialize array elements\n- Example:\nint i;//loop counter/array index\nint[] a = new int[10];\nfor(i = 0; i < a.length; i++)\na[i] = 0;\n- note that the loop counter/array index goes from 0 to\nlength - 1\n- it counts through length = 10 iterations/elements\nusing the zero-numbering of the array index\n\nArrays, Classes, and Methods\nAn array of a class can be declared\nand the class's methods applied to\nthe elements of the array.\npublic void printFirstNames()\n{\nint numberOfPeople = 50;\nPerson[] people = new Person[numberOfPeople];\nfor (int i = 0; i < numberOfPeople; i++)\n{\npeople[i] = new Person();\n//readInfo allows us to set the attributes of a person\npeople[i].readInfo();\n//writeInfo allows us to print the attributes of a person\nSystem.out.println(people[i].writeInfo());\n}\n}\neach array element is\na Person instance\nvariable\nuse the readInfo\nmethod of Person\ncreate an array of\nPersons\nuse the writeInfo\nmethod of Person\n\nArrays and Array Elements\nas Method Arguments\nArrays and array elements can be used with\nclasses and methods just like other objects\n- both an indexed element and an array name\ncan be an argument in a method\n- methods can return an array value or an\narray name\n\npublic static void main(String arg[])\nIndexed\n{\nString scoreString =\nVariables\nJOptionPane.showInputDialog(OEnter your grade\\nO);\nint firstScore = Integer.parseInt(scoreString);\nas Method\nArguments\n]\n;\n(\n;\n)\n[i]\n(\n;\n)\n{\n);\n}\n}\n(\n)\n{\n;\n}\nnextScore is\nan array of\nints\nan element of\nnextScore is\nused as an\nargument of\nmethod average\naverage\nmethod definition\nModification of ArgumentDemo\nint[\nnextScore = new int[3];\nint i\ndouble possibleAverage;\nfor i = 0; i < nextScore.length i++\nnextScore\n= 80 + 10*i;\nfor i = 0; i < nextScore.length i++\npossibleAverage = average(firstScore, nextScore[i]);\nSystem.out.println(\"If your score on exam 2 is \"\n+ nextScore[i]);\nSystem.out.println(\"your average will be \"\n+ possibleAverage\npublic static double average int n1, int n2\nreturn (n1 + n2)/2.0\nprogram in text\n\nWhen Can a Method Change an\nIndexed Variable Argument?\nRemember:\n- primitive types are call-by-value\n- only a copy of the value is passed as an argument in a method\ncall\n- so the method cannot change the value of the indexed variable\n- class types are reference types; they pass the address of\nthe object when they are an argument in a method call\n- the corresponding argument in the method definition becomes\nanother means of accessing the object's contents (another\n\"key\" for the same mailbox)\n- this means the method has access to the object's contents\n- so the method can change the values associated with the\nindexed variable if it is a class (and not a primitive) type\n\nArray Names as Method Arguments\nWhen using an entire array as an argument to a\nmethod:\n- use just the array name and no brackets (this passes\nthe memory address of the array's first element)\n- as described in the previous slide, the method has\naccess to the original array contents and can change\nthe value of its elements\n- the length of the array passed can be different for\neach call\n- when you define the function you do not know the\nlength of the array that will be passed\n- so use the length attribute inside the method to avoid\nArrayIndexOutOfBoundsExceptions\n\nExample: An Array as an Argument\nin a Method Call\npublic static void\nshowArray(char[] a)\n{\nint i;\nfor(i = 0; i < a.length; i++)\nSystem.out.println(a[i]);\n}\nthe method's argument is\nthe name of an array of\ncharacters\nuses the length attribute\nto control the loop\nallows different size arrays\nand avoids index-out-of-\nbounds exceptions\n\nArguments for the Method main\n- The heading for the main method shows a\nparameter that is an array of Strings:\npublic static void main(String[] args)\n- When you run a program from the command\nline, all words after the class name will be\npassed to the main method in the args array:\njava TestProgram Josephine Student\n\nArguments for the Method main\n- The following main method in the class\nTestProgram will print out the first two\narguments it receives:\n{\nSystem.out.println(\"Hello \" + args[0] + \" \" + args[1]);\n}\npublic static void main(String[] args)\n- In this example, the output from the command line\nabove will be:\nHello Josephine Student\n\nUsing = with Array Names:\nRemember They Are Reference Types\nint[] a = new int[3];\nb = a;\na[2] = 10;\n2 2\n10 10\nint[] b = new int[3];\nfor(int i=0; i < a.length; i++)\na[i] = i;\nSystem.out.println(a[2] + \" \" + b[2]);\nSystem.out.println(a[2] + \" \" + b[2]);\nThe output for this code will be:\nThis does not create a\ncopy of array a\nb another way of\nassociated with array a.\nIf we change a stored value\nusing a,we retrieve the\nchanged value when we\nuse b for access\n; it makes\naccessing the values\n\nUsing == with Array Names:\nRemember They Are Reference Types\nint i;\nint[] a = new int[3];\nint[] b = new int[3];\nfor(i=0; i < a.length; i++)\na[i] = 0;\nfor(i=0; i < b.length; i++)\nb[i] = 0;\nif(b == a)\nSystem.out.println(\"a equals b\");\nelse\nSystem.out.println(\"a does not equal b\");\na and b are both\n3-element arrays of ints\nall elements of a and b are\nassigned the value 0\ntests if the\nof a\nand b are equal,\nnot if the array\nThe output for this code will be \" a does not equal b\"\nbecause the addresses referenced by the arrays are not the same.\naddresses\nvalues are equal\n\nTesting Two\nArrays for\nEquality\n- To test two arrays for\nequality you need to\ndefine an equals\nmethod that returns\ntrue if and only if the\narrays have the same\nlength and all\ncorresponding values\nare equal\n- This code shows an\nexample of such an\nequals method.\n)\n{\n)\n;\n{\n//\n;\n{\n;\n;\n}\n}\n;\n}\npublic static boolean equa ls(int[] a, int[] b\nboolean match;\nif (a.length != b.length\nmatch = false\nelse\nmatch = true;\ntentatively\nint i = 0\nwhile (match && (i < a.length))\nif (a[i] != b[i])\nmatch = false\ni++\nreturn match\n\nMethods\nthat Return\nan Array\n- Yet another example\nof passing a\nreference\n- Actually, it is the\naddress of the array\nthat is returned\n- The local array name\nwithin main\nprovides another\nway of accessing the\ncontents of the\noriginal array\n{\n(\n[])\n{\n[] c;\n;\n(\n;\n;\n;\n}\n]\n{\n[]\n[\n[\n;\n[\n;\n[\n[\n[\n;\n}\n}\nc, newArray, and\nthe return type of\nvowels are\nall the same type:\nchar array\npublic class returnArrayDemo\npublic static void main String arg\nchar\nc = vowels()\nfor int i = 0 i < c.length i++)\nSystem.out.println(c[i])\npublic static char[ vowels()\nchar newArray = new char 5];\nnewArray 0] = 'a'\nnewArray 1] = 'e'\nnewArray 2] = 'i';\nnewArray 3] = 'o';\nnewArray 4] = 'u';\nreturn newArray\n\nRead\n- Chapter 5 -- sections 5.1 - 5.7\n- Chapter 6 -- sections 6.1 - 6.2"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture6.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/2fff8255d9ea69aac1e30dd684ba1574_lecture6.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\nHST 952\nComputing for Biomedical Scientists\nLecture 6\n\nDesigning Methods:\nTop-Down Design\n- In pseudocode, write a list of subtasks that the method must\nperform\n- If you can easily write Java statements for a subtask, you are\nfinished with that subtask\n- If you cannot easily write Java statements for a subtask, treat\nit as a new problem and break it up into a list of subtasks\n- Eventually, all of the subtasks will be small enough to easily\ndesign and code\n- Solutions to subtasks might be implemented as private helper\nmethods\n- Top-down design is also known as divide-and-conquer or\nstepwise refinement\n\nDesigning Methods:\nTop-Down Design\n- Person class has attributes of type String and\nGregorianCalendar corresponding to a person's first name,\nlast name, and date of birth: firstName, lastName, and\ndateOfBirth\n- Create a new method:\ndouble ageOfPerson()\nfor the Person class that returns the approximate age (with\nrespect to year and month of birth) of a person. Approximate\nin this case means that if a person was born in September of\n1965 and the current month and year are September 2002, the\nage returned should be 37.0 (the actual day of the month on\nwhich the person was born is ignored).\nWhat tasks should this method perform?\n\nDesigning Methods:\nTop-Down Design\nSome tasks this method should perform:\n- find out the current year\n- find out the current month\n- find out the birth year\n- find out the birth month\n- find out the age using these values\n- subtract the birth year and month\nfrom the current year and month\n- return the value obtained as the\nage\n\nageOfPerson() method\npublic double ageOfPerson()\n{\n// The GregorianCalendar class default constructor creates\n// a new date and time corresponding to the date and time\n// the program in which it is called is executed\nGregorianCalendar today = new GregorianCalendar();\n// Calendar is a parent class to GregorianCalendar\n// YEAR is a static named constant of the Calendar class\nint thisYear = today.get(Calendar.YEAR);\nint birthYear = dateOfBirth.get(Calendar.YEAR);\n// Java Gregorian Calendar month is zero based -- Jan==0\nint thisMonth = today.get(Calendar.MONTH);\nint birthMonth = dateOfBirth.get(Calendar.MONTH);\ndouble age = (thisYear - birthYear) + ((thisMonth - birthMonth)/12.0);\nreturn(age);\n}\n\nageOfPerson() method\npublic double ageOfPerson()\n{\n// The GregorianCalendar class default constructor creates\n// a new date and time corresponding to the date and time\nThe Person class definition\n// the program in which it is called is executed\nwould need to include the\nGregorianCalendar today = new GregorianCalendar();\n// Calendar is a parent class to GregorianCalendar\nfollowing line at the top of\n// YEAR is a static named constant of the Calendar class\nthe Person.java file:\nint thisYear = today.get(Calendar.YEAR);\nint birthYear = dateOfBirth.get(Calendar.YEAR);\nimport java.util.*;\n// Java Gregorian Calendar month is zero based -- Jan==0\nThis import statement tells\nint thisMonth = today.get(Calendar.MONTH);\nint birthMonth = dateOfBirth.get(Calendar.MONTH);\nthe java compiler where to\ndouble age = (thisYear - birthYear) +\nfind the GregorianCalendar\n((thisMonth - birthMonth)/12.0);\nand Calendar built-in classes\nreturn(age);\n}\n\nWrapper Classes\n- Used to wrap primitive types in a class structure\n- All primitive types have an equivalent class\n- The class includes useful constants and static methods,\nincluding one to convert back to the primitive type\nPrimitive type Class type\nMethod to convert back\nint\nInteger\nintValue()\nlong\nLong\nlongValue()\nfloat\nFloat\nfloatValue()\ndouble\nDouble\ndoubleValue()\nchar\nCharacter charValue()\n\nWrapper class example: Integer\n- Declare an Integer class variable:\nInteger n = new Integer();\n- Convert the value of an Integer variable to its\nprimitive type, int:\nint i = n.intValue();\n//method intValue()returns an int\n- Some useful Integer constants:\n- Integer.MAX_VALUE - the maximum\ninteger value the computer can represent\n- Integer.MIN_VALUE - the smallest integer\nvalue the computer can represent\n\nWrapper class example: Integer\n- Some useful Integer methods:\n-Integer.parseString(\"123\") to\nconvert a string of numerals to an integer\n-Integer.toString(123) to\nconvert an Integer to a String\n- The other wrapper classes have similar\nconstants and functions\n\nWrapper classes\nThere are some important differences in the code to\nuse wrapper classes and that for the primitive types\nWrapper Class\nPrimitive Type\n- variables contain the address\n- variables contain a value\nof the object\n- variable declaration example:\n- variable declaration example:\nInteger n;\nint n;\n- variable declaration & init:\nInteger n = new\n- variable declaration & init.:\nInteger(0);\nint n = 0;\n- assignment:\n- assignment:\nn = new Integer(5);\nn = 99;\n\nOutline\n- Arrays continued\n- Packages\n- Inheritance\n\nPartially Filled Arrays\n- Sometimes only part of an array has been\nfilled with data\n- Array elements always contain something,\nwhether you have written to them or not\n- elements which have not been written to/filled\ncontain unknown (garbage) data so you should\navoid reading them\n- There is no automatic mechanism to detect\nhow many elements have been filled - you,\nneed to keep track...\n\nExample of a Partially Filled Array\nentry[0]\nentry[1]\nentry[2]\nAnne\nStephen\nRahul\ncountOfEntries - 1\nentry[3]\ngarbage values\nentry[4]\ncountOfEntries has a value of 3.\nentry.length has a value of 5.\n\nMultidimensional Arrays\n- Arrays with more than one index\n- number of dimensions = number of indexes\n- Arrays with more than two dimensions are a\nsimple extension of two-dimensional (2-D)\narrays\n- A 2-D array corresponds to a table or grid\n- one dimension is the row\n- the other dimension is the column\n- cell: an intersection of a row and column\n- an array element corresponds to a cell in the table\n\nMultidimensional Arrays\nExample of usage:\nStore the different possible ending balances\ncorresponding to $1000 saved at 6 different\ninterest rates over a period of 10 years\n\nTable as a 2-D\nColumn Index 4\n(5th column)\nArray\nE\nE\nE\nE\nE\nE\nE\nIn dexe s\n$1050 $1055\n$1060 $1065 $1070\n$1075\n$1103 $1113\n$1124 $1134 $1145\n$1156\n$1158 $1174\n$1191 $1208 $1225\n$1242\n$1216 $1239\n$1262 $1286 $1311\n$1335\n$1276 $1307\n$1338 $1370 $1403\n$1436\nRow Index 3\n(4th row)\n- Generalizing to two indexes: [row][column]\n- First dimension: row index\n- Second dimension: column index\n- Cell contains balance for the year/row and percentage/column\n- All indexes use zero-numbering\n- Balance[3][4] = cell in 4th row (year = 4) and 5th column (7.00%)\n- Balance[3][4] = $1311 (shown in yellow)\n\nJava Code to Create a 2-D Array\n- Syntax for 2-D arrays is similar to 1-D\narrays\n- Declare a 2-D array of ints named\ntable\n- the array table should have ten rows and\nsix columns\nint[][] table = new int[10][6];\n\nCalculating the Cell Values\nEach array element corresponds to the balance for a specific\nnumber of years and a specific interest rate (assuming a starting\nbalance of $1000):\nbalance(start-balance, years, rate) = (start-balance) x (1 + rate)years\nThe repeated multiplication by (1 + rate) can be done in a for loop that\nrepeats years times.\npublic static int balance(double startBalance, int years, double rate)\n{\ndouble runningBalance = startBalance;\nint count;\nfor (count = 0; count < years; count++)\nrunningBalance = runningBalance*(1 + rate/100);\nreturn (int) (Math.round(runningBalance));\n}\n\nProcessing a 2-D Array:\nfor Loops Nested 2-Deep\n- Arrays and for loops are a natural fit\n- To process all elements of an n-\ndimensional array nest n for loops\n- each loop has its own counter that\ncorresponds to an index\n\nProcessing a 2-D Array:\nfor Loops Nested 2-Deep\n- For example: calculate and enter balances in interest\ntable (10 rows and 6 columns)\n- inner loop repeats 6 times (six rates) for every outer loop\niteration\n- the outer loop repeats 10 times (10 different values of\nyears)\n- so the inner repeats 10 x 6 = 60 times = # cells in\ntable\nint[][] table = new int[10][6];\nint row, column;\nfor (row = 0; row < 10; row++)\nfor (column = 0; column < 6; column++)\ntable[row][column] = balance(1000.00, row + 1, (5 + 0.5*column));\n\nMultidimensional Array Parameters\nand Returned Values\n- Methods may have multi-dimensional array\nparameters\n- Methods may return a multi-dimensional\narray as the value returned\n- The situation is similar to 1-D arrays, but\nwith more brackets\n- Example: a 2-D int array as a method\nargument\n\nMultidimensional Array Parameters\nand Returned Values\nNumber of rows of a 2D array is: nameOfArray.length\nNumber of columns for each row is:\nnameOfArray[row-index].length\npublic static void showTable(int[][] displayArray)\n{\nint row, column;\nfor (row = 0; row < displayArray.length; row++)\n{\nNotice how the number\nof rows is obtained\nSystem.out.print((row + 1) + \"\n\");\nfor (column = 0; column < displayArray[row].length\nNotice how the number\nof columns is obtained\n; column++)\nSystem.out.print(\"$\" + displayArray[row][column] + \" \");\nSystem.out.println();\n}\n}\n\nRagged Arrays\n- Ragged arrays have rows of unequal length\n- each row has a different number of columns, or\nentries\n- Ragged arrays are allowed in Java\n- Example: create a 2-D int array named b with\n5 elements in the first row, 7 in the second row,\nand 4 in the third row:\nint[][] b;\nb = new int[3][];\nb[0] = new int[5];\nb[1] = new int[7];\nb[2] = new int[4];\n\nPackages\n- A way of grouping and naming a collection\nof related classes\n- the classes in a package serve as a library of\nclasses\n- they do not have to be in the same directory as\nthe code for your program\n- The first line of each class in the package\nmust be the keyword package followed by\nthe name of the package\n\nPackages\nExample -- a group of related classes that\nrepresent shapes and methods for drawing them:\npackage graphics;\npublic class Circle extends Graphic {\n. . .\n} // in Circle.java\npackage graphics;\npublic class Rectangle extends Graphic {\n. . .\n} // in Rectangle.java\npackage graphics;\npublic class Ellipse extends Graphic {\n. . .\n} // in Ellipse.java\n\nPackages\n- To use classes from a package in program source\ncode, can put an import statement at the start\nof the file, e.g.:\nimport graphics.*;\n- note the \".*\" notation, \"*\" is a wild-card that\nmatches all class names in the graphics package;\nin our example, it is shorthand for graphics.Circle,\ngraphics.Rectangle, and graphics.Ellipse\n- Class descriptions with no package statement\nare automatically placed in a default package (a\npackage with no name)\n\nPackages\n- Use lowercase letters for the package name\n- By using packages if we write a new class description\nthat has the same name as a built-in Java class, we can\navoid problems\n- java.awt has a Rectangle class\n- to refer to it by its full name: java.awt.Rectangle\n- graphics package has a Rectangle class\n- to refer to it by its full name: graphics.Rectangle\n- To use java.awt and graphics Rectangle packages in the\nsame code, can use their full names (which includes\ntheir package name)\n\nPackages\n- In directory c:jdk\\lib\\examples\\graphics have\npackage graphics;\npublic class Rectangle {\nprivate double length=5.5;\nprivate double width=4.0;\n{\nreturn length*width;\n}\n} // Rectangle.java\npackage graphics;\npublic class Circle {\nprivate double radius=5;\npublic double getArea()\n{\nreturn Math.PI *\nradius * radius;\n}\n} // Circle.java\npublic double getArea()\n\nPackages\n- In directory c:jdk\\lib\\examples\\test have\npackage test;\nimport graphics.*; // import graphics.Rectangle and graphics.Circle\npublic class TestGraphics\n{\npublic static void main (String[] args) {\nRectangle r1 = new Rectangle();\nSystem.out.println(\"Rectangle area is \" + r1.getArea());\nCircle c1 = new Circle();\nSystem.out.println(\"Circle area is \" + c1.getArea());\n} // end of main ()\n}\n\nPackages\n- Pathnames are usually relative and use the CLASSPATH\nenvironment variable\nDOS\n- If: CLASSPATH=c:jdk\\lib\\examples, and the classes in\nyour graphics package are in\nc:jdk\\lib\\examples\\graphics\\, and your test\nprogram is in package test in\nc:jdk\\lib\\examples\\test\\TestGraphics.java\nFrom the DOS command line in c:jdk\\lib\\examples,\ncan type javac test\\TestGraphics.java to compile\nand java test.TestGraphics to run\nOutput:\nRectangle area is 22.0\nCircle area is 78.53981633974483\n\nPackages\nUnix/Linux\n- If: CLASSPATH=/name/lib/examples, and the classes in\nyour graphics package are in\n/name/lib/examples/graphics/, and your test\nprogram is in package test in\n/name/lib/examples/test/TestGraphics.java\nFrom the unix/linux command line in\n/name/lib/examples, you can type\njavac test/TestGraphics.java to compile\nand java test.TestGraphics to run\nOutput:\nRectangle area is 22.0\nCircle area is 78.53981633974483\n\nInheritance\n- OOP is one paradigm that facilitates managing the\ncomplexity of programs\n- OOP applies principles of abstraction to simplify the\ntasks of writing, testing, maintaining and understanding\ncomplex programs\n- OOP aims to increase code reuse\n- reuse classes developed for one application in other\napplications instead of writing new programs from\nscratch (\"Why reinvent the wheel?\")\n- Inheritance is a major technique for realizing these\nobjectives\n\nInheritance Overview\n- Inheritance allows you to define a very general\nclass then later define more specialized classes\nby adding new detail\n- the general class is called the base or parent class\n- The specialized classes inherit all the\nproperties of the general class\n- specialized classes are derived from the base class\n- they are called derived or child classes\n\nInheritance Overview\n- After the general class is developed you only\nhave to write the \"difference\" or\n\"specialization\" code for each derived class\n- A class hierarchy: classes can be derived from\nderived classes (child classes can be parent\nclasses)\n- any class higher in the hierarchy is an ancestor\nclass\n- any class lower in the hierarchy is a descendent\nclass\n\nAn Example of Inheritance:\na Person Class\nThe base class:\n- Constructors:\n- a default constructor\n- three others that initialize the firstName,\nlastName, and dateOfBirth attributes (instance\nvariables)\n- Accessor methods:\n- setFirstName to change the value of the\nfirstName attribute\n- getFirstName to read the value of the\nfirstName attribute\n- same for lastName\n\nAn Example of Inheritance:\na Person Class\nAccessor methods contd.:\n- setDateOfBirth to change the value of the\ndateOfBirth attribute\n- getDateOfBirth to read the value of the\ndateOfBirth attribute\n- writeOutput to display the values of the firstName,\nand lastName attributes\n- One other class method:\n- sameName to compare the values of the firstName and\nlastName attributes for objects of the class\n- Note: the methods are public and the attributes\nprivate\n\nDerived Classes: a Class Hierarchy\nPerson\nStudent\nEmployee\nFaculty\nStaff\nUndergraduate\nGraduate\nMastersDegree\nNonDegree\nPhD\n- The base class can be used to implement specialized classes\n- For example: student, employee, faculty, and staff\n- Classes can be derived from the classes derived from the base class,\netc., resulting in a class hierarchy\n\nExample of Adding Constructor\nin a Derived Class: Student\npublic class Student extends Person\n{\nprivate int studentNumber;\npublic Student()\n{\nsuper();\nstudentNumber = 0;\n}\n...\nz Keyword extends in\nfirst line\n»\nclass\n»\ncreates derived\nclass from base\nthis is inheritance\n- Four new constructors (one on next slide)\n- default initializes attribute studentNumber to 0\n- super must be first action in a constructor definition\n- Included automatically by Java if it is not there\n- super()calls the parent default constructor\n\nExample of Adding Constructor\nin a Derived Class: Student\n- Passes parameter fName to constructor of parent class\n- Uses second parameter to initialize instance variable that\nis not in parent class.\npublic class Student extends Person\n{\n. . .\npublic Student(String fName, int newStudentNumber)\n{\nsuper(fName);\nstudentNumber = newStudentNumber;\n}\n. . .\n\nMore about\nConstructors in a Derived Class\n- Constructors can call other constructors\n- Use super to invoke a constructor that is\ndefined in the parent class\n- as shown on the previous slide\n- Use this to invoke a constructor that is\ndefined within the derived class itself\n- shown on the next slide\n\nExample of a constructor using this\n- calls the constructor with three arguments, fName, lName (String) and 0\n(int), within the same class\npublic Student(String first, String last)\n{\nthis(first, last, 0);\n}\nStudent class has a constructor with three parameters: String for the\nfirstName and lastName attributes and int for the studentNumber\nattribute\npublic Student(String fName, String lName,\nint newStudentNumber)\n{\nstudentNumber = newStudentNumber;\n}\nAnother constructor within Student takes two String arguments and\ninitializes the studentNumber attribute to a value of 0:\nsuper(fName, lName);\n\nExample of Adding an Attribute in\na Derived Class: Student\nA line from the Student class:\nprivate int studentNumber;\n- Note that an attribute for the student\nnumber has been added\n-Student has this attribute in addition to\nfirstName, lastName, and\ndateOfBirth, which are inherited from\nPerson\n\nExample of Overriding a Method in\na Derived Class: Student\n- Both parent and derived classes have a writeOutput method\n- Both methods have the same parameters (none)\n- they have the same signature\n- The method from the derived class overrides (replaces) the\nparent's\n- It will not override the parent if the parameters are different (since\nthey would have different signatures)\n-\nThis is\n\noverriding, not overloading\npublic void writeOutput()\n{\nSystem.out.println(\"Name: \" + getFirstName() + \" \" +\ngetLastName());\nSystem.out.println(\"Student Number : \" +\nstudentNumber);\n}\n\nCall to an Overridden Method\n- Use super to call a method in the parent class that was\noverridden (redefined) in the derived class\n- Example: Student redefined the method writeOutput\nof its parent class, Person\n- Could use super.writeOutput() to invoke the\noverridden (parent) method\npublic void writeOutput()\n{\nsuper.writeOutput(); // prints first and last name\nSystem.out.println(\"Student Number : \" +\nstudentNumber);\n}\n\nOverriding Verses Overloading\nOverriding\n- Same method name\n- Same signature\n- One method in\nancestor, one in\ndescendant\nOverloading\n- Same method name\n- Different signature\n- Both methods can be\nin same class\n\nThe final Modifier\n- Specifies that a method definition cannot be\noverridden with a new definition in a derived class\n- Example:\npublic final void specialMethod()\n{\n. . .\n}\n- Used in specification of some methods in standard\nlibraries\n- Allows the compiler to generate more efficient code\n- An entire class can be declared final, which means it\ncannot be used as a base class to derive another class\n\nprivate & public\nInstance Variables and Methods\n- private instance variables from the parent\nclass are not available by name in derived\nclasses\n- \"Information Hiding\" says they should not be\n- use accessor methods to change them, e.g. can call\nparent's setFirstName method for a Student\nobject to change the firstName attribute\n- private methods are not inherited!\n- use public to allow methods to be inherited\n- only helper methods should be declared private\n\nWhat is the \"Type\" of a Derived class?\n- Derived classes have more than one type\n- They have the type of the derived class (the\nclass they define)\n- They also have the type of every ancestor class\n- all the way to the top of the class hierarchy\n- All classes derive from the original, predefined\nJava class Object\n- That is, Object is the original ancestor class\nfor all other Java classes (including user-defined\nones)\n\nAssignment Compatibility\n- Can assign an object of a derived class to a\nvariable of any ancestor type\nPerson josephine;\nEmployee boss = new Employee();\njosephine = boss;\nOK\n- Can not assign an object of an ancestor class to\na variable of a derived class type\nPerson josephine = new Person();\nEmployee boss;\nboss = josephine;\nNot allowed\nPerson\nEmployee\nPerson is the\nparent class of\nEmployee in\nthis example.\nAn employee is a person but a person is not necessarily an employee\n\nCharacter Graphics Example\nFigure\nBox\nTriangle\noffset\nMethods:\nsetOffset\ngetOffset\ndrawAt\ndrawHere\noffset\nheight\nwidth\nMethods:\nsetOffset\ngetOffset\ndrawAt\ndrawHere\nreset\ndrawHorizontalLine\ndrawSides\ndrawOneLineOfSides\nspaces\noffset\nbase\nMethods:\nsetOffset\ngetOffset\ndrawAt\ndrawHere\nreset\ndrawBase\ndrawTop\nspaces\nInherited\nOverrides\nStatic\nInstance variables:\nInstance variables:\nInstance variables:\n\nJava program execution order\n- Programs normally execute in sequence\n- Non-sequential execution occurs with:\n- selection (if/if-else/switch) and repetition (while/do-\nwhile/for)\n(depending on the test it may not go in sequence)\n- method calls, which jump to the location in memory that\ncontains the method's instructions and returns to the calling\nprogram when the method is finished executing\n- One job of the compiler is to try to figure out the\nmemory addresses for these jumps\n- The compiler cannot always know the address\n- sometimes it needs to be determined at run time\n\nStatic and Dynamic Binding\n- Binding: determining the memory addresses for jumps\n(calls to class methods, etc.)\n- Static: done at compile time\n- also called offline\n- Dynamic: done at run time\n- Compilation is done offline\n- it is a separate operation done before running a\nprogram\n- Binding done at compile time is, therefore, static\n- Binding done at run time is dynamic\n- also called late binding\n\nExample of Dynamic Binding:\nGeneral Description\n- A derived class calls a method in its\nparent class which calls a method that is\noverridden (defined) in the derived class\n- the parent class is compiled separately; in some\ncases before the derived class is even written\n- the compiler cannot possibly know which address\nto use\n- therefore the address must be determined (bound)\nat run time\n\nDynamic Binding: Specific Example\nParent class: Figure\n- Defines methods: drawAt and drawHere\n- drawAt calls drawHere\nDerived class: Box extends Figure\n- Inherits drawAt\n- redefines (overrides) drawHere\n- Calls drawAt\n- uses the parent's drawAt method\n- which must call the derived class's, drawHere method\n- Figure is compiled before Box is even written, so the\naddress of drawHere(in the derived class Box) cannot be\nknown then\n- it must be determined during run time, i.e. dynamically\n\nPolymorphism revisited\n- Using the process of dynamic binding to\nallow different objects to use different\nmethod actions for the same method name\n- Method overloading is an example of\npolymorphism\n- However, the term polymorphism is most\noften used in reference to dynamic binding\n\nSummary\n- A derived class inherits the instance variables & methods of\nthe base class\n- A derived class can create additional instance variables and\nmethods\n- The first thing a constructor in a derived class normally does is\ncall a constructor in the base class\n- If a derived class redefines a method defined in the base class,\nthe version in the derived class overrides that in the base class\n- Private instance variables and methods of a base class cannot\nbe accessed directly in the derived class\n- If A is a derived class of class B, then an instance of A (object)\nis both a member of classes A and B\n- the type of the object is both A and B\n\nRead\n- Sections 6.3 - 6.5"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture7.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/b98a8f146438d4fbf9a07c82f313b344_lecture7.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\nHST 952\nComputing for Biomedical Scientists\nLecture 7\n\nOutline\n- Information hiding revisited\n- Intro to exceptions in java\n- Programming examples\n- Questionnaire\n\nInformation Hiding Revisited\n- To achieve information hiding goal, need to\nmake a class's instance variables private and\nprovide public accessor methods for retrieving\nand setting these variables' values\n- For instance variables that have a class type,\nthis may not be enough!\n- Variables with primitive types in Java are\npassed or returned by value\n- a copy of the variable's value is passed/returned, the\noriginal contents of the variable cannot be modified\nby changing this copy\n\nInformation Hiding Revisited\n- In general, class variables are passed or\nreturned by reference\n- a copy of the memory address the variable refers to\nis passed, the contents of this memory address can\nbe altered once this address is known\n(Exceptions to this rule in Java are variables of the\nString and StringBuffer classes which act like\nvariables of primitive types when passed/returned)\n\nInformation Hiding Revisited\n- cloning a variable is one solution to this problem\n- a clone has the same contents as the original\nvariable but a different address in memory\n- altering the clone does not affect the original\n- classes that allow cloning implement the cloneable\ninterface (e.g. GregorianCalendar)\n- some classes do not allow cloning (do not\nimplement the cloneable interface) e.g. String,\nStringBuffer\n\nInformation Hiding Revisited\n- Programming example: Person class\n\nExceptions: Overview\n- Exceptions give us a way of organizing a\nprogram into sections for the normal case and\nthe exceptional case\n- exception examples:\ndivision by zero\nincorrect type of input\n- Simplifies development, testing, debugging\nand maintenance\n- errors are easier to isolate\n\nExceptions: Some Terminology\n- Throwing an exception: either Java itself or\nyour code signals that something unusual has\nhappened\n- Handling an exception: responding to an\nexception by executing a part of the program\nspecifically written for the exception\n- also called catching an exception\n\nExceptions: Some Terminology\n- The normal case is handled in a try block\n- The exceptional case is handled in a catch\nblock\n- The catch block takes a parameter of type\nException\n- it is called the catch-block parameter\n- Exception is a built-in Java class\n- If an exception is thrown execution in the try\nblock ends and control passes to the catch\nblock(s) after the try block\n\ntry-throw-catch Threesome\nBasic code organization:\ntry\n{\n<code to try>\nif(test condition)\nthrow new Exception(\"Message to display\");\n<more code>\n}\ncatch(Exception e)\n{\n}\n<exception handling code>\nProgramming example: restricting the length of an input string\n\ntry-throw-catch Threesome\nTry block\nStatements execute up to the conditional throw\nstatement\nIf the condition is true the exception is thrown\n- control passes immediately to the catch\nblock(s) after the try block\nElse the condition is false\n- the exception is not thrown\n- the remaining statements in the try block (those\nfollowing the conditional throw) are executed\n\ntry-throw-catch Threesome\nCatch block\nExecutes if an exception is thrown\n- may terminate execution with exit statement\n- if it does not exit, execution resumes after the\ncatch block\nStatements after the Catch block\nExecuted if either the exception is not thrown or if it is\nthrown but the catch block does not exit the program\n\nMore about the catch-Block\n- Although it may look similar to a method definition\nThe catch-block is not a method definition!\n- Every Exception has a getMessage method\n- it retrieves the string given to the exception object when it\nwas thrown, e.g.\nthrow new Exception(\"This message is retrieved\");\n- A catch-block applies only to an immediately\npreceding try block\n- if no exception is thrown the catch block is ignored\n\nPredefined Exception Classes\n- Exception is the root class of all exceptions\n- Many predefined classes throw exceptions\n- the documentation or interface will tell you\n- the exceptions thrown are often also predefined\n- Some common predefined exceptions:\n- IOException\n- ClassNotFoundException, and\n- FileNotFoundException\n\nDocumentation for Exception class\njava.lang\nClass Exception\nThe package which Exception belongs to\nTaken from http://java.sun.com/j2se/1.3/docs/api/index.html\njava.lang.Object\n|\n+--java.lang.Throwable\n|\n+--java.lang.Exception\nAncestor class for all Java classes\nSub-class of Object\nAll Implemented Interfaces:\nSerializable\nA Java class cannot be a subclass of more than\nTo get\naround this, Java allows a class to implement\nmore than one interface. An interface is a\nmust have.\nSub-class of Throwable\none class, but sometimes we need it to have\nproperties of more than one class.\nproperty of a class that says what methods it\n\nDocumentation for Exception class\nDirect Known Subclasses:\nAclNotFoundException, ActivationException, AlreadyBoundException,\nApplicationException, AWTException, BadLocationException,\nClassNotFoundException, CloneNotSupportedException, DataFormatException,\nExpandVetoException, FontFormatException, GeneralSecurityException,\nIllegalAccessException, InstantiationException,\nInterruptedException, IntrospectionException, InvalidMidiDataException,\nInvocationTargetException, IOException, LastOwnerException,\nLineUnavailableException, MidiUnavailableException, MimeTypeParseException,\nNamingException, NoninvertibleTransformException, NoSuchFieldException,\nNoSuchMethodException, NotBoundException, NotOwnerException,\nParseException, PrinterException, PrivilegedActionException,\nPropertyVetoException, RemarshalException, RuntimeException,\nServerNotActiveException, SQLException, TooManyListenersException,\nUnsupportedAudioFileException, UnsupportedFlavorException,\nUnsupportedLookAndFeelException, UserException\n\nDocumentation for Exception class\npublic class Exception\nextends Throwable\nThe class Exception and its subclasses are a form of Throwable that indicates\nconditions that a reasonable application might want to catch.\nConstructor Summary:\nException()\nConstructs an Exception with no specified detail message.\nException(String s)\nConstructs an Exception with the specified detail message.\n\nDocumentation for Exception class\nMethods inherited from class java.lang.Throwable:\nfillInStackTrace, getLocalizedMessage, getMessage, printStackTrace,\nprintStackTrace, printStackTrace, toString\nMethods inherited from class java.lang.Object\nclone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait\nConstructor Detail\npublic Exception()\nConstructs an Exception with no specified detail message.\npublic Exception(String s)\nConstructs an Exception with the specified detail message.\nParameters:\ns - the detail message.\n\nUsing an Object that May Throw\nan Exception\nSample object = new SampleClass();\ntry\n{\n<Possibly some code>\nobject.doStuff();//may throw IOException\n<Possibly some more code>\n}\ncatch(IOException e)\n{\n<Code to handle the IOException, probably\nincluding this line:>\nSystem.out.println(e.getMessage());\n}\n- Predefined exceptions usually include a meaningful message that is retrieved\nwith getMessage\n\nUser-Defined Exception Classes\npublic class DivideByZeroException extends Exception\n{\npublic DivideByZeroException()\n{\nsuper(\"Dividing by Zero!\");\n}\npublic DivideByZeroException(String message)\n{\nsuper(message);\n}\n}\n- Must be derived from some already defined exception class\n- Often the only method you need to define is the constructor\n- Include a constructor that takes a String message argument\n- Also include a default constructor with a call to super and default\nmessage string\n\nWhen to Define\nYour Own Exception Class\n- When you use a throw-statement in your code you\nshould usually define your own exception class.\n- If you use a predefined, more general exception class,\nthen your catch-block will have to be general.\n- A general catch-block could also catch exceptions\nthat should be handled somewhere else.\n- A specific catch-block for your own exception class\nwill catch the exceptions it should and pass others on\n(e.g., DivideByZeroException will only catch\ndivisions by zero and will ignore\nNumberFormatExceptions)\n\nExample:\npublic double divide(int numerator, int denominator)\nUsing the\n{\ndouble quotient = SENTINEL;\nDivide-\nByZero-\ntry\n{\nif (denominator == 0)\nthrow new DivideByZeroException();\nClass\nException\nquotient = numerator/(double)denominator;\nSystem.out.println(numerator + \"/\"\n+ denominator\n+ \" = \" + quotient);\n}\ncatch(DivideByZeroException e)\n{\nSystem.out.println(e.getMessage());\n}\nreturn(quotient);\n}\n\nCatching an Exception in a Method\nother than the One that Throws It\nWhen defining a method you must include a throws-clause to declare any\nexception that might be thrown but is not caught in the method.\n-\nUse a\n\nthrows-clause to \"pass the buck\" to whatever method calls it (pass\nthe responsibility for the catch block to the method that calls it)\n- that method can also pass the buck,\nbut eventually some method must catch it\n- This tells other methods\n\"If you call me, you must handle any exceptions that I throw.\"\n\nExample: throws-Clause\ndivide method\n- May throw a DivideByZeroException in another\nmethod normal that calls it\n- But the catch block is in main\n- So normal must include a throws-clause in the first line of\nthe method definition:\npublic void normal() throws\nDivideByZeroException\n{\n<statements to define the normal method>\n}\n\nMore about Passing the Buck\nGood programming practice:\nEvery exception thrown should eventually be caught in some\nmethod\n- Normally exceptions are either caught in a catch block or\ndeferred to the calling method in a throws-clause\n- If a method throws an exception, it expects the catch block to\nbe in that method unless it is deferred by a throws-clause\n- if the calling method also defers with a throws-clause, its\ncalling program is expected to have the catch block, etc.,\nup the line all the way to main, until a catch block is\nfound\n\np\n()\n{\n);\n}\nMethodA throws\nMyException\nbut defers\ncatching it (by\nusing a throws-\nclause:\np\n)\n{\n{\n()\n}\n)\n{\n}\n}\nTypical Program\nOrganization for\nException Handling in\nReal Programs\nMethodB, which\ncalls MethodA,\ncatches\nMyException\nexceptions:\nublic void MethodA throws MyException\nthrow new MyException(\"Bla Bla Bla\"\nublic void MethodB(\ntry\nMethodA ;//May throw MyException exception\ncatch(MyException e\n<statements to handle MyException exceptions>\n\nUncaught Exceptions\n- In any one method you can catch some\nexceptions and defer others\n- If an exception condition occurs but the\nexception is not caught in the method that\nthrows it or any of its calling methods, either:\n- the program ends abnormally, or,\n- in the case of a GUI using Swing, the\nprogram may become unstable\n\nthrows-Clauses in Derived Classes\n- You cannot add exceptions to the throws-clause of a\nredefined method in a derived class\n- only exceptions in the throws -clause of the parent class's\nmethod can be in the throws -clause of the redefined\nmethod in the derived class\n- In other words, you cannot throw any exceptions that are not\neither caught in a catch block or already listed in the\nthrows -clause of the same method in the base class\n- You can, however, declare fewer exceptions in the throws -\nclause of the redefined method\n\nMultiple Exceptions and\ncatch Blocks in a Method\n- Methods can throw more than one exception\n- The catch blocks immediately following the try block are\nsearched in sequence for one that catches the exception type\n- the first catch block that handles the exception type is the\nonly one that executes\n- Specific exceptions are derived from more general types\n- both the specific and general types from which they are\nderived will handle exceptions of the more specific type\n- So put the catch blocks for the more specific, derived,\nexceptions early and the more general ones later\n\nException: Reality Check\n- Exception handling can be overdone\n- use it sparingly and only in certain ways\n- If the way an exceptional condition is handled\ndepends on how and where the method is invoked,\nthen it is better to use exception handling and let\nthe programmer handle the exception (by writing\nthe catch block and choosing where to put it)\n- Otherwise it is better to avoid throwing exceptions\n\nThe finally Block\nAt this stage of your programming you may not have much use for\nthe finally block, but it is included for completeness - you may\nfind it useful in the future\n- You can add a finally block after the try/catch blocks\n- finally blocks execute whether or not catch block(s)\nexecute\n- Code organization using finally block:\ntry block\ncatch block\nfinally\n{\n<Code to be executed whether or not an exception is thrown>\n}\n\nThree Possibilities for a try-catch-\nfinally Block\n- The try-block runs to the end and no exception is\nthrown.\n- The finally-block runs after the try-block.\n- An exception is thrown in the try-block and caught\nin the matching catch-block.\n- The finally-block runs after the catch-block.\n- An exception is thrown in the try-block and there is\nno matching catch-block.\n- The finally-block is executed before the method ends.\n- Code that is after the catch-blocks but not in a finally-\nblock would not be executed in this situation.\n\nSummary\n- An exception is an object descended from the Exception\nclass\n- Exception handling allows you to design code for the normal\ncase separately from that for the exceptional case\n- You can use predefined exception classes or define your own\n- Exceptions can be thrown by:\n- certain Java statements\n- methods from class libraries\n- explicit use of the throw statement\n- An exception can be thrown in either\n- a try block, or\n- a method definition without a try block, but in this case the\ncall to the method must be placed inside a try block\n\nSummary\n- An exception is caught in a catch block\n- When a method might throw an exception but does not have a\ncatch block to catch it, usually the exception class must be\nlisted in the throws-clause for the method\n- A try block may be followed by more than one catch block\n- more than one catch block may be capable of handling the\nexception\n- the first catch block that can handle the exception is the\nonly one that executes\n- so put the most specific catch blocks first and the most\ngeneral last\n- Every exception class has a getMessage method to retrieve\na text message description of the exception caught\n\nRead\n- Sections 6.4 - 6.5\n- Chapter 7\n- Chapter 8\n\nProgramming examples\n- Exceptions (divide by zero)\n- Inheritance (Student & Person classes)\n\nQuestionnaire"
    },
    {
      "category": "Lecture Notes",
      "title": "lecture8.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/e1a33c4c57ecc9143d37054cc7350e68_lecture8.pdf",
      "content": "Harvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\nHST 952\nComputing for Biomedical Scientists\nLecture 8\n\nOutline\n- Vectors\n- Streams, Input, and Output in Java\n- Programming examples\n\nVectors\n- We can think of a vector as an array that can get\nlarger or smaller when a program is running\n- Data structure - a construct that allows us to\norganize/aggregate data\n- An array is a static data structure\n- A vector is a dynamic data structure\n\nArrays versus Vectors\nArrays\nVectors\nBad:\nGood :\n- Size is fixed when declared\n- Size is not fixed\n- Inefficient storage: can use a - Better storage efficiency: a\npartially full array, but space\npartially full vector may be\nhas been allocated for the\nallocated just the space it needs\nfull size\n- If one more value needs to be\n- If one more value needs to\nadded past the maximum size\nbe added past the maximum\nthe vector size increases\nsize the array needs to be\nautomatically\nredeclared\nGood:\nBad:\n- More efficient (faster)\n- Less efficient (slower) execution\nexecution\n- Elements must be class types\n- Elements can be of any type\n(primitive types not allowed)\n\nUsing Vectors\n- Vectors are not automatically part of Java\n- they are in the util library\n- you must import java.util.*\n- Create a vector with an initial size of 20\nelements:\nVector v = new Vector(20);\n\nVector Initial Capacity vs.\nEfficiency\n- Choosing the initial size of a vector is an\nexample of a tradeoff\n- making it too large wastes allocated memory space\n- making it too small slows execution\n- it takes time to resize vectors dynamically\n- Solution?\n- optimize one at the expense of the other\n- or make good compromises\n- choose a size that is not too big and not too small\n\nVector Syntax\n- The idea is the same as for arrays, but the syntax is different\n- As with arrays, the index must be in the range 0 to size-of-the-\nvector\nArray: a is a String array\na[i] = \"Hi, Mom!\");\nString temp = a[i];\nVector: v is a vector\nv.setElementAt(\"Hi,\nMom!\", i);\nString temp =\n(String)v.elementAt(i);\nInstead of the index in\nbrackets and = for\nassignment, use vector\nmethod setElementAt\nwith two arguments, the\nvalue and the index\nelementAt(int index) to\nretrieve the value of an element\nNote: the cast to String is\nrequired because the base type of\nvector elements is Object\nUse vector method\n\nVector Methods\n- The vector class includes many useful methods:\n- constructors\n- array-like methods, e.g. setElementAt &\nelementAt\n- methods to add elements\n- methods to remove elements\n- search methods\n- methods to work with the vector's size and capacity,\ne.g. to find its size and check if it is empty\n- a clone method to copy a vector\n- see section 10.1 of Savitch text for more details\n\nMore Details About Vectors\n- Vectors put values in successive indexes\n- addElement is used to put initial values in a\nvector\n- new values can be added only at the next higher\nindex\n- You can use setElementAt to change the\nvalue stored at a particular index\n- setElementAt can be used to assign the value\nof an indexed variable only if it has been\npreviously assigned a value with addElement\n\nBase Type of Vectors\n- The base type of an array is specified when the\narray is declared\n- all elements of arrays must be of the same type\n- The base type of a vector is Object\n- elements of a vector can be of any class type\n- in fact, elements of a vector can be of different class\ntypes\n- it is usually best to have all elements in a vector be\nthe same class type\n- to store primitive types in a vector they must be\nconverted to a corresponding wrapper class\n\nMore Details About Vectors\n- The following code looks very reasonable but will produce an\nerror saying that the class Object does not have a method\nnamed length:\nVector v = new Vector()\nString greeting = \"Hi, Mom!\";\nv.addElement(greeting);\nSystem.out.println(\"Length is \" +\n(v.elementAt(0)).length());\n- String, of course, does have a length method, but Java sees\nthe type of v.elementAt(0) as Object, not String\n- Solution? Cast v.elementAt(0) to String:\nSystem.out.println(\"Length is \" +\n(String)(v.elementAt(0)).length();\n\nVector Size Versus Vector Capacity\n- Be sure to understand the difference between\ncapacity and size of a vector:\n- capacity is the declared size of the vector\n- the current maximum number of elements\n- size is the actual number of elements being used\n- the number of elements that contain valid values, not\ngarbage\n- remember that vectors add values only in successive\nindexes\n- Loops that read vector elements should be limited by\nthe value of size, not capacity, to avoid reading\ngarbage values\n\nIncreasing Storage Efficiency of\nVectors\n- A vector automatically increases its size if elements\nbeyond its current capacity are added\n- But a vector does not automatically decrease its size if\nelements are deleted\n- The method trimToSize() shrinks the capacity of\na vector to its current size so there is no extra, wasted\nspace\n- the allocated space is reduced to whatever is\ncurrently being used\n- To use storage more efficiently, use trimToSize()\nwhen a vector will not need its extra capacity later\n\nMore Details About Vectors\n- The method clone is used to make a copy of a\nvector but its return type is Object, not Vector\n- of course you want it to be Vector, not Object\n- So, what do you do?\nThis just makes otherV\nanother name for the vector\nv (there is only one copy of\nthe vector object and it now\nhas two names referring to\nthe same location/address in\nmemory)\n- Cast it to Vector\nVector v = new Vector(10);\nVector otherV;\notherV = v;\nVector otherV2 = (Vector)v.clone();\nThis creates a\ncopy of v\nwith a different name, otherV2\nand a different address in memory\nsecond\n\nProtecting Private Variables\n- Be careful not to return addresses of private vector\nvariables, otherwise calling methods can access them\ndirectly\n- \"Information Hiding\" is compromised\n- To protect against it, return a copy of the vector\n- use clone as described in the previous slide\n- But that's not all:\n- if the elements of the vector are class (and not primitive)\ntypes, they may not have been written to pass a copy\n- they may pass their address\n- so additional work may be required to fix the accessor\nmethods (have accessor methods return clones)\n\nProgramming example\n\nInput/Output (I/O) Overview\n- In this context it is input to and output from\nprograms\n- Input can be from keyboard or a file\n- Output can be to display (screen) or a file\n- Advantages of file I/O\n- permanent copy\n- output from one program can be input to another\n- input can be automated (rather than entered\nmanually)\n\nStreams\n- Stream: an object that either delivers data to its\ndestination (screen, file, etc.) or that takes data from a\nsource (keyboard, file, etc.)\n- it acts as a buffer between the data source and destination\n- Input stream: a stream that provides input to a program\n- Output stream: a stream that accepts output from a\nprogram\n- System.out is an output stream\n- System.in is an input stream\n- A stream connects a program to an I/O object\n- System.out connects a program to the screen\n- System.in connects a program to the keyboard\n\nBinary Versus Text Files\n- All data and programs are ultimately just zeros and ones\n- each digit can have one of two values, hence binary\n- bit is one binary digit, byte is a group of eight bits\n- In text files: the bits represent printable characters\n- one byte per character for ASCII, the most common code\n- for example, Java source files are text files\n- so is any file created with a \"text editor\"\n- In binary files: the bits represent other types of encoded\ninformation, such as executable instructions or numeric data\n- these files are easily read by the computer but not humans\n- they are not intelligible to a human when printed\n\nBinary Versus Text Files\n- Text files are more readable by humans\n- Binary files are more efficient\n- computers read and write binary files more easily than text\n- Java binary files are portable\n- they can be used by Java on different machines\n- Reading and writing binary files is normally done by a\nprogram\n- text files are used only to communicate with humans\nJava Text Files\nJava Binary Files\n- Source files\n- Executable files (created by\n- Occasionally input files\ncompiling source files)\n- Occasionally output files\n- Usually input files\n- Usually output files\n\nText File I/O\n- Important classes for text file output (to the file)\n- PrintWriter, FileWriter, BufferedWriter\n- FileOutputStream\n- Important classes for text file input (from the file):\n- BufferedReader\n- FileReader\n- Note that FileOutputStream and FileReader are used\nonly for their constructors, which can take file names as\narguments.\n- PrintWriter and BufferedReader cannot take file\nnames as arguments for their constructors.\n- To use these classes your program needs a line like the\nfollowing:\nimport java.io.*;\n\nEvery File Has Two Names\n- The code to open the file creates two\nnames for an output file\n- the name used by the operating system\n- e.g., out.txt\n- the stream name\n- e.g., outputStream\n- Java programs use the stream name\n\nText File Output\n- Binary files are more efficient for Java to\nprocess, but text files are readable by humans\n- Java allows both binary and text file I/O\n- To open a text file for output: connect a text file\nto a stream for writing\n- e.g., create a stream of the class PrintWriter\nand connect it to a text file\n\nText File Output\n- For example:\nPrintWriter outputStream = new PrintWriter(new\nFileOutputStream(\"out.txt\"));\n- Then you can use print and println to\nwrite to the file (convenient)\n- The text lists some other useful PrintWriter\nmethods\n\nClosing a File\n- An output file should be closed when\nyou are done writing to it (and an input\nfile should be closed when you are\ndone reading from it)\n- Use the close method of the class\n- If a program ends normally it will\nclose any files that are open\n\nClosing a file\nIf a program automatically closes files when it\nends normally, why close them with explicit calls\nto close?\nTwo reasons:\n1. To make sure it is closed if a program ends\nabnormally (the file could get damaged if it is left\nopen).\n2. A file that has been opened for writing must be\nclosed before it can be opened for reading.\n\nText File Input\n- To open a text file for input: connect a text file to a stream for\nreading\n- use a stream of the class BufferedReader and connect it to a text file\n- use the FileReader class to connect the BufferedReader object to\nthe text file\n- For example:\nBufferedReader inputStream =\nnew BufferedReader(new FileReader(\"data.txt\"));\n- Then:\n- read lines (Strings) with BufferedReader's readLine method\n- BufferedReader has no methods to read numbers directly, so read\nnumbers as Strings and then convert them\n- read a single char with BufferedReader's read method\n\nInput File Exceptions\n- A FileNotFoundException is\nthrown if the file is not found when an\nattempt is made to open a file\n- Most read methods throw IOException\n- we have to write a catch block for it\n- If a read goes beyond the end of the file an\nEOFException is thrown\n\nHandling IOException\n- IOException cannot be ignored\n- either handle it with a catch block\n- or defer it with a throws-clause\nPut code to open a file and read/write to it in\na try-block and write a catch-block for this\nexception :\ncatch(IOException e)\n{\nSystem.out.println(\"Problem...\");\n}\n\nTesting for the End of an Input File\n- A common programming situation is to read data from\nan input file but not know how much data the file\ncontains\n- In these situations you need to check for the end of the\nfile\n- There are three common ways to test for the end of a\nfile:\n1. Put a sentinel value at the end of the file and test for it.\n2. Throw and catch an end-of-file exception.\n3. Test for a special character that signals the end of the file\n(text files often have such a character).\n\nTesting for End of File in a Text File\n- There are several ways to test for end of file. For\nreading text files in Java you can use this one:\n- Test for a special character that signals the end of the file\n- When readLine tries to read beyond the end of a text\nfile it returns the special value null\n- so you can test for null to stop processing a text file\n- read returns -1 when it tries to read beyond the end of\na text file\n- the int value of all ordinary characters is nonnegative\n\nProgramming example\nReading input from one file and writing\noutput to another\n\nReading Parts of a String\n- There are BufferedReader methods to read a line\nand a character, but not just a single word\n- StringTokenizer can be used to parse a line into\nwords\n- it is in the util library so you need to import\njava.util.*\n- some of its useful methods are shown in the text\n- e.g. test if there are more tokens\n- you can specify delimiters (the character or\ncharacters that separate words)\n- the default delimiters are \"white space\" (space, tab, and\nnewline)\n\nExample: StringTokenizer\n- Display the words separated by any of the following\ncharacters: space, new line (\\n), period (.) or comma (,).\nString inputLine = KeyboardInput.readLine();\nStringTokenizer wordFinder =\nnew StringTokenizer(inputLine, \" \\n.,\");\n//the second argument is a string of the 4 delimiters\nwhile(wordFinder.hasMoreTokens())\n{\nSystem.out.println(wordFinder.nextToken());\n}\nQuestion\n2b\nor\n!tooBee\nEntering \"Question,2b.or !tooBee.\"\ngives this output:\n\nWarning: Overwriting a File\n- Opening a file creates an empty file\n- Opening a file creates a new file if one does\nnot already exist\n- Opening a file that already exists eliminates\nthe old file and creates a new, empty one\n- data in the original file is lost\n- How to test for the existence of a file and\navoid overwriting it is covered in section 9.3\nof the text, which discusses the File class\n\nThe File Class\n- Acts like a wrapper class for file names\n- A file name like \"out.txt\" has only String\nproperties\n- But a file name of type File has some very\nuseful methods\n- exists: tests to see if a file already exists\n- canRead: tests to see if the operating system will\nlet you read a file\n- FileInputStream and\nFileOutputStream have constructors that\ntake a File argument as well as constructors\nthat take a String argument\n\nSummary\n- Text files contain strings of printable\ncharacters; they look intelligible to humans\nwhen opened in a text editor.\n- Binary files contain numbers or data in\nnon-printable codes; they look\nunintelligible to humans when opened in a\ntext editor.\n- Java can process both binary and text files\nfor I/O\n\nSummary\n- Always check for the end of the file when\nreading from a file. The way you check for\nend-of-file depends on the method you use\nto read from the file.\n- A file name can be read from the keyboard\ninto a String variable and the variable\nused in place of a file name.\n\nProgramming example\nWant to create a simple parser that can read a boolean\nexpression typed from the keyboard of the form:\ntrue and true\ntrue and false\ntrue or true\ntrue or false\nnot true\nnot false, etc.\nand print out the truth value of the expression\n\nRead\n- Chapter 9\n- Chapter 10"
    },
    {
      "category": "Resource",
      "title": "project.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/53529b61369545ea1da0f8f522f8e558_project.pdf",
      "content": "HST 952\nFall 2002\nProject\nThe project builds upon the database you designed in Homeworks 8 and 9. It also will\nutilize many of the skills you have developed in previous segments of this course.\nYou will develop a part of the laboratory information system. The functionality you will\nadd is the ability to view a patient's test results and perform rudimentary decision\nsupport using the database. You do not need to add functionality to place orders so you\nshould not have to implement classes you do not need.\n1. If your schema does not yet support it, change the schema so that patient test\norders and results are stored as test codes instead of names. A set of codes is\nprovided in a table on a later page. You should also add data about patients from the\nSample Patient file. This has a little more data than was given in Homework 9. (5\npoints)\n2. Create Java classes for entities you had created in your LIS E-R diagram to support\nviewing of test results. Possible classes may be Test, Patient, Result, etc. The actual\nset of classes will depend on your E-R and database design. The classes must\ncontain variables for each of the attributes of an entity and must have get/set\nfunctions for each of the attributes. Your E-R diagram should guide you in designing\nthe classes. The relationships can be expressed as attributes of a class. For\nexample, the relationship that a Patient has many tests can be expressed as follows:\npublic class Patient {\nprivate String patient_id;\nprivate String first_name;\nprivate Vector tests;\n// constructor\n// see below for explanation of db parameter\npublic Patient(LIS_Database db) {\n}\n// load the orders from the database\npublic void getTests() {\nTests t = db.getTestsForPatient(this);\n// add them to our tests vector\n}\npublic void addTest(Test t) {\ntests.add(t);\n}\n}\n(25 points)\n3. Design a class called LIS_Database that has public functions for the following\na. Managing the connection to the database\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nHST 952\nFall 2002\nb. Handling all input and output from the database.\nThe purpose of this class is to hide from the other classes of your application,\nsuch as Patient and Test, all the ugly details of how to deal with the database\nand how the storage is managed. The decoupling of classes from the database\nallows you to switch databases or make changes in your database design with\nminimal effects on the rest of your application.\nAn example stub of the class is provided. You may need different method\nsignatures than the ones in the example below. You will probably need to add\nother public and private functions.\npublic class LIS_Database {\nprivate Connection conn;\nprivate String connection_url; // for the database\n// opens a connection to the database\npublic void open() {\n}\n// closes the connection to the database\npublic void close() {\n}\npublic Patient getPatient(String id) {\n}\npublic void addPatient(Patient pat) {\n}\n// add result for a test\npublic void addResult(Patient pat, Test test, float r) {\n}\n}\n(15 points)\nWrite Java programs described below that utilizes the above classes. Not all of the\nfunctionality required can be handled by SQL so you may have to implement java\nalgorithms for some of them.\n4. Find all patients whose serum potassium value was above normal and whose next\nserum potassium value (measured between 7 and 14 days after the first one) has\nnot decreased. Send the following alert to the physician who ordered the test.\nPatient <Insert Patient's Name Here> potassium not improving.\n<Test name> <Test result> <Date/time for second test>\n<Test name> <Test result> <Date/time for first test>\nThe alert must be sent by e-mail. See the sample program later in this document\nas an example of how to send e-mail from a java program. Change the e-mail\naddress to your own for testing purposes.\n(30 points)\n5. Dr. Bean Counter would like to view all the tests for the month in an organized\nmanner. He would like a program that sorts tests by analytes and by sample types.\n\nHST 952\nFall 2002\nThe table below provides the Analytes and Sample Types for each of the tests.\nWrite a program that takes as a command-line parameter the format of the report\n(i.e., organized by analyte or sample type). The output should consist of Patient\nname, test name, test result, and analyte or sample type.\nHint: you could store the table below as a new table in your database.\n(25 points)\nTest name\nTest\ncode\nAnalyte\nSample\ntype\nSerum sodium\nSodium\nSerum\nSerum potassium\nPotassium\nSerum\nTotal cholesterol\nCholesterol\nSerum\nSerum HCG\nHCG\nSerum\nHemoglobin\nHemoglobin\nWhole blood\nINR\nProthrombin Whole blood\nBlood urea nitrogen\nUrea\nWhole blood\nRed blood cell (RBC) count\nRBC\nWhole blood\nWhite blood cell (WBC)\ncount\nWBC\nWhole blood\nUrine Sodium\nSodium\nUrine\nPlease mail all your database meta, java source code, and output of the programs to\nta952@dsg.harvard.edu\nHint: Good documentation of software makes us happy ☺\nSAMPLE CODE FOR SENDING E-MAIL\nimport java.net.*;\nimport java.io.*;\npublic class SendAlertEmail {\npublic static void main (String[] args) {\nSocket socketSmtpServer = null;\nDataOutputStream dos\n= null;\nBufferedReader dis\n= null;\n// put your smtp server name between the quotes e.g. \"smtp.harvard.edu\"\nString smtpServerName = \" \";\n// put your login name on that server between the quotes below\nString strMyName = \" \";\nString strBuf; // stores messages from the SMTP server\nint portNumToListenTo = 25;\n/* generally, SMTP servers listen for connections on port 25, so\n\nHST 952\nFall 2002\nto establish a connection to an SMTP host, we need to create\na TCP/IP socket that is connected to port 25 of the SMTP host */\ntry {\n/** Establish a TCP/IP connection with the SMTP server you'll\nbe using to send your e-mail */\nsocketSmtpServer = new Socket(smtpServerName, portNumToListenTo);\ndos = new DataOutputStream(socketSmtpServer.getOutputStream());\ndis\n= new BufferedReader(new\nInputStreamReader(socketSmtpServer.getInputStream()));\n/** Done establishing the TCP/IP connection */\n/** Log in to the SMTP server */\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\n// The HELO command identifies you to the SMTP server\ndos.writeBytes(\"HELLO \" + strMyName + \"\\n\");\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\n// The RSET command resets the state of the SMTP server\ndos.writeBytes(\"RSET\\n\");\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\n/** Done logging in to server */\n/** Provide return and delivery addresses for your e-mail alert */\n// replace you@youraddress.com with your valid e-mail address\n// this will not work if you use an invalid e-mail address\ndos.writeBytes(\"MAIL FROM:<you@youraddress.com>\\n\");\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\n// replace you@youraddress.com with your valid e-mail address\ndos.writeBytes(\"RCPT TO:<you@youraddress.com>\\n\");\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\n/** Done providing return and delivery addresses */\n/** Construct data section of the e-mail alert including headers */\ndos.writeBytes (\"DATA\\n\");\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\n// create message headers\n/* Replace To: message with the appropriate physician's\nfirst name and last name and put your e-mail address\nin the angle brackets */\ndos.writeBytes (\"To: Physicianfirstname Physicianlastname \"\n+ \"<physician@physiciansaddress.com>\\n\");\n/* Replace From: message with your first name and last name\nand put your e-mail address in the angle brackets */\ndos.writeBytes (\"From: Yourfirstname Yourlastname \"\n+ \"<you@youraddress.com>\\n\");\ndos.writeBytes (\"Subject: Medical alert about your patient!\\n\");\ndos.writeBytes(\"Content-Type: text/plain; \"\n+ \"charset=\\\"us-ascii\\\"\\n\\n\");\n// create message body\n\nHST 952\nFall 2002\ndos.writeBytes(\"Your patient: <name of patient here> has elevated \"\n+ \"potassium levels!\\n\");\n// indicate end of e-mail message body\ndos.writeBytes(\"\\n.\\n\");\n// read line from SMTP server after indicating end of message body\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\n/** Done constructing data section of the e-mail alert */\n/** wrap up e-mail session with SMTP server */\ndos.writeBytes(\"QUIT\\n\");\nstrBuf = dis.readLine();\nSystem.out.println(strBuf);\ndos.close();\ndis.close();\nsocketSmtpServer.close();\nSystem.out.println(\"Done with e-mail session\");\n/** Done with e-mail session */\n}\ncatch (UnknownHostException e) {\nSystem.out.println(\"Host \" + smtpServerName + \" unknown\");\n}\ncatch (IOException e) {\nSystem.out.println(e);\n}\n}\n}"
    },
    {
      "category": "Resource",
      "title": "samplepatientsproject.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/hst-952-computing-for-biomedical-scientists-fall-2002/8c19843fe8a64bdc652f3b323e8305ba_samplepatientsproject.pdf",
      "content": "HST 952\nFall 2002\nSample Data for Project\nIf data for fields required in your sample database is not provided in this document, feel free to\nmake something up\nTest name\nAlert thresholds\nNormal range\nSerum sodium\nValue is greater than 140\n130 - 140\nSerum potassium\nValue is greater than 5.5 and less than 4\n4 - 5\nTotal cholesterol\nNone\n0 - 180\nSerum HCG\nNone\n0 - 200000\nHemoglobin\nValue is greater than 18 or less than 7\n9 - 15\nINR\nValue is greater than 5 or less than 2\n2.5 - 4.5\nBlood urea nitrogen\nValue is greater than 25 or less than 9\n12 - 20\nRed blood cell (RBC)\ncount\nValue is less than 2,000,000 cells per cubic\nmm\n4,000,000 -\n5,000,000\nWhite blood cell\n(WBC) count\nValue is le ss than 1,000 cells per cubic mm or\nmore than 12,000 cells per cubic mm\n3000 - 10,000\nUrine sodium\nValue is greater than 250\n75-200\nNote: These numbers are examples and are not intended to be realistic\nStore the information on the following patients:\ni) ID:\n00-223-45\nFirst name:\nManuel\nLast Name:\nJones\nDate of birth:\n1/1/1938\nGender:\nMale\nOrdered by:\nSpencer Lott\nTest name\nTime\nperformed\nTime\nordered\nUrgency\nSample\nreceived\ntime\nResult\nSerum sodium\n1/1/2001 3\npm\n1/1/2001\n1 pm\n1/1/2001\n1.30 pm\nSerum potassium\n1/1/2001 3\npm\n1/1/2001\n1 pm\n1/1/2001\n1.30 pm\n3.9\nTotal cholesterol\n1/1/2001 4\npm\n1/1/2001\n1 pm\n1/1/2001\n1.30 pm\nAlerts:\nAlert for low serum potassium sent by page to Dr. Lott on 1/1/2001 at 3.03\nii) ID:\n00-345-12\nFirst name:\nSumeeta\nLast Name:\nSidhu\nDate of birth:\n11/30/1965\nGender:\nFemale\nOrdered by:\nSpencer Lott\nHarvard-MIT Division of Health Sciences and Technology\nHST.952: Computing for Biomedical Scientists\n\nHST 952\nFall 2002\nTest name\nTime\nperformed\nTime\nordered\nUrgency\nSample\nreceived\ntime\nResult\nHemoglobin 6/12/2001\n4 pm\n6/12/2001\n8 am\n6/12/2001\n11 am\n14.8\nRBC Count\n6/12/2001\n4 pm\n6/12/2001\n8 am\n6/12/2001\n11 am\n4,500,000\nWBC Count\n6/12/2001\n4 pm\n6/12/2001\n8 am\n6/12/2001\n11 am\nSerum\npotassium\n7/22/2001\n11 am\n7/21/2001\n6 pm\n7/21/2001\n8 pm\n4.2\nSerum\npotassium\n7/29/2001\n10 am\n7/29/2001\n6.15 pm\n7/29/2001\n8.03 pm\n5.2\niii) ID:\n00-679-56\nFirst name:\nAngela\nLast Name:\nWinterbottom\nDate of birth:\n11/30/1971\nGender:\nFemale\nOrdered by:\nAlicia Stone\nTest name\nDate\nperformed\nTime\nordered\nUrgency\nSample\nreceived\ntime\nResult\nHCG\n4/6/2001\n2.30 pm\n4/4/2001\n3 pm\n4/6/2001 7\nam\nSerum\npotassium\n7/1/2001\n9 am\n7/1/2001\n8.11 am\n7/1/2001\n8.32 am\nSerum\npotassium\n7/10/2001\n10 am\n7/10/2001\n8 am\n7/10/2001\n8.45 am\n6.2\nAlerts:\nAlert for elevated serum potassium sent by page to Dr. Stone on 7/1/2001 at 9.10 am\nAlert for elevated serum potassium sent by page to Dr. Stone on 7/10/2001 at 10.09\nam\niv) ID:\n00-543-27\nFirst name:\nNita\nLast Name:\nHassan\nDate of birth:\n7/28/1969\nGender:\nFemale\nOrdered by:\nJames Jones\nTest name\nDate\nTime\nUrgency\nSample\nResult\n\nHST 952\nFall 2002\nperformed ordered\nreceived\ntime\nBlood Urea\nNitrogen\n5/7/2001\n6.01 pm\n5/7/2001 4\npm\n5/7/2001\n5.04 pm\nAlerts:\nAlert for elevated BUN sent by page to Dr. Jones on 5/7/2001 at 6.22 pm\nv) ID:\n00-152-37\nFirst name:\nAka\nLast Name:\nOmasumi\nDate of birth:\n6/20/1953\nGender:\nFemale\nOrdered by:\nJames Jones\nTest name\nDate\nperformed\nTime\nordered\nUrgency\nSample\nreceived\ntime\nResult\nHCG\n4/6/2001\n2.30 pm\n4/4/2001\n3 pm\n4/6/2001 7\nam\nSerum\npotassium\n7/1/2001\n9 am\n7/1/2001\n8.11 am\n7/1/2001\n8.32 am\nUrine\nsodium\n8/12/2001\n2 pm\n8/12/2001\n8 am\n8/12/2001\n8.45 am\nAlerts:\nAlert for elevated urine sodium sent by page to Dr. Jones on 8/12/2001 at 4.22 pm\nvi) ID:\n11-545-45\nFirst name:\nClaire\nLast Name:\nSkye\nDate of birth:\n11/20/1964\nGender:\nFemale\nOrdered by:\nSpencer Lott\nTest name\nTime\nperformed\nTime\nordered\nUrgency\nSample\nreceived\ntime\nResult\nUrine\nsodium\n6/12/2001\n2 pm\n6/11/2001\n8 am\n6/11/2001\n8.45 am\nRBC Count\n6/12/2001\n4 pm\n6/12/2001\n8 am\n6/12/2001\n11 am\n4,600,000\nWBC Count\n6/12/2001\n4 pm\n6/12/2001\n8 am\n6/12/2001\n11 am\nSerum\npotassium\n7/21/2001\n8 am\n7/20/2001\n6 pm\n7/20/2001\n8 pm\nSerum\n7/29/2001\n7/29/2001\n7/29/2001\n5.2\n\nHST 952\nFall 2002\npotassium\n10 am\n6.15 pm\n8.03 pm\nAlerts:\nAlert for elevated serum potassium sent by page to Dr. Lott on 7/21/2001 at 9.01 am\nPhysicians\ni.\nFirst name:\nJames\nLast Name:\nJones\nDate of birth: 6/9/1938\nGender:\nMale\nSpecialty:\nNephrologist\nii.\nFirst name:\nAlicia\nLast Name:\nStone\nDate of birth: 8/4/1967\nGender:\nFemale\nSpecialty:\nObstetrician\niii.\nFirst name:\nSpencer\nLast Name:\nLott\nDate of birth: 2/28/1945\nGender:\nMale\nSpecialty:\nInternist\nUrgency Levels\nLevel 1: Normal\nLevel 2: Urgent\nLevel 3: Stat"
    }
  ]
}