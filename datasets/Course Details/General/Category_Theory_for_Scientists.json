{
  "course_name": "Category Theory for Scientists",
  "course_description": "The goal of this class is to prove that category theory is a powerful language for understanding and formalizing common scientific models. The power of the language will be tested by its ability to penetrate into taken-for-granted ideas, either by exposing existing weaknesses or flaws in our understanding, or by highlighting hidden commonalities across scientific fields.",
  "topics": [
    "Mathematics",
    "Discrete Mathematics",
    "Mathematical Logic",
    "Science",
    "Mathematics",
    "Discrete Mathematics",
    "Mathematical Logic",
    "Science"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 3 sessions / week, 1 hour / session\n\nPrerequisite\n\nPermission of the instructor\n\nBooks\n\nThe required textbook for this course is available online:\n\nSpivak, David I.\nCategory Theory for Scientists\n, 2013.\n\nThe following book is also recommended:\n\nAwodey, Steve.\nCategory Theory\n. Oxford University Press, 2010. ISBN: 9780199237180.\n\nThe Goal of This Class\n\nThe goal of this class is to prove that category theory is a powerful language for understanding and formalizing common scientific models. The power of the language will be tested by its ability to penetrate into taken-for-granted ideas, either by exposing existing weaknesses or flaws in our understanding, or by highlighting hidden commonalities across scientific fields. Either of these will open up and clarify our thinking on a subject, and if category theory can help us do that consistently, then we should all be prepared to consider the class a success.\n\nHowever, it is possible that the class will fail this test. That is, in order to be really honest we must be willing to acknowledge that maybe category theory is not useful in expanding scientific thinking. But we will only admit defeat if we first make a good faith effort to prove its usefulness to ourselves and find that we come up short.\n\nTo that end, I am requesting your help. I have written a book with several scientific applications, but it could use many more. Once you understand a mathematical topic we discuss, look into your field to see how it might apply there. Such an application might be obvious and \"on the surface\" or creative and \"deep\", but anything of the sort will be useful to us. I want you to tell me what resonates with you, what works for you, what expands your thinking. You can express this in class or in written correspondence.\n\nI also want to hear from you what is missing. If we are to make a powerful impact on our thinking, we should be on the lookout for what we'd hope to find but seem to miss. We admit from the beginning that category theory is not intended to provide formulas that take in initial data and make predictions about the future. This is the domain of differential equations, linear algebra, and other well-known subjects in applied mathematics; it is not something we are attempting to improve upon with category theory. Instead we look into the possibility that some of the very\nstructure of our thinking\ncan be adequately represented and articulated in the language of category theory. To the degree that it can, the infusion of mathematics into our thinking will afford additional rigor, which should lead us to new insights. Be on the lookout for such openings. The overall point is that your engagement is very important for our success. Please speak up often in class and come to office hours.\n\nGrading\n\nAttending lecture is mandatory. Class participation is 33% of your grade. It's crucial that you ask questions when you don't understand.\n\nHomework is also worth 33% of your grade. It will be collected weekly. Late homework will generally not be accepted. Just turn in what you have when the homework is due.\n\nThe rest of your grade is based on your final project. This can either be an oral presentation or a publishable document. See the\nProjects\nsection for more details.\n\nACTIVITIES\n\nPERCENTAGES\n\nClass participation\n\n33%\n\nWeekly homework assignments\n\n33%\n\nFinal project\n\n34%",
  "files": [
    {
      "category": "Resource",
      "title": "Category Theory for Scientists text",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/9cf51d1394fc107baa6764d553dd0bb6_MIT18_S996S13_textbook.pdf",
      "content": "Category Theory for Scientists\n(Old Version)\nDavid I. Spivak\nSeptember 17, 2013\nHow can mathematics make this diagram meaningful?\n\nPreface\nAn early version of this book was put on line in February 2013 to serve as the textbook for\nmy course Category Theory for Scientists taught in the spring semester of 2013 at MIT.\nDuring that semester, students provided me with hundreds of comments and questions,\nwhich led to a substantial improvement (and the addition of 50 pages) to the original\ndocument.\nIn the summer of 2013 I signed a contract with the MIT Press to publish a new\nversion of this work under the title Category Theory for the Sciences. Because I am\ncommitted to the open source development model I insisted that a version of this book,\nnamely the one you are reading, remain freely available online. The MIT Press version\nwill of course not be free.\nOther than the title, there are two main differences between the present version and\nthe MIT Press version. The first difference is that I will do a full edit with the help\nof professional editors from the Press.\nThe second difference is that I will write up\nsolutions to the book's (approximately 280) exercises; some of these will be included in\nthe published version, whereas the rest will be available by way of a password-protected\npage, accessible only to professors who teach the subject.\n\nContents\nIntroduction\n1.1\nA brief history of category theory . . . . . . . . . . . . . . . . . . . . . . .\n1.2\nIntention of this book\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.3\nWhat is requested from the student . . . . . . . . . . . . . . . . . . . . . .\n1.4\nCategory theory references . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1.5\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nThe category of sets\n2.1\nSets and functions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.2\nCommutative diagrams\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.3\nOlogs\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.4\nProducts and coproducts . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.5\nFinite limits in Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.6\nFinite colimits in Set\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2.7\nOther notions in Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nCategories and functors, without admitting it\n3.1\nMonoids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.2\nGroups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.3\nGraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.4\nOrders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3.5\nDatabases: schemas and instances\n. . . . . . . . . . . . . . . . . . . . . . 102\nBasic category theory\n4.1\nCategories and Functors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113\n4.2\nCategories and functors commonly arising in mathematics . . . . . . . . . 129\n4.3\nNatural transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\n4.4\nCategories and schemas are equivalent, Cat » Sch . . . . . . . . . . . . . 165\n4.5\nLimits and colimits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169\n4.6\nOther notions in Cat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192\nCategories at work\n5.1\nAdjoint functors\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\n5.2\nCategories of functors\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n5.3\nMonads\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235\n5.4\nOperads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247\n\nCONTENTS\n\nChapter 1\nIntroduction\nThe title page of this book contains a graphic that we reproduce here.\n(1.1)\nIt is intended to evoke thoughts of the scientific method.\nA hypothesis analyzed by a person produces a prediction, which motivates the\nspecification of an experiment, which when executed results in an observation,\nwhich analyzed by a person yields a hypothesis.\nThis sounds valid, and a good graphic can be exceptionally useful for leading a reader\nthrough the story that the author wishes to tell.\nInterestingly, a graphic has the power to evoke feelings of understanding, without\nreally meaning much. The same is true for text: it is possible to use a language such as\nEnglish to express ideas that are never made rigorous or clear. When someone says \"I\nbelieve in free will,\" what does she believe in? We may all have some concept of what\nshe's saying--something we can conceptually work with and discuss or argue about. But\nto what extent are we all discussing the same thing, the thing she intended to convey?\nScience is about agreement. When we supply a convincing argument, the result of\nthis convincing is agreement.\nWhen, in an experiment, the observation matches the\nhypothesis--success!--that is agreement. When my methods make sense to you, that is\n\nCHAPTER 1. INTRODUCTION\nagreement. When practice does not agree with theory, that is disagreement. Agreement\nis the good stuffin science; it's the high fives.\nBut it is easy to think we're in agreement, when really we're not.\nModeling our\nthoughts on heuristics and pictures may be convenient for quick travel down the road,\nbut we're liable to miss our turnoffat the first mile. The danger is in mistaking our\nconvenient conceptualizations for what's actually there. It is imperative that we have\nthe ability at any time to ground out in reality. What does that mean?\nData. Hard evidence. The physical world. It is here that science touches down and\nheuristics evaporate. So let's look again at the diagram on the cover. It is intended\nto evoke an idea of how science is performed. Is there hard evidence and data to back\nthis theory up? Can we set up an experiment to find out whether science is actually\nperformed according to such a protocol? To do so we have to shake offthe stupor evoked\nby the diagram and ask the question: \"what does this diagram intend to communicate?\"\nIn this course I will use a mathematical tool called ologs, or ontology logs, to give\nsome structure to the kinds of ideas that are often communicated in pictures like the\none on the cover. Each olog inherently offers a framework in which to record data about\nthe subject. More precisely it encompasses a database schema, which means a system of\ninterconnected tables that are initially empty but into which data can be entered. For\nexample consider the olog below\na mass\nan object of mass\nm held at height h\nabove the ground\nhas as mass\no\nwhen dropped has\nas number of sec-\nonds till hitting the\nground\n&\nhas as height\nin meters\n\na real number h\n?\n?\n2h 9.8\n/ a real number\nThis olog represents a framework in which to record data about objects held above the\nground, their mass, their height, and a comparison (the ?-mark in the middle) between\nthe number of seconds till they hit the ground and a certain real-valued function of their\nheight. We will discuss ologs in detail throughout this course.\nThe picture in (1.1) looks like an olog, but it does not conform to the rules that\nwe lay out for ologs in Section 2.3. In an olog, every arrow is intended to represent a\nmathematical function. It is difficult to imagine a function that takes in predictions and\noutputs experiments, but such a function is necessary in order for the arrow\na prediction\nmotivates the specification of\nYYYYYYYYYYYYYYYYYYN an experiment\nin (1.1) to make sense. To produce an experiment design from a prediction probably\nrequires an expert, and even then the expert may be motivated to specify a different\nexperiment on Tuesday than he is on Monday. But perhaps our criticism has led to a\nway forward: if we say that every arrow represents a function when in the context of\na specific expert who is actually doing the science at a specific time, then Figure (1.1)\nbegins to make sense. In fact, we will return to the figure in Section 5.3 (specifically\nExample 5.3.3.10), where background methodological context is discussed in earnest.\n\n1.1. A BRIEF HISTORY OF CATEGORY THEORY\nThis course is an attempt to extol the virtues of a new branch of mathematics,\ncalled category theory, which was invented for powerful communication of ideas between\ndifferent fields and subfields within mathematics. By powerful communication of ideas I\nactually mean something precise. Different branches of mathematics can be formalized\ninto categories. These categories can then be connected together by functors. And the\nsense in which these functors provide powerful communication of ideas is that facts and\ntheorems proven in one category can be transferred through a connecting functor to\nyield proofs of analogous theorems in another category. A functor is like a conductor of\nmathematical truth.\nI believe that the language and toolset of category theory can be useful throughout\nscience. We build scientific understanding by developing models, and category theory is\nthe study of basic conceptual building blocks and how they cleanly fit together to make\nsuch models. Certain structures and conceptual frameworks show up again and again in\nour understanding of reality. No one would dispute that vector spaces are ubiquitous.\nBut so are hierarchies, symmetries, actions of agents on objects, data models, global\nbehavior emerging as the aggregate of local behavior, self-similarity, and the effect of\nmethodological context.\nSome ideas are so common that our use of them goes virtually undetected, such as set-\ntheoretic intersections. For example, when we speak of a material that is both lightweight\nand ductile, we are intersecting two sets. But what is the use of even mentioning this\nset-theoretic fact? The answer is that when we formalize our ideas, our understanding\nis almost always clarified. Our ability to communicate with others is enhanced, and the\npossibility for developing new insights expands. And if we are ever to get to the point\nthat we can input our ideas into computers, we will need to be able to formalize these\nideas first.\nIt is my hope that this course will offer scientists a new vocabulary in which to think\nand communicate, and a new pipeline to the vast array of theorems that exist and are\nconsidered immensely powerful within mathematics. These theorems have not made their\nway out into the world of science, but they are directly applicable there. Hierarchies are\npartial orders, symmetries are group elements, data models are categories, agent actions\nare monoid actions, local-to-global principles are sheaves, self-similarity is modeled by\noperads, context can be modeled by monads.\n1.1\nA brief history of category theory\nThe paradigm shift brought on by Einstein's theory of relativity brought on the real-\nization that there is no single perspective from which to view the world. There is no\nbackground framework that we need to find; there are infinitely many different frame-\nworks and perspectives, and the real power lies in being able to translate between them.\nIt is in this historical context that category theory got its start. 1\nCategory theory was invented in the early 1940s by Samuel Eilenberg and Saunders\nMac Lane.\nIt was specifically designed to bridge what may appear to be two quite\ndifferent fields: topology and algebra. Topology is the study of abstract shapes such as\n7-dimensional spheres; algebra is the study of abstract equations such as y2z \" x3 xz2.\nPeople had already created important and useful links (e.g. cohomology theory) between\nthese fields, but Eilenberg and Mac Lane needed to precisely compare different links with\n1The following history of category theory is far too brief, and perhaps reflects more of the author's\naesthetic than any kind of objective truth, whatever that may mean.\nHere are some much better\nreferences: [Kro], [Mar1], [LM].\n\nCHAPTER 1. INTRODUCTION\none another. To do so they first needed to boil down and extract the fundamental nature\nof these two fields. But the ideas they worked out amounted to a framework that fit not\nonly topology and algebra, but many other mathematical disciplines as well.\nAt first category theory was little more than a deeply clarifying language for existing\ndifficult mathematical ideas. However, in 1957 Alexander Grothendieck used category\ntheory to build new mathematical machinery (new cohomology theories) that granted\nunprecedented insight into the behavior of algebraic equations. Since that time, cat-\negories have been built specifically to zoom in on particular features of mathematical\nsubjects and study them with a level of acuity that is simply unavailable elsewhere.\nBill Lawvere saw category theory as a new foundation for all mathematical thought.\nMathematicians had been searching for foundations in the 19th century and were reason-\nably satisfied with set theory as the foundation. But Lawvere showed that the category\nof sets is simply a category with certain nice properties, not necessarily the center of\nthe mathematical universe. He explained how whole algebraic theories can be viewed\nas examples of a single system. He and others went on to show that higher order logic\nwas beautifully captured in the setting of category theory (more specifically toposes).\nIt is here also that Grothendieck and his school worked out major results in algebraic\ngeometry.\nIn 1980 Joachim Lambek showed that the types and programs used in computer\nscience form a specific kind of category. This provided a new semantics for talking about\nprograms, allowing people to investigate how programs combine and compose to create\nother programs, without caring about the specifics of implementation. Eugenio Moggi\nbrought the category theoretic notion of monads into computer science to encapsulate\nideas that up to that point were considered outside the realm of such theory.\nIt is difficult to explain the clarity and beauty brought to category theory by people\nlike Daniel Kan and Andr e Joyal. They have each repeatedly extracted the essence of a\nwhole mathematical subject to reveal and formalize a stunningly simple yet extremely\npowerful pattern of thinking, revolutionizing how mathematics is done.\nAll this time, however, category theory was consistently seen by much of the mathe-\nmatical community as ridiculously abstract. But in the 21st century it has finally come\nto find healthy respect within the larger community of pure mathematics. It is the lan-\nguage of choice for graduate-level algebra and topology courses, and in my opinion will\ncontinue to establish itself as the basic framework in which mathematics is done.\nAs mentioned above category theory has branched out into certain areas of science\nas well. Baez and Dolan have shown its value in making sense of quantum physics, it\nis well established in computer science, and it has found proponents in several other\nfields as well. But to my mind, we are the very beginning of its venture into scientific\nmethodology. Category theory was invented as a bridge and it will continue to serve in\nthat role.\n1.2\nIntention of this book\nThe world of applied mathematics is much smaller than the world of applicable math-\nematics. As alluded to above, this course is intended to create a bridge between the\nvast array of mathematical concepts that are used daily by mathematicians to describe\nall manner of phenomena that arise in our studies, and the models and frameworks of\nscientific disciplines such as physics, computation, and neuroscience.\nTo the pure mathematician I'll try to prove that concepts such as categories, func-\ntors, natural transformations, limits, colimits, functor categories, sheaves, monads, and\n\n1.2. INTENTION OF THIS BOOK\noperads--concepts that are often considered too abstract for even math majors--can\nbe communicated to scientists with no math background beyond linear algebra. If this\nmaterial is as teachable as I think, it means that category theory is not esoteric but\nsomehow well-aligned with ideas that already make sense to the scientific mind. Note,\nhowever, that this book is example-based rather than proof-based, so it may not be\nsuitable as a reference for students of pure mathematics.\nTo the scientist I'll try to prove the claim that category theory includes a formal\ntreatment of conceptual structures that the scientist sees often, perhaps without realizing\nthat there is well-oiled mathematical machinery to be employed. We will work on the\nstructure of information; how data is made meaningful by its connections, both internal\nand outreaching, to other data. Note, however, that this book should most certainly\nnot be taken as a reference on scientific matters themselves. One should assume that\nany account of physics, materials science, chemistry, etc. has been oversimplified. The\nintention is to give a flavor of how category theory may help us model scientific ideas,\nnot to explain these ideas in a serious way.\nData gathering is ubiquitous in science. Giant databases are currently being mined\nfor unknown patterns, but in fact there are many (many) known patterns that simply\nhave not been catalogued. Consider the well-known case of medical records. A patient's\nmedical history is often known by various individual doctor-offices but quite inadequately\nshared between them. Sharing medical records often means faxing a hand-written note\nor a filled-in house-created form between offices.\nSimilarly, in science there exists substantial expertise making brilliant connections\nbetween concepts, but it is being conveyed in silos of English prose known as journal\narticles. Every scientific journal article has a methods section, but it is almost impossible\nto read a methods section and subsequently repeat the experiment--the English language\nis inadequate to precisely and concisely convey what is being done.\nThe first thing to understand in this course is that reusable methodologies can be\nformalized, and that doing so is inherently valuable. Consider the following analogy.\nSuppose you want to add up the area of a region in space (or the area under a curve).\nYou break the region down into small squares, each of which you know has area A; then\nyou count the number of squares, say n, and the result is that the region has an area of\nabout nA. If you want a more precise and accurate result you repeat the process with\nhalf-size squares. This methodology can be used for any area-finding problem (of which\nthere are more than a first-year calculus student generally realizes) and thus it deserves\nto be formalized. But once we have formalized this methodology, it can be taken to its\nlimit and out comes integration by Riemann sums.\nI intend to show that category theory is incredibly efficient as a language for exper-\nimental design patterns, introducing formality while remaining flexible. It forms a rich\nand tightly woven conceptual fabric that will allow the scientist to maneuver between\ndifferent perspectives whenever the need arises. Once one builds that fabric for oneself,\nhe or she has an ability to think about models in a way that simply would not occur\nwithout it. Moreover, putting ideas into the language of category theory forces a person\nto clarify their assumptions. This is highly valuable both for the researcher and for his\nor her audience.\nWhat must be recognized in order to find value in this course is that conceptual chaos\nis a major problem. Creativity demands clarity of thinking, and to think clearly about a\nsubject requires an organized understanding of how its pieces fit together. Organization\nand clarity also lead to better communication with others. Academics often say they are\npaid to think and understand, but that is not true. They are paid to think, understand,\n\nCHAPTER 1. INTRODUCTION\nand communicate their findings.\nUniversal languages for science--languages such as\ncalculus and differential equations, matrices, or simply graphs and pie-charts--already\nexist, and they grant us a cohesiveness that makes scientific research worthwhile. In this\nbook I will attempt to show that category theory can be similarly useful in describing\ncomplex scientific understandings.\n1.3\nWhat is requested from the student\nI will do my best to make clear the value of category theory in science, but I am not a\nscientist. To that end I am asking for your help in exploring how category theory may\nbe useful in your specific field.\nI also want you to recognize that the value of mathematics is not generally obvious\nat first. A good student learning a good subject with a good teacher will see something\ncompelling almost immediately, but may not see how it will be useful in real life. This\nwill come later. I hope you will work hard to understand even without yet knowing what\nits actual value in your life and research will be. Like a student of soccer is encouraged\nto spend hours juggling the ball when he or she could be practicing penalty shots, it\nis important to gain facility with the materials you will be using. Doing exercises is\nimperative for learning mathematics.\n1.4\nCategory theory references\nI wrote this book because the available books on category theory are almost all written\nfor mathematicians (the rest are written for computer scientists). There is one book by\nLawvere and Schanuel, called Conceptual Mathematics [LS], that offers category theory\nto a wider audience, but its style is not appropriate for this course. Still, it is very well\nwritten and clear.\nThe \"bible\" of category theory is Categories for the working mathematician by Mac\nLane [Mac]. But as the title suggests, it was written for working mathematicians and\nwill be quite opaque to my target audience. However, once a person has read my book,\nMac Lane's book may become a valuable reference.\nOther good books include Steve Awodey's book Category theory [Awo] and Barr and\nWells book Category theory for computing science, [BW]. A paper by Brown and Porter\ncalled Category Theory: an abstract setting for analogy and comparison [BP1] is more\nin line with the style of this book, only much shorter. Online, I find wikipedia and a site\ncalled the nlab to be quite useful.\nThis book attempts to explain category theory by examples and exercises rather than\nby theorems and proofs. I hope this approach will be valuable to the working scientist.\n1.5\nAcknowledgments\nI would like to express my deep appreciation for the many scientists who I have worked\nwith over the past five years. It all started with Paea LePendu who first taught me about\ndatabases when I was naively knocking on doors in the University of Oregon computer\nscience department. This book would never have been written if Tristan Nguyen and\nDave Balaban had not noticed my work and encouraged me to continue. Dave Balaban\nand Peter Gates have been my scientific partners since the beginning, working hard to\n\n1.5. ACKNOWLEDGMENTS\nunderstand what I'm offering and working just as hard to help me understand all that\nI'm missing. Peter Gates has deepened my understanding of data in profound ways.\nI have also been tremendously lucky to know Haynes Miller, who made it possible\nfor me set down at MIT, with the help of Clark Barwick and Jacob Lurie. I knew that\nMIT would be the best place in the world for me to pursue this type of research, and\nit has really come through. Researchers like Markus Buehler and his graduate students\nTristan Giesa and Dieter Brommer have been a pleasure to work with, and the many\nmaterials science examples scattered throughout this book is a testament to how much\nour work together has influenced my thinking.\nI'd also like to thank my collaborators and conversation partners with whom I have\ndiscussed subjects written about in this book. Other than people mentioned above, these\ninclude Steve Awodey, Allen Brown, Adam Chlipala, Carlo Curino, Dan Dugger, Henrik\nForssell, David Gepner, Jason Gross, Bob Harper, Ralph Hutchison, Robert Kent, Jack\nMorava, Scott Morrison, David Platt, Joey Perricone, Dylan Rupel, Guarav Singh, Sam\nShames, Nat Stapleton, Patrick Schultz, Ka Yu Tam, Ryan Wisnesky, Jesse Wolfson,\nand Elizabeth Wood.\nI would like to thank Peter Kleinhenz and Peter Gates for reading this book and\nproviding invaluable feedback before I began teaching the 18-S996 class at MIT in Spring\n2013. In particular the cover image is a mild alteration of something Gates sent me to\nhelp motivate the book to scientists.\nI would also like to greatly thank the 18-S996\ncourse grader Darij Grinberg, who was not only the best grader I've had in my 14 years\nof teaching, but gave me more comments than anyone else on the book itself. I'd also like\nto thank the students from the 18-S996 class at MIT who helped me find typos, pointed\nme to unclear explanations, and generally helped me improve the book in many ways.\nOther than the people listed above, these include Aaron Brookner, Leon Dimas, Dylan\nErb, Deokhwan Kim, Taesoo Kim, Owen Lewis, Yair Shenfeld, and Adam Strandberg.\nI would like to thank my teacher, Peter Ralston, who taught me to repeatedly question\nthe obvious. My ability to commit to a project like this one and to see it to fruition has\ncertainly been enhanced since studying with him.\nFinally, I acknowledge my appreciation for support from the Office of Naval Research\n2 without which this book would not have been remotely possible. I believe that their\nfunding of basic research is an excellent way of ensuring that the US remains a global\nleader in the years to come.\n2Grant numbers: N000140910466, N000141010841, N000141310260\n\nCHAPTER 1. INTRODUCTION\n\nChapter 2\nThe category of sets\nThe theory of sets was invented as a foundation for all of mathematics. The notion of\nsets and functions serves as a basis on which to build our intuition about categories in\ngeneral. In this chapter we will give examples of sets and functions and then move on\nto discuss commutative diagrams. At this point we can introduce ologs which will allow\nus to use the language of category theory to speak about real world concepts. Then we\nwill introduce limits and colimits, and their universal properties. All of this material is\nbasic set theory, but it can also be taken as an investigation of our first category, the\ncategory of sets, which we call Set. We will end this chapter with some other interesting\nconstructions in Set that do not fit into the previous sections.\n2.1\nSets and functions\n2.1.1\nSets\nIn this course I'll assume you know what a set is. We can think of a set X as a collection\nof things x P X, each of which is recognizable as being in X and such that for each pair\nof named elements x, x1 P X we can tell if x \" x1 or not. 1 The set of pendulums is the\ncollection of things we agree to call pendulums, each of which is recognizable as being a\npendulum, and for any two people pointing at pendulums we can tell if they're pointing\nat the same pendulum or not.\nNotation 2.1.1.1. The symbol H denotes the set with no elements. The symbol N\ndenotes the set of natural numbers, which we can write as\nN :\" t0, 1, 2, 3, 4, . . . , 877, . . .u.\nThe symbol Z denotes the set of integers, which contains both the natural numbers and\ntheir negatives,\nZ :\" t. . . , 551, . . . , 2, 1, 0, 1, 2, . . .u.\nIf A and B are sets, we say that A is a subset of B, and write A D B, if every element\nof A is an element of B. So we have N D Z. Checking the definition, one sees that\n1Note that the symbol x1, read \"x-prime\", has nothing to do with calculus or derivatives. It is simply\nnotation that we use to name a symbol that is suggested as being somehow like x. This suggestion\nof kinship between x and x1 is meant only as an aid for human cognition, and not as part of the\nmathematics.\n\nCHAPTER 2. THE CATEGORY OF SETS\nFigure 2.1: A set X with 9 elements and a set Y with no elements, Y \" H.\nfor any set A, we have (perhaps uninteresting) subsets H D A and A D A. We can\nuse set-builder notation to denote subsets. For example the set of even integers can be\nwritten tn P Z | n is evenu. The set of integers greater than 2 can be written in many\nways, such as\ntn P Z | n a 2u\nor\ntn P N | n a 2u\nor\ntn P N | n e 3u.\nThe symbol D means \"there exists\". So we could write the set of even integers as\ntn P Z | n is evenu\n\"\ntn P Z | Dm P Z such that 2m \" nu.\nThe symbol D! means \"there exists a unique\". So the statement \"D!x P R such that x2 \"\n0\" means that there is one and only one number whose square is 0. Finally, the symbol\n@ means \"for all\". So the statement \"@m P N Dn P N such that m a n\" means that for\nevery number there is a bigger one.\nAs you may have noticed, we use the colon-equals notation \" A :\" XY Z \" to mean\nsomething like \"define A to be XY Z\". That is, a colon-equals declaration is not denoting\na fact of nature (like 2 ` 2 \" 4), but a choice of the speaker. It just so happens that the\nnotation above, such as N :\" t0, 1, 2, . . .u, is a widely-held choice.\nExercise 2.1.1.2. Let A \" t1, 2, 3u. What are all the subsets of A? Hint: there are 8. ♦\n2.1.2\nFunctions\nIf X and Y are sets, then a function f from X to Y , denoted f : X N Y , is a mapping\nthat sends each element x P X to an element of Y , denoted fpxq P Y . We call X the\ndomain of the function f and we call Y the codomain of f.\n\n2.1. SETS AND FUNCTIONS\n(2.2)\nNote that for every element x P X, there is exactly one arrow emanating from x,\nbut for an element y P Y , there can be several arrows pointing to y, or there can be no\narrows pointing to y.\nApplication 2.1.2.1. In studying the mechanics of materials, one wishes to know how a\nmaterial responds to tension. For example a rubber band responds to tension differently\nthan a spring does. To each material we can associate a force-extension curve, recording\nhow much force the material carries when extended to various lengths.\nOnce we fix\na methodology for performing experiments, finding a material's force-extension curve\nwould ideally constitute a function from the set of materials to the set of curves. 2\n♦♦\nExercise 2.1.2.2. Here is a simplified account of how the brain receives light. The eye\ncontains about 100 million photoreceptor (PR) cells. Each connects to a retinal ganglion\n(RG) cell. No PR cell connects to two different RG cells, but usually many PR cells can\nattach to a single RG cell.\nLet PR denote the set of photoreceptor cells and let RG denote the set of retinal\nganglion cells.\na.) According to the above account, does the connection pattern constitute a function\nRG N PR, a function PR N RG or neither one?\nb.) Would you guess that the connection pattern that exists between other areas of the\nbrain are \"function-like\"?\n♦\nExample 2.1.2.3. Suppose that X is a set and X1 D X is a subset. Then we can consider\nthe function X1 N X given by sending every element of X1 to \"itself\" as an element of\nX. For example if X \" ta, b, c, d, e, fu and X1 \" tb, d, eu then X1 D X and we turn that\ninto the function X1 N X given by b ÞN b, d ÞN d, e ÞN e. 3\nAs a matter of notation, we may sometimes say something like the following: Let X\nbe a set and let i: X1 D X be a subset. Here we are making clear that X1 is a subset of\nX, but that i is the name of the associated function.\n2In reality, different samples of the same material, say samples of different sizes or at different\ntemperatures, may have different force-extension curves. If we want to see this as a true function whose\ncodomain is curves it should have as domain something like the set of material samples.\n3This kind of arrow, ÞN , is read aloud as \"maps to\". A function f : X N Y means a rule for assigning\nto each element x P X an element fpxq P Y . We say that \"x maps to fpxq\" and write x ÞN fpxq.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExercise 2.1.2.4. Let f : N N N be the function that sends every natural number to its\nsquare, e.g. fp6q \" 36. First fill in the blanks below, then answer a question.\na.) 2 ÞN\nb.) 0 ÞN\nc.) 2 ÞN\nd.) 5 ÞN\ne.) Consider the symbol N and the symbol ÞN. What is the difference between how\nthese two symbols are used in this book?\n♦\nGiven a function f : X N Y , the elements of Y that have at least one arrow pointing\nto them are said to be in the image of f; that is we have\nimpfq :\" ty P Y | Dx P X such that fpxq \" yu.\n(2.3)\nExercise 2.1.2.5. If f : X N Y is depicted by (2.2) above, write its image, impfq as a\nset.\n♦\nGiven a function f : X N Y and a function g: Y N Z, where the codomain of f is\nthe same set as the domain of g (namely Y ), we say that f and g are composable\nX\nf\nYYYN Y\ng\nYYYN Z.\nThe composition of f and g is denoted by g f : X N Z.\nFigure 2.4: Functions f : X N Y and g: Y N Z compose to a function g f : X N Z;\njust follow the arrows.\nLet X and Y be sets. We write HomSetpX, Y q to denote the set of functions X N Y .\n4 Note that two functions f, g: X N Y are equal if and only if for every element x P X\nwe have fpxq \" gpxq.\nExercise 2.1.2.6. Let A \" t1, 2, 3, 4, 5u and B \" tx, yu.\n4The strange notation HomSetp , q will make more sense later, when it is seen as part of a bigger\nstory.\n\n2.1. SETS AND FUNCTIONS\na.) How many elements does HomSetpA, Bq have?\nb.) How many elements does HomSetpB, Aq have?\n♦\nExercise 2.1.2.7.\na.) Find a set A such that for all sets X there is exactly one element in HomSetpX, Aq.\nHint: draw a picture of proposed A's and X's.\nb.) Find a set B such that for all sets X there is exactly one element in HomSetpB, Xq.\n♦\nFor any set X, we define the identity function on X, denoted idX : X N X, to be\nthe function such that for all x P X we have idXpxq \" x.\nDefinition 2.1.2.8 (Isomorphism). Let X and Y be sets. A function f : X N Y is\ncalled an isomorphism, denoted f : X\n-\nYN Y , if there exists a function g: Y N X such\nthat g f \" idX and f g \" idY . We also say that f is invertible and we say that g\nis the inverse of f. If there exists an isomorphism X\n-\nYN Y we say that X and Y are\nisomorphic sets and may write X - Y .\nExample 2.1.2.9. If X and Y are sets and f : X N Y is an isomorphism then the\nanalogue of Diagram 2.2 will look like a perfect matching, more often called a one-to-\none correspondence. That means that no two arrows will hit the same element of Y ,\nand every element of Y will be in the image. For example, the following depicts an\nisomorphism X\n-\nYN Y .\nApplication 2.1.2.10. There is an isomorphism between the set NucDNA of nucleotides\nfound in DNA and the set NucRNA of nucleotides found in RNA. Indeed both sets have\nfour elements, so there are 24 different isomorphisms. But only one is useful. Before we\nsay which one it is, let us say there is also an isomorphism NucDNA - tA, C, G, Tu and\nan isomorphism NucRNA - tA, C, G, Uu, and we will use the letters as abbreviations for\nthe nucleotides.\nThe convenient isomorphism NucDNA\n-\nYN NucRNA is that given by RNA transcription;\nit sends\nA ÞN U, C ÞN G, G ÞN C, T ÞN A.\n\nCHAPTER 2. THE CATEGORY OF SETS\n(See also Application 4.1.2.19.) There is also an isomorphism NucDNA\n-\nYN NucDNA (the\nmatching in the double-helix) given by\nA ÞN T, C ÞN G, G ÞN C, T ÞN A.\nProtein production can be modeled as a function from the set of 3-nucleotide se-\nquences to the set of eukaryotic amino acids. However, it cannot be an isomorphism\nbecause there are 43 \" 64 triplets of RNA nucleotides, but only 21 eukaryotic amino\nacids.\n♦♦\nExercise 2.1.2.11. Let n P N be a natural number and let X be a set with exactly n\nelements.\na.) How many isomorphisms are there from X to itself?\nb.) Does your formula from part a.) hold when n \" 0?\n♦\nLemma 2.1.2.12. The following facts hold about isomorphism.\n1. Any set A is isomorphic to itself; i.e. there exists an isomorphism A -\nYN A.\n2. For any sets A and B, if A is isomorphic to B then B is isomorphic to A.\n3. For any sets A, B, and C, if A is isomorphic to B and B is isomorphic to C then\nA is isomorphic to C.\nProof.\n1. The identity function idA : A N A is invertible; its inverse is idA because\nidA idA \" idA.\n2. If f : A N B is invertible with inverse g: B N A then g is an isomorphism with\ninverse f.\n3. If f : A N B and f 1 : B N C are each invertible with inverses g: B N A and\ng1 : C N B then the following calculations show that f 1 f is invertible with\ninverse g g1:\npf 1 fq pg g1q \" f 1 pf gq g1 \" f 1 idB g1 \" f 1 g1 \" idC\npg g1q pf 1 fq \" g pg1 f 1q f \" g idB f \" g f \" idA\n□\nExercise 2.1.2.13. Let A and B be the sets drawn below:\nA:=\na‚\n7‚\nQ‚\nB:=\nr8‚\n\"Bob\"\n‚\n♣‚\n\n2.1. SETS AND FUNCTIONS\nNote that the sets A and B are isomorphic. Supposing that f : B N t1, 2, 3, 4, 5u sends\n\"Bob\" to 1, sends ♣to 3, and sends r8 to 4, is there a canonical function A N t1, 2, 3, 4, 5u\ncorresponding to f? 5\n♦\nExercise 2.1.2.14. Find a set A such that for any set X there is a isomorphism of sets\nX - HomSetpA, Xq.\nHint: draw a picture of proposed A's and X's.\n♦\nFor any natural number n P N, define a set\nn :\" t1, 2, 3, . . . , nu.\n(2.6)\nSo, in particular, 2 \" t1, 2u, 1 \" t1u, and 0 \" H.\nLet A be any set. A function f : n N A can be written as a sequence\nf \" pfp1q, fp2q, . . . , fpnqq.\nExercise 2.1.2.15.\na.) Let A \" ta, b, c, du. If f : 10 N A is given by pa, b, c, c, b, a, d, d, a, bq, what is fp4q?\nb.) Let s: 7 N N be given by spiq \" i2. Write s out as a sequence.\n♦\nDefinition 2.1.2.16. Cardinality of finite sets][\nLet A be a set and n P N a natural number. We say that A is has cardinality n,\ndenoted\n|A| \" n,\nif there exists an isomorphism of sets A - n. If there exists some n P N such that A has\ncardinality n then we say that A is finite. Otherwise, we say that A is infinite and write\n|A| e 8.\nExercise 2.1.2.17.\na.) Let A \" t5, 6, 7u. What is |A|?\nb.) What is |N|?\nc.) What is |tn P N | n d 5u|?\n♦\nLemma 2.1.2.18. Let A and B be finite sets. If there is an isomorphism of sets f : A N\nB then the two sets have the same cardinality, |A| \" |B|.\nProof. Suppose f : A N B is an isomorphism. If there exists natural numbers m, n P\nN and isomorphisms a: m\n-\nYN A and b: n\n-\nYN B then m\na 1\nYYN A\nfYN B\nbYN n is an\nisomorphism. One can prove by induction that the sets m and n are isomorphic if and\nonly if m \" n.\n□\n5Canonical means something like \"best choice\", a choice that stands out as the only reasonable one.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.2\nCommutative diagrams\nAt this point it is difficult to precisely define diagrams or commutative diagrams in\ngeneral, but we can give the heuristic idea. 6 Consider the following picture:\nA\nf\n/\nh\n\nB\ng\n\nC\n(2.7)\nWe say this is a diagram of sets if each of A, B, C is a set and each of f, g, h is a function.\nWe say this diagram commutes if g f \" h. In this case we refer to it as a commutative\ntriangle of sets.\nApplication 2.2.1.1. The central dogma of molecular biology is that \"DNA codes for\nRNA codes for protein\". That is, there is a function from DNA triplets to RNA triplets\nand a function from RNA triplets to amino acids. But sometimes we just want to discuss\nthe translation from DNA to amino acids, and this is the composite of the other two.\nThe commutative diagram is a picture of this fact.\n♦♦\nConsider the following picture:\nA\nf\n/\nh\n\nB\ng\n\nC\ni\n/ D\nWe say this is a diagram of sets if each of A, B, C, D is a set and each of f, g, h, i is a\nfunction. We say this diagram commutes if g f \" i h. In this case we refer to it as a\ncommutative square of sets.\nApplication 2.2.1.2. Given a physical system S, there may be two mathematical ap-\nproaches f : S N A and g: S N B that can be applied to it. Either of those results in\na prediction of the same sort, f 1 : A N P and g1 : B N P. For example, in mechanics\nwe can use either Lagrangian approach or the Hamiltonian approach to predict future\nstates. To say that the diagram\nS\n/\n\nA\n\nB\n/ P\ncommutes would say that these approaches give the same result.\n♦♦\nAnd so on. Note that diagram (2.7) is considered to be the same diagram as each of\n6We will define commutative diagrams precisely in Section 4.5.2.\n\n2.3. OLOGS\nthe following:\nA\nf\n/\nh\n\nB\ng\n\nC\nA\nf\n/\nh\nB\ng\n/ C\nB\ng\n\nC\nA\nh\n?\nf\nO\n2.3\nOlogs\nIn this course we will ground the mathematical ideas in applications whenever possible.\nTo that end we introduce ologs, which will serve as a bridge between mathematics and\nvarious conceptual landscapes. The following material is taken from [SK], an introduction\nto ologs.\nD\nan amino acid\nfound in dairy\nis\n&\nA\narginine\n✓\n✓\nhas\n/\nis\no\nis\n\nE\nan electrically-\ncharged side\nchain\nis\n\nX\nan amino acid\nhas\nw\nhas\n'\nhas\n/\nR\na side chain\nN\nan amine group\nC\na carboxylic acid\n(2.8)\n2.3.1\nTypes\nA type is an abstract concept, a distinction the author has made. We represent each\ntype as a box containing a singular indefinite noun phrase. Each of the following four\nboxes is a type:\na man\nan automobile\na pair pa, wq, where w is\na woman and a is an au-\ntomobile\na pair pa, wq where w is\na woman and a is a blue\nautomobile owned by w\n(2.9)\nEach of the four boxes in (2.9) represents a type of thing, a whole class of things,\nand the label on that box is what one should call each example of that class. Thus ⌜a\nman⌝does not represent a single man, but the set of men, each example of which is\ncalled \"a man\". Similarly, the bottom right box represents an abstract type of thing,\n\nCHAPTER 2. THE CATEGORY OF SETS\nwhich probably has more than a million examples, but the label on the box indicates the\ncommon name for each such example.\nTypographical problems emerge when writing a text-box in a line of text, e.g. the\ntext-box a man seems out of place here, and the more in-line text-boxes there are, the\nworse it gets. To remedy this, I will denote types which occur in a line of text with\ncorner-symbols; e.g. I will write ⌜a man⌝instead of a man .\n2.3.1.1\nTypes with compound structures\nMany types have compound structures; i.e. they are composed of smaller units. Exam-\nples include\na man and\na woman\na food portion f and\na child c such that c\nate all of f\na triple pp, a, jq where p is\na paper, a is an author of\np, and j is a journal in\nwhich p was published\n(2.10)\nIt is good practice to declare the variables in a \"compound type\", as I did in the last\ntwo cases of (2.10). In other words, it is preferable to replace the first box above with\nsomething like\na man m and\na woman w\nor\na pair pm, wq\nwhere m is a man\nand w is a woman\nso that the variables pm, wq are clear.\nRules of good practice 2.3.1.2. A type is presented as a text box. The text in that box\nshould\n(i) begin with the word \"a\" or \"an\";\n(ii) refer to a distinction made and recognizable by the olog's author;\n(iii) refer to a distinction for which instances can be documented;\n(iv) declare all variables in a compound structure.\nThe first, second, and third rules ensure that the class of things represented by\neach box appears to the author as a well-defined set. The fourth rule encourages good\n\"readability\" of arrows, as will be discussed next in Section 2.3.2.\nI will not always follow the rules of good practice throughout this document.\nI\nthink of these rules being followed \"in the background\" but that I have \"nicknamed\"\nvarious boxes. So ⌜Steve⌝may stand as a nickname for ⌜a thing classified as Steve⌝\nand ⌜arginine⌝as a nickname for ⌜a molecule of arginine⌝. However, when pressed, one\nshould always be able to rename each type according to the rules of good practice.\n2.3.2\nAspects\nAn aspect of a thing x is a way of viewing it, a particular way in which x can be regarded\nor measured. For example, a woman can be regarded as a person; hence \"being a person\"\nis an aspect of a woman. A molecule has a molecular mass (say in daltons), so \"having\na molecular mass\" is an aspect of a molecule. In other words, by aspect we simply mean\n\n2.3. OLOGS\na function. The domain A of the function f : A N B is the thing we are measuring, and\nthe codomain is the set of possible \"answers\" or results of the measurement.\na woman\nis\n/ a person\n(2.11)\na molecule\nhas as molecular mass (Da) / a positive real number\n(2.12)\nSo for the arrow in (2.11), the domain is the set of women (a set with perhaps 3 billion\nelements); the codomain is the set of persons (a set with perhaps 6 billion elements).\nWe can imagine drawing an arrow from each dot in the \"woman\" set to a unique dot in\nthe \"person\" set, just as in (2.2). No woman points to two different people, nor to zero\npeople -- each woman is exactly one person -- so the rules for a function are satisfied.\nLet us now concentrate briefly on the arrow in (2.12). The domain is the set of molecules,\nthe codomain is the set Ra0 of positive real numbers. We can imagine drawing an arrow\nfrom each dot in the \"molecule\" set to a single dot in the \"positive real number\" set. No\nmolecule points to two different masses, nor can a molecule have no mass: each molecule\nhas exactly one mass. Note however that two different molecules can point to the same\nmass.\n2.3.2.1\nInvalid aspects\nI tried above to clarify what it is that makes an aspect \"valid\", namely that it must be\na \"functional relationship.\" In this subsection I will show two arrows which on their face\nmay appear to be aspects, but which on closer inspection are not functional (and hence\nare not valid as aspects).\nConsider the following two arrows:\na person\nhas / a child\n(2.13*)\na mechanical pencil\nuses / a piece of lead\n(2.14*)\nA person may have no children or may have more than one child, so the first arrow is\ninvalid: it is not a function. Similarly, if we drew an arrow from each mechanical pencil\nto each piece of lead it uses, it would not be a function.\nWarning 2.3.2.2. The author of an olog has a world-view, some fragment of which is\ncaptured in the olog. When person A examines the olog of person B, person A may or\nmay not \"agree with it.\" For example, person B may have the following olog\na marriage\nincludes\n&\nincludes\nx\na man\na woman\nwhich associates to each marriage a man and a woman. Person A may take the position\nthat some marriages involve two men or two women, and thus see B's olog as \"wrong.\"\n\nCHAPTER 2. THE CATEGORY OF SETS\nSuch disputes are not \"problems\" with either A's olog or B's olog, they are discrepancies\nbetween world-views. Hence, throughout this paper, a reader R may see a displayed olog\nand notice a discrepancy between R's world-view and my own, but R should not worry\nthat this is a problem. This is not to say that ologs need not follow rules, but instead\nthat the rules are enforced to ensure that an olog is structurally sound, rather than that\nit \"correctly reflects reality,\" whatever that may mean.\nConsider the aspect ⌜an object⌝\nhas\nYYYYN ⌜a weight⌝. At some point in history, this\nwould have been considered a valid function.\nNow we know that the same object\nwould have a different weight on the moon than it has on earth.\nThus as world-\nviews change, we often need to add more information to our olog. Even the validity\nof ⌜an object on earth⌝\nhas\nYYYYN ⌜a weight⌝is questionable. However to build a model\nwe need to choose a level of granularity and try to stay within it, or the whole model\nevaporates into the nothingness of truth!\nRemark 2.3.2.3. In keeping with Warning 2.3.2.2, the arrows (2.13*) and (2.14*) may\nnot be wrong but simply reflect that the author has a strange world-view or a strange\nvocabulary. Maybe the author believes that every mechanical pencil uses exactly one\npiece of lead. If this is so, then ⌜a mechanical pencil⌝\nuses\nYYN ⌜a piece of lead⌝is indeed\na valid aspect! Similarly, suppose the author meant to say that each person was once\na child, or that a person has an inner child. Since every person has one and only one\ninner child (according to the author), the map ⌜a person⌝has as inner child\nYYYYYYYYYYYN ⌜a child⌝is a\nvalid aspect. We cannot fault the olog if the author has a view, but note that we have\nchanged the name of the label to make his or her intention more explicit.\n2.3.2.4\nReading aspects and paths as English phrases\nEach arrow (aspect) X\nfYN Y can be read by first reading the label on its source box\n(domain of definition) X, then the label on the arrow f, and finally the label on its\ntarget box (set of values) Y . For example, the arrow\na book\nhas as first author\n/ a person\n(2.15)\nis read \"a book has as first author a person\".\nRemark 2.3.2.5. Note that the map in (2.15) is a valid aspect, but that a similarly\nbenign-looking map ⌜a book⌝\nhas as author\nYYYYYYYYN ⌜a person⌝would not be valid, because it\nis not functional. The authors of an olog must be vigilant about this type of mistake\nbecause it is easy to miss and it can corrupt the olog.\nSometimes the label on an arrow can be shortened or dropped altogether if it is\nobvious from context. We will discuss this more in Section 2.3.3 but here is a common\n\n2.3. OLOGS\nexample from the way I write ologs.\nA\na pair px, yq where\nx and y are integers\nx\nx\ny\n&\nB\nan integer\nB\nan integer\n(2.16)\nNeither arrow is readable by the protocol given above (e.g. \"a pair px, yq where x and\ny are integers x an integer\" is not an English sentence), and yet it is obvious what each\nmap means. For example, given p8, 11q in A, arrow x would yield 8 and arrow y would\nyield 11. The label x can be thought of as a nickname for the full name \"yields, via the\nvalue of x,\" and similarly for y. I do not generally use the full name for fear that the\nolog would become cluttered with text.\nOne can also read paths through an olog by inserting the word \"which\" after each\nintermediate box. 7 For example the following olog has two paths of length 3 (counting\narrows in a chain):\na child\nis\n/ a person\nhas as parents\n/\nhas, as birthday\n!\na pair pw, mq\nwhere w is a\nwoman and m\nis a man\nw\n/ a woman\na date\nincludes / a year\n(2.17)\nThe top path is read \"a child is a person, who has as parents a pair pw, mq where w is a\nwoman and m is a man, which yields, via the value of w, a woman.\" The reader should\nread and understand the content of the bottom path, which associates to every child a\nyear.\n2.3.2.6\nConverting non-functional relationships to aspects\nThere are many relationships that are not functional, and these cannot be considered\naspects. Often the word \"has\" indicates a relationship -- sometimes it is functional as in\n⌜a person⌝\nhas\nYYYN ⌜a stomach⌝, and sometimes it is not, as in ⌜a father⌝\nhas\nYYN ⌜a child⌝.\nObviously, a father may have more than one child. This one is easily fixed by realizing\nthat the arrow should go the other way: there is a function ⌜a child⌝has\nYYN ⌜a father⌝.\nWhat about ⌜a person⌝\nowns\nYYYN ⌜a car⌝. Again, a person may own no cars or more\nthan one car, but this time a car can be owned by more than one person too. A quick fix\nwould be to replace it by ⌜a person⌝owns\nYYYN ⌜a set of cars⌝. This is ok, but the relationship\nbetween ⌜a car⌝and ⌜a set of cars⌝then becomes an issue to deal with later. There is\n7If the intended elements of an intermediate box are humans, it is polite to use \"who\" rather than\n\"which\", and other such conventions may be upheld if one so desires.\n\nCHAPTER 2. THE CATEGORY OF SETS\nanother way to indicate such \"non-functional\" relationships. In this case it would look\nlike this:\na pair pp, cq where\np is a person, c is a\ncar, and p owns c.\np\n~\nc\n\na person\na car\nThis setup will ensure that everything is properly organized. In general, relationships\ncan involve more than two types, and the general situation looks like this\nR\n{\n\nA1\nA2\n\nAn\nFor example,\nR\na sequence pp, a, jq where p\nis a paper, a is an author\nof p, and j is a journal in\nwhich p was published\np\n}\na\n\nj\n!\nA1\na paper\nA2\nan author\nA3\na journal\nExercise 2.3.2.7. On page 25 we indicate a so-called invalid aspect, namely\na person\nhas / a child\n(2.13*)\nCreate a (valid) olog that captures the parent-child relationship; your olog should still\nhave boxes ⌜a person⌝and ⌜a child⌝but may have an additional box.\n♦\nRules of good practice 2.3.2.8. An aspect is presented as a labeled arrow, pointing from\na source box to a target box. The arrow text should\n\n2.3. OLOGS\n(i) begin with a verb;\n(ii) yield an English sentence, when the source-box text followed by the arrow text\nfollowed by the target-box text is read; and\n(iii) refer to a functional relationship: each instance of the source type should give rise\nto a specific instance of the target type.\n2.3.3\nFacts\nIn this section I will discuss facts, which are simply \"path equivalences\" in an olog. It is\nthe notion of path equivalences that make category theory so powerful.\nA path in an olog is a head-to-tail sequence of arrows. That is, any path starts at\nsome box B0, then follows an arrow emanating from B0 (moving in the appropriate\ndirection), at which point it lands at another box B1, then follows any arrow emanating\nfrom B1, etc, eventually landing at a box Bn and stopping there. The number of arrows\nis the length of the path. So a path of length 1 is just an arrow, and a path of length 0\nis just a box. We call B0 the source and Bn the target of the path.\nGiven an olog, the author may want to declare that two paths are equivalent. For\nexample consider the two paths from A to C in the olog\nA\na person\nhas as parents /\nhas as mother\n&\nB\na pair pw, mq\nwhere w is a\nwoman and\nm is a man\n✓\nyields as w\n\nC\na woman\n(2.18)\nWe know as English speakers that a woman parent is called a mother, so these two paths\nA N C should be equivalent. A more mathematical way to say this is that the triangle in\nOlog (2.18) commutes. That is, path equivalences are simply commutative diagrams as\nin Section 2.2. In the example above we concisely say \"a woman parent is equivalent to\na mother.\" We declare this by defining the diagonal map in (2.18) to be the composition\nof the horizontal map and the vertical map.\nI generally prefer to indicate a commutative diagram by drawing a check-mark, ✓,\nin the region bounded by the two paths, as in Olog (2.18). Sometimes, however, one\ncannot do this unambiguously on the 2-dimensional page. In such a case I will indicate\nthe commutative diagrams (fact) by writing an equation. For example to say that the\ndiagram\nA\nf\n/\nh\n\nB\ng\n\nC\ni\n/ D\ncommutes, we could either draw a checkmark inside the square or write the equation\n\nCHAPTER 2. THE CATEGORY OF SETS\nA f g » A h i above it. 8 Either way, it means that \"f then g\" is equivalent to \"h then\ni\".\nHere is another, more scientific example:\na DNA sequence\nis transcribed to /\ncodes for\n*\nan RNA sequence\n✓\nis translated to\n\na protein\nNote how this diagram gives us the established terminology for the various ways in which\nDNA, RNA, and protein are related in this context.\nExercise 2.3.3.1. Create an olog for human nuclear biological families that includes the\nconcept of person, man, woman, parent, father, mother, and child. Make sure to label\nall the arrows, and make sure each arrow indicates a valid aspect in the sense of Section\n2.3.2.1. Indicate with check-marks (✓) the diagrams that are intended to commute. If the\n2-dimensionality of the page prevents a check-mark from being unambiguous, indicate\nthe intended commutativity with an equation.\n♦\nExample 2.3.3.2 (Non-commuting diagram). In my conception of the world, the following\ndiagram does not commute:\na person\nhas as father /\nlives in\n#\na man\nlives in\n\na city\n(2.19)\nThe non-commutativity of Diagram (2.19) does not imply that, in my conception, no\nperson lives in the same city as his or her father. Rather it implies that, in my conception,\nit is not the case that every person lives in the same city as his or her father.\nExercise 2.3.3.3. Create an olog about a scientific subject, preferably one you think\nabout often. The olog should have at least five boxes, five arrows, and one commutative\ndiagram.\n♦\n2.3.3.4\nA formula for writing facts as English\nEvery fact consists of two paths, say P and Q, that are to be declared equivalent. The\npaths P and Q will necessarily have the same source, say s, and target, say t, but their\n8We defined function composition on page 2.1.2, but here we're using a different notation. There we\nwould have said g f \" i h, which is in the backwards-seeming classical order. Category theorists\nand others often prefer the diagrammatic order for writing compositions, which is f; g \" h; i. For ologs,\nwe follow the latter because it makes for better English sentences, and for the same reason we add the\nsource object to the equation, writing Afg » Ahi.\n\n2.3. OLOGS\nlengths may be different, say m and n respectively. 9 We draw these paths as\nP :\na0\"s\n‚\nf1\n/ a1‚\nf2 / a2‚\nf3 /\nfm 1/ am 1\n‚\nfm / am\"t\n‚\n(2.20)\nQ :\nb0\"s\n‚\ng1\n/ b1‚\ng2\n/ b2‚\ng3 /\ngn 1 / bn 1\n‚\ngn / bn\"t\n‚\nEvery part lof an olog (i.e. every box and every arrow) has an associated English phrase,\nwhich we write as \"l\". Using a dummy variable x we can convert a fact into English too.\nThe following general formula is a bit difficult to understand, see Example 2.3.3.5, but\nhere goes. The fact P » Q from (2.20) can be Englishified as follows:\nGiven x, \"s\", consider the following. We know that x is \"s\",\n(2.21)\nwhich \"f1\" \"a1\", which \"f2\" \"a2\", which . . . \"fm 1\" \"am 1\", which \"fm\" \"t\"\nthat we'll call Ppxq.\nWe also know that x is \"s\",\nwhich \"g1\" \"b1\", which \"g2\" \"b2\", which . . . \"gn 1\" \"bn 1\", which \"gn\" \"t\"\nthat we'll call Qpxq.\nFact: whenever x is \"s\", we will have Ppxq \" Qpxq.\nExample 2.3.3.5. Consider the olog\nA\na person\nhas\n/\nlives in\n'\nB\nan address\n✓\nis in\n\nC\na city\n(2.22)\nTo put the fact that Diagram 2.22 commutes into English, we first Englishify the two\npaths: F=\"a person has an address which is in a city\" and G=\"a person lives in a city\".\nThe source of both is s=\"a person\" and the target of both is t=\"a city\". write:\nGiven x, a person, consider the following. We know that x is a person,\nwhich has an address, which is in a city\nthat we'll call Ppxq.\nWe also know that x is a person,\nwhich lives in a city\nthat we'll call Qpxq.\nFact: whenever x is a person, we will have Ppxq \" Qpxq.\n9If the source equals the target, s \" t, then it is possible to have m \" 0 or n \" 0, and the ideas below\nstill make sense.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExercise 2.3.3.6. This olog was taken from [Sp1].\nN\na phone number\nhas\n/\nC\nan area code\n✓\ncorresponds to\n\nOLP\nan operational land-\nline phone\nis assigned\nis\n/\nP\na physical phone\nis currently\nlocated in\n/\nR\na region\n(2.23)\nIt says that a landline phone is physically located in the region that its phone number\nis assigned. Translate this fact into English using the formula from 2.21.\n♦\nExercise 2.3.3.7. In the above olog (2.23), suppose that the box ⌜an operational landline\nphone⌝is replaced with the box ⌜an operational mobile phone⌝. Would the diagram still\ncommute?\n♦\n2.3.3.8\nImages\nIn this section we discuss a specific kind of fact, generated by any aspect. Recall that\nevery function has an image, meaning the subset of elements in the codomain that are\n\"hit\" by the function. For example the function fpxq \" 2 x: Z N Z has as image the\nset of all even numbers.\nSimilarly the set of mothers arises as is the image of the \"has as mother\" function,\nas shown below\nP\na person\nhas\n$\nf : P NP\nhas as mother\n/\nP\na person\nM\"impfq\na mother\nis\n:\n✓\nExercise 2.3.3.9. For each of the following types, write down a function for which it is\nthe image, or say \"not clearly an image type\"\na.) ⌜a book⌝\nb.) ⌜a material that has been fabricated by a process of type T⌝\nc.) ⌜a bicycle owner⌝\nd.) ⌜a child⌝\ne.) ⌜a used book⌝\nf.) ⌜an inhabited residence⌝\n♦\n2.4\nProducts and coproducts\nIn this section we introduce two concepts that are likely to be familiar, although perhaps\nnot by their category-theoretic names, product and coproduct. Each is an example of a\n\n2.4. PRODUCTS AND COPRODUCTS\nlarge class of ideas that exist far beyond the realm of sets.\n2.4.1\nProducts\nDefinition 2.4.1.1. Let X and Y be sets. The product of X and Y , denoted X ˆ Y , is\ndefined as the set of ordered pairs px, yq where x P X and y P Y . Symbolically,\nX ˆ Y \" tpx, yq | x P X, y P Y u.\nThere are two natural projection functions π1 : X ˆ Y N X and π2 : X ˆ Y N Y .\nX ˆ Y\nπ2\n\nπ1\n\nX\nY\nExample 2.4.1.2. [Grid of dots]\nLet X \" t1, 2, 3, 4, 5, 6u and Y \" t♣, ♦, ♥, ♠u. Then we can draw X ˆ Y as a 6-by-4\ngrid of dots, and the projections as projections\nX ˆ Y\np1,♣q\n‚\np2,♣q\n‚\np3,♣q\n‚\np4,♣q\n‚\np5,♣q\n‚\np6,♣q\n‚\np1,♦q\n‚\np2,♦q\n‚\np3,♦q\n‚\np4,♦q\n‚\np5,♦q\n‚\np6,♦q\n‚\np1,♥q\n‚\np2,♥q\n‚\np3,♥q\n‚\np4,♥q\n‚\np5,♥q\n‚\np6,♥q\n‚\np1,♠q\n‚\np2,♠q\n‚\np3,♠q\n‚\np4,♠q\n‚\np5,♠q\n‚\np6,♠q\n‚\nπ2\n/\nY\n♣‚\n♦‚\n♥‚\n♠‚\n(2.24)\nπ1\n\n1‚\n2‚\n3‚\n4‚\n5‚\n6‚\nX\nApplication 2.4.1.3. A traditional (Mendelian) way to predict the genotype of offspring\nbased on the genotype of its parents is by the use of Punnett squares. If F is the set of\npossible genotypes for the female parent and M is the set of possible genotypes of the\nmale parent, then F ˆ M is drawn as a square, called a Punnett square, in which every\ncombination is drawn.\n♦♦\nExercise 2.4.1.4. How many elements does the set ta, b, c, du ˆ t1, 2, 3u have?\n♦\n\nCHAPTER 2. THE CATEGORY OF SETS\nApplication 2.4.1.5. Suppose we are conducting experiments about the mechanical prop-\nerties of materials, as in Application 2.1.2.1. For each material sample we will produce\nmultiple data points in the set ⌜extension⌝ˆ ⌜force⌝- R ˆ R.\n♦♦\nRemark 2.4.1.6. It is possible to take the product of more than two sets as well. For\nexample, if A, B, and C are sets then A ˆ B ˆ C is the set of triples,\nA ˆ B ˆ C :\" tpa, b, cq | a P A, b P B, c P Cu.\nThis kind of generality is useful in understanding multiple dimensions, e.g. what\nphysicists mean by 10-dimensional space. It comes under the heading of limits, which\nwe will see in Section 4.5.3.\nExample 2.4.1.7. Let R be the set of real numbers. By R2 we mean R ˆ R (though see\nExercise 2.7.2.6). Similarly, for any n P N, we define Rn to be the product of n copies of\nR.\nAccording to [Pen], Aristotle seems to have conceived of space as something like\nS :\" R3 and of time as something like T :\" R.\nSpacetime, had he conceived of it,\nwould probably have been S ˆ T - R4. He of course did not have access to this kind of\nabstraction, which was probably due to Descartes.\nExercise 2.4.1.8. Let Z denote the set of integers, and let `: Z ˆ Z N Z denote the\naddition function and : Z ˆ Z N Z denote the multiplication function. Which of the\nfollowing diagrams commute?\na.)\nZ ˆ Z ˆ Z\npa,b,cqÞNpa b,a cq\n/\npa,b,cqÞNpa`b,cq\n\nZ ˆ Z\npx,yqÞNx`y\n\nZ ˆ Z\npx,yqÞNxy\n/ Z\nb.)\nZ\nxÞNpx,0q /\nidZ\n'\nZ ˆ Z\npa,bqÞNa b\n\nZ\nc.)\nZ\nxÞNpx,1q /\nidZ\n'\nZ ˆ Z\npa,bqÞNa b\n\nZ\n♦\n2.4.1.9\nUniversal property for products\nLemma 2.4.1.10 (Universal property for product). Let X and Y be sets. For any set\nA and functions f : A N X and g: A N Y , there exists a unique function A N X ˆ Y\n\n2.4. PRODUCTS AND COPRODUCTS\nsuch that the following diagram commutes 10\nX ˆ Y\nπ1\n\nπ2\n\nX\n✓\nY\n✓\nA\n@f\n\\\n@g\nB\nD!\nO\n(2.25)\nWe might write the unique function as\nxf, gy: A N X ˆ Y.\nProof. Suppose given f, g as above. To provide a function l: A N X ˆ Y is equivalent\nto providing an element lpaq P X ˆ Y for each a P A. We need such a function for which\nπ1 l\" f and π2 l\" g. An element of X ˆ Y is an ordered pair px, yq, and we can\nuse lpaq \" px, yq if and only if x \" π1px, yq \" fpaq and y \" π2px, yq \" gpaq. So it is\nnecessary and sufficient to define\nxf, gypaq :\" pfpaq, gpaqq\nfor all a P A.\n□\nExample 2.4.1.11 (Grid of dots, continued). We need to see the universal property of\nproducts as completely intuitive. Recall that if X and Y are sets, say of cardinalities\n|X| \" m and |Y | \" n respectively, then X ˆ Y is an m ˆ n grid of dots, and it comes\nwith two canonical projections X\nπ1\nÐY X ˆ Y\nπ2\nYN Y . These allow us to extract from\nevery grid element z P X ˆ Y its column π1pzq P X and its row π2pzq P Y .\nSuppose that each person in a classroom picks an element of X and an element of\nY . Thus we have functions f : C N X and g: C N Y . But isn't picking a column and a\nrow the same thing as picking an element in the grid? The two functions f and g induce\na unique function C N X ˆ Y . And how does this function C N X ˆ Y compare with\nthe original functions f and g? The commutative diagram (2.25) sums up the obvious\nconnection.\nExample 2.4.1.12. Let R be the set of real numbers. The origin in R is an element of R.\nAs you showed in Exercise 2.1.2.14, we can view this (or any) element of R as a function\nz : t,u N R, where t,u is any set with one element. Our function z \"picks out the\norigin\". Thus we can draw functions\nt,u\nz\n\nz\n\nR\nR\n10The symbol @ is read \"for all\"; the symbol D is read \"there exists\", and the symbol D! is read \"there\nexists a unique\". So this diagram is intended to express the idea that for any functions f : A N X and\ng : A N Y , there exists a unique function A N X ˆ Y for which the two triangles commute.\n\nCHAPTER 2. THE CATEGORY OF SETS\nThe universal property for products guarantees a function t,u N R ˆ R, which will be\nthe origin in R2.\nRemark 2.4.1.13. Given sets X, Y, and A, and functions f : A N X and g: A N Y , there\nis a unique function A N X ˆ Y that commutes with f and g. We call it the induced\nfunction A N X ˆ Y , meaning the one that arises in light of f and g.\nExercise 2.4.1.14. For every set A there is some nice relationship between the following\nthree sets:\nHomSetpA, Xq,\nHomSetpA, Y q,\nand\nHomSetpA, X ˆ Y q.\nWhat is it?\nHint: Do not be alarmed: this problem is a bit \"recursive\" in that you'll use products\nin your formula.\n♦\nExercise 2.4.1.15.\na.) Let X and Y be sets. Construct the \"swap map\" s: X ˆ Y N Y ˆ X using only\nthe universal property for products. If π1 : X ˆ Y N X and π2 : X ˆ Y N Y are the\nprojection functions, write s in terms of the symbols \"π1\", \"π2\", \"p , q\", and \" \".\nb.) Can you prove that s is a isomorphism using only the universal property for product?\n♦\nExample 2.4.1.16. Suppose given sets X, X1, Y, Y 1 and functions m: X N X1 and n: Y N\nY 1. We can use the universal property of products to construct a function s: X ˆ Y N\nX1 ˆ Y 1. Here's how.\nThe universal property (Lemma 2.4.1.10) says that to get a function from any set A\nto X1 ˆ Y 1, we need two functions, namely some f : A N X1 and some g: A N Y 1. Here\nA \" X ˆ Y .\nWhat we have readily available are the two projections π1 : X ˆY N X and π2 : X ˆ\nY N Y . But we also have m: X N X1 and n: Y N Y 1. Composing, we set f :\" m π1\nand g :\" n π2.\nX1 ˆ Y 1\nπ1\nz\nπ1\n#\nX1\nY 1\nX\nm\nO\nY\nn\nO\nX ˆ Y\nπ1\nd\nπ2\n:\nO\nThe dotted arrow is often called the product of m: X N X1 and n: Y N Y 1 and is\ndenoted simply by\nm ˆ n: X ˆ Y N X1 ˆ Y 1.\n2.4.1.17\nOlogging products\nGiven two objects c, d in an olog, there is a canonical label \"cˆd\" for their product cˆd,\nwritten in terms of the labels \"c\" and \"d\". Namely,\n\"c ˆ d\" :\" a pair px, yq where x is \"c\" and y is \"d\".\n\n2.4. PRODUCTS AND COPRODUCTS\nThe projections c Ð c ˆ d N d can be labeled \"yields, as x,\" and \"yields, as y,\" respec-\ntively.\nSuppose that e is another object and p: e N c and q: e N d are two arrows. By\nthe universal property of products (Lemma 2.4.1.10), p and q induce a unique arrow\ne N c ˆ d making the evident diagrams commute. This arrow can be labeled\nyields, insofar as it \"p\" \"c\" and \"q\" \"d\",\nExample 2.4.1.18. Every car owner owns at least one car, but there is no obvious function\n⌜a car owner⌝N ⌜a car⌝because he or she may own more than one. One good choice\nwould be the car that the person drives most often, which we'll call his or her primary\ncar. Also, given a person and a car, an economist could ask how much utility the person\nwould get out of the car. From all this we can put together the following olog involving\nproducts:\nO\na car owner\nis\n\nowns,\nas\nprimary,\n#\nyields, insofar\nas it is a person\nand owns, as\nprimary, a car, /\n✓\nP ˆC\na\npair\npx, yq\nwhere\nx\nis\na\nperson and y is\na car\nyields, as x,\nv\nyields, as y,\n\nhas as associ-\nated utility\n/\nV\na dollar value\nP\na person\nC\na car\n2.4.2\nCoproducts\nDefinition 2.4.2.1. Let X and Y be sets. The coproduct of X and Y , denoted X \\ Y ,\nis defined as the \"disjoint union\" of X and Y , i.e. the set for which an element is either\nan element of X or an element of Y . If something is an element of both X and Y then\nwe include both copies, and distinguish between them, in X \\ Y . See Example 2.4.2.2\nThere are two natural inclusion functions i1 : X N X \\ Y and i2 : Y N X \\ Y .\nX\ni1\n\nY\ni2\n\nX \\ Y\nExample 2.4.2.2. The coproduct of X :\" ta, b, c, du and Y :\" t1, 2, 3u is\nX \\ Y - ta, b, c, d, 1, 2, 3u.\nThe coproduct of X and itself is\nX \\ X - ti1a, i1b, i1c, i1d, i2a, i2b, i2c, i2du\nThe names of the elements in X \\ Y are not so important. What's important are the\ninclusion maps i1, i2, which ensure that we know where each element of X \\ Y came\nfrom.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExample 2.4.2.3 (Airplane seats).\nX\nan economy-\nclass seat in\nan airplane\nis\n\nY\na first-class\nseat in an\nairplane\nis\n\nX\\Y\na seat in an\nairplane\n(2.26)\nExercise 2.4.2.4. Would you say that ⌜a phone⌝is the coproduct of ⌜a cellphone⌝and\n⌜a landline phone⌝?\n♦\nExample 2.4.2.5 (Disjoint union of dots).\nX \\ Y\n♣‚\n1‚\n2‚\n3‚\n4‚\n5‚\n6‚\n♦‚\n♥‚\n♠‚\ni2\no\nY\n♣‚\n♦‚\n♥‚\n♠‚\n(2.27)\ni1\nO\n1‚\n2‚\n3‚\n4‚\n5‚\n6‚\nX\n2.4.2.6\nUniversal property for coproducts\nLemma 2.4.2.7 (Universal property for coproduct). Let X and Y be sets. For any set\nA and functions f : X N A and g: Y N A, there exists a unique function X \\ Y N A\n\n2.4. PRODUCTS AND COPRODUCTS\nsuch that the following diagram commutes\nA\nX\n@f\nB\ni1\n\nY\n@g\n\\\ni2\n\nX \\ Y\nD!\nO\nWe might write the unique function as 11\n\"\nf\ng : X \\ Y N A.\nProof. Suppose given f, g as above. To provide a function l: X \\ Y N A is equivalent\nto providing an element fpmq P A is for each m P X \\ Y . We need such a function such\nthat l i1 \" f and l i2 \" g. But each element m P X \\ Y is either of the form i1x or\ni2y, and cannot be of both forms. So we assign\n\"\nf\ng pmq \"\n#\nfpxq\nif m \" i1x,\ngpyq\nif m \" i2y.\nThis assignment is necessary and sufficient to make all relevant diagrams commute.\n□\nExample 2.4.2.8 (Airplane seats, continued). The universal property of coproducts says\nthe following. Any time we have a function X N A and a function Y N A, we get a\nunique function X \\ Y N A. For example, every economy class seat in an airplane and\nevery first class seat in an airplane is actually in a particular airplane. Every economy\nclass seat has a price, as does every first class seat.\nA\na dollar figure\nX\nan economy-\nclass seat in\nan airplane\nhas as price\nis\n/\nis in\n%\nX\\Y\na seat in an\nairplane\nD!\n\nD!\nO\n✓\n✓\n✓\n✓\nY\na first-class\nseat in an\nairplane\nis\no\nhas as price\ne\nis in\ny\nB\nan airplane\n(2.28)\nThe universal property of coproducts formalizes the following intuitively obvious fact:\n11We are about to use a two-line symbol, which is a bit unusual. In what follows a certain function\nX \\ Y N A is being denoted by the symbol\n\"\nf\ng .\n\nCHAPTER 2. THE CATEGORY OF SETS\nIf we know how economy class seats are priced and we know how first class\nseats are priced, and if we know that every seat is either economy class or\nfirst class, then we automatically know how all seats are priced.\nTo say it another way (and using the other induced map):\nIf we keep track of which airplane every economy class seat is in and we\nkeep track of which airplane every first class seat is in, and if we know that\nevery seat is either economy class or first class, then we require no additional\ntracking for any airplane seat whatsoever.\nApplication 2.4.2.9 (Piecewise defined curves). In science, curves are often defined or\nconsidered piecewise. For example in testing the mechanical properties of a material,\nwe might be interested in various regions of deformation, such as elastic, plastic, or\npost-fracture. These are three intervals on which the material displays different kinds of\nproperties.\nFor real numbers a a b P R, let ra, bs :\" tx P R | a d x d bu denote the closed\ninterval. Given a function ra, bs N R and a function rc, ds N R, the universal property\nof coproducts implies that they extend uniquely to a function ra, bs \\ rc, ds N R, which\nwill appear as a piecewise defined curve.\nOften we are given a curve on ra, bs and another on rb, cs, where the two curves agree\nat the point b. This situation is described by pushouts, which are mild generalizations\nof coproducts; see Section 2.6.2.\n♦♦\nExercise 2.4.2.10. Write the universal property for coproduct in terms of a relationship\nbetween the following three sets:\nHomSetpX, Aq,\nHomSetpY, Aq,\nand\nHomSetpX \\ Y, Aq.\n♦\nExample 2.4.2.11. In the following olog the types A and B are disjoint, so the coproduct\nC \" A \\ B is just the union.\nA\na person\nis\n/\nC\"A\\B\na person or a cat\nB\na cat\nis\no\nExample 2.4.2.12. In the following olog, A and B are not disjoint, so care must be taken\nto differentiate common elements.\nA\nan animal\nthat can fly\nlabeled \"A\" is /\nC\"A\\B\nan animal that can fly\n(labeled \"A\") or an\nanimal that can swim\n(labeled \"B\")\nB\nan animal that\ncan swim\nlabeled \"B\" is\no\nSince ducks can both swim and fly, each duck is found twice in C, once labeled as a\nflyer and once labeled as a swimmer. The types A and B are kept disjoint in C, which\njustifies the name \"disjoint union.\"\n\n2.5. FINITE LIMITS IN SET\nExercise 2.4.2.13. Understand Example 2.4.2.12 and see if a similar idea would make\nsense for particles and waves. Make an olog, and choose your wording in accordance with\nRules 2.3.1.2. How do photons, which exhibit properties of both waves and particles, fit\ninto the coproduct in your olog?\n♦\nExercise 2.4.2.14. Following the section above, \"Ologging products\" page 36, come up\nwith a naming system for coproducts, the inclusions, and the universal maps. Try it out\nby making an olog (involving coproducts) discussing the idea that both a .wav file and\na .mp3 file can be played on a modern computer. Be careful that your arrows are valid\nin the sense of Section 2.3.2.1.\n♦\n2.5\nFinite limits in Set\nIn this section we discuss what are called limits of variously-shaped diagrams of sets.\nWe will make all this much more precise when we discuss limits in arbitrary categories\nin Section 4.5.3.\n2.5.1\nPullbacks\nDefinition 2.5.1.1 (Pullback). Suppose given the diagram of sets and functions below.\nY\ng\n\nX\nf\n/ Z\n(2.29)\nIts fiber product is the set\nX ˆZ Y :\" tpx, w, yq | fpxq \" w \" gpyqu.\nThere are obvious projections π1 : X ˆZ Y N X and π2 : X ˆZ Y N Y (e.g. π2px, w, yq \"\ny). Note that if W \" X ˆZ Y then the diagram\nW\n⌟\nπ2\n/\nπ1\n\nY\ng\n\nX\nf\n/ Z\n(2.30)\ncommutes. Given the setup of Diagram 2.29 we define the pullback of X and Y over Z\nto be any set W for which we have an isomorphism W\n-\nYN X ˆZ Y . The corner symbol\n⌟in Diagram 2.30 indicates that W is the pullback.\nExercise 2.5.1.2. Let X, Y, Z be as drawn and f : X N Z and g: Y N Z the indicated\nfunctions.\n\nCHAPTER 2. THE CATEGORY OF SETS\nWhat is the pullback of the diagram X\nf\nYYYN Z\ng\nÐYYY Y ?\n♦\nExercise 2.5.1.3.\na.) Draw a set X with five elements and a set Y with three elements.\nColor each\nelement of X and each element of Y either red, blue, or yellow, 12 and do so in a\n\"random-looking\" way. Considering your coloring of X as a function X N C, where\nC \" tred, blue, yellowu, and similarly obtaining a function Y N C, draw the fiber\nproduct X ˆC Y . Make sure it is colored appropriately.\nb.) The universal property for products guarantees a function X ˆC Y N X ˆ Y , which\nI can tell you will be an injection. This means that the drawing you made of the\nfiber product can be imbedded into the 5 ˆ 3 grid; please draw the grid and indicate\nthis subset.\n♦\nRemark 2.5.1.4. Some may prefer to denote this fiber product by f ˆZ g rather than\nX ˆZ Y . The former is mathematically better notation, but human-readability is often\nenhanced by the latter, which is also more common in the literature. We use whichever\nis more convenient.\nExercise 2.5.1.5.\na.) Suppose that Y \" H; what can you say about X ˆZ Y ?\nb.) Suppose now that Y is any set but that Z has exactly one element; what can you\nsay about X ˆZ Y ?\n♦\nExercise 2.5.1.6. Let S \" R3, T \" R, and think of them as (Aristotelian) space and time,\nwith the origin in S ˆ T given by the center of mass of MIT at the time of its founding.\nLet Y \" S ˆT and let g1 : Y N S be one projection and g2 : Y N T the other projection.\nLet X \" t,u be a set with one element and let f1 : X N S and f2 : X N T be given by\nthe origin in both cases.\na.) What are the fiber products W1 and W2:\nW1\n/\n\n⌟\nY\ng1\n\nX\nf1\n/ S\nW2\n/\n\n⌟\nY\ng2\n\nX\nf2\n/ T\n12You can use shadings rather than coloring, if coloring would be annoying.\n\n2.5. FINITE LIMITS IN SET\nb.) Interpret these sets in terms of the center of mass of MIT at the time of its founding.\n♦\n2.5.1.7\nUsing pullbacks to define new ideas from old\nIn this section we will see that the fiber product of a diagram can serve to define a new\nconcept. For example, in (2.33) we define what it means for a cellphone to have a bad\nbattery, in terms of the length of time for which it remains charged. By being explicit,\nwe reduce the chance of misunderstandings between different groups of people. This can\nbe useful in situations like audits and those in which one is trying to reuse or understand\ndata gathered by others.\nExample 2.5.1.8. Consider the following two ologs. The one on the right is the pullback\nof the one on the left.\nC\na loyal\ncustomer\nis\n\nB\na wealthy\ncustomer\nis\n/\nD\na customer\nA\"BˆDC\na customer\nthat is wealthy\nand loyal\nis\n\nis\n/\nC\na loyal\ncustomer\nis\n\nB\na wealthy\ncustomer\nis\n/\nD\na customer\n(2.31)\nCheck from Definition 2.5.1.1 that the label, \"a customer that is wealthy and loyal\", is\nfair and straightforward as a label for the fiber product A \" B ˆD C, given the labels\non B, C, and D.\nRemark 2.5.1.9. Note that in Diagram (2.31) the top-left box could have been (non-\ncanonically named) ⌜a good customer⌝. If it was taken to be the fiber product, then the\nauthor would be effectively defining a good customer to be one that is wealthy and loyal.\nExercise 2.5.1.10. For each of the following, an author has proposed that the diagram\non the right is a pullback. Do you think their labels are appropriate or misleading; that\nis, is the label on the upper-left box reasonable given the rest of the olog, or is it suspect\nin some way?\na.)\nC\nblue\nis\n\nB\na person\nhas as favorite\ncolor\n/\nD\na color\nA\"BˆDC\na person whose\nfavorite color is blue\nis\n\nhas as favorite\ncolor\n/\nC\nblue\nis\n\nB\na person\nhas as favorite\ncolor\n/\nD\na color\n\nCHAPTER 2. THE CATEGORY OF SETS\nb.)\nC\na woman\nis\n\nB\na dog\nhas as owner\n/\nD\na person\nA\"BˆDC\na dog whose owner\nis a woman\nis\n\nhas as owner\n/\nC\na woman\nis\n\nB\na dog\nhas as owner\n/\nD\na person\nc.)\nC\na piece of\nfurniture\nhas\n\nB\na space in\nour house\nhas\n/\nD\na width\nA\"BˆDC\na good fit\ns\n\nf\n/\nC\na piece of\nfurniture\nhas\n\nB\na space in\nour house\nhas\n/\nD\na width\n♦\nExercise 2.5.1.11.\na.) Consider your olog from Exercise 2.3.3.1. Are any of the commutative squares there\nactually pullback squares?\nb.) Now use ologs with products and pullbacks to define what a brother is and what a\nsister is (again in a human biological nuclear family), in terms of types such as ⌜an\noffspring of mating pair pa, bq⌝, ⌜a person⌝, ⌜a male person⌝, ⌜a female person⌝, and\nso on.\n♦\nDefinition 2.5.1.12 (Preimage). Let f : X N Y be a function and y P Y an element.\nThe preimage of y under f, denoted f 1pyq, is the subset f 1pyq :\" tx P X | fpxq \" yu.\nIf Y 1 D Y is any subset, the preimage of Y 1 under f, denoted f 1pY 1q, is the subset\nf 1pY 1q \" tx P X | fpxq P Y 1u.\nExercise 2.5.1.13. Let f : X N Y be a function and y P Y an element. Draw a pullback\ndiagram in which the fiber product is isomorphic to the preimage f 1pyq.\n♦\nLemma 2.5.1.14 (Universal property for pullback). Suppose given the diagram of sets\nand functions as below.\nY\nu\n\nX\nt\n/ Z\n\n2.5. FINITE LIMITS IN SET\nFor any set A and commutative solid arrow diagram as below (i.e. functions f : A N X\nand g: A N Y such that t f \" u g),\nX ˆZ Y\nπ1\n\nπ2\n\nA\nD!\nO\n@f\nz\n@g\n$\nX\nt\n$\nY\nu\nz\nZ\n(2.32)\nthere exists a unique arrow xf, fyZ : A N X ˆZ Y making everything commute, i.e.\nf \" π1 xf, fyZ\nand\ng \" π2 xf, fyZ.\nExercise 2.5.1.15. Create an olog whose underlying shape is a commutative square. Now\nadd the fiber product so that the shape is the same as that of Diagram (2.32). Assign\nEnglish labels to the projections π1, π2 and to the dotted map A\nxf,fyZ\nYYYYN X ˆZ Y , such\nthat these labels are as canonical as possible.\n♦\n2.5.1.16\nPasting diagrams for pullback\nConsider the diagram drawn below, which includes a left-hand square, a right-hand\nsquare, and a big rectangle.\nA1\nf 1\n/\ni\n\n⌟\nB1\ng1\n/\nj\n\n⌟\nC1\nk\n\nA\nf\n/ B\ng\n/ C\nThe right-hand square has a corner symbol indicating that B1 - B ˆC C1 is a pullback.\nBut the corner symbol on the left is ambiguous; it might be indicating that the left-hand\nsquare is a pullback, or it might be indicating that the big rectangle is a pullback. It\nturns out that if B1 - B ˆC C1 then it is not ambiguous because the left-hand square is\na pullback if and only if the big rectangle is.\nProposition 2.5.1.17. Consider the diagram drawn below\nB1\ng1\n/\nj\n\n⌟\nC1\nk\n\nA\nf\n/ B\ng\n/ C\nwhere B1 - B ˆC C1 is a pullback. Then there is an isomorphism A ˆB B1 - A ˆC C1.\nSaid another way,\nA ˆB pB ˆC C1q - A ˆC C1.\n\nCHAPTER 2. THE CATEGORY OF SETS\nProof. We first provide a map φ: A ˆB pB ˆC C1q N A ˆC C1. An element of A ˆB\npB ˆC C1q is of the form pa, b, pb, c, c1qq such that fpaq \" b, gpbq \" c and kpc1q \" c. But\nthis implies that g fpaq \" c \" kpc1q so we put φpa, b, pb, c, c1qq :\" pa, c, c1q P A ˆC C1.\nNow we provide a proposed inverse, ψ: AˆC C1 N AˆB pB ˆC C1q. Given pa, c, c1q with\ng fpaq \" c \" kpc1q, let b \" fpaq and note that pb, c, c1q is an element of B ˆC C1. So we\ncan define ψpa, c, c1q \" pa, b, pb, c, c1qq. It is easy to see that φ and ψ are inverse.\n□\nProposition 2.5.1.17 can be useful in authoring ologs.\nFor example, the type ⌜a\ncellphone that has a bad battery⌝is vague, but we can lay out precisely what it means\nusing pullbacks:\nA-BˆDC\na cellphone that\nhas a bad battery\n/\n\nC-DˆF E\na bad battery\n/\n\nE-F ˆHG\nless than\n1 hour\n/\n\nG\nbetween\n0 and 1\n\nB\na cellphone\nhas\n/\nD\na battery\nremains\ncharged\nfor\n/\nF\na duration\nof time\nin hours\nyields /\nH\na range of\nnumbers\n(2.33)\nThe category-theoretic fact described above says that since A - B ˆD C and C -\nD ˆF E, it follows that A - B ˆF E. That is, we can deduce the definition \"a cellphone\nthat has a bad battery is defined as a cellphone that has a battery which remains charged\nfor less than one hour.\"\nExercise 2.5.1.18.\na.) Create an olog that defines two people to be \"of approximately the same height\" if\nand only if their height difference is less than half an inch, using a pullback. Your\nolog can include the box ⌜a real number x such that .5 a x a .5⌝.\nb.) In the same olog, make a box for those people whose height is approximately the\nsame as a person named \"The Virgin Mary\". You may need to use images, as in\nSection 2.3.3.8.\n♦\nExercise 2.5.1.19. Consider the diagram on the left below, where both squares commute.\nY 1\n\nY\n>\n\nX1\n/ Z1\nX\n/\n=\nZ\n>\nW 1\n/\n\n⌟\nY 1\n\nW\n/\n\n⌟\nY\n>\n\nX1\n/ Z1\nX\n/\n=\nZ\n>\nLet W \" X ˆZ Y and W 1 \" X1 ˆZ1 Y 1, and form the diagram to the right. Use the\nuniversal property of fiber products to construct a map W N W 1 such that all squares\ncommute.\n♦\n\n2.5. FINITE LIMITS IN SET\n2.5.2\nSpans, experiments, and matrices\nDefinition 2.5.2.1. Given sets A and B, a span on A and B is a set R together with\nfunctions f : R N A and g: R N B.\nR\nf\n\ng\n\nA\nB\nApplication 2.5.2.2. Think of A and B as observables and R as a set of experiments\nperformed on these two variables. For example, let's say T is the set of possible tem-\nperatures of a gas in a fixed container and let's say P is the set of possible pressures of\nthe gas. We perform 1000 experiments in which we change and record the temperature\nand we simultaneously also record the pressure; this is a span T\nfÐY E\ngYN P. The results\nmight look like this:\nExperiment\nID\nTemperature\nPressure\n...\n...\n...\n♦♦\nDefinition 2.5.2.3. Let A, B, and C be sets, and let A\nfÐY R\ngYN B and B\nf 1\nÐY R1\ng1\nYN C\nbe spans. Their composite span is given by the fiber product R ˆB R1 as in the diagram\nbelow:\nR ˆB R1\n\nR\nf\n\ng\n\nR1\nf 1\n\ng1\n\nA\nB\nC\nApplication 2.5.2.4. Let's look back at our lab's experiment from Application 2.5.2.2,\nwhich resulted in a span T\nfÐY E\ngYN P. Suppose we notice that something looks a little\nwrong. The pressure should be linear in the temperature but it doesn't appear to be.\nWe hypothesize that the volume of the container is increasing under pressure. We look\nup this container online and see that experiments have been done to measure the volume\nas the interior pressure changes. The data has generously been made available online,\nwhich gives us a span P\nf 1\nÐY E1\ng1\nYN V .\nThe composite of our lab's span with the online data span yields a span T Ð E2 N V ,\nwhere E2 :\" E ˆP E1. What information does this span give us? In explaining it, one\n\nCHAPTER 2. THE CATEGORY OF SETS\nmight say \"whenever an experiment in our lab yielded the same pressure as one they\nrecorded, let's call that a data point. Every data point has an associated temperature\n(from our lab) and an associated volume (from their experiment). This is the best we\ncan do.\"\nThe information we get this way might be seen by some as unscientific, but it certainly\nis the kind of information people use in business and in every day life calculation--we get\nour data from multiple sources and put it together. Moreover, it is scientific in the sense\nthat it is reproducible. The way we obtained our T-V data is completely transparent.\n♦♦\nWe can relate spans to matrices of natural numbers, and see a natural \"categorifica-\ntion\" of matrix addition and matrix multiplication. If our spans come from experiments\nas in Applications 2.5.2.2 and 2.5.2.4 the matrices involved will look like huge but sparse\nmatrices. Let's go through that.\nLet A and B be sets and let A Ð R N B be a span. By the universal property of\nproducts, we have a unique map R\npYN A ˆ B.\nWe make a matrix of natural numbers out of this data as follows. The set of rows\nis A, the set of columns is B. For elements a P A and b P B, the pa, bq-entry is the\ncardinality of its preimage, |p 1pa, bq|, i.e. the number of elements in R that are sent by\np to pa, bq.\nSuppose we are given two pA, Bq-spans, i.e. A Ð R N B and A Ð R1 N B; we might\nthink of these has having the same dimensions, i.e. they are both |A| ˆ |B|-matrices.\nWe can take the disjoint union R \\ R1 and by the universal property of coproducts we\nhave a unique span A Ð R \\ R1 N B making the requisite diagram commute. 13 The\nmatrix corresponding to this new span will be the sum of the matrices corresponding to\nthe two previous spans out of which it was made.\nGiven a span A Ð R N B and a span B Ð S N C, the composite span can be formed\nas in Definition 2.5.2.3. It will correspond to the usual multiplication of matrices.\nConstruction 2.5.2.5. Given a span A\nfÐY R\ngYN B, one can draw a bipartite graph with\neach element of A drawn as a dot on the left, each element of B drawn as a dot on the\nright, and each element r P R drawn as an arrow connecting vertex fprq on the left to\nvertex gprq on the right.\nExercise 2.5.2.6.\na.) Draw the bipartite graph (as in Construction 2.5.2.5) corresponding to the span\nT\nfÐY E\ngYN P in Application 2.5.2.2.\nb.) Now make up your own span P\nf 1\nÐY E1\ng1\nYN V and draw it. Finally, draw the composite\nspan below.\nc.) Can you say how the composite span graph relates to the graphs of its factors?\nR\n{\n#\n\nA\nR \\ R1\no\n/ B\nR1\n<\nb\nO\n\n2.6. FINITE COLIMITS IN SET\n♦\n2.5.3\nEqualizers and terminal objects\nDefinition 2.5.3.1. Suppose given two parallel arrows\nX\nf\n/\ng\n/ Y.\nEqpf, gq\np\n/ X\nf\n/\ng\n/ Y\n(2.34)\nThe equalizer of f and g is the commutative diagram as to the right in (2.34), where we\ndefine\nEqpf, gq :\" tx P X | fpxq \" gpxqu\nand where p is the canonical inclusion.\nExample 2.5.3.2. Suppose one has designed an experiment to test a theoretical prediction.\nThe question becomes, \"when does the theory match the experiment?\" The answer is\ngiven by the equalizer of the following diagram:\nan input\nshould, according to theory, yield /\naccording to experiment yields / an output\nThe equalizer is the set of all inputs for which the theory and the experiment yield the\nsame output.\nExercise 2.5.3.3. Come up with an olog that uses equalizers in a reasonably interest-\ning way. Alternatively, use an equalizer to specify those published authors who have\npublished exactly one paper. Hint: find a function from authors to papers; then find\nanother.\n♦\nExercise 2.5.3.4. Find a universal property enjoyed by the equalizer of two arrows, and\npresent it in the style of Lemmas 2.4.1.10, 2.4.2.7, and 2.5.1.14.\n♦\nExercise 2.5.3.5.\na.) A terminal set is a set S such that for every set X, there exists a unique function\nX N S. Find a terminal set.\nb.) Do you think that the notion terminal set belongs in this section (Section 2.5)? How\nso?\nIf products, pullbacks, and equalizers are all limits, what do limits have in\ncommon?\n♦\n2.6\nFinite colimits in Set\nThis section will parallel Section 2.5--I will introduce several types of finite colimits and\nhope that this gives the reader some intuition about them, without formally defining\nthem yet. Before doing so, I must define equivalence relations and quotients.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.6.1\nBackground: equivalence relations\nDefinition 2.6.1.1 (Equivalence relations and equivalence classes). Let X be a set. An\nequivalence relation on X is a subset R D X ˆ X satisfying the following properties for\nall x, y, z P X:\nReflexivity: px, xq P R;\nSymmetry: px, yq P R if and only if py, xq P R; and\nTransitivity: if px, yq P R and py, zq P R then px, zq P R.\nIf R is an equivalence relation, we often write x „R y, or simply x „ y, to mean px, yq P R.\nFor convenience we may refer to the equivalence relation by the symbol „, saying that\n„ is an equivalence relation on X.\nAn equivalence class of „ is a subset A D X such that\n- A is nonempty, A % H;\n- if x P A and x1 P A, then x „ x1; and\n- if x P A and x „ y, then y P A.\nSuppose that „ is an equivalence relation on X. The quotient of X by „, denoted X{ „\nis the set of equivalence classes of „.\nExample 2.6.1.2. Let Z denote the set of integers. Define a relation R D Z ˆ Z by\nR \" tpx, yq | Dn P Z such that x ` 7n \" yu.\nThen R is an equivalence relation because x ` 7 0 \" x (reflexivity); x ` 7 n \" y if and\nonly if y ` 7 p nq \" x (symmetry); and x ` 7n \" y and y ` 7m \" z together imply\nthat x ` 7pm ` nq \" z (transitivity).\nExercise 2.6.1.3. Let X be the set of people on earth; define a binary relation R D X ˆX\non X as follows. For a pair px, yq of people, say px, yq P R if x spends a lot of time thinking\nabout y.\na.) Is this relation reflexive?\nb.) Is it symmetric?\nc.) Is it transitive?\n♦\nExample 2.6.1.4 (Partitions). An equivalence relation on a set X can be thought of as a\nway of partitioning X. A partition of X consists of a set I, called the set of parts, and\nfor every element i P I a subset Xi D X such that two properties hold:\n- every element x P X is in some part (i.e. for all x P X there exists i P I such that\nx P Xi); and\n- no element can be found in two different parts (i.e. if x P Xi and x P Xj then\ni \" j).\n\n2.6. FINITE COLIMITS IN SET\nGiven a partition of X, we define an equivalence relation „ on X by saying x „ x1\nif x and x1 are in the same part (i.e. if there exists i P I such that x, x1 P Xi). The\nparts become the equivalence classes of this relation. Conversely, given an equivalence\nrelation, one makes a partition on X by taking I to be the set of equivalence classes and\nfor each i P I letting Xi be the elements in that equivalence class.\nExercise 2.6.1.5. Let X and B be sets and let f : X N B be a function. Define a subset\nR D X ˆ X by\nR \" tpx, yq | fpxq \" fpyqu.\na.) Is R an equivalence relation?\nb.) Are all equivalence relations on X obtainable in this way (as the fibers of some\nfunction having domain X)?\nc.) Does this viewpoint on equivalence classes relate to that of Example 2.6.1.4?\n♦\nExercise 2.6.1.6. Take a set I of sets; i.e. suppose that for each element i P I you are\ngiven a set Xi. For every two elements i, j P I say that i „ j if Xi and Xj are isomorphic.\nIs this relation an equivalence relation on I?\n♦\nLemma 2.6.1.7 (Generating equivalence relations). Let X be a set and R D X ˆ X a\nsubset. There exists a relation S D X ˆ X such that\n- S is an equivalence relation,\n- R D S, and\n- for any equivalence relation S1 such that R D S1, we have S D S1.\nThe relation S1 will be called the equivalence relation generated by R.\nProof. Let LR be the set of all equivalence relations on X that contain R; in other words,\neach element lP LR is an equivalence relation, lP X ˆ X. The set LR is non-empty\nbecause X ˆ X D X ˆ X is an equivalence relation.\nLet S denote the set of pairs\npx1, x2q P X ˆ X that appear in every element of LR. Note that R D S by definition.\nWe need only show that S is an equivalence relation.\nIt is clearly reflexive, because R is. If px, yq P S then px, yq P lfor all lP LR. But\nsince each lis an equivalence relation, py, xq P ltoo, so py, xq P S. This shows that S\nis symmetric. The proof that it is transitive is similar: if px, yq P S and py, zq P S then\nthey are both in each lwhich puts px, zq in each l, which puts it in S.\n□\nRemark 2.6.1.8. Let X be a set and R D X ˆ X a relation. The proof of Lemma 2.6.1.7\nhas the benefit of working even if |X| e 8, but it has the cost that it is not very intuitive,\nnor useful in practice when X is finite. The intuitive way to think about the idea of\nequivalence relation generated by R is as follows.\n1. First add to R what is demanded by reflexivity, R1 :\" R Y tpx, xq | x P Xu.\n2. Then add to R what is demanded by symmetry, R2 :\" R1 Y tpx, yq | py, xq P R1u.\n3. Finally, add to R what is demanded by transitivity,\nS \" R2 Y tpx, zq | px, yq P R2, and py, zq P R2u.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExercise 2.6.1.9. Consider the set R of real numbers. Draw the coordinate plane R ˆ R,\ngive it coordinates x and y. A binary relation on R is a subset S D R ˆ R, which can be\ndrawn as a set of points in the plane.\na.) Draw the relation tpx, yq | y \" x2u.\nb.) Draw the relation tpx, yq | y e x2u.\nc.) Let S0 be the equivalence relation on R generated (in the sense of Lemma 2.6.1.7)\nby the empty set. Draw S as a subset of the plane.\nd.) Consider the equivalence relation S1 generated by tp1, 2q, p1, 3qu. Draw S1 in the\nplane. Highlight the equivalence class containing p1, 2q.\ne.) The reflexivity property and the symmetry property have pleasing visualizations in\nR ˆ R; what are they?\nf.) Is there a nice heuristic for visualizing the transitivity property?\n♦\nExercise 2.6.1.10. Consider the binary relation R \" tpn, n ` 1q | n P Zu D Z ˆ Z.\na.) What is the equivalence relation generated by R?\nb.) How many equivalence classes are there?\n♦\nExercise 2.6.1.11. Suppose N is a network (or graph). Let X be the nodes of the network,\nand let R D X ˆ X denote the relation such that px, yq P R iffthere exists an arrow\nconnecting x to y. 14\na.) What is the equivalence relation „ generated by R?\nb.) What is the quotient X{ „?\n♦\n2.6.2\nPushouts\nDefinition 2.6.2.1 (Pushout). Suppose given the diagram of sets and functions below:\nW\nf\n/\ng\n\nX\nY\n(2.35)\nIts fiber sum, denoted X\\W Y , is defined as the quotient of X\\W \\Y by the equivalence\nrelation „ generated by w „ fpwq and w „ gpwq for all w P W.\nX \\W Y :\" pX \\ W \\ Y q{ „\nwhere @w P W, w „ fpwq\nand\nw „ gpwq.\n14The word iffmeans \"if and only if\". In this case we are saying that the pair px, yq is in R if and\nonly if there exists an arrow connecting x and y.\n\n2.6. FINITE COLIMITS IN SET\nThere are obvious inclusions i1 : X N X \\W Y and i2 : Y N X \\W Y . 15 Note that if\nZ \" X \\W Y then the diagram\nW\ng\n/\nf\n\nY\ni2\n\nX\ni1\n/ Z\n⌜\n(2.36)\ncommutes. Given the setup of Diagram 2.35 we define the pushout of X and Y over W\nto be any set Z for which we have an isomorphism Z\n-\nYN X \\W Y . The corner symbol\n⌜in Diagram 2.36 indicates that Z is the pushout.\nExample 2.6.2.2. Let X \" tx P R | 0 d x d 1u be the set of numbers between 0 and 1,\ninclusive, let Y \" ty P R | 1 d y d 2u by the set of numbers between 1 and 2, inclusive,\nand let W \" t1u. Then the pushout X\nfÐY W\ngYN Y , where f and g are the \"obvious\"\nfunctions (1 ÞN 1) is X \\W Y - tz P R | 0 d z d 2u, as expected. When we eventually\nget to general colimits, one can check that the whole real line can be made by patching\ntogether intervals in this way.\nExample 2.6.2.3 (Pushout). In each example below, the diagram to the right is intended\nto be a pushout of the diagram to the left. The new object, D, is the union of B and\nC, but instances of A are equated to their B and C aspects. This will be discussed after\nthe two diagrams.\nA\na cell in the\nshoulder\nis\n/\nis\n\nC\na cell in\nthe arm\nB\na cell in the\ntorso\nA\na cell in the\nshoulder\nis\n/\nis\n\nC\na cell in\nthe arm\n\nB\na cell in the\ntorso\n/\nD\"B\\AC\na cell in the\ntorso or arm\n(2.37)\nIn the left-hand olog (2.37, the two arrows are inclusions: the author considers every cell\nin the shoulder to be both in the arm and in the torso. The pushout is then just the\nunion, where cells in the shoulder are not double-counted.\n15Note that our term inclusions is not too good, because it seems to suggest that i1 and i2 are injective\n(see Definition 2.7.5.1) and this is not always the case.\n\nCHAPTER 2. THE CATEGORY OF SETS\nA\na college\nmathematics\ncourse\nyields/\nis\nC\nan utterance\nof the phrase\n\"too hard\"\nB\na college\ncourse\nA\na college\nmathematics\ncourse\nyields /\nis\n\nC\nan utterance\nof the phrase\n\"too hard\"\n\nB\na college\ncourse\n/\nD \" B\\A C\na college course,\nwhere every\nmathematics\ncourse is\nreplaced by an\nutterance of the\nphrase \"too\nhard\"\n(2.38)\nIn Olog (2.37), the shoulder is seen as part of the arm and part of the torso. When\ntaking the union of these two parts, we do not want to \"double-count\" the shoulder (as\nwould be done in the coproduct B \\ C, see Example 2.4.2.12). Thus we create a new\ntype A for cells in the shoulder, which are considered the same whether viewed as cells in\nthe arm or cells in the torso. In general, if one wishes to take two things and glue them\ntogether, with A as the glue and with B and C as the two things to be glued, the union\nis the pushout B \\A C. (A nice image of this can be seen in the setting of topological\nspaces, see Example 4.5.3.30.)\nIn Olog (2.38), if every mathematics course is simply \"too hard,\" then when reading\noffa list of courses, each math course will not be read aloud but simply read as \"too\nhard.\" To form D we begin by taking the union of B and C, and then we consider\neverything in A to be the same whether one looks at it as a course or as the phrase \"too\nhard.\" The math courses are all blurred together as one thing. Thus we see that the\npower to equate different things can be exercised with pushouts.\nExercise 2.6.2.4. Let W, X, Y be as drawn and f : W N X and g: W N Y the indicated\nfunctions.\nThe pushout of the diagram X\nf\nÐYYY W\ng\nYYYN Y is a set P. Write down the cardinality\nof P - n as a natural number n P N.\n♦\n\n2.6. FINITE COLIMITS IN SET\nExercise 2.6.2.5. Suppose that W \" H; what can you say about X \\W Z?\n♦\nExercise 2.6.2.6. Let W :\" N \" t0, 1, 2, . . .u denote the set of natural numbers, let X \" Z\ndenote the set of integers, and let Y \" t,u denote a one-element set. Define f : W N X\nby fpwq \" pw ` 1q, and define g: W N Y to be the unique map. Describe the set\nX \\W Y .\n♦\nExercise 2.6.2.7. Let i: R D X ˆ X be an equivalence relation (see Example 2.1.2.3\nfor notation). Composing with the projections π1, π2 : X ˆ X N X, we have two maps\nπ1 i, : R N X and π2 i: R N X.\na.) What is the pushout\nX\nπ1 i\nÐYYY R π2 i\nYYYN X?\nb.) If i: R D X ˆ X is not assumed to be an equivalence relation, we can still define the\npushout above. Is there a relationship between the pushout X\nπ1 i\nÐYYY R π2 i\nYYYN X and\nthe equivalence relation generated by R D X ˆ X?\n♦\nLemma 2.6.2.8 (Universal property for pushout). Suppose given the diagram of sets\nand functions as below.\nW\nu\n/\nt\n\nY\nX\nFor any set A and commutative solid arrow diagram as below (i.e. functions f : X N A\nand g: Y N A such that f t \" g u),\nW\nu\n$\nt\nz\nX\ni1\n\nf\n$\nY\ni2\n\ng\nz\nA\nX \\W Y\nD!\nO\n(2.39)\nthere exists a unique arrow\n\"\nf\ng : X \\W Y N A making everything commute,\nf \"\n\"\nf\ng i1\nand\ng \"\n\"\nf\ng i2.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.6.3\nOther finite colimits\nDefinition 2.6.3.1. [Coequalizer]\nSuppose given two parallel arrows\nX\nf\n/\ng\n/ Y.\nX\nf\n/\ng\n/ Y\nq\n/ Coeqpf, gq\n(2.40)\nThe coequalizer of f and g is the commutative diagram as to the right in (2.40), where\nwe define\nCoeqpf, gq :\" Y { fpxq „ gpxq\ni.e. the coequalizer of f and g is the quotient of Y by the equivalence relation generated\nby tpfpxq, gpxqq | x P Xu D Y ˆ Y\nExercise 2.6.3.2. Let X \" R be the set of real numbers. What is the coequalizer of the\ntwo maps X N X given by x ÞN x and x ÞN px ` 1q respectively?\n♦\nExercise 2.6.3.3. Find a universal property enjoyed by the coequalizer of two arrows. ♦\nExercise 2.6.3.4 (Initial object). An initial set is a set S such that for every set A, there\nexists a unique function S N A.\na.) Find an initial set.\nb.) Do you think that the notion initial set belongs in this section (Section 2.6)? How\nso? If coproducts, pushouts, and coequalizers are all colimits, what do colimits have\nin common?\n♦\n2.7\nOther notions in Set\nIn this section we discuss some left-over notions in the category of Sets.\n2.7.1\nRetractions\nDefinition 2.7.1.1. Suppose we have a function f : X N Y and a function g: Y N X\nsuch that g f \" idX. In this case we call f a retract section and we call g a retract\nprojection.\nExercise 2.7.1.2. Create an olog that includes sets X and Y , and functions f : X N Y\nand g: Y N X such that g f \" idX but such that f g % idY ; that is, such that f is a\nretract section but not an isomorphism.\n♦\n2.7.2\nCurrying\nCurrying is the idea that when a function takes many inputs, we can input them one at\na time or all at once. For example, consider the function that takes a material M and\nan extension E and returns the force transmitted through the material when it is pulled\nto that extension. This is a function e: ⌜a material⌝ˆ ⌜an extension⌝N ⌜a force⌝. This\nfunction takes two inputs at once, but it is convenient to \"curry\" the second input. Recall\n\n2.7. OTHER NOTIONS IN SET\nthat HomSetp⌜an extension⌝, ⌜a force⌝q is the set of theoretical force-extension curves.\nCurrying transforms e into a function\ne1 : ⌜a material⌝N HomSetp⌜an extension⌝, ⌜a force⌝q.\nThis is a more convenient way to package the same information.\nIn fact, it may be convenient to repackage this information another way. For any\nextension, we may want the function that takes a material and returns how much force\nit can transmit at that extension. This is a function\ne2 : ⌜an extension⌝N HomSetp⌜a material⌝, ⌜a force⌝q.\nNotation 2.7.2.1. Let A and B be sets. We sometimes denote the set of functions from\nA to B by\nBA :\" HomSetpA, Bq.\n(2.41)\nExercise 2.7.2.2. For a finite set A, let |A| P N denote the cardinality of (number of\nelements in) A. If A and B are both finite (including the possibility that one or both\nare empty), is it always true that |BA| \" |B||A|?\n♦\nProposition 2.7.2.3 (Currying). Let A denote a set. For any sets X, Y there is a\nbijection\nφ: HomSetpX ˆ A, Y q -\nYN HomSetpX, Y Aq.\n(2.42)\nProof. Suppose given f : X ˆ A N Y . Define φpfq: X N Y A as follows: for any x P X\nlet φpfqpxq: A N Y be defined as follows: for any a P A, let φpfqpxqpaq :\" fpx, aq.\nWe now construct the inverse, ψ: HomSetpX, Y Aq N HomSetpX ˆ A, Y q. Suppose\ngiven g: X N Y A. Define ψpgq: X ˆ A N Y as follows: for any pair px, aq P X ˆ A let\nψpgqpx, aq :\" gpxqpaq.\nThen for any f P HomSetpX ˆ A, Y q we have ψ φpfqpx, aq \" φpfqpxqpaq \" fpx, aq,\nand for any g P HomSetpX, Y Aq we have φ ψpgqpxqpaq \" ψpgqpx, aq \" gpxqpaq, Thus we\nsee that φ is an isomorphism as desired.\n□\nExercise 2.7.2.4. Let X \" t1, 2u, A \" ta, bu, and Y \" tx, yu.\na.) Write down three distinct elements of L :\" HomSetpX ˆ A, Y q.\nb.) Write down all the elements of M :\" HomSetpA, Y q.\nc.) For each of the three elements lP L you chose in part (a), write down the corre-\nsponding function φplq: X N M guaranteed by Proposition 2.7.2.3.\n♦\nExercise 2.7.2.5. Let A and B be sets.\nWe know that HomSetpA, Bq \" BA, so we\nhave a function idBA : HomSetpA, Bq N BA. Look at Proposition 2.7.2.3, making the\nsubstitutions X \" HomSetpA, Bq, Y \" B, and A \" A. Consider the function\nφ 1 : HomSetpHomSetpA, Bq, BAq N HomSetpHomSetpA, Bq ˆ A, Bq\nobtained as the inverse of (2.42).\nWe have a canonical element idBA in the domain\nof φ 1.\nWe can apply the function φ 1 and obtain an element ev \" φ 1pidBAq P\nHomSetpHomSetpA, Bq ˆ A, Bq, which is itself a function,\nev: HomSetpA, Bq ˆ A N B.\n\nCHAPTER 2. THE CATEGORY OF SETS\na.) Describe the function ev in terms of how it operates on elements in its domain.\nb.) Why might one be tempted to denote this function by ev?\n♦\nIf n P N is a natural number, recall from (2.6) that there is a nice set n \" t1, 2, . . . , nu.\nIf A is a set, we often make the abbreviation\nAn :\" An.\n(2.43)\nExercise 2.7.2.6. In Example 2.4.1.7 we said that R2 is an abbreviation for R ˆ R, but\nin (2.43) we say that R2 is an abbreviation for R2. Use Exercise 2.1.2.14, Proposition\n2.7.2.3, Exercise 2.4.2.10, and the fact that 1+1=2, to prove that these are isomorphic,\nR2 - R ˆ R.\n(The answer to Exercise 2.1.2.14 was A \" t,u: i.e. HomSetpt,u, Xq - X for all X.)\n♦\n2.7.3\nArithmetic of sets\nProposition 2.7.3.1 summarizes the properties of products, coproducts, and exponentials,\nand shows them all in a familiar light, namely that of arithmetic. In fact, one can think\nof the natural numbers as literally being the isomorphism classes of finite sets--that's\nwhat they are used for in counting. Consider the standard procedure for counting the\nelements of a set S, say cows in a field: one points to an element in S and simultaneously\nsays \"1\", points to another element in S and simultaneously says \"2\", and so on until\nfinished. This procedure amounts to nothing more than creating an isomorphism (one-\nto-one mapping) between S and some set n.\nAgain, the natural numbers are the isomorphism classes of finite sets. Their behavior,\ni.e. the arithmetic of natural numbers, reflects the behavior of sets. For example the fact\nthat multiplication distributes over addition is a fact about grids of dots as in Example\n2.4.1.2. The following proposition lays out such arithmetic properties of sets.\nIn this proposition, we denote the coproduct of two sets A and B by the notation\nA ` B rather than A \\ B. It is a reasonable notation in general, and one that is often\nused.\nProposition 2.7.3.1. The following isomorphisms exist for any sets A, B, and C (except\nfor one caveat, see Exercise 2.7.3.2).\n- A ` 0 - A\n- A ` B - B ` A\n- pA ` Bq ` C - A ` pB ` Cq\n- A ˆ 0 - 0\n- A ˆ 1 - A\n- A ˆ B - B ˆ A\n- pA ˆ Bq ˆ C - A ˆ pB ˆ Cq\n- A ˆ pB ` Cq - pA ˆ Bq ` pA ˆ Cq\n\n2.7. OTHER NOTIONS IN SET\n- A0 - 1\n- A1 - A\n- 0A - 0\n- 1A - 1\n- AB`C - AB ˆ AC\n- pABqC - ABˆC\nExercise 2.7.3.2. Everything in Proposition 2.7.3.1 is true except in one case, namely\nthat of\n00.\nIn this case, we get conflicting answers, because for any set A, including A \" H \" 0, we\nhave claimed both that A0 - 1 and that 0A - 0.\nWhat is the correct answer for 00, based on the definitions of 0 and 1, given in (2.6),\nand of AB, given in (2.41)?\n♦\nExercise 2.7.3.3. It is also true of natural numbers that if a, b P N and ab \" 0 then either\na \" 0 or b \" 0. Is the analogous statement true of all sets?\n♦\nProposition 2.7.3.1 is in some sense about isomorphisms. It says that understanding\nisomorphisms of sets reduces to understanding natural numbers. But note that there is\nmuch more going on in Set than isomorphisms; in particular there are functions that\nare not invertible.\nIn grade school you probably never saw anything that looked like this:\n53 ˆ 3 YN 5\nAnd yet in Exercise 2.7.2.5 we found a function ev: BA ˆ A N B that exists for any\nsets A, B. This function ev is not an isomorphism so it somehow does not show up as\nan equation of natural numbers. But it still has important meaning.\n16 In terms of\nmere number, it looks like we are being told of an important function 575 N 5, which is\nbizarre. The issue here is precisely the one you confronted in Exercise 2.1.2.13.\nExercise 2.7.3.4. Explain why there is a canonical function 53 ˆ 3 YN 5 but not a\ncanonical function 575 N 5.\n♦\nSlogan 2.7.3.5.\n\" It is true that a set is isomorphic to any other set with the same number\nof elements, but don't be fooled into thinking that the study of sets reduces\nto the study of numbers. Functions that are not isomorphisms cannot be\ncaptured within the framework of numbers. \"\n16Roughly, the existence of ev : 53 ˆ 3 YN 5 says that given a dot in a 5 ˆ 5 ˆ 5 grid of dots, and given\none of the three axes, you can tell me the coordinate of that dot along that axis.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.7.4\nSubobjects and characteristic functions\nDefinition 2.7.4.1. For any set B, define the power set of B, denoted PpBq, to be the\nset of subsets of B.\nExercise 2.7.4.2.\na.) How many elements does PpHq have?\nb.) How many elements does Ppt,uq have?\nc.) How many elements does Ppt1, 2, 3, 4, 5, 6uq have?\nd.) Any idea why they may have named it \"power set\"?\n♦\n2.7.4.3\nSimplicial complexes\nDefinition 2.7.4.4. Let V be a set and let PpV q be its powerset. A subset X D PpV q\nis called downward-closed if, for every u P X and every u1 D u, we have u1 P X. We say\nthat X contains all atoms if for every v P V the singleton set tvu is an element of X.\nA simplicial complex is a pair pV, Xq where V is a set and X D PpV q is a downward-\nclosed subset that contains all atoms. The elements of X are called simplices (singular:\nsimplex). Any subset u D V has a cardinality |u|, so we have a function X N N sending\neach simplex to its cardinality. The set of simplices with cardinality n ` 1 is denoted Xn\nand each element x P Xn is called an n-simplex. 17 Since X contains all atoms (subsets\nof cardinality 1), we have X0 - V , and we may also call the 0-simplices vertices. We\nsometimes call the 1-simplices edges. 18\nSince X0 - V , we may denote a simplicial complex pV, Xq simply by X.\nExample 2.7.4.5. Let n P N be a natural number and let V \" n ` 1. Define the n-simplex,\ndenoted ∆n, to be the simplicial complex PpV q D PpV q, i.e. the whole power set, which\nindeed is downward-closed and contains all atoms.\nWe can draw a simplicial complex X by first putting all the vertices on the page as\ndots. Then for every x P X1, we see that x \" tv, v1u consists of 2 vertices, so we draw\nan edge connecting v and v1. For every y P X2 we see that y \" tw, w1, w2u consists of 3\nvertices, so we draw a (filled-in) triangle connecting them. All three edges will be drawn\ntoo because X is assumed to be downward closed.\nThus, the 0-simplex ∆0, the 1-simplex ∆1, the 2-simplex ∆2, and the 3-simplex ∆3\nare drawn here:\n17It is annoying at first that the set of subsets with cardinality 1 is denoted X0, etc. But this is\nstandard convention because as we will see, Xn will be n-dimensional.\n18The reason we wrote X0 - V rather than X0 \" V is that X0 is the set of 1-element subsets of V .\nSo if V \" ta, b, cu then X0 \" ttau, tbu, tcuu. This is really just pedantry.\n\n2.7. OTHER NOTIONS IN SET\nThe n-simplices for various n's are in no way all of the simplicial complexes.\nIn\ngeneral a simplicial complex is a union or \"gluing together\" of simplices in a prescribed\nmanner. For example, consider the simplicial complex X with vertices X0 \" t1, 2, 3, 4u,\nedges X1 \" tt1, 2u, t2, 3u, t2, 4uu, and no higher simplices X2 \" X3 \" \" H. We\nmight draw X as follows:\n1‚\n2‚\n3‚\n4‚\nExercise 2.7.4.6. Let X be the following simplicial complex, so that X0 \" tA, B, . . . , Mu.\nIn this case X1 consists of elements like tA, Bu and tD, Ku but not tD, Ju.\nWrite out X2 and X3 (hint: the drawing of X indicates that X3 should have one\nelement).\n♦\nExercise 2.7.4.7. The 2-simplex ∆2 is drawn as a filled-in triangle with vertices V \"\nt1, 2, 3u. There is a simplicial complex X \" B∆2 that would be drawn as an empty\ntriangle with the same set of vertices.\na.) Draw ∆2 and X side by side and make clear the difference.\nb.) Write down the data for X as a simplicial complex. In other words what are the sets\nX0, X1, X2, X3, . . .?\n♦\n2.7.4.8\nSubobject classifier\nDefinition 2.7.4.9. Define the subobject classifier for Set, denoted Ω, to be the set\nΩ:\" tTrue, Falseu, together with the function t,u N Ωsending the unique element to\nTrue.\n\nCHAPTER 2. THE CATEGORY OF SETS\nProposition 2.7.4.10. Let B be a set. There is an isomorphism\nφ: HomSetpB, Ωq -\nYN PpBq.\nProof. Given a function f : B N Ω, let φpfq \" tb P B | fpbq \" Trueu D B. We now\nconstruct a function ψ: PpBq N HomSetpB, Ωq to serve as the inverse of φ. Given a\nsubset B1 D B, define ψpB1q: B N Ωas follows:\nψpiqpbq \"\n#\nTrue\nif b P B1,\nFalse\nif b R B1.\nOne checks easily that φ and ψ are mutually inverse.\n□\nDefinition 2.7.4.11 (Characteristic function). Given a subset B1 D B, we call the\ncorresponding function B N Ωthe characteristic function of B1 in B.\nLet B be any set and let PpBq be its power set. By Proposition 2.7.4.10 there is a\nbijection between PpBq and ΩB. Since Ωhas cardinality 2, the cardinality of PpBq is\n2|B|, which explains the correct answer to Exercise 2.7.4.2.\nExercise 2.7.4.12. Let f : A N Ωdenote the characteristic function of some A1 D A, and\ndefine A2 D A to be its complement, A2 :\" A A1 (i.e. a P A2 if and only if a R A1).\na.) What is the characteristic function of A2 D A?\nb.) Can you phrase it in terms of some function ΩN Ω?\n♦\n2.7.5\nSurjections, injections\nThe classical definition of injections and surjections involves elements, which we give now.\nBut a more robust notion involves all maps and will be given in Proposition 2.7.5.4.\nDefinition 2.7.5.1. Let f : X N Y be a function. We say that f is surjective if, for all\ny P Y there exists some x P X such that fpxq \" y. We say that f is injective if, for all\nx P X and all x1 P X with fpxq \" fpx1q we have x \" x1.\nA function that is both injective and surjective is called bijective.\nRemark 2.7.5.2. It turns out that a function that is bijective is always an isomorphism\nand that all isomorphisms are bijective. We will not show that here, but it is not too\nhard; see for example [Big, Theorem 5.4].\nDefinition 2.7.5.3 (Monomorphisms, epimorphisms). Let f : X N Y be a function.\nWe say that f is a monomorphism if for all sets A and pairs of functions g, g1 : A N X,\nA\ng\n\"\ng1\n=X\nf\n/ Y\nif f g \" f g1 then g \" g1.\n\n2.7. OTHER NOTIONS IN SET\nWe say that f is an epimorphism if for all sets B and pairs of functions h, h1 : Y N B,\nX\nf\n/ Y\nh\n\"\nh1\n=B\nif h f \" h1 f then h \" h1.\nProposition 2.7.5.4. Let f : X N Y be a function. Then f is injective if and only if\nit is a monomorphism; f is surjective if and only if it is an epimorphism.\nProof. If f is a monomorphism it is clearly injective by putting A \" t,u. Suppose that\nf is injective and let g, g1 : A N X be functions such that f g \" f g1, but suppose for\ncontradiction that g % g1. Then there is some element a P A such gpaq % g1paq P X. But\nby injectivity fpgpaqq % fpg1paqq, contradicting f g \" f g1.\nSuppose that f : X N Y is an epimorphism and choose some y0 P Y (noting that if\nY is empty then the claim is vacuously true). Let h: Y N Ωdenote the characteristic\nfunction of the subset ty0u D Y and let h1 : Y N Ωdenote the characteristic function\nof H D Y ; note that hpyq \" h1pyq for all y % y0. Then since f is an epimorphism and\nh % h1, we must have h f % h1 f, so there exists x P X with hpfpxqq % h1pfpxqq, which\nimplies that fpxq \" y0. This proves that f is surjective.\nFinally, suppose that f is surjective, and let h, h1 : Y N B be functions with h f \"\nh1 f. For any y P Y , there exists some x P X with fpxq \" y, so hpyq \" hpfpxqq \"\nh1pfpxqq \" h1pyq. This proves that f is an epimorphism.\n□\nProposition 2.7.5.5. Let f : X N Y be a monomorphism.\nThen for any function\ng: A N Y , the top map f 1 : X ˆY A N A in the diagram\nX ˆY A\nf 1\n/\ng1\n\n⌟\nA\ng\n\nX\nf\n/ Y\nis a monomorphism.\nProof. To show that f 1 is a monomorphism, we take an arbitrary set B and two maps\nm, n: B N X ˆY A such that f 1 m \" f 1 n, denote that function by p :\" f 1 m: B N A.\nNow let q \" g1 m and r \" g1 n. The diagram looks like this:\nB\nm\n/\nn\n/\np\n%\nq\n(\nr\n(\nX ˆY A\nf 1\n/\ng1\n\n⌟\nA\ng\n\nX\nf\n/ Y\nWe have that\nf q \" f g1 m \" g f 1 m \" g f 1 n \" f g1 n \" f r\n\nCHAPTER 2. THE CATEGORY OF SETS\nBut we assumed that f is a monomorphism so this implies that q \" r. By the universal\nproperty of pullbacks, Lemma 2.5.1.14, we have m \" n.\n□\nExercise 2.7.5.6. Show, in analogy to Proposition 2.7.5.5, that pushouts preserve epi-\nmorphisms.\n♦\nExample 2.7.5.7. Suppose an olog has a fiber product square\nX ˆZ Y\ng1\n/\nf 1\n\nY\nf\n\nX\ng\n/ Z\nsuch that f is intended to be an injection and g is any map. 19 In this case, there are\nnice labeling systems for f 1, g1, and X ˆZ Y . Namely:\n- \"is\" is an appropriate label for f 1,\n- the label for g is an appropriate label for g1,\n- (the label for X, then \"which\", then the label for g, then the label for Y ) is an\nappropriate label for X ˆZ Y .\nTo give an explicit example,\nXˆZY\na rib which is\nmade by a cow\nis made by\n/\nis\n\nY\na cow\nis\n\nX\na rib\nis made by\n/\nZ\nan animal\nCorollary 2.7.5.8. Let i: A N X be a monomorphism. Then there is a fiber product\nsquare of the form\nA\nf 1 /\ni\n\n⌟\nt,u\nT rue\n\nX\nf\n/ Ω.\n(2.44)\nProof. Let X1 D X denote the image of i and let f : X N Ωdenote the characteristic\nfunction of X1 D X. Then it is easy to check that Diagram 2.44 is a pullback.\n□\nExercise 2.7.5.9. Consider the subobject classifier Ω, the singleton t,u and the map\nt,u T rue\nYYYN Ωfrom Definition 2.7.4.9. Look at diagram 2.44 and in the spirit of Exercise\n2.7.5.7, come up with a label for Ω, a label for t,u, and a label for True. Given a label\nfor X and a label for f, come up with a label for A, a label for i and a label for f 1, such\nthat the English smoothly fits the mathematics.\n♦\n19Of course, this diagram is symmetrical, so the same ideas hold if g is an injection and f is any map.\n\n2.7. OTHER NOTIONS IN SET\n2.7.6\nMultisets, relative sets, and set-indexed sets\nIn this section we prepare ourselves for considering categories other than Set, by looking\nat some categories related to Set.\n2.7.6.1\nMultisets\nConsider the set X of words in a given document. If WCpXq is the wordcount of the\ndocument, we will not generally have WCpXq \" |X|. The reason is that a set cannot\ncontain the same element more than once, so words like \"the\" might be undercounted in\n|X|. A multiset is a set in which elements can be assigned a multiplicity, i.e. a number\nof times they are to be counted.\nBut if X and Y are multisets, what is the appropriate type of mapping from X\nto Y ?\nSince every set is a multiset (in which each element has multiplicity 1), let's\nrestrict ourselves to notions of mapping that agree with the usual one on sets. That\nis, if multisets X and Y happen to be sets then our mappings X N Y should just be\nfunctions.\nExercise 2.7.6.2.\na.) Come up with some notion of mapping for multisets that generalizes functions when\nthe notion is restricted to sets.\nb.) Suppose that X \" p1, 1, 2, 3q and Y \" pa, b, b, bq, i.e. X \" t1, 2, 3u with 1 having\nmultiplicity 2, and Y \" ta, bu with b having multiplicity 3. What are all the maps\nX N Y in your notion?\n♦\nIn Chapter 4 we will be getting to the definition of category, and you can test whether\nyour notion of mapping in fact defines a category. Here is my definition of mapping for\nmultisets.\nDefinition 2.7.6.3. A multiset is a sequence X :\" pE, B, πq where E and B are sets\nand π: E N B is a surjective function. We refer to E as the set of element instances\nof X, we refer to B as the set of element names of X, and we refer to π as the naming\nfunction for X. Given an element name x P B, let π 1pxq D E be the preimage; the\nnumber of elements in π 1pxq is called the multiplicity of x.\nSuppose that X \" pE, B, πq and X1 \" pE1, B1, π1q are multisets. A mapping from\nX to Y , denoted f : X N Y , consists of a pair pf1, f0q such that f1 : E N E1 and\nf0 : B N B1 are functions and such that the following diagram commutes:\nE\nf1\n/\nπ\n\nE1\nπ1\n\nB\nf0\n/ B1.\n(2.45)\nExercise 2.7.6.4. Suppose that a pseudo-multiset is defined to be almost the same as a\nmultiset, except that π is not required to be surjective.\na.) Write down a pseudo-multiset that is not a multi-set.\nb.) Describe the difference between the two notions in terms of multiplicities.\n\nCHAPTER 2. THE CATEGORY OF SETS\nc.) Complexity of names aside, which do you think is a more useful notion: multiset or\npseudo-multisets?\n♦\nExercise 2.7.6.5. Consider the multisets described in Exercise 2.7.6.2.\na.) Write each of them in the form pE, B, πq, as in Definition 2.7.6.3.\nb.) In terms of the same definition, what are the mappings X N Y ?\nc.) If we remove the restriction that diagram 2.45 must commute, how many mappings\nX N Y are there?\n♦\n2.7.6.6\nRelative sets\nLet's continue with our ideas from multisets, but now suppose that we have a fixed set B\nof names that we want to keep once and for all. Whenever someone discusses a set, each\nelement must have a name in B. And whenever someone discusses a mapping, it must\npreserve the names. For example, if B is the set of English words, then every document\nconsists of an ordered set mapping to B (e.g. 1 ÞN Suppose, 2 ÞN that, 3 ÞN we, etc.) A\nmapping from document A to document B would send each word found somewhere in\nA to the same word found somewhere in B. This notion is defined carefully below.\nDefinition 2.7.6.7 (Relative set). Let B be a set. A relative set over B, or simply a\nset over B, is a pair pE, πq such that E is a set and π: E N B is a function. A mapping\nof relative sets over B, denoted f : pE, πq N pE1, π1q, is a function f : E N E1 such that\nthe triangle below commutes, i.e. π \" π1 f,\nE\nf\n/\nπ\n\nE1\nπ1\n\nB\nExercise 2.7.6.8. Given sets X, Y, Z and functions f : X N Y and g: Y N Z, we can\ncompose them to get a function X N Z. If B is a set, if pX, pq, pY, qq, and pZ, rq are\nrelative sets over B, and if f : pX, pq N pY, qq and g: pY, qq N pZ, rq are mappings, is\nthere a reasonable notion of composition such that we get a mapping of relative sets\npX, pq N pZ, rq? Hint: draw diagrams.\n♦\nExercise 2.7.6.9.\na.) Let t,u denote a set with one element. What is the difference between sets over t,u\nand simply sets?\nb.) Describe the sets relative to H. How many are there?\n♦\n2.7.6.10\nIndexed sets\nLet A be a set. Suppose we want to assign to each element a P A a set Sa. This is called\nan A-indexed set. In category theory we are always interested in the legal mappings\nbetween two different structures of the same sort, so we need a notion of A-indexed\nmappings; we do the \"obvious thing\".\n\n2.7. OTHER NOTIONS IN SET\nExample 2.7.6.11. Let C be a set of classrooms. For each c P C let Pc denote the set of\npeople in classroom c, and let Sc denote the set of seats (chairs) in classroom c. Then P\nand S are C-indexed sets. The appropriate kind of mapping between them respects the\nindexes. That is, a mapping of multi-sets P N S should, for each classroom c P C, be a\nfunction Pc N Sc.20\nDefinition 2.7.6.12. Let A be a set. An A-indexed set is a collection of sets Sa, one for\neach element a P A; for now we denote this by pSaqaPA. If pS1\naqaPA is another A-indexed\nset, a mapping of A-indexed sets from pSaqaPA to pS1\naqaPA, denoted\npfaqaPA : pSaqaPA N pS1\naqaPA\nis a collection of functions fa : Sa N S1\na, one for each element a P A.\nExercise 2.7.6.13. Let t,u denote a one element set. What are t,u-indexed sets and\nmappings between them?\n♦\nExercise 2.7.6.14. There is a strong relationship between A-indexed sets and relative sets\nover A. What is it?\n♦\n20If we wanted to allow people from any classroom to choose a chair from just any classroom, category\ntheory would tell us to reconsider P and S as sets, forgetting their indices. See Section 5.1.4.7.\n\nCHAPTER 2. THE CATEGORY OF SETS\n\nChapter 3\nCategories and functors,\nwithout admitting it\nIn this chapter we begin to use our understanding of sets to build more interesting\nmathematical devices, each of which organizes our understanding of a certain kind of\ndomain. For example, monoids organize our thoughts about agents acting on objects;\ngroups are monoids except restricted to only allow agents to act reversibly. We will\nthen study graphs, which are systems of nodes and arrows that can capture ideas like\ninformation flow through a network or model connections between building blocks in a\nmaterial. We will discuss orders, which can be used to study taxonomies or hierarchies.\nFinally we take a mathematical look at databases, which actually subsume everything\nelse in the chapter. Databases are connection patterns for structuring information.\nWe will see in Chapter 4 that everything we study in the present chapter is an example\nof a category. So is Set, the category of sets studied in Chapter 2. One way to think of\na category is as a set of objects and a connection pattern between them; sets are objects\n(ovals full of dots if you wish) connected by functions. But each set is itself a category:\nthe objects inside it are just disconnected! Just like a set has an interior view and an\nexterior view, so will all the categories in this chapter. Each monoid is a category, but\nthere is also a category of monoids.\nHowever, we will not really say the word \"category\" much if at all in this chapter.\nIt seems preferable to let the ideas rise on their own accord as interesting structures in\ntheir own right before explaining that everything in site fits into a single framework.\nThat will be the pleasant reward to come in Chapter 4.\n3.1\nMonoids\nA common way to interpret phenomena we see around us is to say that agents are acting\non objects. For example, in a computer drawing program, the user acts on the canvas\nin certain prescribed ways. Choices of actions from an available list can be performed in\nsequence to transform one image into another. As another example, one might investigate\nthe notion that time acts on the position of hands on a clock in a prescribed way. A\nfirst rule for actions is this: the performance of a sequence of several actions is itself the\nperformance of an action--a more complex action, but an action nonetheless.\nMathematical objects called monoids and groups are tasked with encoding the agent's\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nperspective in all this, i.e. what the agent can do, and what happens when different\nactions are done in succession. A monoid can be construed as a set of actions, together\nwith a formula that encodes how a sequence of actions is itself considered an action. A\ngroup is the same as a monoid, except that every action is required to be reversible. In\nthis section we concentrate on monoids; we will get to groups in Section 3.2.\n3.1.1\nDefinition and examples\nDefinition 3.1.1.1 (Monoid). A monoid is a sequence pM, e, ‹q, where M is a set, e P M\nis an element, and ‹: M ˆM N M is a function, such that the following conditions hold\nfor all m, n, p P M:\n- m ‹ e \" m,\n- e ‹ m \" m, and\n- pm ‹ nq ‹ p \" m ‹ pn ‹ pq.\nWe refer to e as the identity element and to ‹ as the multiplication formula for the\nmonoid.\n1 We call the first two rules identity laws and the third rule the associativity\nlaw for monoids.\nRemark 3.1.1.2. To be pedantic, the conditions from Definition 3.1.1.1 should be stated\n- ‹pm, eq \" m,\n- ‹pe, mq \" m, and\n- ‹p‹pm, nq, pq \" ‹pm, p‹pn, pqq.\nThe way they are written in Definition 3.1.1.1 is called infix notation, and we often use\ninfix notation without mentioning it. That is, given a function : A ˆ B N C, we may\nwrite a b rather than pa, bq.\nExample 3.1.1.3 (Additive monoid of natural numbers). Let M \" N be the set of natural\nnumbers. Let e \" 0 and let ‹: M ˆ M N M denote addition, so that ‹p4, 18q \" 22.\nThen the equations m ‹ 0 \" m and 0 ‹ m \" m hold, and pm ‹ nq ‹ p \" m ‹ pn ‹ pq. By\nassigning e and ‹ in this way, we have \"given N the structure of a monoid\".\nRemark 3.1.1.4. Sometimes we are working with a monoid pM, e, ‹q, and the identity\ne and multiplication ‹ are somehow clear from context. In this case we might refer to\nthe set M as though it were the whole monoid. For example, if we were discussing the\nmonoid from Example 3.1.1.3, we might refer to it as N. The danger comes because sets\nmay have multiple monoid structures, as we see below in Exercise 3.1.1.6.\nExample 3.1.1.5 (Non-monoid). If M is a set, we might call a function f : M ˆ M N M\nan operation on M. For example, if M \" N is the set of natural numbers, we can consider\nthe operation f : N N N called exponentiation. For example fp2, 5q \" 2 2 2 2 2 \" 32\nand fp7, 2q \" 49. This is indeed an operation, but it is not part of any monoid. For one\nthing there is no possible unit. Trying the obvious choice of e \" 1, we see that a1 \" a\n(good), but that 1a \" 1 (bad: we need it to be a). For another thing, this operation is\nnot associative because in general abc % pabqc. For example, 212 \" 2 but p21q2 \" 4.\n1Although the function ‹: M ˆ M N M is called the multiplication formula, it may have nothing\nto do with multiplication. It is nothing more than a formula for taking two inputs and returning an\noutput; calling it \"multiplication\" is suggestive of its origins, rather than prescriptive of its behavior.\n\n3.1. MONOIDS\nOne might also attempt to consider an operation f : M ˆ M N M that, upon closer\ninspection, aren't even operations. For example, if M \" Z then exponentiation is not\neven an operation. Indeed, fp2, 1q \" 2 1 \" 1\n2, and this is not an integer. To have a\nfunction f : M ˆ M N M, we need that every element of the domain, in this case every\npair of integers, has an output under f. So there is no such function f.\nExercise 3.1.1.6. Let M \" N be the set of natural numbers. Taking e \" 1, come up with\na formula for ‹ that gives N the structure of a monoid.\n♦\nExercise 3.1.1.7. Come up with an operation on the set M \" t1, 2, 3, 4u, i.e. a legitimate\nfunction f : M ˆM N M, such that f cannot be the multiplication formula for a monoid\non M. That is, either it is not associative, or no element of M can serve as a unit.\n♦\nExercise 3.1.1.8. In both Example 3.1.1.3 and Exercise 3.1.1.6, the monoids pM, e, ‹q\nsatisfied an additional rule called commutativity, namely m‹n \" n‹m for every m, n P M.\nThere is a monoid pM, e, ‹q lurking in linear algebra textbooks that is not commutative;\nif you have background in linear algebra try to answer this: what M, e, and ‹ might I\nbe referring to?\n♦\nExercise 3.1.1.9. Recall the notion of commutativity for monoids from Exercise 3.1.1.8.\na.) What is the smallest set M that you can give the structure of a non-commutative\nmonoid?\nb.) What is the smallest set M that you can give the structure of a monoid?\n♦\nExample 3.1.1.10 (Trivial monoid). There is a monoid with only one element, M \"\npteu, e, ‹q where ‹: teu ˆ teu N teu is the unique function. We call this monoid the\ntrivial monoid, and sometimes denote it 1.\nExample 3.1.1.11. Suppose that pM, e, ‹q is a monoid. Given elements m1, m2, m3, m4\nthere are five different ways to parenthesize the product m1 ‹ m2 ‹ m3 ‹ m4, and the\nassociativity law for monoids will show them all to be the same. We have\nppm1 ‹ m2q ‹ m3q ‹ m4 \" pm1 ‹ m2q ‹ pm3 ‹ m4q\n\" pm1 ‹ pm2 ‹ m3qq ‹ m4\n\" m1 ‹ pm2 ‹ pm3 ‹ m4qq\n\" m1 ‹ ppm2 ‹ m3q ‹ m4q\nIn fact, the product of any list of monoid elements is the same, regardless of parenthe-\nsization. Therefore, we can unambiguously write m1m2m3m4m5 rather than any given\nparenthesization of it. This is known as the coherence theorem and can be found in\n[Mac].\n3.1.1.12\nFree monoids and finitely presented monoids\nDefinition 3.1.1.13. Let X be a set. A list in X is a pair pn, fq where n P N is a natural\nnumber (called the length of the list) and f : n N X is a function, where n \" t1, 2, . . . , nu.\nWe may denote such a list by\npn, fq \" rfp1q, fp2q, . . . , fpnqs.\nThe empty list is the unique list in which n \" 0; we may denote it by r s. Given an\nelement x P X the singleton list on x is the list rxs. Given a list L \" pn, fq and a number\ni P N with i d n, the ith entry of L is the element fpiq P X.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nGiven two lists L \" pn, fq and L1 \" pn1, f 1q, define the concatenation of L and L1,\ndenoted L ``L1, to be the list pn ` n1, f ``f 1q, where f ``f 1 : n ` n1 N X is given on\ni d n ` n1 by\npf ``f 1qpiq :\"\n#\nfpiq\nif i d n\nf 1pi nq\nif i e n ` 1\nExample 3.1.1.14. Let X \" ta, b, c, . . . , zu. The following are elements of ListpXq:\nra, b, cs, rps, rp, a, a, a, ps, r s, . . .\nThe concatenation of ra, b, cs and rp, a, a, a, ps is ra, b, c, p, a, a, a, ps. The concatenation\nof any list A with r s is just A.\nDefinition 3.1.1.15. Let X be a set. The free monoid generated by X is the sequence\nM :\" pListpXq, r s, ``q, where ListpXq is the set of lists of elements in X, where r s P\nListpXq is the empty list, and where `` is the operation of list concatenation. We refer\nto X as the set of generators for the monoid M.\nExercise 3.1.1.16. Let t,u denote a one-element set.\na.) What is the free monoid generated by t,u?\nb.) What is the free monoid generated by H?\n♦\nIn the definition below, we will define a monoid M by specifying some generators\nand some relations. Lists of generators provide us all the possible ways to write elements\nof M. The relations allow us to have two such ways of writing the same element. The\nfollowing definition is a bit dense, so see Example 3.1.1.19 for a concrete example.\nDefinition 3.1.1.17 (Presented monoid). Let G be a finite set, let n P N be a natural\nnumber, 2 and for each 1 d i d n, let mi and m1\ni be elements of ListpGq.\nThe\nmonoid presented by generators G and relations tpmi, m1\niq | 1 d i d nu is the monoid\nM \" pM, e, ‹q defined as follows.\nLet „ denote the equivalence relation on ListpGq\ngenerated by tpxmiy „ xm1\niyq | x, y P ListpGq, 1 d i d nu, and define M \" ListpGq{ „.\nLet e \" r s and let a b be obtained by concatenating representing lists.\nRemark 3.1.1.18. Every free monoid is a presented monoid, because we can just take the\nset of relations to be empty.\nExample 3.1.1.19. Let G \" ta, b, c, du. Think of these as buttons that can be pressed.\nThe free monoid ListpGq is the set of all ways of pressing buttons, e.g. pressing a then a\nthen c then c then d corresponds to the list ra, a, c, c, ds. The idea of presented monoids\nis that you notice that pressing ra, a, cs always gives the same result as pressing rd, ds.\nYou also notice that pressing rc, a, c, as is the same thing as doing nothing.\nIn this case, we would have m1 \" ra, a, cs, m1\n1 \" rd, ds, and m2 \" rc, a, c, as, m1\n2 \" r s\nand relations tpm1, m1\n1q, pm2, m1\n2qu. Really this means that we're equating m1 with m1\nand m2 with m1\n2, which for convenience we'll write out:\nra, a, cs \" rd, ds\nand\nra, c, a, cs \" r s\n2The number n P N is going to stand for the number of relations we declare.\n3Each mi and m1\ni are going to be made equal in the set M.\n\n3.1. MONOIDS\nTo see how this plays out, we give an example of a calculation in M \" ListpGq{ „.\nNamely,\nrb, c, b, d, d, a, c, a, a, c, ds \" rb, c, b, a, a, c, a, c, a, a, c, ds \" rb, c, b, a, a, a, c, ds\n\" rb, c, b, a, d, d, ds.\nApplication 3.1.1.20 (Buffer). Let G \" ta, b, c, . . . zu. Suppose we have a buffer of 32\ncharacters and we want to consider the set of lists of length at most 32 to be a monoid.\nWe simply have to decide what happens when someone types a list of length more than\n32.\nOne option is to say that the last character typed overwrites the 32nd entry,\nra1, a2, . . . , a31, a32, bs „1 ra1, a2, . . . , a31, bs.\nAnother option is to say that any character typed after 32 entries is discarded,\nra1, a2, . . . , a31, a32, bs „2 ra1, a2, . . . , a31, a32s.\nBoth of these yield finitely presented monoids, generated by G. (In case it's useful, the\nnumber of necessary relations in both cases is 2633.)\n♦♦\nExercise 3.1.1.21. Let's consider the buffer concept again (see Application 3.1.1.20), but\nthis time only having size 3 rather than size 32. Show using Definition 3.1.1.17 that with\nrelations given by „1 we indeed have ra, b, c, d, e, fs \" ra, b, fs and that with relations\ngiven by „2 we indeed have ra, b, c, d, e, fs \" ra, b, cs.\n♦\nExercise 3.1.1.22. Let K :\" tBS, a, b, c, . . . , zu, a set having 27 elements. Suppose you\nwant to think of BS P K as the \"backspace key\" and the elements a, b, . . . z P K as the\nletter keys on a keyboard. Then the free monoid ListpKq is not quite appropriate as a\nmodel because we want ra, b, d, BSs \" ra, bs.\na.) Choose a set of relations for which the monoid presented by generators K and the\nchosen relations is appropriate to this application.\nb.) Under your relations, how does rBSs compare with r s? Is that suitable?\n♦\n3.1.1.23\nCyclic monoids\nDefinition 3.1.1.24. A monoid is called cyclic if it has a presentation involving only\none generator.\nExample 3.1.1.25. Let Q be a symbol; we look at some cyclic monoids generated by\ntQu. With no relations the monoid would be the free monoid on one generator, and\nwould have underlying set tr s, rQs, rQ, Qs, rQ, Q, Qs, . . .u, with identity element r s and\nmultiplication given by concatenation (e.g. rQ, Q, Qs ``rQ, Qs \" rQ, Q, Q, Q, Qs). This\nis just N, the additive monoid of natural numbers.\nWith the really strong relation rQs „ r s we would get the trivial monoid, a monoid\nhaving only one element (see Example 3.1.1.10).\nAnother possibility is given in the first part of Example 3.1.2.3, where the relation\nQ12 „ r s is used, where Q12 is shorthand for rQ, Q, Q, Q, Q, Q, Q, Q, Q, Q, Q, Qs.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nExample 3.1.1.26. Consider the cyclic monoid with generator Q and relation Q7 \" Q4.\nThis monoid has seven elements, te \" Q0, Q \" Q1, Q2, Q3, Q4, Q5, Q6u, and we know\nthat Q6 ‹ Q5 \" Q7 Q4 \" Q4 Q4 \" Q7 Q \" Q5. One might depict this monoid as\nfollows\ne‚\n/ Q‚\n/ Q2\n‚\n/ Q3\n‚\n/ Q4\n‚\n\nQ6\n‚\nA\nQ5\n‚\no\nTo see the mathematical source of this intuitive depiction, see Example 5.2.1.17.\nExercise 3.1.1.27 (Classify the cyclic monoids). Classify all the cyclic monoids up to\nisomorphism. That is, come up with a naming system such that every cyclic monoid can\nbe given a name in your system, such that no two non-isomorphic cyclic monoids have\nthe same name, and such that no name exists in the system unless it refers to a cyclic\nmonoid.\nHint: one might see a pattern in which the three monoids in Example 3.1.1.25 corre-\nspond respectively to 8, 1, and 12, and then think \"Cyclic monoids can be classified by\n(i.e. systematically named by elements of) the set N \\ t8u.\" That idea is on the right\ntrack, but is not correct.\n♦\n3.1.2\nMonoid actions\nDefinition 3.1.2.1 (Monoid action). Let pM, e, ‹q be a monoid and let S be a set. An\naction of pM, e, ‹q on S, or simply an action of M on S or an M-action on S, is a\nfunction\nu : M ˆ S N S\nsuch that the following conditions hold for all m, n P M and all s P S:\n- e u s \" s\n- m u pn u sq \" pm ‹ nq u s. 4\nRemark 3.1.2.2. To be pedantic (and because it's sometimes useful), we may rewrite u\nas α: M ˆ S N S and restate the conditions from Definition 3.1.2.1 as\n- αpe, sq \" s, and\n- αpm, αpn, sqq \" αpm ‹ n, sq.\nExample 3.1.2.3. Let S \" t0, 1, 2, . . . , 11u and let N \" pN, 0, `q be the additive monoid\nof natural numbers (see Example 3.1.1.3). We define a function u: NˆS N S by taking\na pair pn, sq to the remainder that appears when n ` s is divided by 12. For example\n4 u 2 \" 6 and 8 u 9 \" 5. This function has the structure of a monoid action because\nthe two rules from Definition 3.1.2.1 hold.\n4 Definition 3.1.2.1 actually defines a left action of pM, e, ‹q on S. A right action is like a left action\nexcept the order of operations is somehow reversed. We will not really use right-actions in this text, but\nwe briefly define it here for completeness. With notation as above, the only difference is in the second\ncondition. We replace it by the condition that for all m, n P M and all s P S we have\nm u pn u sq \" pn ‹ mq u s\n\n3.1. MONOIDS\nSimilarly, let T denote the set of points on a circle, elements of which are denoted by\na real number in the interval r0, 12q, i.e.\nT \" tx P R | 0 d x a 12u\nand let R \" pR, 0, `q denote the additive monoid of real numbers. Then there is an\naction R ˆ T N T, similar to the one above (see Exercise 3.1.2.4).\nOne can think of this as an action of the monoid of time on the clock.\nExercise 3.1.2.4.\na.) Realize the set T :\" r0, 12q D R as the coequalizer of a pair of arrows R N R.\nb.) For any x P R, realize the mapping x : T N T, implied by Example 3.1.2.3, using\nthe universal property of coequalizers.\nc.) Prove that it is an action.\n♦\nExercise 3.1.2.5. Let B denote the set of buttons (or positions) of a video game controller\n(other than, say 'start' and 'select'), and consider the free monoid ListpBq on B.\na.) What would it mean for ListpBq to act on the set of states of some game? Imagine\na video game G1 that uses the controller, but for which ListpBq would not be said to\nact on the states of G1. Now imagine a simple game G for which ListpBq would be\nsaid to act.\nb.) Can you think of a state s of G, and two distinct elements l, l1 P ListpBq such that\nlu s \" l1 u s? In video game parlance, what would you call an element b P B such\nthat, for every state s P G, one has b u s \" s?\nc.) In video game parlance, what would you call a state s P S such that, for every\nsequence of buttons lP ListpBq, one has lu s \" s?\n♦\nApplication 3.1.2.6. Let f : R N R be a differentiable function of which we want to find\nroots (points x P R such that fpxq \" 0). Let x0 P R be a starting point. For any n P N\nwe can apply Newton's method to xn to get\nxn`1 \" xn fpxnq\nf 1pxnq.\nThis is a monoid (namely N, the free monoid on one generator) acting on a set (namely\nR).\nHowever, Newton's method can get into trouble. For example at a critical point it\ncauses division by 0, and sometimes it can oscillate or overshoot. In these cases we want\nto perturb a bit to the left or right. To have these actions available to us, we would add\n\"perturb\" elements to our monoid. Now we have more available actions at any point,\nbut at the cost of using a more complicated monoid.\nWhen publishing an experimental finding, there may be some deep methodological\nquestions that are not considered suitably important to mention. For example, one may\nnot publish the kind solution finding method (e.g. Newton's method or Runge-Kutta)\nthat was used, nor the set of available actions, e.g. what kinds of perturbation were used\nby the researcher. However, these may actually influence the reproducibility of results.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nBy using a language such as that of monoid actions, we can align our data model with\nour unspoken assumptions about how functions are analyzed.\n♦♦\nRemark 3.1.2.7. A monoid is useful for understanding how an agent acts on the set of\nstates of an object, but there is only one kind of action. At any point, all actions are\navailable. In reality it is often the case that contexts can change and different actions\nare available at different times. For example on a computer, the commands available in\none application have no meaning in another. This will get us to categories in the next\nchapter.\n3.1.2.8\nMonoids actions as ologs\nIf monoids are understood in terms of how they act on sets, then it is reasonable to think\nof them in terms of ologs. In fact, the ologs associated to monoids are precisely those\nologs that have exactly one type (and possibly many arrows and commutative diagrams).\nExample 3.1.2.9. In this example we show how to associate an olog to a monoid action.\nConsider the monoid M generated by the set tu, d, ru, standing for \"up, down, right\",\nand subject to the relations\nru, ds „ r s,\nrd, us „ r s,\nru, rs \" rr, us,\nand\nrd, rs \" rr, ds.\nWe might imagine that M acts on the set of positions for a character in an old video\ngame. In that case the olog corresponding to this action should look something like the\nfollowing:\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved up results in a character position, which\nwhen moved down results in a character position that we'll call P(x). We also\nknow that x is a character position that we'll call Q(x). Fact: whenever x is a\ncharacter position we will have P(x)=Q(x). Summary: [up, down] = [ ]\n\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved down results in a character position,\nwhich when moved up results in a character position that we'll call P(x). We also\nknow that x is a character position that we'll call Q(x). Fact: whenever x is a\ncharacter position we will have P(x)=Q(x). Summary: [down, up] = [ ]\n\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved up results in a character position, which\nwhen moved right results in a character position that we'll call P(x). We also\nknow that x is a character position, which when moved right results in a\ncharacter position, which when moved up results in a character position that\nwe'll call Q(x). Fact: whenever x is a character position we will have P(x)=Q(x).\nSummary: [up, right] = [right, up]\n\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved down results in a character position,\nwhich when moved right results in a character position that we'll call P(x). We\nalso know that x is a character position, which when moved right results in a\ncharacter position, which when moved down results in a character position that\nwe'll call Q(x). Fact: whenever x is a character position we will have P(x)=Q(x).\nSummary: [down, right] = [right, down]\n3.1.2.10\nFinite state machines\nAccording to Wikipedia, a deterministic finite state machine is a quintuple pΣ, S, s0, δ, Fq,\nwhere\n1. Σ is a finite non-empty set of symbols, called the input alphabet,\n2. S is a finite, non-empty set, called the state set,\n3. δ: Σ ˆ S N S is a function, called the state-transition function, and\n\n3.1. MONOIDS\n4. s0 P S is an element, called the initial state,\n5. F D S is a subset, called the set of final states.\nIn this book we will not worry about the initial state and the set of final states,\nconcerning ourselves more with the interaction via δ of the alphabet Σ on the set S of\nstates.\nFigure 3.1:\nA finite state machine with alphabet Σ \" ta, bu and state set S \"\ntState 0, State 1, State 2u. If pressed, we will make State 0 the initial state and {State\n2} the set of final states.\nThe following proposition expresses the notion of finite state automata in terms of\nfree monoids and their actions on finite sets.\nProposition 3.1.2.11. Let Σ, S be finite non-empty sets. Giving a function δ: ΣˆS N\nS is equivalent to giving an action of the free monoid ListpΣq on S.\nProof. By Definition 3.1.2.1, we know that function ε: ListpΣq ˆ S N S constitutes an\naction of the monoid ListpΣq on the set S if and only if, for all s P S we have εpr s, sq \" s,\nand for any two elements m, m1 P ListpΣq we have εpm, εpm1, sqq \" εpm ‹ m1, sq, where\nm ‹ m1 is the concatenation of lists. Let\nA \" tε: ListpΣq ˆ S N S | ε constitutes an actionu.\nWe need to prove that there is an isomorphism of sets\nφ: A -\nYN HomSetpΣ ˆ S, Sq.\nGiven an element ε: ListpΣqˆS N S in A, define φpεq on an element pσ, sq P ΣˆS by\nφpεqpσ, sq :\" εprσs, sq, where rσs is the one-element list. We now define ψ: HomSetpΣ ˆ\nS, Sq N A.\nGiven an element f P HomSetpΣ ˆ S, Sq, define ψpfq: ListpΣq ˆ S N S on a pair\npL, sq P ListpΣq ˆ S, where L \" rε1, . . . , εns as follows. By induction, if n \" 0, put\nψpfqpL, sq \" s; if n e 1, let L1 \" rε1, . . . , εn 1s and put ψpfqpL, sq \" ψpfqpL1, fpεn, sqq.\nOne checks easily that ψpfq satisfies the two rules above, making it an action of ListpΣq\non S. It is also easy to check that φ and ψ are mutually inverse, completing the proof.\n□\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nWe sum up the idea of this section as follows:\nSlogan 3.1.2.12.\n\" A finite state machine is an action of a free monoid on a finite set. \"\nExercise 3.1.2.13. Consider the functions φ and ψ above.\na.) Show that for any f : Σ ˆ S N S, the map ψpfq: ListpΣq ˆ S N S constitutes an\naction.\nb.) Show that φ and ψ are mutually inverse functions (i.e. φ ψ \" idHompΣˆS,Sq and\nψ φ \" idA.)\n♦\n3.1.3\nMonoid action tables\nLet M be a monoid generated by the set G \" tg1, . . . , gmu, and with some relations,\nand suppose that α: M ˆ S N S is an action of M on a set S \" ts1, . . . , snu. We can\nrepresent the action α using an action table whose columns are the elements of G and\nwhose rows are the elements of S. In each cell prow, colq, where row P S and col P G,\nwe put the element αpcol, rowq P S.\nExample 3.1.3.1 (Action table). If Σ and S are the sets from Figure 3.1, the displayed\naction of ListpΣq on S would be given by the action table\nAction from 3.1\nID\na\nb\nState 0\nState 1\nState 2\nState 1\nState 2\nState 1\nState 2\nState 0\nState 0\n(3.2)\nExample 3.1.3.2 (Multiplication action table). Every monoid acts on itself by its multi-\nplication formula, M ˆM N M. If G is a generating set for M, we can write the elements\nof G as the columns and the elements of M as rows, and call this a multiplication table.\nFor example, let pN, 1, q denote the multiplicative monoid of natural numbers. The\nmultiplication table is as follows:\nMultiplication of natural numbers\nN\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n...\n...\n...\n...\n...\n...\n...\n...\n(3.3)\n\n3.1. MONOIDS\nTry to understand what is meant by this: \"applying column 2 and then column 2 returns\nthe same thing as applying column 4.\"\nIn the above table, we were implicitly taking every element of N as a generator (since\nwe had a column for every natural number).\nIn fact, there is a smallest generating\nset for the monoid pN, 1, q, so that every element of the monoid is a product of some\ncombination of these generators, namely the primes and 0.\nMultiplication of natural numbers\nN\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n...\n...\n...\n...\n...\n...\n...\n...\nExercise 3.1.3.3. Let N be the additive monoid of natural numbers, let S \" t0, 1, 2, . . . , 11u,\nand let : NˆS N S be the action given in Example 3.1.2.3. Using a nice small generating\nset for the monoid, write out the corresponding action table.\n♦\n3.1.4\nMonoid homomorphisms\nA monoid pM, e, ‹q involves a set, an identity element, and a multiplication formula. For\ntwo monoids to be comparable, their sets, their identity elements, and their multiplication\nformulas should be appropriately comparable. For example the additive monoids N and\nZ should be comparable because N D Z is a subset, the identity elements in both cases\nare the same e \" 0, and the multiplication formulas are both integer addition.\nDefinition 3.1.4.1. Let M :\" pM, e, ‹q and M1 :\" pM 1, e1, ‹1q be monoids. A monoid\nhomomorphism f from M to M1, denoted f : M N M1, is a function f : M N M 1\nsatisfying two conditions:\n- fpeq \" e1, and\n- fpm1 ‹ m2q \" fpm1q ‹1 fpm2q, for all m1, m2 P M.\nThe set of monoid homomorphisms from M to M1 is denoted HomMonpM, M1q.\nExample 3.1.4.2 (From N to Z). As stated above, the inclusion map i: N N Z induces a\nmonoid homomorphism pN, 0, `q N pZ, 0, `q because ip0q \" 0 and ipn1 ` n2q \" ipn1q `\nipn2q.\nLet i5 : N N Z denote the function i5pnq \" 5 n, so i5p4q \" 20. This is also a monoid\nhomomorphism because i5p0q \" 5 0 \" 0 and i5pn1`n2q \" 5 pn1`n2q \" 5 n1`5 n2 \"\ni5pn1q ` i5pn2q.\nApplication 3.1.4.3. Let R \" ta, c, g, uu and let T \" R3, the set of triplets in R. Let\nR \" ListpRq be the free monoid on R and let T \" ListpTq denote the free monoid on\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nT. There is a monoid homomorphism F : T N R given by sending t \" pr1, r2, r3q to the\nlist rr1, r2, r3s. 5\nIf A be the set of amino acids and A \" ListpAq the free monoid on A, the process\nof translation gives a monoid homomorphism G: T N A, turning a list of RNA triplets\ninto a polypeptide. But how do we go from a list of RNA nucleotides to a polypeptide?\nThe answer is that there is no good way to do this mathematically. So what is going\nwrong?\nThe answer is that there should not be a monoid homomorphism R N A because not\nall sequences of nucleotides produce a polypeptide; for example if the sequence has only\ntwo elements, it does not code for a polypeptide. There are several possible remedies to\nthis problem. One is to take the image of F, which is a submonoid R1 D R. It is not\nhard to see that there is a monoid homomorphism F 1 : R1 N T , and we can compose it\nwith G to get our desired monoid homomorphism G F 1 : R1 N A. 6\n♦♦\nExample 3.1.4.4. Given any monoids M there is a unique monoid homomorphism from\nM to the trivial monoid 1 (see Example 3.1.1.10). There is also a unique homomorphism\n1 N M. These facts together have an upshot: between any two monoids M and M1 we\ncan always construct a homomorphism\nM\n!\nYYYN 1\n!\nYYYN M1\nwhich we call the trivial homomorphism M N M1. A morphism M N M1 that is not\ntrivial is called a nontrivial homomorphism.\nProposition 3.1.4.5. Let M \" pZ, 0, `q and M1 \" pN, 0, `q. The only monoid homo-\nmorphism f : M N M1 sends every element m P Z to 0 P N.\nProof. Let f : M N M1 be a monoid homomorphism, and let n \" fp1q and n1 \" fp 1q\nin N. Then we know that since 0 \" 1`p 1q in Z we must have 0 \" fp0q \" fp1`p 1qq \"\nfp1q ` fp 1q \" n ` n1 P N. But if n e 1 then this is impossible, so n \" 0. Similarly\nn1 \" 0. Any element m P Z can be written m \" 1`1` `1 or as m \" 1` 1` ` 1,\nand it is easy to see that fp1q ` fp1q ` ` fp1q \" 0 \" fp 1q ` fp 1q ` ` fp 1q.\nTherefore, fpmq \" 0 for all m P Z.\n□\nExercise 3.1.4.6. For any m P N let im : N N Z be the function impnq \" m n. All\nsuch functions are monoid homomorphisms pN, 0, `q N pZ, 0, `q. Do any monoid homo-\nmorphisms pN, 0, `q N pZ, 0, `q not come in this way? For example, what about using\nn ÞN 5 n 1 or n ÞN n2, or some other function?\n♦\nExercise 3.1.4.7. Let M :\" pN, 0, `q be the additive monoid of natural numbers, let N \"\npRe0, 0, `q be the additive monoid of nonnegative real numbers, and let P :\" pRa0, 1, q\nbe the multiplicitive monoid of positive real numbers. Can you think of any nontrivial\nmonoid homomorphisms of the following sorts:\nM N N,\nM N P,\nN N P,\nN N M,\nP N N?\n♦\n5More\nprecisely,\nthe\nmonoid\nhomomorphism\nF\nsends\na\nlist\nrt1, t2, . . . , tns\nto\nthe\nlist\nrr1,1, r1,2, r1,3, r2,1, r2,2, r2,3, . . . , rn,1, rn,2, rn,3s, where for each 0 d i d n we have ti \" pri,1, ri,2, ri,3q.\n6Adding stop-codons to the mix we can handle more of R, e.g. sequences that don't have a multiple-\nof-three many nucleotides.\n\n3.1. MONOIDS\n3.1.4.8\nHomomorphisms from free monoids\nRecall that pN, 0, `q is the free monoid on one generator. It turns out that for any other\nmonoid M \" pM, e, ‹q, the set of monoid homomorphisms N N M is in bijection with\nthe set M. This is a special case (in which G is a set with one element) of the following\nproposition.\nProposition 3.1.4.9. Let G be a set, let FpGq :\" pListpGq, r s, ``q be the free monoid\non G, and let M :\" pM, e, ‹q be any monoid. There is a natural bijection\nHomMonpFpGq, Mq -\nYN HomSetpG, Mq.\nProof. We provide a function φ: HomMonpFpGq, Mq N HomSetpG, Mq and a function\nψ: HomSetpG, Mq N HomMonpFpGq, Mq and show that they are mutually inverse. Let\nus first construct φ. Given a monoid homomorphism f : FpGq N M, we need to provide\nφpfq: G N M. Given any g P G we define φpfqpgq :\" fprgsq.\nNow let us construct ψ. Given p: G N M, we need to provide ψppq: ListpGq N M\nsuch that ψppq is a monoid homomorphism. For a list L \" rg1, . . . , gns P ListpGq, define\nψppqpLq :\" ppg1q ‹ ‹ ppgnq P M. In particular, ψppqpr sq \" e. It is not hard to see\nthat this is a monoid homomorphism. It is also easy to see that φ ψppq \" p for all\np P HomSetpG, Mq. We show that ψ φpfq \" f for all f P HomMonpFpGq, Mq. Choose\nL \" rg1, . . . , gns P ListpGq. Then\nψpφfqpLq \" pφfqpg1q ‹ ‹ pφfqpgnq \" frg1s ‹ ‹ frgns \" fprg1, . . . , gnsq \" fpLq.\n□\nExercise 3.1.4.10. Let G \" ta, bu, let M :\" pM, e, ‹q be any monoid, and let f : G N M\nbe given by fpaq \" m and fpbq \" n, where m, n P M.\nIf ψ: HomSetpG, Mq N\nHomMonpFpGq, Mq is the function from the proof of Proposition 3.1.4.9 and L \"\nra, a, b, a, bs, what is ψpfqpLq ?\n♦\n3.1.4.11\nRestriction of scalars\nA monoid homomorphism f : M N M 1 (see Definition 3.1.4.1) ensures that the elements\nof M have a reasonable interpretation in M 1; they act the same way over in M 1 as\nthey did back home in M. If we have such a homomorphism f and we have an action\nα: M 1 ˆ S N S of M 1 on a set S, then we have a method for allowing M to act on S as\nwell. Namely, we take an element of M, send it over to M 1, and act on S. In terms of\nfunctions, we compose α with the function f ˆ idS : M ˆ S N M 1 ˆ S, to get a function\nwe'll denote\n∆fpαq: M ˆ S N S.\nAfter Proposition 3.1.4.12 we will know that ∆fpαq is indeed a monoid action, and we\nsay that it is given by restriction of scalars along f.\nProposition 3.1.4.12. Let M :\" pM, e, ‹q and M1 :\" pM 1, e1, ‹1q be monoids, f : M N\nM1 a monoid homomorphism, S a set, and suppose that α: M 1 ˆ S N S is an action of\nM1 on S. Then ∆fpαq: M ˆ S N S, defined as above, is a monoid action as well.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nProof. Refer to Remark 3.1.2.2; we assume α is a monoid action and want to show that\n∆fpαq is too. We have ∆fpαqpe, sq \" αpfpeq, sq \" αpe1, sq \" s. We also have\n∆fpαqpm, ∆fpαqpn, sqq \" αpfpmq, αpfpnq, sqq \" αpfpmq ‹1 fpnq, sq\n\" αpfpm ‹ nq, sq\n\" ∆fpαqpm ‹ n, sq.\n□\nExample 3.1.4.13. Let N and Z denote the additive monoids of natural numbers and\nintegers, respectively, and let i: N N Z be the inclusion, which we saw in Example\n3.1.4.2 is a monoid homomorphism. There is an action α: Z ˆ R N R of the monoid\nZ on the set R of real numbers, given by αpn, xq \" n ` x. Clearly, this action works\njust as well if we restrict our scalars to N D Z, allowing ourselves only to add natural\nnumbers to reals. The action ∆iα: N ˆ R N R is given on pn, xq P N ˆ R by ∆iαpn, xq \"\nαpipnq, xq \" αpn, xq \" n ` x, just as expected.\nExample 3.1.4.14. Suppose that V is a complex vector space. In particular, this means\nthat the monoid C of complex numbers (under multiplication) acts on the elements of V .\nIf i: R N C is the inclusion of the real line inside C, then i is a monoid homomorphism.\nRestriction of scalars in the above sense turns V into a real vector space, so the name\n\"restriction of scalars\" is apt.\nExercise 3.1.4.15. Let N be the free monoid on one generator, let Σ \" ta, bu, and let\nS \" tState 0, State 1, State 2u. Consider the map of monoids f : N N ListpΣq given by\nsending 1 ÞN ra, b, bs. The monoid action α: ListpΣq ˆ S N S given in Example 3.1.3.1\ncan be transformed by restriction of scalars along f to an action ∆fpαq of N on S. Write\ndown its action table.\n♦\n3.2\nGroups\nGroups are monoids in which every element has an inverse. If we think of these structures\nin terms of how they act on sets, the difference between groups and monoids is that the\naction of every group element can be undone. One way of thinking about groups is in\nterms of symmetries. For example, the rotations and reflections of a square form a group.\nAnother way to think of the difference between monoids and groups is in terms of\ntime. Monoids are likely useful in thinking about diffusion, in which time plays a role and\nthings cannot be undone. Groups are more likely useful in thinking about mechanics,\nwhere actions are time-reversible.\n3.2.1\nDefinition and examples\nDefinition 3.2.1.1. Let pM, e, ‹q be a monoid. An element m P M is said to have an\ninverse if there exists an m1 P M such that mm1 \" e and m1m \" e. A group is a monoid\npM, e, ‹q in which every element m P M has an inverse.\nProposition 3.2.1.2. Suppose that M :\" pM, e, ‹q is a monoid and let m P M be an\nelement. Then m has at most one inverse. 7\n7If M is a group then every element m has exactly one inverse.\n\n3.2. GROUPS\nProof. Suppose that both m1 and m2 are inverses of m; we want to show that m1 \" m2.\nThis follows by the associative law for monoids:\nm1 \" m1pmm2q \" pm1mqm2 \" m2.\n□\nExample 3.2.1.3. The additive monoid pN, 0, `q is not a group because none of its ele-\nments are invertible, except for 0. However, the monoid of integers pZ, 0, `q is a group.\nThe monoid of clock positions from Example 3.1.1.25 is also a group. For example the\ninverse of Q5 is Q7 because Q5 ‹ Q7 \" e \" Q7 ‹ Q5.\nExample 3.2.1.4. Consider a square centered at the origin in R2. It has rotational and\nmirror symmetries. There are eight of these, which we denote\nte, ρ, ρ2, ρ3, φ, φρ, φρ2, φρ3u,\nwhere ρ stands for 90 counterclockwise rotation and φ stands for horizontal-flip (across\nthe vertical axis). So relations include ρ4 \" e, φ2 \" e, and ρ3φ \" φρ.\nExample 3.2.1.5. The set of 3ˆ3 matrices can be given the structure of a monoid, where\nthe identity element is the 3 ˆ 3 identity matrix, the multiplication is matrix multiplica-\ntion. The subset of invertible matrices forms a group, called the general linear group of\ndimension 3 and denoted GL3. Inside of GL3 is the so-called orthogonal group, denoted\nO3, of matrices M such that M 1 \" M J. These matrices correspond to symmetries of\nthe sphere centered at the origin.\nAnother interesting group is the Euclidean group Ep3q which consists of all isometries\nof R3, i.e. all functions R3 N R3 that preserve distances.\nApplication 3.2.1.6. In crystallography one is often concerned with the symmetries that\narise in the arrangement A of atoms in a molecule. To think about symmetries in terms of\ngroups, we first define an atom-arrangement to be a finite subset i: A D R3. A symmetry\nin this case is an isometry of R3 (see Example 3.2.1.5), say f : R3 N R3 such that there\nexists a dotted arrow making the diagram below commute:\nA\n/\ni\nA\ni\nR3\nf\n/ R3\nThat is, it's an isometry of R3 such that each atom of A is sent to a position currently\noccupied by an atom of A. It is not hard to show that the set of such isometries forms\na group, called the space group of the crystal.\n♦♦\nExercise 3.2.1.7. Let S be a finite set. A permutation of S is an isomorphism f : S\n-\nYN S.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\na.) Come up with an identity, and a multiplication formula, such that the set of permu-\ntations of S forms a monoid.\nb.) Is it a group?\n♦\nExercise 3.2.1.8. In Exercise 3.1.1.27 you classified the cyclic monoids. Which of them\nare groups?\n♦\nDefinition 3.2.1.9 (Group action). Let pG, e, ‹q be a group and S a set. An action of\nG on S is a function u: G ˆ S N S such that for all s P S and g, g1 P G, we have\n- e u s \" s and\n- g u pg1 u sq \" pg ‹ g1q u s.\nIn other words, considering G as a monoid, it is an action in the sense of Definition\n3.1.2.1.\nExample 3.2.1.10. When a group acts on a set, it has the character of symmetry. For\nexample, consider the group whose elements are angles θ. This group may be denoted\nUp1q and is often formalized as the unit circle in C of complex numbers z \" a ` bi\nsuch that |z| \" a2 ` b2 \" 1. The set of such points is given the structure of a group\npUp1q, e, ‹q by defining the identity element to be e :\" 1 ` 0i and the group law to be\ncomplex multiplication. But for those unfamiliar with complex numbers, this is simply\nangle addition where we understand that 360 \" 0 . If θ1 \" 190 and θ2 \" 278 , then\nθ1 ‹ θ2 \" 468 \" 108 . In the language of complex numbers, z \" eiθ.\nThe group Up1q acts on any set that we can picture as having rotational symmetry\nabout a fixed axis, such as the earth around the north-south axis. We will define S \"\ntpx, y, zq P R3 | x2 ` y2 ` z2 \" 1u, the unit sphere, and understand the rotational action\nof Up1q on S.\nWe first show that Up1q acts on R3 by θ u px, y, zq \" px cos θ ` y sin θ, x sin θ `\ny cos θ, zq, or with matrix notation as\nθ u px, y, zq :\" px, y, zq\n\ncospθq\nsinpθq\nsinpθq\ncospθq\n\n‚\nTrigonometric identities ensure that this is indeed an action.\n\n3.2. GROUPS\nIn terms of action tables, we would need infinitely many columns to express this\naction. Here is a sample\nAction of Up1q on R3\nR3\nθ \" 45\nθ \" 90\nθ \" 100\n(0,0,0)\n(0,0,0)\n(0,0,0)\n(0,0,0)\n(1,0,0)\n(.71,.71,0)\n(0,1,0)\n(-.17,.98,0)\n(0,1,-4.2)\n(-.71,.71,-4.2)\n(-1,0,-4.2)\n(-.98,-.17,-4.2)\n(3,4,2)\n(4.95,.71,2)\n(-4,3,2)\n(3.42,-3.65,2)\n...\n...\n...\n...\nFinally, we are looking to see that the action preserves length so that if px, y, zq P S\nthen θ u px, y, zq P S; this way we will have confirmed that Up1q indeed acts on S. The\ncalculation begins by assuming x2 ` y2 ` z2 \" 1 and checks\npx cos θ ` y sin θq2 ` p x sin θ ` y cos θq2 ` z2 \" x2 ` y2 ` z2 \" 1.\nExercise 3.2.1.11. Let X be a set and consider the group of permutations of X (see\nExercise 3.2.1.7), which we will denote ΣX. Find a canonical action of ΣX on X.\n♦\nDefinition 3.2.1.12. Let G be a group acting on a set X. For any point x P X, the\norbit of x, denoted Gx, is the set\nGx :\" tx1 P X | Dg P G such that gx \" x1u.\nApplication 3.2.1.13. Let S be the surface of the earth, understood as a sphere, and let\nG \" Up1q be the group of angles acting on S as in Example 3.2.1.10. The orbit of any\npoint p \" px, y, zq P S is the set of points on the same latitude line as p.\nOne may also consider a small band around the earth, i.e. the set A \" tpx, y, zq | 1.0 d\nx2 ` y2 ` z2 d 1.05u. The action of Up1q u S extends to an action Up1q u A. The\norbits are latitude-lines-at-altitude. A simplifying assumption in climatology may be\ngiven by assuming that Up1q acts on all currents in the atmosphere in an appropriate\nsense. That way, instead of considering movement within the whole space A, we only\nallow movement that behaves the same way throughout each orbit of the group action.\n♦♦\nExercise 3.2.1.14.\na.) Consider the Up1q action on R3 given in Example 3.2.1.10. Describe the set of orbits\nof this action.\nb.) What are the orbits of the action of the permutation group Σt1,2,3u on the set t1, 2, 3u?\n(See Exercise 3.2.1.11.)\n♦\nExercise 3.2.1.15. Let G be a group and X a set on which G acts by u: G ˆ X N X.\nIs \"being in the same orbit\" an equivalence relation on X?\n♦\nDefinition 3.2.1.16. Let G and G1 be groups. A group homomorphism f : G N G1 is\ndefined to be a monoid homomorphism G N G1, where G and G1 are being regarded as\nmonoids in accordance with Definition 3.2.1.1.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n3.3\nGraphs\nIn this course, unless otherwise specified, whenever we speak of graphs we are not talking\nabout curves in the plane, such as parabolas, or pictures of functions generally. We are\nspeaking of systems of vertices and arrows.\nWe will take our graphs to be directed, meaning that every arrow points from a vertex\nto a vertex; rather than merely connecting vertices, arrows will have direction. If a and\nb are vertices, there can be many arrows from a to b, or none at all. There can be arrows\nfrom a to itself. Here is the formal definition in terms of sets and functions.\n3.3.1\nDefinition and examples\nDefinition 3.3.1.1. A graph G consists of a sequence G :\" pV, A, src, tgtq where\n- V is a set, called the set of vertices of G (singular:vertex),\n- A is a set, called the set of arrows of G,\n- src: A N V is a function, called the source function for G, and\n- tgt: A N V is a function, called the target function for G.\nGiven an arrow a P A we refer to srcpaq as the source vertex of a and to tgtpaq as the\ntarget vertex of a.\nTo draw a graph, first draw a dot for every element of V . Then for every element\na P A, draw an arrow connecting dot srcpaq to dot tgtpaq.\nExample 3.3.1.2 (Graph). Here is a picture of a graph G \" pV, A, src, tgtq:\nG :\"\n‚v\nf\n/ ‚w\nh\n=\ng\n#\n‚x\n‚y\ni\n\nj\n#\n‚z\nk\na\n(3.4)\nWe have V \" tv, w, x, y, zu and A \" tf, g, h, i, j, ku. The source and target functions\nsrc, tgt: A N V can be captured in the table to the left below:\nA\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\ni\ny\ny\nj\ny\nz\nk\nz\ny\nV\nv\nw\nx\ny\nz\nIn fact, all of the data of the graph G is captured in the two tables above--together they\ntell us the sets A and V and the functions src and tgt.\n\n3.3. GRAPHS\nExample 3.3.1.3. Every olog has an underlying graph. The additional information in an\nolog has to do with which pairs of paths are declared equivalent, as well as text that has\ncertain English-readability rules.\nExercise 3.3.1.4. a.) Draw the graph corresponding to the following tables:\nA\nsrc\ntgt\nf\nv\nw\ng\nv\nw\nh\nv\nw\ni\nx\nw\nj\nz\nw\nk\nz\nz\nV\nu\nv\nw\nx\ny\nz\nb.) Write down two tables, as above, corresponding to the following graph:\na‚\n/ b‚\n/\nc‚\n_\n/ d‚\ne‚\nf‚\no\n/ g‚\nB\n♦\nExercise 3.3.1.5. Let A \" t1, 2, 3, 4, 5u and B \" ta, b, cu. Draw them and choose an\narbitrary function f : A N B and draw it.\nLet A \\ B be the coproduct of A and\nB (Definition 2.4.2.1) and let A\ni1\nYN A \\ B\ni2\nÐY B be the two inclusions.\nConsider\nthe two functions src, tgt: A N A \\ B, where src \" i1 and tgt is the composition\nA\nfYN B\ni2\nYN A \\ B. Draw the associated graph pA \\ B, A, src, tgtq.\n♦\nExercise 3.3.1.6.\na.) Let V be a set. Suppose we just draw the elements of V as vertices and have no\narrows between them. Is this a graph?\nb.) Given V , is there any other \"canonical\" or somehow automatic non-random proce-\ndure for generating a graph with those vertices?\n♦\nExample 3.3.1.7. Recall from Construction 2.5.2.5 the notion of bipartite graph, which\nwe defined to be a span (i.e. pair of functions, see Definition 2.5.2.1) A\nfÐY R\ngYN B. Now\nthat we have a formal definition of graph, we might hope that bipartite graphs fit in,\nand they do. Let V \" A \\ B and let i: A N V and j : B N V be the inclusions. Let\nsrc \" i f : R N V and let tgt \" j g: R N V be the composites.\nA\ni\n\nR\nsrc\n'\ntgt\nf\n?\ng\n\nV\nB\nj\n>\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nThen pV, R, src, tgtq is a graph that would be drawn exactly as we specified the drawing\nof spans in Construction 2.5.2.5.\nExample 3.3.1.8. Let n P N be a natural number. The chain graph of length n, denoted\nrns is the graph depicted here:\n0‚\n/ 1‚\n/\n/ n‚\nIn general rns has n arrows and n ` 1 vertices. In particular, when n \" 0 we have that\nr0s is the graph consisting of a single vertex and no arrows.\nExample 3.3.1.9. Let G \" pV, A, src, tgtq be a graph; we want to spread it out over\ndiscrete time, so that each arrow does not occur within a given time-slice but instead\nover a quantum unit of time.\nLet N \" pN, N, n ÞN n, n ÞN n ` 1q be the graph depicted\n0‚\n/ 1‚\n/ 2‚\n/\nWhen we get to limits in a category, we will understand that products can be taken in\nthe category of graphs (see Example 4.5.1.5), and N ˆ G will make sense. For now, we\nconstruct it by hand.\nLet TpGq \" pV ˆ N, A ˆ N, src1, tgt1q be a new graph, where for a P A and n P N we\nhave src1pa, nq :\" psrcpaq, nq and tgt1pa, nq \" ptgtpaq, n ` 1q. This may be a bit much to\nswallow, so try to simply understand what is being done in the following example.\nLet G be the graph drawn below\na‚\nf\n\ng\nb‚\nThen TpGq will be the graph\na0‚\nf0\n/\ng0\n\na1‚\nf1\n/\ng1\n\na2‚\nf2\n/\ng2\n\nb0‚\nb1‚\nb2‚\n\nAs you can see, f-arrows still take a's to a's and g-arrows still take a's to b's, but they\nalways march forward in time.\nExercise 3.3.1.10. Let G be the graph depicted below:\na‚\nw\n%\nx\n:\nb‚\ny\ne\nz\nd\nDraw (using ellipses \" \" if necessary) the graph TpGq defined in Example 3.3.1.9.\n♦\n\n3.3. GRAPHS\nExercise 3.3.1.11. Consider the infinite graph G \" pV, A, src, tgtq depicted below,\n...\n...\n...\np0, 2q\n/\nO\np1, 2q\n/\nO\np2, 2q\n/\nO\n\np0, 1q\n/\nO\np1, 1q\n/\nO\np2, 1q\n/\nO\n\np0, 0q\n/\nO\np1, 0q\n/\nO\np2, 0q\n/\nO\n\na.) Write down the sets A and V .\nb.) What are the source and target function A N V ?\n♦\nExercise 3.3.1.12. A graph is a pair of functions A N V . This sets up the notion of\nequalizer and coequalizer (see Definitions 2.5.3.1 and 2.6.3.1).\na.) What feature of a graph is captured by the equalizer of its source and target func-\ntions?\nb.) What feature of a graph is captured by the coequalizer of its source and target\nfunctions?\n♦\n3.3.2\nPaths in a graph\nWe all know what a path in a graph is, especially if we understand that a path must\nalways follow the direction of arrows. The following definition makes this idea precise.\nIn particular, one can have paths of any finite length n P N, even length 0 or 1. Also,\nwe want to be able to talk about the source vertex and target vertex of a path, as well\nas concatenation of paths.\nDefinition 3.3.2.1. Let G \" pV, A, src, tgtq be a graph.\nA path of length n in G,\ndenoted p P Pathpnq\nG\nis a head-to-tail sequence\np \" pv0\na1\nYN v1\na2\nYN v2\na3\nYN . . . an\nYYN vnq\n(3.5)\nof arrows in G, which we denote by v0a1a2 . . . an. In particular we have canonical iso-\nmorphisms Pathp1q\nG - A and Pathp0q\nG - V ; we refer to the path of length 0 on vertex v\nas the trivial path on v and denote it simply by v. We denote by PathG the set of paths\nin G,\nPathG :\"\nd\nnPN\nPathpnq\nG .\nEvery path p P PathG has a source vertex and a target vertex, and we may denote these\nby src, tgt: PathG N V . If p is a path with srcppq \" v and tgtppq \" w, we may denote\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nit by p: v N w. Given two vertices v, w P V , we write PathGpv, wq to denote the set of\nall paths p: v N w.\nThere is a concatenation operation on paths. Given a path p: v N w and q: w N x,\nwe define the concatenation, denoted pq: v N x in the obvious way. If p \" va1, a2 . . . am\nand q \" wb1b2 . . . bn then pq \" va1 . . . amb1 . . . bn. In particular, if p (resp. r) is the\ntrivial path on vertex v (resp. vertex w) then for any path q: v N w, we have pq \" q\n(resp. qr \" q).\nExample 3.3.2.2. In Diagram (3.4), page 86, there are no paths from v to y, one path\n(f) from v to w, two paths (fg and fh) from v to x, and infinitely many paths\ntyip1pjkqq1 ipnpjkqqn | n, p1, q1, . . . , pn, qn P Nu\nfrom y to y. There are other paths as well, including the five trivial paths.\nExercise 3.3.2.3. How many paths are there in the following graph?\n1‚\nf\n/ 2‚\ng\n/ 3‚\n♦\nExercise 3.3.2.4. Let G be a graph and consider the set PathG of paths in G. Suppose\nsomeone claimed that there is a monoid structure on the set PathG, where the multipli-\ncation formula is given by concatenation of paths. Are they correct? Why or why not?\nHint: what should be the identity element?\n♦\n3.3.3\nGraph homomorphisms\nA graph pV, A, src, tgtq involves two sets and two functions. For two graphs to be com-\nparable, their two sets and their two functions should be appropriately comparable.\nDefinition 3.3.3.1. Let G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q be graphs. A\ngraph homomorphism f from G to G1, denoted f : G N G1, consists of two functions\nf0 : V N V 1 and f1 : A N A1 such that the two diagrams below commute:\nA\nf1\n/\nsrc\n\nA1\nsrc1\n\nV\nf0\n/ V 1\nA\nf1\n/\ntgt\n\nA1\ntgt1\n\nV\nf0\n/ V 1\n(3.6)\nRemark 3.3.3.2. The above conditions (3.6) may look abstruse at first, but they encode\na very important idea, roughly stated \"arrows are bound to their vertices\". Under a map\nof graphs G N G1 , one cannot flippantly send an arrow of G any old arrow of G1: it\nmust still connect the vertices it connected before. Below is an example of a mapping\nthat does not respect this condition: a connects 1 and 2 before, but not after:\n1‚\na\n/ 2‚\n1ÞN11,2ÞN21,aÞNa1\n/\n‚\n‚\na1\n/ 31\n‚\nThe commutativity of the diagrams in (3.6) is exactly what is needed to ensure that\narrows are handled in the expected way by a proposed graph homomorphism.\n\n3.3. GRAPHS\nExample 3.3.3.3 (Graph homomorphism). Let G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q\nbe the graphs drawn to the left and right (respectively) below:\n1‚\na\n/\nd\n\nc\n\n2‚\nb\n/ 3‚\n4‚\n5‚\ne\n/ 6‚\n1 ÞN 11, 2 ÞN 21,\n3 ÞN 11, 4 ÞN 41,\n5 ÞN 51, 6 ÞN 51\n/\n‚\nw\n/\ny\n‚\nx\no\n‚\n‚\nz\n\n(3.7)\nThe colors indicate our choice of function f0 : V N V 1. Given that choice, condition (3.6)\nimposes in this case that there is a unique choice of graph homomorphism f : G N G1.\nExercise 3.3.3.4.\na.) Where are a, b, c, d, e sent under f1 : A N A1 in Diagram (3.7)?\nb.) Choose a couple elements of A and check that they behave as specified by Diagram\n(3.6).\n♦\nExercise 3.3.3.5. Let G be a graph, let n P N be a natural number, and let rns be the\nchain graph of length n, as in Example 3.3.1.8. Is a path of length n in G the same thing\nas a graph homomorphism rns N G, or are there subtle differences? More precisely, is\nthere always an isomorphism between the set of graph homomorphisms rns N G and the\nset Pathpnq\nG\nof length-n paths in G?\n♦\nExercise 3.3.3.6. Given a morphism of graphs f : G N G1, there an induced function\nPathpfq: PathpGq N PathpG1q.\na.) Is it the case that for every n P N, the function Pathpfq carries PathpnqpGq to\nPathpnqpG1q, or can path lengths change in this process?\nb.) Suppose that f0 and f1 are injective (meaning no two distinct vertices in G are sent\nto the same vertex (respectively for arrows) under f). Does this imply that Pathpfq\nis also injective (meaning no two distinct paths are sent to the same path under f)?\nc.) Suppose that f0 and f1 are surjective (meaning every vertex in G1 and every arrow\nin G1 is in the image of f). Does this imply that Pathpfq is also surjective? Hint: at\nleast one of the answers to these three questions is \"no\".\n♦\nExercise 3.3.3.7. Given a graph pV, A, src, tgtq, let i: A N V ˆV be function guaranteed\nby the universal property for products, as applied to src, tgt: A N V . One might hope\nto summarize Condition (3.6) for graph homomorphisms by the commutativity of the\nsingle square\nA\nf1\n/\ni\n\nA1\ni1\n\nV ˆ V\nf0ˆf0\n/ V 1 ˆ V 1.\n(3.8)\nIs the commutativity of the diagram in (3.8) indeed equivalent to the commutativity of\nthe diagrams in (3.6)?\n♦\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n3.3.3.8\nBinary relations and graphs\nDefinition 3.3.3.9. Let X be a set. A binary relation on X is a subset R D X ˆ X.\nIf X \" N is the set of integers, then the usual d defines a relation on X: given\npm, nq P N ˆ N, we put pm, nq P R iffm d n. As a table it might be written as to the\nleft\nm d n\nm\nn\n...\n...\nn \" 5m\nm\nn\n...\n...\n|n m| d 1\nm\nn\n...\n...\n(3.9)\nThe middle table is the relation tpm, nq P N ˆ N | n \" 5mu D N ˆ N and the right-hand\ntable is the relation tpm, nq P N ˆ N | |n m| d 1u D N ˆ N.\nExercise 3.3.3.10. A relation on R is a subset of RˆR, and one can indicate such a subset\nof the plane by shading. Choose an error bound ε a 0 and draw the relation one might\nrefer to as \"ε-approximation\". To say it another way, draw the relation \"x is within ε of\ny\".\n♦\nExercise 3.3.3.11 (Binary relations to graphs). a.) If R D SˆS is a binary relation, find\na natural way to make a graph out of it, having vertices S.\nb.) What is the set A of arrows?\nc.) What are the source and target functions src, tgt: A N S?\nd.) Take the left-hand table in (3.9) and consider its first 7 rows (i.e. forget the\n...). Draw\nthe corresponding graph (do you see a tetrahedron?).\ne.) Do the same for the right-hand table.\n♦\nExercise 3.3.3.12 (Graphs to binary relations).\na.) If pV, A, src, tgtq is a graph, find a natural way to make a binary relation R D V ˆ V\nout of it.\nb.) Take the left-hand graph G from (3.7) and write out the corresponding binary relation\nin table form.\n♦\nExercise 3.3.3.13 (Going around the loops). a.) Given a binary relation R D S ˆS, you\nknow from Exercise 3.3.3.11 how to construct a graph out of it, and from Exercise\n3.3.3.12 how to make a new binary relation out of that. How does the resulting\nrelation compare with the original?\n\n3.4. ORDERS\nb.) Given a graph pV, A, src, tgtq, you know from Exercise 3.3.3.12 how to make a new\nbinary relation out of it, and from Exercise 3.3.3.11 how to construct a new graph\nout of that. How does the resulting graph compare with the original?\n♦\n3.4\nOrders\nPeople usually think of certain sets as though they just are ordered, e.g. that an order is\nordained by God. For example the natural numbers just are ordered. The letters in the\nalphabet just are ordered. But in fact we put orders on sets, and some are simply more\ncommonly used in culture. One could order the letters in the alphabet by frequency of\nuse and e would come before a. Given different purposes, we can put different orders\non the same set. For example in Exercise 4.5.1.4 we will give a different ordering on the\nnatural numbers that is useful in elementary number theory.\nIn science, we might order the set of materials in two different ways. In the first, we\nconsider material A to be \"before\" material B if A is an ingredient or part of B, so water\nwould be before concrete. But we could also order materials based on how electrically\nconductive they are, whereby concrete would be before water. This section is about\ndifferent kinds of orders.\n3.4.1\nDefinitions of preorder, partial order, linear order\nDefinition 3.4.1.1. Let S be a set and R D S ˆ S a binary relation on S; if ps, s1q P R\nwe will write s d s1. Then we say that R is a preorder if, for all s, s1, s2 P S we have\nReflexivity: s d s, and\nTransitivity: if s d s1 and s1 d s2, then s d s2.\nWe say that R is a partial order if it is a preorder and, in addition, for all s, s1 P S we\nhave\nAntisymmetry: If s d s1 and s1 d s, then s \" s1.\nWe say that R is a linear order if it is a partial order and, in addition, for all s, s1 P S\nwe have\nComparability: Either s d s1 or s1 d s.\nWe denote such a preorder (or partial order or linear order) by pS, dq.\nExercise 3.4.1.2.\na.) Decide whether the table to the left in Display (3.9) constitutes a linear order.\nb.) Show that neither of the other tables are even preorders.\n♦\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nExample 3.4.1.3 (Partial order not linear order). We will draw an olog for playing cards.\na dia-\nmond\nis\n\"\na heart\nis\n|\na club\nis\n#\na spade\nis\n{\na red\ncard\nis\n)\na black\ncard\nis\nu\na 4 of di-\namonds\nis\n\nis\nO\na card\na black\nqueen\nis\n\nis\nc\na 4\nis\n/\na num-\nbered\ncard\nis\n<\na face\ncard\nis\na\na queen\nis\no\n(3.10)\nWe can put a binary relation on the set of boxes here by saying A d B if there is a\npath A N B. One can see immediately that this is a preorder because length=0 paths\ngive reflexivity and concatenation of paths gives transitivity. To see that it is a partial\norder we only note that there are no loops. But this partial order is not a linear order\nbecause there is no path (in either direction) between, e.g., ⌜a 4 of diamonds⌝and ⌜a\nblack queen⌝, so it violates the comparability condition.\nRemark 3.4.1.4. Note that olog (3.10) in Example 3.4.1.3 is a good olog in the sense that\ngiven any collection of cards (e.g. choose 45 cards at random from each of 7 decks and\nthrow them in a pile), they can be classified according to the boxes of (3.10) such that\nevery arrow indeed constitutes a function (which happens to be injective). For example\nthe arrow ⌜a heart⌝\nis\nYYYN ⌜a red card⌝is a function from the set of chosen hearts to the\nset of chosen red cards.\nExample 3.4.1.5 (Preorder not partial order). Every equivalence relation is a preorder\nbut rarely are they partial orders. For example if S \" t1, 2u and we put R \" S ˆS, then\nthis is an equivalence relation. It is a preorder but not a partial order (because 1 d 2\nand 2 d 1, but 1 % 2, so antisymmetry fails).\nApplication 3.4.1.6. Classically, we think of time as linearly ordered. A nice model is\npR, dq, the usual linear order on the set of real numbers. But according to the theory\nof relativity, there is not actually a single order to the events in the universe. Different\nobservers correctly observe different orders on the set of events, and so in some sense on\ntime itself.\n♦♦\nExample 3.4.1.7 (Finite linear orders). Let n P N be a natural number. Define a linear\norder on the set t0, 1, 2, . . . , nu in the standard way. Pictorially,\nrns :\"\n0‚\n/ 1‚\n/ 2‚\n/\n/ n‚\nEvery finite linear order, i.e. linear order on a finite set, is of the above form. That\nis, though the labels might change, the picture would be the same. We can make this\nprecise when we have a notion of morphism of orders (see Definition 3.4.4.1)\n\n3.4. ORDERS\nExercise 3.4.1.8. Let S \" t1, 2, 3, 4u.\na.) Find a preorder R D S ˆ S such that the set R is as small as possible. Is it a partial\norder? Is it a linear order?\nb.) Find a preorder R1 D S ˆS such that the set R1 is as large as possible. Is it a partial\norder? Is it a linear order?\n♦\nExercise 3.4.1.9.\na.) List all the preorder relations possible on the set t1, 2u.\nb.) For any n P N, how many linear orders exist on the set t1, 2, 3, . . . , nu.\nc.) Does your formula work when n \" 0?\n♦\nRemark 3.4.1.10. We can draw any preorder pS, dq as a graph with vertices S and with\nan arrow a N b if a d b. These are precisely the graphs with the following two properties\nfor any vertices a, b P S:\n1. there is at most one arrow a N b, and\n2. if there is a path from a to b then there is an arrow a N b.\nIf pS, dq is a partial order then the associated graph has an additional \"no loops\" prop-\nerty,\n3. if n P N is an integer with n e 2 then there are no paths of length n that start\nat a and end at a.\nIf pS, dq is a linear order then there is an additional \"comparability\" property,\n4. for any two vertices a, b there is an arrow a N b or an arrow b N a.\nGiven a graph G, we can create a binary relation d on its set S of vertices as follows.\nSay a d b if there is a path in G from a to b. This relation will be reflexive and transitive,\nso it is a preorder. If the graph satisfies Property 3 then the preorder will be a partial\norder, and if the graph also satisfies Property 4 then the partial order will be a linear\norder. Thus graphs give us a nice way to visualize orders.\nSlogan 3.4.1.11.\n\" A graph generates a preorder: v d w if there is a path v N w. This is a\ngreat way to picture a preorder. \"\nExercise 3.4.1.12. Let G \" pV, A, src, tgtq be the graph below.\na‚\n/ b‚\nc‚\n_\n/ d‚\ne‚\nf‚\no\n/ g‚\nB\nIn the corresponding pre-order which of the following are true:\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\na.) a d b?\nb.) a d c?\nc.) c d b?\nd.) b \" c?\ne.) e d f?\nf.) f d d?\n♦\nExercise 3.4.1.13.\na.) Let S \" t1, 2u. The subsets of S form a partial order; draw the associated graph.\nb.) Repeat this for Q \" H, R \" t1u, and T \" t1, 2, 3u.\nc.) Do you see n-dimensional cubes?\n♦\nDefinition 3.4.1.14. Let pS, dq be a preorder. A clique is a subset S1 D S such that\nfor each a, b P S1 one has a d b.\nExercise 3.4.1.15. True or false: a partial order is a preorder that has no cliques. (If\nfalse, is there a \"nearby\" true statement?)\n♦\nExample 3.4.1.16. Let X be a set and R D X ˆ X a relation. For elements x, y P X\nwe will say there is an R-path from x to y if there exists a natural number n P N and\nelements x0, x1, . . . , xn such that\n1. x0 \" x,\n2. xn \" y, and\n3. for all i P N, if 0 d i d n 1 then pxi, xi`1q P R.\nLet R denote the relation where px, yq P R if there exists an R-path from x to y. We call\nR the preorder generated by R. We note some facts about R.\nContainment. If px, yq P R then px, yq P R. That is R D R.\nReflexivity . For all x P X we have px, xq P R.\nTransitivity. For all x, y, z P X, if px, yq P R and py, zq P R then px, zq P R.\nTo check the containment claim, just use n \" 1 so x0 \" x and xn \" y. To check the\nreflexivity claim, use n \" 0 so x0 \" x \" y and condition 3 is vacuously satisfied. To check\ntransitivitiy, suppose given R-paths x \" x0, x1, . . . , xn \" y and y \" y0, y1, . . . , yp \" z;\nthen x \" x0, x1, . . . xn, y1, . . . , yp \" z will be an R-path from x to z.\nThe point is that we can turn any relation into a preorder in a canonical way. Here\nis a concrete case of the above idea.\nLet X \" ta, b, c, du and suppose given the relation tpa, bq, pb, cq, pb, dq, pd, cq, pc, cqu.\nThis is neither reflexive nor transitive, so it's not a preorder. To make it a preorder\nwe follow the above prescription.\nStarting with R-paths of length n \" 0 we put\ntpa, aq, pb, bq, pc, cq, pd, dqu into R. The R-paths of length 1 add our original elements,\n\n3.4. ORDERS\ntpa, bq, pb, cq, pb, dq, pd, cq, pc, cqu. We don't mind redundancy (e.g. pc, cq), but from now\non in this example we will only write down the new elements. The R-paths of length 2\nadd tpa, cq, pa, dqu to R. One can check that R-paths of length 3 and above do not add\nanything new to R, so we are done. The relation\nR \" tpa, aq, pb, bq, pc, cq, pd, dq, pa, bq, pb, cq, pb, dq, pd, cq, pa, cq, pa, dqu\nis reflexive and transitive, hence a preorder.\nExercise 3.4.1.17. Let X \" ta, b, c, d, e, fu and let R \" tpa, bq, pb, cq, pb, dq, pd, eq, pf, aqu.\na.) What is the preorder R generated by R?\nb.) Is it a partial order?\n♦\nExercise 3.4.1.18. Let X be the set of people and let R D X ˆ X be the relation with\npx, yq P R if x is the child of y. Describe the preorder generated by R.\n♦\n3.4.2\nMeets and joins\nLet X be any set. Recall from Definition 2.7.4.9 that the powerset of X, denoted PpXq is\nthe set of subsets of X. There is a natural order on PpXq given by the subset relationship,\nas exemplified in Exercise 3.4.1.13. Given two elements a, b P PpXq we can consider them\nas subsets of X and take their intersection as an element of PpXq which we denote a ^ b.\nWe can also consider them as subsets of X and take their union as an element of PpXq\nwhich we denote a _ b. The intersection and union operations are generalized in the\nfollowing definition.\nDefinition 3.4.2.1. Let pS, dq be a preorder and let s, t P S be elements. A meet of s\nand t is an element w P S satisfying the following universal property:\n- w d s and w d t and,\n- for any x P S, if x d s and x d t then x d w.\nIf w is a meet of s and t, we write w - s ^ t.\nA join of s and t is an element w P S satisfying the following universal property:\n- s d w and t d w and,\n- for any x P S, if s d x and t d x then w d x.\nIf w is a join of s and t, we write w - s _ t.\nThat is, the meet of s and t is the biggest thing smaller than both, i.e. a greatest\nlower bound, and the join of s and t is the smallest thing bigger than both, i.e. a least\nupper bound. Note that the meet of s and t might be s or t itself. Note that s and t may\nhave more than one meet (or more than one join). However, any two meets of s and t\nmust be in the same clique, by the universal property (and the same for joins).\nExercise 3.4.2.2. Consider the partial order from Example 3.4.1.3.\na.) What is the join of ⌜a diamond⌝and ⌜a heart⌝?\nb.) What is the meet of ⌜a black card⌝and ⌜a queen⌝?\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nc.) What is the meet of ⌜a diamond⌝and ⌜a card⌝?\n♦\nNot every two elements in a preorder need have a meet, nor need they have a join.\nExercise 3.4.2.3.\na.) If possible, find two elements in the partial order from Example 3.4.1.3 that do not\nhave a meet. 8\nb.) If possible, find two elements that do not have a join (in that preorder).\n♦\nExercise 3.4.2.4. As mentioned in the introduction to this section, the power set S :\"\nPpXq of any set X naturally has the structure of a partial order. Its elements s P S\ncorrespond to subsets s D X, and we put s d t if and only if s D t as subsets of X. The\nmeet of two elements is their intersection as subsets of X, s ^ t \" s X t, and the join of\ntwo elements is their union as subsets of X, s _ t \" s Y t.\na.) Is it possible to put a monoid structure on the set S in which the multiplication\nformula is given by meets? If so, what would the identity element be?\nb.) Is it possible to put a monoid structure on the set S in which the multiplication\nformula is given by joins? If so, what would the identity element be?\n♦\nExample 3.4.2.5 (Trees). A tree, i.e. a system of nodes and branches, all of which emanate\nfrom a single node called the root, is a partial order, but generally not a linear order. A\ntree pT, dq can either be oriented toward the root (so the root is the largest element) or\naway from the root (so the root is the smallest element); let's only consider the latter.\nBelow is a tree, pictured as a graph. The root is labeled e.\na‚\nb‚\n/ c‚\n;\n/\n#\nd‚\ne‚\n;\n#\nf‚\ng‚\n/\n#\nh‚\ni‚\n(3.11)\nIn a tree, every pair of elements s, t P T has a meet s ^ t (their closest mutual\nancestor). On the other hand if s and t have a join c \" s _ t then either c \" s or c \" t.\nExercise 3.4.2.6. Consider the tree drawn in (3.11).\na.) What is the meet i ^ h?\nb.) What is the meet h ^ b?\nc.) What is the join b _ a?\nd.) What is the join b _ g?\n♦\n8Use the displayed preorder, not any kind of \"completion of what's there\".\n\n3.4. ORDERS\n3.4.3\nOpposite order\nDefinition 3.4.3.1. Let S :\" pS, dq be a preorder. The opposite preorder, denoted Sop\nis the preorder pS, dopq having the same set of elements but where s dop s1 iffs1 d s.\nExample 3.4.3.2. Recall the preorder N :\" pN, dividesq from Exercise 4.5.1.4. Then\nN op is the set of natural numbers but where m d n iffm is a multiple of n. So 6 d 2\nand 6 d 3.\nExercise 3.4.3.3. Suppose that S :\" pS, dq is a preorder.\na.) If S is a partial order, is Sop also a partial order?\nb.) If S is a linear order, is Sop a linear order?\n♦\nExercise 3.4.3.4. Suppose that S :\" pS, dq is a preorder, and that s1, s2 P S have join t\nin S. The preorder Sop has the same elements as S. Is t the join of s1 and s2 in Sop, or\nis it their meet, or is it not necessarily their meet nor their join?\n♦\n3.4.4\nMorphism of orders\nAn order pS, dq, be it a preorder, a partial order, or a linear order, involves a set and a\nbinary relations. For two orders to be comparable, their sets and their relations should\nbe appropriately comparable.\nDefinition 3.4.4.1. Let S :\" pS, dq and S1 :\" pS1, d1q be preorders (respectively partial\norders or linear orders). A morphism of preorders (resp. of partial orders or of linear\norders) f from S to S1, denoted f : S N S1, is a function f : S N S1 such that, for every\npair of elements s1, s2 P S, if s1 d s2 then fps1q d1 fps2q.\nExample 3.4.4.2. Let X and Y be sets, let f : X N Y be a function. Then for every\nsubset X1 D X, its image fpX1q D Y is a subset (see Section 2.1.2). Thus we have a\nfunction F : PpXq N PpY q, given by taking images. This is a morphism of partial orders\npPpXq, Dq N pPpY q, Dq. Indeed, if a D b in PpXq then fpaq D fpbq in PpY q.\nApplication 3.4.4.3. It's often said that \"a team is only as strong as its weakest member\".\nIs this true for materials? The hypothesis that a material is only as strong as its weakest\nconstituent can be understood as follows.\nRecall from the introduction to this section (see 3.4, page 93) that we can put several\ndifferent orders on the set M of materials. One example there was the order given by\nconstituency (m dC m1 if m is an ingredient or constituent of m1). Another order is\ngiven by strength: m dS m1 if m1 is stronger than m (in some fixed setting).\nIs it true that if material m is a constituent of material m1 then the strength of\nm1 is less than or equal to the strength of m?\nThis is the substance of our quote\nabove. Mathematically the question would be posed, \"is there a morphism of preorders\npM, dCq YN pM, dop\nS q?\"\n♦♦\nExercise 3.4.4.4. Let X and Y be sets, let f : X N Y be a function. Then for every\nsubset Y 1 D Y , its preimage f 1pY 1q D X is a subset (see Definition 2.5.1.12). Thus we\nhave a function F : PpY q N PpXq, given by taking preimages. Is it a morphism of partial\norders?\n♦\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nExample 3.4.4.5. Let S be a set. The smallest preorder structure that can be put on\nS is to say a d b iffa \" b. This is indeed reflexive and transitive, and it is called the\ndiscrete preorder on S.\nThe largest preorder structure that can be put on S is to say a d b for all a, b P S.\nThis again is reflexive and transitive, and it is called the indiscrete preorder on S.\nExercise 3.4.4.6. Let S be a set and let pT, dT q be a preorder. Let dD be the discrete\npreorder on S. Given a morphism of preorders pS, dDq N pT, dT q we get a function\nS N T.\na.) Which functions S N T arise in this way?\nb.) Given a morphism of preorders pT, dT q N pS, dDq, we get a function T N S. In\nterms of dT , which functions T N S arise in this way?\n♦\nExercise 3.4.4.7. Let S be a set and let pT, dT q be a preorder. Let dI be the indiscrete\npreorder on S. Given a morphism of preorders pS, dIq N pT, dT q we get a function\nS N T.\na.) In terms of dT , which functions S N T arise in this way?\nb.) Given a morphism of preorders pT, dT q N pS, dIq, we get a function T N S. In\nterms of dT , which functions T N S arise in this way?\n♦\n3.4.5\nOther applications\n3.4.5.1\nBiological classification\nBiological classification is a method for dividing the set of organisms into distinct classes,\ncalled taxa. In fact, it turns out that such a classification, say a phylogenetic tree, can\nbe understood as a partial order C on the set of taxa. The typical ranking of these taxa,\nincluding kingdom, phylum, etc., can be understood as morphism of orders f : C N rns,\nfor some n P N.\nFor example we may have a tree (see Example 3.4.2.5) that looks like this\nArchaea\n‚\n/ Pyrodicticum\n‚\nSpirochetes\n‚\nLife\n‚\n/\n\n?\nBacteria\n‚\n/\nAquifex\n‚\nFungi\n‚\nEukaryota\n‚\n/\nAnimals\n‚\n/ HomoSapien\n‚\nWe also have a linear order that looks like this:\nLife\n‚\n/ Domain\n‚\n/ Kingdom\n‚\n/ Phylum\n‚\n/\n/ Genus\n‚\n/ Species\n‚\n\n3.4. ORDERS\nand the ranking system that puts Eukaryota at Domain and Hopo Sapien at Species is\nan order-preserving function from the dots upstairs to the dots downstairs; that is, it is\na morphism of preorders.\nExercise 3.4.5.2. Since the phylogenetic tree is a tree, it has all meets.\na.) Determine the meet of dogs and humans.\nb.) If we did not require the phylogenetic partial order to be a tree, what would it mean\nif two taxa (nodes in the phylogenetic partial order), say a and b, had join c with\nc % a and c % b?\n♦\nExercise 3.4.5.3.\na.) In your favorite scientific realm, are there any interesting classification systems that\nare actually orders?\nb.) Choose one; what would meets and joins mean in that setting?\n♦\n3.4.5.4\nSecurity\nSecurity, say of sensitive information, is based on two things: a security clearance and\n\"need to know.\" The former, security clearance might have levels like \"confidential\",\n\"secret\", \"top secret\". But maybe we can throw in \"president\" and some others too, like\n\"plebe\".\nExercise 3.4.5.5. Does it appear that security clearance is a preorder, a partial order, or\na linear order?\n♦\nNeed-to-know is another classification of people. For each bit of information, we do\nnot necessarily want everyone to know about it, even everyone of the specified clearance.\nIt is only disseminated to those that need to know.\nExercise 3.4.5.6. Let P be the set of all people and let I be the set of all pieces of\ninformation known by the government. For each subset I D I, let KpIq D P be the set\nof people that need to know every piece of information in I. Let S \" tKpIq | I D Iu be\nthe set of all \"need-to-know groups\", with the subset relation denoted d.\na.) Is pS, dq a preorder? If not, find a nearby preorder.\nb.) If I1 D I2 do we always have KpI1q D KpI2q or KpI2q D KpI1q or possibly neither?\nc.) Should the preorder pS, dq have all meets?\nd.) Should pS, dq have all joins?\n♦\n3.4.5.7\nSpaces, e.g. geography\nConsider closed curves that can be drawn in the plane R2, e.g. circles, ellipses, and\nkidney-bean shaped curves. The interiors of these closed curves (not including the bound-\nary itself) are called basic open sets in R2. The good thing about such an interior U is\nthat any point p P U is not on the boundary, so no matter how close p is to the boundary\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nof U, there will always be a tiny basic open set surrounding p and completely contained\nin U. In fact, the union of any collection of basic open sets still has this property. An\nopen set in R2 is any subset U D R2 that can be formed as the union of a collection of\nbasic open sets.\nExample 3.4.5.8. Let U \" tpx, yq P R2 | x a 0u.\nTo see that U is open, define the\nfollowing sets: for any a, b P R, let Spa, bq be the square parallel to the axes, with side\nlength 1, where the upper left corner is pa, bq. Let S1pa, bq be the interior of Spa, bq. Then\neach S1pa, bq is open, and U is the union of S1pa, bq over the collection of all a a 0 and\nall b,\nU \"\nd\na, b P R,\na a 0\nS1pa, bq.\nThe idea of open sets extends to spaces beyond R2. For example, on the earth one\ncould define a basic open set to be the interior of any region one can \"draw a circle\naround\" (with a metaphorical pen), and define open sets to be unions of basic open sets.\nExercise 3.4.5.9. Let S be the set of open subsets on earth, as defined in the above\nparagraph.\na.) If d is the subset relation, is pS, dq a preorder or a partial order?\nb.) Does it have meets, does it have joins?\n♦\nExercise 3.4.5.10. Let S be the set of open subsets of earth as defined above. To each\nopen subset of earth suppose we know the range of recorded temperature throughout s\n(i.e. the low and high throughout the region). Thus to each element s P S we assign an\ninterval Tpsq :\" tx P R | a d x d bu. If we order the set V of intervals of R by the subset\nrelation, it gives a partial order on V .\na.) Does our assignment T : S N V amount to a morphism of orders?\nb.) Does it preserve meets or joins? (Hint: it doesn't preserve both.)\n♦\nExercise 3.4.5.11.\na.) Can you think of a space relevant to your favorite area of science for which it makes\nsense to assign an interval of real numbers to each open set somehow, analogously to\nExercise 3.4.5.10? For example for a sample of some material under stress, perhaps\nthe strain on each open set is somehow an interval?\nb.) Repeat the questions from Exercise 3.4.5.10.\n♦\n3.5\nDatabases: schemas and instances\nThe first three sections of this chapter were about classical objects from mathematics.\nThe present section is about databases, which are classical objects from computer science.\nThese are truly \"categories and functors, without admitting it\" (see Theorem 4.4.2.3).\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\n3.5.1\nWhat are databases?\nData, in particular the set of observations made during experiment, plays 9 a primary\nrole in science of any kind. To be useful data must be organized, often in a row-and-\ncolumn display called a table. Columns existing in different tables can refer to the same\ndata.\nA database is a collection of tables, each table T of which consists of a set of columns\nand a set of rows. We roughly explain the role of tables, columns, and rows as follows.\nThe existence of table T suggests the existence of a fixed methodology for observing\nobjects or events of a certain type.\nEach column c in T prescribes a single kind or\nmethod of observation, so that the datum inhabiting any cell in column c refers to an\nobservation of that kind. Each row r in T has a fixed sourcing event or object, which\ncan be observed using the methods prescribed by the columns. The cell pr, cq refers to\nthe observation of kind c made on event r. All of the rows in T should refer to uniquely\nidentifiable objects or events of a single type, and the name of the table T should refer\nto that type.\nExample 3.5.1.1. When graphene is strained (lengthened by a factor of x e 1), it becomes\nstressed (carries a force in the direction of the lengthening). The following is a made-up\nset of data.\nGraphene sample\nID\nSource\nStress\nStrain\nA118-1\nC Smkt\nA118-2\nC Smkt\n0.02\nA118-3\nC Smkt\n0.05\nA118-4\nAC\n0.04\nA118-5\nAC\n0.1\nA118-6\nC Plat\n0.1\nSupplier\nID\nFull name\nPhone\nC Smkt\nCarbon Supermarket\n(541)781-6611\nAC\nAdvanced Chemical\n(410) 693-0818\nC Plat\nCarbon Platform\n(510) 719-2857\nMcD\nMcDonard's Burgers\n(617) 244-4400\nAPP\nAcme Pen and Paper\n(617) 823-5603\n(3.12)\nIn the first table, titled \"Graphene sample\", the rows refer to graphene samples, and\nthe table is so named. Each graphene sample can be observed according to the source\nsupplier from which it came, the strain that it was subjected to, and the stress that\nit carried. These observations are the columns. In the second table, the rows refer to\nsuppliers of various things, and the table is so named. Each supplier can be observed\naccording to its full name and its phone number; these are the columns.\nIn the left-hand table it appears either that each graphene sample was used only\nonce, or that the person recording the data did not keep track of which samples were\nreused. If such details become important later, the lab may want to change the layout\nof the first table by adding on the appropriate column. This can be accomplished using\nmorphisms of schemas, which will be discussed in Section 4.4.1.\n9The word data is generally considered to be the plural form of the word datum. However, individual\ndatum elements are only useful when they are organized into structures (e.g. if one were to shuffle the\ncells in a spreadsheet, most would consider the data to be destroyed). It is the whole organized structure\nthat really houses the information; the data must be in formation in order to be useful. Thus I will use\nthe word data as a collective noun (akin to the word \"sand\"); it bridges the divide between the individual\ndatum elements (akin to the grains of sand) and the data set (akin to a sand pile). In particular, I will\noften use the word data as a singular noun.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n3.5.1.2\nPrimary keys, foreign keys, and data columns\nThere is a bit more structure in the above tables (Example 3.12) then may first meet\nthe eye. Each table has a primary ID column, found on the left, as well as some data\ncolumns and some foreign key columns. The primary key column is tasked with uniquely\nidentifying different rows. Each data column houses elementary data of a certain sort.\nPerhaps most interesting from a structural point of view are the foreign key columns,\nbecause they link one table to another, creating a connection pattern between tables.\nEach foreign key column houses data that needs to be further unpacked. It thus refers us\nto another foreign table, in particular the primary ID column of that table. In Example\n3.12 the Source column was a foreign key to the Supplier table.\nHere is another example, lifted from [Sp2].\nExample 3.5.1.3. Consider the bookkeeping necessary to run a department store. We\nkeep track of a set of employees and a set of departments. For each employee e, we keep\ntrack of\nE.1 the first name of e, which is a FirstNameString,\nE.2 the last name of e, which is a LastNameString,\nE.3 the manager of e, which is an Employee, and\nE.4 the department that e works in, which is a Department.\nFor each department d, we keep track of\nD.1 the name of d, which is a DepartmentNameString, and\nD.2 the secretary of d, which is an Employee.\nAbove we can suppose that E.1, E.2, and D.1 are data columns (referring to names\nof various sorts), and E.3, E.4, and D.2 are foreign key columns (referring to managers,\nsecretaries, etc.).\nDisplay (3.13) shows how such a database might look at a particular moment in time.\nEmployee\nID\nfirst\nlast\nmanager\nworksIn\nDavid\nHilbert\nq10\nBertrand\nRussell\nx02\nEmmy\nNoether\nq10\nDepartment\nID\nname\nsecretary\nq10\nSales\nx02\nProduction\n(3.13)\n3.5.1.4\nBusiness rules\nLooking at the tables from Example 3.5.1.3, one may notice a few patterns. First, every\nemployee works in the same department as his or manager. Second, every department's\nsecretary works in that department. Perhaps the business counts on these rules for the\nway it structures itself. In that case the database should enforce those rules, i.e. it\nshould check that whenever the data is updated, it conforms to the rules:\nRule 1 For every employee e, the manager of e works in the same department\nthat e works in.\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\nRule 2 For every department d, the secretary of d works in department d.\n(3.14)\nTogether, the statements E.1, E.2, E.3, E.4, D.1, and D.2 from Example 3.5.1.3 and\nRule 1 and Rule 2, constitute what we will call the schema of the database. We will\nformalize this idea in Section 3.5.2.\n3.5.1.5\nData columns as foreign keys\nTo make everything consistent, we could even say that data columns are specific kinds of\nforeign keys. That is, each data column constitutes a foreign key to some non-branching\nleaf table, which has no additional data.\nExample 3.5.1.6. Consider again Example 3.5.1.3. Note that first names and last names\nhad a particular type, which we all but ignored above. We could cease to ignore them\nby adding three tables, as follows.\nFirstNameString\nID\nAlan\nAlice\nBertrand\nCarl\nDavid\nEmmy\n...\nLastNameString\nID\nArden\nHilbert\nJones\nNoether\nRussell\n...\nDepartmentNameString\nID\nMarketing\nProduction\nSales\n...\n(3.15)\nIn combination, Displays (3.13) and (3.15) form a collection of tables with the prop-\nerty that every column is either a primary key or a foreign key. The notion of data\ncolumn is now subsumed under the notion of foreign key column. Everything is either a\nprimary key (one per table, labeled ID) or a foreign key column (everything else).\n3.5.2\nSchemas\nThe above section may all seem intuitive or reasonable in some ways, but also a bit\ndifficult to fully grasp, perhaps. It would be nice to summarize what is happening in a\npicture. Such a picture, which will basically be a graph, should capture the conceptual\nlayout to which the data conforms, without yet being concerned with the individual data\nthat may populate the tables in this instant. We proceed at first by example, giving the\nprecise definition in Definition 3.5.2.6.\nExample 3.5.2.1. In Examples 3.5.1.3 and 3.5.1.6, the conceptual layout for a department\nstore was given, and some example tables were shown. We were instructed to keep track\nof employees, departments, and six types of data (E.1, E.2, E.3, E.4, D.1, and D.2), and\nwe were instructed to follow two rules (Rule 1, Rule 2). All of this is summarized in the\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nfollowing picture:\nC:\" Schema for tables (3.13) and (3.15) conforming to (3.14)\nEmployee manager worksIn » Employee worksIn\nDepartment secretary worksIn » Department\nEmployee\n‚\nworksIn\n/\nmanager\n\nfirst\n~\nlast\n\nDepartment\n‚\nsecretary\no\nname\n\nFirstNameString\n‚\nLastNameString\n‚\nDepartmentNameString\n‚\n(3.16)\nThe five tables from (3.13) and (3.15) are seen as five vertices; this is also the number of\nprimary ID columns. The six foreign key columns from (3.13) and (3.15) are seen as six\narrows; each points from a table to a foreign table. The two rules from (3.14) are seen as\nstatements at the top of Display (3.16).We will explain path equivalences in Definition\n3.5.2.3.\nExercise 3.5.2.2. Come up with a schema (consisting of dots and arrows) describing the\nconceptual layout of information presented in Example 3.5.1.1.\n♦\nIn order to define schemas, we must first define the notion of schematic equivalence\nrelation, which is to hold on the set of paths of a graph G (see Section 3.3.2). Such\nan equivalence relation (in addition to being reflexive, symmetric, and transitive) has\ntwo sorts of additional properties: equivalent paths must have the same source and\ntarget, and the composition of equivalent paths with other equivalent paths must yield\nequivalent paths. Formally we have Definition 3.5.2.3.\nDefinition 3.5.2.3.\nLet G \" pV, A, src, tgtq be a graph, and let PathG denote the set of paths in G\n(see Definition 3.3.2.1). A path equivalence declaration (or PED) is an expression of the\nform p » q where p, q P PathG have the same source and target, srcppq \" srcpqq and\ntgtppq \" tgtpqq.\nA congruence on G is a relation » on PathG that has the following properties:\n1. The relation » is an equivalence relation.\n2. If p » q then srcppq \" srcpqq.\n3. If p » q then tgtppq \" tgtpqq.\n4. Suppose p, q: b N c are paths, and m: a N b is an arrow. If p » q then mp » mq.\n5. Suppose p, q: a N b are paths, and n: b N c is an arrow. If p » q then pn » qn.\nAny set of path equivalence declarations (PEDs) generates a congruence. We tend\nto elide the difference between a congruence and the set of PEDs that generates it.\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\nExercise 3.5.2.4. Consider the graph shown in (3.16), and the two declarations shown at\nthe top. They generate a congruence.\na.) Is it true that the following PED is an element of this congruence?\nEmployee manager manager worksIn\n?» Employee worksIn\nb.) What about this one?\nEmployee worksIn secretary\n?» Employee\nc.) What about this one?\nDepartment secretary manager worksIn name\n?» Department name\n♦\nLemma 3.5.2.5. Suppose that G is a graph and » is a congruence on G. Suppose\np » q: a N b and r » s: b N c. Then pr » qs.\nProof. The picture to have in mind is this:\n‚\n/\n/ ‚\n\n‚\n/\n/ ‚\n\na‚\n»\nA\n\np\n%\nq\nb‚\n»\nA\n\nr\n%\ns\nc‚\n‚\n/\n/ ‚\nA\n‚\n/\n/ ‚\nA\nApplying condition (3) from Definition 3.5.2.3 to each arrow in path p, it follows by\ninduction that pr » ps.\nApplying condition (4) to each arrow in path s, it follows\nsimilarly that ps » qs. Because » is an equivalence relation, it follows that pr » qs.\n□\nDefinition 3.5.2.6. A database schema (or simply schema) C consists of a pair C :\"\npG, »q where G is a graph and » is a congruence on G.\nExample 3.5.2.7. The picture drawn in (3.16) has the makings of a schema. Pictured is\na graph with two PEDs; these generate a congruence, as discussed in Exercise 3.5.2.4.\nA schema can be converted into a system of tables each with a primary key and some\nnumber of foreign keys referring to other tables, as discussed in Section 3.5.1. Definition\n3.5.2.6 gives a precise conceptual understanding of what a schema is, and the following\nrules describe how to convert such a thing into a table layout.\nRules of good practice 3.5.2.8. Converting a schema C \" pG, »q into a table layout should\nbe done as follows:\n(i) There should be a table for every vertex in G and if the vertex is named, the table\nshould have that name;\n(ii) Each table should have a left-most column called ID, set apart from the other\ncolumns by a double vertical line; and\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n(iii) To each arrow a in G having source vertex s :\" srcpaq and target vertex t :\" tgtpaq,\nthere should be a foreign key column a in table s, referring to table t; if the arrow\na is named, column a should have that name.\nExample 3.5.2.9 (Discrete dynamical system). Consider the schema\nLoop :\"\ns‚\nf\n\n(3.17)\nin which the congruence is trivial (i.e.\ngenerated by the empty set of PEDs.)\nThis\nschema is quite interesting. It encodes a set s and a function f : s N s. Such a thing\nis called a discrete dynamical system. One imagines s as the set of states and, for any\nstate x P s, a notion of \"next state\" fpxq P s. For example\ns\nID\nf\nA\nB\nB\nC\nC\nC\nD\nB\nE\nC\nF\nG\nG\nH\nH\nG\n...pictured...\nA‚\n/ B‚\n/ C‚ q\nD‚\n;\nE‚\n;\nF‚\n/ G‚\n( H‚\nh\n(3.18)\nApplication 3.5.2.10. Imagine a quantum-time universe in which there are discrete time\nsteps. We model it as a discrete dynamical system, i.e. a table of the form (3.18). For\nevery possible state of the universe we include a row in the table. The state in the next\ninstant is recorded in the second column.\n♦♦\nExample 3.5.2.11 (Finite hierarchy). The schema Loop can also be used to encode hier-\narchies, such as the manager relation from Examples 3.5.1.3 and 3.5.2.1,\nE‚\nmgr\n\nOne problem with this, however, is if a schema has even one loop, then it can have in-\nfinitely many paths (corresponding, e.g. to an employees manager's manager's manager's\n... manager).\nSometimes we know that in a given company that process eventually ends, a famous\nexample being that at Ben and Jerry's ice cream, there were only seven levels. In that\ncase we know that an employee's 8th level manager is equal to his or her 7th level\nmanager. This can be encoded by the PED\nE mgr mgr mgr mgr mgr mgr mgr mgr » E mgr mgr mgr mgr mgr mgr mgr\nor more concisely, mgr8 \" mgr7.\nExercise 3.5.2.12. Is there any nontrivial PED on Loop that holds for the data in Example\n3.5.2.9? If so, what is it and how many equivalence classes of paths in Loop are there\nafter you impose that relation?\n♦\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\nExercise 3.5.2.13. Let P be a chess-playing program. Given any position (including the\nhistory of the game and choice of whose turn it is), P will make a move.\na.) Is this an example of a discrete dynamical system?\nb.) How do the rules for ending the game in a win or draw play out in this model? (Look\nup online how chess games end if you don't know.)\n♦\n3.5.2.14\nOlogging schemas\nIt should be clear that a database schema is nothing but an olog in disguise.\nThe\ndifference is basically the readability requirements for ologs. There is an important new\naddition in this section, namely that we can fill out an olog with data. Conversely, we\nhave seen that databases are not any harder to understand than ologs are.\nExample 3.5.2.15. Consider the olog\na moon\norbits\nYYYYYYN a planet\n(3.19)\nWe can document some instances of this relationship using the following tables:\norbits\na moon\na planet\nThe Moon\nEarth\nPhobos\nMars\nDeimos\nMars\nGanymede\nJupiter\nTitan\nSaturn\n(3.20)\nClearly, this table of instances can be updated as more moons are discovered by the\nauthor (be it by telescope, conversation, or research).\nExercise 3.5.2.16. In fact, Example 3.5.2.15 did not follow Rules 3.5.2.8. Strictly follow-\ning those rules, copy over the data from (3.20) into tables that are in accordance with\nschema (3.19).\n♦\nExercise 3.5.2.17.\na.) Write down a schema, in terms of the boxes ⌜a thing I own⌝and ⌜a place⌝and one\nadditional arrow, that might help one remember where they decided to put \"random\"\nthings.\nb.) What is a good label for the arrow?\nc.) Fill in some rows of the corresponding set of tables for your own case.\n♦\nExercise 3.5.2.18. Consider the olog\nC\na child\nhas\n/\nF\na father\nhas as first\nk\nhas as tallest\nt\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\na.) What path equivalence declarations would be appropriate for this olog? You can use\nf : F N C, t: F N C, and h: C N F if you prefer.\nb.) How many PEDs are in the congruence?\n♦\n3.5.3\nInstances\nGiven a database schema pG, »q, an instance of it is just a bunch of tables whose data\nconform to the specified layout. These can be seen throughout the previous section, most\nexplicitly in the relationship between schema (3.16) and tables (3.13) and (3.15), and\nbetween schema (3.17) and table (3.18). Below is the mathematical definition.\nDefinition 3.5.3.1. Let C \" pG, »q where G \" pV, A, src, tgtq.\nAn instance on C,\ndenoted pPK, FKq: C N Set, is defined as follows: One announces some constituents\n(A. primary ID part, B. foreign key part) and asserts that they conform to a law (1.\npreservation of congruence). Specifically, one announces\nA. a function PK: V N Set; i.e. to each vertex v P V one provides a set PKpvq;10\nand\nB. for every arrow a P A with v \" srcpaq and w \" tgtpaq, a function FKpaq: PKpvq N\nPKpwq. 11\nOne asserts that the following law holds for any vertices v, w and paths p \" va1a2 . . . am\nand q \" va1\n1a1\n2 . . . a1\nn from v to w:\n1. If p » q then for all x P PKpvq, we have\nFKpamq FKpa2q FKpa1qpxq \" FKpa1\nnq FKpa1\n2q FKpa1\n1qpxq\nin PKpwq.\nExercise 3.5.3.2. Consider the olog pictured below:\nC :\"\na self-email\nis\n/ an email\nis sent by,\nis sent to\na person\nGiven x, a self-email, consider the following.\nWe know that x is a self-email, which is an email,\nwhich is sent by a person that we'll call Ppxq.\nWe also know that x is a self-email, which is an\nemail, which is sent to a person that we'll call Qpxq.\nFact: whenever x is a self-email, we will have Ppxq \"\nQpxq\n10The elements of PKpvq will be listed as the rows of table v, or more precisely as the leftmost cells\nof these rows.\n11The arrow a will correspond to a column, and to each row r P PKpvq the pr, aq cell will contain the\ndatum FKpaqprq.\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\na self-email\nID\nis\nSEm1207\nEm1207\nSEm1210\nEm1210\nSEm1211\nEm1211\nan email\nID\nis sent by\nis sent to\nEm1206\nBob\nSue\nEm1207\nCarl\nCarl\nEm1208\nSue\nMartha\nEm1209\nChris\nBob\nEm1210\nChris\nChris\nEm1211\nJulia\nJulia\nEm1212\nMartha\nChris\na person\nID\nBob\nCarl\nChris\nJulia\nMartha\nSue\n(3.21)\na.) What is the set PKp⌜an email⌝q?\nb.) What is the set PKp⌜a person⌝q?\nc.) What is the function FKpis sent byq: PKp⌜an email⌝q N PKp⌜a person⌝q?\nd.) Interpret the sentences at the bottom of C as the Englishification of a simple path\nequivalence declaration. Is it satisfied by the instance (3.21); that is, does law 1.\nfrom Definition 3.5.3.1 hold?\n♦\nExample 3.5.3.3 (Monoid action table). In Example 3.1.2.9, we saw how a monoid M\ncould be captured as an olog with only one object. As a database schema, this means\nthere is only one table. Every generator of M would be a column of the table. The\nnotion of database instance for such a schema is precisely the notion of action table from\nSection 3.1.3. Note that a monoid can act on itself, in which case this action table is the\nmonoid's multiplication table as in Example 3.1.3.2, but it can also act on any other set\nas in Example 3.1.3.1. If M acts on a set S, then the set of rows in the action table will\nbe S.\nExercise 3.5.3.4. Draw (as a graph) the schema for which Table 3.2 is an instance.\n♦\nExercise 3.5.3.5. Suppose that M is a monoid and some instance of it is written out in\ntable form. It's possible that M is a group. What evidence in an instance table for M\nmight suggest that M is a group?\n♦\n3.5.3.6\nPaths through a database\nLet C :\" pG, »q be a schema and let pPK, FKq: C N Set be an instance on C. Then\nfor every arrow a: v N w in G we get a function FKpaq: PKpvq N PKpwq. Functions\ncan be composed, so in fact for every path through G we get a function. Namely, if\np \" v0a1, a2, . . . , an is a path from v0 to vn then the instance provides a function\nFKppq :\" FKpanq FKpa2q FKpa1q: PKpv0q N PKpvnq,\nwhich first made an appearance as part of Law 1 in Definition 3.5.3.1.\nExample 3.5.3.7. Consider the department store schema from Example 3.5.2.1, and in\n(3.16) the path rworksIn, secretary, lasts which points from Employee to LastNameString.\nThe instance will let us interpret this path as a function from the set of employees to\nthe set of last names; this could be a useful function to have around. The instance from\n(3.13) would yield the following function\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nEmployee\nID\nSecr. name\nHilbert\nRussell\nHilbert\nExercise 3.5.3.8. Consider the path p :\" rf, fs on the Loop schema from (3.17). Using the\ninstance from (3.18), where PKpsq \" tA, B, C, D, E, F, G, Hu, interpret p as a function\nPKpsq N PKpsq, and write this as a 2-column table, as above in Example 3.5.3.7.\n♦\nExercise 3.5.3.9.\na.) Given an instance pPK, FKq on a schema C, and given a trivial path p (i.e. p has\nlength 0; it starts at some vertex but doesn't go anywhere), what function does p\nyield?\nb.) What are the domain and codomain of p?\n♦\n\nChapter 4\nBasic category theory\n\"...We know only a very few--and, therefore, very precious--schemes whose unifying\npowers cross many realms.\" - Marvin Minsky.1\nCategories, or an equivalent notion, have already been secretly introduced as ologs.\nOne can think of a category as a graph (as in Section 3.3) in which certain paths have\nbeen declared equivalent. (Ologs demand an extra requirement that everything in sight\nbe readable in natural language, and this cannot be part of the mathematical definition\nof category.)\nThe formal definition of category is given in Definition 4.1.1.1, but it\nwill not be obviously the same as the \"graph+path equivalences\" notion; the latter was\ngiven in Definition 3.5.2.6 as the definition of a schema. Once we talk about how different\ncategories can be compared using functors (Definition 4.1.2.1), and how different schemas\ncan be compared using schema mappings (Definition 4.4.1.2), we will prove that the two\nnotions are equivalent (Theorem 4.4.2.3).\n4.1\nCategories and Functors\nIn this section we give the standard definition of categories and functors. These, together\nwith natural transformations (Section 4.3), form the backbone of category theory. We\nalso give some examples.\n4.1.1\nCategories\nIn everyday speech we think of a category as a kind of thing. A category consists of a\ncollection of things, all of which are related in some way. In mathematics, a category\ncan also be construed as a collection of things and a type of relationship between pairs\nof such things. For this kind of thing-relationship duo to count as a category, we need to\ncheck two rules, which have the following flavor: every thing must be related to itself by\nsimply being itself, and if one thing is related to another and the second is related to a\nthird, then the first is related to the third. In a category, the \"things\" are called objects\nand the \"relationships\" are called morphisms.\nIn various places throughout this book so far we have discussed things of various\nsorts, e.g. sets, monoids, graphs. In each case we discussed how such things should be\n1[Min, Problems of disunity, p. 126].\n\nCHAPTER 4. BASIC CATEGORY THEORY\nappropriately compared. In each case the \"things\" will stand as the objects and the\n\"appropriate comparisons\" will stand as the morphisms in the category.\nHere is the\ndefinition.\nDefinition 4.1.1.1. A category C is defined as follows: One announces some constituents\n(A. objects, B. morphisms, C. identities, D. compositions) and asserts that they conform\nto some laws (1. identity law, 2. associativity law). Specifically, one announces:\nA. a collection ObpCq, elements of which are called objects;\nB. for every pair x, y P ObpCq, a set HomCpx, yq P Set. It is called the hom-set\nfrom x to y; its elements are called morphisms from x to y; 2\nC. for every object x P ObpCq, a specified morphism denoted idx P HomCpx, xq\ncalled the identity morphism on x; and\nD. for every three objects x, y, z P ObpCq, a function\n: HomCpy, zq ˆ HomCpx, yq N HomCpx, zq,\ncalled the composition formula.\nGiven objects x, y P ObpCq, we can denote a morphism f P HomCpx, yq by f : x N y; we\nsay that x is the domain of f and that y is the codomain of f. Given also g: y N z,\nthe composition formula is written using infix notation, so g f : x N z means pg, fq P\nHomCpx, zq.\nOne asserts that the following law holds:\n1. for every x, y P ObpCq and every morphism f : x N y, we have\nf idx \" f\nand\nidy f \" f;\nand;\n2. if w, x, y, z P ObpCq are any objects and f : w N x,\ng: x N y,\nand h: y N z\nare any morphisms, then the two ways to compose are the same:\nph gq f \" h pg fq P HomCpw, zq.\nRemark 4.1.1.2. There is perhaps much that is unfamiliar about Definition 4.1.1.1 but\nthere is also one thing that is strange about it. The objects ObpCq of C are said to\nbe a \"collection\" rather than a set. This is because we sometimes want to talk about\nthe category of all sets, in which every possible set is an objects, and if we try to say\nthat the collection of sets is itself, we run into Russell's paradox. Modeling this was\na sticking point in the foundations of category theory, but it was eventually fixed by\nGrothendieck's notion of expanding universes. Roughly the idea is to choose some huge\nset κ (with certain properties making it a universe), to work entirely inside of it when\npossible, and to call anything in that world κ-small (or just small if κ is clear from\ncontext). When we need to look at κ itself, we choose an even bigger universe κ1 and\nwork entirely within it.\nA category in which the collection ObpCq is a set (or in the above language, a small\nset) is called a small category. From here on out we will not take care of the difference,\nreferring to ObpCq as a set. We do not think this will do any harm to scientists using\ncategory theory, at least not in the beginning phases of their learning.\n2The reason for the notation Hom and the word hom-set is that morphisms are often called homo-\nmorphisms, e.g. in group theory.\n\n4.1. CATEGORIES AND FUNCTORS\nExample 4.1.1.3 (The category Set of sets). Chapter 2 was all about the category of sets,\ndenoted Set. The objects are the sets and the morphisms are the functions; we even\nused the current notation, referring to the set of functions X N Y as HomSetpX, Y q.\nThe composition formula is given by function composition, and for every set X, the\nidentity function idX : X N X serves as the identity morphism for X P ObpSetq. The\ntwo laws clearly hold, so Set is indeed a category.\nExample 4.1.1.4 (The category Fin of finite sets). Inside the category Set is a subcategory\nFin D Set, called the category of finite sets. Whereas an object S P ObpSetq is a set\nthat can have arbitrary cardinality, we define Fin such that its objects include all (and\nonly) the sets S with finitely many elements, i.e. |S| \" n for some natural number n P N.\nEvery object of Fin is an object of Set, but not vice versa.\nAlthough Fin and Set have a different collection of objects, their morphisms are in\nsome sense \"the same\". For any two finite sets S, S1 P ObpFinq, we can also think of\nS, S1 P ObpSetq, and we have\nHomFinpS, S1q \" HomSetpS, S1q.\nThat is a morphism in Fin between finite sets S and S1 is simply a function f : S N S1.\nExample 4.1.1.5 (The category Mon of monoids). We defined monoids in Definition\n3.1.1.1 and monoid homomorphisms in Definition 3.1.4.1. Every monoid M :\" pM, e, ‹Mq\nhas an identity homomorphism idM : M N M, given by the identity function idM : M N\nM. To compose two monoid homomorphisms f : M N M1 and g: M1 N M2, we com-\npose their underlying functions f : M N M 1 and g: M 1 N M 2, and check that the result\ng f is a monoid homomorphism. Indeed,\ng fpeq \" gpe1q \" e2\ng fpm1 ‹M m2q \" gpfpm1q ‹M 1 fpm2qq \" g fpm1q ‹M 2 g fpm2q.\nIt is clear that the two laws hold, so Mon is a category.\nExercise 4.1.1.6 (The category Grp of groups). Suppose we set out to define a category\nGrp, having groups as objects and group homomorphisms as morphisms, see Definition\n3.2.1.16. Show (to the level of detail of Example 4.1.1.5) that the rest of the conditions\nfor Grp to be a category are satisfied.\n♦\nExercise 4.1.1.7 (The category PrO of preorders). Suppose we set out to define a cate-\ngory PrO, having preorders as objects and preorder homomorphisms as morphisms (see\nDefinition 3.4.4.1). Show (to the level of detail of Example 4.1.1.5 that the rest of the\nconditions for PrO to be a category are satisfied.\n♦\nExample 4.1.1.8 (Non-category 1). So what's not a category? Two things can go wrong:\neither one fails to specify all the relevant constituents (A, B, C, D from Definition 4.1.1.1,\nor the constituents do not obey the laws (1, 2).\nLet G be the following graph,\nG \"\na‚\nf\n/ b‚\ng\n/ c‚ .\nSuppose we try to define a category G by faithfully recording vertices as objects and\narrows as morphisms. Will that be a category?\n\nCHAPTER 4. BASIC CATEGORY THEORY\nFollowing that scheme, we put ObpGq \" ta, b, cu. For all 9 pairs of objects we need a\nhom-set. Say\nHomGpa, aq \" H\nHomGpa, bq \" tfu\nHomGpa, cq \" H\nHomGpb, aq \" H\nHomGpb, bq \" H\nHomGpb, cq \" tgu\nHomGpc, aq \" H\nHomGpc, bq \" H\nHomGpc, cq \" H\nIf we say we are done, the listener should object that we have given neither identities\nnor a composition formula. In fact, it is impossible to give identities under our scheme,\nbecause e.g. HomGpa, aq \" H.\nSuppose we fix that problem, adding an element to each of our \"diagonals\" so that\nHomGpa, aq \" tidau,\nHomGpb, bq \" tidbu,\nand\nHomGpc, cq \" tidcu.\nWhat about a composition formula? We need a function HomGpa, bq ˆ HomGpb, cq N\nHomGpa, cq, but the domain is nonempty and the codomain is empty; there is no such\nfunction.\nAgain, we must make a change, adding an element to make\nHomGpa, cq \" thu.\nWe would now say g f \" h. Finally, this does the trick and we have a category. A\ncomputer could check this quickly, as can someone with good intuition for categories;\nfor everyone else, it may be a painstaking process involving determining whether there\nis a unique composition formula for each of the 27 pairs of hom-sets and whether the\nassociative law holds in the 81 necessary cases. Luckily this computation is \"sparse\"\n(lots of H's), so it's not as bad as it first seems.\nRedrawing all the morphisms as arrows, our graph has become:\nG \"\na‚\nida\n:\nf\n/\nh\nb‚\nidb\n\ng\n/ c‚\nidc\nd\nExample 4.1.1.9 (Non-category 2). In this example, we will make a faux-category F with\none object and many morphisms. The problem here will be our composition formula.\nDefine F to have one object ObpFq \" t,u, and HomFp,, ,q \" N. Define id, \" 1 P\nN. Define the composition formula : N ˆ N N N by m n \" mn. This is a perfectly\ncromulent function, but it does not work right as a composition formula. Indeed, for the\nidentity law to hold, we would need m1 \" m \" 1m, and one side of this is false. For the\nassociativity law to hold, we would need pmnqp \" mpnpq, but this is also not the case.\nTo fix this problem we have to completely revamp our composition formula. It would\nwork to use multiplication, m n \" m n. Then the identity law would read 1 m \"\nm \" m 1, and that holds; and the associativity law would read pm nq p \" m pn pq,\nand that holds.\nExample 4.1.1.10 (The category of preorders with joins). Suppose that we are only\ninterested in preorders pX, dq for which every pair of elements has a join. We saw in\nExercise 3.4.2.3 that not all preorders have this property.\nHowever we can create a\ncategory C in which every object does have this property. To begin we put ObpCq \"\ntpX, dq P ObpPrOq | pX, dq has all joinsu. But what about morphisms?\n\n4.1. CATEGORIES AND FUNCTORS\nOne option would be to put in no morphisms (other than identities), and to just\nconsider this collection of objects as having no structure other than a set.\nAnother option would be to put in exactly the same morphisms as in PrO: for any\nobjects a, b P ObpCq we consider a and b as regular old preorders, and put HomCpa, bq :\"\nHomPrOpa, bq. The resulting category of preorders with joins is called the full subcategory\nof PrO spanned by the preorders with joins.3\nA third option, and the one perhaps that would jump out to a category theorist, is\nto take the choice about how we define our objects as a clue to how we should define\nour morphisms. Namely, if we are so interested in joins, perhaps we want joins to be\npreserved under morphisms. That is, if f : pX, dXq N pY, dY q is a morphism of preorders\nthen for any join w \" x _ x1 in X we might want to enforce that fpwq \" fpxq _ fpx1q in\nY . Thus a third possibility for the morphisms of C would be\nHomCpa, bq :\" tf P HomPrOpa, bq | f preserves joinsu.\nOne can check easily that the identity morphisms preserve joins and that compositions of\njoin-preserving morphisms are join-preserving, so this version of homomorphisms makes\nfor a well-defined category.\nExample 4.1.1.11 (Category FLin of finite linear orders). We have a category PrO of\npreorders, and some of its objects are finite (nonempty) linear orders.\nLet FLin be\nthe full subcategory of PrO spanned by the linear orders. That is, following Definition\n3.4.4.1, given linear orders X, Y , every morphism of preorders X N Y counts as a\nmorphism in FLin:\nHomFLinpX, Y q \" HomPrOpX, Y q.\nExercise 4.1.1.12. Let FLin be the category of finite linear orders, defined in Example\n4.1.1.11. For n P N, let rns be the linear order defined in Example 3.4.1.7. What are the\ncardinalities of the following sets:\na.) HomFLinpr0s, r3sq;\nb.) HomFLinpr3s, r0sq;\nc.) HomFLinpr2s, r3sq;\nd.) HomFLinpr1s, rnsq?\ne.) (Challenge) HomFLinprms, rnsq?\nIt turns out that the category FLin of linear orders is sufficiently rich that much of al-\ngebraic topology (the study of arbitrary spaces, such as Mobius strips and 7-dimensional\nspheres) can be understood in its terms. See Example 4.6.1.6.\n♦\nExample 4.1.1.13 (Category of graphs). We defined graphs in Definition 3.3.1.1 and\ngraph homomorphisms in Definition 3.3.3.1. To see that these are sufficient to form a\ncategory is considered routine to a seasoned category-theorist, so let's see why.\nSince a morphism from G \" pV, A, src, tgtq to G1 \" pV 1, A1, src1, tgt1q involves two\nfunctions f0 : V N V 1 and f1 : A N A1, the identity and composition formulas will\nsimply arise from the identity and composition formulas for sets.\nAssociativity will\nfollow similarly. The only thing that needs to be checked, really, is that the composition\nof two such things, each satisfying (3.6), will itself satisfy (3.6). Just for completeness,\nwe check that now.\n3The definition of full subcategories will be given as Definition 4.6.3.1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nSuppose that f \" pf0, f1q: G N G1 and g \" pg0, g1q: G1 N G2 are graph homomor-\nphisms, where G2 \" pV 2, A2, src2, tgt2q. Then in each diagram below\nA\nf1\n/\nsrc\n\nA1\ng1\n/\nsrc1\n\nA2\nsrc2\n\nV\nf0\n/ V 1\ng0\n/ V 2\nA\nf1\n/\ntgt\n\nA1\ntgt1\n\ng1\n/ A2\ntgt2\n\nV\nf0\n/ V 1\ng0\n/ V 2\n(4.1)\nthe left-hand square commutes because f is a graph homomorphism and the right-hand\nsquare commutes because g is a graph homomorphism. Thus the whole rectangle com-\nmutes, meaning that g f is a graph homomorphism, as desired.\nWe denote the category of graphs and graph homomorphisms by Grph.\nRemark 4.1.1.14. When one is struggling to understand basic definitions, notation, and\nstyle, a phase which naturally occurs when learning new mathematics (or any new lan-\nguage), the above example will probably appear long and tiring. I'd say you've mastered\nthe basics when the above example really does feel straightforward. Around this time,\nI imagine you'll begin to get a sense of the remarkable organisational potential of the\ncategorical way of thinking.\nExercise 4.1.1.15. Let F be a vector field on R2. Recall that for two points x, x1 P R2,\nany curve C with endpoints x and x1, and any parameterization r: ra, bs N C, the line\nintegral\ns\nC Fprq dr returns a real number. It does not depend on r, except its orientation\n(direction). Therefore, if we think of C has having an orientation, say going from x to\nx1, then\ns\nC F is a well-defined real number. If C goes from x to x1, let's suggestively\nwrite C : x N x1. Define an equivalence relation „ on the set of oriented curves in R2 by\nsaying C „ C1 if\n- C and C1 start at the same point,\n- C and C1 end at the same point, and\n-\ns\nC F \"\ns\nC1 F.\nSuppose we try to make a category CF as follows. Put ObpCF q \" R2, and for every\npair of points x, x1 P R2, let HomCF px, x1q \" tC : x N x1u{ „, where C : x N x1 is an\noriented curve and „ means \"same line integral\", as explained above.\nIs there an identity morphism and a composition formula that will make CF into a\ncategory?\n♦\n4.1.1.16\nIsomorphisms\nIn any category we have a notion of isomorphism between objects.\nDefinition 4.1.1.17. Let C be a category and let X, Y P ObpCq be objects. An isomor-\nphism f from X to Y is a morphism f : X N Y in C, such that there exists a morphism\ng: Y N X in C such that\ng f \" idX\nand\nf g \" idY .\nIn this case we say that the morphism f is invertible and that g is the inverse of f. We\nmay also say that the objects X and Y are isomorphic.\n\n4.1. CATEGORIES AND FUNCTORS\nExample 4.1.1.18. If C \" Set is the category of sets, then the above definition coincides\nprecisely with the one given in Definition 2.1.2.8.\nExercise 4.1.1.19. Suppose that G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q are\ngraphs and that f \" pf0, f1q: G N G1 is a graph homomorphism (as in Definition\n3.3.3.1).\na.) If f is an isomorphism in Grph, does this imply that f0 : V N V 1 and f1 : A N A1\nare isomorphisms in Set?\nb.) If so, why; and if not, show a counterexample (where f is an isomorphism but either\nf0 or f1 is not).\n♦\nExercise 4.1.1.20. Suppose that G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q are\ngraphs and that f \" pf0, f1q: G N G1 is a graph homomorphism (as in Definition\n3.3.3.1).\na.) If f0 : V N V 1 and f1 : A N A1 are isomorphisms in Set, does this imply that f is\nan isomorphism in Grph?\nb.) If so, why; and if not, show a counterexample (where f0 and f1 are isomorphisms\nbut f is not).\n♦\nLemma 4.1.1.21. Let C be a category and let „ be the relation on ObpCq given by saying\nX „ Y iffX and Y are isomorphic. Then „ is an equivalence relation.\nProof. The proof of Lemma 2.1.2.12 can be mimicked in this more general setting.\n□\n4.1.1.22\nAnother viewpoint on categories\nHere is an alternate definition of category, using the work we did in Chapter 2.\nExercise 4.1.1.23. Suppose we begin our definition of category as follows.\nA category, C consists of a sequence pObpCq, HomC, dom, cod, ids, q, where\n1. ObpCq is a set,4\n2. HomC is a set, and dom, cod: HomC N ObpCq are functions,\n3. ids: ObpCq N HomC is a function, and\n4See Remark 4.1.1.2.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4. is a function as depicted in the commutative diagram below\nHomC\ncod\n)\ndom\n\"\nHomC ˆObpCq HomC\n✓\n✓\n\nh\n/\n\n⌟\nHomC\ncod /\ndom\n\nObpCq\nHomC\ncod\n/\ndom\n\nObpCq\nObpCq\n(4.2)\na.) Express the fact that for any x P ObpCq the morphism idx points from x to x in\nterms of the functions id, dom, cod.\nb.) Express the condition that composing a morphism f with an appropriate identity\nmorphism yields f.\nc.) Express the associativity law in these terms (Hint: Proposition 2.5.1.17 may be\nuseful).\n♦\nExample 4.1.1.24 (Partial olog for a category). Below is an olog that captures some of\nthe essential structures of a category.\na morphism\nin C\nhas as codomain\n)\nhas as domain\n\na pair pg, fq\nof composable\nmorphisms\n✓\n✓\nhas as composition\nd\nyields\nas g\n/\nyields as f\n\n⌟\na morphism\nin C\nhas as\ncodomain\n/\nhas as domain\n\nan object of C\na morphism\nin C\nhas as\ncodomain\n/\nhas as domain\n\nan object of C\nan object of C\n(4.3)\nMissing from (4.3) is the notion of identity morphism (as an arrow from ⌜an object\nof C⌝to ⌜a morphism in C⌝) and the associated path equivalences, as well as the identity\n\n4.1. CATEGORIES AND FUNCTORS\nand associativity laws. All of these can be added to the olog, at the expense of some\nclutter.\nRemark 4.1.1.25. Perhaps it is already clear that category theory is very interconnected.\nIt may feel like everything relates to everything, and this feeling may intensify as you\ngo on. However, the relationships between different notions are rigorously defined, and\nnot random. Moreover, almost everything presented in this book can be formalized in\na proof system like Coq (the most obvious exceptions being things like the readability\nrequirement of ologs and the modeling of scientific applications).\nWhenever you feel cognitive vertigo, look to formal definitions as the ground of your\nunderstanding.\nIt is good practice to make sure that the intuition you've developed\nactually \"touches down\" on that ground, i.e. that your way of thinking can be built up\nsolidly from the foundational definitions.\n4.1.2\nFunctors\nA category C \" pObpCq, HomC, dom, cod, ids, q, involves a set of objects, a set of mor-\nphisms, a notion of domains and codomains, a notion of identity morphisms, and a\ncomposition formula. For two categories to be comparable, these various components\nshould be appropriately comparable.\nDefinition 4.1.2.1. Let C and C1 be categories. A functor F from C to C1, denoted\nF : C N C1, is defined as follows: One announces some constituents (A. on-objects part,\nB. on-morphisms part) and asserts that they conform to some laws (1. preservation of\nidentities, 2. preservation of composition). Specifically, one announces\nA. a function ObpFq: ObpCq N ObpC1q, which we sometimes denote simply by\nF : ObpCq N ObpC1q; and\nB. for every pair of objects c, d P ObpCq, a function\nHomF pc, dq: HomCpc, dq N HomC1pFpcq, Fpdqq,\nwhich we sometimes denote simply by F : HomCpc, dq N HomC1pFpcq, Fpdqq.\nOne asserts that the following laws hold:\n1. Identities are preserved by F.\nThat is, for any object c P ObpCq, we have\nFpidcq \" idF pcq; and\n2. Composition is preserved by F.\nThat is, for any objects b, c, d P ObpCq and\nmorphisms g: b N c and h: c N d, we have Fph gq \" Fphq Fpgq.\nExample 4.1.2.2 (Monoids have underlying sets). Recall from Definition 3.1.1.1 that if\nM \" pM, e, ‹q is a monoid, then M is a set. And recall from Definition 3.1.4.1 that if\nf : M N M1 is a monoid homomorphism then f : M N M 1 is a function. Thus we have\na functor\nU : Mon N Set\nthat takes every monoid to its underlying set and every monoid homomorphism to its\nunderlying function.\nGiven two monoids M \" pM, e, ‹q and M1 \" pM 1, e1, ‹1q, there may be many func-\ntions from M to M 1 that do not arise from monoid homomorphisms. It is often useful to\nspeak of such functions. For example, one could assign to every command in one video\n\nCHAPTER 4. BASIC CATEGORY THEORY\ngame V a command in another video game V 1, but this may not work in the \"monoidy\nway\" when performing a sequence of commands. By being able to speak of M as a set,\nor as M as a monoid, and understanding the relationship U between them, we can be\nclear about where we stand at all times in our discussion.\nExample 4.1.2.3 (Groups have underlying monoids). Recall that a group is just a monoid\npM, e, ‹q with the extra property that every element m P M has an inverse m1 ‹ m \" e \"\nm ‹ m1. Thus to every group we can assign its underlying monoid. Similarly, a group\nhomomorphism is just a monoid homomorphism of its underlying monoids. This means\nthat there is a functor\nU : Grp N Mon\nthat sends every group or group homomorphism to its underlying monoid or monoid\nhomomorphism. That identity and composition are preserved is obvious.\nSlogan 4.1.2.4.\n\" Out of all our available actions, some are reversable. \"\nApplication 4.1.2.5. Suppose you're a scientist working with symmetries. But then sup-\npose that the symmetry breaks somewhere, or you add some extra observable which is\nnot reversible under the symmetry. You want to seamlessly relax the requirement that\nevery action be reversible without changing anything else. You want to know where you\ncan go, or what's allowed. The answer is to simply pass from the category of groups (or\ngroup actions) to the category of monoids (or monoid actions).\nWe can also reverse this change of perspective. Recall that in Example 3.1.2.9 we\ndiscussed a monoid M controlling the actions of a video game character. The character\nposition (P) could be moved up (u), moved down (d), or moved right (r). The path\nequivalences P.u.d \" P and P.d.u \" P imply that these two actions are mutually\ninverse, whereas moving right has no inverse.\nThis, plus equivalences P.r.u \" P.u.r\nand P.r.d \" P.d.r, defined a monoid M.\nInside M is a submonoid G, which includes just upward and downward movement.\nIt has one object, just like M, i.e. ObpMq \" tPu \" ObpGq. But it has fewer morphisms.\nIn fact there is a monoid isomorphism G - Z because we can assign to any movement in\nG the number of ups, e.g. P.u.u.u.u.u is assigned the integer 5, P.d.d.d is assigned the\ninteger 3, and P.d.u.u.d.d.u is assigned the integer 0 P Z. But Z is a group, because\nevery integer has an inverse.\nThus we can consider G as a group G1 P ObpGrpq or as a monoid G2 P ObpMonq.\nIt is better to consider G as a group, because groups are more structured than monoids.\nIt's as though putting G in Grp gives it more \"potential energy\" than putting it in Mon\n-- we can always \"drop it down\" from Grp to Mon, but not vice versa. The way to\nmake this precise is that we can make use of the functor U : Grp N Mon from Example\n4.1.2.3 and find that UpG1q \" G2. But to find a functor F : Mon N Grp such that\nFpG2q \" G1 would be much more ad hoc.\nThe upshot is that we can use functors to compare groups and monoids.\n♦♦\nExample 4.1.2.6. Recall that we have a category Set of sets and a category Fin of\nfinite sets. We said that Fin was a subcategory of Set. In fact we can think of this\n\"subcategory\" relationship in terms of functors, just like we thought of the \"subset\"\nrelationship in terms of functions in Example 2.1.2.3.\nThat is, if we have a subset\n\n4.1. CATEGORIES AND FUNCTORS\nS D S1, then every element s P S is an element of S1, so we make a function f : S N S1\nsuch that fpsq \" s P S1.\nTo give a functor i: Fin N Set, we have to announce how it will work on objects\nand how it will work on morphisms. We begin by announcing a function i: ObpFinq N\nObpSetq. But that's easy because ObpFinq D ObpSetq, so we proceed as above: ipSq \" S\nfor any S P ObpFinq. We also have announce, for each pair of objects S, S1 P ObpFinq,\na function\ni: HomFinpS, S1q N HomSetpS, S1q.\nBut again, that's easy because we know by definition (see Example 4.1.1.4) that these\ntwo sets are equal, HomFinpS, S1q \" HomSetpS, S1q. Hence we can simply take i to be\nthe identity function on morphisms. It is easy to see that identites and compositions are\npreserved by i. Therefore, we have defined a functor i.\nExercise 4.1.2.7 (Forgetful functors between types of orders). A partial order is just a\npreorder with a special property. A linear order is just a partial order with a special\nproperty.\na.) Is there an \"obvious\" functor FLin N PrO?\nb.) Is there an \"obvious\" functor PrO N FLin?\n♦\nProposition 4.1.2.8 (Preorders to graphs). Let PrO be the category of preorders and\nGrph be the category of graphs. There is a functor P : PrO N Grph such that for any\npreorder X \" pX, dq, the graph PpXq has vertices X.\nProof. Given a preorder X \" pX, dXq, we can make a graph FpXq with vertices X\nand an arrow x N x1 whenever x dX x1, as in Remark 3.4.1.10. More precisely, the\npreorder dX is a relation, i.e. a subset RX D X ˆ X, which we think of as a function\ni: RX N X ˆ X. Composing with projections π1, π2 : X ˆ X N X gives us\nsrcX :\" π1 i: RX N X\nand\ntgtX :\" π2 i: RX N X.\nThen we put FpXq :\" pX, RX , srcX , tgtX q. This gives us a function F : ObpPrOq N\nObpGrphq.\nSuppose now that f : X N Y is a preorder morphism (where Y \" pY, dY q). This is a\nfunction f : X N Y such that for any px, x1q P X ˆX, if x dX x1 then fpxq d fpx1q. But\nthat's the same as saying that there exists a dotted arrow making the following diagram\nof sets commute\nRX\n/\n\nX ˆ X\nfˆf\n\nRY\n/ Y ˆ Y\n(Note that there cannot be two different dotted arrows making that diagram commute\nbecause RY N Y ˆ Y is a monomorphism.) Our commutative square is precisely what's\nneeded for a graph homomorphism, as shown in Exercise 3.3.3.7. Thus, we have defined\nF on objects and on morphisms. It is clear that F preserves identity and composition.\n□\nExercise 4.1.2.9. In Proposition 4.1.2.8 we gave a functor P : PrO N Grph.\n\nCHAPTER 4. BASIC CATEGORY THEORY\na.) Is every graph G P ObpGrphq in the image of P (or more precisely, is the function\nObpPq: ObpPrOq N ObpGrphq\nsurjective)?\nb.) If so, why; if not, name a graph not in the image.\nc.) Suppose that G, H P ObpGrphq are two graphs that are in the image of P. Is every\ngraph homomorphism f : G N H in the image of HomP ? In other words, does every\ngraph homomorphism between G and H come from a preorder homomorphism?\n♦\nRemark 4.1.2.10. There is a functor W : PrO N Set sending pX, dq to X.\nThere\nis a functor T : Grph N Set sending pV, A, src, tgtq to V . When we understand the\ncategory of categories (Section 4.1.2.27), it will be clear that Proposition 4.1.2.8 can be\nsummarized as a commutative triangle in Cat,\nPrO\nP\n/\nW\n\nGrph\nT\n\nSet\nExercise 4.1.2.11 (Graphs to preorders). Recall from (2.3) that every function f : A N\nB has an image, imfpAq D B.\nUse this idea and Example 3.4.1.16 to construct a\nfunctor Im: Grph N PrO such that for any graph G \" pV, A, src, tgtq, the preorder\nhas elements given by the vertices of G (i.e. we have ImpGq \" pV, dGq, for some ordering\ndG).\n♦\nExercise 4.1.2.12. What is the preorder ImpGq when G P ObpGrphq is the following\ngraph?\nG :\"\nv‚\nf\n/ w‚\nh\n?\ng\nx‚\ny‚\ni\n\nj\nz‚\nk\n_\n♦\nExercise 4.1.2.13. Consider the functor Im: Grph N PrO constructed in Exercise\n4.1.2.11.\na.) Is every preorder X P ObpPrOq in the image of Im (or more precisely in the image\nof ObpImq: ObpGrphq N ObpPrOq)?\nb.) If so, why; if not, name a preorder not in the image.\nc.) Suppose that X, Y P ObpPrOq are two preorders that are in the image of Im. Is\nevery preorder morphism f : X N Y in the image of HomIm? In other words, does\nevery preorder homomorphism between X and Y come from a graph homomorphism?\n\n4.1. CATEGORIES AND FUNCTORS\n♦\nExercise 4.1.2.14. We have functors P : PrO N Grph and Im: Grph N PrO.\na.) What can you say about Im P : PrO N PrO?\nb.) What can you say about P Im: Grph N Grph?\n♦\nExercise 4.1.2.15. Consider the functors P : PrO N Grph and Im: Grph N PrO.\nAnd consider the chain graph rns of length n from Example 3.3.1.8 and the linear order\nrns of length n from Example 3.4.1.7. To differentiate the two, let's rename them for\nthis exercise as rnsGrph P ObpGrphq and rnsPrO P ObpPrOq.\nWe see a similarity\nbetween rnsGrph and rnsPrO, and we might hope that our functors help us formalize this\nsimilarity. That is, we might hope that one of the following hold:\nPprnsPrOq -? rnsGrph\nor\nImprnsGrphq -? rnsPrO.\nDo either, both, or neither of these hold?\n♦\nRemark 4.1.2.16. In the course announcement for 18-S996, I wrote the following:\nIt is often useful to focus ones study by viewing an individual thing, or a\ngroup of things, as though it exists in isolation.\nHowever, the ability to\nrigorously change our point of view, seeing our object of study in a different\ncontext, often yields unexpected insights. Moreover this ability to change\nperspective is indispensable for effectively communicating with and learning\nfrom others. It is the relationships between things, rather than the things\nin and by themselves, that are responsible for generating the rich variety\nof phenomena we observe in the physical, informational, and mathematical\nworlds.\nThis holds at many different levels. For example, one can study a group (in the sense of\nDefinition 3.2.1.1) in isolation, trying to understand its subgroups or its automorphisms,\nand this is mathematically interesting. But one can also view it as a quotient of something\nelse, or as a subgroup of something else. One can view the group as a monoid and look\nat monoid homomorphisms to or from it. One can look at the group in the context of\nsymmetries by seeing how it acts on sets. These changes of viewpoint are all clearly\nand formally expressible within category theory. We know how the different changes of\nviewpoint compose and how they fit together in a larger context.\nExercise 4.1.2.17.\na.) Is the above quote also true in your scientific discipline of expertise? How so?\nb.) Can you imagine a way that category theory can help catalogue the kinds of rela-\ntionships or changes of viewpoint that exist in your discipline?\nc.) What kinds of structures that you use often really deserve to be better formalized?\nKeep this kind of question in mind for your final project.\n♦\nExample 4.1.2.18 (Free monoids). Let G be a set. We saw in 3.1.1.15 that ListpGq is a\nmonoid, called the free monoid on G. Given a function f : G N G1, there is an induced\nfunction Listpfq: ListpGq N ListpG1q, and this preserves the identity element r s and\nconcatenation of lists, so Listpfq is a monoid homomorphism. It is easy to check that\nList: Set N Mon is a functor.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nApplication 4.1.2.19. In Application 2.1.2.10 we discussed an isomorphism NucDNA -\nNucRNA given by RNA transcription. Applying the functor List we get a function\nListpNucDNAq -\nYN ListpNucRNAq,\nwhich will send sequences of DNA nucleotides to sequences of RNA nucleotides and vice\nversa. This is performed by polymerases.\n♦♦\nExercise 4.1.2.20. Let G \" t1, 2, 3, 4, 5u, G1 \" ta, b, cu, and let f : G N G1 be given by\nthe sequence pa, c, b, a, cq.5 Then if L \" r1, 1, 3, 5, 4, 5, 3, 2, 4, 1s, what is ListpfqpLq?\n♦\nExercise 4.1.2.21. We can rephrase our notion of functor in terms compatible with Ex-\nercise 4.1.1.23. We would begin by saying that a functor F : C N C1 consists of two\nfunctions,\nObpFq: ObpCq N ObpC1q\nand\nHomF : HomC N HomC1,\nwhich we call the on-objects part and the on-morphisms part, respectively. They must\nfollow some rules, expressed by the commutativity of the following squares in Set:\nHomC\ndom /\nHomF\n\nObpCq\nObpF q\n\nHomC1\ndom / ObpC1q\nHomC\ncod /\nHomF\n\nObpCq\nObpF q\n\nHomC1\ncod / ObpC1q\n(4.4)\nObpCq\nObpF q\n\nid\n/ HomC\nHomF\n\nObpC1q\nid\n/ HomC1\nHomC ˆObpCq HomC\n\n/\n\nHomC\nHomF\n\nHomC1 ˆObpC1q HomC1\n\n/ HomC1\n(4.5)\nWhere does the (unlabeled) left-hand function in the bottom right diagram come from?\nHint: use Exercise 2.5.1.19.\nConsider Diagram (4.2) and imagine it as though contained in a pane of glass. Then\nimagine a parallel pane of glass involving C1 in place of C everywhere.\na.) Draw arrows from the C pane to the C1 pane, each labeled ObpFq or HomF as seems\nappropriate.\nb.) If F is a functor (i.e. satisfies (4.4) and (4.5)), do all the squares in your drawing\ncommute?\nc.) Does the definition of functor involve anything not captured in this setup?\n♦\nExample 4.1.2.22 (Paths-graph). Let G \" pV, A, src, tgtq be a graph. Then for any pair of\nvertices v, w P G, there is a set PathGpv, wq of paths from v to w; see Definition 3.3.2.1.\n5See Exercise 2.1.2.15 in case there is any confusion with this.\n\n4.1. CATEGORIES AND FUNCTORS\nIn fact there is a set PathG and functions src, tgt: PathG N V . That information is\nenough to define a new graph,\nPathspGq :\" pV, PathG, src, tgtq.\nMoreover, given a graph homomorphism f : G N G1, every path in G is sent under f\nto a path in G1. So Paths: Grph N Grph is a functor.\nExercise 4.1.2.23.\na.) Consider the graph G from Example 3.3.3.3. Draw the paths-graph PathspGq for G.\nb.) Repeating the above exercise for G1 from the same example would be hard, because\nthe path graph PathspG1q has infinitely many arrows. However, the graph homomor-\nphism f : G N G1 does induce a morphism of paths-graphs Pathspfq: PathspGq N\nPathspG1q, and it is possible to say how that acts on the vertices and arrows of\nPathspGq. Please do so.\nc.) Given a graph homomorphism f : G N G1 and two paths p: v N w and q: w N x in\nG, is it true that Pathspfq preserves the concatenation? What does that even mean?\n♦\nExercise 4.1.2.24. Suppose that C and D are categories, c, c1 P ObpCq are objects, and\nF : C N D is a functor. Suppose that c and c1 are isomorphic in C. Show that this\nimplies that Fpcq and Fpc1q are isomorphic in D.\n♦\nExample 4.1.2.25. For any graph G, we can assign its set of loops EqpGq as in Exercise\n3.3.1.12. This assignment is functorial in that given a graph homomorphism G N G1\nthere is an induced function EqpGq N EqpG1q. Similarly, we can functorially assign the\nset of connected components of the graph, CoeqpGq. In other words Eq: Grph N Set\nand Coeq: Grph N Set are functors. The assignment of vertex set and arrow set are\ntwo more functors Grph N Set.\nSuppose you want to decide whether two graphs G and G1 are isomorphic. Supposing\nthat the graphs have thousands of vertices and thousands of arrows, this could take a\nlong time. However, the functors above, in combination with Exercise 4.1.2.24 give us\nsome things to try.\nThe first thing to do is to count the number of loops of each, because these numbers\nare generally small. If the number of loops in G is different than the number of loops\nin G1 then because functors preserve isomorphisms, G and G1 cannot be isomorphic.\nSimilarly one can count the number of connected components, again generally a small\nnumber; if the number of components in G is different than the number of components\nin G1 then G - G1. Similarly, one can simply count the number of vertices or the number\nof arrows in G and G1. These are all isomorphism invariants.\nAll this is a bit like trying to decide if a number is prime by checking if it's even, if\nits digits add up to a multiple of 3, or it ends in a 5; these tests do not determine the\nanswer, but they offer some level of discernment.\nRemark 4.1.2.26. In the introduction I said that functors allow ideas in one domain to\nbe rigorously imported to another. Example 4.1.2.25 is a first taste. Because functors\npreserve isomorphisms, we can tell graphs apart by looking at them in a simpler category,\nSet.\nThere is relatively simple theorem in Set that says that for different natural\nnumbers m, n the sets m and n are never isomorphic. This theorem is transported via\nour four functors to four different theorems about telling graphs apart.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.1.2.27\nThe category of categories\nRecall from Remark 4.1.1.2 that a small category C is one in which ObpCq is a set. We\nhave not really been paying attention to this issue, and everything we have said so far\nworks whether C is small or not. In the following definition we really ought to be a little\nmore careful, so we are.\nProposition 4.1.2.28. There exists a category, called the category of small categories\nand denoted Cat, in which the objects are the small categories and the morphisms are\nthe functors,\nHomCatpC, Dq \" tF : C N D | F is a functoru.\nThat is, there are identity functors, functors can be composed, and the identity and\nassociativity laws hold.\nProof. We follow Definition 4.1.1.1. We have specified ObpCatq and HomCat already.\nGiven a small category C, there is an identity functor idC : C N C that is identity on the\nset of objects and the set of morphisms. And given a functor F : C N D and a functor\nG: D N E, it is easy to check that G F : C N E, defined by composition of functions\nObpGq ObpFq: ObpCq N ObpEq and HomG HomF : HomC N HomE (see Exercise\n4.1.2.21), is a functor. For the same reasons, it is easy to show that functors obey the\nidentity law and the composition formula. Therefore this specification of Cat satisfies\nthe definition of being a category.\n□\nExample 4.1.2.29 (Categories have underlying graphs). Let C \" pObpCq, HomC, dom, cod, ids, q\nbe a category (see Exercise 4.1.1.23). Then pObpCq, HomC, dom, codq is a graph, which we\nwill call the graph underlying C and denote by UpCq P ObpGrphq. A functor F : C N D\ninduces a graph morphism UpFq: UpCq N UpDq, as seen in (4.4). So we have a functor,\nU : Cat N Grph.\nExample 4.1.2.30 (Free category on a graph). In Example 4.1.2.22, we discussed a functor\nPaths: Grph N Grph that considered all the paths in a graph G as the arrows of a\nnew graph PathspGq. In fact, PathspGq could be construed as a category, which we will\ndenote FpGq P ObpCatq and call the free category generated by G.\nHere, the objects of the category FpGq are the vertices of G. For any two vertices v, v1\nthe hom-set HomF pGqpv, v1q is the set of paths in G from v to v1. The identity elements\nare given by the trivial paths, and the composition formula is given by concatenation of\npaths.\nTo see that F is a functor, we need to see that a graph homomorphism f : G N G1\ninduces a functor Fpfq: FpGq N FpG1q. But this was shown in Exercise 4.1.2.23. Thus\nwe have a functor\nF : Grph N Cat\ncalled the free category functor.\nExercise 4.1.2.31. Let G be the graph depicted\nv0‚\ne\nYYYYYN\nv1‚,\nand let r1s P ObpCatq denote the free category on G (see Example 4.1.2.30). We call r1s\nthe free arrow category.\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS129\na.) What are its objects?\nb.) For every pair of objects in r1s, write down the hom-set.\n♦\nExercise 4.1.2.32. Let G be the graph whose vertices are all cities in the US and whose\narrows are airplane flights connecting cities. What idea is captured by the free category\non G?\n♦\nExercise 4.1.2.33. Let F : Grph N Cat denote the free category functor from Example\n4.1.2.30, and let U : Cat N Grph denote the underlying graph functor from Example\n4.1.2.29. We have seen the composition U F : Grph N Grph before; what was it\ncalled?\n♦\nExercise 4.1.2.34. Recall the graph G from Example 3.3.1.2. Let C \" FpGq be the free\ncategory on G.\na.) What is HomCpv, xq?\nb.) What is HomCpx, vq?\n♦\nExample 4.1.2.35 (Discrete graphs, discrete categories). There is a functor Disc: Set N\nGrph that sends a set S to the graph\nDiscpSq :\" pS, H, !, !q,\nwhere !: H N S is the unique function. We call DiscpSq the discrete graph on the set S.\nIt is clear that a function S N S1 induces a morphism of discrete graphs. Now applying\nthe free category functor F : Grph N Cat, we get the so-called discrete category on the\nset S, which we also might call Disc: Set N Cat.\nExercise 4.1.2.36. Recall from (2.6) the definition of the set n for any natural number\nn P N, and let Dn :\" Discpnq P ObpCatq.\na.) List all the morphisms in D4.\nb.) List all the functors D3 N D2.\n♦\nExercise 4.1.2.37 (Terminal category). Let C be a category. How many functors are there\nC N D1, where D1 :\" Discp1q is the discrete category on one element?\n♦\nWe sometimes refer to Discp1q as the terminal category (for reasons that will be made\nclear in Section 4.5.3), and for simplicity denote it by 1.\nExercise 4.1.2.38. If someone said \"Ob is a functor from Cat to Set,\" what might they\nmean?\n♦\n4.2\nCategories and functors commonly arising in math-\nematics\n4.2.1\nMonoids, groups, preorders, and graphs\nWe saw in Section 4.1.1 that there is a category Mon of monoids, a category Grp of\ngroups, a category PrO of preorders, and a category Grph of graphs. In this section we\n\nCHAPTER 4. BASIC CATEGORY THEORY\nshow that each monoid M, each group G, and each preorder P can be considered as its\nown category. If each object in Mon is a category, we might hope that each morphism\nin Mon is just a functor, and this is true. The same holds for Grp and PrO. We will\ndeal with graphs in Section 4.2.1.20.\n4.2.1.1\nMonoids as categories\nIn Example 3.1.2.9 we said that to olog a monoid, we should use only one box. And\nagain in Example 3.5.3.3 we said that a monoid action could be captured by only one\ntable. These ideas emanated from the understanding that a monoid is perfectly modeled\nas a category with one object.\nEach monoid as a category with one object\nLet pM, e, ‹q be a monoid.\nWe\nconsider it as a category M with one object, ObpMq \" t▲u, and\nHomMp▲, ▲q :\" M.\nThe identity morphism id▲serves as the monoid identity e, and the composition formula\n: HomMp▲, ▲q ˆ HomMp▲, ▲q N HomMp▲, ▲q\nis given by ‹: M ˆ M N M. The associativity and identity laws for the monoid match\nprecisely with the associativity and identity laws for categories.\nIf monoids are categories with one object, is there any categorical way of phrasing the\nnotion of monoid homomorphism? Suppose that M \" pM, e, ‹q and M1 \" pM 1, e1, ‹1q.\nWe know that a monoid homomorphism is a function f : M N M 1 such that fpeq \" e1\nand such that for every pair m0, m1 P M we have fpm0 ‹ m1q \" fpm0q ‹1 fpm1q. What\nis a functor M N M1?\nEach monoid homomorphism as a functor between one-object categories\nSay\nthat ObpMq \" t▲u and ObpM1q \" t▲1u; and we know that HomMp▲, ▲q \" M and\nHomM1p▲1, ▲1q \" M 1. A functor F : M N M1 consists first of a function ObpMq N\nObpM1q, but these sets have only one element each, so there is nothing to say on that\nfront. It also consists of a function HomM N homM1 but that is just a function M N M 1.\nThe identity and composition formulas for functors match precisely with the identity and\ncomposition formula for monoid homomorphisms, as discussed above. Thus a monoid\nhomomorphism is nothing more than a functor between one-object categories.\nSlogan 4.2.1.2.\n\" A monoid is a category G with one object. A monoid homomorphism is\njust a functor between one-object categories. \"\nWe formalize this as the following theorem.\nTheorem 4.2.1.3. There is a functor i: Mon N Cat with the following properties:\n- for every monoid M P ObpMonq, the category ipMq P ObpCatq itself has exactly\none object,\n|ObpipMqq| \" 1\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS131\n- for every pair of monoids M, M1 P ObpMonq the function\nHomMonpM, M1q -\nYN HomCatpipMq, ipM1qq,\ninduced by the functor i, is a bijection.\nProof. This is basically the content of the preceding paragraphs. The functor i sends a\nmonoid to the corresponding category with one object and i sends a monoid homomor-\nphism to the corresponding functor; it is not hard to check that i preserves identities\nand compositions.\n□\nTheorem 4.2.1.3 situates the theory of monoids very nicely within the world of cate-\ngories. But we have other ways of thinking about monoids, namely their actions on sets.\nAs such it would greatly strengthen the story if we could subsume monoid actions within\ncategory theory also, and we can.\nEach monoid action as a set-valued functor\nRecall from Definition 3.1.2.1 that if\npM, e, ‹q is a monoid, an action consists of a set S and a function u: M ˆ S N S such\nthat e u s \" s and m0 u pm1 u sq \" pm0 ‹ m1q u s for all s P S. How might we relate\nthe notion of monoid actions to the notion of functors? One idea is to try asking what\na functor F : M N Set is; this idea will work.\nSince M has only one object, we obtain one set, S :\" Fp▲q P ObpSetq. We also\nobtain a function HomF : HomMp▲, ▲q N HomSetpFp▲q, Fp▲qq, or more concisely, a\nfunction\nHF : M N HomSetpS, Sq.\nBy currying (see Proposition 2.7.2.3), this is the same as a function u: M ˆS N S. The\nrule that e u s \" s becomes the rule that functors preserve identities, HomF pid▲q \" idS.\nThe other rule is equivalent to the composition formula for functors.\n4.2.1.4\nGroups as categories\nA group is just a monoid pM, e, ‹q in which every element m P M is invertible, meaning\nthere exists some m1 P M with m ‹ m1 \" e \" m1 ‹ m. If a monoid is the same thing\nas a category M with one object, then a group must be a category with one object\nand with an additional property having to do with invertibility. The elements of M are\nthe morphisms of the category M, so we need a notion of invertibility for morphisms.\nLuckily we have such a notion already, namely isomorphism. We have the following:\nSlogan 4.2.1.5.\n\" A group is a category G with one object, such that every morphism in G\nis an isomorphism. A group homomorphism is just a functor between such\ncategories. \"\nTheorem 4.2.1.6. There is a functor i: Grp N Cat with the following properties:\n- for every group G P ObpGrpq, the category ipGq P ObpCatq itself has exactly one\nobject, and every morphism m in ipGq is an isomorphism; and\n\nCHAPTER 4. BASIC CATEGORY THEORY\n- for every pair of groups G, G1 P ObpGrpq the function\nHomGrppG, G1q -\nYN HomCatpipGq, ipG1qq,\ninduced by the functor i, is a bijection.\nJust as with monoids, an action of some group pG, e, ‹q on a set S P ObpSetq is the\nsame thing as a functor G N Set sending the unique object of G to the set S.\n4.2.1.7\nMonoid and group stationed at each object in a category\nIf a monoid is just a category with one object, we can locate monoids in any category C\nby narrowing our gaze to one object in C. Similarly for groups.\nExample 4.2.1.8 (Endomorphism monoid). Let C be a category and x P ObpCq an object.\nLet M \" HomCpx, xq. Note that for any two elements f, g P M we have f g: x N x\nin M. Let M \" pM, idx, q. It is easy to check that M is a monoid; it is called the\nendomorphism monoid of x in C.\nExample 4.2.1.9 (Automorphism group). Let C be a category and x P ObpCq an object.\nLet G \" tf : x N x | f is an isomorphismu. Let G \" pG, idx, q. It is easy to check that\nG is a group; it is called the automorphism group of x in C.\nExercise 4.2.1.10. Let S \" t1, 2, 3, 4u P ObpSetq.\na.) What is the automorphism group of S in Set, and how many elements does this\ngroup have?\nb.) What is the endomorphism monoid of S in Set, and how many elements does this\nmonoid have?\nc.) Recall from Example 4.1.2.3 that every group has an underlying monoid UpGq; is\nthe endomorphism monoid of S the underlying monoid of the automorphism group\nof S?\n♦\nExercise 4.2.1.11. Consider the graph G depicted below.\n1‚\n,\n\n2‚\n\nl\n3‚\n,\nL\n4‚\nL\nl\nWhat is its group of automorphisms? Hint: every automorphism of G will induce an\nautomorphism of the set t1, 2, 3, 4u; which ones will preserve the arrows?\n♦\n4.2.1.12\nPreorders as categories\nA preorder pX, dq consists of a set X and a binary relation d that is reflexive and\ntransitive. We can make from pX, dq P ObpPrOq a category X P ObpCatq as follows.\nDefine ObpXq \" X and for every two objects x, y P X define\nHomX px, yq \"\n#\nt\"x d y\"u\nif x d y\nH\nif x e y\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS133\nTo clarify: if x d y, we assign HomX px, yq to be the set containing only one element,\nnamely the string \"x d y\".6 If px, yq is not in relation d, then we assign HomX px, yq to\nbe the empty set. The composition formula\n: HomX px, yq ˆ HomX py, zq N HomX px, zq\n(4.6)\nis completely determined because either one of two possibilities occurs. One possibility\nis that the left-hand side is empty (if either x e y or y e z; in this case there is a unique\nfunction as in (4.6). The other possibility is that the left-hand side is not empty in\ncase x d y and y d, which implies x d z, so the right-hand side has exactly one element\n\"x d z\" in which case again there is a unique function as in (4.6).\nOn the other hand, if C is a category having the property that for every pair of objects\nx, y P ObpCq, the set HomCpx, yq is either empty or has one element, then we can form\na preorder out of C. Namely, take X \" ObpCq and say x d y if there exists a morphism\nx N y in C.\nExercise 4.2.1.13. We have seen that a preorder can be considered as a category P. Recall\nfrom Definition 3.4.1.1 that a partial order is a preorder with an additional property.\nPhrase the defining property for partial orders in terms of isomorphisms in the category\nP.\n♦\nExercise 4.2.1.14. Suppose that C is a preorder (considered as a category). Let x, y P\nObpCq be objects such that x d y and y d x. Prove that there is an isomorphism x N y\nin C.\n♦\nExample 4.2.1.15. The olog from Example 3.4.1.3 depicted a partial order, say P. In it\nwe have\nHomPp⌜a diamond⌝, ⌜a red card⌝q \" tisu\nand we have\nHomPp⌜a black queen⌝, ⌜a card⌝q - tis isu;\nBoth of these sets contain exactly one element, the name is not important. The set\nHomPp⌜a 4⌝, ⌜a 4 of diamonds⌝q \" H.\nExercise 4.2.1.16. Every linear order is a partial order with a special property. Can you\nphrase this property in terms of hom-sets?\n♦\nProposition 4.2.1.17. There is a functor i: PrO N Cat with the following properties\nfor every preorder pX, dq:\n1. the category X :\" ipX, dq has objects ObpXq \" X; and\n2. for each pair of elements x, x1 P ObpXq the set HomX px, x1q has at most one\nelement.\nMoreover, any category with property 2 is in the image of the functor i.\nProof. To specify a functor i: PrO N Cat, we need to say what it does on objects and\non morphisms. To an object pX, dq in PrO, we assign the category X with objects X\nand a unique morphism from x N x1 if x d x1; this was discussed at the top of Section\n4.2.1.12. To a morphism f : pX, dXq N pY, dY q of preorders, we must assign a functor\nipfq: X N Y. Again, to specify a functor we need to say what it does on objects and\n6The name of this morphism is completely unimportant.\nWhat matters is that HomX px, yq has\nexactly one element iffx d y.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nmorphisms of X. To an object x P ObpXq \" X, we assign the object fpxq P Y \" ObpYq.\nGiven a morphism f : x N x1 in X, we know that x d x1 so by Definition 3.4.4.1 we\nhave that fpxq d fpx1q, and we assign to f the unique morphism fpxq N fpx1q in Y. To\ncheck that the rules of functors (preservation of identities and composition) are obeyed\nis routine.\n□\nSlogan 4.2.1.18.\n\" A preorder is a category in which every hom-set has either 0 elements or 1\nelement. A preorder morphism is just a functor between such categories. \"\nExercise 4.2.1.19. Recall the functor P : PrO N Grph from Proposition 4.1.2.8, the\nfunctors F : Grph N Cat and U : Cat N Grph from Example 4.1.2.33, and the functor\ni: PrO N Cat from Proposition 4.2.1.17.\na.) Do either of the following diagrams of categories commute?\nPrO\nP\n/\ni\n\n?\nGrph\nF\n\nCat\nPrO\nP\n/\ni\n\n?\nGrph\nCat\nU\nA\nb.) We also had a functor Grph N PrO. Does the following diagram of categories\ncommute?\nGrph\n/\nF\n\n?\nPrO\ni\n\nCat\n♦\n4.2.1.20\nGraphs as functors\nLet C denote the category depicted below\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\n(4.7)\nThen a functor G: GrIn N Set is the same thing as two sets GpArq, GpVeq and two\nfunctions Gpsrcq: GpArq N GpVeq and Gptgtq: GpArq N GpVeq. This is precisely what\nis needed for a graph; see Definition 3.3.1.1. We call GrIn the graph indexing category.\nExercise 4.2.1.21. Consider the terminal category, 1, also known as the discrete category\non one element (see Exercise 4.1.2.37). Let GrIn be as in (4.7) and consider the functor\ni0 : 1 N GrIn sending the object of 1 to the object V P ObpGrInq. If G: GrIn N Set\nis a graph, what is the composite G i0? It consists of only one set; what set is it? For\nexample, what set is it when G is the graph from Example 3.3.3.3.\n♦\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS135\nIf a graph is a functor GrIn N Set, what is a graph homomorphism?\nWe will\nsee later in Example 4.3.1.17 that graph homomorphisms are homomorphisms between\nfunctors, which are called natural transformations. (Natural transformations are the\nhighest-\"level\" structure that occurs in ordinary category theory.)\nExample 4.2.1.22. Let D be the category depicted below\nD :\"\nA‚\nρ\nsrc /\ntgt /\nV‚\n(4.8)\nwith the following composition formula:\nρ ρ \" idA;\nsrc ρ \" tgt;\nand\ntgt ρ \" src.\nThe idea here is that the morphism ρ: A N A reverses arrows. The PED ρ ρ \" idA\nforces the fact that the reverse of the reverse of an arrow yields the original arrow. The\nPEDs src ρ \" tgt and tgt ρ \" src force the fact that when we reverse an arrow, its\nsource and target switch roles.\nThis category D is the symmetric graph indexing category. Just like any graph can\nbe understood as a functor GrIn N Set, where GrIn is the graph indexing category\ndisplayed in (4.7), any symmetric graph can be understood as a functor D N Set, where\nD is the category drawn above. Given a functor G: D N Set, we will have a set of\narrows, a set of vertices, a source operation, a target operation, and a \"reverse direction\"\noperation that all behave as expected.\nIt is customary to draw the connections in a symmetric graph as line segments rather\nthan arrows between vertices. However, a better heuristic is to think that each connection\nbetween vertices consists of two arrows, one pointing in each direction.\nSlogan 4.2.1.23.\n\" In a symmetric graph, every arrow has an equal and opposite arrow. \"\nExercise 4.2.1.24. Which of the following graphs are symmetric:\na.) The graph G from (3.4)?\nb.) The graph G from Exercise 3.3.1.10?\nc.) The graph G1 from (3.7)?\nd.) The graph Loop from (3.17), i.e. the graph having exactly one vertex and one arrow?\ne.) The graph G from Exercise 4.2.1.11?\n♦\nExercise 4.2.1.25. Let GrIn be the graph indexing category shown in (4.7) and let D be\nthe symmetric graph indexing category displayed in (4.8).\na.) How many functors are there of the form GrIn N D?\nb.) Is one more \"reasonable\" than the others?\nc.) Choose the one that seems most reasonable and call it i: GrIn N D. If a symmetric\ngraph is a functor S : D N Set, you can compose with i to get a functor S i: GrIn N\nSet. This is a graph; what graph is it? What has changed?\n♦\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.2.2\nDatabase schemas present categories\nRecall from Definition 3.5.2.6 that a database schema (or schema, for short) consists of a\ngraph together with a certain kind of equivalence relation on its paths. In Section 4.4.1\nwe will define a category Sch that has schemas as objects and appropriately modified\ngraph homomorphisms as morphisms. In Section 4.4.2 we prove that the category of\nschemas is equivalent (in the sense of Definition 4.3.4.1) to the category of categories,\nSch » Cat.\nThe difference between schemas and categories is like the difference between monoid\npresentations, given by generators and relations as in Definition 3.1.1.17, and the monoids\nthemselves. The same monoid has (infinitely) many different presentations, and so it is\nfor categories: many different schemas can present the same category. Computer scien-\ntists may think of the schema as syntax and the category it presents as the corresponding\nsemantics. A schema is a compact form, and can be specified in finite space and time\nwhile generating something infinite.\nSlogan 4.2.2.1.\n\" A database schema is a category presentation. \"\nWe will formally show in Section 4.4.2 how to turn a schema into a category (the\ncategory it presents). For now, it seems pedagogically better not to be so formal, because\nthe idea is fairly straightforward. Suppose given a schema S, which consists of a graph\nG \" pV, A, src, tgtq equipped with a congruence „ (see Definition 3.5.2.3). It presents a\ncategory C defined as follows. The set of objects in C is defined to be the vertices V ; the\nset of morphisms in C is defined to be the quotient PathspGq{ „; and the composition\nlaw is concatenation of paths. The path equivalences making up „ become commutative\ndiagrams in C.\nExample 4.2.2.2. The schema Loop, depicted below, has no path equivalence declarations.\nAs a graph it has one vertex and one arrow.\nLoop :\"\ns‚\nf\n\nThe category it generates, however, is the free monoid on one generator, N. It has one\nobject ▲but a morphism f n : ▲N ▲for every natural number n P N, thought of as\n\"how many times to go around the loop f\". Clearly, the schema is more compact that\nthe infinite category it generates.\nExercise 4.2.2.3. Consider the olog from Exercise 3.5.2.18, which says that for any father\nx, his first child's father is x. It is redrawn below as a schema S, and we include the\ndesired path equivalence declaration, F c f \" F,\nF‚\nc\n/ C‚\nf\n_\nHow many morphisms are there (total) in the category generated by S?\n♦\nExercise 4.2.2.4. Suppose that G is a graph and that G is the schema generated by G\nwith no PEDs. What is the relationship between the category generated by G and the\nfree category FpGq P ObpCatq as defined in Example 4.1.2.30?\n♦\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS137\n4.2.2.5\nInstances on a schema C\nIf schemas are like categories, what are instances? Recall that an instance I on a schema\nS \" pG, »q assigns to each vertex v in G a set of rows say Ipvq P ObpSetq. And to every\narrow a: v N v1 in G the instance assigns a function Ipaq: Ipvq N Ipv1q. The rule is that\ngiven two equivalent paths, their compositions must give the same function. Concisely,\nan instance is a functor I : S N Set.\nExample 4.2.2.6. We have now seen that a monoid is just a category M with one ob-\nject and that a monoid action is a functor M N Set.\nUnder our understanding of\ndatabase schemas as categories, M is a schema and so an action becomes an instance\nof that schema. The monoid action table from Example ex:action table was simply a\nmanifestation of the database instance according to the Rules 3.5.2.8.\nExercise 4.2.2.7. In Section 4.2.1.20 we discuss how each graph is a functor GrIn N Set\nfor the graph indexing category depicted below:\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\nBut now we know that if a graph is a set-valued functor then we can consider GrIn as\na database schema.\na.) How many tables, and how many columns of each should there be (if unsure, consult\nRules 3.5.2.8)?\nb.) Write out the table view of graph G from Example 3.3.3.3.\n♦\n4.2.3\nSpaces\nCategory theory was invented for use in algebraic topology, and in particular to discuss\nnatural transformations between certain functors. We will get to natural transformations\nmore formally in Section 4.3. For now, they are ways of relating functors. In the original\nuse, Eilenberg and Mac Lane were interested in functors that connect topological spaces\n(shapes like spheres, etc.) to algebraic systems (groups, etc.)\nFor example, there is a functor that assigns to each space X its group π1pXq of round-\ntrip voyages (starting and ending at some chosen point x P X), modulo some equivalence\nrelation. There is another functor that assigns to every space its group H1pX, Zq of ways\nto drop some (positive or negative) number of circles on X. These two functors are\nrelated, but they are not equal.\nThere is a relationship between the functor π1 and the functor H1. For example\nwhen X is the figure-8 space (two circles joined at a point) the group π1pXq is much\nbigger than the group H1pXq. Indeed π1pXq includes information about the order and\ndirection of loops traveled; whereas the group H1pX, Zq includes only information about\nhow many times one goes around each loop. However, there is a natural transformation\nof functors π1p q N H1p , Zq, called the Hurewicz transformation, which \"forgets\" the\nextra information and thus yields a simplification.\nExample 4.2.3.1. Given a set X, recall that PpXq denotes the set of subsets of X. A\ntopology on X is a choice of which subsets U P PpXq will be called open sets. The union\nof any number of open sets must be considered to be an open set, and the intersection\n\nCHAPTER 4. BASIC CATEGORY THEORY\nof any finite number of open sets must be considered open. One could say succinctly\nthat a topology on X is a sub-order OpenpXq D PpXq that is closed under taking finite\nmeets and infinite joins.\nA topological space is a pair pX, OpenpXqq, where X is a set and OpenpXq is a\ntopology on X. The elements of the set X are called points. A morphism of topological\nspaces (also called a continuous map) is a function f : X N Y such that for every\nV P OpenpY q the preimage f 1pV q P PpXq is actually in OpenpXq. That is, such that\nthere exists a dashed arrow making the diagram below commute:\nOpenpY q\n/\n\nOpenpXq\n\nPpY q\nf 1\n/ PpXq.\nThe category of topological spaces, denoted Top, is the category having objects and\nmorphisms as above.\nExercise 4.2.3.2.\na.) Explain how \"looking at points\" gives a functor Top N Set.\nb.) Does \"looking at open sets\" give a functor Top N PrO?\n♦\nExample 4.2.3.3 (Continuous dynamical systems). The set R can be given a topology in\na standard way.7 But pR, 0, `q is also a monoid. Moreover, for every x P R the monoid\noperation `: R ˆ R N R is continuous. 8 So we say that R :\" pR, 0, `q is a topological\nmonoid.\nRecall from Section 4.2.1.1 that a monoid action is a functor M N Set, where M\nis a monoid. Instead imagine a functor a: R N Top? Since R is a category with one\nobject, this amounts to an object X P ObpTopq, a space. And to every real number\nt P R we obtain a continuous map aptq: X N X. If we consider X as the set of states\nof some system and R as the time line, we have captured what is called a continuous\ndynamical system.\nExample 4.2.3.4. Recall (see [Axl]) that a real vector space is a set X, elements of which\nare called vectors, which is closed under addition and scalar multiplication. For example\nR3 is a vector space. A linear transformation from X to Y is a function f : X N Y that\nappropriately preserves addition and scalar multiplication. The category of real vector\nspaces, denoted VectR, has as objects the real vector spaces and as morphisms the linear\ntransformations.\nThere is a functor VectR N Grp sending a vector space to its underlying group of\nvectors, where the group operation is addition of vectors and the group identity is the\n0-vector.\nExercise 4.2.3.5. Every vector space has vector subspaces, ordered by inclusion (the\norigin is inside of any line which is inside of certain planes, etc., and all are inside of the\nwhole space V ). If you know about this topic, answer the following questions.\n7The topology is given by saying that U D R is open ifffor every x P U there exists ε a 0 such that\nty P R | |y x| a εu D Uu. One says, \"U D R is open if every point in U has an epsilon-neighborhood\nfully contained in U\".\n8The topology on R ˆ R is similar; a subset U D R ˆ R is open if every point x P U has an epsilon-\nneighborhood (a disk around x of some positive radius) fully contained in U.\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS139\na.) Does a linear transformation V N V 1 induce a morphism of these orders? In other\nwords, is there a functor VectR N PrO?\nb.) Would you guess that there is a nice functor VectR N Top? By a \"nice functor\" I\nmean one that doesn't make people roll their eyes (for example, there is a functor\nVectR N Top that sends every vector space to the empty space, and that's not\nreally a \"nice\" one. If someone asked for a functor VectR N Top for their birthday,\nthis functor would make them sad. We're looking for a functor VectR N Top that\nwould make them happy.)\n♦\n4.2.3.6\nGroupoids\nGroupoids are like groups except a groupoid can have more than one object.\nDefinition 4.2.3.7. A groupoid is a category C such that every morphism is an isomor-\nphism. If C and D are groupoids, a morphism of groupoids, denoted F : C N D, is simply\na functor. The category of groupoids is denoted Grpd.\nExample 4.2.3.8. There is a functor Grpd N Cat, sending a groupoid to its underlying\ncategory. There is also a functor Grp N Grpd sending a group to \"itself as a groupoid\nwith one object.\"\nApplication 4.2.3.9. Let M be a material in some original state s0.9 Construct a category\nSM whose objects are the states of M, e.g. by pulling on M in different ways, or by\nheating it up, etc. we obtain such states. Include a morphism from state s to state\ns1 if there exists a physical transformation from s to s1. Physical transformations can\nbe performed one after another, so we can compose morphisms, and perhaps we can\nagree this composition is associative. Note that there exists a morphism is : s0 N s for\nany s. Note also that this category is a preorder because there either exists a physical\ntransformation or there does not. 10\nThe elastic deformation region of the material is the set of states s such that there\nexists a morphism s N s0, because any such morphism will be the inverse of is : s0 N s.\nA transformation is irreversible if there is no transformation back. If s1 is not in the\nelastic deformation region, we can (inventing a term) still talk about the region that is\n\"elastically-equivalent\" to s1. It is all the objects in SM that are isomorphic to s1. If we\nconsider only elastic equivalences, we are looking at a groupoid sitting inside the larger\ncategory SM.\n♦♦\nExample 4.2.3.10. Alan Weinstein explains groupoids in terms of tiling patterns on a\nbathroom floor, see [WeA].\nExample 4.2.3.11. Let I \" tx P R | 0 d x d 1u denote the unit interval. It can be given\na topology in a standard way, as a subset of R (see Example 4.2.3.3)\nFor any space X, a path in X is a continuous map I N X. Two paths are called\nhomotopic if one can be continuously deformed to the other, where the deformation\n9This example may be a bit crude, in accordance with the crudeness of my understanding of materials\nscience.\n10Someone may choose to beef this category up to include the set of physical processes between states\nas the hom-set. This gives a category that is not a preorder. But there would be a functor from their\ncategory to ours.\n\nCHAPTER 4. BASIC CATEGORY THEORY\noccurs completely within X. 11 One can prove that being homotopic is an equivalence\nrelation on paths.\nPaths in X can be composed, one after the other, and the composition is associative\n(up to homotopy). Moreover, for any point x P X there is a trivial path (that stays at\nx). Finally every path is invertible (by traversing it backwards) up to homotopy.\nThis all means that to any space X P ObpTopq we can associate a groupoid, called\nthe fundamental groupoid of X and denoted Π1pXq P ObpGrpdq. The objects of Π1pXq\nare the points of X; the morphisms in Π1pXq are the paths in X (up to homotopy). A\ncontinuous map f : X N Y can be composed with any path I N X to give a path I N Y\nand this preserves homotopy. So in fact Π1 : Top N Grpd is a functor.\nExercise 4.2.3.12. Let T denote the surface of a donut, i.e. a torus. Choose two points\np, q P T. Since Π1pTq is a groupoid, it is also a category. What would the hom-set\nHomΠ1pT qpp, qq represent?\n♦\nExercise 4.2.3.13. Let U D R2 be an open subset of the plane, and let F be an irrotational\nvector field on U (i.e. one with curlpFq \" 0). Following Exercise 4.1.1.15, we have a\ncategory CF .\nIf two curves C, C1 in U are homotopic then they have the same line\nintegral,\ns\nC F \"\ns\nC1 F.\nWe also have a category Π1U, given by the fundamental groupoid, as in Example\n4.2.3.11. Both categories have the same objects, ObpCF q \" |U| \" ObpΠ1Uq, the set of\npoints in U.\na.) Is there a functor CF N Π1U or a functor Π1U N CF that is identity on the under-\nlying objects?\nb.) What is CF if F is a conservative vector field?\n♦\nExercise 4.2.3.14. Consider the set A of all (well-formed) arithmetic expressions in the\nsymbols t0, . . . , 9, `, , , p, qu. For example, here are some elements of A:\n52,\n52 7,\n50 ` 3 p6 2q.\nWe can say that an equivalence between two arithmetic expressions is a justification that\nthey give the same \"final answer\", e.g. 52`60 is equivalent to 10 p5`6q`p2`0q, which\nis equivalent to 10 11`2. I've basically described a groupoid. What are its objects and\nwhat are its morphisms?\n♦\n4.2.4\nLogic, set theory, and computer science\n4.2.4.1\nThe category of propositions\nGiven a domain of discourse, a logical proposition is a statement that is evalued in any\nmodel of that domain as either true or \"not always true\". For example, in the domain\nof real numbers we might have the proposition\nFor all real numbers x P R there exists a real number y P R such that y a 3x.\n11 Let I2 \" tpx, yq P R2 | 0 d x d 1 and 0 d y d 1u denote the square. There are two inclusions\ni0, i1 : I N S that put the interval inside the square at the left and right sides. Two paths f0, f1 : I N X\nare homotopic if there exists a continuous map f : I ˆ I N X such that f0 \" f i0 and f1 \" f i1,\nI\ni1\n/\ni0 / I ˆ I\nf\n/ X\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS141\nWe say that one logical proposition P implies another proposition Q, denoted P n Q if,\nfor every model in which P is true, so is Q. There is a category Prop whose objects are\nlogical propositions and whose morphisms are proofs that one statement implies another.\nCrudely, one might say that B holds at least as often as A if there is a morphism A N B\n(meaning whenever A holds, so does B). So the proposition \"x % x\" holds very seldom\nand \"x \" x\" always very often.\nExample 4.2.4.2. We can repeat this idea for non-mathematical statements. Take all\npossible statements that are verifiable by experiment as objects of a category. Given\ntwo such statements, it may be that one implies the other (e.g. \"if the speed of light is\nfixed then there are relativistic effects\"). Every statement implies itself (identity) and\nimplication is transitive, so we have a category.\nLet's consider differences in proofs to be irrelevant, so the category Prop becomes a\npreorder: either A implies B or it does not. Then it makes sense to discuss meets and\njoins. It turns out that meets are \"and's\" and joins are \"or's\". That is, given propositions\nA, B the meet A^B is defined to be a proposition that holds as often as possible subject\nto the constraint that it implies both A and B; the proposition \"A holds and B holds\"\nfits the bill. Similarly, the join A _ B is given by \"A holds or B holds\".\nExercise 4.2.4.3. Consider the set of possible laws (most likely an infinite set) that can\nbe dictated to hold throughout a jurisdiction. Consider each law as a proposition (\"such\nand such is (dictated to be) the case\"), i.e as an object of our preorder Prop. Given a\njurisdiction V , and a set of laws tl1, l2, . . . , lnu that are dictated to hold throughout V ,\nwe take their meet LpV q :\" l1 ^ l2 ^ ^ ln and consider it to be the single law of the\nland V . Suppose that V is a jurisdiction and U is a sub-jurisdiction (e.g. U is a county\nand V is a state); write U d V . Then clearly any law dictated by the large jurisdiction\n(the state) must also hold throughout the small jurisdiction (the county).\na.) What is the relation in Prop between LpUq and LpV q?\nb.) Consider the preorder J on jurisdictions given by d as above. Is \"the law of the\nland\" a morphism of preorders J N Prop? To be a bit more high-brow, considering\nboth J and Prop to be categories (by Proposition 4.2.1.17), we have a function\nL: ObpJq N ObpPropq; this question is asking whether L extends to a functor\nJ N Prop.12\n♦\nExercise 4.2.4.4. Take again the preorder J of jurisdictions from Exercise 4.2.4.3 and the\nidea that laws are propositions. But this time, let RpV q be the set of all possible laws\n(not just those dictated to hold) that are in actuality being respected, i.e. followed, by\nall people in V . This assigns to each jurisdiction a set.\na.) Since preorders can be considered categories, does our \"the set of respected laws\"\nfunction R: ObpJq N ObpSetq extend to a functor J N Set?\nb.) What about if instead we take the meet of all these laws and assign to each ju-\nrisdiction the maximal law respected throughout. Does this assignment ObpJq N\nObpPropq extend to a functor J N Prop? 12\n♦\n12Hint: Exercises 4.2.4.3 and 4.2.4.4 will ask similar yes/no questions and at least one of these is\ncorrectly answered \"no\".\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.2.4.5\nA categorical characterization of Set\nThe category Set of sets is fundamental in mathematics, but instead of thinking of it\nas something given or somehow special, it can be shown to merely be a category with\ncertain properties, each of which can be phrased purely categorically. This was shown\nby Lawvere [Law]. A very readable account is given in [Le2].\n4.2.4.6\nCategories in computer science\nComputer science makes heavy use of trees, graphs, orders, lists, and monoids. We have\nseen that all of these are naturally viewed in the context of category theory, though\nit seems that such facts are rarely mentioned explicitly in computer science textbooks.\nHowever, categories are also used explicitly in the theory of programming languages\n(PL). Researchers in that field attempt to understand the connection between what\nprograms are supposed to do (their denotation) and what they actually cause to occur\n(their operation). Category theory provides a useful mathematical formalism in which\nto study this.\nThe kind of category most often considered by a PL researcher is what is known\nas a Cartesian closed category or CCC, which means a category T that has products\n(like A ˆ B in Set) and exponential objects (like BA in Set).\nSet is an example\nof a CCC, but there are others that are more appropriate for actual computation.\nThe objects in a PL person's CCC represent the types of the language, types such\nas integers, strings, floats. The morphisms represent computable functions, e.g.\nlength:\nstringsYNintegers. The products allow one to discuss pairs pa, bq where\na is of one type and b is of another type. Exponential objects allow one to consider\ncomputable functions as things that can be input to a function (e.g. given any com-\nputable function floatsNintegers one can consistently multiply its results by 2 and\nget a new computable function floatsNintegers. We will be getting to products in\nSection 4.5.1.8 and exponential objects in Section 4.3.2.\nBut category theory did not only offer a language for thinking about programs, it\noffered an unexpected tool called monads. The above CCC model for types allows re-\nsearchers only to discuss functions, leading to the notion of functional programming\nlanguages; however, not all things that a computer does are functions. For example,\nreading input and output, changing internal state, etc. are operations that can be per-\nformed that ruin the functional-ness of programs. Monads were found in 19?? by Moggi\n[Mog] to provide a powerful abstraction that opens the doors to such non-functional\noperations without forcing the developer to leave the category-theoretic garden of eden.\nWe will discuss monads in Section 5.3.\nWe have also seen in Section 4.2.2 that databases are well captured by the language of\ncategories. We will formalize this in Section 4.4. Throughout the remainder of this book\nwe will continue to use databases to bring clarity to concepts within standard category\ntheory.\n4.2.5\nCategories applied in science\nCategories are being used throughout mathematics to relate various subjects, as well\nas to draw out the essential structures within these subjects. For example, there is an\nactive research for \"categorifying\" classical theories like that of knots, links, and braids\n[Kho]. It is similarly applied in science, to clarify complex subjects. Here are some very\nbrief descriptions of scientific disciplines to which category theory is applied.\n\n4.3. NATURAL TRANSFORMATIONS\nQuantum field theory is was categorified by Atiyah [Ati] in the late 1980's, with much\nsuccess (at least in producing interesting mathematics). In this domain, one takes a cat-\negory in which an object is a reasonable space, called a manifold, and a morphism is a\nmanifold connecting two manifolds, like a cylinder connects two circles. Such connecting\nmanifolds are called cobordisms, and as such people refer to the category as Cob. Topo-\nlogical quantum field theory is the study of functors Cob N Vect that assign a vector\nspace to each manifold and a linear transformation of vector spaces to each cobordism.\nInformation theory 13 is the study of how to ideally compress messages so that they\ncan be sent quickly and accurately across a noisy channel.14 Invented in 1948 by Claude\nShannon, its main quantity of interest is the number of bits necessary to encode a piece\nof information. For example, the amount of information in an English sentence can be\ngreatly reduced. The fact that t's are often followed by h's, or that e's are much more\ncommon than z's, implies that letters are not being used as efficiently as possible. The\namount of bits necessary to encode a message is called its entropy and has been linked\nto the commonly used notion of the same name in physics.\nIn [BFL], Baez, Fritz, and Leinster show that entropy can be captured quite cleanly\nusing category theory.\nThey make a category FinProb whose objects are finite sets\nequipped with a probability measure, and whose morphisms are probability preserving\nfunctions. They characterize information loss as a way to assign numbers to such mor-\nphisms, subject to certain explicit constraints. They then show that the entropy of an\nobject in FinProb is the amount of information lost under the unique map to the single-\nton set t,u. This approach explicates (by way of the explicit constraints for information\nloss functions) the essential idea of Shannon's information theory, allowing it to be gener-\nalized to categories other than FinProb. Thus Baez and Leinster effectively categorified\ninformation theory.\nRobert Rosen proposed in the 1970s that category theory could play a major role in\nbiology. That story is only now starting to be fleshed out. There is a categorical account\nof evolution and memory, called Memory Evolutive Systems [EV]. There is also a paper\n[BP2] by Brown and Porter with applications to neuroscience.\n4.3\nNatural transformations\nIn this section we conclude our discussion of the Big 3, by defining natural transforma-\ntions. Category theory was originally invented to discuss natural transformations. These\nwere sufficiently conceptually challenging that they required formalization and thus the\ninvention of category theory. If we think of categories as domains (of discourse, interac-\ntion, comparability, etc.) and of functors as transformations between different domains,\nthe natural transformations compare different transformations.\nNatural transformations can seem a bit abstruse at first, but hopefully some examples\nand exercises will help.\n13To me, the subject of \"information theory\" is badly named. That discipline is devoted to finding\nideal compression schemes for messages to be sent quickly and accurately across a noisy channel. It\ndeliberately does not pay any attention to what the messages mean. To my mind this should be called\ncompression theory or redundancy theory. Information is inherently meaningful--that is its purpose--\nany theory that is unconcerned with the meaning is not really studying information per se. The people\nwho decide on speed limits for roads and highways may care about human health, but a study limited\nto deciding ideal speed limits should not be called \"human health theory\".\n14Despite what was said above, Information theory has been extremely important in a diverse array\nof fields, including computer science [MacK], but also in neuroscience [Bar], [Lin] and physics [Eve]. I'm\nnot trying to denigrate the field; I am only frustrated with its name.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.3.1\nDefinition and examples\nLet's begin with an example. There is a functor List: Set N Set, which sends a set\nX to the set ListpXq consisting of all lists whose entries are elements of X. Given a\nmorphism f : X N Y , we can transform a list with entries in X into a list with entries\nin Y by applying f to each (this was worked out in Exercise 4.1.2.20)..\nIt may seem a strange thing to contemplate, but there is also a functor List\nList: Set N Set that sends a set X to the set of lists of lists in X. If X \" ta, b, cu then\nList ListpXq contains elements like\n\"\nra, bs, ra, c, a, b, cs, rcs\n%\nand\n\"\nr s\n%\nand\n\"\nras, r s, ra, a, as\n%\n.\nWe can naturally transform a list of lists into a list by concatenation. In other words,\nfor any set X there is a function μX : List ListpXq N ListpXq which sends our lists\nabove to ra, b, a, c, a, b, c, cs and r s and ra, a, a, as, respectively. In fact, even if we use a\nfunction f : X N Y to convert a list of X's into a list of Y 's (or a list of lists of X's into\na list of lists of Y 's), the concatenation \"works right\". Take a deep breath for the precise\nstatement couched as a slogan.\nSlogan 4.3.1.1.\n\" Naturality works like this: Using a function f : X N Y to convert a list of\nlists of X's into a list of list of Y 's and then concatenating to get a simple\nlist of Y 's does the same thing as first concatenating our list of lists of\nX's into a simple list of X's and then using our function f to convert it into\na list of Y 's. \"\nLet's make this concrete. Let X \" ta, b, cu, let Y \" t1, 2, 3u, and let f : X N Y\nassign fpaq \" 1, fpbq \" 1, fpcq \" 2. Our naturality condition says the following for any\nlist of lists of X's, in particular for\n\"\nra, bs, ra, c, a, b, cs, rcs\n%\n:\n\"\nra, bs, ra, c, a, b, cs, rcs\n%\nμX\n/\n_\nList Listpfq\n\nra, b, a, c, a, b, c, cs\n_\nListpfq\n\n\"\nr1, 1s, r1, 2, 1, 1, 2s, r2s\n%\nμY\n/ r1, 1, 1, 2, 1, 1, 2, 2s\nKeep these μX in mind in the following definition--they serve as the \"components\"\nof a natural transformation List List N List of functors C N D, where C \" D \" Set.\nDefinition 4.3.1.2. Let C and D be categories and let F : C N D and G: C N D be\nfunctors. A natural transformation α from F to G, denoted α: F N G, is defined as\nfollows: one announces some constituents (A. components) and asserts that they conform\nto some laws (1. naturality squares). Specifically, one announces\nA. for each object c P ObpCq a morphism αc : Fpcq N Gpcq in D, called the c-\ncomponent of α.\nOne asserts that the following law holds:\n1. For every morphism h: c N c1 in C, the following square, called the naturality\n\n4.3. NATURAL TRANSFORMATIONS\nsquare for h, must commute:\nFpcq\n✓\nF phq\n\nαc\n/ Gpcq\nGphq\n\nFpc1q\nαc1 / Gpc1q\n(4.9)\nExample 4.3.1.3. Consider the categories C - r1s and D - r2s drawn below:\nC :\"\n0‚\np\n/ 1‚\nD :\"\nA‚\nf\n/ B‚\ng\n/ C‚ .\nConsider the functors F, G: r1s N r2s where Fp0q \" A, Fp1q \" B, Gp0q \" A, and\nGp1q \" C. The orange dots and arrows in the picture below represent the image of C\nunder F and G.\nA\nB\nC\nf\ng\nA\nB\nC\nf\ng\nf\ng\ng○f\nidA\nidB\nidC\ng○f\ng○f\nIt turns out that there is only one possible natural transformation F N G; we call\nit α and explore its naturality square. We have drawn the components of α: F N G in\ngreen. These components are α0 \" idA : Fp0q N Gp0q and α1 \" g: Fp1q N Gp1q. The\nnaturality square for p: 0 N 1 is written twice below, once with notation following that\nin (4.9) and once in local notation.\nFp0q\nα0 /\nF ppq\n\nGp0q\nGppq\n\nFp1q\nα1 / Gp1q\nA\nidA /\nf\n\nA\ng f\n\nB\ng\n/ C\n\nCHAPTER 4. BASIC CATEGORY THEORY\nIt is clear that this diagram commutes, so our components α0 and α1 satisfy the law of\nDefinition 4.3.1.2, making α a natural transformation.\nLemma 4.3.1.4. Let C and D be categories, let F, G: C N D be functors, and for every\nobject c P ObpCq, let αc : Fpcq N Gpcq be a morphism in D.\nSuppose given a path\nc0\nf1\nYN c1\nf2\nYN\nfn\nYN cn such that the naturality square\nFpci 1q\nF pfiq\n\nαci 1 / Gpci 1q\nGpfiq\n\nFpciq\nαci\n/ Gpciq\ncommutes for each 1 d i d n.\nThen the naturality square for the composite p :\"\nfn f2 f1 : c0 N cn\nFpc0q\nαc0 /\nF ppq\n\nGpc0q\nGppq\n\nFpcnq\nαcn\n/ Gpcnq\nalso commutes. In particular, the naturality square commutes for every identity mor-\nphism idc.\nProof. When n \" 0 we have a path of length 0 starting at each c P ObpCq. It vacuously\nsatisfies the condition, so we need to see that its naturality square\nFpcq\nαc\n/\nF pidcq\n\nGpcq\nGpidcq\n\nFpcq\nαc\n/ Gpcq\ncommutes. But this is clear because functors preserve identities.\nThe rest of the proof follows by induction on n. Suppose q \" fn 1 f2 f1 : c0 N\ncn 1 and p \" fn q and that the naturality squares for q and for fn commute; we need\nonly show that the naturality square for p commutes. That is, we assume the two small\nsquares commute below; but it follows that the large rectangle does too, completing the\nproof.\nFpc0q\nαc0\n/\nF pqq\n\nGpc0q\nGpqq\n\nFpcn 1q\nαcn 1 /\nF pfnq\n\nGpcn 1q\nGpfnq\n\nFpcnq\nαcn\n/ Gpcnq\n□\n\n4.3. NATURAL TRANSFORMATIONS\nExample 4.3.1.5. Let C \" D \" r1s be the linear order of length 1, thought of as a\ncategory (by Proposition 4.2.1.17). There are three functors C N D, which we can write\nas p0, 0q, p0, 1q, and p1, 1q; these are depicted left to right below.\n0‚\n/\nf\n0‚\nf\n0‚\n/\nf\n0‚\nf\n0‚z\n\nf\n0‚\nf\n1‚\nD\nB\n1‚\n1‚\n/ 1‚\n1‚\n/ 1‚\nThese are just functors so far. What are the natural transformations say α: p0, 0q N\np0, 1q? To specify a natural transformation, we must specify a component for each object\nin C. In our case α0 : 0 N 0 and α1 : 0 N 1. There is only one possible choice: α0 \" id0\nand α1 \" f. Now that we have chosen components we need to check the naturality\nsquares.\nThere are three morphisms in C, namely id0, f, id1. By Lemma 4.3.1.4, we need only\ncheck the naturality square for f. We write it twice below, once in the abstract notation\nand once in concrete notation:\nFp0q\nα0 /\nF pfq\n\nGp0q\nGpfq\n\nFp1q\nα1 / Gp1q\nid0 /\nid0\n\nf\n\nf\n/ 1\nThis commutes, so α is indeed a natural transformation.\nExercise 4.3.1.6. With notation as in Example 4.3.1.5,\na.) how many natural transformations are there p0, 0q N p1, 1q?\nb.) how many natural transformations are there p0, 0q N p0, 0q?\nc.) how many natural transformations are there p0, 1q N p0, 0q?\nd.) how many natural transformations are there p0, 1q N p1, 1q?\n♦\nExercise 4.3.1.7. Let List: Set N Set be the functor sending a set X to the set ListpXq of\nlists with entries in X. We saw above that there is a natural transformation List List N\nList given by concatenation.\na.) If someone said \"singleton lists give a natural transformation σ from idSet to List\",\nwhat might they mean? That is, for a set X, what component σX might they be\nsuggesting?\nb.) Do these components satisfy the necessary naturality squares for functions f : X N\nY ?\n♦\nExercise 4.3.1.8. Let C and D be categories, and suppose that d P ObpDq is a terminal\nobject. Consider the functor tduC : C N D that sends each object c P ObpCq to d and\neach morphism in C to the identity morphism idd on d.\n\nCHAPTER 4. BASIC CATEGORY THEORY\na.) For any other functor F : C N D, how many natural transformations are there F N\ntduC?\nb.) Let D \" Set and let d \" t,u.\nIf C \" r1s is the linear order of length 1, and\nF : C N Set is any functor, what does it mean to give a natural transformation\ntduC N F?\n♦\nApplication 4.3.1.9. In Figure 3.1 we drew a finite state machine on alphabet Σ \" ta, bu,\nand in Example 3.1.3.1 we showed the associated action table. It will be reproduced\nbelow. Imagine this was your model for understanding the behavior of some system\nwhen acted on by commands a and b. And suppose that a collaborator tells you that she\nhas a more refined notion that fits with the same data. Her notion has 6 states rather\nthan 3, but it's \"compatible\". What might that mean?\nLet's call the original state machine X and the new model Y .\nThe action tables for these two machines are:\nOriginal model X\nID\na\nb\nState 0\nState 1\nState 2\nState 1\nState 2\nState 1\nState 2\nState 0\nState 0\nProposed model Y\nID\na\nb\nState 0\nState 1A\nState 2A\nState 1A\nState 2A\nState 1B\nState 1B\nState 2B\nState 1C\nState 1C\nState 2B\nState 1B\nState 2A\nState 0\nState 0\nState 2B\nState 0\nState 0\nHow are these models compatible? Looking at the table for Y , if one removes the\ndistinction between States 1A, 1B, 1C and between States 2A and 2B, then one returns\nwith the table for X. The table for Y is more specific, but it is fully compatible with\ntable X. The sense in which it is compatible is precisely the sense defined by there being\na natural transformation.\nRecall that M \" pListpΣq, r s, ``q is a monoid, and that a monoid is simply a category\nwith one object, say ObpMq \" t▲u (see Section 4.2.1). With Σ \" ta, bu, the monoid M\ncan be visualized as follows:\nM \"\n▲‚\na\n:\nb\nd\n\n4.3. NATURAL TRANSFORMATIONS\nRecall also that a state machine on M is simply a functor M N Set. We thus have\ntwo such functors, X and Y . A natural transformation α: Y N X would consist of a\ncomponent αm for every object m P ObpMq, such that certain diagrams commute. But\nM having only one object, we need only one function α▲: Y p▲q N Xp▲q, where Y p▲q is\nthe set of (6) states of Y and Xp▲q is the set of (3) states of X.\nThe states of Y have been named so as to make the function α▲particularly easy to\nguess.15 We need to check that two squares commute:\nY p▲q\nα▲/\nY paq\n\nXp▲q\nXpaq\n\nY p▲q\nα▲/ Xp▲q\nY p▲q\nα▲/\nY pbq\n\nXp▲q\nXpbq\n\nY p▲q\nα▲/ Xp▲q\n(4.10)\nThis can only be checked by going through and making sure certain things match, as\nspecified by (4.10); we spell it out in gory detail. The columns that should match are\nthose whose entries are written in blue.\nNaturality square for a: ▲N ▲\nY p▲q [ID]\nY paq\nα▲ Y paq\nα▲\nXpaq α▲\nState 0\nState 1A\nState 1\nState 0\nState 1\nState 1A\nState 2A\nState 2\nState 1\nState 2\nState 1B\nState 2B\nState 2\nState 1\nState 2\nState 1C\nState 2B\nState 2\nState 1\nState 2\nState 2A\nState 0\nState 0\nState 2\nState 0\nState 2B\nState 0\nState 0\nState 2\nState 0\n(4.11)\nNaturality square for b: ▲N ▲\nY p▲q [ID]\nY pbq\nα▲ Y pbq\nα▲\nXpbq α▲\nState 0\nState 2A\nState 2\nState 0\nState 2\nState 1A\nState 1B\nState 1\nState 1\nState 1\nState 1B\nState 1C\nState 1\nState 1\nState 1\nState 1C\nState 1B\nState 1\nState 1\nState 1\nState 2A\nState 0\nState 0\nState 2\nState 0\nState 2B\nState 0\nState 0\nState 2\nState 0\n(4.12)\nIn reality we need to check that for every morphism in M, such as ra, a, bs, a similar\ndiagram commutes. But this holds automatically. For example (flipping the naturality\nsquare sideways for typographical reasons)\nY p▲q\nY paq /\nα▲\n\nY p▲q\nY paq /\nα▲\n\nY p▲q\nY pbq /\nα▲\n\nY p▲q\nα▲\n\nXp▲q\nXpaq\n/ Xp▲q\nXpaq\n/ Xp▲q\nXpbq\n/ Xp▲q\n15The function α▲: Y p▲q N Xp▲q makes the following assignments: State 0 ÞN State 0, State 1A ÞN\nState 1, State 1B ÞN State 1, State 1C ÞN State 1, State 2A ÞN State 2, State 2B ÞN State 2.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nSince each small square above commutes (as checked by tables 4.11 and 4.12), the big\nouter rectangle commutes too.\nTo recap, the notion of compatibility between Y and X is one that can be checked\nand agreed upon by humans, but doing so it is left implicit, and it may be difficult to\nexplain to an outsider what exactly was agreed to, especially in more complex situations.\nIt is quite convenient to simply claim \"there is a natural transformation from Y to X.\"\n♦♦\nExercise 4.3.1.10. Let F : C N D be a functor. Suppose someone said \"the identity on\nF is a natural transformation from F to itself.\"\na.) What might they mean?\nb.) If it is somehow true, what are the components of this natural transformation?\n♦\nExample 4.3.1.11. Let r1s P ObpCatq be the free arrow category described in Exercise\n4.1.2.31 and let D be any category.\nTo specify a functor F : r1s N D requires the\nspecification of two objects, Fpv1q, Fpv2q P ObpDq and a morphism Fpeq: Fpv1q N Fpv2q\nin D. The identity and composition formulas are taken care of once that much is specified.\nTo recap, a functor F : r1s N D is the same thing as a morphism in D.\nThus, choosing two functors F, G: r1s N D is precisely the same thing as choosing\ntwo morphisms in D. Let us call them f : a0 N a1 and g: b0 N b1, where to be clear we\nhave f \" Fpeq, a0 \" Fpv0q, a1 \" Fpv1q and g \" Gpeq, b0 \" Gpv0q, b1 \" Gpv1q.\nA natural transformation α: F N G consists of two components, h0 :\" αv0 : a0 N b0\nand h1 :\" αv1 : a1 N b1, drawn as dashed lines below:\na0\nh0\n/\nf\n\nb0\ng\n\na1\nh1\n/ b1\nThe condition for α to be a natural transformation is that the above square commutes.\nIn other words, a functor r1s N D is an arrow in D and a natural transformation\nbetween two such functors is just a commutative square in D.\nExample 4.3.1.12. Recall that to any graph G we can associate the so-called paths-graph\nPathspGq, as described in Example 4.1.2.22. This is a functor Paths: Grph N Grph.\nThere is also an identity functor idGrph : Grph N Grph. A natural transformation\nη: idGrph N Paths would consist of a graph homomorphism ηG : idGrphpGq N PathspGq\nfor every graph G. But idGrphpGq \" G by definition, so we need ηG : G N PathspGq.\nRecall that PathspGq has the same vertices as G and every arrow in G counts as a path\n(of length 1). So there is an obvious graph homomorphism from G to PathspGq. It is\nnot hard to see that the necessary naturality squares commute.\nExample 4.3.1.13. For any graph G we can associate the paths-graph PathspGq, and\nnothing stops us from doing that twice to yield a new graph PathspPathspGqq. Let's\nthink through what a path of paths in G is. It's a head-to-tail sequence of arrows in\nPathspGq, meaning a head-to-tail sequence of paths in G. These composable sequences of\npaths (or \"paths of paths\") are the individual arrows in PathspPathspGqq. (The vertices\nin PathspGq and PathspPathspGqq are the same as those in G, and all source and target\nfunctions are as expected.)\n\n4.3. NATURAL TRANSFORMATIONS\nClearly, given such a sequence of paths in G, we could compose them to one big path in\nG with the same endpoints. In other words, there is graph morphism μG : PathspPathspGqq N\nPathspGq, that one might call \"concatenation\". In fact, this concatenation extends to a\nnatural transformation\nμ: Paths Paths N Paths\nbetween functors Grph N Grph. In Example 4.3.1.12, we compared a graph to its\npaths-graph using a natural transformation idGrph N Paths; here we are making a\nsimilar kind of comparison.\nRemark 4.3.1.14. In Example 4.3.1.12 we saw that there is a natural transformation\nsending each graph into its paths-graph. There is a formal sense in which a category is\nnothing more than a kind of reverse mapping. That is, to specify a category is the same\nthing as to specify a graph G together with a graph homomorphism PathspGq N G. The\nformalities involve monads, which we will discuss in Section 5.3.\nExercise 4.3.1.15. Let X and Y be sets, and let f : X N Y .\nThere is a functor\nCX : Grph N Set that sends every graph to the set X and sends every morphism\nof graphs to the identity morphism idX : X N X. This functor is called the constant\nfunctor at X. Similarly there is a constant functor CY : Grph N Set.\na.) Use f to construct a natural transformation CX N CY .\nb.) What are its components?\n♦\nExercise 4.3.1.16. For any graph pV, A, src, tgtq we can extract the set of arrows or the set\nof vertices. Since each morphism of graphs includes a function between their arrow sets\nand a function between their vertex sets, we actually have functors Ar: Grph N Set\nand Ve: Grph N Set.\na.) If someone said \"taking source vertices gives a natural transformation from Ar to\nVe\", what natural transfromation might they be referring to?\nb.) What are its components?\nc.) If a different person, say from a totally different country, were to say \"taking target\nvertices also gives a natural transformation from Ar to Ve,\" would they also be\ncorrect?\n♦\nExample 4.3.1.17 (Graph homomorphisms are natural transformations). As discussed\nabove (see Diagram 4.7), there is a category GrIn for which a functor G: GrIn N Set\nis the same thing as a graph. Namely, we have\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\nA natural transformation of two such functors α: G N G1 involves two components,\nαAr : GpArq N G1pArq and αVe : GpVeq N G1pVeq, and two naturality squares, one for\nsrc and one for tgt. This is precisely the same thing as a graph homomorphism, as\ndefined in Definition 3.3.3.1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.3.2\nVertical and horizontal composition\nIn this section we discuss two types of compositions for natural transformations. The\nterms vertical and horizontal are used to describe them; these terms come from the\nfollowing pictures:\nαo\nC\nF\n\nG\n/\nH\nBD\nβo\nC\nF1\n!\nγ1o\nG1\n= D\nF2\n!\nγ2o\nG2\n= E\nWe generally use to denote both kinds of composition, but if we want to be very clear we\nwill differentiate as follows: β α: F N H for vertical composition, and γ2 γ1 : F2 F1 YN\nG2 G1 for horizontal composition. Of course, the actual arrangement of things on a\npage of text does not correlate with verticality or horizontality--these are just names.\nWe will define them more carefully below.\n4.3.2.1\nVertical composition of natural transformations\nThe following proposition proves that functors and natural transformations (using ver-\ntical composition) form a category.\nProposition 4.3.2.2. Let C and D be categories. There exists a category, called the\ncategory of functors from C to D and denoted FunpC, Dq, whose objects are the functors\nC N D and whose morphisms are the natural transformations,\nHomFunpC,DqpF, Gq \" tα: F N G | α is a natural transformationu.\nThat is, there are identity natural transformations, natural transformations can be com-\nposed, and the identity and associativity laws hold.\nProof. We showed in Exercise 4.3.1.10 that there for any functor F : C N D, there\nis an identity natural transformation idF : F N F (its component at c P ObpCq is\nidF pcq : Fpcq N Fpcq).\nGiven a natural transformation α: F N G and a natural transformation β : G N H,\nwe propose for the composite β α the transformation γ : F N H having components\nβc αc for every c P ObpCq. To see that γ is indeed a natural transformation, one simply\nputs together naturality squares for α and β to get naturality squares for β α.\nThe associativity and identity laws for FunpC, Dq follow from those holding for mor-\nphisms in D.\n□\nNotation 4.3.2.3. We sometimes denote the category FunpC, Dq by DC.\nExample 4.3.2.4. Recall from Exercise 4.1.2.38 that there is a functor Ob: Cat N Set\nsending a category to its set of objects. And recall from Example 4.1.2.35 that there\nis a functor Disc: Set N Cat sending a set to the discrete category with that set of\nobjects (all morphisms in DiscpSq are identity morphisms). Let P : Cat N Cat be the\ncomposition P \" Disc Ob. Then P takes a category and makes a new category with\nthe same objects but no morphisms. It's like crystal meth for categories.\n\n4.3. NATURAL TRANSFORMATIONS\nLet idCat : Cat N Cat be the identity functor. There is a natural transformation\ni: P N idCat. For any category C, the component iC : PpCq N C is pretty easily under-\nstood. It is a morphism of categories, i.e. a functor. The two categories PpCq and C\nhave the same set of objects, namely ObpCq, so our functor is identity on objects; and\nPpCq has no non-identity morphisms, so nothing else needs be specified.\nExercise 4.3.2.5. Let C \"\nA‚ be the category with ObpCq \" tAu, and HomCpA, Aq \"\ntidAu. What is FunpC, Setq? In particular, characterize the objects and the morphisms.\n♦\nExercise 4.3.2.6. Let n P N and let n be the set with n elements, considered as a discrete\ncategory. 16 In other words, we write n to mean what should really be called Discpnq.\nDescribe the category Funp3, 2q.\n♦\nExercise 4.3.2.7. Let 1 denote the discrete category with one object, and let C be any\ncategory.\na.) What are the objects of Funp1, Cq?\nb.) What are the morphisms of Funp1, Cq?\n♦\nExample 4.3.2.8. Let 1 denote the discrete category with one object (also known as the\ntrivial monoid). For any category C, we investigate the category D :\" FunpC, 1q. Its\nobjects are functors C N 1. Such a functor F assigns to each object in C an object in 1\nof which there is one; so there is no choice in what F does on objects. And there is only\none morphism in 1 so there is no choice in what F does on morphisms. The upshot is\nthat there is only one object in D, let's call it F, in D, so D is a monoid. What are its\nmorphisms?\nA morphism α: F N F in D is a natural transformation of functors.\nFor every\nc P ObpCq we need a component αc : Fpcq N Fpcq, which is a morphism 1 N 1 in 1.\nBut there is only one morphism in 1, namely id1, so there is no choice about what these\ncomponents should be: they are all id1. The necessary naturality squares commute, so\nα is indeed a natural transformation. Thus the monoid D is the trivial monoid; that is,\nFunpC, 1q - 1 for any category C.\nExercise 4.3.2.9. Let 0 represent the discrete category on 0 objects; it has no objects and\nno morphisms. Let C be any category. What is Funp0, Cq?\n♦\nExercise 4.3.2.10. Let r1s denote the free arrow category as in Exercise 4.1.2.31, and\nlet C be the graph indexing category from (4.7).\nDraw the underlying graph of the\ncategory Funpr1s, Cq, and then specify which pairs of paths in that graph correspond to\ncommutative diagrams in Funpr1s, Cq.\n♦\n16When we have a functor, such as Disc: Set N Cat, we may sometimes say things like \"Let S\nbe a set, considered as a category\" (or in general, given a functor F : C N D, we may say \"consider\nc P ObpCq, taken as an object in D\"). What this means is that we want to take ideas and methods\navailable in Cat and use them on our set S. Having our functor Disc lying around, we use it to move S\ninto Cat, as DiscpSq P ObpCatq, upon which we can use our intended methods. However, our human\nminds get bogged down seeing DiscpSq because it is bulky (e.g. FunpDiscp3q, Discp2qq is harder to read\nthan Funp3, 2q). So we abuse notation and write S in place of DiscpSq. To add insult to injury, we\ntalk about S as though it was still a set, e.g. discussing its elements rather than its objects. This kind\nof conceptual abbreviation is standard practice in mathematical discussion because it eases the mental\nburden for experts, but when one says \"Let S be an X considered as a Y \" the other may always ask,\n\"How again are you considering X's to be Y 's?\" and expect a functor .\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.3.2.11\nNatural isomorphisms\nLet C and D be categories. We have defined a category FunpC, Dq whose objects are\nfunctors C N D and whose morphisms are natural transformations.\nWhat are the\nisomorphisms in this category?\nLemma 4.3.2.12. Let C and D be categories and let F, G: C N D be functors. A natural\ntransformation α: F N G is an isomorphism in FunpC, Dq if and only if the component\nαc : Fpcq N Gpcq is an isomorphism for each object c P ObpCq. In this case α is called a\nnatural isomorphism.\nProof. First suppose that α is an isomorphism with inverse β : G N F, and let βc : Gpcq N\nFpcq denote its c component. We know that α β \" idG and β α \" idF . Using the\ndefinitions of composition and identity given in Proposition 4.3.2.2, this means that for\nevery c P ObpCq we have αc βc \" idGpcq and βc αc \" idF pcq; in other words αc is an\nisomorphism.\nSecond suppose that each αc is an isomorphism with inverse βc : Gpcq N Fpcq. We\nneed to see that these components assemble into a natural transformation; i.e. for every\nmorphism h: c N c1 in C the right-hand square\nFpcq\n✓\nF phq\n\nαc\n/ Gpcq\nGphq\n\nFpc1q\nαc1 / Gpc1q\nGpcq\n?\nGphq\n\nβc\n/ Fpcq\nF phq\n\nGpc1q\nβc1\n/ Fpc1q\ncommutes. We know that the left-hand square commutes because α is a natural trans-\nformation; we have labeled each square with a ? or a ✓accordingly. In the following\ndiagram we want to show that the left-hand square commutes. We know that the middle\nsquare commutes.\nGpcq\nidGpcq\n&\n?\nGphq\n\nβc\n/ Fpcq\n✓\nF phq\n\nαc\n/ Gpcq\n?\nGphq\n\nβc\n/ Fpcq\nF phq\n\nGpc1q\nβc1\n/ Fpc1q\nαc1\n/\nidF pc1q\nGpc1q\nβc1\n/ Fpc1q\nTo complete the proof we need only to show that Fphq βc \" βc1 Gphq. This can be\nshown by a \"diagram chase.\" We go through it symbolically, for demonstration.\nFphq βc \" βc1 αc1 Fphq βc \" βc1 Gphq αc βc \" βc1 Gphq.\n□\nExercise 4.3.2.13. Recall from Application 4.3.1.9 that a finite state machine on alphabet\nΣ can be understood as a functor M N Set, where M \" ListpΣq is the free monoid\n\n4.3. NATURAL TRANSFORMATIONS\ngenerated by Σ. In that example we also discussed how natural transformations provide\na nice language for changing state machines. Describe what kinds of changes are made\nby natural isomorphisms.\n♦\n4.3.2.14\nHorizontal composition of natural transformations\nExample 4.3.2.15 (Whiskering). Suppose that M \" Listpa, bq and M1 \" Listpm, n, pq\nare free monoids, and let F : M1 N M be given by sending rms ÞN ras, rns ÞN rbs, and\nrps ÞN rb, a, as. An application of this might be if the sequence rb, a, as was commonly\nused in practice and one wanted to add a new button just for that sequence.\nRecall Application 4.3.1.9. Let X : M N Set and Y : M N Set be the functors, and\nlet α: Y N X be the natural transformation found there. We reproduce them here:\nOriginal model X : M N Set\nID\na\nb\nState 0\nState 1\nState 2\nState 1\nState 2\nState 1\nState 2\nState 0\nState 0\nProposed model Y : M N Set\nID\na\nb\nState 0\nState 1A\nState 2A\nState 1A\nState 2A\nState 1B\nState 1B\nState 2B\nState 1C\nState 1C\nState 2B\nState 1B\nState 2A\nState 0\nState 0\nState 2B\nState 0\nState 0\nWe can compose X and Y with F as in the diagram below\nM1\nF\n/ M\nY\n(\nX\nαo\nSet\nto get functors Y F and X F, both of type M1 N Set. What would these be? 17\nX F\nID\nm\nn\np\nState 0\nState 1\nState 2\nState 1\nState 1\nState 2\nState 1\nState 0\nState 2\nState 0\nState 0\nState 2\nY F\nID\nm\nn\np\nState 0\nState 1A\nState 2A\nState 1A\nState 1A\nState 2A\nState 1B\nState 0\nState 1B\nState 2B\nState 1C\nState 0\nState 1C\nState 2B\nState 1B\nState 0\nState 2A\nState 0\nState 0\nState 2A\nState 2B\nState 0\nState 0\nState 2A\nThe map α is what sent both State 1A and State 1B in Y to State 1 in X, and\nso on. We can see that \"the same α works now:\" the p column of the table respects\nthat mapping. But α was a natural transformation Y N X where as we need a natural\ntransformation Y F N X F. This is called whiskering. It is a kind of horizontal\ncomposition of natural transformation.\n17The p-column comes from applying b then a then a, as specified above by F.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nDefinition 4.3.2.16 (Whiskering). Let B, C, D, and E be categories, let G1, G2 : C N D\nbe functors, and let α: G1 N G2 a natural transformation. Suppose that F : B N C\n(respectively H : D N E) is a functor, depicted below:\nB\nF\n/ C\nαo\nG1 \"\nG2\n?D\n\nrespectively,\nC\nαo\nG1 \"\nG2\n?D\nH\n/ E\n\n‹‹‚,\nThen the pre-whiskering of α by F, denoted α F : G1 F N G2 F (respectively, the\npost-whiskering of α by H, denoted H α: H G1 N H G2) is defined as follows.\nFor each b P ObpBq the component pα Fqb : G1 Fpbq N G2 Fpbq is defined to\nbe αF pbq.\n(Respectively, for each c P ObpCq the component pH αqc : H G1pcq N\nH G2pcq is defined to be Hpαcq.) Checking that the naturality squares (in each case)\nis straightforward.\nThe rest of this section can safely be skipped; I include it only for my own sense of\ncompleteness.\nDefinition 4.3.2.17 (Horizontal composition of natural transformations). Let B, C, and\nD be categories, let F1, F2 : B N C and G1, G2 : C N D be functors, and let α: F1 N F2\nand β : G1 N G2 be natural transformations, as depicted below:\nB\nαo\nF1\n!\nF2\n? C\nβo\nG1 \"\nG2\n?D\nBy pre- and post-whiskering in one order or the other we get the following diagram\nG1 F1\nG1 α /\nβ F1\n\nG1 F2\nβ F2\n\nG2 F1\nG2 α / G2 F2\nIt is straightforward to show that this diagram commutes, so we can take the composition\nto be our definition of the horizontal composition\nβ α: G1 F1 N G2 F2.\nRemark 4.3.2.18. Whiskering a natural transformation α with a functor F is the same\nthing as horizontally composing α with the identity natural transformation idF . This\nis true for both pre- and post- whiskering. For example in the notation of Definition\n4.3.2.16 we have\nα F \" α idF\nand\nH α \" idH α.\nRemark 4.3.2.19. All of the above is somehow similar to the world of paths inside a\ndatabase schema S, as seen in Definition 3.5.2.3. Indeed, a congruence on the paths of S\nis an equivalence relation that is closed under composition. The equivalence relation part\nis analogous to the fact that natural transformations can be composed vertically. The\nclosure under composition part (Properties (3) and (4) in Definition 3.5.2.3) is analogous\nto pre- and post whiskering. See also Lemma 3.5.2.5.\nThis is being mentioned only as a curiosity and a way for the reader to draw connec-\ntions, not with any additional purpose at this time.\n\n4.3. NATURAL TRANSFORMATIONS\nTheorem 4.3.2.20.\nα1o\nβ1o\nC\nF1\n\nF2\n/\nF3\nBD\nG1\n\nG2\n/\nG3\nBE\nα2o\nβ2o\nGiven a setup of categories, functors, and natural transformations as above, we have\npβ2 β1q pα2 α1q \" pβ2 α2q pβ1 α1q.\nProof. One need only observe that each square in the following diagram commutes, so\nfollowing the outer path pβ2 β1q pα2 α1q yields the same morphism as following the\ndiagonal path ; pβ2 α2q pβ1 α1q:\nG1F1\nG1 α1/\nβ1 F1\n\nG1F2\nG1 α2/\nβ1 F2\n\nG1F3\nβ1 F3\n\nG2F1\nG2 α1/\nβ2 F1\n\nG2F2\nG2 α2/\nβ2 F2\n\nG2F3\nβ2 F3\n\nG3F1 G3 α1\n/ G3F2 G3 α2\n/ G3F3\n□\n4.3.3\nThe category of instances on a database schema\nIn Section 4.2.2 we showed that schemas are presentations of categories, and we will\nshow in Section 4.4 that in fact the category of schemas is equivalent to the category\nof categories. In this section we therefore take license to blur the distinction between\nschemas and categories.\nIf C is a schema, i.e. a category, then as we discussed in Section 4.2.2.5, an instance\non C is a functor I : C N Set. But now we have a notion beyond categories and functors,\nnamely that of natural transformations. So we make the following definition.\nDefinition 4.3.3.1. Let C be a schema (or category). The category of instances on C,\ndenoted C-Set, is FunpC, Setq. Its objects are C-instances (i.e. functors C N Setq and\nits morphisms are natural transformations.\nRemark 4.3.3.2. One might object to Definition 4.3.3.1 on the grounds that database\ninstances should not be infinite. This is a reasonable perspective, so it is a pleasant fact\nthat the above definition can be modified easily to accomodate it. The subcategory Fin\n(see Example 4.1.1.4) of finite sets can be substituted for Set in Definition 4.3.3.1. One\ncould define the category of finite instances on C as C Fin \" FunpC, Finq. Almost all\nof the ideas in this book will make perfect sense in C Fin.\nNatural transformations should serve as some kind of morphism between instances on\nthe same schema. How are we to interpret a natural transformation α: I N J between\ndatabase instances I, J : C N Set?\n\nCHAPTER 4. BASIC CATEGORY THEORY\nOur first clue comes from Application 4.3.1.9.\nThere we considered the case of\na monoid M, and we thought about a natural transformation between two functors\nX, Y : M N Set, considered as different finite state machines. The notion of natural\ntransformation captured the idea of one model being a refinement of another. This same\nkind of idea works for databases with more than one table (categories with more than\none object), but the whole thing is a bit opaque. Let's work it through slowly.\nExample 4.3.3.3. Let us consider the terminal schema, 1 - ‚Grapes . An instance is a\nfunctor 1 N Set and it is easy to see that this is the same thing as just a set. A natural\ntransformation α: I N J is a function from set I to set J. In the standard table view,\nwe might have I and J as below:\nGrapes pIq\nID\nGrape 1\nGrape 3\nGrape 4\nGrapes pJq\nID\nJan1-01\nJan1-02\nJan1-03\nJan1-04\nJan3-01\nJan4-01\nJan4-02\nThere are 343 natural transformations I N J. Perhaps some of them make more sense\nthan others; e.g. we could hope that the numbers in I corresponded to the numbers after\nthe dash in J, or perhaps to what seems to be the date in January. But it could be that\nthe rows in J correspond to batches, and all three grapes in I are part of the first batch\non Jan-1. The notion of natural transformation is a mathematical one.\nExercise 4.3.3.4. Recall the notion of set-indexed sets from Definition 2.7.6.12. Let A be\na set, and come up with a schema A such that instances on A are A-indexed sets. Is our\ncurrent notion of morphism between instances (i.e. natural transformations) well-aligned\nwith the above definition of \"mapping of A-indexed sets\"?\n♦\nFor a general schema (or category) C, let us think through what a morphism α: I N J\nbetween instances I, J : C N Set is. For each object c P ObpCq there is a component\nαc : Ipcq N Jpcq. This means that just like in Example 4.3.3.3, there is for each table c\na function from the rows in I's manifestation of c to the rows in J's manifestation of c.\nSo to make a natural transformation, such a function has to be specified table by table.\nBut then we have to contend with naturality squares, one for every arrow in C. Arrows\nin C correspond to foreign key columns in the database. The naturality requirement was\nalready covered in Application 4.3.1.9 (and see especially how (4.10) is checked in (4.11)\nand (4.12)).\nExample 4.3.3.5. We saw in Section 4.2.1.20 that graphs can be regarded as functors\nG N Set, where G - GrIn is the \"schema for graphs\" shown here:\nG :\"\nArrow\n‚\nsrc /\ntgt /\nVertex\n‚\nA database instance I : G N Set on G consists of two tables. Here is an example\n\n4.3. NATURAL TRANSFORMATIONS\ninstance:\nI :\"\n‚v\nf\n/ ‚w\nh\n=\ng\n#\n‚x\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nTo discuss natural transformations, we need two instances. Here is another, J : G N Set,\nJ :\"\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nu‚\nArrow pJq\nID\nsrc\ntgt\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pJq\nID\nq\nr\ns\nt\nu\nTo give a natural transformation α: I N J, we give two components: one for arrows\nand one for vertices. We need to say where each vertex in I goes in J and we need to\nsay where each arrow in I goes in J. The naturality squares insist that if we specify\nthat g ÞN j, for example, then we better specify thatw ÞN r and that x ÞN s. What a\ncomputer is very good at, but a human is fairly slow at, is checking that a given pair of\ncomponents (arrows and vertices) really is natural.\nThere are 8000 ways to come up with component functions αArrow and αVertex, but\nprecisely four natural transformations, i.e. four graph homomorphisms, I N J; the other\n7996 are haphazard flingings of arrows to arrows and vertices to vertices without any\nregard to sources and targets. We briefly describe the four now.\nFirst off, nothing can be sent to u because arrows must go to arrows and u touches\nno arrows. If we send v ÞN q then f must map to i, and w must map to r, and both g\nand h must map to j, and x must map to s. If we send v ÞN r then there are two choices\nfor g and h. If we send v ÞN s then there's one way to obtain a graph morphism. If we\ntry to send v ÞN? t, we fail. All of this can be seen by staring at the tables rather than\nat the pictorial representations of the graphs; the human eye understands these pictures\nbetter, but the computer understands the tables better.\nExercise 4.3.3.6. If I, J : G N Set are as in Example 4.3.3.5, how many natural trans-\nformations are there J N I?\n♦\nExercise 4.3.3.7. Let YA : G N Set denote the instance below:\nArrow pYAq\nID\nsrc\ntgt\na\nv0\nv1\nVertex pYAq\nID\nv0\nv1\nLet I : G N Set be as in Example 4.3.3.5.\na.) How many natural transformations are there YA N I?\nb.) With J as above, how many natural transformations are there YA N J?\nc.) Do you have any conjecture about the way natural transformations YA N X behave\nfor arbitrary graphs X : G N Set?\n\nCHAPTER 4. BASIC CATEGORY THEORY\n♦\nIn terms of databases, this notion of instance morphism I N J is fairly benign. For\nevery table its a mapping from the set of rows in I's version of the table to J's version\nof the table, such that all the foreign keys are respected. We will see that this notion of\nmorphism has excellent formal properties, so that projections, unions, and joins of tables\n(the typical database operations) would be predicted to be \"obviously interesting\" by a\ncategory theorist who had no idea what a database was. 18\nHowever, something is also missing from the natural transformation picture. A very\nimportant occurrence in the world of databases is the update. Everyone can understand\nthis: a person makes a change in one of the tables, like changing your address from\nCambridge, MA to Hereford, UK. Most such arbitrary changes of database instance are\nnot \"natural\", in that the new linking pattern is incompatible with the old.\nIt is interesting to consider how updates of C-instances should be understood category\ntheoretically. We might want a category UpdC whose objects are C-instances and whose\nmorphisms are updates. But then what is the composition formula? Is there a unique\nmorphism I N J whenever J can be obtained as an update on I? Because in that case,\nwe would be defining UpdC to be the indiscrete category on the set of C-instances (see\nExample 4.3.4.3).\nExercise 4.3.3.8. Research project: Can you come up with a satisfactory way to model\ndatabase updates category-theoretically? Let N be the category\nrNs :\"\n0‚\n/ 1‚\n/ 2‚\n/\nrepresenting a discrete timeline. A place to start might be to use something like the slice\ncategory Cat{rNs where the fiber over each object in N is a snapshot of the database in\ntime. Can you make this work?\n♦\n4.3.4\nEquivalence of categories\nWe have a category Cat of categories, and in every category there is a notion of isomor-\nphism between objects: one morphism each way, such that each round-trip composition\nis the identity. An isomorphism in Cat, therefore, takes place between two categories,\nsay C and D: it is a functor F : C N D and a functor G: D N C such that G F \" idC\nand F G \" idD.\nIt turns out that categories are often similar enough to be considered equivalent\nwithout being isomorphic. For this reason, the notion of isomorphism is considered \"too\nstrong\" to be useful for categories. The feeling to a category theorist might be akin to\nsaying that two material samples are the same if there is an atom-by-atom matching, or\nthat two words are the same if they are written in the same font, of the same size, by\nthe same person, in the same state of mind.\nAs reasonable as isomorphism is as a notion in most categories, it fails to be the\n\"right notion\" about categories. The reason is that in categories there are objects and\nmorphisms, whereas when we talk about categories, we have categories and functors, plus\nnatural transformations. These serve as mappings between mappings, and this is not\npart of the structure of an ordinary category. In cases where a category C does have\nsuch mappings between mappings, it is often a \"better notion\" if we take that extra\n18More precisely, given a functor between schemas F : C N D, the pullback ∆F : D-Set N C-Set, its\nleft ΣF and its right adjoint ΠF constitute these important queries. See Section 5.1.4.\n\n4.3. NATURAL TRANSFORMATIONS\nstructure into account, like we will for categories. This whole subject leads us to the\nstudy of 2-categories (or n-categories, or 8-categories), which we do not discuss in this\nbook. See, for example, [Le1] for an introduction.\nRegardless, our purpose now is to explain this \"good notion\" of sameness for cat-\negories, namely equivalences of categories, which appropriately take natural transfor-\nmations into account. Instead of \"functors going both ways with round trips equal to\nidentity\", which is required in order to be an isomorphism of categories, equivalence of\ncategories demands \"functors going both ways with round trips isomorphic to identity\".\nDefinition 4.3.4.1 (Equivalence of categories). Let C and C1 be categories. A functor\nF : C N C1 is called an equivalence of categories, and denoted F : C\n»\nYN C1, 19 if there exists\na functor F 1 : C1 N C and natural isomorphisms α: idC\n-\nYN F 1 F and α1 : idC1\n-\nYN F F 1.\nIn this case we say that F and F 1 are mutually inverse equivalences.\nUnpacking a bit, suppose we are given functors F : C N C1 and F 1 : C1 N C. We want\nto know something about the roundtrips on C and on C1; we want to know the same\nkind of information about each roundtrip, so let's concentrate on the C side. We want\nto know something about F 1 F : C N C, so let's name it i: C N C; we want to know\nthat i is a natural isomorphism. That is, for every c P ObpCq we want an isomorphism\nαc : c -\nYN ipcq, and we want to know that these isomorphisms are picked carefully enough\nthat given g: c N c1 in C, the choice of isomorphisms for c and c1 are compatible,\nc\nαc /\ng\n\nipcq\nipgq\n\nc1\nαc1 / ipc1q.\nTo be an equivalence, the same has to hold for the other roundtrip, i1 \" F F 1 : C1 N C1.\nExercise 4.3.4.2. Let C and C1 be categories. Suppose that F : C N C1 is an isomorphism\nof categories.\na.) Is it an equivalence of categories?\nb.) What are the components of α and α1 (with notation as in Definition 4.3.4.1)?\n♦\nExample 4.3.4.3. Let S be a set and let S ˆ S D S ˆ S be the complete relation on\nS, which is a preorder KS. Recall from Proposition 4.2.1.17 that we have a functor\ni: PrO N Cat, and the resulting category ipKSq is called the indiscrete category on S;\nit has objects S and a single morphism between every pair of objects. Here is a picture\nof Kt1,2,3u:\n1‚\n\n)\n\n2‚ q\ni\n\n3‚D\nA\nQ\n19The notation » has already been used for equivalences of paths in a schema. We do not mean to\nequate these ideas; we are just reusing the symbol. Hopefully no confusion will arise.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nIt is easy check that K1, the indiscrete category on one element, is isomorphic to 1,\nthe discrete category on one object, also known as the terminal category (see Exercise\n4.1.2.37). The category 1 consists of one object, its identity morphism, and nothing else.\nThe only way that KS can be isomorphic to 1 is if S has one element.\n20 On the\nother hand, there is an equivalence of categories\nKS » 1\nfor every set S % H.\nIn fact, there are many such equivalences, one for each element of S. To see this,\nlet S be a nonempty set and choose an element s0 P S. For every s P S, there is a\nunique isomorphism ks : s\n-\nYN s0 in KS. Let F : KS N 1 be the only possible functor\n(see Exercise 4.1.2.37), and let F 1 : 1 N KS send the unique object in 1 to the object s0.\nNote that F 1 F \" id1 : 1 N 1 is the identity, but that F F 1 : KS N KS sends\neverything to s0. Let α \" id1 and define α1 : idKS N F F 1 by α1\ns \" ks. Note that α1\ns is\nan isomorphism for each s P ObpKSq, and note that α1 is a natural transformation (hence\nnatural isomorphism) because every possible square commutes in KS. This completes\nthe proof, initiated in the paragraph above, that the category KS is equivalent to 1 for\nevery nonempty set S, and that this fact can be witnessed by any element s0 P S.\nExample 4.3.4.4. Consider the category FLin, described in Example 4.1.1.11, of finite\nnonempty linear orders. For every natural number n P N, let rns P ObpFLinq denote the\nlinear order shown in Example 3.4.1.7. Define a category ∆whose objects are given by\nObp∆q \" trns | n P Nu and with Hom∆prms, rnsq \" HomFLinprms, rnsq. The difference\nbetween FLin and ∆is only that objects in FLin may have \"funny labels\", e.g.\n5‚\n/ x‚\n/ \"Sam\"\n‚\nwhereas objects in ∆all have standard labels, e.g.\n0‚\n/ 1‚\n/ 2‚\nClearly FLin is a much larger category, and yet feels like it is \"pretty much the same\nas\" ∆. Justly, they are equivalent, FLin » ∆.\nThe functor F 1 : ∆N FLin is the inclusion; the functor F : FLin N ∆sends every\nfinite nonempty linear order X P ObpFLinq to the object FpXq :\" rns P ∆, where\nObpXq - t0, 1, . . . , nu. For each such X there is a unique isomorphism αX : X\n-\nYN rns,\nand these fit together into 21 the required natural isomorphism idFLin N F 1 F. The\nother natural isomorphism α1 : id∆N F F 1 is the identity.\nExercise 4.3.4.5. Recall from Definition 2.1.2.16 that a set X is called finite if there\nexists a natural number n P N and an isomorphism of sets X N n. Let Fin denote the\ncategory whose objects are the finite sets and whose morphisms are the functions. Let\nS denote the category whose objects are the sets n and whose morphisms are again the\nfunctions. For every object X P ObpFinq there exists an isomorphism pX : X N n for\nsome unique object n P ObpSq. Find an equivalence of categories Fin »\nYN S.\n♦\n20One way to see this is that by Exercise 4.1.2.38, we have a functor Ob: Cat N Set, and we know\nby Exercise 4.1.2.24 that functors preserve isomorphisms, so an isomorphism between categories must\nrestrict to an isomorphism between their sets of objects. The only sets that are isomorphic to 1 have\none element.\n21The phrase \"these fit together into\" is suggestive shorthand for, and thus can be replaced with, the\nphrase \"the naturality squares commute for these components, so together they constitute\".\n\n4.3. NATURAL TRANSFORMATIONS\nExercise 4.3.4.6. We say that two categories C and D are equivalent if there exists an\nequivalence of categories between them. Show that the relation of \"being equivalent\" is\nan equivalence relation on ObpCatq.\n♦\nExample 4.3.4.7. Consider the group Z2 :\" pt0, 1u, 0, `q, where 1`1 \" 0. As a category,\nZ2 has one object ▲and two morphisms, namely 0, 1, such that 0 is the identity. Since\nZ2 is a group, the morphism 1: ▲N ▲must have an inverse x, meaning 1 ` x \" 0, and\nx \" 1 is the only solution.\nThe point is that the morphism 1 in Z2 is an isomorphism. Let C \" 1 be the terminal\ncategory as in Exercise 4.1.2.37. One might accidentally believe that C is equivalent\nto Z2, but this is not the case! The argument in favor of the accidental belief is that\nwe have unique functors F : Z2 N C and F 1 : C N Z2 (and this is true); the roundtrip\nF F 1 : C N C is the identity (and this is true); and for the roundtrip F 1 F : Z2 N Z2\nboth morphisms in Z2 are isomorphisms, so any choice of morphism α▲: ▲N F 1 Fp▲q\nwill be an isomorphism (and this is true). The problem is that no such α▲will be a\nnatural transformation.\nWhen we roundtrip F 1 F : Z2 N Z2, the image of 1: ▲N ▲is F 1 Fp1q \" 0 \" id▲.\nSo the naturality square for the morphism 1 looks like this:\n▲\nα▲\n/\n\n▲\n0\"F 1 F p1q\n\n▲\nα▲\n/ ▲\nwhere we still haven't decided whether we want α▲to be 0 or 1. Unfortunately, neither\nchoice works (i.e. for neither choice will the diagram commute) because x ` 1 % x ` 0 in\nZ2.\nDefinition 4.3.4.8 (Skeleton). Let C be a category. We saw in Lemma 4.1.1.21 that\nthe relation of \"being isomorphic\" is an equivalence relation - on ObpCq. An election in\nC is a choice E of the following sort:\n- for each --equivalence class S D ObpCq a choice of object sE P S, called the elected\nobject for S, and\n- for each object c P ObpCq a choice of isomorphism ic : sE N c and jc : c N sE with\nic jc \" idc and jc ic \" idsE, where sE is an elected object (depending on c).\nGiven an election E in C, there is a category called the E-elected skeleton of C, denoted\nSkelEpCq, whose objects are the elected objects and whose morphisms s N t for any\nelected objects s, t P ObpCq are given by HomSkelEpCqps, tq \" HomCps, tq. Any object\nc P ObpCq is isomorphic to a unique elected object sE; we refer to sE as the elected rep-\nresentative of c; we refer to the isomorphisms ic and jc as the representing isomorphisms\nfor c.\nProposition 4.3.4.9. Let C be a category and let E be an election in C. There is an\nequivalence of categories\nSkelEpCq » C.\nProof. The functor F 1 : SkelEpCq N C is the inclusion. The functor F : C N SkelEpCq\nsends each object in C to its elected representative. Given objects c, c1 P ObpCq with\n\nCHAPTER 4. BASIC CATEGORY THEORY\nelected representatives s, t respectively, and given a morphism g: c N c1 in C, let ic, jc, ic1,\nand jc1 be the representing isomorphisms, and define Fpgq: s N t to be the composite\ns\nic\n/ c\ng\n/ c1\njc1\n/ t.\nThis is functorial because it sends the identity to the identity and Fpg g1q \" Fpgq Fpg1q.\nThe composite F F 1 : SkelEpCq N SkelEpCq is the identity. For each c P ObpCq define\nαc : c -\nYN F 1 Fpcq by αc :\" jc. Given g: c N c1 the required naturality square is shown\nto the left below:\nc\njc\n/\ng\n\n?\ns\nic\n/\nF 1 F pgq\n\nc\ng\n\nc1\nj1\nc\n/ t\nc1\nj1\nc\no\nThe right-hand part commutes by definition of F and F 1; i.e. j1 g ic \" F 1 Fpgq. The\nleft-hand square commutes because ic jc \" idc.\n□\nDefinition 4.3.4.10. A skeleton of C is a category S, equivalent to C, such that for any\ntwo objects s, s1 P ObpSq, if s - s1 then s \" s1.\nExercise 4.3.4.11. Let P be a preorder (considered as a category).\na.) If P1 is a skeleton of P, is it a partial order?\nb.) Is every partial order the skeleton of some preorder?\n♦\nDefinition 4.3.4.12 (Full and faithful functors). Let C and D be categories, and\nlet F : C N D be a functor.\nFor any two objects c, c1 P ObpCq, we have a function\nHomF pc, c1q: HomCpc, c1q N HomDpFpcq, Fpc1qq guaranteed by the definition of functor.\nWe say that F is a full functor if HomF pc, c1q is surjective for every c, c1. We say that\nF is a faithful functor if HomF pc, c1q is injective for every c, c1. We say that F is a fully\nfaithful functor if HomF pc, c1q is bijective for every c, c1.\nExercise 4.3.4.13. Let 1 and 2 be the discrete categories on one and two objects, respec-\ntively. There is only one functor 2 N 1.\na.) Is it full?\nb.) Is it faithful?\n♦\nExercise 4.3.4.14. Let 0 denote the empty category, and let C be any category. There is\na unique functor F : 0 N C.\na.) For general C will F be full?\nb.) For general C will F be faithful?\nc.) For general C will F be an equivalence of categories?\n\n4.4. CATEGORIES AND SCHEMAS ARE EQUIVALENT, CAT » SCH\n♦\nProposition 4.3.4.15. Let C and C1 be categories and let F : C N C1 be an equivalence\nof categories. Then F is fully faithful.\nProof. Suppose F is an equivalence, so we can find a functor F 1 : C1 N C and natural\nisomorphisms α: idC\n-\nYN F 1 F and α1 : idC1\n-\nYN F F 1. We need to know that for any\nobjects c, d P ObpCq, the map\nHomF pc, dq: HomCpc, dq N HomC1pFc, Fdq\nis bijective. Consider the following diagram\nHomCpc, dq\nHomF pc,dq /\nα\n&\nHomC1pFc, Fdq\nα1\n(\nHomF 1pF c,F dq\n\nHomCpF 1Fc, F 1Fdq\nHomF pF 1F c,F 1F dq\n/ HomC1pFF 1Fc, FF 1Fdq\nThe fact that α is bijective implies that the vertical function is surjective. The fact that\nα1 is bijective implies that the vertical function is injective, so it is bijective. This implies\nthat HomF pc, dq is bijective as well.\n□\nExercise 4.3.4.16. Let Z2 be the group (as category) from Example 4.3.4.7. Are there\nany fully faithful functors Z2 N 1?\n♦\n4.4\nCategories and schemas are equivalent, Cat » Sch\nPerhaps it is intuitively clear that schemas are somehow equivalent to categories, and in\nthis section we make that precise. The basic idea was already laid out in Section 4.2.2.\n4.4.1\nThe category Sch of schemas\nRecall from Definition 3.5.2.6 that a schema consists of a pair C :\" pG, »q, where G \"\npV, A, src, tgtq is a graph and » is a congruence, meaning a kind of equivalence relation\non the paths in G (see Definition 3.5.2.3. If we think of a schema as being analogous to a\ncategory, what should fulfill the role of functors? That is, what are to be the morphisms\nin Sch?\nUnfortunately, ones first guess may give the wrong notion if we want an equivalence\nSch » Cat. Since objects in Sch are graphs with additional structure, one might imagine\nthat a morphism C N C1 in Sch should be a graph homomorphism (as in Definition\n3.3.3.1) that preserves said structure. But graph homomorphisms require that arrows be\nsent to arrows, whereas we are more interested in paths than in individual arrows--the\narrows are merely useful for presentation.\nIf instead we define morphisms between schemas to be maps that send paths in C to\npaths in C1, subject to the requirements that path endpoints, path concatenations, and\npath equivalences are preserved, this will turn out to give the correct notion. And since\n\nCHAPTER 4. BASIC CATEGORY THEORY\na path is a concatenation of its arrows, it suffices to give a function F from the arrows of\nC to the paths of C1, which automatically takes care of the first two requirements above;\nwe must only take care that F preserves path equivalences.\nRecall from Examples 4.1.2.22 and 4.3.1.13 the paths-graph functor Paths: Grph N\nGrph, the paths of paths functor Paths Paths: Grph N Grph, and the natural\ntransformations for any graph G,\nηG : G N PathspGq\nand\nμG : PathspPathspGqq N PathspGq.\n(4.13)\nThe function ηG spells out the fact that every arrow in G counts as a path in G, and the\nfunction μG spells out the fact that a head-to-tail sequence of paths (a path of paths) in\nG can be concatenated to a single path in G.\nExercise 4.4.1.1. Let r2s denote the graph\n0‚N\n1‚N\n2‚, and let Loop denote the unique graph\nhaving one vertex and one arrow (pictured in Diagram (3.17)).\na.) Find a graph homomorphism f : r2s N PathspLoopq that is injective on arrows\n(i.e.\nsuch that no two arrows in the graph r2s are sent by f to the same arrow\nin PathspLoopq).\nb.) The graph r2s has 6 paths, so Pathspr2sq has 6 arrows. What are the images of these\narrows under the graph homomorphism Pathspfq: Pathspr2sq N PathspPathspLoopqq?\n♦\nWe are almost ready to give the definition of schema morphism, but before we do, let's\nreturn to our original idea. Given graphs G, G1 (underlying schemas C, C1) we originally\nwanted a function from the paths in G to the paths in G1, but we realized it was more\nconcise to speak of a function from arrows in G to paths in G1. How do we get back\nwhat we originally wanted from the concise version?\nGiven a graph homomorphism\nf : G N PathspG1q, we use (4.13) to form the following composition, which we denote\nsimply by Pathsf : PathspGq N PathspG1q:\nPathspGq\nPathspfq / PathspPathspG1qq\nμG1\n/ PathspG1q\n(4.14)\nThis says that given a function from arrows in G to paths in G1, a path in G becomes\na path of paths in G1, which can be concatenated to a path in G1. This simply and\nprecisely spells out our intuition.\nDefinition 4.4.1.2 (Schema morphism). Let G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q\nbe graphs, and let C \" pG, »Gq and C1 \" pG1, »G1q be schemas. A schema morphism F\nfrom C to D, denoted F : C N D is a graph homomorphism 22\nF : G N PathspG1q\nthat satisfies the following condition for any paths p and q in G:\nif\np »G q\nthen\nPathsF ppq »G1 PathsF pqq.\n(4.15)\nTwo schema morphisms E, F : C N C1 are considered identical if they agree on vertices\n(i.e. E0 \" F0) and if, for every arrow f in G, there is a path equivalence in G1\nE1pfq »G1 F1pfq.\n22By Definition 3.3.3.1, a graph homomorphism F : G N PathspG1q will consist of a vertex part\nF0 : V N V 1 and an arrows part F1 : E N PathpG1q. See also Definition 3.3.2.1.\n\n4.4. CATEGORIES AND SCHEMAS ARE EQUIVALENT, CAT » SCH\nWe now define the category of schemas, denoted Sch, to be the category whose objects\nare schemas as in Definition 3.5.2.6 and whose morphisms are schema morphisms defined\nas above.\nThe identity morphism on schema C \" pG, »Gq is the schema morphism\nidC :\" ηG : G N PathspGq as defined in Equation (4.13). We need only understand\nhow to compose schema morphisms F : C N C1 and F 1 : C1 N C2.\nOn objects their\ncomposition is obvious. Given an arrow in C, it is sent to a path in C1; each arrow in that\npath is sent to a path in C2. We then have a path of paths which we can concatenate\n(via μG2 : PathspPathspG2qq N PathspG2q as in 4.13) to get a path in C2 as desired.\nSlogan 4.4.1.3.\n\" A schema morphism sends vertices to vertices, arrows to paths, and path\nequivalences to path equivalences. \"\nExample 4.4.1.4. Let r2s be the linear order graph of length 2, pictured to the left, and\nlet C denote the schema pictured to the right below:\nr2s :\"\n0‚\nf1\n/ 1‚\nf2\n/ 2‚\nC :\"\na‚\ng\n/\ni\n\nb‚\nh\nc‚\nWe impose on C the path equivalence declaration rg, hs » ris and show that in this case\nC and r2s are isomorphic in Sch. We have a schema morphism F : r2s N C sending\n0 ÞN a, 1 ÞN b, 2 ÞN c, and sending each arrow in r2s to an arrow in C. And we have\na schema morphism F 1 : C N r2s which reverses this mapping on vertices; note that\nF 1 must send the arrow i in C to the path rf1, f2s in r2s, which is ok! The roundtrip\nF 1 F : r2s N r2s is identity.\nThe roundtrip F F 1 : C N C may look like it's not\nthe identity; indeed it sends vertices to themselves but it sends i to the path rg, hs.\nBut according to Definition 4.4.1.2, this schema morphism is considered identical to idC\nbecause there is a path equivalence idCpiq \" ris » rg, hs \" F F 1piq.\nExercise 4.4.1.5. Consider the schema r2s and the schema C pictured above, except where\nthis time we do not impose any path equivalence declarations on C, so rg, hs firis in our\ncurrent version of C.\na.) How many schema morphisms are there r2s N C that send 0 to a?\nb.) How many schema morphisms are there C N r2s that send a to 0?\n♦\nExercise 4.4.1.6. Consider the graph Loop pictured below\nLoop :\"\ns‚\nf\n\nand for any natural number n, let Ln denote the schema pLoop, »nq where »n is the\nPED f n`1 » f n. This is the \"finite hierarchy\" schema of Example 3.5.2.11. Let 1 denote\nthe graph with one vertex and no arrows; consider it as a schema.\n\nCHAPTER 4. BASIC CATEGORY THEORY\na.) Is 1 isomorphic to L1 in Sch?\nb.) Is it isomorphic to any (other) Ln?\n♦\nExercise 4.4.1.7. Let Loop and Ln be the schemas defined in Exercise 4.4.1.6.\na.) What is the cardinality of the set HomSchpL3, L5q?\nb.) What is the cardinality of the set HomSchpL5, L3q? Hint: the cardinality of the set\nHomSchpL4, L9q is 8.\n♦\n4.4.2\nProving the equivalence\nConstruction 4.4.2.1 (From schema to category). We will define a functor L: Sch N\nCat. Let C \" pG, »q be a categorical schema, where G \" pV, A, src, tgtq. Define LpCq to\nbe the category with ObpLpCqq \" V , and with HomLpCqpv1, v2q :\" PathGpv, wq{ », i.e.\nthe set of paths in G, modulo the path equivalence relation for C. The composition of\nmorphisms is defined by concatenation of paths, and Lemma 3.5.2.5 ensures that such\ncomposition is well-defined. We have thus defined L on objects of Sch.\nGiven a schema morphism F : C N C1, where C1 \" pG1, »1q, we need to produce\na functor LpFq: LpCq N LpC1q. The objects of LpCq and LpC1q are the vertices of G\nand G1 respectively, and F provides the necessary function on objects. Diagram (4.14)\nprovides a function PathsF : PathspGq N PathspG1q will provide the requisite function\nfor morphisms.\nA morphism in LpCq is an equivalence class of paths in C. For any representative path\np P PathspGq, we have PathsF ppq P PathspG1q, and if p » q then PathsF ppq »1 PathsF pqq\nby condition 4.15. Thus PathsF indeed provides us with a function HomLpCq N HomLpC1q.\nThis defines L on morphisms in Sch.\nIt is clear that L preserves composition and\nidentities, so it is a functor.\nConstruction 4.4.2.2 (From category to schema). We will define a functor R: Cat N\nSch. Let C \" pObpCq, HomC, dom, cod, ids, q be a category (see Exercise 4.1.1.23). Let\nRpCq \" pG, »q where G is the graph\nG \" pObpCq, HomC, dom, codq,\nand with » defined as the congruence generated by the following path equivalence dec-\nlarations: for any composable sequence of morphisms f1, f2, . . . , fn (with dompfi`1q \"\ncodpfiq for each 1 d i d n 1) we put\nrf1, f2, . . . , fns » rfn f2 f1s.\n(4.16)\nThis defines R on objects of Cat.\nA functor F : C N D induces a schema morphism RpFq: RpCq N RpDq, because\nvertices are sent to vertices, arrows are sent to arrows (as paths of length 1), and path\nequivalence is preserved by (5.14) and the fact that F preserves the composition formula.\nThis defines R on morphisms in Cat. It is clear that R preserves compositions, so it is\na functor.\n\n4.5. LIMITS AND COLIMITS\nTheorem 4.4.2.3. The functors\nL: Sch\n/ Cat: R\no\nare mutually inverse equivalences of categories.\nSketch of proof. It is clear that there is a natural isomorphism α: idCat\n-\nYN L R; i.e.\nfor any category C, there is an isomorphism C - LpRpCqq.\nBefore giving an isomorphism β : idSch\n-\nYN R L, we briefly describe RpLpSqq \":\npG1, »1q for a schema S \" pG, »q. Write G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q.\nOn vertices we have V \" V 1. On arrows we have A1 \" PathG{ ». The congruence »1\nfor RpLpSqq is imposed in (5.14). Under »1, every path of paths in G is made equivalent\nto its concatenation, considered as a path of length 1 in G1.\nThere is a natural transformation β : idSch N R L whose S-component sends each\narrow in G to a certain path of length 1 in G1. We need to see that βS has an inverse.\nBut this is straightforward: every arrow f in R LpSq is an equivalence class of paths\nin S; choose any one and send f there; by Definition 4.4.1.2 any other choice will give\nthe identical morphism of schemas. It is easy to show that the roundtrips are identities\n(again up to the notion of identity given in Definition 4.4.1.2).\n□\n4.5\nLimits and colimits\nLimits and colimits are universal constructions, meaning they represent certain ideals of\nbehavior in a category. When it comes to sets that map to A and B, the pA ˆ Bq-grid is\nideal--it projects on to both A and B as straightforwardly as possible. When it comes\nto sets that can interpret the elements of both A and B, the disjoint union A \\ B is\nideal--it includes both A and B without confusion or superfluity. These are limits and\ncolimits in Set. Limits and colimits exist in other categories as well.\nLimits in a preorder are meets, colimits in a preorder are joins. Limits and colimits\nalso exist for database instances and monoid actions, allowing us to discuss for example\nthe product or union of different state machines. Limits and colimits exist for spaces,\ngiving rise to products and unions, as well as quotients.\nLimits and colimits do not exist in every category; when C is complete with respect\nto limits (or colimits), these limits always seem to mean something valuable to human\nintuition. For example, when a subject has already been studied for a long time before\ncategory theory came around, it often turns out that classically interesting constructions\nin the subject correspond to limits and colimits in its categorification C. For example\nproducts, unions, equivalence relations, etc. are classical ideas in set theory that are\nnaturally captured by limits and colimits in Set.\n4.5.1\nProducts and coproducts in a category\nIn Sections 2.4, we discussed products and coproducts in the category Set of sets. Now\nwe discuss the same notions in an arbitrary category. For both products and coproducts\nwe will begin with examples and then write down the general concept, but we'll work on\nproducts first.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.5.1.1\nProducts\nThe product of two sets is a grid, which projects down onto each of the two sets. This\nis good intuition for products in general.\nExample 4.5.1.2. Given two preorders, X1 :\" pX1, d1q and X2 :\" pX2, d2q, we can take\ntheir product and get a new preorder X1 ˆ X2. Both X1 and X2 have underlying sets\n(namely X1 and X2), so we might hope that the underlying set of X1 ˆ X2 is the set\nX1 ˆX2 of ordered pairs, and this turns out to be true. We have a notion of less-than on\nX1 and we have a notion of less-than on X2; we need to construct a notion of less-than\non X1 ˆ X2. So, given two ordered pairs px1, x2q and px1\n1, x1\n2q, when should we say that\npx1, x2q d1,2 px1\n1, x1\n2q holds? The obvious guess is to say that it holds iffboth x1 d1 x1\nand x2 d2 x1\n2 hold, and this works:\nX1 ˆ X2 :\" pX1 ˆ X2, d1,2q\nNote that the projection functions X1 ˆ X2 N X1 and X1 ˆ X2 N X2 induce\nmorphisms of preorders. That is, if px1, x2q d1,2 px1\n1, x1\n2q then in particular x1 d x1\n1. So\nwe have preorder morphisms\nX1 ˆ X2\n\nX1\nX2\nExercise 4.5.1.3. Suppose that you have a partial order pS, dSq on songs (so you know\nsome songs are preferable to others but sometimes you can't compare). And suppose\nyou have a partial order pA, dAq on pieces of art. You're about to be given a pair ps, aq\nincluding a song and a piece of art. Does the product partial order S ˆ A provide a\nreasonable guess for your preferences on pairs?\n♦\nExercise 4.5.1.4. Consider the partial order d on N given by standard \"less-than-or-\nequal-to\", so 5 d 9 etc.\nAnd consider another partial order, divides on N, where\na divides b if \"a goes into b evenly\", i.e. if there exists n P N such that a n \" b, so\n5 divides 35. If we call the product order pX, lq :\" pN, dq ˆ pN, dividesq, which of\nthe following are true:\np2, 4q l p3, 4q?\np2, 4q l p3, 5q?\np2, 4q l p8, 0q?\np2, 4q l p0, 0q?\n♦\nExample 4.5.1.5. Given two graphs G1 \" pV1, A1, src1, tgt1q and G2 \" pV2, A2, src2, tgt2q,\nwe can take their product and get a new graph G1 ˆ G2. The vertices will be the grid\nof vertices V1 ˆ V2, so each vertex in G1 ˆ G2 is labeled by a pair of vertices, one from\nG1 and one from G2. When should an arrow connect pv1, v2q to pv1\n1, v1\n2q? Whenever we\ncan find an arrow in G1 connecting v1 to v1\n1 and we can find an arrow in G2 connecting\nv2 to v1\n2. It turns out there is a simple formula for the set of arrows in G1 ˆ G2, namely\nA1 ˆ A2.\nLet's write G :\" G1ˆG2 and say G \" pV, A, src, tgtq. We now know that V \" V1ˆV2\nand A \" A1 ˆ A2. What should the source and target functions A N V be? Given a\nfunction src1 : A1 N V1 and a function src2 : A2 N V2, the universal property of products\nin Set (Lemma 2.4.1.10 or better Example 2.4.1.16) provides a unique function\nsrc :\" src1 ˆ src2 : A1 ˆ A2 N V1 ˆ V2\n\n4.5. LIMITS AND COLIMITS\nNamely the source of arrow pa1, a2q will be the vertex psrc1pa1q, src2pa2qq. Similarly we\nhave a ready-made choice of target function tgt \" tgt1 ˆ tgt2. We have now defined the\nproduct graph.\nHere's a concrete example. Let I and J be as drawn below:\nI :\"\nv‚\nf\nw‚\ng\n\nh\n\nx‚\nJ :\"\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nArrow pJq\nID\nsrc\ntgt\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pJq\nID\nq\nr\ns\nt\nThe product I ˆJ drawn below has, as expected 3 4 \" 12 vertices and 3 4 \" 12 arrows:\nI ˆ J :\"\npv,qq\n‚\npf,iq\n!\npv,rq\n‚\n!\npv,sq\n‚\n}\n\npv,tq\n‚\npw,qq\n‚\n%\npw,rq\n‚\n%\npw,sq\n‚\ny\n%\npw,tq\n‚\npx,qq\n‚\npx,rq\n‚\npx,sq\n‚\npx,tq\n‚\nArrow\npI ˆ Jq\nID\nsrc\ntgt\npf, iq\npv, qq\npw, rq\npf, jq\npv, rq\npw, sq\npf, kq\npv, sq\npw, rq\npf, lq\npv, sq\npw, tq\npg, iq\npw, qq\npx, rq\npg, jq\npw, rq\npx, sq\npg, kq\npw, sq\npx, rq\npg, lq\npw, sq\npx, tq\nph, iq\npw, qq\npx, rq\nph, jq\npw, rq\npx, sq\nph, kq\npw, sq\npx, rq\nph, lq\npw, sq\npx, tq\nVertex\npI ˆ Jq\nID\npv, qq\npv, rq\npv, sq\npv, tq\npw, qq\npw, rq\npw, sq\npw, tq\npx, qq\npx, rq\npx, sq\npx, tq\nHere is the most important thing to notice.\nLook at the Arrow table for I ˆ J,\nand for each ordered pair, look only at the second entry in all three columns; you will\nsee something that matches with the Arrow table for J. Do the same for I, and again\nyou'll see a perfect match. These \"matchings\" are readily-visible graph homomorphisms\nI ˆ J N I and I ˆ J N J in Grph.\nExercise 4.5.1.6. Let r1s \"\n0‚\nf\nYYN\n1‚ be the linear order graph of length 1 and let P \"\nPathspr1sq be its paths-graph, as in Example 4.1.2.22 (so P should have three arrows\nand two vertices). Draw the graph P ˆ P.\n♦\nExercise 4.5.1.7. Recall from Example 3.5.2.9 that a discrete dynamical system (DDS)\nis a set s together with a function f : s N s. By now it should be clear that if\nLoop :\"\ns‚\nf\n\nCHAPTER 4. BASIC CATEGORY THEORY\nis the loop schema, then a DDS is simply an instance (a functor) I : Loop N Set. We\nhave not yet discussed products of DDS's, but perhaps you can guess how they should\nwork. For example, consider the instances I, J : Loop N Set tabulated below:\ns\n(I)\nID\nf\nA\nC\nB\nC\nC\nC\ns\n(J)\nID\nf\nx\ny\ny\nx\nz\nz\na.) Make a guess and tabulate I ˆ J. Then draw it.23\nb.) Recall the notion of natural transformations between functors (see Example 4.3.3.5),\nwhich in the case of functors Loop N Set are the morphisms of instances. Do you see\nclearly that there is a morphism of instances I ˆ J N I and I ˆ J N J? Just check\nthat if you look only at the left-hand coordinates in your I ˆ J, you see something\ncompatible with I.\n♦\nIn every case above, what's most important to recognize is that there are projection\nmaps IˆJ N I and IˆJ N J, and that the construction of IˆJ seems as straightforward\nas possible, subject to having these projections. It is time to give the definition.\nDefinition 4.5.1.8. Let C be a category and let X, Y P ObpCq be objects. A span on X\nand Y consists of three constituents pZ, p, qq, where Z P ObpCq is an object, and where\np: Z N X and q: Z N Y are morphisms in C.\nZ\np\n\nq\n\nX\nY\nA product of X and Y is a span X\nπ1\nÐY X ˆ Y\nπ2\nYN Y , 24 such that for any other span\nX\npÐY Z\nqYN Y there exists a unique morphism tp,q : Z N X ˆ Y such that the diagram\nbelow commutes:\nX ˆ Y\nπ1\n\nπ2\n\nX\nY\nZ\np\n\\\nq\nB\ntp,q\nO\nRemark 4.5.1.9. Definition 4.5.1.8 endows the product of two objects with something\nknown as a universal property. It says that a product of two objects X and Y maps to\n23The result is not necessarily inspiring, but at least computing it is straightforward.\n24The names X ˆ Y and π1, π2 are not mathematically important, they are pedagogically suggestive.\n\n4.5. LIMITS AND COLIMITS\nthose two objects, and serves as a gateway for all who do the same. \"None shall map\nto X and Y except through me!\" This grandiose property is held by products in all the\nvarious categories we have discussed so far. It is what I meant when I said things like\n\"X ˆY maps to both X and Y and does so as straightforwardly as possible\". The grid of\ndots obtained as the product of two sets has such a property, as was shown in Example\n2.4.1.11.\nExample 4.5.1.10. In Example 4.5.1.2 we discussed products of preorders. In this example\nwe will discuss products in an individual preorder. That is, by Proposition 4.2.1.17, there\nis a functor PrO N Cat that realizes every preorder as a category. If P \" pP, dq is\na preorder, what are products in P? Given two objects a, b P ObpPq we first consider\nspans on a and b, i.e. a Ð z N b. That would be some z such that z d a and z d b. The\nproduct will be such a span a e a ˆ b d b, but such that every other spanning object z\nis less than or equal to a ˆ b. In other words a ˆ b is as big as possible subject to the\ncondition of being less than a and less than b. This is precisely the meet of a and b (see\nDefinition 3.4.2.1).\nExample 4.5.1.11. Note that the product of two objects in a category C may not exist.\nLet's return to preorders to see this phenomenon.\nConsider the set R2, and say that px1, y1q d px2, y2q if there exists le 1 such that\nx1l\" x2 and y1l\" y2; in other words, point p is less than point q if, in order to travel\nfrom q to the origin along a straight line, one must pass through p along the way.\nWe have given a perfectly good partial order, but p :\" p1, 0q and q :\" p0, 1q do not\nhave a product. Indeed, it would have to be a non-zero point that was on the same\nline-through-the origin as p and the same line-through-the-origin as q, of which there are\nnone.\nExample 4.5.1.12. Note that there can be more than one product of two objects in a\ncategory C, but that any two choices will be canonically isomorphic. Let's return once\nmore to preorders to see this phenomenon.\nConsider the set R2 and say that px1, y1q d px2, y2q if x2\n1 ` y2\n1 d x2\n2 ` y2\n2, in other\nwords if the former is on a smaller 0-circle (by which I mean \"circle centered at the\norigin\") than the latter is.\nFor any two points p, q there will be lots of points that serve as products: anything\non the smaller of their two 0-circles will suffice. Given any two points a, b on this smaller\ncircle, we will have a unique isomorphism a - b because a d b and b d a and all\nmorphisms are unique in a preorder.\nExercise 4.5.1.13. Consider the preorder P of cards in a deck, shown in Example 3.4.1.3;\nit is not the entire story of cards in a deck, but take it to be so. In other words, be like\na computer and take what's there at face value. Consider the preorder P as a category\n(by way of the functor PrO N Cat).\na.) For each of the following pairs, what is their product in P (if it exists)?\n⌜a diamond⌝ˆ ⌜a heart⌝?\n⌜a queen⌝ˆ ⌜a black card⌝?\n⌜a card⌝ˆ ⌜a red card⌝?\n⌜a face card⌝ˆ ⌜a black card⌝?\nb.) How would these answers differ if P was completed to the \"whole story\" partial order\nclassifying cards in a deck?\n♦\n25Note that p0, 0q is not related to anything else.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nExercise 4.5.1.14. Let X be a set, and consider it as a discrete category. Given two\nobjects x, y P ObpXq, under what conditions will there exist a product x ˆ y?\n♦\nExercise 4.5.1.15. Let f : R N R be a function, like you would see in 6th grade (maybe\nfpxq \" x ` 7). A typical thing to do is to graph f as a curve running through the plane\nR2 :\" R ˆ R. This curve can be understood as a function F : R N R2.\na.) Given some x P R, what are the coordinates of Fpxq P R2?\nb.) Obtain F : R N R2 using the universal property given in Definition 4.5.1.8.\n♦\nExercise 4.5.1.16. Consider the preorder pN, dividesq, discussed in Exercise 4.5.1.4,\nwhere e.g. 5 d 15 but 5 e 6.\na.) What is the product of 9 and 12 in this category?\nb.) Is there a standard name for products in this category?\n♦\nExample 4.5.1.17. All products exist in the category Cat. Given two categories C and\nD, there is a product category C ˆ D. We have ObpC ˆ Dq \" ObpCq ˆ ObpDq and for\nany two objects pc, dq and pc1, d1q, we have\nHomCˆDppc, dq, pc1, d1qq \" HomCpc, c1q ˆ HomCpd, d1q.\nThe composition formula is \"obvious\".\nLet r1s P ObpCatq denote the linear order category of length 1, drawn\nr1s :\"\n0‚\nf\n/ 1‚\nAs a schema it has one arrow, but as a category it has three morphisms. So we expect\nr1sˆr1s to have 9 morphisms, and that's true. In fact, r1sˆr1s looks like a commutative\nsquare:\np0,0q\n‚\nid0ˆf\n/\nfˆid0\n\np0,1q\n‚\nfˆid1\n\np1,0q\n‚\nid1ˆf\n/ p1,1q\n‚\n(4.17)\nWe see only four morphisms here, but there are also four identities and one morphism\np0, 0q N p1, 1q given by composition of either direction. It is a minor miracle that the\ncategorical product somehow \"knows\" that this square should commute; however, this is\nnot the mere preference of man but instead the dictate of God! By which I mean, this\nfollows rigorously from the definitions we already gave of Cat and products.\n4.5.1.18\nCoproducts\nThe coproduct of two sets is their disjoint union, which includes non-overlapping copies\nof each of the two sets. This is good intuition for coproducts in general.\n\n4.5. LIMITS AND COLIMITS\nExample 4.5.1.19. Given two preorders, X1 :\" pX1, d1q and X2 :\" pX2, d2q, we can take\ntheir coproduct and get a new preorder X1 \\ X2. Both X1 and X2 have underlying sets\n(namely X1 and X2), so we might hope that the underlying set of X1 ˆX2 is the disjoint\nunion X1 \\ X2, and that turns out to be true. We have a notion of less-than on X1 and\nwe have a notion of less-than on X2.\nGiven an element x P X1 \\ X2 and an element x1 P X1 \\ X2, how can we use d1 and\nd2 to compare x1 and x2? The relation d1 only knows how to compare elements of X1\nand the relation d2 only knows how to compare elements of X2. But x and x1 may come\nfrom different homes; e.g. x P X1 and x1 P X2, in which case neither d1 nor d2 gives\nany clue about which should be bigger.\nSo when should we say that x d1\\2 x1 holds? The obvious guess is to say that x is\nless than x1 iffsomebody says it is; that is, if both x and x1 are from the same home and\nthe local ordering has x d x1. To be precise, we say x d1\\2 x1 if and only if either one\nof the following conditions hold:\n- x P X1 and x1 P X1 and x d1 x1, or\n- x P X2 and x1 P X2 and x d2 x1.\nWith d1\\2 so defined, one checks that it is not only a preorder, but that it serves as a\ncoproduct of X1 and X2,\nX1 \\ X2 :\" pX1 \\ X2, d1\\2q.\nNote that the inclusion functions X1 N X1\\X2 and X2 N X1\\X2 induce morphisms\nof preorders. That is, if x, x1 P X1 are elements such that x d1 x1 in X1 then the same\nwill hold in X1 \\ X2. So we have preorder morphisms\nX1 \\ X2\nX1\nA\nX2\n]\nExercise 4.5.1.20. Suppose that you have a partial order A :\" pA, dAq on apples (so\nyou know some apples are preferable to others but sometimes you can't compare). And\nsuppose you have a partial order O :\" pO, dOq on oranges. You're about to be given\ntwo pieces of fruit from a basket of apples and oranges. Is the coproduct partial order\nA \\ O a reasonable guess for your preferences, or does it seem biased?\n♦\nExample 4.5.1.21. Given two graphs G1 \" pV1, A1, src1, tgt1q and G2 \" pV2, A2, src2, tgt2q,\nwe can take their coproduct and get a new graph G1 \\ G2. The vertices will be the dis-\njoint union of vertices V1 \\ V2, so each vertex in G1 \\ G2 is labeled either by a vertex\nin G1 or by one in G2 (and if any labels are shared, then something must be done to\ndifferentiate them). When should an arrow connect v to v1? Whenever both are from the\nsame component (i.e. either v, v1 P V1 or v, v1 P V2) and we can find an arrow connecting\nthem in that component. It turns out there is a simple formula for the set of arrows in\nG1 \\ G2, namely A1 \\ A2.\nLet's write G :\" G1\\G2 and say G \" pV, A, src, tgtq. We now know that V \" V1\\V2\nand A \" A1 \\ A2. What should the source and target functions A N V be? Given\na function src1 : A1 N V1 and a function src2 : A2 N V2, the universal property of\ncoproducts in Set can be used to specify a unique function\nsrc :\" src1 \\ src2 : A1 \\ A2 N V1 \\ V2.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nNamely for any arrow a P A, we know either a P A1 or a P A2 (and not both), so the\nsource of a will be the vertex src1paq if a P A1 and src2paq if a P A2. Similarly we\nhave a ready-made choice of target function tgt \" tgt1 \\ tgt2. We have now defined the\ncoproduct graph.\nHere's a real example. Let I and J be as in Example 4.3.3.5, drawn below:\nI :\"\nv‚\nf\nw‚\ng\n\nh\n\nx‚\nJ :\"\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nu‚\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nArrow pJq\nID\nsrc\ntgt\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pJq\nID\nq\nr\ns\nt\nu\nThe coproduct I \\ J drawn below has, as expected 3 ` 5 \" 8 vertices and 3 ` 4 \" 7\narrows:\nI \\ J :\"\nv‚\nf\nw‚\ng\n\nh\n\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nx‚\nu‚\nArrow pI \\ Jq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pI \\ Jq\nID\nv\nw\nx\nq\nr\ns\nt\nu\nHere is the most important thing to notice. Look at the Arrow table I and notice\nthat there is a way to send each row to a row in I \\ J, such that all the foreign keys\nmatch. Similarly in the arrow table and the two vertex tables for J. These \"matchings\"\nare readily-visible graph homomorphisms I N I \\ J and J N I \\ J in Grph.\nExercise 4.5.1.22. Recall from Example 3.5.2.9 that a discrete dynamical system (DDS)\nis a set s together with a function f : s N s; if\nLoop :\"\ns‚\nf\n\nis the loop schema, then a DDS is simply an instance (a functor) I : Loop N Set. We\nhave not yet discussed coproducts of DDS's, but perhaps you can guess how they should\n\n4.5. LIMITS AND COLIMITS\nwork. For example, consider the instances I, J : Loop N Set tabulated below:\ns\n(I)\nID\nf\nA\nC\nB\nC\nC\nC\ns\n(J)\nID\nf\nx\ny\ny\nx\nz\nz\nMake a guess and tabulate I \\ J. Then draw it.\n♦\nIn every case above (preorders, graphs, DDSs), what's most important to recognize\nis that there are inclusion maps I N I \\ J and J N I \\ J, and that the construction of\nI \\ J seems as straightforward as possible, subject to having these inclusions. It is time\nto give the definition.\nDefinition 4.5.1.23. Let C be a category and let X, Y P ObpCq be objects. A cospan\non X and Y consists of three constituents pZ, i, jq, where Z P ObpCq is an object, and\nwhere i: X N Z and j : Y N Z are morphisms in C.\nZ\nX\ni\nE\nY\nj\nX\nA coproduct of X and Y is a cospan X\nι1\nYN X \\ Y\nι2\nÐY Y , 26 such that for any other\ncospan X\niYN Z\njÐY Y there exists a unique morphism si,j : X \\ Y N Z such that the\ndiagram below commutes:\nX \\ Y\nsi,j\n\nX\nι1\nB\ni\n\nY\nι2\n\\\nj\n\nZ\nRemark 4.5.1.24. Definition 4.5.1.8 endows the coproduct of two objects with a universal\nproperty. It says that a coproduct of two objects X and Y receives maps from those two\nobjects, and serves as a gateway for all who do the same. \"None shall receive maps from\nX and Y except through me!\" This grandiose property is held by all the coproducts we\nhave discussed so far. It is what I meant when I said things like \"X \\ Y receives maps\nfrom both X and Y and does so as straightforwardly as possible\". The disjoint union\nof dots obtained as the coproduct of two sets has such a property, as can be seen by\nthinking about Example 2.4.2.5.\nExample 4.5.1.25. By Proposition 4.2.1.17, there is a functor PrO N Cat that realizes\nevery preorder as a category. If P \" pP, dq is a preorder, what are coproducts in P?\nGiven two objects a, b P ObpPq we first consider cospans on a and b, i.e. a N z Ð b.\n26The names X \\ Y and ι1, ι2 are not mathematically important, they are pedagogically suggestive.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nA cospan of a and b is any z such that a d z and b d z. The coproduct will be such a\ncospan a d a \\ b e b, but such that every other cospanning object z is greater than or\nequal to a \\ b. In other words a \\ b is as small as possible subject to the condition of\nbeing bigger than a and bigger than b. This is precisely the join of a and b (see Definition\n3.4.2.1).\nJust as for products, the coproduct of two objects in a category C may not exist, or it\nmay not be unique. The non-uniqueness is much less \"bad\" because given two candidate\ncoproducts, they will be canonically isomorphic. They may not be equal, but they are\nisomorphic. But coproducts might not exist at all in certain categories. We will explore\nthat a bit below.\nExample 4.5.1.26. Consider the set R2 and partial order from Example 4.5.1.11 where\npx1, y1q d px2, y2q if there exists le 1 such that x1l\" x2 and y1l\" y2. Again the\npoints p :\" p1, 0q and q :\" p0, 1q do not have a coproduct. Indeed, it would have to\nbe a non-zero point that was on the same line-through-the origin as p and the same\nline-through-the-origin as q, of which there are none.\nExercise 4.5.1.27. Consider the preorder P of cards in a deck, shown in Example 3.4.1.3;\nit is not the entire story of cards in a deck, but take it to be so. In other words, be like a\ncomputer and take what's there at face value. Consider the preorder P as a category (by\nway of the functor PrO N Cat). For each of the following pairs, what is their coproduct\nin P (if it exists)?\na.)\n⌜a diamond⌝\\⌜a heart⌝?\n⌜a queen⌝\\⌜a black card⌝?\n⌜a card⌝\\⌜a red card⌝?\n⌜a face card⌝\\⌜a black card⌝?\nb.) How would these answers differ if P was completed to the \"whole story\" partial order\nclassifying cards in a deck?\n♦\nExercise 4.5.1.28. Let X be a set, and consider it as a discrete category. Given two\nobjects x, y P ObpXq, under what conditions will there exist a coproduct x \\ y?\n♦\nExercise 4.5.1.29. Consider the preorder pN, dividesq, discussed in Exercise 4.5.1.4,\nwhere e.g. 5 d 15 but 5 e 6.\na.) What is the coproduct of 9 and 12 in that category?\nb.) Is there a standard name for coproducts in that category?\n♦\n4.5.2\nDiagrams in a category\nWe have been drawing diagrams since the beginning of the book. What is it that we\nhave been drawing pictures of? The answer is that we have been drawing functors.\nDefinition 4.5.2.1. Let C and I be categories. 27 An I-shaped diagram in C is simply\na functor d: I N C. In this case I is called the indexing category for the diagram.\n27In fact, the indexing category I is usually assumed to be small in the sense of Remark 4.1.1.2,\nmeaning that its collection of objects is a set.\n\n4.5. LIMITS AND COLIMITS\nSuppose given an indexing category I and an I-shaped diagram X : I N C. One\ndraws this as follows. For each object in q P I, draw a dot labeled by Xpqq; if several\nobjects in I point to the same object in C, then several dots will be labeled the same way.\nDraw the images of morphisms f : q N q1 in I by drawing arrows between dots Xpqq\nand Xpq1q, and label each arrow by the image morphism Xpfq in C. Again, if several\nmorphisms in I are sent to the same morphism in C, then several arrows will be labeled\nthe same way. One can abbreviate this process by not drawing every morphism in I, so\nlong as every morphism in I is represented by a unique path in C, i.e. as long as the\ndrawing is sufficiently unambiguous as a depiction of X : I N C.\nExample 4.5.2.2. Consider the commutative diagram in Set drawn below:\nN\n`1 /\n\nN\n\nN\n`2 / Z\n(4.18)\nThis is the drawing of a functor d: r1s ˆ r1s N Set (see Example 4.5.1.17).\nWith\nnotation for the objects and morphisms of r1s ˆ r1s as shown in Diagram (4.17), we have\ndp0, 0q \" dp0, 1q \" dp1, 0q \" N and dp1, 1q \" Z (for some reason..) and dpid0, fq: N N N\ngiven by n ÞN n ` 1, etc.\nThe fact that d is a functor means it must respect composition formulas, which implies\nthat Diagram (4.18) commutes. Recall from Section 2.2 that not all diagrams one can\ndraw will commute; one must specify that a given diagram commutes if he or she wishes\nto communicate this fact. But then how is a non-commuting diagram to be understood\nas a functor?\nLet G P ObpGrphq denote the following graph\np0,0q\n‚\nf\n/\nh\np0,1q\n‚\ng\np1,0q\n‚\ni\n/ p1,1q\n‚\nRecall the free category functor F : Grph N Cat from Example 4.1.2.30.\nThe free\ncategory FpGq P ObpCatq on G looks almost like r1s ˆ r1s except that since rf, gs is a\ndifferent path in G than is rh, is, they become different morphisms in FpGq. A functor\nFpGq N Set might be drawn the same way that (4.18) is, but it would be a diagram\nthat would not be said to commute.\nWe call r1s ˆ r1s the commutative square indexing category. 28\nExercise 4.5.2.3. Consider r2s, the linear order category of length 2.\na.) Is r2s the appropriate indexing category for commutative triangles?\nb.) If not, what is?\n♦\n28We might call what is here denoted by FpGq the noncommutative square indexing category.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nExample 4.5.2.4. Recall that an equalizer in Set was a diagram of sets that looked like\nthis:\nE‚\nf\n/ A‚\ng1\n/\ng2\n/\nB‚\n(4.19)\nwhere g1 f \" g2 f. What is the indexing category for such a diagram? It is the schema\n(4.19) with the PED rf, g1s » rf, g2s. That is, in some sense you're seeing the indexing\ncategory, but the PED needs to be declared.\nExercise 4.5.2.5. Let C be a category, A P ObpCq an object, and f : A N A a morphism\nin C. Consider the two diagrams in C drawn below:\nA‚\nf\n/ A‚\nf\n/ A‚\nf\n/\nA‚\nf\na.) Should these two diagrams have the same indexing category?\nb.) If they should have the same indexing category, what is causing or allowing the\npictures to appear different?\nc.) If they should not have the same indexing category, what coincidence makes the two\npictures have so much in common?\n♦\nDefinition 4.5.2.6. Let I P ObpCatq be a category. The left cone on I, denoted IY, is\nthe category defined as follows. On objects we put ObpIYq \" t 8u\\ObpIq, and we call\nthe new object 8 the cone point of IY. On morphisms we add a single new morphism\nsb : 8 N b for every object b P ObpIq; more precisely,\nHomIYpa, bq \"\n$\n'\n'\n'\n&\n'\n'\n'\n%\nHomIpa, bq\nif a, b P ObpIq\ntsbu\nif a \" 8, b P ObpIq\ntid 8u\nif a \" b \" 8\nH\nif a P ObpIq, b \" 8.\nThe composition formula is in some sense obvious. To compose two morphisms both in\nI, compose as dictated by I; if one has 8 as source then there will be a unique choice\nof composite.\nThere is an obvious inclusion of categories,\nI N IY.\n(4.20)\nRemark 4.5.2.7. Note that the specification of IY given in Definition 4.5.2.6 works just\nas well if I is considered a schema and we are constructing a schema IY: add the new\nobject 8 and the new arrows sb : 8 N b for each b P ObpIq, and for every morphism\nf : b N b1 in I add a PED rsb1s » rsb, fs. We generally will not distinguish between\ncategories and schemas, since they are equivalent.\nExample 4.5.2.8. For a natural number n P N, we define the n-leaf star schema, denoted\nStarn, to be the category (or schema, see Remark 4.5.2.7) nY, where n is the discrete\n\n4.5. LIMITS AND COLIMITS\ncategory on n objects. Below we draw Star0, Star1, Star2, and Star3.\nStar0\n‚\nStar1\n‚\ns1\n\n1‚\nStar2\n‚\ns1\n\ns2\n\n1‚\n2‚\nStar3\n‚\ns1\n\ns2\n\ns3\n\n1‚\n2‚\n3‚\nExercise 4.5.2.9. Let C0 :\" 0 denote the empty category and for any natural number\nn P N, let Cn`1 \" pCnqY. Draw C4.\n♦\nExercise 4.5.2.10. Let C be the graph indexing schema as in (4.7). What is CY and how\ndoes it compare to (4.19)?\n♦\nDefinition 4.5.2.11. Let I P ObpCatq be a category. The right cone on I, denoted IZ,\nis the category defined as follows. On objects we put ObpIZq \" ObpIq\\t8u, and we call\nthe new object 8 the cone point of IZ. On morphisms we add a single new morphism\ntb : b N 8 for every object b P ObpIq; more precisely,\nHomIZpa, bq \"\n$\n'\n'\n'\n&\n'\n'\n'\n%\nHomIpa, bq\nif a, b P ObpIq\nttbu\nif a P ObpIq, b \" 8\ntid8u\nif a \" b \" 8\nH\nif a \" 8, b P ObpIq.\nThe composition formula is in some sense obvious. To compose two morphisms both in\nI, compose as dictated by I; if one has 8 as target then there will be a unique choice of\ncomposite.\nThere is an obvious inclusion of categories I N IZ.\nExercise 4.5.2.12. Let C be the category p2YqZ, where 2 is the discrete category on two\nobjects. Then C is somehow square-shaped, but what category is it exactly? Looking\nat Example 4.5.2.2, is C the commutative diagram indexing category r1s ˆ r1s, is it the\nnon-commutative diagram indexing category FpGq, or is it something else?\n♦\n4.5.3\nLimits and colimits in a category\nLet C be a category, let I be an indexing category (which just means that I is a category\nthat we're about to use as the indexing category for a diagram), and let D: I N C an\nI-shaped diagram (which just means a functor). It is in relation to this setup that we\ncan discuss the limit or colimit. In general the limit of a diagram D: I N C will be a IY\nshaped diagram lim D: IY N C. In the case of products I \" 2 and IY \" Star2 looks\nlike a span (see Example 4.5.2.8). But out of all the IY-shaped diagrams, which is the\nlimit of D? Answer: the one with the universal \"gateway\" property, see Remark 4.5.1.9.\n4.5.3.1\nUniversal objects\nDefinition 4.5.3.2. Let C be a category. An object a P ObpCq is called initial if, for\nall objects c P ObpCq there exists a unique morphism a N c, i.e. |HomCpa, cq| \" 1. An\nobject z P ObpCq is called terminal if, for all objects c P ObpCq there is exists a unique\nmorphism c N z, i.e. |HomCpc, zq| \" 1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nAn object in a category is called universal if it is either initial or terminal, but we\nrarely use that term in practice, preferring to be specific about whether the object is\ninitial or terminal. The word final is synonymous with the word terminal, but we'll try\nto constantly use terminal.\nColimits will end up being defined as initial things of a certain sort, and limits will\nend up being defined as terminal things of a certain sort. But we will get to that in\nSection 4.5.3.15.\nWarning 4.5.3.3. A category C may have more than one initial object; similarly a category\nC may have more than one terminal object. We will see in Example 4.5.3.5 that any set\nwith one element, e.g. t u or t,u, is a terminal object in Set. These terminal sets have\nthe same number of elements, but they are not the exact-same set; two sets having the\nsame cardinality means precisely that there exists an isomorphism between them.\nIn fact, Proposition 4.5.3.4 below shows that in any category C, any two terminal\nobjects in C are isomorphic (similarly, any two initial objects in C are isomorphic).\nWhile there are many isomorphisms in Set between t1, 2, 3u and ta, b, cu, there is only\none isomorphism between t u and ,. This is always the case for universal objects: there\nis a unique isomorphism between any two terminal (respectively initial) objects in any\ncategory.\nAs a result, people often speak of the initial object in C or the terminal object in C,\nas though there was only one. \"It's unique up to unique ismorphism!\" is the justification\nfor this use of the so-called definite article the rather than the indefinite article a. This\nis not a very misleading way of speaking, because just like the president today does not\ncontain exactly the same atoms as the president yesterday, the difference is unimportant.\nBut we still mention this as a warning: if C has a terminal object, we may speak of it as\nthough it were unique, calling it the terminal object, and similarly for initial objects.\nWe will use the definite article throughout this document, e.g. in Example 4.5.3.5\nwe will discuss the initial object in Set and the terminal object in Set. This is common\nthroughout mathematical literature as well.\nProposition 4.5.3.4. Let C be a category and let a1, a2 P ObpCq both be initial objects.\nThen there is a unique isomorphism a1\n-\nYN a2. (Similarly, for any two terminal objects\nin C there is a unique isomorphism between them.)\nProof. Suppose a1 and a2 are initial.\nSince a1 is initial there is a unique morphism\nf : a1 N a2; there is also a unique morphism a1 N a1, which must be ida1. Since a2 is\ninitial there is a unique morphism g: a2 N a1; there is also a unique morphism a2 N a2,\nwhich must be ida2. So g f \" ida1 and f g \" ida2, which means that f is the desired\n(unique) isomorphism.\nThe proof for terminal objects is appropriately \"dual\".\n□\nExample 4.5.3.5. The initial object in Set is the set a for which there is always one way\nto map from a to anything else. Given c P ObpSetq there is exactly one function H N c,\nbecause there are no choices to be made, so the empty set H is the initial object in Set.\nThe terminal object in Set is the set z for which there is always one way to map to\nz from anything else. Given c P ObpSetq there is exactly one function c N t,u, where\nt,u is any set with one element, because there are no choices to be made: everything in\nc must be sent to the single element in t,u. There are lots of terminal objects in Set,\nand they are all isomorphic to 1.\n\n4.5. LIMITS AND COLIMITS\nExample 4.5.3.6. The initial object in Grph is the graph a for which there is always one\nway to map from a to anything else. Given c P ObpGrphq, there is exactly one function\nH N c, where H P Grph is the empty graph; so H is the initial object.\nThe terminal object in Grph is more interesting. It is Loop, the graph with one\nvertex and one arrow. In fact there are infinitely many terminal objects in Grph, but\nall of them are isomorphic to Loop.\nExercise 4.5.3.7. Let X be a set, let PpXq be the set of subsets of X (see Definition\n2.7.4.9). We can regard PpXq as a preorder under inclusion of subsets (see for example\nSection 3.4.2). And we can regard preorders as categories using a functor PrO N Cat\n(see Proposition 4.2.1.17).\na.) What is the initial object in PpXq?\nb.) What is the terminal object in PpXq?\n♦\nExample 4.5.3.8. The initial object in the category Mon of monoids is the trivial monoid,\n1. For any monoid M, a morphism of monoids 1 N M is a functor between 1-object\ncategories and these are determined by where they send morphisms. Since 1 has only\nthe identity morphism and functors must preserve identities, there is no choice involved\nin finding a monoid morphism 1 N M.\nSimilarly, the terminal object in Mon is also the trivial monoid, 1. For any monoid\nM, a morphism of monoids M N 1 sends everything to the identity; there is no choice.\nExercise 4.5.3.9.\na.) What is the initial object in Grp, the category of groups?\nb.) What is the terminal object in Grp?\n♦\nExample 4.5.3.10. Recall the preorder Prop of logical propositions from Section 4.2.4.1.\nThe initial object is a proposition that implies all others. It turns out that \"FALSE\" is\nsuch a proposition. The proposition \"FALSE\" is like \"1 % 1\"; in logical formalism it can\nbe shown that if \"FALSE\" is true then everything is true.\nThe terminal object in Prop is a proposition that is implied by all others. It turns\nout that \"TRUE\" is such a proposition. In logical formalism, everything implies that\n\"TRUE\" is true.\nExample 4.5.3.11. The discrete category 2 has no initial object and no terminal ob-\nject. The reason is that it has two objects 1, 2, but no maps from one to the other, so\nHom2p1, 2q \" Hom2p2, 1q \" H.\nExercise 4.5.3.12. Recall the divides preorder from Exercise 4.5.1.4, where 5 divides 15.\na.) Considering this preorder as a category, does it have an initial object?\nb.) Does it have a terminal object?\n♦\nExercise 4.5.3.13. Let M \" pListpta, buq, r s, ``q denote the free monoid on ta, bu (see\nDefinition 3.1.1.15), considered as a category (via Theorem 4.2.1.3).\na.) Does it have an initial object?\n\nCHAPTER 4. BASIC CATEGORY THEORY\nb.) Does it have a terminal object?\nc.) Which monoids have initial (respectively terminal) objects?\n♦\nExercise 4.5.3.14. Let S be a set and consider the indiscrete category KS P ObpCatq on\nobjects S (see Example 4.3.4.3).\na.) For what S does KS have an initial object?\nb.) For what S does KS have a terminal object?\n♦\n4.5.3.15\nExamples of limits\nLet C be a category and let X, Y P ObpCq be objects. Definition 4.5.1.8 defines a product\nof X and Y to be a span X\nπ1\nÐY X ˆY\nπ2\nYN Y such that for every other span X\npÐY Z\nqYN Y\nthere exists a unique morphism Z N X ˆ Y making the triangles commute. It turns out\nthat we can enunciate this in our newly formed language of universal objects by saying\nthat the span X\nπ1\nÐY X ˆ Y\nπ2\nYN Y is itself a terminal object in the category of spans\non X and Y . Phrasing the definition of products in this way will be generalizable to\ndefining arbitrary limits.\nConstruction 4.5.3.16 (Products). Let C be a category and let X1, X2 be objects. We can\nconsider this setup as a diagram X : 2 N C, where Xp1q \" X1 and Xp2q \" X2. Consider\nthe category 2Y \" Star2, which is drawn in Example 4.5.2.8; the inclusion i: 2 N 2Y, as\nin (4.20); and the category of functors Funp2Y, Cq. The objects in Funp2Y, Cq are spans\nin C and the morphisms are natural transformations between them. Given a functor\nS : 2Y N C we can compose with i: 2 N 2Y to get a functor 2 N C. We want that to be\nX.\nX\n/\ni\n\nC\n2Y\nS\n?\nSo we are ready to define the category of spans on X1 and X2.\nDefine the category of spans on X, denoted C{X, to be the category whose objects\nand morphisms are as follows:\nObpC{Xq \" tS : 2Y N C | S i \" Xu\n(4.21)\nHomC{XpS, S1q \" tα: S N S1 | α i \" idXu.\nThe product of X1 and X2 was defined in Definition 4.5.1.8; we can now recast X1 ˆ X2\nas the terminal object in C{X.\nTo bring this down to earth, an object in C{X can be pictured as a diagram in C of\nthe following form:\nZ\np\n\nq\n\nX1\nX2\n\n4.5. LIMITS AND COLIMITS\nIn other words, the objects of C{X are spans, each of which we might write in-line as\nX1\npÐY Z\nqYN X2. A morphism in C{X from object X1\npÐY Z\nqYN X2 to object X1\np1\nÐY Z1\nq1\nYN\nX2 consists of a morphism l: Z N Z1, such that p1 l\" p and q1 l\" q. So the set of\nsuch morphisms in C{X are all the l's that make the right-hand diagram commute: 29\nHomC{X\n\nZ\np\n\nq\n\nX1\nX2\n,\nZ1\np1\n\nq1\n\nX1\nX2\n\n‹‹‚\n\"\n$\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n&\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n%\nZ\np\n\nq\n\nl\n\nX1\nX2\nZ1\np1\nY\nq1\nE\n,\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n.\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n-\n(4.22)\nEach object in C{X is a span on X1 and X2, and each morphism in C{X is a \"morphism\nof cone points in C making everything in sight commute\". The terminal object in C{X is\nthe product of X1 and X2; see Definition 4.5.1.8.\nIt may be strange to have a category in which the objects are spans in another\ncategory. But once you admit this possibility, the notion of morphism between spans\nis totally sensible. Or if it isn't, then stare at (4.22) for 30 seconds and say to yourself\n\"When in Rome..!\" These are the aqueducts of category theory, and they work wonders.\nExample 4.5.3.17. Consider the arbitrary 6-object category C drawn below, in which the\n29To be completely pedantic, according to (4.21), the morphisms in C{X should be drawn like this:\nHomC{X\n\nZ\np\n\nq\n\nX1\nX2\n,\nZ1\np1\n\nq1\n\nX1\nX2\n\n‹‹‹‹‚\n\"\n$\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n&\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n%\nZ\np\n\nq\n\nα 8\n\nX1\nα1\nX2\nα2\nX1\nX2\nZ1\np1\nY\nq1\nE\n,\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n.\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n-\nBut this is going a bit overboard. The point is, the set HomC{X is the set of morphisms serving the role\nof α 8 : Z N Z1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nthree diagrams that can commute do:\nC :\"\nX1‚\nA‚\na\nB‚\nf\no\n✓\nb1\n@\nb2\n\nC‚\n✓\n✓\nc1\n^\nc2\ng\n/ D‚\nd1\nl\nd2\nr\nX2‚\nLet X : 2 N C be given by Xp1q \" X1 and Xp2q \" X2. Then the category of spans on\nX might be drawn\nC{X -\npB,b1,b2q\n‚\npC,c1,c2q\n‚\ng\n/ pD,d1,d2q\n‚\n4.5.3.18\nDefinition of limit\nDefinition 4.5.3.19. Let C be a category, let I be a category; let IY be the left cone on\nI, and let i: I N IY be the inclusion. Suppose that X : I N C is an I-shaped diagram\nin C. The slice category of C over X denoted C{X is the category whose objects and\nmorphisms are as follows:\nObpC{Xq \" tS : IY N C | S i \" Xu\nHomC{XpS, S1q \" tα: S N S1 | α i \" idXu.\nA limit of X, denoted limI X or lim X, is a terminal object in C{X.\nPullbacks\nThe relevant indexing category for pullbacks is the cospan, I \" 2Z drawn\nas to the left below:\nI\n0‚\n\n1‚\n\n2‚\nX : I N C\nX0‚\n\nX1‚\nX2‚\nA I-shaped diagram in C is a functor X : I N C, which we might draw as to the right\nabove (e.g. X0 P ObpCq).\n30We use a dash box here because we're not drawing the whole category but merely a diagram existing\ninside C.\n\n4.5. LIMITS AND COLIMITS\nAn object S in the slice category C{X is a commutative diagram S : IY N C over X,\nwhich looks like the box to the left below:\nS P ObpC{Xq\nS 8\n!\n}\nX0‚\n\nX1‚\n~\nX2‚\nf : S N S1\nS 8\n\nf\n\nS1\n\n~\nX0‚\n\nX1‚\n~\nX2‚\nA morphism in C{X is drawn in the dashbox to the right above. A terminal object in\nC{X is precisely the \"gateway\" we want, i.e. the limit of X is the pullback X0 ˆX2 X1.\nExercise 4.5.3.20. Let I be the graph indexing category (see 4.7).\na.) What is IY?\nb.) Now let G: I N Set be the graph from Example 3.3.1.2. Give an example of an\nobject in Set{G.\nc.) We have already given a name to the limit of G: I N Set; what is it?\n♦\nExercise 4.5.3.21. Let C be a category and let I \" H be the empty category. There is a\nunique functor X : H N C.\na.) What is the slice category C{X?\nb.) What is the limit of X?\n♦\nExample 4.5.3.22. Often one wants to take the limit of some strange diagram. We have\nnow constructed the limit for any shape diagram. For example, if we want to take the\nproduct of more than two, say n, objects, we could use the diagram shape I \" n whose\ncone is Starn from Example 4.5.2.8.\nExample 4.5.3.23. We have now defined limits in any category, so we have defined limits\nin Cat. Let r1s denote the category depicted\n0‚\ne\n/ 1‚\nand let C be a category. Naming two categories is the same thing as naming a functor\nX : 2 N Cat, so we now have such a functor. Its limit is denoted r1s ˆ C. It turns\nout that r1s ˆ C looks like a \"C-shaped prism\". It consists of two panes, front and back\nsay, each having the precise shape as C (same objects, same arrows, same composition),\nand morphisms from the front pane to the back pane making all front-to-back squares\n\nCHAPTER 4. BASIC CATEGORY THEORY\ncommute. For example, if C looked was the category generated by the schema to the left\nbelow, then C ˆ r1s would be the category generated by the schema to the right below:\nA‚\nf\n/\ng\n\nB‚\nh\n\nC‚\nD‚\nA1‚\nf1\n/\ng1\nB1‚\nh1\n\nA0‚\nAe\n@\nf0\n/\ng0\n\nB0‚\nBe\n@\nh0\n\nC1‚\nD1‚\nC0‚\nCe\n@\nD0‚\nDe\n@\nIt turns out that a natural transformation α: F N G between functors F, G: C N D\nis the same thing as a functor C ˆ r1s N D such that the front pane is sent via F\nand the back pane is sent via G. The components are captured by the front-to-back\nmorphisms, and the naturality is captured by the commutativity of the front-to-back\nsquares in C ˆ r1s.\nRemark 4.5.3.24. Recall in Section 2.7.6.6 we described relative sets. In fact, Definition\n2.7.6.7 basically defines a category of relative sets over any fixed set B. Let 1 denote the\ndiscrete category on one object, and note that providing a functor 1 N Set is the same\nas simply providing a set, so consider B : 1 N Set. Then the slice category Set{B, as\ndefined in Definition 4.5.3.19 is precisely the category of relative sets over B: it has the\nsame objects and morphisms as was described in Definition 2.7.6.7.\n4.5.3.25\nDefinition of colimit\nThe definition of colimits is appropriately \"dual\" to the definition of limits.\nInstead\nof looking at left cones, we look at right cones; instead of being interested in terminal\nobjects, we are interested in initial objects.\nDefinition 4.5.3.26. Let C be a category, let I be a category; let IZ be the right cone\non I, and let i: I N IZ be the inclusion. Suppose that X : I N C is an I-shaped diagram\nin C. The coslice category of C over X denoted CX{ is the category whose objects and\nmorphisms are as follows:\nObpCX{q \" tS : IZ N C | S i \" Xu\nHomCX{pS, S1q \" tα: S N S1 | α i \" idXu.\nA colimit of X, denoted colimI X or colim X, is an initial object in CX{.\n\n4.5. LIMITS AND COLIMITS\nPushouts\nThe relevant indexing category for pushouts is the span, I \" 2Y drawn as\nto the left below:\nI\n1‚\n2‚\n0‚\n\\\nB\nX : I N C\nX1‚\nX2‚\nX0‚\n^\n@\nAn I-shaped diagram in C is a functor X : I N C, which we might draw as to the right\nabove (e.g. X0 P ObpCq).\nAn object S in the coslice category CX{ is a commutative diagram S : IZ N C over\nX, which looks like the box to the left below:\nS P ObpCX{q\nS8\nX1‚\n>\nX2‚\n`\nX0‚\n_\n?\nf : S N S1\nS1\nS8\nf\nO\nX1‚\n>\n<\nX2‚\n`\na\nX0‚\n?\n_\nA morphism in CX{ is drawn in the dashbox to the right above. An initial object in CX{\nis precisely the \"gateway\" we want; i.e. the colimit of X is the pushout, X1 \\X0 X2.\nExercise 4.5.3.27. Let I be the graph indexing category (see 4.7).\na.) What is IZ?\nb.) Now let G: I N Set be the graph from Example 3.3.1.2. Give an example of an\nobject in SetG{.\nc.) We have already given a name to the colimit of G: I N Set; what is it?\n♦\nExercise 4.5.3.28. Let C be a category and let I \" H be the empty category. There is a\nunique functor X : H N C.\na.) What is the coslice category CX{?\nb.) What is the colimit of X (assuming it exists)?\n♦\n\nCHAPTER 4. BASIC CATEGORY THEORY\nExample 4.5.3.29 (Cone as colimit). We have now defined colimits in any category, so we\nhave defined colimits in Cat. Let C be a category and recall from Example 4.5.3.23 the\ncategory C ˆ r1s. The inclusion of the front pane is a functor i0 : C N C ˆ r1s (similarly,\nthe inclusion of the back pane is a functor i1 : C N C ˆ r1s). Finally let t: C N 1 be the\nunique functor to the terminal category (see Exercise 4.1.2.37). We now have a diagram\nin Cat of the form\nC\ni0 /\nt\n\nC ˆ r1s\nThe colimit (i.e. the pushout) of this diagram in Cat slurps down the entire front pane\nof C ˆ r1s to a point, and the resulting category is isomorphic to CY. Figure 4.23 is a\ndrawing of this phenomenon.\n\n4.5. LIMITS AND COLIMITS\nC :\"\nA0‚\n/\n\nB0‚\n\nC0‚\nD0‚\ni0\n/\nC ˆ r1s\nA1‚\n/\n\nB1‚\n\nA0‚\n@\n/\n\nB0‚\n@\n\nC1‚\nD1‚\nC0‚\n@\nD0‚\n@\nt\n\n‚\n/\nA1‚\n/\n\nB1‚\n\n‚\n?\n\n_\n\nC1‚\nD1‚\nCY - pC ˆ r1sq \\C 1\nFigure 4.23: Let C be the category drawn in the upper left corner. The left cone CY on\nC is obtained as a pushout in Cat. We first make a prism C ˆ r1s, and then identify the\nfront pane with a point.\n(Similarly, the pushout of the analogous diagram for i1 would give CZ.)\nExample 4.5.3.30. Consider the category Top of topological spaces. The (hollow) circle\nis a topological space which people often denote S1 (for \"1-dimensional sphere\"). The\nfilled-in circle, also called a 2-dimensional disk, is denoted D2. The inclusion of the circle\ninto the disk is continuous so we have a morphism in Top of the form i: S1 N D2. The\nterminal object in Top is the one-point space t,u, and so there is a unique morphism\nt: S1 N t,u.\nThe pushout of the diagram D2\niÐY S1\ntYN t,u is isomorphic to the\n2-dimensional sphere (the exterior of a tennis ball), S2. The reason is that we have\nslurped the entire bounding circle to a point, and the category of topological spaces has\nthe right morphisms to ensure that the resulting space really is a sphere.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nApplication 4.5.3.31. Consider the symmetric graph Gn consisting of a chain of n vertices,\n1‚\n2‚\n\nn‚\nThink of this as modeling a subway line.\nThere are n-many graph homomorphisms\nG1 N Gn given by the various vertices. One can create transit maps using colimits. For\nexample, the colimit of the diagram to the left is the symmetric graph drawn to the right\nbelow.\ncolim\n\nG1\n/\n\nG7\nG1\no\n\nG5\nG3\nG1\nO\n/ G7\nG1\nO\no\n\n‹‹‹‹‹‹‹‹‹‹‚\ncan be drawn\n‚5\n1‚\n2‚\n3‚\n4‚4\n5‚\n6‚1\n7‚\n‚3\n1‚\n2‚\n3‚2\n4‚\n5‚2\n6‚\n7‚\n‚1\n‚3\n♦♦\n4.6\nOther notions in Cat\nIn this section we discuss some leftover notions about categories. For example in Section\n4.6.1 we explain a kind of duality for categories, in which arrows are flipped. For example\nreversing the order in a preorder is an example of this duality, as is the similarity between\nlimits and colimits. In Section 4.6.2 we discuss the so-called Grothendieck construction\nwhich in some sense graphs functors, and we show that it is useful for transforming\ndatabases into the kind of format (RDF) used in scraping data offwebpages. We define\na general construction for creating categories in Section 4.6.4. Finally, in Section 4.6.5\nwe show that precisely the same arithmetic statements that held for sets in Section 2.7.3\nhold for categories.\n4.6.1\nOpposite categories\nPeople used to discuss two different kinds of functors between categories: the so-called\ncovariant functors and the so-called contravariant functors.\nCovariant functors are\nwhat we have been calling functors.\nThe reader may have come across the idea of\ncontravariance when considering Exercise 4.2.3.2.31\nThere we saw that a continuous\nmapping of topological spaces f : X N Y does not induce a morphism of orders on\ntheir open sets OpenpXq N OpenpY q; that is not required by the notion of continuity.\nInstead, a morphism of topological spaces f : X N Y induces a morphism of orders\nOpenpY q N OpenpXq, going backwards. So we do not have a functor Top N PrO\nin this way, but it's quite close. One used to say that Open is a contravariant functor\nTop N PrO.\n31Similarly, see Exercise 4.2.4.4.\n\n4.6. OTHER NOTIONS IN CAT\nAs important and common as contravariance is, people found that keeping track of\nwhich functors were covariant and which were contravariant was a big hassle. Luck-\nily, there is a simple work-around, which simplifies everything: the notion of opposite\ncategories.\nDefinition 4.6.1.1. Let C be a category. The opposite category of C, denoted Cop, has\nthe same objects as C, i.e. ObpCopq \" ObpCq, and for any two objects c, c1, one defines\nHomCoppc, c1q :\" HomCpc1, cq.\nExample 4.6.1.2. If n P N is a natural number and n the corresponding discrete category,\nthen nop \" n. Recall the span category I \" 2Y from Definition 4.5.1.8. Its opposite is\nthe cospan category Iop \" 2Z, from Definition 4.5.1.23.\nExercise 4.6.1.3. Let C be the category from Example 4.5.3.17. Draw Cop.\n♦\nLemma 4.6.1.4. Let C and D be categories.\nOne has pCopqop \" C.\nAlso we have\nFunpC, Dq - FunpCop, Dopq. This implies that a functor Cop N D can be identified with\na functor C N Dop.\nProof. This follows straightforwardly from the definitions.\n□\nExercise 4.6.1.5. In Exercises 4.2.3.2, 4.2.4.3, and 4.2.4.4 there were questions about\nwhether a certain function ObpCq N ObpDq extended to a functor C N D. In each case,\nsee if the proposed function would extend to a \"contravariant functor\" i.e. to a functor\nCop N D.\n♦\nExample 4.6.1.6 (Simplicial sets). Recall from Example 4.3.4.4 the category ∆of linear\norders rns. For example, r1s is the linear order 0 d 1 and r2s is the linear order 0 d 1 d 2.\nBoth r1s and r2s are objects of ∆. There are 6 morphisms from r1s to r2s, which we\ncould denote\nHom∆pr1s, r2sq \" tp0, 0q, p0, 1q, p0, 2q, p1, 1q, p1, 2q, p2, 2qu.\nIt may seem strange, but the category ∆op turns out to be quite useful in algebraic\ntopology.\nIt is the indexing category for a combinatorial approach to the homotopy\ntheory of spaces. That is, we can represent something like the category of spaces and\ncontinuous maps using the functor category sSet :\" Funp∆op, Setq, which is called the\ncategory of simplicial sets.\nThis may seem very complicated compared to something we did earlier, namely sim-\nplicial complexes. But simplicial sets have excellent formal properties that simplicial\ncomplexes do not. We will not go further with this here, but through the work of Dan\nKan, Andr e Joyal, Jacob Lurie, and many others, simplicial sets have allowed category\ntheory to pierce deeply into the realm of topology and vice versa.\n4.6.2\nGrothendieck construction\nLet C be a database schema (or category) and let J : C N Set be an instance. We have\nbeen drawing this in table form, but there is another standard way of laying out the data\nin J, called the resource descriptive framework or RDF. Developed for the web, RDF is a\nuseful format when one does not have a schema in hand, e.g. when scraping information\n\nCHAPTER 4. BASIC CATEGORY THEORY\noffof a website, one does not know what schema will be best. In these cases, information\nis stored in so-called RDF triples, which are of the form\nxSubject, Predicate, Objecty\nFor example, one might see something like\nSubject\nPredicate\nObject\nA01\noccurredOn\nD13114\nA01\nperformedBy\nP44\nA01\nactionDescription\nTold congress to raise debt ceiling\nD13114\nhasYear\nD13114\nhasMonth\nJanuary\nD13114\nhasDay\nP44\nFirstName\nBarack\nP44\nLastName\nObama\n(4.24)\nCategory-theoretically, it is quite simple to convert a database instance J : C N Set\ninto an RDF triple store. To do so, we use the Grothendieck construction, which is more\naptly named the category of elements construction, defined below.32\nDefinition 4.6.2.1. Let C be a category and let J : C N Set be a functor. The category\nof elements of J, denoted\ns\nC J, is defined as follows:\nObp\nw\nC\nJq :\" tpC, xq | C P ObpCq, x P JpCqu.\nHoms\nC JppC, xq, pC1, x1qq :\" tf : C N C1 | Jpfqpxq \" x1u.\nThere is a natural functor πJ :\ns\nC J YN C. It sends each object pC, xq P Obp\ns\nC Jq to\nthe object C P ObpCq. And it sends each morphism f : pC, xq N pC1, x1q to the morphism\nf : C N C1. We call πJ the projection functor.\nExample 4.6.2.2. Let A be a set, and consider it as a discrete category.\nWe saw in\nExercise 4.3.3.4 that a functor S : A N Set is the same thing as an A-indexed set, as\ndiscussed in Section 2.7.6.10. We will follow Definition 2.7.6.12 and for each a P A write\nSa :\" Spaq.\nWhat is the category of elements of a functor S : A N Set? The objects of\ns\nA S are\npairs pa, sq where a P A and s P Spaq. Since A has nothing but identity morphisms,\ns\nA S\nhas nothing but identity morphisms; i.e. it is the discrete category on a set. In fact that\nset is the disjoint union\nw\nA\nS \"\ng\naPA\nSa.\nThe functor πS :\ns\nA S N A sends each element in Sa to the element a P A.\n32Apparently, Alexander Grothendieck did not invent this construction, it was discussed prior to\nGrothendieck's use of it, e.g. by Mac Lane. But more to the point, the term Grothendieck construction is\nnot grammatically suited in the sense that both the following are awkward in English: \"the Grothendieck\nconstruction of J is ...\" (awkward because J is not being constructed but used in a construction) and\n\"the Grothendieck construct for J is...\" (awkward because it just is). The term category of elements is\nmore descriptive and easier to use grammatically.\n\n4.6. OTHER NOTIONS IN CAT\nOne can see this as a kind of histogram. For example, let A \" tBOS, NYC, LA, DCu and\nlet S : A N Set assign\nSBOS \" tAbby, Bob, Casandrau,\nSNYC \" H,\nSLA \" tJohn, Jimu, and\nSDC \" tAbby, Carlau.\nThen the category of elements of S would look like the (discrete) category at the top:\nw\nA\nS \"\npBOS,Abbyq\n‚\npBOS,Bobq\n‚\npLA,Johnq\n‚\npDC,Abbyq\n‚\npBOS,Casandraq\n‚\npLA,Jimq\n‚\npDC,Carlaq\n‚\n(4.25)\nπS\n\nA \"\nBOS\n‚\nNYC\n‚\nLA‚\nDC‚\nWe also see that the category of elements construction has converted an A-indexed\nset into a relative set over A, as in Definition 2.7.6.7.\nThe above example does not show at all how the Grothendieck construction trans-\nforms a database instance into an RDF triple store. The reason is that our database\nschema was A, a discrete category that specifies no connections between data (it simply\ncollects the data into bins). So lets examine a more interesting database schema and\ninstance. This is taken from [Sp2].\nApplication 4.6.2.3. Consider the schema below, which we first encountered in Example\n3.5.2.1:\nC :\"\nEmployee manager worksIn » Employee worksIn\nDepartment secretary worksIn » Department\nEmployee\n‚\nworksIn\n/\nmanager\n\nfirst\n~\nlast\n\nDepartment\n‚\nsecretary\no\nname\n\nFirstNameString\n‚\nLastNameString\n‚\nDepartmentNameString\n‚\n(4.26)\n\nCHAPTER 4. BASIC CATEGORY THEORY\nAnd consider the instance J : C N Set, which we first encountered in (3.13) and (3.15)\nEmployee\nID\nfirst\nlast\nmanager\nworksIn\nDavid\nHilbert\nq10\nBertrand\nRussell\nx02\nEmmy\nNoether\nq10\nDepartment\nID\nname\nsecretary\nq10\nSales\nx02\nProduction\nFirstNameString\nID\nAlan\nBertrand\nCarl\nDavid\nEmmy\nLastNameString\nID\nArden\nHilbert\nJones\nNoether\nRussell\nDepartmentNameString\nID\nMarketing\nProduction\nSales\nThe category of elements of J : C N Set looks like this:\nw\nC\nJ \"\n‚\nfirst\n\nlast\n,\nmanager\nA\nworksIn\n(\n‚\n‚\nq10\n‚\nx02\n‚\nsecretary\nh\nname\n}\nAlan\n‚\nHilbert\n‚\nProduction\n‚\nBertrand\n‚\nRussell\n‚\nSales\n‚\nDavid\n‚\nNoether\n‚\nMarketing\n‚\nEmmy\n‚\nArden\n‚\nCarl\n‚\nJones\n‚\nπJ\n\n(4.27)\nC \"\nEmployee\n‚\nworksIn\n/\nmanager\n\nfirst\n\nlast\n\nDepartment\n‚\nsecretary\no\nname\n\nFirstNameString\n‚\nLastNameString\n‚\nDepartmentNameString\n‚\n\n4.6. OTHER NOTIONS IN CAT\nIn the above drawing (4.27) of\ns\nC J, we left out 10 arrows for ease of readability, for\nexample, we left out an arrow\n‚\nfirst\nYYYYYYN\nBertrand\n‚\n.\nFor the punchline, how do we see the category of elements\ns\nC J as an RDF triple\nstore? For each arrow in\ns\nC J, we take the triple consisting of the source vertex, the\narrow name, and the target vertex. So our triple store would include triples such as\nx102 first Bertrandy and x101 manager 103y.\n♦♦\nExercise 4.6.2.4. Come up with a schema and instance whose category of elements con-\ntains (at least) the data from (4.24).\n♦\nSlogan 4.6.2.5.\n\" The Grothendieck construction takes structured, boxed-up data and flattens\nit by throwing it all into one big space. The projection functor is then tasked\nwith remembering which box each datum originally came from. \"\nExercise 4.6.2.6. Recall from Section 3.1.2.10 that a finite state machine is a free monoid\npListpΣq, r s, ``q acting on a set X. Recall also that we can consider a monoid as a\ncategory M with one object and a monoid action as a set-valued functor F : M N Set,\n(see Section 4.2.1.1). In the case of Figure 3.1 the monoid in question is Listpa, bq, which\ncan be drawn as the schema\n▲\na\nb\ne\nand the functor F : M N Set is recorded in an action table in Example 3.1.3.1. What\nis\ns\nM F? How does it relate to the picture in Figure 3.1?\n♦\n4.6.3\nFull subcategory\nDefinition 4.6.3.1. Let C be a category and let X D ObpCq be a set of objects in C.\nThe full subcategory of C spanned by X is the category, which we denote by COb\"X, with\nobjects ObpCOb\"Xq :\" X and with morphisms HomCOb\"Xpx, x1q :\" HomCpx, x1q.\nExample 4.6.3.2. The following are examples of full subcategories. We will name them in\nthe form \"X inside of Y \", and each time we mean that X and Y are names of categories,\nthe category X can be considered as a subcategory of the category Y in some sense, and\nit is full. In other words, all morphisms in Y \"count\" as morphisms in X.\n- Finite sets inside of sets, Fin D Set;\n- Finite sets of the form n inside of Fin;\n- Linear orders of the form rns inside of all finite linear orders, ∆D FLin;\n- Groups inside of monoids, Grp D Mon;\n- Monoids inside of categories, Mon D Cat;\n- Sets inside of graphs, Set D Grph;\n- Partial orders (resp. linear orders) inside of PrO;\n\nCHAPTER 4. BASIC CATEGORY THEORY\n- Discrete categories (resp. indiscrete categories) inside of Cat;\nRemark 4.6.3.3. A subcategory C D D is (up to isomorphism) just a functor i: C N D\nthat happens to be injective on objects and arrows. The subcategory is full if and only\nif i is a full functor in the sense of Definition 4.3.4.12.\nExample 4.6.3.4. Let C be a category, let X D ObpCq be a set of objects, and let COb\"X\ndenote the full subcategory of C spanned by X. We can realize this as a fiber product\nof categories. Indeed, recall that for any set, we can form the indiscrete category on\nthat set; see Example 4.3.4.3.\nIn fact, we have a functor Ind: Set N Cat.\nThus\nour function X N ObpCq can be converted into a functor between indiscrete categories\nIndpXq N IndpObpCqq. There is also a functor C N IndpObpCqq sending each object to\nitself. Then the full subcategory of C spanned by X is the fiber product of categories,\nCOb\"X\n/\n\nC\n\nIndpXq\n/ IndpObpCqq\nExercise 4.6.3.5. Including all identities and all compositions, how many morphisms are\nthere in the full subcategory of Set spanned by the objects t0, 1, 2u? Write them out. ♦\n4.6.4\nComma categories\nCategory theory includes a highly developed and interoperable catalogue of materials\nand production techniques. One such is the comma category.\nDefinition 4.6.4.1. Let A, B, and C be categories and let F : A N C and G: B N C\nbe functors. The comma category of C morphisms from F to G, denoted pF OC Gq or\nsimply pF O Gq, is the category with objects\nObpF O Gq \" tpa, b, fq | a P ObpAq, b P ObpBq, f : Fpaq N Gpbq in Cu\nand for any two objects pa, b, fq and pa1, b1, f 1q the set HompF OGqppa, b, fq, pa1, b1, f 1qq of\nmorphisms pa, b, fq YN pa1, b1, f 1q is\ntpq, rq | q: a N a1 in A, r: b N b1 in B, such that f 1 Fpqq \" Gprq fu.\nIn pictures,\nHompF OGqppa, b, fq, pa1, b1, f 1qq :\"\n$\n'\n'\n'\n'\n'\n&\n'\n'\n'\n'\n'\n%\na\nq\n\nFpaq\n✓\nf\n/\nF pqq\n\nGpbq\nGprq\n\nb\nr\n\na1\nFpa1q\nf 1\n/ Gpb1q\nb1\n,\n/\n/\n/\n/\n/\n.\n/\n/\n/\n/\n/\n-\nWe refer to the diagram A\nFYN C\nG\nÐY B (in Cat) as the setup for the comma category\npF O Gq.\nThere is a canonical functor pF O Gq N A called left projecton, sending pa, b, fq to a,\nand a canonical functor pF O Gq N B called right projection, sending pa, b, fq to b.\n\n4.6. OTHER NOTIONS IN CAT\nA setup A\nFYN C\nG\nÐY B is reversable; i.e. we can flip it to obtain B\nG\nYN C\nF\nÐY A.\nHowever, note that pF O Gq is different than (i.e. almost never equivalent to) pG O Fq,\nunless every arrow in C is an isomorphism.\nSlogan 4.6.4.2.\n\" When two categories A, B can be interpreted in a common setting C, the\ncomma category integrates them by recording how to move from A to B\ninside C. \"\nExample 4.6.4.3. Let C be a category and I : C N Set a functor. In this example we\nshow that the comma category construction captures the notion of taking the category\nof elements\ns\nC I; see Definition 4.6.2.1.\nConsider the set 1, the category Discp1q, and the functor F : Discp1q N Set sending\nthe unique object to the set 1. We use the comma category setup 1\nF\nYYYN Set\nI\nÐYYY C.\nThere is an isomorphism of categories\nz\nC\nI - pF O Iq.\nIndeed, an object in pF O Iq is a triple pa, b, fq where a P Obp1q, b P ObpCq, and\nf : Fpaq N Ipbq is a morphism in Set. There is only one object in 1, so this reduces to\na pair pb, fq where b P ObpCq and f : t,u N Ipbq. The set of functions t,u N Ipbq is\nisomorphic to Ipbq, as we saw in Exercise 2.1.2.14. So we have reduced ObpF O Iq to the\nset of pairs pb, xq where b P ObpCq and x P Ipbq; this is Obp\ns\nC Iq. Because there is only\none function 1 N 1, a morphism pb, xq N pb1, x1q in pF O Iq boils down to a morphism\nr: b N b1 such that the diagram\nx / Ipbq\nIprq\n\nx1 / Ipb1q\ncommutes.\nBut such diagrams are in one-to-one correspondence with the diagrams\nneeded for morphisms in\ns\nC I.\nExercise 4.6.4.4. Let C be a category and let c, c1 P ObpCq be objects. Consider them\nas functors c, c1 : 1 N C, and consider the setup 1\nc\nYYYN C\nc1\nÐYYY 1. What is the comma\ncategory pc O c1q?\n♦\n4.6.5\nArithmetic of categories\nIn Section 2.7.3, we summarized some of the properties of products, coproducts, and\nexponentials for sets, attempting to show that they lined up precisely with familiar\narithmetic properties of natural numbers. Astoundingly, we can do the same for cate-\ngories.\nIn the following proposition, we denote the coproduct of two categories A and B by\nthe notation A ` B rather than A \\ B. We also denote the functor category FunpA, Bq\nby BA. Finally, we use 0 and 1 to refer to the discrete category on 0 and on 1 object,\nrespectively.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nProposition 4.6.5.1. The following isomorphisms exist for any small categories A, B,\nand C.\n- A ` 0 - A\n- A ` B - B ` A\n- pA ` Bq ` C - A ` pB ` Cq\n- A ˆ 0 - 0\n- A ˆ 1 - A\n- A ˆ B - B ˆ A\n- pA ˆ Bq ˆ C - A ˆ pB ˆ Cq\n- A ˆ pB ` Cq - pA ˆ Bq ` pA ˆ Cq\n- A0 - 1\n- A1 - A\n- 0A - 0,\nif A % 0\n- 1A - 1\n- AB`C - AB ˆ AC\n- pABqC - ABˆC\nProof. These are standard results; see [Mac].\n□\n\nChapter 5\nCategories at work\nWe have now set up an understanding of the basic notions of category theory: categories,\nfunctors, natural transformations, and universal properties. We have discussed many\nsources of examples: orders, graphs, monoids, and databases. We begin this chapter with\nthe notion of adjoint functors (also known as adjunctions), which are like dictionaries\nthat translate back and forth between different categories.\n5.1\nAdjoint functors\nJust above, in the introduction to this chapter, I said that adjoint functors are like\ndictionaries that translate back and forth between different categories. How far can we\ntake that analogy?\nIn the common understanding of dictionaries, we assume that the two languages (say\nFrench and English) are equally expressive, and that a good dictionary will be an even\nexchange of ideas. But in category theory we often have two categories that are not\non the same conceptual level. This is most clear in the case of so-called free-forgetful\nadjunctions. In Section 5.1.1 we will explore the sense in which each adjunction provides\na dictionary between two categories that are not necessarily on an equal footing, so to\nspeak.\n5.1.1\nDiscussion and definition\nConsider the category of monoids and the category of sets. A monoid pM, e, ‹q is a set\nwith an identity element and a multiplication formula that is associative. A set is just\na set. A dictionary between Mon and Set should not be required to set up an even\nexchange, but instead an exchange that is appropriate to the structures at hand. It will\nbe in the form of two functors, one we'll denote by L: Set N Mon, and one we'll denote\nby R: Mon N Set. But to say what \"appropriate\" means requires more work.\nLet's bring it down to earth with an analogy. A one-year-old can make repeatable\nnoises and an adult can make repeatable noises. One might say \"after all, talking is noth-\ning but making repeatable noises.\" But the adult's repeatable noises are called words,\nthey form sentences, and these sentences can cause nuclear wars. There is something\nmore in adult language than there is simply in repeatable sounds. In the same vein, a\ntennis match can be viewed as physics, but you won't see the match. So we have some-\nthing analogous to two categories here: ((repeated noises)) and ((meaningful words)).\n\nCHAPTER 5. CATEGORIES AT WORK\nWe are looking for adjoint functors going back and forth, serving as the appropriate sort\nof dictionary.\nTo translate baby talk into adult language we would make every repeated noise a\nkind of word, thereby granting it meaning. We don't know what a given repeated noise\nshould mean, but we give it a slot in our conceptual space, always pondering \"I wonder\nwhat she means by Konnen..\" On the other hand, to translate from meaningful words to\nrepeatable noises is easy. We just hear the word as a repeated noise, which is how the\nbaby probably hears it.\nAdjoint functors often come in the form of \"free\" and \"forgetful\". Here we freely\nadd Konnen to our conceptual space without having any idea how it adheres to the\nrest of the child's noises or feelings. But it doesn't act like a sound to us, it acts like\na word; we don't know what it means but we figure it means something. Conversely,\nthe translation going the other way is \"forgetful\", forgetting the meaning of our words\nand just hearing them as sounds. The baby hears our words and accepts them as mere\nsounds, not knowing that there is anything extra to get.\nBack to sets and monoids, the sets are like the babies from our story: they are\nsimple objects full of unconnected dots. The monoids are like adults, forming words and\nperforming actions. In the monoid, each element means something and combines with\nother elements in some way. There are lots of different sets and lots of different monoids,\njust as there are many babies and many adults, but there are patterns to the behavior\nof each kind and we put them in different categories.\nApplying free functor L: Set N Mon to a set X makes every element x P X a word,\nand these words can be strung together to form more complex words. (We discussed\nthe free functor in Section 3.1.1.12.) Since a set such as X carries no information about\nthe meaning or structure of its various elements, the free monoid FpXq does not relate\ndifferent words in any way. To apply the forgetful functor R: Mon N Set to a monoid,\neven a structured one, is to simply forget that its elements are anything but mere elements\nof a set. It sends a monoid pM, 1, ‹q to the set M.\nThe analogy is complete. However, this is all just ideas. Let's give a definition, then\nreturn to our sets, monoids, sounds, and words.\nDefinition 5.1.1.1. Let B and A be categories. 1 An adjunction between B and A is a\npair of functors\nL: B N A\nand\nR: A N B\ntogether with a natural isomorphism 2 whose component for any objects A P ObpAq and\nB P ObpBq is:\nαB,A : HomApLpBq, Aq\n-\nYYYN HomBpB, RpAqq.\n(5.1)\nThis isomorphism is called the adjunction isomorphism for the pL, Rq adjunction, and\nfor any morphism f : LpBq N A in A, we refer to αB,Apfq: B N RpAq as the adjunct of\nf. 3\n1Throughout this definition, notice that B's come before A's, especially in (5.1), which might be\nconfusing. It was a stylistic choice to match with the Babies and Adults discussion above and below\nthis definition.\n2The natural isomorphism α (see Lemma 4.3.2.12) is between two functors Bop ˆ A N Set, namely\nthe functor pB, Aq ÞN HomApLpBq, Aq and the functor pB, Aq ÞN HomBpB, RpAqq.\n3Conversely, for any g : B N RpAq in B we refer to α 1\nB,Apgq: LpBq N A as the adjunct of g.\n\n5.1. ADJOINT FUNCTORS\nThe functor L is called the left adjoint and the functor R is called the right adjoint.\nWe may say that L is the left adjoint of R or that R is the right adjoint of L.\n4 We\noften denote this setup by\nL: B\n/ A :R\no\nProposition 5.1.1.2. Let L: Set N Mon be the functor sending X P ObpSetq to the\nfree monoid LpXq :\" pListpXq, r s, ``q, as in Definition 3.1.1.15. Let R: Mon N Set\nbe the functor sending each monoid M :\" pM, 1, ‹q to its underlying set RpMq :\" M.\nThen L is left adjoint to R.\nProof. If we can find a natural isomorphism of sets\nαX,M : HomMonpLpXq, Mq N HomSetpX, RpMqq\nwe will have succeeded in showing that these functors are adjoint.\nSuppose given an element f P HomMonpLpXq, Mq, i.e. a monoid homomorphism\nf : ListpXq N M (sending r s to 1 and list concatenation to ‹). Then in particular we\ncan apply f to the singleton list rxs for any x P X. This gives a function X N M by\nx ÞN fprxsq, and this is αX,Mpfq: X N M \" RpMq. We need only to supply an inverse\nβX,M : HomSetpX, RpMqq N HomMonpLpXq, Mq.\nSuppose given an element g P HomSetpX, RpMqq, i.e. a function g: X N M. Then to\nany list l\" rx1, x2, . . . , xns P ListpXq we can assign βX,Mplq :\" gpx1q‹gpx2q‹ ‹gpxnq\n(if l\" r s is the empty list, assign βX,Mpr sq :\" 1). We now have a function ListpXq N M.\nIt is a monoid homomorphism because it respects identity and composition. It is easy\nto check that β and α are mutually inverse, completing the proof.\n□\nExample 5.1.1.3. We need to ground our discussion in some concrete mathematics. In\nProposition 5.1.1.2 we provided our long-awaited adjunction between sets and monoids.\nA set X gets transformed into a monoid by considering lists in X; a monoid M gets\ntransformed into a set by forgetting the multiplication law. So we have a functor going\none way and the other,\nL: Set N Mon,\nR: Mon N Set,\nbut an adjunction is more than that: it includes a guarantee about the relationship\nbetween these two functors. What is the relationship between L and R? Consider an\narbitrary monoid M \" pM, 1, q.\nIf I want to pick out 3 elements of the set M, that's the same thing as giving a\nfunction ta, b, cu N M. But that function exists in the category of sets; in fact it is\nan element of HomSetpta, b, cu, Mq. But since M \" RpMq is the underlying set of our\nmonoid, we can view the current paragraph in the light of our adjunction Equation (5.1)\nby saying it has been about the set\nHomSetpta, b, cu, RpMqq.\nThis set classifies all the ways to pick three elements out of the underlying set of our\nmonoid M. It was constructed completely from within the category Set.\n4The left adjoint does not have to be called L, nor does the right adjoint have to be called R, of\ncourse. This is suggestive.\n\nCHAPTER 5. CATEGORIES AT WORK\nNow we ask what Equation (5.1) means. The equation\nHomMonpLpta, b, cuq, Mq - HomSetpta, b, cu, RpMqq.\ntells us that somehow we can answer the same question completely from within the cat-\negory of monoids. In fact it tells us how to do so, namely as HomMonpListpt1, 2, 3u, Mq.\nExercise 5.1.1.4 looks at how that should go. The answer is \"hidden\" in the proof of\nProposition 5.1.1.2.\nExercise 5.1.1.4. Let X \" ta, b, cu and let M \" pN, 1, q be the multiplicative monoid\nof natural numbers (see Example 3.1.3.2).\nLet f : X N N be the function given by\nfpaq \" 7, fpbq \" 2, fpcq \" 2, and let βX,M : HomSetpX, RpMqq N HomMonpLpXq, Mq\nbe as in the proof of Proposition 5.1.1.2. What is βX,Mpfqprb, b, a, csq?\n♦\nLet us look once more at the adjunction between adults and babies.\nUsing the\nnotation of Definition 5.1.1.1 A is the \"adult category\" of meaningful words and B is the\n\"baby category\" of repeated noises. The left adjoint turns every repeated sound into a\nmeaningful word (having \"free\" meaning) and the right adjoint \"forgets\" the meaning of\nany word and considers it merely as a sound.\nAt the risk of taking this simple analogy too far, let's have a go at the heart of the\nissue: how to conceive of the isomorphism (5.1) of Hom's. Once we have freely given a\nslot to each of baby's repeated sounds, we try to find a mapping from the lexicon LpBq\nof these new words to our own lexicon A of meaningful words; these are mappings in\nthe adult category A of the form LpBq N A. And (stretching it) the baby tries to find\na mapping (which we might see as emulation) from her set B of repeatable sounds to\nthe set RpAq of the sounds the adult seems to repeat. If there was a global system for\nmaking these transformations that would establish (5.1) and hence the adjunction.\nNote that the directionality of the adjunction makes a difference. If L: B N A is left\nadjoint to R: A N B we rarely have an isomorphism HomApA, LpBqq - HomBpRpAq, Bq.\nIn the case of babies and adults, we see that it would make little sense to look for a\nmapping in the category of meaningful words from the adult lexicon to the wordifications\nof baby-sounds, because there is unlikely to be a good candidate for most of our words.\nThat is, to which of our child's repeated noises would we assign the concept \"weekday\"?\nAgain, the above is simply an analogy, and almost certainly not formalizable. The\nnext example shows mathematically the point we tried to make in the previous para-\ngraph, that the directionality of an adjunction is not arbitrary.\nExample 5.1.1.5. Let L: Set N Mon and R: Mon N Set be the free and forgetful\nfunctors from Proposition 5.1.1.2. We know that L is left adjoint to R; however L is not\nright adjoint to R. In other words, we can show that the necessary natural isomorphism\ncannot exist.\nLet X \" ta, bu and let M \" pt1u, 1, !q be the trivial monoid. Then the necessary\nnatural isomorphism would need to give us a bijection\nHomMonpM, LpXqq -? HomSetpt1u, Xq.\nBut the left-hand side has one element, because M is the initial object in Mon (see Ex-\nample 4.5.3.8), whereas the right-hand side has two elements. Therefore no isomorphism\ncan exist.\nExample 5.1.1.6. Preorders have underlying sets, giving rise to a functor U : PrO N Set.\nThe functor U has both a left adjoint and a right adjoint.\nThe left adjoint of U is\nD: Set N PrO, sending a set X to the discrete preorder on X (the preorder with\n\n5.1. ADJOINT FUNCTORS\nunderlying set X, having the fewest possible d's). The right adjoint of U is I : Set N\nPrO, sending a set X to the indiscrete preorder on X (the preorder with underlying set\nX, having the most possible d's). See Example 3.4.4.5.\nExercise 5.1.1.7. Let U : Grph N Set denote the functor sending a graph to its under-\nlying set of vertices. This functor has both a left and a right adjoint.\na.) What functor Set N Grph is the left adjoint of U?\nb.) What functor Set N Grph is the right adjoint of U?\n♦\nExample 5.1.1.8. Here are some other adjunctions:\n- Ob: Cat N Set has a left adjoint Set N Cat given by the discrete category.\n- Ob: Cat N Set has a right adjoint Set N Cat given by the indiscrete category.\n- The underlying graph functor Cat N Grph has a left adjoint Grph N Cat given\nby the free category.\n- The functor PrO N Grph, given by drawing edges for d's, has a left adjoint given\nby existence of paths.\n- The forgetful functor from posets to preorders has a left adjoint given by quotient\nby isomorphism relation.\n- Given a set A, the functor p ˆ Aq: Set N Set has a right adjoint HompA, q\n(this was called currying in Section 2.7.2).\nExercise 5.1.1.9. Let F : C N D and G: D N C be mutually inverse equivalences of\ncategories (see Definition 4.3.4.1). Are they adjoint in one direction or the other?\n♦\nExercise 5.1.1.10. The discrete category functor Disc: Set N Cat has a left adjoint\np: Cat N Set.\na.) For an arbitrary object X P ObpSetq and an arbitrary object C P ObpCatq, write\ndown the adjunction isomorphism.\nb.) Let C be the free category on the graph G:\nG :\"\nv‚\nf\n/ w‚\nh\n?\ng\nx‚\ny‚\ni\n\nj\nz‚\nk\n_\nand let X \" t1, 2, 3u. How many elements does the set HomSetpC, DiscpXqq have?\nc.) What can you do to an arbitrary category C to make a set ppCq such that the\nadjunction isomorphism holds? That is, how does the functor p behave on objects?\n♦\n\nCHAPTER 5. CATEGORIES AT WORK\nThe following proposition says that all adjoints to a given functor are isomorphic to\neach other.\nProposition 5.1.1.11. Let C and D be categories, let F : C N D be a functor, and\nlet G, G1 : D N C also be functors. If both G and G1 are right adjoint (respectively left\nadjoint) to F then there is a natural isomorphism φ: G N G1.\nProof. Suppose that both G and G1 are right adjoint to F (the case of G and G1 being\nleft adjoint is similarly proved). We first give a formula for the components of φ: G N G1\nand its inverse ψ: G1 N G. Given an object d P ObpDq, we use c \" Gpdq to obtain two\nnatural isomorphisms, one from each adjunction:\nHomCpGpdq, Gpdqq - HomDpFpGpdqq, dq - HomCpGpdq, G1pdqq.\nThe identity component idGpdq is then sent to some morphism Gpdq N G1pdq, which we\ntake to be φd. Similarly, we use c1 \" G1pdq to obtain two natural isomorphisms, one from\neach adjunction:\nHomCpG1pdq, G1pdqq - HomDpFpG1pdqq, dq - HomCpG1pdq, Gpdqq.\nAgain, the identity component idG1pdq is sent to some morphism G1pdq N Gpdq, which\nwe take to be ψd. The naturality of the isomorphisms implies that φ and ψ are natural\ntransformations, and it is straightforward to check that they are mutually inverse.\n□\n5.1.1.12\nQuantifiers as adjoints\nOne of the simplest but neatest places that adjoints show up is between preimages and\nthe logical quantifiers D and @, which we first discussed in Notation 2.1.1.1.\nThe setting\nin which to discuss this is that of sets and their power preorders. That is, if X is a set\nthen recall from Section 3.4.2 that the power set PpXq has a natural ordering by inclusion\nof subsets.\nGiven a function f : X N Y and a subset V D Y the preimage is f 1pV q :\" tx P\nX | fpxq P V u. If V 1 D V then f 1pV 1q D f 1pV q, so in fact f 1 : PpY q N PpXq can be\nconsidered a functor (where of course we are thinking of preorders as categories). The\nquantifiers appear as adjoints of f 1.\nLet's begin with the left adjoint of f 1 : PpY q N PpXq. It is a functor Lf : PpXq N\nPpY q. Choose an object U D X in PpXq. It turns out that\nLfpUq \" ty P Y | Dx P f 1pyq such that x P Uu.\nAnd the right adjoint Rf : PpXq N PpY q, when applied to U is\nRfpUq \" ty P Y | @x P f 1pyq, x P Uu.\nIn fact, the functor Lf is generally denoted Df : PpXq N PpY q, and Rf is generally\ndenoted @f : PpXq N PpY q.\nPpXq\nDf\n(\n@f\n6 PpY q.\nf 1\no\nWe will see in the next example why this notation is apt.\n\n5.1. ADJOINT FUNCTORS\nExample 5.1.1.13. In logic or computer science, the quantifiers D and @ are used to\nask whether any or all elements of a set have a certain property.\nFor example, one\nmay have a set of natural numbers and want to know whether any or all are even or\nodd. Let Y \" teven, oddu, and let p: N N Y be the function that takes assigns to\neach natural number its parity (even or odd). Because the elements of PpNq and PpY q\nare ordered by \"inclusion of subsets\", we can construe these orders as categories (by\nProposition 4.2.1.17). That's all old; what's new is that we have adjunctions between\nthese categories\nPpNq\nDp\n(\n@p\n6 PpY q.\np 1\no\nGiven a subset U D N, i.e.\nan object U P ObpPpNqq, we investigate the objects\nDppUq, @ppUq. These are both subsets of teven, oddu. The set DppUq includes the el-\nement even if there exists an even number in U; it includes the element odd if there\nexists an odd number in U. Similarly, the set @ppUq includes the element even if every\neven number is in U and it includes odd if every odd number is in U. 5\nWe explain just one of these in terms of the definitions. Let V \" tevenu D Y . Then\nf 1pV q D N is the set of even numbers, and there is a morphism f 1pV q N U in PpNq\nif and only if U contains all the even numbers. Therefore, the adjunction isomorphism\nHomPpNqpf 1pV q, Uq - HomPpY qpV, @pUq says that V D @pU, i.e. @ppUq includes the\nelement even if and only if U contains all the even numbers, as we said above.\nExercise 5.1.1.14. The national Scout jamboree is a gathering of Boy Scouts from troops\nacross the US. Let X be the set of Boy Scouts in the US, and let Y be the set of Boy\nScout troops in the US. Let t: X N Y be the function that assigns to each Boy Scout\nhis troop. Let U D X be the set of Boy Scouts in attendance at this years jamboree.\nWhat is the meaning of the objects DtU and @tU?\n♦\nExercise 5.1.1.15. Let X be a set and U D X a subset. Find a set Y and a function\nf : X N Y such that DfpUq somehow tells you whether U is non-empty, and such that\n@fpUq somehow tells you whether U \" X.\n♦\nIn fact, \"quantifiers as adjoints\" is part of a larger story. Suppose we think of elements\nof a set X as bins, or storage areas. An element of PpXq can be construed as an injection\nU aN X, i.e. an assignment of a bin to each element of U, with at most one element of U\nin each bin. Relaxing that restriction, we may consider arbitrary sets U and assignments\nU N X of a bin to each element u P U. Given a function f : X N Y , we can generalize\nDf and @f to functors denoted Σf and Πf, which will parameterize disjoint unions and\nproducts (respectively) over y P Y . This will be discussed in Section 5.1.4.\n5.1.2\nUniversal concepts in terms of adjoints\nIn this section we discuss how universal concepts, i.e. initial objects and terminal objects,\ncolimits and limits, are easily phrased in the language of adjoint functors. We will say\nthat a functor F : C N D is a left adjoint if there exists a functor G: D N C such that F\nis a left adjoint of G. We showed in Proposition 5.1.1.11 that if F is a left adjoint of some\nfunctor G, then it is isomorphic to every other left adjoint of G, and G is isomorphic to\nevery other right adjoint of F.\n5It may not be clear that by this point we have also handled the question, \"is every element of U\neven?\" One simply checks that odd is not an element of DpU.\n\nCHAPTER 5. CATEGORIES AT WORK\nExample 5.1.2.1. Let C be a category and t: C N 1 the unique functor to the terminal\ncategory. Then t is a left adjoint if and only if C has a terminal object, and t is a right\nadjoint if and only if C has an initial object. The proofs are dual, so let's focus on the\nfirst.\nThe functor t has a right adjoint R: 1 N C if and only if there is an isomorphism\nHomCpc, rq - Hom1ptpcq, 1q,\nwhere r \" Rp1q. But Hom1ptpcq, 1q has one element. Thus t has a right adjoint iffthere\nis a unique morphism c N r in C. This is the definition of r being a terminal object.\nWhen we defined colimits and limits in Definitions 4.5.3.26 and 4.5.3.19 we did so for\nindividual I-shaped diagrams X : I N C. Using adjoints we can define the limit of every\nI-shaped diagram in C at once.\nLet t: C N 1 denote the unique functor to the terminal category. Given an object\nc P ObpCq, consider it as a functor c: 1 N C. Then c t: I N C is the constant functor\nat c, sending each object in I to the same C-object c, and every morphism in I to idc.\nThis induces a functor that we denote by ∆t : C N FunpI, Cq.\nSuppose we want to take the colimit or limit of X. We are given an object X of\nFunpI, Cq and we want back an object of C. We could hope, and it turns out to be true,\nthat the adjoints of ∆t are the limit and colimit. Indeed let Σt : FunpI, Cq N C be the\nleft adjoint of ∆t, and let Πt : FunpI, Cq N C be the right adjoint of ∆t. Then Σt is the\nfunctor that takes colimits, and Πt is the functor that takes limits.\nWe will work with a generalization of colimits and limits in Section 5.1.4. But for\nnow, let's bring this down to earth with a concrete example.\nExample 5.1.2.2. Let C \" Set, and let I \" 3. The category FunpI, Setq is the category\nof t1, 2, 3u-indexed sets, e.g. pZ, N, Zq P ObpFunpI, Setqq is an object of it. The functor\n∆t : Set N FunpI, Setq acts as follows.\nGiven a set c P ObpSetq, consider it as a\nfunctor c: 1 N Set, and the composite c t: I N Set is the constant functor. That is,\n∆tpcq: I N Set is the t1, 2, 3u-indexed set pc, c, cq.\nTo say that ∆t has a right adjoint called Πt : FunpI, Setq N Set and that it \"takes\nlimits\" should mean that if we look through the definition of right adjoint, we will see\nthat the formula will somehow yield the appropriate limit. Fix a functor D: I N Set, so\nDp1q, Dp2q, and Dp3q are sets. The limit lim D of D is the product Dp1q ˆ Dp2q ˆ Dp3q.\nFor example, if D \" pZ, N, Zq then lim D \" Z ˆ N ˆ Z. How does this fact arise in the\ndefinition of adjoint?\nThe definition of Πt being the right adjoint to ∆t says that there is a natural isomor-\nphism of sets,\nHomFunpI,Setqp∆tpcq, Dq - HomSetpc, ΠtpDqq.\n(5.2)\nThe left-hand side has elements f P HomFunpI,Setqp∆tpcq, Dq that look like the left below,\nbut having these three maps is equivalent to having the diagram to the right below:\nc\nfp1q\n\nc\nfp2q\n\nc\nfp3q\n\nDp1q\nDp2q\nDp3q\nc\nfp1q\n\nfp2q\n\nfp3q\n\nDp1q\nDp2q\nDp3q\n\n5.1. ADJOINT FUNCTORS\nThe isomorphism in (5.2) says that choosing the three maps fp1q, fp2q, fp3q is the same\nthing as choosing a function c N ΠtpDq. But this is very close to the universal property\nof limits: there is a unique map l: c N Dp1q ˆ Dp2q ˆ Dp3q, so this product serves well\nas Πt as we have said. We're not giving a formal proof here, but what is missing at\nthis point is the fact that certain diagrams have to commute. This comes down to the\nnaturality of the isomorphism (5.2). The map linduces a naturality square\n∆tpcq\n∆tplq/\nf\n\n∆tΠtD\nπ\n\nD\nD\nwhich says that the following diagram commutes:\nc\nfp1q\n|\nfp2q\n\nfp3q\n\"\nl\n\nDp1q\nDp2q\nDp3q\nDp1q ˆ Dp2q ˆ Dp3q\nπ1\nb\nπ2\nO\nπ3\n<\nIt is not hard to show that the composition of left adjoints is a left adjoint, and the\ncomposition of right adjoints is a right adjoint. In the following example we show how\ncurrying (as in Sections 2.7.2 and 5.1.1.8) arises out of a certain combination of data\nmigration functors.\nExample 5.1.2.3 (Currying via ∆, Σ, Π). Let A, B, and C be sets. Consider the unique\nfunctor a: A N 1 and consider B and C as functors 1\nB\nYYYN Set and 1\nC\nYYYN Set\nrespectively.\nA\na\n/ 1\nB\n#\nC\n=Set\nNote that 1-Set - Set, and we will elide the difference. Our goal is to see currying\narise out of the adjunction between Σa ∆a and Πa ∆a, which tells us that there is an\nisomorphism\nHomSetpΣa∆apBq, Cq - HomSetpB, Πa∆apCqq.\n(5.3)\nBy definition, ∆apBq: A N Set assigns to each element a P A the set B. Since ΣA\ntakes disjoint unions, we have a bijection\nΣap∆apBqq \"\nz\naPA\nB\n\n- A ˆ B.\n\nCHAPTER 5. CATEGORIES AT WORK\nSimilarly ∆apCq: A N Set assigns to each element a P A the set C. Since ΠA takes\nproducts, we have a bijection\nΠap∆apCqq \"\nz\naPA\nC\n\n- CA.\nThe currying isomorphism HomSetpA ˆ B, Cq - HomSetpB, CAq falls out of (5.3).\n5.1.3\nPreservation of colimits or limits\nOne useful fact about adjunctions is that left adjoints preserve all colimits and right\nadjoints preserve all limits.\nProposition 5.1.3.1. Let L: B\n/ A :R\no\nbe an adjunction. For any indexing cate-\ngory I and functor D: I N B, if D has a colimit in B then there is a unique isomorphism\nLpcolim Dq - colimpL Dq.\nSimilarly, for any I P ObpCatq and functor D: I N A, if D has a limit in A then\nthere is a unique isomorphism\nRplim Dq - limpR Dq.\nProof. The proof is simple if one knows the Yoneda lemma (Section 5.2.1.12). I have\ndecided to skip it to keep the book shorter. See [Mac].\n□\nExample 5.1.3.2. Since Ob: Cat N Set is both a left adjoint and a right adjoint, it must\npreserve both limits and colimits. This means that if you want to know the set of objects\nin the fiber product of some categories, you can simply take the fiber product of the set\nof objects in those categories,\nObpA ˆC Bq - ObpAq ˆObpCq ObpBq.\nWhile the right-hand side might look daunting, it is just a fiber product in Set which is\nquite understandable.\nThis is greatly simplifying. If one thinks through what defines a limit in Cat, one\nis dragged through notions of slice categories and terminal objects in them. These slice\ncategories are in Cat so they involve several categories and functors, and it gets hairy\nor even hopeless to a beginner. Knowing that the objects are given by a simple fiber\nproduct makes the search for limits in Cat much simpler.\nFor example, if rns is the linear order category of length n then rns ˆ rms has nm `\nn ` m ` 1 objects because rns has n ` 1 objects and rms has m ` 1 objects.\nExample 5.1.3.3. The \"path poset\" functor L: Grph N PrO given by existence of paths\n(see Exercise 4.1.2.11) is left adjoint to the functor R: PrO N Grph given by replacing\nd's by arrows. This means that L preserves colimits. So taking the union of graphs G\nand H results in a graph whose path poset LpG \\ Hq is the union of the path posets of\nG and H. But this is not so for products.\n\n5.1. ADJOINT FUNCTORS\nLet G \" H \"\na‚\nf\n/ b‚ . Then LpGq \" LpHq \" r1s, the linear order of length 1.\nBut the product G ˆ H in Grph looks like the graph\npa,aq\n‚\n\npa,bq\n‚\npb,aq\n‚\npb,bq\n‚\nIts preorder LpG ˆ Hq does not have pa, aq d pa, bq, whereas this is the case in LpGq ˆ\nLpHq.\n5.1.4\nData migration\nAs we saw in Sections 4.2.2 and 4.2.2.5, a database schema is a category C and an instance\nis a functor I : C N Set.\nNotation 5.1.4.1. Let C be a category. Throughout this section we denote by C-Set\nthe category FunpC, Setq of functors from C to Set, i.e. the category of instances on C.\nIn this section we discuss what happens to the resulting instances when different\nschemas are connected by a functor, say F : C N D. It turns out that three adjoint func-\ntors emerge: ∆F : D-Set N C-Set, ΣF : C-Set N D-Set, and ΠF : C-Set N D-Set,\nwhere ∆F is adjoint to both,\nΣF : C-Set\n/ D-Set :∆F\no\n∆F : D-Set\n/ C-Set :ΠF .\no\nIt turns out that almost all the basic database operations are captured by these three\nfunctors. For example, ∆F handles the job of duplicating or deleting tables, as well as\nduplicating or deleting columns in a single table. The functor ΣF handles taking unions,\nand the functor ΠF handles joining tables together, matching columns, or selecting the\nrows with certain properties (e.g. everyone whose first name is Mary).\n5.1.4.2\nPullback: ∆\nGiven a functor F : C N D and a functor I : D N Set, we can compose them to get a\nfunctor I F : C N Set. In other words, the presence of F provides a way to convert D-\ninstances into C-instances. In fact this conversion is functorial, meaning that morphisms\nof D-instances are sent to morphisms of C-instances. We denote the resulting functor by\n∆F : D-Set N C-Set and call it pullback along F.\nWe have seen an example of this before in Example 4.3.2.15, where we showed how a\nmonoid homomorphism F : M1 N M could add functionality to a finite state machine.\nMore generally, we can use pullbacks to reorganize data, copying and deleting tables and\ncolumns.\nRemark 5.1.4.3. Given a functor F : C N D, which we think of as a schema translation,\nthe functor ∆F : D-Set N C-Set \"goes the opposite way\". The reasoning is simple to\nany explain (composition of functors) but something about it is often very strange to\npeople, at first. The rough idea of this \"contravariance\" is captured by the role-reversal\nin the following slogan:\nSlogan 5.1.4.4.\n\nCHAPTER 5. CATEGORIES AT WORK\n\" If I get my information from you, then your information becomes my infor-\nmation. \"\nConsider the following functor F : C N D: 6\nC :\"\nSSN\n‚\nFirst\n‚\nT1‚\nF\n=\n!\nT2‚\na\n}\n\nLast\n‚\nSalary\n‚\nF\nYYYN\nSSN\n‚\nFirst\n‚\nT‚\nF\n>\n\nLast\n‚\nSalary\n‚\n\": D\n(5.4)\nLet's spend a moment recalling how to \"read\" schemas. In schema C there are leaf\ntables SSN, First, Last, Salary, which represent different kinds of basic data. More\ninterestingly, there are two fact tables. The first is called T1 and it relates SSN, First,\nand Last. The second is called T2 and it relates First, Last, and Salary.\nThe functor F : C N D relates C to a schema with a single fact table relating all four\nattributes: SSN, First, Last, and Salary. We are interested in ∆F : D-Set N C-Set.\nSuppose given the following database instance I : D N Set on D:\nT\nID\nSSN\nFirst\nLast\nSalary\nXF667\n115-234\nBob\nSmith\n$250\nXF891\n122-988\nSue\nSmith\n$300\nXF221\n198-877\nAlice\nJones\n$100\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nHow do you get the instance ∆F pIq: C N Set?\nThe formula was given above:\ncompose I with F. In terms of tables, it feels like duplicating table T as T1 and T2, but\ndeleting a column from each in accordance with the definition of C in (5.4). Here is the\nresult, ∆F pIq, in table form:\n6This example was taken from [Sp1], http://arxiv.org/abs/1009.1166.\n\n5.1. ADJOINT FUNCTORS\nT1\nID\nSSN\nFirst\nLast\nXF667\n115-234\nBob\nSmith\nXF891\n122-988\nSue\nSmith\nXF221\n198-877\nAlice\nJones\nT2\nID\nFirst\nLast\nSalary\nXF221\nAlice\nJones\n$100\nXF667\nBob\nSmith\n$250\nXF891\nSue\nSmith\n$300\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nExercise 5.1.4.5. Let C \" pG, »q be a schema. A leaf table is an object c P ObpCq with\nno outgoing arrows.\na.) Write the condition of being a \"leaf table\" mathematically in three different lan-\nguages: that of graphs (using symbols V, A, src, tgt), that of categories (using HomC,\netc.), and that of tables (in terms of columns, tables, rows, etc.).\nb.) In the language of categories, is there a difference between a terminal object and a\nleaf table? Explain.\n♦\nExercise 5.1.4.6. Consider the schemas\nr1s \"\n0‚\nf\nYYYN\n1‚\nand\nr2s \"\n0‚\ng\nYYYN\n1‚\nh\nYYYN\n2‚ ,\nand the functor F : r1s N r2s given by sending 0 ÞN 0 and 1 ÞN 2.\na.) How many possibilities are there for Fpfq?\nb.) Now suppose I : r2s N Set is given by the following tables.\nID\ng\nAm\nTo be verb\nBaltimore\nPlace\nCarla\nPerson\nDevelop\nAction verb\nEdward\nPerson\nFoolish\nAdjective\nGreen\nAdjective\nID\nh\nAction verb\nVerb\nAdjective\nAdjective\nPlace\nNoun\nPerson\nNoun\nTo be verb\nVerb\nID\nAdjective\nNoun\nVerb\nWrite out the two tables associated to the r1s-instance ∆F pIq: r1s N Set.\n♦\n\nCHAPTER 5. CATEGORIES AT WORK\n5.1.4.7\nLeft pushforward: Σ\nLet F : C N D be a functor.\nThe functor ∆F : D-Set N C-Set has a left adjoint,\nΣF : C-Set N D-Set.\nThe rough idea is that ΣF performs parameterized colimits.\nGiven an instance I : C N Set, we get an instance on D that acts as follows. For each\nobject d P ObpDq, the set ΣF pIqpdq is the colimit (think, union) of some diagram back\nhome in C.\nLeft pushforwards (also known as left Kan extensions) are discussed at length in\n[Sp1]; here we begin with some examples from that paper.\nExample 5.1.4.8. We again use the functor F : C N D drawn below\nC :\"\nSSN\n‚\nFirst\n‚\nT1‚\nF\n=\n!\nT2‚\na\n}\n\nLast\n‚\nSalary\n‚\nF\nYYYN\nSSN\n‚\nFirst\n‚\nT‚\nF\n>\n\nLast\n‚\nSalary\n‚\n\": D\n(5.4)\nWe will be applying the left pushforward ΣF : C-Set N D-Set to the following instance\nI : C N Set:\nT1\nID\nSSN\nFirst\nLast\nT1-001\n115-234\nBob\nSmith\nT1-002\n122-988\nSue\nSmith\nT1-003\n198-877\nAlice\nJones\nT2\nID\nFirst\nLast\nSalary\nT2-001\nAlice\nJones\n$100\nT2-002\nSam\nMiller\n$150\nT2-004\nSue\nSmith\n$300\nT2-010\nCarl\nPratt\n$200\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nThe functor F : C N D sent both tables T1 and T2 to table T. Applying ΣF will take\nthe what was in T1 and T2 and put the union in T. The result ΣF I : D N Set is as\nfollows:\n\n5.1. ADJOINT FUNCTORS\nT\nID\nSSN\nFirst\nLast\nSalary\nT1-001\n115-234\nBob\nSmith\nT1-001.Salary\nT1-002\n122-988\nSue\nSmith\nT1-002.Salary\nT1-003\n198-877\nAlice\nJones\nT1-003.Salary\nT2-001\nT2-A101.SSN\nAlice\nJones\n$100\nT2-002\nT2-A102.SSN\nSam\nMiller\n$150\nT2-004\nT2-004.SSN\nSue\nSmith\n$300\nT2-010\nT2-A110.SSN\nCarl\nPratt\n$200\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nT2-001.SSN\nT2-002.SSN\nT2-004.SSN\nT2-010.SSN\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nT1-001.Salary\nT1-002-Salary\nT1-003-Salary\nAs you can see, there was no set salary information for any data coming from table\nT1 nor any set SSN information for any data coming form table T2. But the definition\nof adjoint, given in Definition 5.1.1.1, yielded the universal response: freely add new\nvariables that take the place of missing information. It turns out that this idea already\nhas a name in logic, Skolem variables, and a name in database theory, labeled nulls.\nExercise 5.1.4.9. Consider the functor F : 3 N 2 sending 1 ÞN 1, 2 ÞN 2, 3 ÞN 2.\na.) Write down an instance I : 3 N Set.\nb.) Given the description that \"ΣF performs a parameterized colimit\", make an educated\nguess about what ΣF pIq will be. Give your answer in the form of two sets that are\nmade up from the three sets you already wrote down.\n♦\nWe now briefly give the actual formula for computing left pushforwards. Suppose\nthat F : C N D is a functor and let I : C N Set be a set-valued functor on C. Then\nΣF pIq: D N Set is defined as follows. Given an object d P ObpDq we first form the\ncomma category (see Definition 4.6.4.1) for the setup\nC\nFYN D\nd\nÐY 1\nand denote it by pF O dq. There is a canonical projection functor π: pF O dq N C, which\nwe can compose with I : C N Set to obtain a functor pF O dq N Set. We are ready to\ndefine ΣF pIqpdq to be its colimit,\nΣF pIqpdq :\" colim\npF Odq I π.\nWe have defined ΣF pIq: D N Set on objects d P ObpDq. As for morphisms we will be\neven more brief, but one can see [Sp1] for details. Given a morphism g: d N d1 one\n\nCHAPTER 5. CATEGORIES AT WORK\nnotes that there is an induced functor pF O gq: pF O dq N pF O d1q and a commutative\ndiagram of categories:\npF O dq\npF Ogq\n/\nπ\n\nI π\n\npF O d1q\nπ1\nI π1\n\nC\nI\n\nSet\nBy the universal property of colimits, this induces the required function\ncolim\npF Odq I π\nΣF pIqpgq\nYYYYYYYYN colim\npF Od1q I π1.\n5.1.4.10\nRight pushforward: Π\nLet F : C N D be a functor. We heard in Section 5.1.4.7 that the functor ∆F : D-Set N\nC-Set has a left adjoint. Here we explain that it has a right adjoint, ΠF : C-Set N D-Set\nas well. The rough idea is that ΠF performs parameterized limits. Given an instance\nI : C N Set, we get an instance on D that acts as follows. For each object d P ObpDq,\nthe set ΠF pIqpdq is the limit (think, fiber product) of some diagram back home in C.\nRight pushforwards (also known as right Kan extensions) are discussed at length in\n[Sp1]; here we begin with some examples from that paper.\nExample 5.1.4.11. We once again use the functor F : C N D from Example 5.1.4.8. We\nwill apply the right pushforward ΠF to instance I : C N Set from that example. 7\nThe instance ΠF pIq will put data in all 5 tables in D. In T it will put pairs pt1, t2q\nwhere t1 is a row in T1 and t2 is a row in T2 for which the first and last names agree.\n7To repeat for convenience,\nC :\"\nSSN\n‚\nFirst\n‚\nT1‚\nF\n>\n\nT2‚\n`\n~\n\nLast\n‚\nSalary\n‚\nF\nYYYYN\nSSN\n‚\nFirst\n‚\nT‚\nG\n>\n\nLast\n‚\nSalary\n‚\n\": D\n(5.4)\nI : C N Set is\nT1\nID\nSSN\nFirst\nLast\nT1-001\n115-234\nBob\nSmith\nT1-002\n122-988\nSue\nSmith\nT1-003\n198-877\nAlice\nJones\nT2\nID\nFirst\nLast\nSalary\nT2-001\nAlice\nJones\n$100\nT2-002\nSam\nMiller\n$150\nT2-004\nSue\nSmith\n$300\nT2-010\nCarl\nPratt\n$200\n\n5.1. ADJOINT FUNCTORS\nIt will copy the leaf tables exactly, so we do not display them here; the following is the\ntable T for ΠF pIq:\nT\nID\nSSN\nFirst\nLast\nSalary\nT1-002T2-A104\n122-988\nSue\nSmith\n$300\nT1-003T2-A101\n198-877\nAlice\nJones\n$100\nLooking at T1 and T2, there were only two ways to match first and last names.\nExercise 5.1.4.12. Consider the functor F : 3 N 2 sending 1 ÞN 1, 2 ÞN 2, 3 ÞN 2.\na.) Write down an instance I : 3 N Set.\nb.) Given the description that \"ΠF performs a parameterized limit\", make an educated\nguess about what ΠF pIq will be. Give your answer in the form of two sets that are\nmade up from the three sets you already wrote down.\n♦\nWe now briefly give the actual formula for computing right pushforwards. Suppose\nthat F : C N D is a functor and let I : C N Set be a set-valued functor on C. Then\nΠF pIq: D N Set is defined as follows. Given an object d P ObpDq we first form the\ncomma category (see Definition 4.6.4.1) for the setup\n1 dYN D\nF\nÐY C\nand denote it by pd O Fq. There is a canonical projection functor π: pd O Fq N C, which\nwe can compose with I : C N Set to obtain a functor pd O Fq N Set. We are ready to\ndefine ΠF pIqpdq to be its limit,\nΠF pIqpdq :\" lim\npdOF q I π.\nWe have defined ΠF pIq: D N Set on objects d P ObpDq. As for morphisms we will be\neven more brief, but one can see [Sp1] for details. Given a morphism g: d N d1 one\nnotes that there is an induced functor pg O Fq: pd1 O Fq N pd O Fq and a commutative\ndiagram of categories:\npd1 O Fq\npgOF q\n/\nπ1\n\nI π1\n\npd O Fq\nπ\n\nI π\n\nC\nI\n\nSet\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\n\nCHAPTER 5. CATEGORIES AT WORK\nBy the universal property of limits, this induces the required function\nlim\npdOF q I π\nΠF pIqpgq\nYYYYYYYYN lim\npd1OF q I π1.\n5.2\nCategories of functors\nFor any two categories C and D, 8 we discussed the category FunpC, Dq of functors and\nnatural transformations between them. In this section we discuss functor categories a bit\nmore and give some important applications within mathematics (sheaves) that extend\nto the real world.\n5.2.1\nSet-valued functors\nLet C be a category. Then we have been writing C-Set to denote the functor category\nFunpC, Setq. Here is a nice result about these categories.\nProposition 5.2.1.1. Let C be a category. The category C-Set is closed under colimits\nand limits.\nSketch of proof. Let J be an indexing category and D: J N C-Set a functor. For each\nobject c P ObpCq, we have a functor Dc : J N Set defined by Dcpjq \" Dpjqpcq. Define a\nfunctor L: C N Set by Lpcq \" limJ Dc, and note that for each f : c N c1 in C there is\nan induced function Lpfq: Lpcq N Lpc1q. One can check that L is a limit of J, because\nit satisfies the relevant universal property.\nThe dual proof holds for colimits.\n□\nApplication 5.2.1.2. When taking in data about a scientific subject, one often finds\nthat the way one thinks about the problem changes over time.\nWe understand this\nphenomenon in the language of databases in terms of a series of schemas C1, C2, . . . , Cn,\nperhaps indexed chronologically. The problem is that old data is held in old schemas\nand we want to see it in our current understanding. The first step is to transfer all the\nold data to our new schema in the freest possible way, that is, making no assumptions\nabout how to fill in the new fields. If one creates functors Fi : Ci N Ci`1 from each of\nthese schemas to the next, then we can push the data forward using ΣFi.\nDoing this we will have n datasets on D :\" Cn, namely one for each \"epoch of\nunderstanding\". Since the category D-Set has all colimits, we can take the union of\nthese datasets and get one. It will have many Skolem variables (see Example 5.1.4.8),\nand these need to be handled in a coherent way. However, the universality of left adjoints\ncould be interpreted as saying that any reasonable formula for handling this old data\ncan be applied to our results.\n♦♦\nExercise 5.2.1.3. By Proposition 5.2.1.1, the category C-Set is closed under taking limits.\nBy Exercises 4.5.3.21 and 4.5.3.28, this means in particular that C-Set has an initial\nobject and a terminal object.\na.) Let A P ObpC-Setq be the initial object, considered as a functor A: C N Set. For\nany c P ObpCq, what is the set Apcq?\n8Technically C has to be small (see Remark 4.1.1.2), but as we said there, we are not worrying about\nthat distinction in this book.\n\n5.2. CATEGORIES OF FUNCTORS\nb.) Let Z P ObpC-Setq be the terminal object, considered as a functor Z : C N Set. For\nany c P ObpCq, what is the set Zpcq?\n♦\nProposition 5.2.1.1 says that we can add or multiply database states together. In\nfact, database states on C form what is called a topos which means that just about every\nconsideration we made for sets holds for instances on any schema. Perhaps the simplest\nschema is C \"\n‚ , on which the relevant topos is indeed Set.\nBut schemas can be\narbitrarily complex, and it is impressive that all of these considerations make sense in\nsuch generality. Here is a table that makes a comparison between these domains.\nDictionary between Set and C-Set\nConcept in Set\nConcept in C-Set\nSet\nObject in C-Set\nFunction\nMorphism in C-Set\nElement\nRepresentable functor\nEmpty set\nInitial object\nNatural numbers\nNatural numbers object\nImage\nImage\n(Co)limits\n(Co)limits\nExponential objects\nExponential objects\n\"Familiar\" arithmetic\n\"Familiar\" arithmetic\nPower sets 2X\nPower objects ΩX\nCharacteristic functions\nCharacteristic morphisms\nSurjections, injections\nEpimorphisms, monomorphisms\nIn the above table we said that elements of a set are akin to representable functors\nin C-Set, but we have not yet defined those; we do so in Section 5.2.1.6. First we briefly\ndiscuss monomorphisms and epimorphisms in general (Definition 5.2.1.4) and then in\nC-Set (Proposition 5.2.1.5).\nDefinition 5.2.1.4 (Monomorphism, Epimorphism). Let S be a category and let f : X N\nY be a morphism. We say that f is a monomorphism if it has the following property.\nFor all objects A P ObpSq and morphisms g, g1 : A N X in S,\nA\ng\n\"\ng1\n=X\nf\n/ Y\nif f g \" f g1 then g \" g1.\nWe say that f : X N Y is an epimorphism if it has the following property. For all\nobjects B P ObpSq and morphisms h, h1 : Y N B in S,\nX\nf\n/ Y\nh\n\"\nh1\n=B\nif h f \" h1 f then h \" h1.\n\nCHAPTER 5. CATEGORIES AT WORK\nIn the category of sets, monomorphisms are the same as injections and epimorphisms\nare the same as surjections (see Proposition 2.7.5.4). The same is true in C-Set: one\ncan check \"table by table\" that a morphism of instances is mono or epi.\nProposition 5.2.1.5. Let C be a category and let X, Y : C N Set be objects in C-Set\nand let f : X N Y be a morphism in C-Set. Then f is a monomorphism (respectively an\nepimorphism) if and only if, for every object c P ObpCq, the function fpcq: Xpcq N Y pcq\nis injective (respectively surjective).\nSketch of proof. We first show that if f is mono (respectively epi) then so is fpcq for all\nc P ObpCq. Considering c as a functor c: 1 N C, this result follows from the fact that ∆c\npreserves limits and colimits, hence monos and epis.\nWe now check that if fpcq is mono for all c P ObpCq then f is mono. Suppose that\ng, g1 : A N X are morphisms in C-Set such that f g \" f g1. Then for every c we have\nf gpcq \" f g1pcq which implies by hypothesis that gpcq \" g1pcq. But the morphisms\nin C-Set are natural transformations, and if two natural transformations g, g1 have the\nsame components then they are the same.\nA similar argument works to show the analogous result for epimorphisms.\n□\n5.2.1.6\nRepresentable functors\nGiven a category C, there are certain functors C N Set that come with the package, one\nfor every object in C. So if C is a database schema, then for every table c P ObpCq there\nis a certain database instance associated to it. These instances, i.e. set-valued functors,\nare called representable functors, and they'll be defined in Definition ??. The idea is\nthat if a database schema represents a conceptual layout of types (e.g. as an olog), then\neach type T has an instance associated to it, standing for \"the generic thing of type T\nwith all its generic attributes\".\nDefinition 5.2.1.7. Let C be a category and let c P ObpCq be an object. The functor\nHomCpc, q: C N Set, sending d P ObpCq to the set HomCpc, dq and acting similarly\non morphisms d N d1, is said to be represented by c.\nIf a functor F : C N Set is\nisomorphic to HomCpc, q, we say that F is a representable functor. We sometimes write\nYc :\" HomCpc, q for short.\nExample 5.2.1.8. Given a category C and an object c P ObpCq, we get a representable\nfunctor. If we think of C as a database schema and c as a table, then what does the\nrepresentable functor Yc : C N Set look like in terms of databases? It turns out that the\nfollowing procedure will generate it.\nBegin by writing a new row, say \",\", in the ID column of table c. For each foreign\nkey column f : c N c1, add a row in the ID column of table c1 called \"fp,q\" and record\nthat result (i.e. \"fp,q\") in the f column of table c. Repeat as follows: for each table d,\nidentify all rows r that have blank cell in column g: d N e. Add a new row called \"gprq\"\nto table e and record that result in the pr, gq cell of table d.\nHere is a concrete example. Let C be the following schema:\nA‚\nf\n/ B‚\ng1\n/\ng2\n/\nh\nC‚\ni\n/ D‚\nE‚\n\n5.2. CATEGORIES OF FUNCTORS\nThen YB : C N Set is the following instance\nA\nID\nf\nB\nID\ng1\ng2\nh\n,\ng1p,q\ng2p,q\nhp,q\nC\nID\ni\ng1p,q\nipg1p,qq\ng2p,q\nipg2p,qq\nD\nID\nipg1p,qq\nipg2p,qq\nE\nID\nhp,q\nWe began with a single element in table B and followed the arrows, putting new\nentries wherever they were required. One might call this the schematically implied ref-\nerence spread or SIRS of the element , in table B. Notice that the table at A is empty,\nbecause there are no morphisms B N A.\nRepresentable functors Yc yield databases states that are as free as possible, subject\nto having the initial row , in table c. We have seen things like this before (by the name\nof Skolem variables) when studying the left pushforward Σ. Indeed, if c P ObpCq is an\nobject, we can consider it as a functor c: 1 N C. A database instance on 1 is the same\nthing as a set X. The left pushforward ΣcpXq has the same kinds of Skolem variables.\nIf X \" t,u is a one element set, then we get the representable functor Σcpt,uq - Yc.\nExercise 5.2.1.9. Consider the schema for graphs,\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\na.) Write down the representable functor YAr : GrIn N Set as two tables.\nb.) Write down the representable functor YVe as two tables.\n♦\nExercise 5.2.1.10. Consider the loop schema\nLoop :\"\ns‚\nf\n\n.\nWhat is the representable functor Ys : Loop N Set?\n♦\nLet B be a box in an olog, say ⌜a person⌝, and recall that an aspect of B is an\noutgoing arrow, such as ⌜a person⌝\nhas as height in inches\nYYYYYYYYYYYYYYN ⌜an integer⌝.\nThe following\nslogan explains representable functors in those terms.\nSlogan 5.2.1.11.\n\" The functor represented by ⌜a person⌝simply leaves a placeholder, like\nxperson's name herey or xperson's height herey, for every aspect of ⌜a person⌝.\nIn general, there is a representable functor for every type in an olog. The\nrepresentable functor for type T simply encapsulates the most generic or\nabstract example of type T, by leaving a placeholder for each of its attributes.\n\"\n\nCHAPTER 5. CATEGORIES AT WORK\n5.2.1.12\nYoneda's lemma\nOne of the most powerful tools in category theory is Yoneda's lemma. It is often consid-\nered by new students to be quite abstract, but grounding it in databases may help.\nThe idea is this. Suppose that I : C N Set is a database instance, and let c P ObpCq\nbe an object. Because I is a functor, we know that for every row r P Ipcq in table c a\nvalue has been recorded in the f-column, where f : c N c1 is any outgoing arrow. The\nvalue in the pr, fq-cell refers to some row in table c1. What we're saying is that each row\nin table c induces SIRS throughout the database. They may not be \"Skolem\", or in any\nsense \"freely generated\", but they are there nonetheless. The point is that to each row\nin c there is a unique mapping Yc N I.\nLemma 5.2.1.13 (Yoneda's lemma, part 1.). Let C be a category, c P ObpCq an object,\nand I : C N Set a set-valued functor. There is a natural bijection\nHomC-SetpYc, Iq\n-\nYYYYN Ipcq.\nProof. See [Mac].\n□\nExample 5.2.1.14. Consider the category C drawn below:\nC :\"\nmother firstChild = idMother\nChild\n‚\nmother\n/ Mother\n‚\nfirstChild\nh\nThere are two representable functors, YChild and YMother. The latter, when written as a\ndatabase instance, will consist of a single row in each table. The former, YChild : C N Set\nis shown here:\nChild\nID\nmother\n,\nmother(,)\nfirstChild(mother(,))\nmother(,)\nMother\nID\nfirstChild\nmother(,)\nfirstChild(mother(,))\nThe representable functor YChild is the freest instance possible, starting with one element\nin the Child table and satisfying the constraints.\nHere is another instance I : C N Set:\nChild\nID\nmother\nAmy\nMs. Adams\nBob\nMs. Adams\nCarl\nMs. Jones\nDeb\nMs. Smith\nMother\nID\nfirstChild\nMs. Adams\nBob\nMs. Jones\nCarl\nMs. Smith\nDeb\nYoneda's lemma (5.2.1.13) is about the set of natural transformations YChild N I.\nRecall from Definition 4.3.1.2 that a search for natural transformations can get a bit\ntedious.\nYoneda's lemma makes the calculation quite trivial.\nIn our case there are\nexactly four such natural transformations, and they are completely determined by where\n, goes. In some sense the symbol , represents child-ness in our database.\n\n5.2. CATEGORIES OF FUNCTORS\nExercise 5.2.1.15. Consider the schema C and instance I : C N Set from Example\n5.2.1.14. Let YChild be the representable functor as above.\na.) Let α: YChild N I be the natural transformation sending , to Amy.\nWhat is\nαChildpfirstChild(motherp,qqq? 9\nb.) Let α: YChild N I be the natural transformation sending , to Bob.\nWhat is\nαChildpfirstChild(motherp,qqq?\nc.) Let α: YChild N I be the natural transformation sending , to Carl.\nWhat is\nαChildpfirstChild(motherp,qqq?\nd.) Let α: YChild N I be the natural transformation sending , to Deb.\nWhat is\nαChildpfirstChild(motherp,qqq?\ne.) Let α: YChild N I be the natural transformation sending , to Amy.\nWhat is\nαMotherpmotherp,qq?\n♦\nWe saw in Section 5.2.1.6 that a representable functor is a mathematically-generated\ndatabase instance for an abstract thing of type T.\nIt creates placeholders for every\nattribute that things of type T are supposed to have.\nSlogan 5.2.1.16.\n\" Yoneda's lemma says the following. Specifying an actual thing of type T is\nthe same as filling in all placeholders found in the generic thing of type T. \"\nYoneda's lemma is considered by many category theory lovers to be the most im-\nportant tool in the subject. While its power is probably unclear to students whose sole\nbackground in category theory comes from this book, Yoneda's lemma is indeed ex-\ntremely useful for reasoning. It allows us to move the notion of functor application into\nthe realm of morphisms between functors (i.e. morphisms in C-Set, which are natural\ntransformations). This keeps everything in one place -- it's all in the morphisms -- and\nthus more interoperable.\nExample 5.2.1.17. In Example 3.1.1.26, we discussed the cyclic monoid M generated by\nthe symbol Q and subject to the relation Q7 \" Q4. We drew a picture like this:\nQ0\n‚\n/ Q1\n‚\n/ Q2\n‚\n/ Q3\n‚\n/ Q4\n‚\n\nQ6\n‚\nA\nQ5\n‚\no\n(5.5)\nWe are finally ready to give the mathematical foundation for this picture. Since M is a\ncategory with one object, ▲, there is a unique representable functor (up to isomorphism)\nY :\" Y▲: M N Set. A functor M N Set can be thought of as a set with an M-action,\nas discussed in Section 4.2.1.1. Here the required set is\nY p▲q \" HomMp▲, ▲q - tQ0, Q1, Q2, Q3, Q4, Q5, Q6u\n9There is a lot of clutter, perhaps. Note that \"firstChild(mother(,))\" is a row in the Child table.\nAssuming that the math follows the meaning, if , points to Amy, where should firstChild(Mother(,))\npoint?\n\nCHAPTER 5. CATEGORIES AT WORK\nand the action is pretty straightforward (it is called the principal action). We might say\nthat (5.5) is a picture of this principal action of M.\nHowever, we can go one step further. Given a functor Y : M N Set, we can take\nits category of elements,\ns\nM Y as in Section 4.6.2.\nThe category\ns\nM Y has objects\nY p▲q P ObpSetq, i.e. the set of dots in (5.5), and it has a unique morphism Qi N Qj for\nevery path of length d 6 from Qi to Qj in that picture.\nExercise 5.2.1.18. Let c P ObpCq be an object and let I P ObpC-Setq be another object.\nConsider c also as a functor c: 1 N C and recall the pullback functor ∆c : C-Set N Set\nand its left adjoint Σc : Set N C-Set from Section 5.1.4.\na.) What is the set ∆cpIq?\nb.) What is HomSetpt,u, ∆cpIqq?\nc.) What is HomC-SetpΣcpt,uq, Iq?\nd.) How does Σcpt,uq compare to Yc, the functor represented by c, as objects in C-Set?\n♦\nLemma 5.2.1.19 (Yoneda's lemma, part 2). Let C be a category.\nThe assignment\nc ÞN Yc from Lemma 5.2.1.13 extends to a functor Y : Cop N C-Set, and this functor is\nfully faithful.\nIn particular, if c, c1 P ObpCq are objects and there is an isomorphism Yc - Yc1 in\nC-Set, then there is an isomorphism c - c1 in C.\nProof. See [Mac].\n□\nExercise 5.2.1.20. The distributive law for addition of natural numbers says pa`bqˆc \"\na ˆ c ` b ˆ c. Below we will give a proof of the distributive law, using category-theoretic\nreasoning. Annotate anything in red ink with a justification for why it is true.\nProposition 5.2.1.21. For any natural numbers a, b, c P N, the distributive law\npa ` bqc \" ac ` bc\nholds.\nSketch of proof. To finish, justify red stuff.\nLet A, B, C be finite sets and let X be another finite set.\nHomSetppA ` Bq ˆ C, Xq-HomSetpA ` B, XCq\n-HomSetpA, XCq ˆ HomSetpB, XCq\n-HomSetpA ˆ C, Xq ˆ HomSetpB ˆ C, Xq\n-HomSetppA ˆ Cq ` pB ˆ Cq, Xq.\nBy the appropriate application of Yoneda's lemma, we see that there is an isomorphism\npA ` Bq ˆ C - pA ˆ Cq ` pB ˆ Cq\nin Fin. The result about natural numbers follows.\n□\n♦\n\n5.2. CATEGORIES OF FUNCTORS\n5.2.1.22\nThe subobject classifier ΩP ObpC-Setq\nIf C is a category then the functor category C-Set is a very nice kind of category, called\na topos. Note that when C \" 1 is the terminal category, then we have an isomorphism\nC-Set - Set, so the category of sets is a special case of a topos. What is so interesting\nabout toposes (or topoi) is that they so nicely generalize many properties of Set. In this\nshort section we investigate only one such property, namely that C-Set has a subobject\nclassifier, denoted ΩP ObpC-Setq. In the case C \" 1, we saw back in Section 2.7.4.9\nthat the subobject classifier is tTrue, Falseu P ObpSetq.\nAs usual, we consider the matter of subobject classifiers by grounding the discussion\nin terms of databases.\nDefinition 5.2.1.23. Let C be a category, let C-Set denote its category of instances,\nand let 1 P ObpC-Setq denote the terminal object. A subobject classifier for C-Set is an\nobject ΩC P ObpC-Setq and a morphism t: 1 N ΩC with the following property. For any\nmonomorphism f : X N Y in C-Set, there exists a unique morphism charpfq: Y N ΩC\nsuch that the following diagram is a pullback in C-Set:\nX\n!\n/\nf\n\n⌟\nt\n\nY\ncharpfq\n/ ΩC\nIn terms of databases, what this means is that for every schema C there is some special\ninstance ΩC P ObpC-Setq that somehow classifies sub-instances. When our schema is\nthe terminal category, C \" 1, instances are sets and we saw in Definition 2.7.4.9 that the\nsubobject classifier is Ω1 \" tTrue, Falseu. One might think that the subobject classifier\nfor C-Set should just consist of a two-element set table-by-table, i.e. that for every\nc P ObpCq we should have ΩC \"? tTrue, Falseu, but this is not correct.\nIn fact, for any object c P ObpCq, it is easy to say what ΩCpcq should be. We know\nby Yoneda's lemma (Lemma 5.2.1.13) that ΩCpcq \" HomC-SetpYc, ΩCq, where Yc is the\nfunctor represented by c. There is a bijection between HomC-SetpYc, ΩCq and the set of\nsub-instances of Yc. Each morphism f : c N d in C induces a morphism Yf : Yd N Yc,\nand the map ΩCpfq: ΩCpcq N ΩCpdq sends a sub-instance A D Yc to the pullback\nY 1\nf\npAq\n/\n\n⌟\nA\n\nYd\nYf\n/ Yc\nBut this is all very abstract. We now give an example of a subobject classifier.\nExample 5.2.1.24. Consider the category C - r3s depicted below\nC :\"\n✓\n0‚\nafter 1\n/\nafter 2\nafter 3\n$\n1‚\nafter 1\n/\nafter 2\n2‚\nafter 1\n/ 3‚\n✓\n✓\n\nCHAPTER 5. CATEGORIES AT WORK\nTo write down ΩC we need to understand the representable functors Yc P ObpC-Setq,\nfor c \" 0, 1, 2, 3, as well as their subobjects. Here is Y0 as an instance:\nY0p0q\nID\nafter 1\nafter 2\nafter 3\n,\nafter 1(,)\nafter 2(,)\nafter 3(,)\nY0p1q\nID\nafter 1\nafter 2\nafter 1p,q\nafter 2p,q\nafter 3p,q\nY0p2q\nID\nafter 1\nafter 2p,q\nafter 3p,q\nY0p3q\nID\nafter 3p,q\nWhat are the sub-instances of this? There is the empty sub-instance H D Y0 and the\nidentity sub-instance Y0 D Y0. But there are three more as well. Note that if we want\nto keep the , row of table 0 then we have to keep everything. But if we throw away the\n, row of table 0 we can still keep the rest and get a sub-instance. If we want to keep\nthe after 1p,q row of table 1 then we have to keep its images in tables 2 and 3. But we\ncould throw away both the , row of table 0 and the after 1p,q row of table 1 and still\nkeep the rest. And so on. In other words, the subobjects of Y0 are in bijection with the\nset ΩCp0q :\" tyes, in 1, in 2, in 3, neveru.\nThe same analysis holds for the other tables of ΩC. It looks like this:\nΩCp0q\nID\nafter 1\nafter 2\nafter 3\nyes\nyes\nyes\nyes\nin 1\nyes\nyes\nyes\nin 2\nin 1\nyes\nyes\nin 3\nin 2\nin 1\nyes\nnever\nnever\nnever\nnever\nΩCp1q\nID\nafter 1\nafter 2\nyes\nyes\nyes\nin 1\nyes\nyes\nin 2\nin 1\nyes\nnever\nnever\nnever\nΩCp2q\nID\nafter 1\nyes\nyes\nin 1\nyes\nnever\nnever\nΩCp3q\nID\nyes\nnever\nThe morphism 1 N ΩC picks out the yes row of every table.\nNow that we have constructed ΩC P ObpC-Setq, we are ready to see it in action.\nWhat makes ΩC special is that for any instance X : C N Set, the subinstances if X\nare in one-to-one correspondence with the morphisms X N ΩC. Consider the following\narbitrary instance X, where the blue rows denote a sub-instance A D X.\nXp0q\nID\nafter 1\nafter 2\nafter 3\na1\nb1\nc1\nd1\na2\nb2\nc1\nd1\na3\nb2\nc1\nd1\na4\nb3\nc2\nd2\na5\nb5\nc3\nd1\nXp1q\nID\nafter 1\nafter 2\nb1\nc1\nd1\nb2\nc1\nd1\nb3\nc2\nd2\nb4\nc1\nd1\nb5\nc3\nd1\nXp2q\nID\nafter 1\nc1\nd1\nc2\nd2\nc3\nd1\nXp3q\nID\nd1\nd2\n(5.6)\n\n5.2. CATEGORIES OF FUNCTORS\nThis blue sub-instance A D X corresponds to a map charpAq: X N ΩC. That is for\neach c P ObpCq the rows in the c-table of X are sent to the rows in the c-table of ΩC.\nThe way charpAq works is as follows. For each table i and row x P Xpiq, find the first\ncolumn f in which the entry is blue (i.e. fpxq P A), and send x to the corresponding\nelement of ΩCpiq. For example, charpAqp0q sends a1 to in 2 and sends a4 to never, and\ncharpAqp2q sends c1 to yes and sends c2 to never.\nExercise 5.2.1.25. a.) Write out the blue subinstance A D X shown in (5.6) as an in-\nstance of C, i.e. as four tables.\nb.) This subinstance A D X corresponds to a map l:\" charpAq: X N ΩC. For all c P\nObpCq we have a function lpcq: Xpcq N ΩCpcq. With c \" 1, write out lp1q: Xp1q N\nΩCp1q.\n♦\nExercise 5.2.1.26. Let Loop be the loop schema\nLoop \"\ns‚\nf\n\n.\na.) What is the subobject classifier ΩLoop P ObpLoop-Setq?\nb.) How does ΩLoop compare to the representable functor Ys?\n♦\nExercise 5.2.1.27. Let GrIn \"\nAr‚\nsrc /\ntgt /\nVe‚\nbe the indexing category for graphs.\na.) Write down the subobject classifier ΩGrIn P ObpGrIn-Setq in tabular form, i.e. as\ntwo tables.\nb.) Draw ΩGrIn as a graph.\nc.) Let G be the graph below and G1 D G the blue part.\nw‚\nf\n\ng\n/\nh\nx‚\ny‚\nj\nM\ni\n/ z‚\nWrite down G P ObpGrIn-Setq in tabular form.\nd.) Write down the components of the natural transformation charpG1q: G N ΩGrIn.\n♦\n5.2.2\nDatabase instances in other categories\n5.2.2.1\nRepresentations of groups\nThe classical mathematical subject of representation theory is the study of FunpG, Vectq\nwhere G is a group and Vect is the category of vector spaces (over say R). Every such\n\nCHAPTER 5. CATEGORIES AT WORK\nfunctor F : G N Vect is called a representation of G. Since G is a category with one\nobject ▲, F consists of a single vector space V \" Fp▲q together with an action of G on\nit.\nWe can think of this in terms of databases if we have a presentation of G in terms of\ngenerators and relations. The schema corresponding to G has one table and this table\nhas a column for each generator. Giving a representation F is the same as giving an\ninstance on our schema, with some properties that stem from the fact that our target\ncategory is Vect rather than Set. There are many possibilities for expressing 10 such\ndata.\nOne possibility is if we could somehow draw V , say if V is 1-, 2-, or 3-dimensional.\nIf so, let P be our chosen picture of V , e.g. P is the standard drawing of a Cartesian\ncoordinate plane. Then every column of our table would consist entirely of the picture\nP instead of a set of rows. Drawing a point in the ID-column picture would result in\na point being drawn in each other column's picture, in accordance with the G-action.\nEach column would of course respect addition and scalar multiplication.\nAnother possibility is to use the fact that there is a functor U : Vect N Set, so our\ninstance F : G N Vect can be converted to an ordinary instance U F : G N Set. We\nwould have an ordinary set of rows. This set would generally be infinite, but it would\nbe structured by addition and scalar multiplication. For example, assuming V is finite\ndimensional, one could find a few rows that generated the rest.\nA third possibility is to use monads, which allow the table to have only as many rows\nas V has dimensions. This is a considerable savings of space. See Section 5.3.\n5.2.2.2\nRepresentations of quivers\nRepresentation theory also studies representations of quivers. A quiver is just the free\ncategory (see Example 4.1.2.30) on a graph. If P is a graph with free category P then a\nrepresentation of the quiver P is a functor F : P N Vect. Such a representation consists\nof a vector space at every vertex of P and a linear transformation for every arrow. All of\nthe discussion from Section 5.2.2.1 works in this setting, except that there is more than\none table.\n5.2.2.3\nOther target categories\nOne can imagine the value of using target categories other than Set or Vect for databases.\nApplication 5.2.2.4. Geographic data consists of maps of the earth together with various\nfunctions on it. For example for any point on the earth one may want to know the\naverage temperature recorded in the past 10 years, or the precise temperature at this\nmoment. Earth can be considered as a topological space, E. Similarly, temperatures\non earth reside on a continuum, say the space T of real numbers r 100, 200s. Thus the\ntemperature record is a function E N T.\nOther records such as precipitation, population density, elevation, etc. can all be\nconsidered as continuous functions from E to some space. Agencies like the US Geological\nSurvey hold databases of such information. By modeling them on functors C N Top,\nthey may be able to employ mathematical tools such as persistent homology [WeS] to\nfind interesting invariants of the data.\n♦♦\n10We would use the term \"representing\" or \"presenting\", but they are both taken in the context of\nour narrative!\n\n5.2. CATEGORIES OF FUNCTORS\nApplication 5.2.2.5. Many other scientific disciplines could use the same kind of tool. For\nexample, in studying the mechanics of materials, one may want to consider the material\nas a topological space M and measure values such as energy as a continuous M N E.\nSuch observations could be modeled by databases with target category Top or Vect\nrather than Set.\n♦♦\n5.2.3\nSheaves\nLet X be a topological space (see Example 4.2.3.1), such as a sphere. In Section 5.2.2.3\nwe discussed continuous functions out of X, and their use in science (e.g. recording\ntemperatures on the earth as a continuous map X N r 100, 200s). Sheaves allow us to\nconsider the local-global nature of such maps, taking into account reparable discrepancies\nin data gathering tools.\nApplication 5.2.3.1. Suppose that X is the topological space corresponding to the earth;\nby a region we mean an open subset U D X. Suppose that we cover X with 10,000 regions\nU1, U2, . . . , U10000, such that some of the regions overlap in a non-empty subregion (e.g.\nperhaps U5 X U9 % Hq. For each i, j let Ui,j \" Ui X Uj.\nFor each region Ui D X we have a temperature recording device, which gives a\nfunction Ti : Ui N r 100, 200s. If Ui X Uj % H then two different recording devices\ngive us temperature data for the intersection Ui,j. Suppose we find that they do not give\nprecisely the same data, but that there is a translation formula between their results. For\nexample, Ti might register 3 warmer than Tj registers, throughout the region Ui X Uj.\nA consistent system of translation formulas is called a sheaf. It does not demand a\nuniversal \"true\" temperature function, but only a consistent translation system between\nthem.\n♦♦\nThe following definitions (Definitions 5.2.3.2, 5.2.3.5) make the notion of sheaf precise,\nbut we must go slowly (because it will already feel quick to the novice). For every region\nU, we can record the value of some function (say temperature) throughout U; although\nthis record might consist of a mountain of data (a temperature for each point in U!),\nwe think of it as one thing. That is, it is one element in the set of value-assignments\nthroughout U. A sheaf holds the set of possible values-assignments-throughout-U's for\nall the different regions U, as well as how a value-assignment-throughout-U restricts to\na value-assignment-throughout-V for any subset V D U.\nDefinition 5.2.3.2. Let X be a topological space, let OpenpXq denote its partial order\nof open sets, and let OpenpXqop be the opposite category. A presheaf on X is a functor\nO: OpenpXqop N Set. For every open set U D X we refer to the set OpUq as the set\nof values-assignments throughout U of O. If V D U is an open subset, it corresponds to\nan arrow in OpenpXq and applying the functor O yields a function called the restriction\nmap from U to V and denoted ρV,U : OpUq N OpV q. Given a P OpUq, we may denote\nρV,Upaq by a|V ; it is called the restriction of a to V .\nThe category of presheaves on X is simply OpenpXqop-Set; see Definition 4.3.3.1.\nExercise 5.2.3.3.\na.) Come up with 4 overlapping open subsets that cover the square X :\" r0, 3sˆr0, 3s D\nR2. Write down a label for each open set as well as a label for each overlap (2-fold,\n3-fold, etc.); you now have labeled n open sets. For each of these open sets, draw\n\nCHAPTER 5. CATEGORIES AT WORK\na dot with the appropriate label, and then draw an arrow from one dot to another\nwhen the first refers to an open subset of the second. This is a preorder; call it\nOpenpXq. Now make up and write down formulas R1 : X N R and R2 : X N R with\nR1 d R2, expressing a range of temperatures R1ppq d x d R2ppq that an imaginary\nexperiment shows can exist at each point p in the square.\nb.) Suppose we now tried to make our presheaf O: OpenpXqop N Set as follows. For\neach of your open sets, say A, we could put\nOpAq :\" tf : A N R | R1paq d fpaq d R2paqu.\nWhat are the restriction maps? Do you like the name \"value-assignment throughout\nA\" for elements of OpAq?\nc.) We can now make another presheaf O1 given the same experiment. For each of your\nopen sets, say A, we could put\nO1pAq :\" tf : A N R | f is continuous, and R1paq d fpaq d R2paqu.\nAre you comfortable with the idea that there is a morphism of presheaves O1 N O?\n♦\nBefore we define sheaves, we need to clarify the notion of covering. Suppose that U\nis a region and that V1, . . . , Vn are subregions (i.e. for each 1 d i d n we have Vi D U).\nThen we say that the Vi cover U if every point in U is in Vi for some i. Another way to\nsay this is that the natural function \\iVi N U is surjective.\nExample 5.2.3.4. Let X \" R be the space of real numbers, and define the following open\nsubsets: U \" p5, 10q, V1 \" p5, 7q, V2 \" p6, 9q, V3 \" p7, 10q. 11 Then V1, V2, V3 is a cover of\nU. It has overlaps V12 \" V1 X V2 \" p6, 7q, V13 \" V1 X V3 \" H, V23 \" V2 X V3 \" p7, 9q.\nGiven a presheaf O: OpenpXqop N Set, we have sets and functions as in the following\n(incomplete) diagram\nOpV1q\n)\nOpV1 X V2q\nOpUq\n>\n/\n\nOpV2q\n)\nOpV2 X V3q\nOpV3q\nA presheaf O on X tells us what value-assignments throughout U can exist for each\nU. Suppose we have a value-assignment a P OpUq throughout U and another value-\nassignment a1 P OpU 1q throughout U 1, and suppose that they agree as value-assignments\nthroughout U X U 1, i.e. a|UXU1 \" a1|UXU1. In this case we should have a unique value-\nassignment b P OpU Y U 1q throughout U Y U 1 that agrees on the U-part with a and\nagrees on the U 1-part with a1; i.e. b|U \" a and b|U 1 \" a1. This is the sheaf condition.\n11We use parentheses to denote open intervals of real numbers. For example p6, 9q denotes the set\ntx P R | 6 a x a 9u.\n\n5.2. CATEGORIES OF FUNCTORS\nDefinition 5.2.3.5. Let X be a topological space, let OpenpXq be its partial order of\nopen sets, and let O: OpenpXqop N Set be a presheaf. Given an open set U D X and a\ncover V1, . . . , Vn of U, the following condition is called the sheaf condition for that cover.\nSheaf condition Given a sequence a1, . . . , an where each is a value-assignment ai P\nOpViq throughout Vi, suppose that for all i, j we have ai|ViXVj \" aj|ViXVj; then\nthere is a unique value-assignment b P OpUq such that b|Vi \" ai.\nThe presheaf O is called a sheaf if it satisfies the sheaf condition for every cover.\nExample 5.2.3.6. Let X \" R and let U, V1, V2, V3 be the open cover given in Example\n5.2.3.4. Given a measurement taken throughout V1, a measurement taken throughout\nV2, and a measurement taken throughout V3, we have elements a1 P OpV1q, a2 P OpV2q,\nand a3 P OpV3q. If they are in agreement on the overlap intervals, we can glue them to\ngive a measurement throughout U.\nRemark 5.2.3.7. In Application 5.2.3.1, we said that sheaves would help us patch together\ninformation from different sources. Even if different temperature-recording devices Ti\nand Tj registered different temperatures on an overlapping region Ui X Uj, we said they\ncould be patched together if there was a consistent translation system between their\nresults. What is actually needed is a set of isomorphisms\npi,j : Ti|Ui,j\n-\nYN Tj|Ui,j\nthat translate between them, and that these pi,j's act in concert with one another. This\n(when precisely defined,) is called descent data.. The way it interacts with our definition\nof sheaf given in Definitions 5.2.3.2 and 5.2.3.5 is buried in the restriction maps ρ for the\noverlaps as subsets Ui,j D Ui and Ui,j D Uj. We will not explain further here. One can\nsee [Gro].\nApplication 5.2.3.8. Consider outer space as a topological space X. Different astronomers\nrecord observations. Let C \" r390, 700s denote the set of wavelengths in the visible light\nspectrum (written in nanometers). Given an open subset U D X let OpUq denote the\nset of functions U N C. The presheaf O satisfies the sheaf condition; this is the taken-\nfor-granted fact that we can patch together different observations of space.\nBelow are three views of the night sky. Given a telescope position to obtain the first\nview, one moves the telescope right and a little down to obtain the second and one moves\nit down and left to obtain the third. 12\n12Image credit: NASA, ESA, Digitized Sky Survey Consortium.\n\nCHAPTER 5. CATEGORIES AT WORK\nThese are value-assignments a1 P OpV1q, a2 P OpV2q, and a3 P OpV3q throughout subsets\nV1, V2, V3 D X (respectively). These subsets V1, V2, V3 cover some (strangely-shaped)\nsubset U D X. The sheaf condition says that these three value-assignments glue together\nto form a single value-assignment throughout U:\n\n5.2. CATEGORIES OF FUNCTORS\n♦♦\nExercise 5.2.3.9. Find an application of sheaves in your own domain of expertise.\n♦\nApplication 5.2.3.10. Suppose we have a sheaf for temperatures on earth.\nFor every\nregion U we have a set of theoretically possible temperature-assignments throughout U.\nFor example we may know that if it is warm in Texas, warm in Arkansas, and warm\nin Kansas, then it cannot be cold in Oklahoma. With such a sheaf O in hand, one can\nuse facts about the temperature in one region U to predict the temperature in another\nregion V .\nThe mathematics is as follows. Suppose given regions U, V D X and a subset A D\nOpUq corresponding to what we know about the temperature assignment throughout U.\nWe take the following fiber product\npρU,Xq 1pAq\n⌟\n/\n\nOpXq\nρU,X\n\nρV,X / OpV q\nA\n/ OpUq\nThe image of the top map is a subset of OpV q telling us which temperature-assignments\nare possible throughout V given our knowledge A about the temperature throughout U.\nWe can imagine the same type of prediction systems for other domains as well, such\nas the energy of various parts of a material.\n♦♦\nExample 5.2.3.11. In Exercises 4.2.4.3 and 4.2.4.4 we discussed the idea of laws being\ndictated or respected throughout a jurisdiction.\nIf X is earth, to every jurisdiction\nU D X we assign the set OpUq of laws that are dictated to hold throughout U. Given\na law on U and a law on V , we can see if they amount to the same law on U X V . For\nexample, on U a law might say \"no hunting near rivers\" and on V a law might say \"no\nhunting in public areas\". It just so happens that on U XV all public areas are near rivers\nand vice versa, so the laws agree there. These laws patch together to form a single rule\nabout hunting that is enforced throughout the union U YV , respected by all jurisdictions\nwithin it.\n\nCHAPTER 5. CATEGORIES AT WORK\n5.2.3.12\nSheaf of ologged concepts\nDefinition 5.2.3.5 defines what should be called a sheaf of sets. We can discuss sheaves\nof groups or even sheaves of categories. Here is an application of the latter.\nRecall the notion of simplicial complexes discussed in Section 2.7.4.3. They look like\nthis:\n(5.7)\nGiven such a simplicial complex X, we can imagine each vertex v P X0 as an entity with\na worldview (e.g. a person) and each simplex as the common worldview shared by its\nvertices. To model this, we will assign to each vertex v P X an olog Opvq, corresponding\nto the worldview held by that entity, and to each simplex u P Xn, we assign an olog Opuq\ncorresponding to a common ground worldview.. Recall that X is a subset of PpX0q; it is\na preorder and its elements (the simplices) are ordered by inclusion. If u, v are simplices\nwith u D v then we want a map of ologs (i.e.\na schema morphism) Opvq N Opuq\ncorresponding to how any idea that is shared among the people in v is shared among\nthe people in u. Thus we have a functor O: X N Sch (where we are forgetting the\ndistinction between ologs and databases for notational convenience).\nTo every simplicial complex (indeed every ordered set) one can associate a topological\nspace; in fact we have a functor Alx: PrO N Top, called the Alexandrov functor.\nApplying AlxpXopq we have a space which we denote by X. One can visualize X as X,\nbut the open sets include unions of simplices. There is a unique sheaf of categories on\nX that behaves like X on simplices.\nHow does this work in the case of our sheaf O of worldviews? For simplices such as\npAq or pCIq, the sheaf returns the olog corresponding to that person or shared worldview.\nBut for open sets like the union of pCIJq and pIJKq, what we get is the olog consisting\nof the types shared by C, I, and J for which I and J affirm agreement with types shared\nby I, J, and K.\nExample 5.2.3.13. Imagine two groups of people G1 and G2 each making observations\nabout the world. Suppose that there is some overlap H \" G1 XG2. Then it may happen\nthat there is a conversation including G1 and G2 and both groups are talking about\nsomething and, although using different words, H says \"you guys are talking about the\n\n5.3. MONADS\nsame things, you just use different words.\" In this case there is an object-assignment\nthroughout G1 Y G2 that agrees with both those on G1 and those on G2.\n5.2.3.14\nTime\nOne can use sheaves to model objects in time; Goguen gave an approach to this in [Gog].\nFor another approach, let C be a database schema. The lifespan of information about the\nworld is generally finite; that is, what was true yesterday is not always the case today.\nThus we can associate to each interval U of time the information that we deem to hold\nthroughout U. This is sometimes called the valid time of the data.\nIf something is the case throughout U and we have a subset V D U then of course\nit is the case throughout V . And the sheaf condition holds too: if some information\nholds throughout U and some other information holds throughout U 1, and if these two\nthings restrict to the same information on the overlap U X V , then they can be glued to\ninformation that holds throughout the union U Y V .\nSo we can model information-change over time by using a sheaf of C-sets on the\ntopological space R. One way to think of this is simply as an instance on the schema\nC ˆ OpenpRqop. The sheaf condition is just an added property that our instances have\nto obey.\nExample 5.2.3.15. Consider a hospital in which babies are born. In our scenario, mothers\nenter the hospital, babies are born, mothers and babies leave the hospital. Let C be the\nschema\nc\na baby\nwas birthed by\n/\nm\na mother\nConsider the 8-hour intervals\nShift1 :\" pJan 1 00 : 00, Jan 1 08 : 00q,\nShift2 :\" pJan 1 04 : 00, Jan 1 12 : 00q,\nShift3 :\" pJan 1 8 : 00, Jan 1 16 : 00q.\nThe nurses take shifts of 8 hours, overlapping with their predecessors by 4 hours, and they\nrecord in the database only patients that were there throughout their shift or throughout\nany overlapping shift. A mother might be in the hospital throughout shift 1, arriving\nbefore the new year. A baby is born at 05:00 on Jan 1, and thus does not make it into\nthe Shift1-table, but does make it into the pShift1 X Shift2q-table. The two are there\nuntil 17:00 on Jan 1, and so they are recorded in the Shift2 and Shift3 tables.\nWhether or not this implementation of the sheaf semantics is most useful in practice\nis certainly debatable. But something like this could easily be useful as a semantics, i.e.\na way of thinking about, the temporal nature of data.\n5.3\nMonads\nMonads would probably not have been invented without category theory, but they have\nbeen quite useful in formalizing algebra, calculating invariants of topological spaces, and\nimbedding non-functional operations into functional programming languages. We will\nmainly discuss monads in terms of how they can help us make modeling contexts explicit,\nand in so doing allow us to simplify the language we use in the model.\nMuch of the following material on monads is taken from [Sp3].\n\nCHAPTER 5. CATEGORIES AT WORK\n5.3.1\nMonads formalize context\nMonads can formalize assumptions about the way one will do business throughout a\ndomain. For example, suppose that we want to consider functions that do not have to\nreturn a value for all inputs. Such partial functions can be composed. Indeed, given a\npartial function f : A N B and a partial function g: B N C, one gets a partial function\ng f : A N C in an obvious way.\nHere we are drawing arrows as though we are talking about functions, but there is an\nimplicit context in which we are actually talking about partial functions. Monads allow\nus to write things in the \"functional\" way while holding the underlying context. What\nmakes them useful is that the notion of context we are using here is made formal.\nExample 5.3.1.1 (Partial functions). Partial functions can be modeled by ordinary func-\ntions, if we add a special \"no answer\" element to the codomain. That is, the set of\npartial functions A N B is in one-to-one correspondence with the set of ordinary func-\ntions A N B \\ t,u.\nFor example, suppose we want to model the partial function\nfpxq :\"\nx2 1 : R N R in this way, we would use the function\nfpxq :\"\n$\n'\n&\n'\n%\nx2 1\nif x % 1 and x % 1,\n,\nif x \" 1,\n,\nif x \" 1.\nAn ordinary function f : A N B can be considered a partial function because we can\ncompose with the inclusion\nB N B \\ t,u\n(5.8)\nBut how do we compose two partial functions written in this way? Suppose f : A N\nB \\ t,u and g: B N C \\ t,u are functions. First form a new function\ng1 :\" g \\ t,u: B \\ t,u N C \\ t,u \\ t,u\n(5.9)\nthen compose to get pg1 fq: A N C \\ t,u \\ t,u, and finally send both ,'s to the same\nelement by composing with\nC \\ t,u \\ t,u N C \\ t,u.\n(5.10)\nWhat does this mean? Every element a P A is sent by f to either an element b P B\nor \"no answer\". If it has an answer fpaq P B, this is either sent by g to an element\ngpfpaqq P C or to \"no answer\". We get a partial function A N C by sending a to gpfpaqq\nif possible or to \"no answer\" if it gets stopped along the way.\nThis monad is sometimes called the maybe monad in computer science, because a\npartial function f : A N B takes every element of A and either outputs just an element\nof B or outputs nothing; more succinctly, it outputs a \"maybe B\".\nApplication 5.3.1.2. Experiments are supposed to be performed objectively, but suppose\nwe imagine that changing the person who performs the experiment, say in psychology,\nmay change the outcome. Let A be the set of experimenters, let X be the parameter space\nfor the experimental variables (e.g. X \" Age ˆ Income) and let Y be the observation\nspace (e.g. Y \" propensity for violence). Then whereas we want to think of such an\nexperiment as telling us about a function f : X N Y , we may want to make some of the\ncontext explicit by including information about who performed the experiment. That is,\nwe are really finding a function f : X ˆ A N Y .\n\n5.3. MONADS\nHowever, it may be the case that even ascertaining someones age or income, which\nis done by asking that person, is subject to who in A is doing the asking, and so we\nagain want to consider the experimenter as part of the equation. In this case, we can\nuse a monad to hide the fact that everything in sight is assumed to be influenced by\nA. In other words, we want to announce once and for all our modeling context--that\nevery observable is possibly influenced by the observer--so that it can recede into the\nbackground.\nWe will return to this in Examples 5.3.2.6 and 5.3.3.4.\n♦♦\n5.3.2\nDefinition and examples\nWhat aspects of Example 5.3.1.1 are really about monads, and what aspects are just\nabout partial functions in particular? It is a functor and a pair of natural transformations\nthat showed up in (5.9), (5.8), and (5.10). In this section we will give the definition and\na few examples. We will return to our story about how monads formalize context in\nSection 5.3.3.\nDefinition 5.3.2.1 (Monad). A monad on Set is defined as follows: One announces\nsome constituents (A. functor, B. unit map, C. multiplication map) and asserts that they\nconform to some laws (1. unit laws, 2. associativity law). Specifically, one announces\nA. a functor T : Set N Set,\nB. a natural transformation η: idSet N T, and\nC. a natural transformation μ: T T N T\nWe sometimes refer to the functor T as though it were the whole monad; we call η the\nunit map and we call μ the multiplication map. One asserts that the following laws hold:\n1. The following diagrams of functors Set N Set commute:\nT idSet\nidT η /\n\"\n%\nT T\nμ\n\nT\nidSet T\nη idT /\n\"\n%\nT T\nμ\n\nT\n2. The following diagram of functors Set N Set commutes:\nT T T\nμ idT /\nidT μ\n\nT T\nμ\n\nT T\nμ\n/ T\nExample 5.3.2.2 (List monad). We now go through Definition 5.3.2.1 using what is called\nthe List monad. The first step is to give a functor List: Set N Set, which we did in\nExample 4.1.2.18. Recall that if X \" tp, q, ru then ListpXq includes the empty list r s,\nsingleton lists, such as rps, and any other list of elements in X, such as rp, p, r, q, ps. Given\n\nCHAPTER 5. CATEGORIES AT WORK\na function f : X N Y , one obtains a function Listpfq: ListpXq N ListpY q by entry-wise\napplication of f.\nAs a monad, the functor List comes with two natural transformations, a unit map\nη and a multiplication map μ. Given a set X, the unit map ηX : X N ListpXq returns\nsingleton lists as follows\nX\nηX\n/ ListpXq\np\n/ rps\nq\n/ rqs\nr\n/ rrs\nGiven a set X, the multiplication map μX : ListpListpXqq N ListpXq flattens lists of lists\nas follows.\nListpListpXqq\nμX\n/ ListpXq\n\"\nrq, p, rs, rs, rq, r, p, rs, rrs\n%\n/ rq, p, r, q, r, p, r, rs\nThe naturality of η and μ just mean that these maps work appropriately well under\nterm-by-term replacement by a function f : X N Y . Finally the three monad laws from\nDefinition 5.3.2.1 can be exemplified as follows:\nrp, q, qs idList η / \"\nrps, rqs, rqs\n%\n_\nμ\n\nrp, q, qs\nrp, q, qs η idList / \"\nrp, q, qs\n%\n_\nμ\n\nrp, q, qs\n\"\"\nrp, qs, rrs\n%\n,\n\"\nrs, rr, q, qs\n%ı μ idList /\n_\nidList μ\n\n\"\nrp, qs, rrs, rs, rr, q, qs\n%\n_\nμ\n\n\"\nrp, q, rs, rr, q, qs\n%\nμ\n/ rp, q, r, r, q, qs\nExercise 5.3.2.3. Let P: Set N Set be the powerset functor, so that given a function\nf : X N Y the function Ppfq: PpXq N PpY q is given by taking images.\na.) Make sense of the following statement: \"with η defined by singleton subsets and with\nμ defined by union, J :\" pP, η, μq is a monad\".\nb.) With X \" ta, bu, write down the function ηX as a 2-row, 2-column table, and write\ndown the function μX as a 16-row, 2-column table (you can stop after 5 rows if you\nfully get it).\nc.) Check that you believe the monad laws from Definition 5.3.2.1.\n\n5.3. MONADS\n♦\nExample 5.3.2.4 (Partial functions as a monad). Here is the monad for partial functions.\nThe functor T : Set N Set sends a set X to the set X \\ t,u. Clearly, given a function\nf : X N Y there is an induced function f \\ t,u: X \\ t,u N Y \\ t,u, so this is a\nfunctor. The natural transformation η: id N T is given on a set X by the component\nfunction\nηX : X N X \\ t,u\nthat includes X aN X \\ t,u. Finally, the natural transformation μ: T T N T is given\non a set X by the component function\nμX : X \\ t,u \\ t,u YN X \\ t,u\nthat collapses both copies of ,.\nExercise 5.3.2.5. Let E be a set, elements we will refer to as exceptions. We imagine\nthat a function f : X N Y either outputs a value or one of these exceptions, which might\nbe things like \"overflow!\" or \"division by zero!\", etc. Let T : Set N Set be the functor\nX ÞN X\\E. Follow Example 5.3.2.4 and come up with a unit map η and a multiplication\nmap μ for which pT, η, μq is a monad.\n♦\nExample 5.3.2.6. Fix a set A. Let T : Set N Set be given by TpXq \" XA \" HomSetpA, Xq;\nthis is a functor. For a set X, let ηX : X N TpXq be given by the constant function,\nx ÞN cx : A N X where cxpaq \" x for all a P A. To specify a function\nμX : HomSetpA, TpXqq N HomSetpA, Xq,\nwe curry and need a function AˆHomSetpA, TpXqq N X. We have an evaluation function\n(see Exercise 2.7.2.5) ev: A ˆ HomSetpA, TpXqq N TpXq, and we have an identity func-\ntion idA : A N A, so we have a function pidAˆevq: AˆHomSetpA, TpXqq YN AˆTpXq.\nComposing that with another evaluation function A ˆ HomSetpA, Xq N X yields our\ndesired μX. Namely, for all b P A and f P HompA, TpXqq we have\nμXpfqpbq \" fpbqpbq.\nRemark 5.3.2.7. Monads can be defined on categories other than Set. In fact, for any\ncategory C one can take Definition 5.3.2.1 and replace every occurrence of Set with C\nand obtain the definition for monads on C. We have actually seen a monad pPaths, η, μq\non the category Grph of graphs before, namely in Examples 4.3.1.12 and 4.3.1.13. That\nis, Paths: Grph N Grph, which sends a graph to its paths-graph is the functor part.\nThe unit map η includes a graph into its paths-graph using the observation that every\narrow is a path of length 1. And the multiplication map μ concatenates paths of paths.\nThe Kleisli category of this monad (see Definition 5.3.3.1) is used, e.g. in (4.14) to define\nmorphisms of database schemas.\n5.3.3\nKleisli category of a monad\nGiven a monad J :\" pT, η, μq, we can form a new category KlspJq.\nDefinition 5.3.3.1. Let J \" pT, η, μq be a monad on Set. Form a new category, called\nthe Kleisli category for J, denoted KlspJq, with sets as objects, ObpKlspJqq :\" ObpSetq,\nand with\nHomKlspJqpX, Y q :\" HomSetpX, TpY qq\n\nCHAPTER 5. CATEGORIES AT WORK\nfor sets X, Y . The identity morphism idX : X N X in KlspJq is given by η: X N TpXq\nin Set. The composition of morphisms f : X N Y and g: Y N Z in KlspJq is given as\nfollows. Writing them as functions, we have f : X N TpY q and g: Y N TpZq. The first\nstep is to apply the functor T to g, giving Tpgq: TpY q N TpTpZqq. Then compose with\nf to get Tpgq f : X N TpTpZqq. Finally, compose with μZ : TpTpZqq N TpZq to get\nthe required function X N TpZq. The associativity of this composition formula follows\nfrom the associativity law for monads.\nExample 5.3.3.2. Recall the monad J for partial functions, TpXq \" X \\ t,u, from\nExample 5.3.2.4.\nThe Kleisli category KlspJq has sets as objects, but a morphism\nf : X N Y means a function X N Y \\ t,u, i.e a partial function.\nGiven another\nmorphism g: Y N Z, the composition formula in KlspJq ensures that g f : X N Z has\nthe appropriate behavior.\nNote how this monad allows us to make explicit our assumption that all functions\nare partial, and then hide it away from our notation.\nRemark 5.3.3.3. For any monad J \" pT, η, μq on Set, there is a functor i: Set N KlspJq\ngiven as follows. On objects we have ObpKlspJqq \" ObpSetq, so take i \" idObpSetq.\nGiven a morphism f : X N Y in Set, we need a morphism ipfq: X N Y in KlspJq, i.e.\na function ipfq: X N TpY q. We assign ipfq to be the composite X\nfYN Y\nηYN TpY q. The\nfunctoriality of this mapping follows from the unit law for monads.\nThe point is that any ordinary function (morphism in Set) has an interpretation as\na morphism in the Kleisli category of any monad. More categorically, there is a functor\nSet N KlspJq.\nExample 5.3.3.4. In this example we return to the setting laid out by Application 5.3.1.2\nwhere we had a set A of experimenters and assumed that the person doing the experiment\nmay affect the outcome. We use the monad J \" pT, η, μq from Example 5.3.2.6 and\nhope that KlspJq will conform to our understanding of how to manage the affect of the\nexperimenter on data.\nThe objects of KlspJq are ordinary sets, but a map f : X N Y in KlspJq is a function\nX N Y A. By currying this is the same as a function X ˆA N Y , as desired. To compose\nf with g: Y N Z in KlspJq, we follow the formula. It turns out to be equivalent to the\nfollowing. We have a function X ˆ A N Y and a function Y ˆ A N Z. Modifying the\nfirst slightly, we have a function X ˆ A N Y ˆ A, by identity on A, and we can now\ncompose to get X ˆ A N Z.\nWhat does this say in terms of experimenters affecting data gathering? It says that\nif we work within KlspJq then we will be able to assume that the experimenter is being\ntaken into account; all proposed functions X N Y are actually functions A ˆ X N Y .\nThe natural way to compose these experiments is that we only consider the data from\none experiment to feed into another if the experimenter is the same in both experiments.\nExercise 5.3.3.5. In Exercise 5.3.2.3 we discussed the power set monad J \" pP, η, μq.\na.) Can you find a way to relate the morphisms in KlspJq to relations? That is, given\na morphism f : A N B in KlspJq, is there a natural way to associate to it a relation\nR D A ˆ B?\n13This requirement seems a bit stringent, but it can be mitigated in a variety of ways. One such way\nis to notice that by Remark 5.3.3.3 that we have not added any requirement, because any old way of\ndoing business yields a valid new way of doing business (we just say \"every experimenter would get the\nsame result\"). Another way would be to hand offthe experiment results to another person, who could\ncarry it forward (see Example 5.3.3.8).\n\n5.3. MONADS\nb.) How does the composition formula in KlspJq relate to the composition of relations\ngiven in Definition 2.5.2.3? 14\n♦\nExercise 5.3.3.6. Let J \" pP, η, μq be the power set monad. The category KlspJq is\nclosed under binary products, i.e.\nevery pair of objects A, B P ObpKlspJqq have a\nproduct in KlspJq. What is the product of A \" t1, 2, 3u and B \" ta, bu?\n♦\nExercise 5.3.3.7. Let J \" pP, η, μq be the power set monad. The category KlspJq is\nclosed under binary coproducts, i.e. every pair of objects A, B P ObpKlspJqq have a\ncoproduct in KlspJq. What is the coproduct of A \" t1, 2, 3u and B \" ta, bu?\n♦\nExample 5.3.3.8. Let A be any preorder. We speak of A throughout this example as\nthough it was the linear order given by time because this is a nice case, however the\nmathematics works for any A P ObpPrOq.\nThere is a monad J \" pT, η, μq that captures the idea that a function f : X N Y\noccurs in the context of time in the following sense: The output of f is determined not\nonly by the element x P X on which it is applied but also by the time at which it was\napplied to x; and the output of f occurs at another time, which is not before the time\nof input.\nThe functor part of the monad is given on X P ObpSetq by\nTpXq \" tp: A N A ˆ X | if ppaq \" pa1, xq then a1 e au.\nThe unit ηX : X N TpXq sends x to the function a ÞN pa, xq. The multiplication map\nμX : TpTpXqq N TpXq is roughly described as follows. If for every a P A you have a\nlater element a1 e a and a function p: A N A ˆ X that takes elements of A to later\nelements of A and values of X, then ppa1q is a still later element of A and a value of X,\nas desired.\nMorphisms in the Kleisli category KlspJq can be curried to be functions f : AˆX N\nA ˆ Y such that if fpa, xq \" pa1, yq then a1 e a.\nRemark 5.3.3.9. One of the most important monads in computer science is the so-called\nstate monad. It is used when one wants to allow a program to mutate state variables\n(e.g. in the program\nif x a 4 then x :\" x ` 1 else Print \"done\")\nx is a state variable. The state monad is a special case of the monad discussed in Example\n5.3.3.8. Given any set A, the usual state monad of type A is obtained by giving A the\nindiscrete preorder (see Example 3.4.4.5). More explicitly it is a monad with functor\npart\nX ÞN pA ˆ XqX,\nand it will be briefly discussed in Example 5.3.5.4.\nExample 5.3.3.10. Here we reconsider the image from the front cover of this book, re-\nproduced here.\n14Actually, Definition 2.5.2.3 is about composing spans, but a relation R D A ˆ B is a kind of span,\nR N A ˆ B.\n\nCHAPTER 5. CATEGORIES AT WORK\nIt looks like an olog, and all ologs are database schemas (see Section 3.5.2.14). But\nhow is \"analyzed by a person yields\" a function from observations to hypotheses? The\nvery name belies the fact that it is an invalid aspect in the sense of Section 2.3.2.1, because\ngiven an observation there may be more than one hypothesis yielded, corresponding to\nwhich person is doing the observing. In fact, all of the arrows in this diagram correspond\nto some hidden context involving people: the prediction is dependent on who analyzes\nthe hypothesis, the specification of an experiment is dependent on who is motivated to\nspecify it, and experiments may result in different observations by different observers.\nWithout monads, the model of science proposed by this olog would be difficult to\nbelieve in. But by choosing a monad we can make explicit (and then hide from discourse)\nour implicit assumption that \"of course this is all dependent on which human is doing\nthe science\". The choice of monad is an additional modeling choice. Do we want to\nincorporate the partial order of time? Do we want the scientist to be modified by each\nfunction (i.e. the person is changed when analyzing an observation to yield a hypothesis)?\nThese are all interesting possibilities.\nOne reasonable choice would be to use the state monad of type A, where A is the\nset of scientific models. This implies the following context: every morphism f : X N Y\nin the Kleisli category of this monad is really a morphism f : X ˆ A N Y ˆ A; while\nostensibly giving a map from X to Y , it is influenced by the scientific model under which\nit is performed, and its outcome yields a new scientific model.\nReading the olog in this context might look like this:\nA hypothesis (in the presence of a scientific model) analyzed by a person\nproduces a prediction (in the presence of a scientific model), which motivates\nthe specification of an experiment (in the presence of a scientific model),\nwhich when executed results in an observation (in the presence of a scientific\nmodel), which analyzed by a person yields a hypothesis (in the presence of a\nscientific model).\nThe parenthetical statements can be removed if we assume them to always be around,\nwhich can be done using the monad above.\n\n5.3. MONADS\n5.3.3.11\nRelaxing functionality constraint for ologs\nIn Section 2.3.2 we said that every arrow in an olog has to be English-readable as a\nsentence, and it has to correspond to a function. For example, the arrow\na person\nhas / a child\n(5.11)\ncomprises an readable sentence, but does not correspond to a function because a person\nmay have no children or more than one child.\nWe'll call olog in which every arrow\ncorresponds to a function (the only option proposed so far in the book) a functional\nolog. Requiring that ologs be functional as we have been doing, comes with advantages\nand disadvantages. The main advantage is that creating a functional olog requires more\nconceptual clarity about the situation, and this has benefits for the olog-creator as well\nas for anyone to whom he or she tries to explain the situation. The main disadvantage\nis that creating a functional olog takes more time, and the olog takes up more space on\nthe page.\nIn the context of the power set monad (see Exercise 5.3.2.3), a morphism f : X N Y\nbetween sets X and Y becomes a binary relation on X and Y , rather than a function,\nas seen in Exercise 5.3.3.5. So in that context, the arrow in (5.11) becomes valid. An\nolog in which arrows correspond to mere binary relations rather than functions might be\ncalled a relational olog.\n5.3.4\nMonads in databases\nIn this section we discuss how to record data in the presence of a monad. The idea is quite\nsimple. Given a schema (category) C, an ordinary instance is a functor I : C N Set. But\nif J \" pT, η, μq is a monad, then a Kleisli J-instance on C is a functor J : C N KlspJq.\nSuch a functor associates to every object c P ObpCq a set Jpcq, and to every arrow\nf : c N c1 in C a morphism Jpfq: Jpcq N Jpc1q in KlspJq. How does this look in terms\nof tables?\nRecall that to represent an ordinary database instance I : C N Set, we use a tabular\nformat in which every object c P ObpCq is displayed as a table including one ID column\nand an additional column for every arrow emanating from c. In the ID column of table\nc were elements of the set Ipcq and in the column assigned to some arrow f : c N c1 the\ncells were elements of the set Ipc1q.\nTo represent a Kleisli database instance J : C N KlsJ is similar; we again use a\ntabular format in which every object c P ObpCq is displayed as a table including one ID\ncolumn and an additional column for every arrow emanating from c. In the ID column\nof table c are again elements of the set Jpcq; however in the column assigned to some\narrow f : c N c1 are not elements of Jpc1q but T-values in Jpc1q, i.e. elements of TpJpc1qq.\nExample 5.3.4.1. Let J \" pT, η, μq be the monad for partial functions, as discussed in\nExample 5.3.1.1. Given any schema C, we can represent a Kleisli J-instance I : C N\nKlspJq in tabular format. To every object c P ObpCq we'll have a set Ipcq of rows, and\ngiven a column c N c1 every row will produce either a value in Ipc1q or fail to produce\na value; this is the essence of partial functions. We might denote the absence of a value\nusing ,.\nConsider the schema indexing graphs\nC :\"\nArrow\n‚\nsrc /\ntgt /\nVertex\n‚\n\nCHAPTER 5. CATEGORIES AT WORK\nAs we discussed in Section 4.2.1.20, an ordinary instance on C represents a graph.\nI :\"\n‚v\nf\n/ ‚w\nh\n=\ng\n#\n‚x\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nA Kleisli J-instance on C represents graphs in which edges can fail to have a source\nvertex, fail to have a target vertex, or both.\nJ :\"\n‚v\ni\n\nf\n/ ‚w\nh\n=\ng\n#\n‚x\nj\n/\nArrow pJq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\ni\nv\n,\nj\n,\n,\nVertex pJq\nID\nv\nw\nx\nThe context of these tables is that of partial functions, so we do not need a reference for\n, in the vertex table. Mathematically, the morphism Jpsrcq: JpArrowq N JpVertexq\nneeds to be a function JpArrowq N JpVertexq \\ t,u, and it is.\n5.3.4.2\nProbability distributions\nLet r0, 1s D R denote the set of real numbers between 0 and 1. Let X be a set and\np: X N r0, 1s a function. We say that p is a finitary probability distribution on X if\nthere exists a finite subset W D X such that\ny\nwPW\nppwq \" 1,\n(5.12)\nand such that ppxq a 0 if and only if x P W. Note that W is unique if it exists; we call\nit the support of p and denote it Suppppq. Note also that if X is a finite set then every\nfunction p satisfying (5.12) is a finitary probability distribution on X.\nFor any set X, let DistpXq denote the set of finitary probability distributions on X. It\nis easy to check that given a function f : X N Y one obtains a function Distpfq: DistpXq N\nDistpY q by Distpfqpyq \" r\nfpxq\"y ppxq. Thus we can consider Dist: Set N Set as a\nfunctor, and in fact the functor part of a monad. Its unit η: X N DistpXq is given by the\nKronecker delta function x ÞN δx where δxpxq \" 1 and δxpx1q \" 0 for x1 % x. Its multipli-\ncation μ: DistpDistpXqq N DistpXq is given by weighted sum: given a finitary proba-\nbility distribution w: DistpXq N r0, 1s and x P X, put μpwqpxq \" r\npPSupppwq wppqppxq.\nExample 5.3.4.3 (Markov chains). Let Loop be the loop schema,\nLoop :\"\ns‚\nf\n\nas in Example 3.5.2.9. A Dist-instance on Loop is equivalent to a time-homogeneous\nMarkov chain. To be explicit, a functor δ: Loop N KlsDist assigns to the unique object\n\n5.3. MONADS\ns P ObpLoopq a set S \" δpsq, which we call the state space, and to f : s N s a function\nδpfq: S N DistpSq, which sends each element x P S to some probability distribution on\nelements of S. For example, the table δ on the left corresponds to the Markov matrix\nM on the right below:\nδ :\"\ns\nID\nf\n.5(1)+.5(2)\n1(2)\n.7(1)+.3(3)\n.4(1)+.3(2)+.3(4)\nM :\"\n\n0.5\n0.5\n0.7\n0.3\n0.4\n0.3\n0.3\n\n‹‹‚\n(5.13)\nAs one might hope, for any natural number n P N the map f n : S N DistpSq\ncorresponds to the matrix M n, which sends an element in S to its probable location\nafter n iterations of the transition map.\nApplication 5.3.4.4. Every star emits a spectrum of light, which can be understood as\na distribution on the electromagnetic spectrum. Given an object B on earth, different\nparts of B will absorb radiation at different rates. Thus B produces a function from the\nelectromagnetic spectrum to distributions of energy absorption. In the context of the\nprobability distributions monad, we can record data on the schema\nstar\n‚\nemits\n/ wavelengths\n‚\nabsorbed by B\n/ energies\n‚\nThe composition formula for Kleisli categories is the desired one: to each star we associate\nthe weighted sum of energy absorption rates over the set of wavelengths emitted by the\nstar.\n♦♦\n5.3.5\nMonads and adjunctions\nThere is a strong connection between monads and adjunctions: every adjunction creates\na monad, and every monad \"comes from\" an adjunction. For example, the List monad\n(Example 5.3.2.2) comes from the free-forgetful adjunction between sets and monoids\nSet\nF\n/Mon\nU\no\n(see Proposition 5.1.1.2). That is, for any set X, the free monoid on X is\nFpXq \" pListpXq, r s, ``q,\nand the underlying set of that monoid is UpFpXqq \" ListpXq. Now it may seem like\nthere was no reason to use monoids at all--the set ListpXq was needed in order to discuss\nFpXq--but it will turn out that the unit η and multiplication μ will come drop out of\nthe adjunction too. First, we discuss the unit and counit of an adjunction.\nDefinition 5.3.5.1. Let C and D be categories, and let L: C N D and R: D N C be\nfunctors with adjunction isomorphism\nαc,d : HomDpLpcq, dq\n-\nYYYN HomCpc, Rpdqq\n\nCHAPTER 5. CATEGORIES AT WORK\nfor any objects c P ObpCq and d P ObpDq. The unit η: idC N R L (respectively the\ncounit ε: L R N idD) are natural transformations defined as follows.\nGiven an object c P ObpCq, we apply α to idLpcq : Lpcq N Lpcq to get\nηc : c N R Lpcq;\nsimilarly given an object d P ObpDq we apply α 1 to idRpdq : Rpdq N Rpdq to get\nεd : L Rpdq N d.\nBelow we will show how to use the unit and counit of any adjunction to make a\nmonad. We first walk through the process in Example 5.3.5.2.\nExample 5.3.5.2. Consider the adjunction Set\nF\n/Mon\nU\no\nbetween sets and monoids.\nLet T \" U F : Set N Set; this will be the functor part of our monad, and we have\nT \" List. Then the unit of the adjunction, η: idSet N U F is precisely the unit of the\nmonad: for any set X P ObpSetq the component ηX : X N ListpXq is the function that\ntakes x P X to the singleton list rxs P ListpXq. The monad also has a multiplication\nmap μX : TpTpXqq N TpXq, which amounts to flattening a list of lists. This function\ncomes about using the counit ε, as follows\nT T \" U F U F\nidU ε idF\nYYYYYYYYYN U F \" T.\nThe general procedure for extracting a monad from an adjunction is analogous to\nthat shown in Example 5.3.5.2. Given any adjunction\nC\nL\n/D\nR\no\nWe define J \" R L: C N C, we define η: idC N J to be the unit of the adjunction\n(as in Definition 5.3.5.1), and we define μ: J J N J to be the natural transformation\nidR ε idL : RLRL N RL, obtained by applying the counit ε: LR N idD.\nThe above procedure produces monads on arbitrary categories C, whereas our def-\ninition of monad (Definition 5.3.2.1) considers only the case C \" Set. However, this\ndefinition can be generalized to arbitrary categories C by simply replacing every occur-\nrence of the string Set with the string C. Similarly, our definition of Kleisli categories\n(Definition 5.3.3.1) considers only the case C \" Set, but again the generalization to\narbitrary categories C is straightforward. In Proposition 5.3.5.3, it may be helpful to\nagain put C \" Set if one is at all disoriented.\nProposition 5.3.5.3. Let C be a category, let pJ, η, μq be a monad on C, and let K :\"\nKlsCpJq be the Kleisli category. Then there is an adjunction\nC\nL\n/K\nR\no\nsuch that the monad pJ, η, μq is obtained (up to isomorphism) by the above procedure.\nSketch of proof. The functor L: C N K was discussed in Remark 5.3.3.3. We define it\nto be identity on objects (recall that ObpKq \" ObpCq). Given objects c, c1 P ObpCq the\nfunction\nHomCpc, c1q\nL\nYYYN HomKpc, c1q \" HomCpc, Jpc1qq\n\n5.4. OPERADS\nis given by f ÞN ηc1 f. The fact that this is a functor (i.e. that it preserves composition)\nfollows from a monad axiom.\nThe functor R: K N C acts on objects by sending c P ObpKq \" ObpCq to Jpcq P\nObpCq. For objects c, c1 P ObpKq the function\nHomCpc, Jpc1qq \" HomKpc, c1q\nR\nYYYN HomCpJpcq, Jpc1qq\nis given by sending the C-morphism f : c N Jpc1q to the composite\nJpcq\nJpfq\nYYYYYN JJpc1q\nμc1\nYYYYN Jpc1q.\nAgain, the functoriality follows from monad axioms.\nWe will not continue on to show that these are adjoint or that they produce the\nmonad pJ, η, μq, but see [Mac, VI.5.1] for the remainder of the proof.\n□\nExample 5.3.5.4. Let A P ObpSetq be a set, and recall the currying adjunction\nSet\nAˆ /Set\nA\no\ndiscussed briefly in Example 5.1.1.8. The corresponding monad StA is typically called\nthe state monad of type A in programming language theory. Given a set X, we have\nStApXq \" pA ˆ XqA.\nIn the Kleisli category KlspStAq a morphism from X to Y is a function of the form\nX N pA ˆ Y qA, but this can be curried to a function A ˆ X N A ˆ Y .\nThis monad is related to holding on to an internal state variable of type A. Every\nmorphism ostensibly from X to Y actually takes as input not only an element of X but\nalso the current state a P A, and it produces as output not only an element of Y but an\nupdated state as well.\nComputer scientists in programming language theory have found monads to be very\nuseful ([Mog]). In much the same way, monads on Set can be useful in databases, as\ndiscussed in Section 5.3.4. Another, totally different way to use monads in databases is by\nusing a mapping between schemas to produce in each one an internal model of the other.\nThat is, for any functor F : C N D, i.e. mapping of database schemas, the adjunction\npΣF , ∆F q produces a monad on C-Set, and the adjunction p∆F , ΠF q produces a monad\non D-Set. If one interprets the List monad as producing in Set an internal model of\nthe category Mon of monoids, one can similarly interpret the above monads on C-Set\nand D-Set as producing internal models of each within the other.\n5.4\nOperads\nIn this section we briefly introduce operads, which are generalizations of categories.\nThey often are useful for speaking about self-similarity of structure. For example, we\nwill use them to model agents made up of smaller agents, or materials made up of smaller\nmaterials. This association with self-similarity is not really inherent in the definition,\nbut it tends to emerge in our thinking about many operads used in practice.\nLet me begin with a warning.\n\nCHAPTER 5. CATEGORIES AT WORK\nWarning 5.4.0.5. My use of the term operad is not entirely standard and conflicts with\nwidespread usage. The more common term for what I am calling an operad is symmetric\ncolored operad or a symmetric multicategory. An operad classically is a multicategory\nwith one object, and a colored operad is a multicategory. The analogy is that \"operad is\nto multicategory as monoid is to category\". The term multicategory stems from the fact\nthat the morphisms in a multicategory have many, rather than one, input. But there\nis nothing really \"multi\" about the multicategory itself, only its morphisms. Probably\nthe real reason though is that I find the term multicategory to be clunky and the term\noperad to be sleek, clocking in at half the syllables. I apologize if my break with standard\nterminology causes any confusion.\nThis introduction to operads is quite short. One should see [Le1] for an excellent\ntreatment.\n5.4.1\nDefinition and classical examples\nAn operad is like a category in that it has objects, morphisms, and a composition formula,\nand it follows an identity law and an associativity law.\nThe difference is that each\nmorphism has many inputs (and one output).\nThe description of composition in an operad is a bit heavier than it is in a category, but\nthe idea fairly straightforward. Here is a picture of morphisms being composed.\n\n5.4. OPERADS\nA\nB\nC\nS\nD\nT\nf1\nf2\ng\nX\ng ⚬ (f1,f2)\nX\nA\nB\nC\nD\nthe arrows above compose to give\nNote that S and T disappear from the composition, but this is analogous to the way the\nmiddle object disappears from the composition of morphisms in a category\nA\nf\nYYYN S\ng\nYYYN X\nthe arrows to the left compose to give\nA\ng f\nYYYYYN X\nHere is the definition, which we take directly from [Sp4].\nDefinition 5.4.1.1. An operad O is defined as follows: One announces some constituents\n(A. objects, B. morphisms, C. identities, D. compositions) and asserts that they conform\nto some laws (1. identity law, 2. associativity law). Specifically,\nA. one announces a collection ObpOq, each element of which is called an object of\nO.\nB. for each object y P ObpOq, finite set n P ObpFinq, and n-indexed set of objects\nx: n N ObpOq, one announces a set Onpx; yq P ObpSetq. Its elements are called\nmorphisms from x to y in O.\nC. for every object x P ObpOq, one announces a specified morphism denoted idx P\nO1px; xq called the identity morphism on x.\nD. Let s: m N n be a morphism in Fin. Let z P ObpOq be an object, let y: n N\nObpOq be an n-indexed set of objects, and let x: m N ObpOq be an m-indexed\nset of objects. For each element i P n, write mi :\" s 1piq for the pre-image of s\nunder i, and write xi \" x|mi : mi N ObpOq for the restriction of x to mi. Then\n\nCHAPTER 5. CATEGORIES AT WORK\none announces a function\n: Onpy; zq ˆ\nz\niPn\nOmipxi; ypiqq YN Ompx; zq,\n(5.14)\ncalled the composition formula.\nGiven an n-indexed set of objects x: n N ObpOq and an object y P ObpOq, we sometimes\nabuse notation and denote the set of morphisms from x to y by Opx1, . . . , xn; yq. 15 We\nmay write HomOpx1, . . . , xn; yq, in place of Opx1, . . . , xn; yq, when convenient. We can\ndenote a morphism φ P Onpx; yq by φ: x N y or by φ: px1, . . . , xnq N y; we say that\neach xi is a domain object of φ and that y is the codomain object of φ. We use infix\nnotation for the composition formula, e.g. writing ψ pφ1, . . . , φnq.\nOne asserts that the following laws hold:\n1. for every x1, . . . , xn, y P ObpOq and every morphism φ: px1, . . . , xnq N y, we\nhave\nφ pidx1, . . . , idxnq \" φ\nand\nidy φ \" φ;\n2. Let m\nsYN n\ntYN p be composable morphisms in Fin.\nLet z P ObpOq be an\nobject, let y: p N ObpOq, x: n N ObpOq, and w: m N ObpOq respectively\nbe a p-indexed, n-indexed, and m-indexed set of objects. For each i P p, write\nni \" t 1piq for the pre-image and xi : ni N ObpOq for the restriction. Similarly,\nfor each k P n write mk \" s 1pkq and wk : mk N ObpOq; for each i P p, write\nmi, \" pt sq 1piq and wi, : mi, N ObpOq; for each j P ni, write mi,j :\" s 1pjq\nand wi,j : mi,j N ObpOq. Then the diagram below commutes:\ns\nOppy; zq ˆ s\niPp Onipxi; ypiqq ˆ s\niPp, jPni Omi,jpwi,j; xipjqq\n*\nt s\nOnpx; zq ˆ s\nkPn Omkpwk; xpkqq\n)\ns\nOppy; zq ˆ s\niPp Omi, pwi, ; ypiqq\nu\nOmpw; zq\nRemark 5.4.1.2. In this remark we will discuss the abuse of notation in Definition 5.4.1.1\nand how it relates to an action of a symmetric group on each morphism set in our\ndefinition of operad. We follow the notation of Definition 5.4.1.1, especially following\nthe use of subscripts in the composition formula.\nSuppose that O is an operad, z P ObpOq is an object, y: n N ObpOq is an n-indexed\nset of objects, and φ: y N z is a morphism.\nIf we linearly order n, enabling us to\nwrite φ: pyp1q, . . . , yp|n|qq N z, then changing the linear ordering amounts to finding an\nisomorphism of finite sets σ: m -\nYN n, where |m| \" |n|. Let x \" y σ and for each i P n,\nnote that mi \" σ 1ptiuq \" tσ 1piqu, so xi \" x|σ 1piq \" ypiq. Taking idxi P Omipxi; ypiqq\nfor each i P n, and using the identity law, we find that the composition formula induces\na bijection Onpy; zq -\nYN Ompx; zq, which we might denote by\nσ: Opyp1q, yp2q, . . . , ypnq; zq - O\n`\nypσp1qq, ypσp2qq, . . . , ypσpnqq; z\n\n.\n15There are three abuses of notation when writing Opx1, . . . , xn; yq, which we will fix one by one. First,\nit confuses the set n P ObpFinq with its cardinality |n| P N. But rather than writing Opx1, . . . , x|n|; yq,\nit would be more consistent to write Opxp1q, . . . , xp|n|q; yq, because we have assigned subscripts another\nmeaning in part D. But even this notation unfoundedly suggests that the set n has been endowed with\na linear ordering, which it has not. This may be seen as a more serious abuse, but see Remark 5.4.1.2.\n\n5.4. OPERADS\nIn other words, there is an induced group action of Autpnq on Onpx; zq, where Autpnq is\nthe group of permutations of an n-element set.\nThroughout this book, we will permit ourselves to abuse notation and speak of mor-\nphisms φ: px1, x2, . . . , xnq N y for a natural number n P N, without mentioning the\nabuse inherent in choosing an order, so long as it is clear that permuting the order of\nindices would not change anything up to canonical isomorphism.\nExample 5.4.1.3. Let Sets denote the operad defined as follows. For objects we put\nObpSetsq \" ObpSetq. For a natural number n P N and sets X1, . . . , Xn, Y , put\nHomSetspX1, . . . , Xn; Y q :\" HomSetpX1 ˆ ˆ Xn, Y q.\nGiven functions f1 : pX1,1 ˆ ˆ X1,m1q N Y1 through fn : pXn,1 ˆ ˆ Xn,mnq N Yn\nand a function Y1 ˆ ˆ Yn N Z, the universal property provides us a unique function\nof the form pX1,1 ˆ ˆ Xn,mnq YN Z, giving rise to our composition formula.\nExample 5.4.1.4 (Little squares operad). An operad commonly used in mathematics is\ncalled the little n-cubes operad. We'll focus on n \" 2 and talk about the little squares\noperad O. Here the set of objects has only one element, which we denote by a square,\nObpOq \" t u.\nFor a natural number n P N, a morphism f : p , , . . . , q YN is a\npositioning of n non-overlapping squares inside of a square.\nHere is a picture of a\nmorphism pX1, X2, X3q N Y , where X1 \" X2 \" X3 \" Y \" .\nThe composition law says that given a positioning of small squares inside a large square,\nand given a positioning of tiny squares inside each of those small squares, we get a\npositioning of tiny squares inside a large square. A picture is shown in Figure 5.15.\n\nCHAPTER 5. CATEGORIES AT WORK\nFigure 5.15: Here we show a morphism pX1, X2, X3q N Y and morphisms pW1,1, W1,2q N\nX1, pW2,1, W2,2, W2,3q N X2, and pW3,1q N X3, each of which is a positioning of squares\ninside a square. The composition law scales and positions the squares in the \"obvious\"\nway.\nHopefully, what we meant by \"self-similarity\" in the introduction to this section (see\npage 247) is becoming clear.\nExercise 5.4.1.5. Consider an operad O like the little squares operad from Example\n5.4.1.4, except with three objects: square, circle, equilateral triangle. A morphism is\nagain a non-overlapping positioning of shapes inside of a shape.\na.) Draw an example of a morphism f from two circles and a square to a triangle.\nb.) Find three other morphisms that compose into f, and draw the composite.\n♦\n5.4.1.6\nOperads: functors and algebras\nIf operads are like categories, then we can define things like functors and call them operad\nfunctors. Before giving the definition, we give a warning.\n\n5.4. OPERADS\nWarning 5.4.1.7. What we call operad functors in Definition 5.4.1.8 are usually (if not\nalways) called operad morphisms. We thought that the terminology clash between mor-\nphisms of operads and morphisms in an operad was too confusing. It is similar to what\nwould occur in regular category theory (e.g. Chapter 4) if we replaced the term \"functor\"\nwith the term \"category morphism\".\nDefinition 5.4.1.8. Let O and O1 be operads. An operad functor from O to O1, denoted\nF : O N O1 consists of some constituents (A. on-objects part, B. on-morphisms part)\nconforming to some laws (1. preservation of identities, 2. preservation of composition),\nas follows:\nA. There is a function ObpFq: ObpOq N ObpO1q.\nB. For each object y P ObpOq, finite set n P ObpFinq, and n-indexed set of objects\nx: n N ObpOq, there is a function\nFn : Onpx; yq N O1\nnpFx; Fyq.\nAs in B. above, we often denote ObpFq, and also each Fn, simply by F. The laws that\ngovern these constituents are as follows:\n1. For each object x P ObpOq, the equation Fpidxq \" idF x holds.\n2. Let s: m N n be a morphism in Fin. Let z P ObpOq be an object, let y: n N\nObpOq be an n-indexed set of objects, and let x: m N ObpOq be an m-indexed\nset of objects. Then, with notation as in Definition 5.4.1.1, the following diagram\nof sets commutes:\nOnpy; zq ˆ s\niPn Omipxi; ypiqq\nF\n/\n\nO1\nnpFy; Fzq ˆ s\niPn O1\nmipFxi; Fypiqq\n\nOmpx; zq\nF\n/ O1\nmpFx; Fzq\n(5.16)\nWe denote the category of operads and operad functors by Oprd.\nExercise 5.4.1.9. Let O denote the little squares operad from Example 5.4.1.4 and let\nO1 denote the operad you constructed in Exercise 5.4.1.5.\na.) Can you come up with an operad functor O N O1?\nb.) Is it possible to find an operad functor O1 N O?\n♦\nDefinition 5.4.1.10 (Operad algebra). Let O be an operad. An algebra on O is an\noperad functor A: O N Sets.\nRemark 5.4.1.11. Every category can be construed as an operad (yes, there is a functor\nCat N Oprd), by simply not including non-unary morphisms. That is, given a category\nC, one makes an operad O with ObpOq :\" ObpCq and with\nHomOpx1, . . . , xn; yq \"\n#\nHomCpx1, yq\nif n \" 1;\nH\nif n % 1\n\nCHAPTER 5. CATEGORIES AT WORK\nJust like a schema is a category presentation, it is possible to discuss operad presentations\nby generators and relations. Under this analogy, an algebra on an operad corresponds\nto an instance on a schema.\n5.4.2\nApplications of operads and their algebras\nHierarchical structures may be well-modeled by operads.\nDescribing such structures\nusing operads and their algebras allows one to make appropriate distinctions between\ndifferent types of thinking. For example, the allowable formations are encoded in the\noperad, whereas the elements that will fit into those formations are encoded in the\nalgebra. Morphisms of algebras are high-level understandings of how elements of very\ndifferent types (such as materials vs. numbers) can occupy the same place in the structure\nand be compared. We will give examples below.\nApplication 5.4.2.1. Every material is composed of constituent materials, arranged in\ncertain patterns. (In case the material is \"pure\", we consider the material to consist\nof itself as the sole constituent.) Each of these constituent materials each is itself an\narrangement of constituent materials. Thus we see a kind of self-similarity which we can\nmodel with operads.\nOne material is a structured\ncomposite of other materials,\neach of which is a structured\ncomposite of other materials.\n(5.17)\nFor example, a tendon is made of collagen fibers that are assembled in series and\nthen in parallel, in a specific way. Each collagen fibre is made of collagen fibrils that are\nagain assembled in series and then in parallel, with slightly different specifications. We\ncan continue down, perhaps indefinitely, though our resolution fails at some point. A\n\n5.4. OPERADS\ncollagen fibril is made up of tropocollagen collagen molecules, which are twisted ropes\nof collagen molecules, etc.16\nHere is how operads might be employed. We want the same operad to model both\nactual materials, theoretical materials, and functional properties; that is we want more\nthan one algebra on the same operad.\nThe operad O should abstractly model the structure, but not the substance being\nstructured.\nImagine that each of the shapes (including the background \"shape\") in\nDiagram (5.17) is a place-holder, saying something like \"your material here\".\nEach\nmorphism (that's what (5.17) is a picture of) represents a construction of a material out\nof parts. In our picture, it appears we are only concerned with the spacial arrangements,\nbut there is far more flexibility than that. Whether we want to allow for additional\ndetails beyond spacial arrangements is the kinds of choice we make in a meeting called\n\"what operad should we use?\"\n♦♦\nApplication 5.4.2.2. Suppose we have chosen an operad O to model the structure of\nmaterials. Each object of O might correspond to a certain quality of material, and each\nmorphism corresponds to an arrangement of various qualities to form a new quality. An\nalgebra A: O N Sets on O forces us to choose what substances will fill in for these\nqualities. For every object x P ObpOq, we want a set Apxq which will be the set of\nmaterials with that quality. For every arrangement, i.e. morphism, f : px1, . . . , xnq N y,\nand every choice a1 P Apx1q, . . . , an P Apxnq of materials, we need to understand what\nmaterial a1 \" Apfqpa1, . . . , anq P Apyq will emerge when these materials are arranged in\naccordance with f. We are really pinning ourselves down here.\nBut there may be more than one interesting algebra on O. Suppose that B : O N Sets\nis an algebra of strengths rather than materials. For each object x P ObpOq, which\nrepresents some quality, we let Bpxq be the set of possible strengths that something of\nquality x can have. Then for each arrangement, i.e. morphism, f : px1, . . . , xnq N y,\nand every choice b1 P Bpx1q, . . . , bn P Bpxnq of strengths, we need to understand what\nstrength b1 \" Bpfqpb1, . . . , bnq P Bpyq will emerge when these strengths are arranged in\naccordance with f. Certainly an impressive achievement!\nFinally, a morphism of algebras S : A N B would consist of a coherent system for\nassigning to each material a P ApXq of a given quality x a specific strength Spaq P BpXq,\nin such a way that morphisms behaved appropriately. In this language we have stated a\nvery precise goal for the field of material mechanics.\n♦♦\nExercise 5.4.2.3. Consider again the little squares operad O from Example 5.4.1.4. Sup-\npose we wanted to use this operad to describe those photographic mosaics.\na.) Come up with an algebra P : O N Sets that sends the square to the set of all photos\nthat can be pasted into that square. What does P do on morphisms in O?\nb.) Come up with an algebra C : O N Sets that sends each square to the set of all colors\n(visible frequencies of light). In other words, Cp q is the set of colors, not the set of\nways to color the square. What does C do on morphisms in O. Hint: use some kind\nof averaging scheme for the morphisms.\nc.) Guess: if someone were to appropriately define morphisms of O-algebras (something\nakin to natural transformations between functors O N Sets), do you think there\n16Thanks to Professor Sandra Shefelbine for explaining the hierarchical nature of collagen to me. Any\nerrors are my own.\n\nCHAPTER 5. CATEGORIES AT WORK\nwould some a morphism of algebras P N C?\n♦\n5.4.2.4\nWiring diagrams\nExample 5.4.2.5. Here we describe an operad of relations, which we will denote by R.\nThe objects are sets, ObpRq \" ObpSetq. A morphism f : px1, x2, . . . , xnq YN x1 in R is\na diagram in Set of the form\nR\nf1\nw\nf2\n{\n\nfn\n\nf 1\n\nx1\nx2\n\nxn\nx1\n(5.18)\nsuch that the induced function R YN px1 ˆ x2 ˆ ˆ xn ˆ x1q is an injection.\nWe use a composition formula similar to that in Definition 2.5.2.3. Namely, we form\na fiber product\nFP\n\"\ny\ns\niPn Ri\nw\n$\nS\n}\n\ns\niPn\ns\njPmi xi,j\ns\niPn yi\nz\nOne can show that the induces function FP YN\ns\niPn\ns\njPmi xi\n\nˆ y is an injection, so\nwe have a valid composition formula. Finally, the associativity and identity laws hold.\nApplication 5.4.2.6. Suppose we are trying to model life in the following way. We define\nan entity as a set of phenomena, but in order to use colloquial language we say the entity\nis able to experience that set of phenomena. We also want to be able to put entities\ntogether to form a super-entity, so we have a notion of morphism f : pe1, . . . , enq YN e1\ndefined as a relation as in (5.18). The idea is that the morphism f is a way of translating\nbetween the phenomena that may be experienced by the sub-entities and the phenomena\nthat may be experienced by the super-entity.\nThe operad R from Example 5.4.2.5 becomes useful as a language for discussing issues\nin this domain.\n♦♦\nExample 5.4.2.7. Let R be the operad of relations from Example 5.4.2.5. Consider the\nalgebra S : R N Sets given by Spxq \" Ppxq. Given a morphism s\ni xi Ð R N y and\nsubsets x1\ni D xi, we have a subset s\ni x1\ni D s\ni xi. We take the fiber product\nFP\n/\n{\nR\n|\n\ns\ni x1\ni\n/ s\ni xi\ny\n17Technically we need to use isomorphism classes of cone points, but we don't worry about this here.\n\n5.4. OPERADS\nand the image of FP N y is a subset of y.\nApplication 5.4.2.8. Following Application 5.4.2.6 we can use Example 5.4.2.7 as a model\nof survival. Each entity survives only for a subset of the phenomena that it can expe-\nrience. Under this interpretation, the algebra from Example 5.4.2.7 defines survival as\nthe survival of all parts. That is, suppose that we understand how a super-entity is\ncomposed of sub-entities in the sense that we have a translation between the set of phe-\nnomena that may be experienced across the sub-entities and the set of phenomena that\nmay be experienced by the super-entity. Then the super-entity will survive exactly those\nphenomena which translate to phenomena for which each sub-entity desires.\nPerhaps a better term than survival would be \"allowance\". A bureaucracy consists of\na set of smaller bureaucracies, each of which allows certain phenomena to pass; the whole\nbureaucracy allows something to pass if and only if, when translated to the perspective\nof each sub-bureaucracy, it is allowed to pass there.\n♦♦\nExample 5.4.2.9. In this example we discuss wiring diagrams that look like this:\nE is composed of\nE1, E2, and E3\nin the following way:\nE\nE1\nE2\nE3\nThe operad in question will be denoted W; it is discussed in greater detail in [Sp4]. The\nobjects of W are pairs pC, sq where C is a finite set and v: C N ObpSetq is a function.\nThink of such an object as a circle with C-many cables sticking out of it; each cable c is\nassigned a set vpcq corresponding to the set of values that can be carried on that cable.\nFor example E2 \" pC, vq where |C| \" 11 and we consider v to be specified by declaring\nthat black wires carry Z and red wires carry tsweet, sour, salty, bitter, umamiu.\nThe morphisms in W will be pictures as above, formalized as follows. Given ob-\njects pC1, v1q, . . . , pCn, vnq, pD, wq, a morphism F : ppC1, v1q, . . . , pCn, vnqq YN pD, wq is\n\nCHAPTER 5. CATEGORIES AT WORK\na commutative diagram of sets 18\nU\niPn Ci\n\\ivi\n%\ni\n/ G\nx\n\nD\nj\no\nw\n{\nObpSetq\nsuch that i and j are jointly surjective.\nComposition of morphisms is easily understood in pictures: given wiring diagrams\ninside of wiring diagrams, we can throw away the intermediary circles. In terms of sets,\nwe perform a pushout.\nThere is an operad functor W N S given by sending pC, vq to s\ncPC vpcq. The idea is\nthat to an entity defined as having a bunch of cables carrying variables, a phenomenon is\nthe same thing as a choice of value on each cable. A wiring diagram translates between\nvalues experienced locally and values experienced globally.\nApplication 5.4.2.10. In cognitive neuroscience or in industrial economics, it may be that\nwe want to understand the behavior of an entity such as a mind, a society, or a business\nin terms of its structure. Knowing the connection pattern (connectome, supply chain) of\nsub-entities should help us understand how big changes are generated from small ones.\nUnder the functor W N S the algebra S N Sets from Application 5.4.2.8 becomes an\nalgebra W N Sets. To each entity we now associate some subset of the value-assignments\nit can carry.\n♦♦\nApplication 5.4.2.11. In [RS], Radul and Sussman discuss propagator networks. These\ncan presumably be understood in terms of wiring diagrams and their algebra of relations.\n♦♦\n18If one is concerned with cardinality issues, fix a cardinality κ and replace ObpSetq everywhere with\nObpSetaκq.\n\nIndex\na category\nCat, 126\nFLin, 115\nFin, 113, 160\nGrp, 113\nGrpd, 137\nGrph, 115\nMon, 113\nPrO, 113\nProp, 138\nSch, 165\nSet, 113\nStarn, 178\nTop, 136\nVect, 136, 225\n∆, 160, 191\nC-Set, 155\nsSet, 191\nGrIn, 132\nterminal, 127\na functor\nDisc: Set N Cat, 127, 150\nDisc: Set N Grph, 127\nInd: Set N Cat, 196\nCat N Grph, 127, 202\nCat N Sch, 166\nFLin N PrO, 121\nGrp N Cat, 129\nGrp N Grpd, 137\nGrp N Mon, 120\nGrpd N Cat, 137\nGrph N Cat, 126, 202\nGrph N PrO, 122\nGrph N Set, 122, 149, 202\nList: Set N Set, 142\nMon N Cat, 128\nMon N Set, 119, 199\nOb: Cat N Set, 127, 150, 202\nPaths: Grph N Grph, 125, 126, 148,\nΠ1 : Top N Grpd, 138\nPrO N Cat, 131, 132, 159, 171, 175\nPrO N Grph, 121, 132, 202\nPrO N Set, 122, 202\nPrO N Top, 231\nSch N Cat, 166\nSet N Mon, 123, 199\nSet N PrO, 202\nTop N PrOop, 136\nTop N Set, 136\nVectR N Grp, 136\nVectR N PrO, 137\nVectR N Top, 137\n∆N FLin, 160\na group\nE3, 81\nGL3, 81\nUp1q, 82\nΣX, 83\na monad\nPaths, 236\nexceptions, 236\nList, 234\nmaybe, 233\npartial functions, 233\na schema\nLoop, 170, 241\ndepartment store, 102\nindexing graphs, 156\na symbol\npF O Gq, 196\nX{ „, 48\nrns, 92\nFun, 150\nHomSet, 16\nHomC, 112\nN, 13\nOb, 112\nΩ, 59\nP, 58\n\nINDEX\nPath, 87\nR, 32\nZ, 13\nu, 72\n, 16, 112\ncolim, 186\n, 154\nH, 13\nD, 14, 203\nD!, 14\n@, 14, 203\nidX, 17\ns\n, 192\n-, 17\nY, 178\nlim, 184\n⌟, 39\nÞN, 15\nCop, 191\nC{X, 184\nCX{, 186\n``, 70\nZ, 179\n„, 48\n», 28, 159\n\\, 35\nˆ, 31\n⌜, 51\nf 1, 42\n:=, 14\na warning\n\"set\" of objects in a category, 112\ndifferent worldviews, 23\nmisuse of the, 180\nnotation for composition, 28\noperad functors, 249\noperads vs. multicategories, 245\noversimplified science, 9\naction\nleft, 72\nof a group, 82\nof a monoid, 72\norbit of, 83\nright, 72\naction table, 76\nadjoint functors, 199\nadjunct, 200\nadjunction, 200\nadjunction isomorphism, 200\nanalogy: babies and adults, 199\ncounit, 242\nunit, 242\nalgebra\noperad, 250\nan operad\nSets, 248\nlittle n-cubes, 248\nlittle squares, 248\nappropriate comparison, 77, 88, 97, 112,\narrow, 84\nBaez, John, 8\nbiological classification, 98\ncanonical, 18\ncardinality, 19\ncategory, 112\narithmetic of, 198\nas equivalent to schema, 163\ncartesian closed, 140\ncomma, 196\ncoslice, 186\ndiscrete, 127\nequivalence of, 159\nfree category, 126, 225\nKleisli, 236\nnon-example, 113, 114\nof elements, 192\nopposite, 191\npresentation, 134\nslice, 184\nsmall, 112\nunderlying graph of, 126\nCCCs, 140\ncharacteristic function, 60\ncoequalizer, 54\ncolimit, 186\ncommon ground, 231\ncommuting diagram, 20\ncomponent, 142\ncomposition\nclassical order, 28\ndiagrammatic order, 28\nof functions, 16\nof morphisms, 112\nconcatenation\nof lists, 70\nof paths, 88\n\nINDEX\ncone\nleft, 178\nright, 179\ncongruence, 104\ncontext, 233\ncoproduct\ninclusion functions, 35\ncoproducts, 172\nof sets, 35\nuniversal property of, 36\ncorrespondence\none-to-one, 17\ncoslice, 186\ncospan, 175\ncurrying, 54\nas adjunction, 202\nvia data migration functors, 207\ndata, 101\nvalid time, 232\ndata migration, 208\nleft pushforward Σ, 211\npullback ∆, 209\nright pushforward Π, 213\ndatabase\nbusiness rules, 102\ncategory of instances on, 155\nforeign key, 102\ninstance, 108, 135\nKleisli, 240\nprimary key, 102\nschema, 103, 105\ntables, 101\ndescent data, 228\ndiagam\ncommutes, 20\ndiagram, 176\nin Set, 20\nDolan, James, 8\ndynamical system\ncontinuous, 136\ndiscrete, 106\nEilenberg, Samuel, 7\nEnglishification, 29\nEnglishifiication, 109\nentry\nin list, 69\nepimorphism, 217\nin Set, 60\nequalizer, 47, 185\nequivalence relation, 48\nas partition, 48\nequivalence classes, 48\ngenerated, 49\nquotient by, 48\nexceptions, 236\nexponentials\nevaluation of, 55\nexponentials\nin Set, 55\nfiber product, 39\nfiber sum, 50\nfinite state machine, 74, 195\nfunction, 14\nbijection, 60\ncodomain, 14\ncomposition, 16\ndomain, 14\nequality of, 16\nidentity, 17\ninjection, 60\ninverse, 17\nisomorphism, 17\nsurjection, 60\nfunctor, 119\nadjoint, 200\nconstant, 205\ncontravariant, 190\ncovariant, 190\nfaithful, 162\nfull, 162\nrepresentable, 218\ngateway, 170\ngeography, 100, 226\ngraph, 84\nas functor, 132\nbipartite, 46\nchain, 86\nconverting to a preorder, 93\nfree category on, 126, 225\nhomomorphism, 88\npaths, 87\npaths-graph, 124, 236\nsymmetric, 133\ngraph homomorphism\nas functor, 156\nGrothendieck, 192\n\nINDEX\nconstruction, 191\nexpanding universes, 112\nin history, 8\ngroup, 80\naction, 82\nas category, 129\nhomomorphism of, 83\nof automorphisms, 130\ngroupoid, 137\nfundamental, 137\nof material states, 137\nhierarchy, 106\nhom-set, 112\niff, 50\nimage, 16\nin olog, 30\ninclusion functions, 35\nindexed set, 64, 65\nas functor, 156\nindexing category, 176\ninduced function, 34\ninfix notation, 68\ninformation theory, 141\ninitial object, 179\nin C-Set, 216\ninstance, 108, 135\nKleisli, 240\nisomorphism, 116\nof sets, 17\njoin, 95\nJoyal, Andr e, 8\nKan extension\nleft, 211\nright, 213\nKan, Daniel, 8\nKleisli category, 236\nlabeled null, 212\nLambek, Joachim, 8\nLawvere, William, 8\nleaf table, 210\nlimit, 184\nlinear order\nfinite, 92\nlist, 69, 234\nas functor, 124\nconcatenation, 70\nlocal-to-global, 7\nMac Lane, Saunders, 7\nMarkov chain, 241\nmaterials\nforce extension curves, 54\nforce-extension curves, 15\nmeet, 95\nMoggi, Eugenio, 8\nmonad, 232, 234\nformalizing context, 233\nKleisli category of, 236\non Grph, 236\non Set, 234\non arbitrary category, 243\nmonoid, 67\naction, 72\nadditive natural numbers, 68\nas category, 128\ncommutative, 69\ncyclic, 71\nfree, 70, 123\nhomomorphism, 77\nidentity element of, 68\ninitial, 181\ninverse of an element in, 80\nmultiplication formula, 68\nof endomorphisms, 130\nolog of, 74\npresented, 70\nterminal, 181\ntrivial, 69\ntrivial homomorphism, 78\nmonomorphism, 217\nin Set, 60\nmorphism, 112\ninverse, 116\nmulticategory, 245\nmultiset, 63\nnatural isomorphism, 152\nnatural transformation, 142\nas functor, 185\nas refinement of model, 146\nfor adding functionality, 153\nhorizontal composition of, 154\ninterchange, 154\nvertical composition of, 150\nwhiskering of, 154\n\nINDEX\nolog, 21\nas database schema, 107\naspects, 22\nfacts, 27\nfacts in English, 28\nimages, 30\ninvalid aspects, 23\npath in, 27\nrelational, 240\nrules, 22, 26, 105\nsheaf of, 231\ntypes, 21\nunderlying graph, 85\none-to-one correspondence, 17\nopen cover, 227\noperad\nalgebra of, 250\ncolored, 245\nmorphism of, 250\norbit, 83\nrotating earth, 82\norder, 91\nlinear order, 91\nmorphism, 97\nopposite, 97\npartial order, 91\npreorder, 91\ntree, 96\npartial function, 233\npartial functions, 233\npath, 87\nPED, 104\npermutation, 81\npower set, 58\nas poset, 94\npreimage, 42, 203\npreorder\nas category, 130\nclique in, 94\nconverting to graph, 93\ndiscrete, 98\ngenerated, 94\nindiscrete, 98\njoin, 95\nmeet, 95\npresheaf, 226\nproduct\nas grid, 31\nprojection functions, 31\nproducts, 168, 170, 182\nas not always existing, 171\nof sets, 31\nuniversal property of, 32\nprojection functions, 31\npullback, 184\nof sets, 39\npushout, 186\nof topological spaces, 189\nRDF, 192\nas category of elements, 193\nrelation\nbinary, 90\nequivalence, 48\ngraph of, 90\nrelative set, 64\nas slice category, 186\nrepresentable functor, 218\nrepresentation theory, 225\nrestriction of scalars, 79\nretraction, 54\nRNA transcription, 17\nschema, 105\nas category presentation, 134\nas equivalent to category, 163\nas syntax, 134\ncongruence, 104\nfact table, 209\nleaf table, 103, 209\nmorphism, 164\nof a database, 103\nPath equivalence declaration (PED),\nschematically implied reference spread, 219\nsecurity, 99\nset, 13\narithmetic of, 56\nLawvere's description of, 140\npermutation of, 81\nset builder notation, 14\nsheaf\ncondition, 228\ndescent data, 228\nglueing, 228\nsheaves, 226\nsimplex, 58\nsimplicial complex, 58, 231\n\nINDEX\nsimplicial set, 191\nskeleton, 161\nSkolem, 219\nSkolem variable, 212\nslice, 184\nspace, 99, 135\ntopological, 135\nspace group, 81\nspan, 45\ncomposite, 45\nsubcategory\nfull, 115, 195\nsubobject classifier\nin C-Set, 222\nin Set, 59\nsubset, 13\nas function, 15\ncharacteristic function of, 60\nsubway, 189\nsymmetry, 81\nterminal object, 179\nin C-Set, 216\nin Set, 47\ntopological space, 136\ntopology, 135\ntopos, 222\ntree, 96\nroot, 96\ntrivial homomorphism\nof monoids, 78\nuniversal property, 170\nproducts, 32\npullback, 184\nvector field, 116, 138\nconservative, 138\nvector space, 136, 225\nvertex, 84\nwiring diagram, 254\nYoneda's lemma, 220\n\nBibliography\n[Ati]\nAtiyah, M. (1989) \"Topological quantum field theories\". Publications\nMath ematiques de l'IH ES 68 (68), pp. 175-186.\n[Axl]\nAxler, S. (1997) Linear algebra done right. Springer.\n[Awo]\nS. Awodey. (2010) Category theory. Second edition. Oxford Logic Guides, 52.\nOxford University Press, Oxford.\n[Bar]\nBralow, H. (1961) \"Possible principles underlying the transformation of\nsensory messages\". Sensory communication, pp. 217 - 234.\n[BD]\nBaez, J.C.; Dolan, J. (1995) \"Higher-dimensional algebra and topological\nquantum field theory\". Journal of mathematical physics vol 36, 6073.\n[BFL]\nBaez, J.C.; Fritz, T.; Leinster, T. (2011) \"A characterization of entropy in\nterms of information loss.\" Entropy 13, no. 11.\n[BS]\nBaez, J.C.; Stay, M. (2011) \"Physics, topology, logic and computation: a\nRosetta Stone.\" New structures for physics, 95Ð172. Lecture Notes in Phys.,\n813, Springer, Heidelberg.\n[BP1]\nBrown, R.; Porter, T. (2006) \"Category Theory: an abstract setting for\nanalogy and comparison, In: What is Category Theory? Advanced Studies in\nMathematics and Logic, Polimetrica Publisher, Italy, pp. 257-274.\n[BP2]\nBrown, R.; Porter, T. (2003) \"Category theory and higher dimensional\nalgebra: potential descriptive tools in neuroscience\", Proceedings of the\nInternational Conference on Theoretical Neurobiology, Delhi, edited by\nNandini Singh, National Brain Research Centre, Conference Proceedings 1\n80-92.\n[BW]\nM. Barr, C. Wells. (1990) Category theory for computing science. Prentice\nHall International Series in Computer Science. Prentice Hall International,\nNew York.\n[Big]\nBiggs, N.M. (2004) Discrete mathematics. Oxford University Press, NY.\n[Dia]\nDiaconescu, R. (2008) Institution-independent model theory Springer.\n[DI]\nD oring, A.; Isham, C. J. \"A topos foundation for theories of physics. I.\nFormal languages for physics.\" J. Math. Phys. 49 (2008), no. 5, 053515.\n\nBIBLIOGRAPHY\n[EV]\nEhresmann, A.C.; Vanbremeersch, J.P. (2007) Memory evolutive systems;\nhierarchy, emergence, cognition. Elsevier.\n[Eve]\nEverett III, H. (1973). \"The theory of the universal wave function.\" In The\nmany-worlds interpretation of quantum mechanics (Vol. 1, p. 3).\n[Gog]\nGoguen, J. (1992) \"Sheaf semantics for concurrent interacting objects\"\nMathematical structures in Computer Science Vol 2, pp. 159 - 191.\n[Gro]\nGrothendieck, A. (1971). S eminaire de G eom etrie Alg ebrique du Bois Marie -\n1960-61 - Revˆetements etales et groupe fondamental - (SGA 1) (Lecture notes\nin mathematics 224) (in French). Berlin; New York: Springer-Verlag.\n[Kro]\nKr omer, R. (2007). Tool and Object: A History and Philosophy of Category\nTheory, Birkhauser.\n[Lam]\nLambek, J. (1980) \"From λ-calculus to Cartesian closed categories\". In\nFormalism, Academic Press, London, pp. 375 - 402.\n[Law]\nLawvere, F.W. (2005) \"An elementary theory of the category of sets (long\nversion) with commentary.\" (Reprinted and expanded from Proc. Nat. Acad.\nSci. U.S.A. 52 (1964)) Repr. Theory Appl. Categ. 11, pp. 1 - 35.\n[Kho]\nKhovanov, M. (2000) \"A categorificiation of the Jones polynomial\" Duke\nMath J..\n[Le1]\nLeinster, T. (2004) Higher Operads, Higher Categories. London Mathematical\nSociety Lecture Note Series 298, Cambridge University Press.\n[Le2]\nLeinster, T. (2012) \"Rethinking set theory\". ePrint available\nhttp://arxiv.org/abs/1212.6543.\n[Lin]\nLinsker, R. (1988) \"Self-organization in a perceptual network\". Computer 21,\nno. 3, pp. 105 - 117.\n[LM]\nLandry, E.; Marquis, J-P., 2005, \"Categories in Contexts: historical,\nfoundational, and philosophical.\" Philosophia Mathematica, (3), vol. 13, no. 1,\n1 - 43.\n[LS]\nF.W. Lawvere, S.H. Schanuel. (2009) Conceptual mathematics. A first\nintroduction to categories. Second edition. Cambridge University Press,\nCambridge.\n[MacK]\nMacKay, D.J. (2003). Information theory, inference and learning algorithms.\nCambridge university press.\n[Mac]\nMac Lane, S. (1998) Categories for the working mathematician. Second\nedition. Graduate Texts in Mathematics, 5. Springer-Verlag, New York.\n[Mar1]\nMarquis, J-P. (2009) From a Geometrical Point of View: a study in the\nhistory and philosophy of category theory, Springer.\n[Mar2]\nMarquis, J-P, \"Category Theory\", The Stanford Encyclopedia of Philosophy\n(Spring 2011 Edition), Edward N. Zalta (ed.), http:\n//plato.stanford.edu/archives/spr2011/entries/category-theory\n\nBIBLIOGRAPHY\n[Min]\nMinsky, M. The Society of Mind. Simon and Schuster, NY 1985.\n[Mog]\nMoggi, E. (1989) \"A category-theoretic account of program modules.\"\nCategory theory and computer science (Manchester, 1989), 101Ð117, Lecture\nNotes in Comput. Sci., 389, Springer, Berlin.\n[nLa]\nnLab authors. http://ncatlab.org/nlab/show/HomePage\n[Pen]\nPenrose, R. (2006) The road to reality. Random house.\n[RS]\nRadul, A.; Sussman, G.J. (2009). \"The art of the propagator\". MIT Computer\nscience and artificial intelligence laboratory technical report.\n[Sp1]\nSpivak, D.I. (2012) \"Functorial data migration\". Information and\ncommunication\n[Sp2]\nSpivak, D.I. (2012) \"Queries and constraints via lifting problems\". Submitted\nto Mathematical structures in computer science. ePrint available:\nhttp://arxiv.org/abs/1202.2591\n[Sp3]\nSpivak, D.I. (2012) \"Kleisli database instances\". ePrint available:\nhttp://arxiv.org/abs/1209.1011\n[Sp4]\nSpivak, D.I. (2013) \"The operad of wiring diagrams: Formalizing a graphical\nlanguage for databases, recursion, and plug-and-play circuits\". Available\nonline: http://arxiv.org/abs/1305.0297\n[SGWB] Spivak D.I., Giesa T., Wood E., Buehler M.J. (2011) \"Category Theoretic\nAnalysis of Hierarchical Protein Materials and Social Networks.\" PLoS ONE\n6(9): e23911. doi:10.1371/journal.pone.0023911\n[SK]\nSpivak, D.I., Kent, R.E. (2012) \"Ologs: A Categorical Framework for\nKnowledge Representation.\" PLoS ONE 7(1): e24274.\ndoi:10.1371/journal.pone.0024274.\n[WeS]\nWeinberger, S. (2011) \"What is... Persistent Homology?\" AMS.\n[WeA]\nWeinstein, A. (1996) \"Groupoids: unifying internal and external symmetry.\nNotices of the AMS Vol 43, no. 7, pp. 744 - 752.\n[Wik]\nWikipedia (multiple authors). Various articles, all linked with a\nhyperreference are scattered throughout this text. All accessed December 6,\n2012 - September 17, 2013.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996 Category Theory for Scientists\nSpring 2013\n\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Textbook: Basic Category Theory",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/b84f9d8840db0c745c75ab23c89851bb_MIT18_S996S13_chapter4.pdf",
      "content": "Chapter 4\nBasic category theory\n\"...We know only a very few--and, therefore, very precious--schemes whose unifying\npowers cross many realms.\" - Marvin Minsky.1\nCategories, or an equivalent notion, have already been secretly introduced as ologs.\nOne can think of a category as a graph (as in Section 3.3) in which certain paths have\nbeen declared equivalent. (Ologs demand an extra requirement that everything in sight\nbe readable in natural language, and this cannot be part of the mathematical definition\nof category.)\nThe formal definition of category is given in Definition 4.1.1.1, but it\nwill not be obviously the same as the \"graph+path equivalences\" notion; the latter was\ngiven in Definition 3.5.2.6 as the definition of a schema. Once we talk about how different\ncategories can be compared using functors (Definition 4.1.2.1), and how different schemas\ncan be compared using schema mappings (Definition 4.4.1.2), we will prove that the two\nnotions are equivalent (Theorem 4.4.2.3).\n4.1\nCategories and Functors\nIn this section we give the standard definition of categories and functors. These, together\nwith natural transformations (Section 4.3), form the backbone of category theory. We\nalso give some examples.\n4.1.1\nCategories\nIn everyday speech we think of a category as a kind of thing. A category consists of a\ncollection of things, all of which are related in some way. In mathematics, a category\ncan also be construed as a collection of things and a type of relationship between pairs\nof such things. For this kind of thing-relationship duo to count as a category, we need to\ncheck two rules, which have the following flavor: every thing must be related to itself by\nsimply being itself, and if one thing is related to another and the second is related to a\nthird, then the first is related to the third. In a category, the \"things\" are called objects\nand the \"relationships\" are called morphisms.\nIn various places throughout this book so far we have discussed things of various\nsorts, e.g. sets, monoids, graphs. In each case we discussed how such things should be\n1[Min, Problems of disunity, p. 126].\n\nCHAPTER 4. BASIC CATEGORY THEORY\nappropriately compared. In each case the \"things\" will stand as the objects and the\n\"appropriate comparisons\" will stand as the morphisms in the category.\nHere is the\ndefinition.\nDefinition 4.1.1.1. A category C is defined as follows: One announces some constituents\n(A. objects, B. morphisms, C. identities, D. compositions) and asserts that they conform\nto some laws (1. identity law, 2. associativity law). Specifically, one announces:\nA. a collection ObpCq, elements of which are called objects;\nB. for every pair x, y P ObpCq, a set HomCpx, yq P Set. It is called the hom-set\nfrom x to y; its elements are called morphisms from x to y; 2\nC. for every object x P ObpCq, a specified morphism denoted idx P HomCpx, xq\ncalled the identity morphism on x; and\nD. for every three objects x, y, z P ObpCq, a function\n: HomCpy, zq ˆ HomCpx, yq N HomCpx, zq,\ncalled the composition formula.\nGiven objects x, y P ObpCq, we can denote a morphism f P HomCpx, yq by f : x N y; we\nsay that x is the domain of f and that y is the codomain of f. Given also g: y N z,\nthe composition formula is written using infix notation, so g f : x N z means pg, fq P\nHomCpx, zq.\nOne asserts that the following law holds:\n1. for every x, y P ObpCq and every morphism f : x N y, we have\nf idx \" f\nand\nidy f \" f;\nand;\n2. if w, x, y, z P ObpCq are any objects and f : w N x,\ng: x N y,\nand h: y N z\nare any morphisms, then the two ways to compose are the same:\nph gq f \" h pg fq P HomCpw, zq.\nRemark 4.1.1.2. There is perhaps much that is unfamiliar about Definition 4.1.1.1 but\nthere is also one thing that is strange about it. The objects ObpCq of C are said to\nbe a \"collection\" rather than a set. This is because we sometimes want to talk about\nthe category of all sets, in which every possible set is an objects, and if we try to say\nthat the collection of sets is itself, we run into Russell's paradox. Modeling this was\na sticking point in the foundations of category theory, but it was eventually fixed by\nGrothendieck's notion of expanding universes. Roughly the idea is to choose some huge\nset κ (with certain properties making it a universe), to work entirely inside of it when\npossible, and to call anything in that world κ-small (or just small if κ is clear from\ncontext). When we need to look at κ itself, we choose an even bigger universe κ1 and\nwork entirely within it.\nA category in which the collection ObpCq is a set (or in the above language, a small\nset) is called a small category. From here on out we will not take care of the difference,\nreferring to ObpCq as a set. We do not think this will do any harm to scientists using\ncategory theory, at least not in the beginning phases of their learning.\n2The reason for the notation Hom and the word hom-set is that morphisms are often called homo-\nmorphisms, e.g. in group theory.\n\n4.1. CATEGORIES AND FUNCTORS\nExample 4.1.1.3 (The category Set of sets). Chapter 2 was all about the category of sets,\ndenoted Set. The objects are the sets and the morphisms are the functions; we even\nused the current notation, referring to the set of functions X N Y as HomSetpX, Y q.\nThe composition formula is given by function composition, and for every set X, the\nidentity function idX : X N X serves as the identity morphism for X P ObpSetq. The\ntwo laws clearly hold, so Set is indeed a category.\nExample 4.1.1.4 (The category Fin of finite sets). Inside the category Set is a subcategory\nFin D Set, called the category of finite sets. Whereas an object S P ObpSetq is a set\nthat can have arbitrary cardinality, we define Fin such that its objects include all (and\nonly) the sets S with finitely many elements, i.e. |S| \" n for some natural number n P N.\nEvery object of Fin is an object of Set, but not vice versa.\nAlthough Fin and Set have a different collection of objects, their morphisms are in\nsome sense \"the same\". For any two finite sets S, S1 P ObpFinq, we can also think of\nS, S1 P ObpSetq, and we have\nHomFinpS, S1q \" HomSetpS, S1q.\nThat is a morphism in Fin between finite sets S and S1 is simply a function f : S N S1.\nExample 4.1.1.5 (The category Mon of monoids). We defined monoids in Definition\n3.1.1.1 and monoid homomorphisms in Definition 3.1.4.1. Every monoid M :\" pM, e, ‹Mq\nhas an identity homomorphism idM : M N M, given by the identity function idM : M N\nM. To compose two monoid homomorphisms f : M N M1 and g: M1 N M2, we com-\npose their underlying functions f : M N M 1 and g: M 1 N M 2, and check that the result\ng f is a monoid homomorphism. Indeed,\ng fpeq \" gpe1q \" e2\ng fpm1 ‹M m2q \" gpfpm1q ‹M 1 fpm2qq \" g fpm1q ‹M 2 g fpm2q.\nIt is clear that the two laws hold, so Mon is a category.\nExercise 4.1.1.6 (The category Grp of groups). Suppose we set out to define a category\nGrp, having groups as objects and group homomorphisms as morphisms, see Definition\n3.2.1.16. Show (to the level of detail of Example 4.1.1.5) that the rest of the conditions\nfor Grp to be a category are satisfied.\n♦\nExercise 4.1.1.7 (The category PrO of preorders). Suppose we set out to define a cate-\ngory PrO, having preorders as objects and preorder homomorphisms as morphisms (see\nDefinition 3.4.4.1). Show (to the level of detail of Example 4.1.1.5 that the rest of the\nconditions for PrO to be a category are satisfied.\n♦\nExample 4.1.1.8 (Non-category 1). So what's not a category? Two things can go wrong:\neither one fails to specify all the relevant constituents (A, B, C, D from Definition 4.1.1.1,\nor the constituents do not obey the laws (1, 2).\nLet G be the following graph,\nG \"\na‚\nf\n/ b‚\ng\n/ c‚ .\nSuppose we try to define a category G by faithfully recording vertices as objects and\narrows as morphisms. Will that be a category?\n\nCHAPTER 4. BASIC CATEGORY THEORY\nFollowing that scheme, we put ObpGq \" ta, b, cu. For all 9 pairs of objects we need a\nhom-set. Say\nHomGpa, aq \" H\nHomGpa, bq \" tfu\nHomGpa, cq \" H\nHomGpb, aq \" H\nHomGpb, bq \" H\nHomGpb, cq \" tgu\nHomGpc, aq \" H\nHomGpc, bq \" H\nHomGpc, cq \" H\nIf we say we are done, the listener should object that we have given neither identities\nnor a composition formula. In fact, it is impossible to give identities under our scheme,\nbecause e.g. HomGpa, aq \" H.\nSuppose we fix that problem, adding an element to each of our \"diagonals\" so that\nHomGpa, aq \" tidau,\nHomGpb, bq \" tidbu,\nand\nHomGpc, cq \" tidcu.\nWhat about a composition formula? We need a function HomGpa, bq ˆ HomGpb, cq N\nHomGpa, cq, but the domain is nonempty and the codomain is empty; there is no such\nfunction.\nAgain, we must make a change, adding an element to make\nHomGpa, cq \" thu.\nWe would now say g f \" h. Finally, this does the trick and we have a category. A\ncomputer could check this quickly, as can someone with good intuition for categories;\nfor everyone else, it may be a painstaking process involving determining whether there\nis a unique composition formula for each of the 27 pairs of hom-sets and whether the\nassociative law holds in the 81 necessary cases. Luckily this computation is \"sparse\"\n(lots of H's), so it's not as bad as it first seems.\nRedrawing all the morphisms as arrows, our graph has become:\nG \"\na‚\nida\n:\nf\n/\nh\nb‚\nidb\n\ng\n/ c‚\nidc\nd\nExample 4.1.1.9 (Non-category 2). In this example, we will make a faux-category F with\none object and many morphisms. The problem here will be our composition formula.\nDefine F to have one object ObpFq \" t,u, and HomFp,, ,q \" N. Define id, \" 1 P\nN. Define the composition formula : N ˆ N N N by m n \" mn. This is a perfectly\ncromulent function, but it does not work right as a composition formula. Indeed, for the\nidentity law to hold, we would need m1 \" m \" 1m, and one side of this is false. For the\nassociativity law to hold, we would need pmnqp \" mpnpq, but this is also not the case.\nTo fix this problem we have to completely revamp our composition formula. It would\nwork to use multiplication, m n \" m n. Then the identity law would read 1 m \"\nm \" m 1, and that holds; and the associativity law would read pm nq p \" m pn pq,\nand that holds.\nExample 4.1.1.10 (The category of preorders with joins). Suppose that we are only\ninterested in preorders pX, dq for which every pair of elements has a join. We saw in\nExercise 3.4.2.3 that not all preorders have this property.\nHowever we can create a\ncategory C in which every object does have this property. To begin we put ObpCq \"\ntpX, dq P ObpPrOq | pX, dq has all joinsu. But what about morphisms?\n\n4.1. CATEGORIES AND FUNCTORS\nOne option would be to put in no morphisms (other than identities), and to just\nconsider this collection of objects as having no structure other than a set.\nAnother option would be to put in exactly the same morphisms as in PrO: for any\nobjects a, b P ObpCq we consider a and b as regular old preorders, and put HomCpa, bq :\"\nHomPrOpa, bq. The resulting category of preorders with joins is called the full subcategory\nof PrO spanned by the preorders with joins.3\nA third option, and the one perhaps that would jump out to a category theorist, is\nto take the choice about how we define our objects as a clue to how we should define\nour morphisms. Namely, if we are so interested in joins, perhaps we want joins to be\npreserved under morphisms. That is, if f : pX, dXq N pY, dY q is a morphism of preorders\nthen for any join w \" x _ x1 in X we might want to enforce that fpwq \" fpxq _ fpx1q in\nY . Thus a third possibility for the morphisms of C would be\nHomCpa, bq :\" tf P HomPrOpa, bq | f preserves joinsu.\nOne can check easily that the identity morphisms preserve joins and that compositions of\njoin-preserving morphisms are join-preserving, so this version of homomorphisms makes\nfor a well-defined category.\nExample 4.1.1.11 (Category FLin of finite linear orders). We have a category PrO of\npreorders, and some of its objects are finite (nonempty) linear orders.\nLet FLin be\nthe full subcategory of PrO spanned by the linear orders. That is, following Definition\n3.4.4.1, given linear orders X, Y , every morphism of preorders X N Y counts as a\nmorphism in FLin:\nHomFLinpX, Y q \" HomPrOpX, Y q.\nExercise 4.1.1.12. Let FLin be the category of finite linear orders, defined in Example\n4.1.1.11. For n P N, let rns be the linear order defined in Example 3.4.1.7. What are the\ncardinalities of the following sets:\na.) HomFLinpr0s, r3sq;\nb.) HomFLinpr3s, r0sq;\nc.) HomFLinpr2s, r3sq;\nd.) HomFLinpr1s, rnsq?\ne.) (Challenge) HomFLinprms, rnsq?\nIt turns out that the category FLin of linear orders is sufficiently rich that much of al-\ngebraic topology (the study of arbitrary spaces, such as Mobius strips and 7-dimensional\nspheres) can be understood in its terms. See Example 4.6.1.6.\n♦\nExample 4.1.1.13 (Category of graphs). We defined graphs in Definition 3.3.1.1 and\ngraph homomorphisms in Definition 3.3.3.1. To see that these are sufficient to form a\ncategory is considered routine to a seasoned category-theorist, so let's see why.\nSince a morphism from G \" pV, A, src, tgtq to G1 \" pV 1, A1, src1, tgt1q involves two\nfunctions f0 : V N V 1 and f1 : A N A1, the identity and composition formulas will\nsimply arise from the identity and composition formulas for sets.\nAssociativity will\nfollow similarly. The only thing that needs to be checked, really, is that the composition\nof two such things, each satisfying (3.6), will itself satisfy (3.6). Just for completeness,\nwe check that now.\n3The definition of full subcategories will be given as Definition 4.6.3.1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nSuppose that f \" pf0, f1q: G N G1 and g \" pg0, g1q: G1 N G2 are graph homomor-\nphisms, where G2 \" pV 2, A2, src2, tgt2q. Then in each diagram below\nA\nf1\n/\nsrc\n\nA1\ng1\n/\nsrc1\n\nA2\nsrc2\n\nV\nf0\n/ V 1\ng0\n/ V 2\nA\nf1\n/\ntgt\n\nA1\ntgt1\n\ng1\n/ A2\ntgt2\n\nV\nf0\n/ V 1\ng0\n/ V 2\n(4.1)\nthe left-hand square commutes because f is a graph homomorphism and the right-hand\nsquare commutes because g is a graph homomorphism. Thus the whole rectangle com-\nmutes, meaning that g f is a graph homomorphism, as desired.\nWe denote the category of graphs and graph homomorphisms by Grph.\nRemark 4.1.1.14. When one is struggling to understand basic definitions, notation, and\nstyle, a phase which naturally occurs when learning new mathematics (or any new lan-\nguage), the above example will probably appear long and tiring. I'd say you've mastered\nthe basics when the above example really does feel straightforward. Around this time,\nI imagine you'll begin to get a sense of the remarkable organisational potential of the\ncategorical way of thinking.\nExercise 4.1.1.15. Let F be a vector field on R2. Recall that for two points x, x1 P R2,\nany curve C with endpoints x and x1, and any parameterization r: ra, bs N C, the line\nintegral\ns\nC Fprq dr returns a real number. It does not depend on r, except its orientation\n(direction). Therefore, if we think of C has having an orientation, say going from x to\nx1, then\ns\nC F is a well-defined real number. If C goes from x to x1, let's suggestively\nwrite C : x N x1. Define an equivalence relation „ on the set of oriented curves in R2 by\nsaying C „ C1 if\n- C and C1 start at the same point,\n- C and C1 end at the same point, and\n-\ns\nC F \"\ns\nC1 F.\nSuppose we try to make a category CF as follows. Put ObpCF q \" R2, and for every\npair of points x, x1 P R2, let HomCF px, x1q \" tC : x N x1u{ „, where C : x N x1 is an\noriented curve and „ means \"same line integral\", as explained above.\nIs there an identity morphism and a composition formula that will make CF into a\ncategory?\n♦\n4.1.1.16\nIsomorphisms\nIn any category we have a notion of isomorphism between objects.\nDefinition 4.1.1.17. Let C be a category and let X, Y P ObpCq be objects. An isomor-\nphism f from X to Y is a morphism f : X N Y in C, such that there exists a morphism\ng: Y N X in C such that\ng f \" idX\nand\nf g \" idY .\nIn this case we say that the morphism f is invertible and that g is the inverse of f. We\nmay also say that the objects X and Y are isomorphic.\n\n4.1. CATEGORIES AND FUNCTORS\nExample 4.1.1.18. If C \" Set is the category of sets, then the above definition coincides\nprecisely with the one given in Definition 2.1.2.8.\nExercise 4.1.1.19. Suppose that G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q are\ngraphs and that f \" pf0, f1q: G N G1 is a graph homomorphism (as in Definition\n3.3.3.1).\na.) If f is an isomorphism in Grph, does this imply that f0 : V N V 1 and f1 : A N A1\nare isomorphisms in Set?\nb.) If so, why; and if not, show a counterexample (where f is an isomorphism but either\nf0 or f1 is not).\n♦\nExercise 4.1.1.20. Suppose that G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q are\ngraphs and that f \" pf0, f1q: G N G1 is a graph homomorphism (as in Definition\n3.3.3.1).\na.) If f0 : V N V 1 and f1 : A N A1 are isomorphisms in Set, does this imply that f is\nan isomorphism in Grph?\nb.) If so, why; and if not, show a counterexample (where f0 and f1 are isomorphisms\nbut f is not).\n♦\nLemma 4.1.1.21. Let C be a category and let „ be the relation on ObpCq given by saying\nX „ Y iffX and Y are isomorphic. Then „ is an equivalence relation.\nProof. The proof of Lemma 2.1.2.12 can be mimicked in this more general setting.\n□\n4.1.1.22\nAnother viewpoint on categories\nHere is an alternate definition of category, using the work we did in Chapter 2.\nExercise 4.1.1.23. Suppose we begin our definition of category as follows.\nA category, C consists of a sequence pObpCq, HomC, dom, cod, ids, q, where\n1. ObpCq is a set,4\n2. HomC is a set, and dom, cod: HomC N ObpCq are functions,\n3. ids: ObpCq N HomC is a function, and\n4See Remark 4.1.1.2.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4. is a function as depicted in the commutative diagram below\nHomC\ncod\n)\ndom\n\"\nHomC ˆObpCq HomC\n✓\n✓\n\nh\n/\n\n⌟\nHomC\ncod /\ndom\n\nObpCq\nHomC\ncod\n/\ndom\n\nObpCq\nObpCq\n(4.2)\na.) Express the fact that for any x P ObpCq the morphism idx points from x to x in\nterms of the functions id, dom, cod.\nb.) Express the condition that composing a morphism f with an appropriate identity\nmorphism yields f.\nc.) Express the associativity law in these terms (Hint: Proposition 2.5.1.17 may be\nuseful).\n♦\nExample 4.1.1.24 (Partial olog for a category). Below is an olog that captures some of\nthe essential structures of a category.\na morphism\nin C\nhas as codomain\n)\nhas as domain\n\na pair pg, fq\nof composable\nmorphisms\n✓\n✓\nhas as composition\nd\nyields\nas g\n/\nyields as f\n\n⌟\na morphism\nin C\nhas as\ncodomain\n/\nhas as domain\n\nan object of C\na morphism\nin C\nhas as\ncodomain\n/\nhas as domain\n\nan object of C\nan object of C\n(4.3)\nMissing from (4.3) is the notion of identity morphism (as an arrow from ⌜an object\nof C⌝to ⌜a morphism in C⌝) and the associated path equivalences, as well as the identity\n\n4.1. CATEGORIES AND FUNCTORS\nand associativity laws. All of these can be added to the olog, at the expense of some\nclutter.\nRemark 4.1.1.25. Perhaps it is already clear that category theory is very interconnected.\nIt may feel like everything relates to everything, and this feeling may intensify as you\ngo on. However, the relationships between different notions are rigorously defined, and\nnot random. Moreover, almost everything presented in this book can be formalized in\na proof system like Coq (the most obvious exceptions being things like the readability\nrequirement of ologs and the modeling of scientific applications).\nWhenever you feel cognitive vertigo, look to formal definitions as the ground of your\nunderstanding.\nIt is good practice to make sure that the intuition you've developed\nactually \"touches down\" on that ground, i.e. that your way of thinking can be built up\nsolidly from the foundational definitions.\n4.1.2\nFunctors\nA category C \" pObpCq, HomC, dom, cod, ids, q, involves a set of objects, a set of mor-\nphisms, a notion of domains and codomains, a notion of identity morphisms, and a\ncomposition formula. For two categories to be comparable, these various components\nshould be appropriately comparable.\nDefinition 4.1.2.1. Let C and C1 be categories. A functor F from C to C1, denoted\nF : C N C1, is defined as follows: One announces some constituents (A. on-objects part,\nB. on-morphisms part) and asserts that they conform to some laws (1. preservation of\nidentities, 2. preservation of composition). Specifically, one announces\nA. a function ObpFq: ObpCq N ObpC1q, which we sometimes denote simply by\nF : ObpCq N ObpC1q; and\nB. for every pair of objects c, d P ObpCq, a function\nHomF pc, dq: HomCpc, dq N HomC1pFpcq, Fpdqq,\nwhich we sometimes denote simply by F : HomCpc, dq N HomC1pFpcq, Fpdqq.\nOne asserts that the following laws hold:\n1. Identities are preserved by F.\nThat is, for any object c P ObpCq, we have\nFpidcq \" idF pcq; and\n2. Composition is preserved by F.\nThat is, for any objects b, c, d P ObpCq and\nmorphisms g: b N c and h: c N d, we have Fph gq \" Fphq Fpgq.\nExample 4.1.2.2 (Monoids have underlying sets). Recall from Definition 3.1.1.1 that if\nM \" pM, e, ‹q is a monoid, then M is a set. And recall from Definition 3.1.4.1 that if\nf : M N M1 is a monoid homomorphism then f : M N M 1 is a function. Thus we have\na functor\nU : Mon N Set\nthat takes every monoid to its underlying set and every monoid homomorphism to its\nunderlying function.\nGiven two monoids M \" pM, e, ‹q and M1 \" pM 1, e1, ‹1q, there may be many func-\ntions from M to M 1 that do not arise from monoid homomorphisms. It is often useful to\nspeak of such functions. For example, one could assign to every command in one video\n\nCHAPTER 4. BASIC CATEGORY THEORY\ngame V a command in another video game V 1, but this may not work in the \"monoidy\nway\" when performing a sequence of commands. By being able to speak of M as a set,\nor as M as a monoid, and understanding the relationship U between them, we can be\nclear about where we stand at all times in our discussion.\nExample 4.1.2.3 (Groups have underlying monoids). Recall that a group is just a monoid\npM, e, ‹q with the extra property that every element m P M has an inverse m1 ‹ m \" e \"\nm ‹ m1. Thus to every group we can assign its underlying monoid. Similarly, a group\nhomomorphism is just a monoid homomorphism of its underlying monoids. This means\nthat there is a functor\nU : Grp N Mon\nthat sends every group or group homomorphism to its underlying monoid or monoid\nhomomorphism. That identity and composition are preserved is obvious.\nSlogan 4.1.2.4.\n\" Out of all our available actions, some are reversable. \"\nApplication 4.1.2.5. Suppose you're a scientist working with symmetries. But then sup-\npose that the symmetry breaks somewhere, or you add some extra observable which is\nnot reversible under the symmetry. You want to seamlessly relax the requirement that\nevery action be reversible without changing anything else. You want to know where you\ncan go, or what's allowed. The answer is to simply pass from the category of groups (or\ngroup actions) to the category of monoids (or monoid actions).\nWe can also reverse this change of perspective. Recall that in Example 3.1.2.9 we\ndiscussed a monoid M controlling the actions of a video game character. The character\nposition (P) could be moved up (u), moved down (d), or moved right (r). The path\nequivalences P.u.d \" P and P.d.u \" P imply that these two actions are mutually\ninverse, whereas moving right has no inverse.\nThis, plus equivalences P.r.u \" P.u.r\nand P.r.d \" P.d.r, defined a monoid M.\nInside M is a submonoid G, which includes just upward and downward movement.\nIt has one object, just like M, i.e. ObpMq \" tPu \" ObpGq. But it has fewer morphisms.\nIn fact there is a monoid isomorphism G - Z because we can assign to any movement in\nG the number of ups, e.g. P.u.u.u.u.u is assigned the integer 5, P.d.d.d is assigned the\ninteger 3, and P.d.u.u.d.d.u is assigned the integer 0 P Z. But Z is a group, because\nevery integer has an inverse.\nThus we can consider G as a group G1 P ObpGrpq or as a monoid G2 P ObpMonq.\nIt is better to consider G as a group, because groups are more structured than monoids.\nIt's as though putting G in Grp gives it more \"potential energy\" than putting it in Mon\n-- we can always \"drop it down\" from Grp to Mon, but not vice versa. The way to\nmake this precise is that we can make use of the functor U : Grp N Mon from Example\n4.1.2.3 and find that UpG1q \" G2. But to find a functor F : Mon N Grp such that\nFpG2q \" G1 would be much more ad hoc.\nThe upshot is that we can use functors to compare groups and monoids.\n♦♦\nExample 4.1.2.6. Recall that we have a category Set of sets and a category Fin of\nfinite sets. We said that Fin was a subcategory of Set. In fact we can think of this\n\"subcategory\" relationship in terms of functors, just like we thought of the \"subset\"\nrelationship in terms of functions in Example 2.1.2.3.\nThat is, if we have a subset\n\n4.1. CATEGORIES AND FUNCTORS\nS D S1, then every element s P S is an element of S1, so we make a function f : S N S1\nsuch that fpsq \" s P S1.\nTo give a functor i: Fin N Set, we have to announce how it will work on objects\nand how it will work on morphisms. We begin by announcing a function i: ObpFinq N\nObpSetq. But that's easy because ObpFinq D ObpSetq, so we proceed as above: ipSq \" S\nfor any S P ObpFinq. We also have announce, for each pair of objects S, S1 P ObpFinq,\na function\ni: HomFinpS, S1q N HomSetpS, S1q.\nBut again, that's easy because we know by definition (see Example 4.1.1.4) that these\ntwo sets are equal, HomFinpS, S1q \" HomSetpS, S1q. Hence we can simply take i to be\nthe identity function on morphisms. It is easy to see that identites and compositions are\npreserved by i. Therefore, we have defined a functor i.\nExercise 4.1.2.7 (Forgetful functors between types of orders). A partial order is just a\npreorder with a special property. A linear order is just a partial order with a special\nproperty.\na.) Is there an \"obvious\" functor FLin N PrO?\nb.) Is there an \"obvious\" functor PrO N FLin?\n♦\nProposition 4.1.2.8 (Preorders to graphs). Let PrO be the category of preorders and\nGrph be the category of graphs. There is a functor P : PrO N Grph such that for any\npreorder X \" pX, dq, the graph PpXq has vertices X.\nProof. Given a preorder X \" pX, dXq, we can make a graph FpXq with vertices X\nand an arrow x N x1 whenever x dX x1, as in Remark 3.4.1.10. More precisely, the\npreorder dX is a relation, i.e. a subset RX D X ˆ X, which we think of as a function\ni: RX N X ˆ X. Composing with projections π1, π2 : X ˆ X N X gives us\nsrcX :\" π1 i: RX N X\nand\ntgtX :\" π2 i: RX N X.\nThen we put FpXq :\" pX, RX , srcX , tgtX q. This gives us a function F : ObpPrOq N\nObpGrphq.\nSuppose now that f : X N Y is a preorder morphism (where Y \" pY, dY q). This is a\nfunction f : X N Y such that for any px, x1q P X ˆX, if x dX x1 then fpxq d fpx1q. But\nthat's the same as saying that there exists a dotted arrow making the following diagram\nof sets commute\nRX\n/\n\nX ˆ X\nfˆf\n\nRY\n/ Y ˆ Y\n(Note that there cannot be two different dotted arrows making that diagram commute\nbecause RY N Y ˆ Y is a monomorphism.) Our commutative square is precisely what's\nneeded for a graph homomorphism, as shown in Exercise 3.3.3.7. Thus, we have defined\nF on objects and on morphisms. It is clear that F preserves identity and composition.\n□\nExercise 4.1.2.9. In Proposition 4.1.2.8 we gave a functor P : PrO N Grph.\n\nCHAPTER 4. BASIC CATEGORY THEORY\na.) Is every graph G P ObpGrphq in the image of P (or more precisely, is the function\nObpPq: ObpPrOq N ObpGrphq\nsurjective)?\nb.) If so, why; if not, name a graph not in the image.\nc.) Suppose that G, H P ObpGrphq are two graphs that are in the image of P. Is every\ngraph homomorphism f : G N H in the image of HomP ? In other words, does every\ngraph homomorphism between G and H come from a preorder homomorphism?\n♦\nRemark 4.1.2.10. There is a functor W : PrO N Set sending pX, dq to X.\nThere\nis a functor T : Grph N Set sending pV, A, src, tgtq to V . When we understand the\ncategory of categories (Section 4.1.2.27), it will be clear that Proposition 4.1.2.8 can be\nsummarized as a commutative triangle in Cat,\nPrO\nP\n/\nW\n\nGrph\nT\n\nSet\nExercise 4.1.2.11 (Graphs to preorders). Recall from (2.3) that every function f : A N\nB has an image, imfpAq D B.\nUse this idea and Example 3.4.1.16 to construct a\nfunctor Im: Grph N PrO such that for any graph G \" pV, A, src, tgtq, the preorder\nhas elements given by the vertices of G (i.e. we have ImpGq \" pV, dGq, for some ordering\ndG).\n♦\nExercise 4.1.2.12. What is the preorder ImpGq when G P ObpGrphq is the following\ngraph?\nG :\"\nv‚\nf\n/ w‚\nh\n?\ng\nx‚\ny‚\ni\n\nj\nz‚\nk\n_\n♦\nExercise 4.1.2.13. Consider the functor Im: Grph N PrO constructed in Exercise\n4.1.2.11.\na.) Is every preorder X P ObpPrOq in the image of Im (or more precisely in the image\nof ObpImq: ObpGrphq N ObpPrOq)?\nb.) If so, why; if not, name a preorder not in the image.\nc.) Suppose that X, Y P ObpPrOq are two preorders that are in the image of Im. Is\nevery preorder morphism f : X N Y in the image of HomIm? In other words, does\nevery preorder homomorphism between X and Y come from a graph homomorphism?\n\n4.1. CATEGORIES AND FUNCTORS\n♦\nExercise 4.1.2.14. We have functors P : PrO N Grph and Im: Grph N PrO.\na.) What can you say about Im P : PrO N PrO?\nb.) What can you say about P Im: Grph N Grph?\n♦\nExercise 4.1.2.15. Consider the functors P : PrO N Grph and Im: Grph N PrO.\nAnd consider the chain graph rns of length n from Example 3.3.1.8 and the linear order\nrns of length n from Example 3.4.1.7. To differentiate the two, let's rename them for\nthis exercise as rnsGrph P ObpGrphq and rnsPrO P ObpPrOq.\nWe see a similarity\nbetween rnsGrph and rnsPrO, and we might hope that our functors help us formalize this\nsimilarity. That is, we might hope that one of the following hold:\nPprnsPrOq -? rnsGrph\nor\nImprnsGrphq -? rnsPrO.\nDo either, both, or neither of these hold?\n♦\nRemark 4.1.2.16. In the course announcement for 18-S996, I wrote the following:\nIt is often useful to focus ones study by viewing an individual thing, or a\ngroup of things, as though it exists in isolation.\nHowever, the ability to\nrigorously change our point of view, seeing our object of study in a different\ncontext, often yields unexpected insights. Moreover this ability to change\nperspective is indispensable for effectively communicating with and learning\nfrom others. It is the relationships between things, rather than the things\nin and by themselves, that are responsible for generating the rich variety\nof phenomena we observe in the physical, informational, and mathematical\nworlds.\nThis holds at many different levels. For example, one can study a group (in the sense of\nDefinition 3.2.1.1) in isolation, trying to understand its subgroups or its automorphisms,\nand this is mathematically interesting. But one can also view it as a quotient of something\nelse, or as a subgroup of something else. One can view the group as a monoid and look\nat monoid homomorphisms to or from it. One can look at the group in the context of\nsymmetries by seeing how it acts on sets. These changes of viewpoint are all clearly\nand formally expressible within category theory. We know how the different changes of\nviewpoint compose and how they fit together in a larger context.\nExercise 4.1.2.17.\na.) Is the above quote also true in your scientific discipline of expertise? How so?\nb.) Can you imagine a way that category theory can help catalogue the kinds of rela-\ntionships or changes of viewpoint that exist in your discipline?\nc.) What kinds of structures that you use often really deserve to be better formalized?\nKeep this kind of question in mind for your final project.\n♦\nExample 4.1.2.18 (Free monoids). Let G be a set. We saw in 3.1.1.15 that ListpGq is a\nmonoid, called the free monoid on G. Given a function f : G N G1, there is an induced\nfunction Listpfq: ListpGq N ListpG1q, and this preserves the identity element r s and\nconcatenation of lists, so Listpfq is a monoid homomorphism. It is easy to check that\nList: Set N Mon is a functor.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nApplication 4.1.2.19. In Application 2.1.2.10 we discussed an isomorphism NucDNA -\nNucRNA given by RNA transcription. Applying the functor List we get a function\nListpNucDNAq -\nYN ListpNucRNAq,\nwhich will send sequences of DNA nucleotides to sequences of RNA nucleotides and vice\nversa. This is performed by polymerases.\n♦♦\nExercise 4.1.2.20. Let G \" t1, 2, 3, 4, 5u, G1 \" ta, b, cu, and let f : G N G1 be given by\nthe sequence pa, c, b, a, cq.5 Then if L \" r1, 1, 3, 5, 4, 5, 3, 2, 4, 1s, what is ListpfqpLq?\n♦\nExercise 4.1.2.21. We can rephrase our notion of functor in terms compatible with Ex-\nercise 4.1.1.23. We would begin by saying that a functor F : C N C1 consists of two\nfunctions,\nObpFq: ObpCq N ObpC1q\nand\nHomF : HomC N HomC1,\nwhich we call the on-objects part and the on-morphisms part, respectively. They must\nfollow some rules, expressed by the commutativity of the following squares in Set:\nHomC\ndom /\nHomF\n\nObpCq\nObpF q\n\nHomC1\ndom / ObpC1q\nHomC\ncod /\nHomF\n\nObpCq\nObpF q\n\nHomC1\ncod / ObpC1q\n(4.4)\nObpCq\nObpF q\n\nid\n/ HomC\nHomF\n\nObpC1q\nid\n/ HomC1\nHomC ˆObpCq HomC\n\n/\n\nHomC\nHomF\n\nHomC1 ˆObpC1q HomC1\n\n/ HomC1\n(4.5)\nWhere does the (unlabeled) left-hand function in the bottom right diagram come from?\nHint: use Exercise 2.5.1.19.\nConsider Diagram (4.2) and imagine it as though contained in a pane of glass. Then\nimagine a parallel pane of glass involving C1 in place of C everywhere.\na.) Draw arrows from the C pane to the C1 pane, each labeled ObpFq or HomF as seems\nappropriate.\nb.) If F is a functor (i.e. satisfies (4.4) and (4.5)), do all the squares in your drawing\ncommute?\nc.) Does the definition of functor involve anything not captured in this setup?\n♦\nExample 4.1.2.22 (Paths-graph). Let G \" pV, A, src, tgtq be a graph. Then for any pair of\nvertices v, w P G, there is a set PathGpv, wq of paths from v to w; see Definition 3.3.2.1.\n5See Exercise 2.1.2.15 in case there is any confusion with this.\n\n4.1. CATEGORIES AND FUNCTORS\nIn fact there is a set PathG and functions src, tgt: PathG N V . That information is\nenough to define a new graph,\nPathspGq :\" pV, PathG, src, tgtq.\nMoreover, given a graph homomorphism f : G N G1, every path in G is sent under f\nto a path in G1. So Paths: Grph N Grph is a functor.\nExercise 4.1.2.23.\na.) Consider the graph G from Example 3.3.3.3. Draw the paths-graph PathspGq for G.\nb.) Repeating the above exercise for G1 from the same example would be hard, because\nthe path graph PathspG1q has infinitely many arrows. However, the graph homomor-\nphism f : G N G1 does induce a morphism of paths-graphs Pathspfq: PathspGq N\nPathspG1q, and it is possible to say how that acts on the vertices and arrows of\nPathspGq. Please do so.\nc.) Given a graph homomorphism f : G N G1 and two paths p: v N w and q: w N x in\nG, is it true that Pathspfq preserves the concatenation? What does that even mean?\n♦\nExercise 4.1.2.24. Suppose that C and D are categories, c, c1 P ObpCq are objects, and\nF : C N D is a functor. Suppose that c and c1 are isomorphic in C. Show that this\nimplies that Fpcq and Fpc1q are isomorphic in D.\n♦\nExample 4.1.2.25. For any graph G, we can assign its set of loops EqpGq as in Exercise\n3.3.1.12. This assignment is functorial in that given a graph homomorphism G N G1\nthere is an induced function EqpGq N EqpG1q. Similarly, we can functorially assign the\nset of connected components of the graph, CoeqpGq. In other words Eq: Grph N Set\nand Coeq: Grph N Set are functors. The assignment of vertex set and arrow set are\ntwo more functors Grph N Set.\nSuppose you want to decide whether two graphs G and G1 are isomorphic. Supposing\nthat the graphs have thousands of vertices and thousands of arrows, this could take a\nlong time. However, the functors above, in combination with Exercise 4.1.2.24 give us\nsome things to try.\nThe first thing to do is to count the number of loops of each, because these numbers\nare generally small. If the number of loops in G is different than the number of loops\nin G1 then because functors preserve isomorphisms, G and G1 cannot be isomorphic.\nSimilarly one can count the number of connected components, again generally a small\nnumber; if the number of components in G is different than the number of components\nin G1 then G - G1. Similarly, one can simply count the number of vertices or the number\nof arrows in G and G1. These are all isomorphism invariants.\nAll this is a bit like trying to decide if a number is prime by checking if it's even, if\nits digits add up to a multiple of 3, or it ends in a 5; these tests do not determine the\nanswer, but they offer some level of discernment.\nRemark 4.1.2.26. In the introduction I said that functors allow ideas in one domain to\nbe rigorously imported to another. Example 4.1.2.25 is a first taste. Because functors\npreserve isomorphisms, we can tell graphs apart by looking at them in a simpler category,\nSet.\nThere is relatively simple theorem in Set that says that for different natural\nnumbers m, n the sets m and n are never isomorphic. This theorem is transported via\nour four functors to four different theorems about telling graphs apart.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.1.2.27\nThe category of categories\nRecall from Remark 4.1.1.2 that a small category C is one in which ObpCq is a set. We\nhave not really been paying attention to this issue, and everything we have said so far\nworks whether C is small or not. In the following definition we really ought to be a little\nmore careful, so we are.\nProposition 4.1.2.28. There exists a category, called the category of small categories\nand denoted Cat, in which the objects are the small categories and the morphisms are\nthe functors,\nHomCatpC, Dq \" tF : C N D | F is a functoru.\nThat is, there are identity functors, functors can be composed, and the identity and\nassociativity laws hold.\nProof. We follow Definition 4.1.1.1. We have specified ObpCatq and HomCat already.\nGiven a small category C, there is an identity functor idC : C N C that is identity on the\nset of objects and the set of morphisms. And given a functor F : C N D and a functor\nG: D N E, it is easy to check that G F : C N E, defined by composition of functions\nObpGq ObpFq: ObpCq N ObpEq and HomG HomF : HomC N HomE (see Exercise\n4.1.2.21), is a functor. For the same reasons, it is easy to show that functors obey the\nidentity law and the composition formula. Therefore this specification of Cat satisfies\nthe definition of being a category.\n□\nExample 4.1.2.29 (Categories have underlying graphs). Let C \" pObpCq, HomC, dom, cod, ids, q\nbe a category (see Exercise 4.1.1.23). Then pObpCq, HomC, dom, codq is a graph, which we\nwill call the graph underlying C and denote by UpCq P ObpGrphq. A functor F : C N D\ninduces a graph morphism UpFq: UpCq N UpDq, as seen in (4.4). So we have a functor,\nU : Cat N Grph.\nExample 4.1.2.30 (Free category on a graph). In Example 4.1.2.22, we discussed a functor\nPaths: Grph N Grph that considered all the paths in a graph G as the arrows of a\nnew graph PathspGq. In fact, PathspGq could be construed as a category, which we will\ndenote FpGq P ObpCatq and call the free category generated by G.\nHere, the objects of the category FpGq are the vertices of G. For any two vertices v, v1\nthe hom-set HomF pGqpv, v1q is the set of paths in G from v to v1. The identity elements\nare given by the trivial paths, and the composition formula is given by concatenation of\npaths.\nTo see that F is a functor, we need to see that a graph homomorphism f : G N G1\ninduces a functor Fpfq: FpGq N FpG1q. But this was shown in Exercise 4.1.2.23. Thus\nwe have a functor\nF : Grph N Cat\ncalled the free category functor.\nExercise 4.1.2.31. Let G be the graph depicted\nv0‚\ne\nYYYYYN\nv1‚,\nand let r1s P ObpCatq denote the free category on G (see Example 4.1.2.30). We call r1s\nthe free arrow category.\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS129\na.) What are its objects?\nb.) For every pair of objects in r1s, write down the hom-set.\n♦\nExercise 4.1.2.32. Let G be the graph whose vertices are all cities in the US and whose\narrows are airplane flights connecting cities. What idea is captured by the free category\non G?\n♦\nExercise 4.1.2.33. Let F : Grph N Cat denote the free category functor from Example\n4.1.2.30, and let U : Cat N Grph denote the underlying graph functor from Example\n4.1.2.29. We have seen the composition U F : Grph N Grph before; what was it\ncalled?\n♦\nExercise 4.1.2.34. Recall the graph G from Example 3.3.1.2. Let C \" FpGq be the free\ncategory on G.\na.) What is HomCpv, xq?\nb.) What is HomCpx, vq?\n♦\nExample 4.1.2.35 (Discrete graphs, discrete categories). There is a functor Disc: Set N\nGrph that sends a set S to the graph\nDiscpSq :\" pS, H, !, !q,\nwhere !: H N S is the unique function. We call DiscpSq the discrete graph on the set S.\nIt is clear that a function S N S1 induces a morphism of discrete graphs. Now applying\nthe free category functor F : Grph N Cat, we get the so-called discrete category on the\nset S, which we also might call Disc: Set N Cat.\nExercise 4.1.2.36. Recall from (2.6) the definition of the set n for any natural number\nn P N, and let Dn :\" Discpnq P ObpCatq.\na.) List all the morphisms in D4.\nb.) List all the functors D3 N D2.\n♦\nExercise 4.1.2.37 (Terminal category). Let C be a category. How many functors are there\nC N D1, where D1 :\" Discp1q is the discrete category on one element?\n♦\nWe sometimes refer to Discp1q as the terminal category (for reasons that will be made\nclear in Section 4.5.3), and for simplicity denote it by 1.\nExercise 4.1.2.38. If someone said \"Ob is a functor from Cat to Set,\" what might they\nmean?\n♦\n4.2\nCategories and functors commonly arising in math-\nematics\n4.2.1\nMonoids, groups, preorders, and graphs\nWe saw in Section 4.1.1 that there is a category Mon of monoids, a category Grp of\ngroups, a category PrO of preorders, and a category Grph of graphs. In this section we\n\nCHAPTER 4. BASIC CATEGORY THEORY\nshow that each monoid M, each group G, and each preorder P can be considered as its\nown category. If each object in Mon is a category, we might hope that each morphism\nin Mon is just a functor, and this is true. The same holds for Grp and PrO. We will\ndeal with graphs in Section 4.2.1.20.\n4.2.1.1\nMonoids as categories\nIn Example 3.1.2.9 we said that to olog a monoid, we should use only one box. And\nagain in Example 3.5.3.3 we said that a monoid action could be captured by only one\ntable. These ideas emanated from the understanding that a monoid is perfectly modeled\nas a category with one object.\nEach monoid as a category with one object\nLet pM, e, ‹q be a monoid.\nWe\nconsider it as a category M with one object, ObpMq \" t▲u, and\nHomMp▲, ▲q :\" M.\nThe identity morphism id▲serves as the monoid identity e, and the composition formula\n: HomMp▲, ▲q ˆ HomMp▲, ▲q N HomMp▲, ▲q\nis given by ‹: M ˆ M N M. The associativity and identity laws for the monoid match\nprecisely with the associativity and identity laws for categories.\nIf monoids are categories with one object, is there any categorical way of phrasing the\nnotion of monoid homomorphism? Suppose that M \" pM, e, ‹q and M1 \" pM 1, e1, ‹1q.\nWe know that a monoid homomorphism is a function f : M N M 1 such that fpeq \" e1\nand such that for every pair m0, m1 P M we have fpm0 ‹ m1q \" fpm0q ‹1 fpm1q. What\nis a functor M N M1?\nEach monoid homomorphism as a functor between one-object categories\nSay\nthat ObpMq \" t▲u and ObpM1q \" t▲1u; and we know that HomMp▲, ▲q \" M and\nHomM1p▲1, ▲1q \" M 1. A functor F : M N M1 consists first of a function ObpMq N\nObpM1q, but these sets have only one element each, so there is nothing to say on that\nfront. It also consists of a function HomM N homM1 but that is just a function M N M 1.\nThe identity and composition formulas for functors match precisely with the identity and\ncomposition formula for monoid homomorphisms, as discussed above. Thus a monoid\nhomomorphism is nothing more than a functor between one-object categories.\nSlogan 4.2.1.2.\n\" A monoid is a category G with one object. A monoid homomorphism is\njust a functor between one-object categories. \"\nWe formalize this as the following theorem.\nTheorem 4.2.1.3. There is a functor i: Mon N Cat with the following properties:\n- for every monoid M P ObpMonq, the category ipMq P ObpCatq itself has exactly\none object,\n|ObpipMqq| \" 1\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS131\n- for every pair of monoids M, M1 P ObpMonq the function\nHomMonpM, M1q -\nYN HomCatpipMq, ipM1qq,\ninduced by the functor i, is a bijection.\nProof. This is basically the content of the preceding paragraphs. The functor i sends a\nmonoid to the corresponding category with one object and i sends a monoid homomor-\nphism to the corresponding functor; it is not hard to check that i preserves identities\nand compositions.\n□\nTheorem 4.2.1.3 situates the theory of monoids very nicely within the world of cate-\ngories. But we have other ways of thinking about monoids, namely their actions on sets.\nAs such it would greatly strengthen the story if we could subsume monoid actions within\ncategory theory also, and we can.\nEach monoid action as a set-valued functor\nRecall from Definition 3.1.2.1 that if\npM, e, ‹q is a monoid, an action consists of a set S and a function u: M ˆ S N S such\nthat e u s \" s and m0 u pm1 u sq \" pm0 ‹ m1q u s for all s P S. How might we relate\nthe notion of monoid actions to the notion of functors? One idea is to try asking what\na functor F : M N Set is; this idea will work.\nSince M has only one object, we obtain one set, S :\" Fp▲q P ObpSetq. We also\nobtain a function HomF : HomMp▲, ▲q N HomSetpFp▲q, Fp▲qq, or more concisely, a\nfunction\nHF : M N HomSetpS, Sq.\nBy currying (see Proposition 2.7.2.3), this is the same as a function u: M ˆS N S. The\nrule that e u s \" s becomes the rule that functors preserve identities, HomF pid▲q \" idS.\nThe other rule is equivalent to the composition formula for functors.\n4.2.1.4\nGroups as categories\nA group is just a monoid pM, e, ‹q in which every element m P M is invertible, meaning\nthere exists some m1 P M with m ‹ m1 \" e \" m1 ‹ m. If a monoid is the same thing\nas a category M with one object, then a group must be a category with one object\nand with an additional property having to do with invertibility. The elements of M are\nthe morphisms of the category M, so we need a notion of invertibility for morphisms.\nLuckily we have such a notion already, namely isomorphism. We have the following:\nSlogan 4.2.1.5.\n\" A group is a category G with one object, such that every morphism in G\nis an isomorphism. A group homomorphism is just a functor between such\ncategories. \"\nTheorem 4.2.1.6. There is a functor i: Grp N Cat with the following properties:\n- for every group G P ObpGrpq, the category ipGq P ObpCatq itself has exactly one\nobject, and every morphism m in ipGq is an isomorphism; and\n\nCHAPTER 4. BASIC CATEGORY THEORY\n- for every pair of groups G, G1 P ObpGrpq the function\nHomGrppG, G1q -\nYN HomCatpipGq, ipG1qq,\ninduced by the functor i, is a bijection.\nJust as with monoids, an action of some group pG, e, ‹q on a set S P ObpSetq is the\nsame thing as a functor G N Set sending the unique object of G to the set S.\n4.2.1.7\nMonoid and group stationed at each object in a category\nIf a monoid is just a category with one object, we can locate monoids in any category C\nby narrowing our gaze to one object in C. Similarly for groups.\nExample 4.2.1.8 (Endomorphism monoid). Let C be a category and x P ObpCq an object.\nLet M \" HomCpx, xq. Note that for any two elements f, g P M we have f g: x N x\nin M. Let M \" pM, idx, q. It is easy to check that M is a monoid; it is called the\nendomorphism monoid of x in C.\nExample 4.2.1.9 (Automorphism group). Let C be a category and x P ObpCq an object.\nLet G \" tf : x N x | f is an isomorphismu. Let G \" pG, idx, q. It is easy to check that\nG is a group; it is called the automorphism group of x in C.\nExercise 4.2.1.10. Let S \" t1, 2, 3, 4u P ObpSetq.\na.) What is the automorphism group of S in Set, and how many elements does this\ngroup have?\nb.) What is the endomorphism monoid of S in Set, and how many elements does this\nmonoid have?\nc.) Recall from Example 4.1.2.3 that every group has an underlying monoid UpGq; is\nthe endomorphism monoid of S the underlying monoid of the automorphism group\nof S?\n♦\nExercise 4.2.1.11. Consider the graph G depicted below.\n1‚\n,\n\n2‚\n\nl\n3‚\n,\nL\n4‚\nL\nl\nWhat is its group of automorphisms? Hint: every automorphism of G will induce an\nautomorphism of the set t1, 2, 3, 4u; which ones will preserve the arrows?\n♦\n4.2.1.12\nPreorders as categories\nA preorder pX, dq consists of a set X and a binary relation d that is reflexive and\ntransitive. We can make from pX, dq P ObpPrOq a category X P ObpCatq as follows.\nDefine ObpXq \" X and for every two objects x, y P X define\nHomX px, yq \"\n#\nt\"x d y\"u\nif x d y\nH\nif x e y\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS133\nTo clarify: if x d y, we assign HomX px, yq to be the set containing only one element,\nnamely the string \"x d y\".6 If px, yq is not in relation d, then we assign HomX px, yq to\nbe the empty set. The composition formula\n: HomX px, yq ˆ HomX py, zq N HomX px, zq\n(4.6)\nis completely determined because either one of two possibilities occurs. One possibility\nis that the left-hand side is empty (if either x e y or y e z; in this case there is a unique\nfunction as in (4.6). The other possibility is that the left-hand side is not empty in\ncase x d y and y d, which implies x d z, so the right-hand side has exactly one element\n\"x d z\" in which case again there is a unique function as in (4.6).\nOn the other hand, if C is a category having the property that for every pair of objects\nx, y P ObpCq, the set HomCpx, yq is either empty or has one element, then we can form\na preorder out of C. Namely, take X \" ObpCq and say x d y if there exists a morphism\nx N y in C.\nExercise 4.2.1.13. We have seen that a preorder can be considered as a category P. Recall\nfrom Definition 3.4.1.1 that a partial order is a preorder with an additional property.\nPhrase the defining property for partial orders in terms of isomorphisms in the category\nP.\n♦\nExercise 4.2.1.14. Suppose that C is a preorder (considered as a category). Let x, y P\nObpCq be objects such that x d y and y d x. Prove that there is an isomorphism x N y\nin C.\n♦\nExample 4.2.1.15. The olog from Example 3.4.1.3 depicted a partial order, say P. In it\nwe have\nHomPp⌜a diamond⌝, ⌜a red card⌝q \" tisu\nand we have\nHomPp⌜a black queen⌝, ⌜a card⌝q - tis isu;\nBoth of these sets contain exactly one element, the name is not important. The set\nHomPp⌜a 4⌝, ⌜a 4 of diamonds⌝q \" H.\nExercise 4.2.1.16. Every linear order is a partial order with a special property. Can you\nphrase this property in terms of hom-sets?\n♦\nProposition 4.2.1.17. There is a functor i: PrO N Cat with the following properties\nfor every preorder pX, dq:\n1. the category X :\" ipX, dq has objects ObpXq \" X; and\n2. for each pair of elements x, x1 P ObpXq the set HomX px, x1q has at most one\nelement.\nMoreover, any category with property 2 is in the image of the functor i.\nProof. To specify a functor i: PrO N Cat, we need to say what it does on objects and\non morphisms. To an object pX, dq in PrO, we assign the category X with objects X\nand a unique morphism from x N x1 if x d x1; this was discussed at the top of Section\n4.2.1.12. To a morphism f : pX, dXq N pY, dY q of preorders, we must assign a functor\nipfq: X N Y. Again, to specify a functor we need to say what it does on objects and\n6The name of this morphism is completely unimportant.\nWhat matters is that HomX px, yq has\nexactly one element iffx d y.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nmorphisms of X. To an object x P ObpXq \" X, we assign the object fpxq P Y \" ObpYq.\nGiven a morphism f : x N x1 in X, we know that x d x1 so by Definition 3.4.4.1 we\nhave that fpxq d fpx1q, and we assign to f the unique morphism fpxq N fpx1q in Y. To\ncheck that the rules of functors (preservation of identities and composition) are obeyed\nis routine.\n□\nSlogan 4.2.1.18.\n\" A preorder is a category in which every hom-set has either 0 elements or 1\nelement. A preorder morphism is just a functor between such categories. \"\nExercise 4.2.1.19. Recall the functor P : PrO N Grph from Proposition 4.1.2.8, the\nfunctors F : Grph N Cat and U : Cat N Grph from Example 4.1.2.33, and the functor\ni: PrO N Cat from Proposition 4.2.1.17.\na.) Do either of the following diagrams of categories commute?\nPrO\nP\n/\ni\n\n?\nGrph\nF\n\nCat\nPrO\nP\n/\ni\n\n?\nGrph\nCat\nU\nA\nb.) We also had a functor Grph N PrO. Does the following diagram of categories\ncommute?\nGrph\n/\nF\n\n?\nPrO\ni\n\nCat\n♦\n4.2.1.20\nGraphs as functors\nLet C denote the category depicted below\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\n(4.7)\nThen a functor G: GrIn N Set is the same thing as two sets GpArq, GpVeq and two\nfunctions Gpsrcq: GpArq N GpVeq and Gptgtq: GpArq N GpVeq. This is precisely what\nis needed for a graph; see Definition 3.3.1.1. We call GrIn the graph indexing category.\nExercise 4.2.1.21. Consider the terminal category, 1, also known as the discrete category\non one element (see Exercise 4.1.2.37). Let GrIn be as in (4.7) and consider the functor\ni0 : 1 N GrIn sending the object of 1 to the object V P ObpGrInq. If G: GrIn N Set\nis a graph, what is the composite G i0? It consists of only one set; what set is it? For\nexample, what set is it when G is the graph from Example 3.3.3.3.\n♦\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS135\nIf a graph is a functor GrIn N Set, what is a graph homomorphism?\nWe will\nsee later in Example 4.3.1.17 that graph homomorphisms are homomorphisms between\nfunctors, which are called natural transformations. (Natural transformations are the\nhighest-\"level\" structure that occurs in ordinary category theory.)\nExample 4.2.1.22. Let D be the category depicted below\nD :\"\nA‚\nρ\nsrc /\ntgt /\nV‚\n(4.8)\nwith the following composition formula:\nρ ρ \" idA;\nsrc ρ \" tgt;\nand\ntgt ρ \" src.\nThe idea here is that the morphism ρ: A N A reverses arrows. The PED ρ ρ \" idA\nforces the fact that the reverse of the reverse of an arrow yields the original arrow. The\nPEDs src ρ \" tgt and tgt ρ \" src force the fact that when we reverse an arrow, its\nsource and target switch roles.\nThis category D is the symmetric graph indexing category. Just like any graph can\nbe understood as a functor GrIn N Set, where GrIn is the graph indexing category\ndisplayed in (4.7), any symmetric graph can be understood as a functor D N Set, where\nD is the category drawn above. Given a functor G: D N Set, we will have a set of\narrows, a set of vertices, a source operation, a target operation, and a \"reverse direction\"\noperation that all behave as expected.\nIt is customary to draw the connections in a symmetric graph as line segments rather\nthan arrows between vertices. However, a better heuristic is to think that each connection\nbetween vertices consists of two arrows, one pointing in each direction.\nSlogan 4.2.1.23.\n\" In a symmetric graph, every arrow has an equal and opposite arrow. \"\nExercise 4.2.1.24. Which of the following graphs are symmetric:\na.) The graph G from (3.4)?\nb.) The graph G from Exercise 3.3.1.10?\nc.) The graph G1 from (3.7)?\nd.) The graph Loop from (3.17), i.e. the graph having exactly one vertex and one arrow?\ne.) The graph G from Exercise 4.2.1.11?\n♦\nExercise 4.2.1.25. Let GrIn be the graph indexing category shown in (4.7) and let D be\nthe symmetric graph indexing category displayed in (4.8).\na.) How many functors are there of the form GrIn N D?\nb.) Is one more \"reasonable\" than the others?\nc.) Choose the one that seems most reasonable and call it i: GrIn N D. If a symmetric\ngraph is a functor S : D N Set, you can compose with i to get a functor S i: GrIn N\nSet. This is a graph; what graph is it? What has changed?\n♦\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.2.2\nDatabase schemas present categories\nRecall from Definition 3.5.2.6 that a database schema (or schema, for short) consists of a\ngraph together with a certain kind of equivalence relation on its paths. In Section 4.4.1\nwe will define a category Sch that has schemas as objects and appropriately modified\ngraph homomorphisms as morphisms. In Section 4.4.2 we prove that the category of\nschemas is equivalent (in the sense of Definition 4.3.4.1) to the category of categories,\nSch » Cat.\nThe difference between schemas and categories is like the difference between monoid\npresentations, given by generators and relations as in Definition 3.1.1.17, and the monoids\nthemselves. The same monoid has (infinitely) many different presentations, and so it is\nfor categories: many different schemas can present the same category. Computer scien-\ntists may think of the schema as syntax and the category it presents as the corresponding\nsemantics. A schema is a compact form, and can be specified in finite space and time\nwhile generating something infinite.\nSlogan 4.2.2.1.\n\" A database schema is a category presentation. \"\nWe will formally show in Section 4.4.2 how to turn a schema into a category (the\ncategory it presents). For now, it seems pedagogically better not to be so formal, because\nthe idea is fairly straightforward. Suppose given a schema S, which consists of a graph\nG \" pV, A, src, tgtq equipped with a congruence „ (see Definition 3.5.2.3). It presents a\ncategory C defined as follows. The set of objects in C is defined to be the vertices V ; the\nset of morphisms in C is defined to be the quotient PathspGq{ „; and the composition\nlaw is concatenation of paths. The path equivalences making up „ become commutative\ndiagrams in C.\nExample 4.2.2.2. The schema Loop, depicted below, has no path equivalence declarations.\nAs a graph it has one vertex and one arrow.\nLoop :\"\ns‚\nf\n\nThe category it generates, however, is the free monoid on one generator, N. It has one\nobject ▲but a morphism f n : ▲N ▲for every natural number n P N, thought of as\n\"how many times to go around the loop f\". Clearly, the schema is more compact that\nthe infinite category it generates.\nExercise 4.2.2.3. Consider the olog from Exercise 3.5.2.18, which says that for any father\nx, his first child's father is x. It is redrawn below as a schema S, and we include the\ndesired path equivalence declaration, F c f \" F,\nF‚\nc\n/ C‚\nf\n_\nHow many morphisms are there (total) in the category generated by S?\n♦\nExercise 4.2.2.4. Suppose that G is a graph and that G is the schema generated by G\nwith no PEDs. What is the relationship between the category generated by G and the\nfree category FpGq P ObpCatq as defined in Example 4.1.2.30?\n♦\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS137\n4.2.2.5\nInstances on a schema C\nIf schemas are like categories, what are instances? Recall that an instance I on a schema\nS \" pG, »q assigns to each vertex v in G a set of rows say Ipvq P ObpSetq. And to every\narrow a: v N v1 in G the instance assigns a function Ipaq: Ipvq N Ipv1q. The rule is that\ngiven two equivalent paths, their compositions must give the same function. Concisely,\nan instance is a functor I : S N Set.\nExample 4.2.2.6. We have now seen that a monoid is just a category M with one ob-\nject and that a monoid action is a functor M N Set.\nUnder our understanding of\ndatabase schemas as categories, M is a schema and so an action becomes an instance\nof that schema. The monoid action table from Example ex:action table was simply a\nmanifestation of the database instance according to the Rules 3.5.2.8.\nExercise 4.2.2.7. In Section 4.2.1.20 we discuss how each graph is a functor GrIn N Set\nfor the graph indexing category depicted below:\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\nBut now we know that if a graph is a set-valued functor then we can consider GrIn as\na database schema.\na.) How many tables, and how many columns of each should there be (if unsure, consult\nRules 3.5.2.8)?\nb.) Write out the table view of graph G from Example 3.3.3.3.\n♦\n4.2.3\nSpaces\nCategory theory was invented for use in algebraic topology, and in particular to discuss\nnatural transformations between certain functors. We will get to natural transformations\nmore formally in Section 4.3. For now, they are ways of relating functors. In the original\nuse, Eilenberg and Mac Lane were interested in functors that connect topological spaces\n(shapes like spheres, etc.) to algebraic systems (groups, etc.)\nFor example, there is a functor that assigns to each space X its group π1pXq of round-\ntrip voyages (starting and ending at some chosen point x P X), modulo some equivalence\nrelation. There is another functor that assigns to every space its group H1pX, Zq of ways\nto drop some (positive or negative) number of circles on X. These two functors are\nrelated, but they are not equal.\nThere is a relationship between the functor π1 and the functor H1. For example\nwhen X is the figure-8 space (two circles joined at a point) the group π1pXq is much\nbigger than the group H1pXq. Indeed π1pXq includes information about the order and\ndirection of loops traveled; whereas the group H1pX, Zq includes only information about\nhow many times one goes around each loop. However, there is a natural transformation\nof functors π1p q N H1p , Zq, called the Hurewicz transformation, which \"forgets\" the\nextra information and thus yields a simplification.\nExample 4.2.3.1. Given a set X, recall that PpXq denotes the set of subsets of X. A\ntopology on X is a choice of which subsets U P PpXq will be called open sets. The union\nof any number of open sets must be considered to be an open set, and the intersection\n\nCHAPTER 4. BASIC CATEGORY THEORY\nof any finite number of open sets must be considered open. One could say succinctly\nthat a topology on X is a sub-order OpenpXq D PpXq that is closed under taking finite\nmeets and infinite joins.\nA topological space is a pair pX, OpenpXqq, where X is a set and OpenpXq is a\ntopology on X. The elements of the set X are called points. A morphism of topological\nspaces (also called a continuous map) is a function f : X N Y such that for every\nV P OpenpY q the preimage f 1pV q P PpXq is actually in OpenpXq. That is, such that\nthere exists a dashed arrow making the diagram below commute:\nOpenpY q\n/\n\nOpenpXq\n\nPpY q\nf 1\n/ PpXq.\nThe category of topological spaces, denoted Top, is the category having objects and\nmorphisms as above.\nExercise 4.2.3.2.\na.) Explain how \"looking at points\" gives a functor Top N Set.\nb.) Does \"looking at open sets\" give a functor Top N PrO?\n♦\nExample 4.2.3.3 (Continuous dynamical systems). The set R can be given a topology in\na standard way.7 But pR, 0, `q is also a monoid. Moreover, for every x P R the monoid\noperation `: R ˆ R N R is continuous. 8 So we say that R :\" pR, 0, `q is a topological\nmonoid.\nRecall from Section 4.2.1.1 that a monoid action is a functor M N Set, where M\nis a monoid. Instead imagine a functor a: R N Top? Since R is a category with one\nobject, this amounts to an object X P ObpTopq, a space. And to every real number\nt P R we obtain a continuous map aptq: X N X. If we consider X as the set of states\nof some system and R as the time line, we have captured what is called a continuous\ndynamical system.\nExample 4.2.3.4. Recall (see [Axl]) that a real vector space is a set X, elements of which\nare called vectors, which is closed under addition and scalar multiplication. For example\nR3 is a vector space. A linear transformation from X to Y is a function f : X N Y that\nappropriately preserves addition and scalar multiplication. The category of real vector\nspaces, denoted VectR, has as objects the real vector spaces and as morphisms the linear\ntransformations.\nThere is a functor VectR N Grp sending a vector space to its underlying group of\nvectors, where the group operation is addition of vectors and the group identity is the\n0-vector.\nExercise 4.2.3.5. Every vector space has vector subspaces, ordered by inclusion (the\norigin is inside of any line which is inside of certain planes, etc., and all are inside of the\nwhole space V ). If you know about this topic, answer the following questions.\n7The topology is given by saying that U D R is open ifffor every x P U there exists ε a 0 such that\nty P R | |y x| a εu D Uu. One says, \"U D R is open if every point in U has an epsilon-neighborhood\nfully contained in U\".\n8The topology on R ˆ R is similar; a subset U D R ˆ R is open if every point x P U has an epsilon-\nneighborhood (a disk around x of some positive radius) fully contained in U.\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS139\na.) Does a linear transformation V N V 1 induce a morphism of these orders? In other\nwords, is there a functor VectR N PrO?\nb.) Would you guess that there is a nice functor VectR N Top? By a \"nice functor\" I\nmean one that doesn't make people roll their eyes (for example, there is a functor\nVectR N Top that sends every vector space to the empty space, and that's not\nreally a \"nice\" one. If someone asked for a functor VectR N Top for their birthday,\nthis functor would make them sad. We're looking for a functor VectR N Top that\nwould make them happy.)\n♦\n4.2.3.6\nGroupoids\nGroupoids are like groups except a groupoid can have more than one object.\nDefinition 4.2.3.7. A groupoid is a category C such that every morphism is an isomor-\nphism. If C and D are groupoids, a morphism of groupoids, denoted F : C N D, is simply\na functor. The category of groupoids is denoted Grpd.\nExample 4.2.3.8. There is a functor Grpd N Cat, sending a groupoid to its underlying\ncategory. There is also a functor Grp N Grpd sending a group to \"itself as a groupoid\nwith one object.\"\nApplication 4.2.3.9. Let M be a material in some original state s0.9 Construct a category\nSM whose objects are the states of M, e.g. by pulling on M in different ways, or by\nheating it up, etc. we obtain such states. Include a morphism from state s to state\ns1 if there exists a physical transformation from s to s1. Physical transformations can\nbe performed one after another, so we can compose morphisms, and perhaps we can\nagree this composition is associative. Note that there exists a morphism is : s0 N s for\nany s. Note also that this category is a preorder because there either exists a physical\ntransformation or there does not. 10\nThe elastic deformation region of the material is the set of states s such that there\nexists a morphism s N s0, because any such morphism will be the inverse of is : s0 N s.\nA transformation is irreversible if there is no transformation back. If s1 is not in the\nelastic deformation region, we can (inventing a term) still talk about the region that is\n\"elastically-equivalent\" to s1. It is all the objects in SM that are isomorphic to s1. If we\nconsider only elastic equivalences, we are looking at a groupoid sitting inside the larger\ncategory SM.\n♦♦\nExample 4.2.3.10. Alan Weinstein explains groupoids in terms of tiling patterns on a\nbathroom floor, see [WeA].\nExample 4.2.3.11. Let I \" tx P R | 0 d x d 1u denote the unit interval. It can be given\na topology in a standard way, as a subset of R (see Example 4.2.3.3)\nFor any space X, a path in X is a continuous map I N X. Two paths are called\nhomotopic if one can be continuously deformed to the other, where the deformation\n9This example may be a bit crude, in accordance with the crudeness of my understanding of materials\nscience.\n10Someone may choose to beef this category up to include the set of physical processes between states\nas the hom-set. This gives a category that is not a preorder. But there would be a functor from their\ncategory to ours.\n\nCHAPTER 4. BASIC CATEGORY THEORY\noccurs completely within X. 11 One can prove that being homotopic is an equivalence\nrelation on paths.\nPaths in X can be composed, one after the other, and the composition is associative\n(up to homotopy). Moreover, for any point x P X there is a trivial path (that stays at\nx). Finally every path is invertible (by traversing it backwards) up to homotopy.\nThis all means that to any space X P ObpTopq we can associate a groupoid, called\nthe fundamental groupoid of X and denoted Π1pXq P ObpGrpdq. The objects of Π1pXq\nare the points of X; the morphisms in Π1pXq are the paths in X (up to homotopy). A\ncontinuous map f : X N Y can be composed with any path I N X to give a path I N Y\nand this preserves homotopy. So in fact Π1 : Top N Grpd is a functor.\nExercise 4.2.3.12. Let T denote the surface of a donut, i.e. a torus. Choose two points\np, q P T. Since Π1pTq is a groupoid, it is also a category. What would the hom-set\nHomΠ1pT qpp, qq represent?\n♦\nExercise 4.2.3.13. Let U D R2 be an open subset of the plane, and let F be an irrotational\nvector field on U (i.e. one with curlpFq \" 0). Following Exercise 4.1.1.15, we have a\ncategory CF .\nIf two curves C, C1 in U are homotopic then they have the same line\nintegral,\ns\nC F \"\ns\nC1 F.\nWe also have a category Π1U, given by the fundamental groupoid, as in Example\n4.2.3.11. Both categories have the same objects, ObpCF q \" |U| \" ObpΠ1Uq, the set of\npoints in U.\na.) Is there a functor CF N Π1U or a functor Π1U N CF that is identity on the under-\nlying objects?\nb.) What is CF if F is a conservative vector field?\n♦\nExercise 4.2.3.14. Consider the set A of all (well-formed) arithmetic expressions in the\nsymbols t0, . . . , 9, `, , , p, qu. For example, here are some elements of A:\n52,\n52 7,\n50 ` 3 p6 2q.\nWe can say that an equivalence between two arithmetic expressions is a justification that\nthey give the same \"final answer\", e.g. 52`60 is equivalent to 10 p5`6q`p2`0q, which\nis equivalent to 10 11`2. I've basically described a groupoid. What are its objects and\nwhat are its morphisms?\n♦\n4.2.4\nLogic, set theory, and computer science\n4.2.4.1\nThe category of propositions\nGiven a domain of discourse, a logical proposition is a statement that is evalued in any\nmodel of that domain as either true or \"not always true\". For example, in the domain\nof real numbers we might have the proposition\nFor all real numbers x P R there exists a real number y P R such that y a 3x.\n11 Let I2 \" tpx, yq P R2 | 0 d x d 1 and 0 d y d 1u denote the square. There are two inclusions\ni0, i1 : I N S that put the interval inside the square at the left and right sides. Two paths f0, f1 : I N X\nare homotopic if there exists a continuous map f : I ˆ I N X such that f0 \" f i0 and f1 \" f i1,\nI\ni1\n/\ni0 / I ˆ I\nf\n/ X\n\n4.2. CATEGORIES AND FUNCTORS COMMONLY ARISING IN MATHEMATICS141\nWe say that one logical proposition P implies another proposition Q, denoted P n Q if,\nfor every model in which P is true, so is Q. There is a category Prop whose objects are\nlogical propositions and whose morphisms are proofs that one statement implies another.\nCrudely, one might say that B holds at least as often as A if there is a morphism A N B\n(meaning whenever A holds, so does B). So the proposition \"x % x\" holds very seldom\nand \"x \" x\" always very often.\nExample 4.2.4.2. We can repeat this idea for non-mathematical statements. Take all\npossible statements that are verifiable by experiment as objects of a category. Given\ntwo such statements, it may be that one implies the other (e.g. \"if the speed of light is\nfixed then there are relativistic effects\"). Every statement implies itself (identity) and\nimplication is transitive, so we have a category.\nLet's consider differences in proofs to be irrelevant, so the category Prop becomes a\npreorder: either A implies B or it does not. Then it makes sense to discuss meets and\njoins. It turns out that meets are \"and's\" and joins are \"or's\". That is, given propositions\nA, B the meet A^B is defined to be a proposition that holds as often as possible subject\nto the constraint that it implies both A and B; the proposition \"A holds and B holds\"\nfits the bill. Similarly, the join A _ B is given by \"A holds or B holds\".\nExercise 4.2.4.3. Consider the set of possible laws (most likely an infinite set) that can\nbe dictated to hold throughout a jurisdiction. Consider each law as a proposition (\"such\nand such is (dictated to be) the case\"), i.e as an object of our preorder Prop. Given a\njurisdiction V , and a set of laws tl1, l2, . . . , lnu that are dictated to hold throughout V ,\nwe take their meet LpV q :\" l1 ^ l2 ^ ^ ln and consider it to be the single law of the\nland V . Suppose that V is a jurisdiction and U is a sub-jurisdiction (e.g. U is a county\nand V is a state); write U d V . Then clearly any law dictated by the large jurisdiction\n(the state) must also hold throughout the small jurisdiction (the county).\na.) What is the relation in Prop between LpUq and LpV q?\nb.) Consider the preorder J on jurisdictions given by d as above. Is \"the law of the\nland\" a morphism of preorders J N Prop? To be a bit more high-brow, considering\nboth J and Prop to be categories (by Proposition 4.2.1.17), we have a function\nL: ObpJq N ObpPropq; this question is asking whether L extends to a functor\nJ N Prop.12\n♦\nExercise 4.2.4.4. Take again the preorder J of jurisdictions from Exercise 4.2.4.3 and the\nidea that laws are propositions. But this time, let RpV q be the set of all possible laws\n(not just those dictated to hold) that are in actuality being respected, i.e. followed, by\nall people in V . This assigns to each jurisdiction a set.\na.) Since preorders can be considered categories, does our \"the set of respected laws\"\nfunction R: ObpJq N ObpSetq extend to a functor J N Set?\nb.) What about if instead we take the meet of all these laws and assign to each ju-\nrisdiction the maximal law respected throughout. Does this assignment ObpJq N\nObpPropq extend to a functor J N Prop? 12\n♦\n12Hint: Exercises 4.2.4.3 and 4.2.4.4 will ask similar yes/no questions and at least one of these is\ncorrectly answered \"no\".\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.2.4.5\nA categorical characterization of Set\nThe category Set of sets is fundamental in mathematics, but instead of thinking of it\nas something given or somehow special, it can be shown to merely be a category with\ncertain properties, each of which can be phrased purely categorically. This was shown\nby Lawvere [Law]. A very readable account is given in [Le2].\n4.2.4.6\nCategories in computer science\nComputer science makes heavy use of trees, graphs, orders, lists, and monoids. We have\nseen that all of these are naturally viewed in the context of category theory, though\nit seems that such facts are rarely mentioned explicitly in computer science textbooks.\nHowever, categories are also used explicitly in the theory of programming languages\n(PL). Researchers in that field attempt to understand the connection between what\nprograms are supposed to do (their denotation) and what they actually cause to occur\n(their operation). Category theory provides a useful mathematical formalism in which\nto study this.\nThe kind of category most often considered by a PL researcher is what is known\nas a Cartesian closed category or CCC, which means a category T that has products\n(like A ˆ B in Set) and exponential objects (like BA in Set).\nSet is an example\nof a CCC, but there are others that are more appropriate for actual computation.\nThe objects in a PL person's CCC represent the types of the language, types such\nas integers, strings, floats. The morphisms represent computable functions, e.g.\nlength:\nstringsYNintegers. The products allow one to discuss pairs pa, bq where\na is of one type and b is of another type. Exponential objects allow one to consider\ncomputable functions as things that can be input to a function (e.g. given any com-\nputable function floatsNintegers one can consistently multiply its results by 2 and\nget a new computable function floatsNintegers. We will be getting to products in\nSection 4.5.1.8 and exponential objects in Section 4.3.2.\nBut category theory did not only offer a language for thinking about programs, it\noffered an unexpected tool called monads. The above CCC model for types allows re-\nsearchers only to discuss functions, leading to the notion of functional programming\nlanguages; however, not all things that a computer does are functions. For example,\nreading input and output, changing internal state, etc. are operations that can be per-\nformed that ruin the functional-ness of programs. Monads were found in 19?? by Moggi\n[Mog] to provide a powerful abstraction that opens the doors to such non-functional\noperations without forcing the developer to leave the category-theoretic garden of eden.\nWe will discuss monads in Section 5.3.\nWe have also seen in Section 4.2.2 that databases are well captured by the language of\ncategories. We will formalize this in Section 4.4. Throughout the remainder of this book\nwe will continue to use databases to bring clarity to concepts within standard category\ntheory.\n4.2.5\nCategories applied in science\nCategories are being used throughout mathematics to relate various subjects, as well\nas to draw out the essential structures within these subjects. For example, there is an\nactive research for \"categorifying\" classical theories like that of knots, links, and braids\n[Kho]. It is similarly applied in science, to clarify complex subjects. Here are some very\nbrief descriptions of scientific disciplines to which category theory is applied.\n\n4.3. NATURAL TRANSFORMATIONS\nQuantum field theory is was categorified by Atiyah [Ati] in the late 1980's, with much\nsuccess (at least in producing interesting mathematics). In this domain, one takes a cat-\negory in which an object is a reasonable space, called a manifold, and a morphism is a\nmanifold connecting two manifolds, like a cylinder connects two circles. Such connecting\nmanifolds are called cobordisms, and as such people refer to the category as Cob. Topo-\nlogical quantum field theory is the study of functors Cob N Vect that assign a vector\nspace to each manifold and a linear transformation of vector spaces to each cobordism.\nInformation theory 13 is the study of how to ideally compress messages so that they\ncan be sent quickly and accurately across a noisy channel.14 Invented in 1948 by Claude\nShannon, its main quantity of interest is the number of bits necessary to encode a piece\nof information. For example, the amount of information in an English sentence can be\ngreatly reduced. The fact that t's are often followed by h's, or that e's are much more\ncommon than z's, implies that letters are not being used as efficiently as possible. The\namount of bits necessary to encode a message is called its entropy and has been linked\nto the commonly used notion of the same name in physics.\nIn [BFL], Baez, Fritz, and Leinster show that entropy can be captured quite cleanly\nusing category theory.\nThey make a category FinProb whose objects are finite sets\nequipped with a probability measure, and whose morphisms are probability preserving\nfunctions. They characterize information loss as a way to assign numbers to such mor-\nphisms, subject to certain explicit constraints. They then show that the entropy of an\nobject in FinProb is the amount of information lost under the unique map to the single-\nton set t,u. This approach explicates (by way of the explicit constraints for information\nloss functions) the essential idea of Shannon's information theory, allowing it to be gener-\nalized to categories other than FinProb. Thus Baez and Leinster effectively categorified\ninformation theory.\nRobert Rosen proposed in the 1970s that category theory could play a major role in\nbiology. That story is only now starting to be fleshed out. There is a categorical account\nof evolution and memory, called Memory Evolutive Systems [EV]. There is also a paper\n[BP2] by Brown and Porter with applications to neuroscience.\n4.3\nNatural transformations\nIn this section we conclude our discussion of the Big 3, by defining natural transforma-\ntions. Category theory was originally invented to discuss natural transformations. These\nwere sufficiently conceptually challenging that they required formalization and thus the\ninvention of category theory. If we think of categories as domains (of discourse, interac-\ntion, comparability, etc.) and of functors as transformations between different domains,\nthe natural transformations compare different transformations.\nNatural transformations can seem a bit abstruse at first, but hopefully some examples\nand exercises will help.\n13To me, the subject of \"information theory\" is badly named. That discipline is devoted to finding\nideal compression schemes for messages to be sent quickly and accurately across a noisy channel. It\ndeliberately does not pay any attention to what the messages mean. To my mind this should be called\ncompression theory or redundancy theory. Information is inherently meaningful--that is its purpose--\nany theory that is unconcerned with the meaning is not really studying information per se. The people\nwho decide on speed limits for roads and highways may care about human health, but a study limited\nto deciding ideal speed limits should not be called \"human health theory\".\n14Despite what was said above, Information theory has been extremely important in a diverse array\nof fields, including computer science [MacK], but also in neuroscience [Bar], [Lin] and physics [Eve]. I'm\nnot trying to denigrate the field; I am only frustrated with its name.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.3.1\nDefinition and examples\nLet's begin with an example. There is a functor List: Set N Set, which sends a set\nX to the set ListpXq consisting of all lists whose entries are elements of X. Given a\nmorphism f : X N Y , we can transform a list with entries in X into a list with entries\nin Y by applying f to each (this was worked out in Exercise 4.1.2.20)..\nIt may seem a strange thing to contemplate, but there is also a functor List\nList: Set N Set that sends a set X to the set of lists of lists in X. If X \" ta, b, cu then\nList ListpXq contains elements like\n\"\nra, bs, ra, c, a, b, cs, rcs\n%\nand\n\"\nr s\n%\nand\n\"\nras, r s, ra, a, as\n%\n.\nWe can naturally transform a list of lists into a list by concatenation. In other words,\nfor any set X there is a function μX : List ListpXq N ListpXq which sends our lists\nabove to ra, b, a, c, a, b, c, cs and r s and ra, a, a, as, respectively. In fact, even if we use a\nfunction f : X N Y to convert a list of X's into a list of Y 's (or a list of lists of X's into\na list of lists of Y 's), the concatenation \"works right\". Take a deep breath for the precise\nstatement couched as a slogan.\nSlogan 4.3.1.1.\n\" Naturality works like this: Using a function f : X N Y to convert a list of\nlists of X's into a list of list of Y 's and then concatenating to get a simple\nlist of Y 's does the same thing as first concatenating our list of lists of\nX's into a simple list of X's and then using our function f to convert it into\na list of Y 's. \"\nLet's make this concrete. Let X \" ta, b, cu, let Y \" t1, 2, 3u, and let f : X N Y\nassign fpaq \" 1, fpbq \" 1, fpcq \" 2. Our naturality condition says the following for any\nlist of lists of X's, in particular for\n\"\nra, bs, ra, c, a, b, cs, rcs\n%\n:\n\"\nra, bs, ra, c, a, b, cs, rcs\n%\nμX\n/\n_\nList Listpfq\n\nra, b, a, c, a, b, c, cs\n_\nListpfq\n\n\"\nr1, 1s, r1, 2, 1, 1, 2s, r2s\n%\nμY\n/ r1, 1, 1, 2, 1, 1, 2, 2s\nKeep these μX in mind in the following definition--they serve as the \"components\"\nof a natural transformation List List N List of functors C N D, where C \" D \" Set.\nDefinition 4.3.1.2. Let C and D be categories and let F : C N D and G: C N D be\nfunctors. A natural transformation α from F to G, denoted α: F N G, is defined as\nfollows: one announces some constituents (A. components) and asserts that they conform\nto some laws (1. naturality squares). Specifically, one announces\nA. for each object c P ObpCq a morphism αc : Fpcq N Gpcq in D, called the c-\ncomponent of α.\nOne asserts that the following law holds:\n1. For every morphism h: c N c1 in C, the following square, called the naturality\n\n4.3. NATURAL TRANSFORMATIONS\nsquare for h, must commute:\nFpcq\n✓\nF phq\n\nαc\n/ Gpcq\nGphq\n\nFpc1q\nαc1 / Gpc1q\n(4.9)\nExample 4.3.1.3. Consider the categories C - r1s and D - r2s drawn below:\nC :\"\n0‚\np\n/ 1‚\nD :\"\nA‚\nf\n/ B‚\ng\n/ C‚ .\nConsider the functors F, G: r1s N r2s where Fp0q \" A, Fp1q \" B, Gp0q \" A, and\nGp1q \" C. The orange dots and arrows in the picture below represent the image of C\nunder F and G.\nA\nB\nC\nf\ng\nA\nB\nC\nf\ng\nf\ng\ng○f\nidA\nidB\nidC\ng○f\ng○f\nIt turns out that there is only one possible natural transformation F N G; we call\nit α and explore its naturality square. We have drawn the components of α: F N G in\ngreen. These components are α0 \" idA : Fp0q N Gp0q and α1 \" g: Fp1q N Gp1q. The\nnaturality square for p: 0 N 1 is written twice below, once with notation following that\nin (4.9) and once in local notation.\nFp0q\nα0 /\nF ppq\n\nGp0q\nGppq\n\nFp1q\nα1 / Gp1q\nA\nidA /\nf\n\nA\ng f\n\nB\ng\n/ C\n\nCHAPTER 4. BASIC CATEGORY THEORY\nIt is clear that this diagram commutes, so our components α0 and α1 satisfy the law of\nDefinition 4.3.1.2, making α a natural transformation.\nLemma 4.3.1.4. Let C and D be categories, let F, G: C N D be functors, and for every\nobject c P ObpCq, let αc : Fpcq N Gpcq be a morphism in D.\nSuppose given a path\nc0\nf1\nYN c1\nf2\nYN\nfn\nYN cn such that the naturality square\nFpci 1q\nF pfiq\n\nαci 1 / Gpci 1q\nGpfiq\n\nFpciq\nαci\n/ Gpciq\ncommutes for each 1 d i d n.\nThen the naturality square for the composite p :\"\nfn f2 f1 : c0 N cn\nFpc0q\nαc0 /\nF ppq\n\nGpc0q\nGppq\n\nFpcnq\nαcn\n/ Gpcnq\nalso commutes. In particular, the naturality square commutes for every identity mor-\nphism idc.\nProof. When n \" 0 we have a path of length 0 starting at each c P ObpCq. It vacuously\nsatisfies the condition, so we need to see that its naturality square\nFpcq\nαc\n/\nF pidcq\n\nGpcq\nGpidcq\n\nFpcq\nαc\n/ Gpcq\ncommutes. But this is clear because functors preserve identities.\nThe rest of the proof follows by induction on n. Suppose q \" fn 1 f2 f1 : c0 N\ncn 1 and p \" fn q and that the naturality squares for q and for fn commute; we need\nonly show that the naturality square for p commutes. That is, we assume the two small\nsquares commute below; but it follows that the large rectangle does too, completing the\nproof.\nFpc0q\nαc0\n/\nF pqq\n\nGpc0q\nGpqq\n\nFpcn 1q\nαcn 1 /\nF pfnq\n\nGpcn 1q\nGpfnq\n\nFpcnq\nαcn\n/ Gpcnq\n□\n\n4.3. NATURAL TRANSFORMATIONS\nExample 4.3.1.5. Let C \" D \" r1s be the linear order of length 1, thought of as a\ncategory (by Proposition 4.2.1.17). There are three functors C N D, which we can write\nas p0, 0q, p0, 1q, and p1, 1q; these are depicted left to right below.\n0‚\n/\nf\n0‚\nf\n0‚\n/\nf\n0‚\nf\n0‚z\n\nf\n0‚\nf\n1‚\nD\nB\n1‚\n1‚\n/ 1‚\n1‚\n/ 1‚\nThese are just functors so far. What are the natural transformations say α: p0, 0q N\np0, 1q? To specify a natural transformation, we must specify a component for each object\nin C. In our case α0 : 0 N 0 and α1 : 0 N 1. There is only one possible choice: α0 \" id0\nand α1 \" f. Now that we have chosen components we need to check the naturality\nsquares.\nThere are three morphisms in C, namely id0, f, id1. By Lemma 4.3.1.4, we need only\ncheck the naturality square for f. We write it twice below, once in the abstract notation\nand once in concrete notation:\nFp0q\nα0 /\nF pfq\n\nGp0q\nGpfq\n\nFp1q\nα1 / Gp1q\nid0 /\nid0\n\nf\n\nf\n/ 1\nThis commutes, so α is indeed a natural transformation.\nExercise 4.3.1.6. With notation as in Example 4.3.1.5,\na.) how many natural transformations are there p0, 0q N p1, 1q?\nb.) how many natural transformations are there p0, 0q N p0, 0q?\nc.) how many natural transformations are there p0, 1q N p0, 0q?\nd.) how many natural transformations are there p0, 1q N p1, 1q?\n♦\nExercise 4.3.1.7. Let List: Set N Set be the functor sending a set X to the set ListpXq of\nlists with entries in X. We saw above that there is a natural transformation List List N\nList given by concatenation.\na.) If someone said \"singleton lists give a natural transformation σ from idSet to List\",\nwhat might they mean? That is, for a set X, what component σX might they be\nsuggesting?\nb.) Do these components satisfy the necessary naturality squares for functions f : X N\nY ?\n♦\nExercise 4.3.1.8. Let C and D be categories, and suppose that d P ObpDq is a terminal\nobject. Consider the functor tduC : C N D that sends each object c P ObpCq to d and\neach morphism in C to the identity morphism idd on d.\n\nCHAPTER 4. BASIC CATEGORY THEORY\na.) For any other functor F : C N D, how many natural transformations are there F N\ntduC?\nb.) Let D \" Set and let d \" t,u.\nIf C \" r1s is the linear order of length 1, and\nF : C N Set is any functor, what does it mean to give a natural transformation\ntduC N F?\n♦\nApplication 4.3.1.9. In Figure 3.1 we drew a finite state machine on alphabet Σ \" ta, bu,\nand in Example 3.1.3.1 we showed the associated action table. It will be reproduced\nbelow. Imagine this was your model for understanding the behavior of some system\nwhen acted on by commands a and b. And suppose that a collaborator tells you that she\nhas a more refined notion that fits with the same data. Her notion has 6 states rather\nthan 3, but it's \"compatible\". What might that mean?\nLet's call the original state machine X and the new model Y .\nX:=\nState 0\nState 1\nState 2\na\nb\na\na\nb\nb\nY :=\nState 0\nState 1A\nState 2B\nb\nState 2A\nState 1B\nState 1C\nb\nb\nb\nb\na\na\na\na\na\na\nb\nThe action tables for these two machines are:\nOriginal model X\nID\na\nb\nState 0\nState 1\nState 2\nState 1\nState 2\nState 1\nState 2\nState 0\nState 0\nProposed model Y\nID\na\nb\nState 0\nState 1A\nState 2A\nState 1A\nState 2A\nState 1B\nState 1B\nState 2B\nState 1C\nState 1C\nState 2B\nState 1B\nState 2A\nState 0\nState 0\nState 2B\nState 0\nState 0\nHow are these models compatible? Looking at the table for Y , if one removes the\ndistinction between States 1A, 1B, 1C and between States 2A and 2B, then one returns\nwith the table for X. The table for Y is more specific, but it is fully compatible with\ntable X. The sense in which it is compatible is precisely the sense defined by there being\na natural transformation.\nRecall that M \" pListpΣq, r s, ``q is a monoid, and that a monoid is simply a category\nwith one object, say ObpMq \" t▲u (see Section 4.2.1). With Σ \" ta, bu, the monoid M\ncan be visualized as follows:\nM \"\n▲‚\na\n:\nb\nd\n\n4.3. NATURAL TRANSFORMATIONS\nRecall also that a state machine on M is simply a functor M N Set. We thus have\ntwo such functors, X and Y . A natural transformation α: Y N X would consist of a\ncomponent αm for every object m P ObpMq, such that certain diagrams commute. But\nM having only one object, we need only one function α▲: Y p▲q N Xp▲q, where Y p▲q is\nthe set of (6) states of Y and Xp▲q is the set of (3) states of X.\nThe states of Y have been named so as to make the function α▲particularly easy to\nguess.15 We need to check that two squares commute:\nY p▲q\nα▲/\nY paq\n\nXp▲q\nXpaq\n\nY p▲q\nα▲/ Xp▲q\nY p▲q\nα▲/\nY pbq\n\nXp▲q\nXpbq\n\nY p▲q\nα▲/ Xp▲q\n(4.10)\nThis can only be checked by going through and making sure certain things match, as\nspecified by (4.10); we spell it out in gory detail. The columns that should match are\nthose whose entries are written in blue.\nNaturality square for a: ▲N ▲\nY p▲q [ID]\nY paq\nα▲ Y paq\nα▲\nXpaq α▲\nState 0\nState 1A\nState 1\nState 0\nState 1\nState 1A\nState 2A\nState 2\nState 1\nState 2\nState 1B\nState 2B\nState 2\nState 1\nState 2\nState 1C\nState 2B\nState 2\nState 1\nState 2\nState 2A\nState 0\nState 0\nState 2\nState 0\nState 2B\nState 0\nState 0\nState 2\nState 0\n(4.11)\nNaturality square for b: ▲N ▲\nY p▲q [ID]\nY pbq\nα▲ Y pbq\nα▲\nXpbq α▲\nState 0\nState 2A\nState 2\nState 0\nState 2\nState 1A\nState 1B\nState 1\nState 1\nState 1\nState 1B\nState 1C\nState 1\nState 1\nState 1\nState 1C\nState 1B\nState 1\nState 1\nState 1\nState 2A\nState 0\nState 0\nState 2\nState 0\nState 2B\nState 0\nState 0\nState 2\nState 0\n(4.12)\nIn reality we need to check that for every morphism in M, such as ra, a, bs, a similar\ndiagram commutes. But this holds automatically. For example (flipping the naturality\nsquare sideways for typographical reasons)\nY p▲q\nY paq /\nα▲\n\nY p▲q\nY paq /\nα▲\n\nY p▲q\nY pbq /\nα▲\n\nY p▲q\nα▲\n\nXp▲q\nXpaq\n/ Xp▲q\nXpaq\n/ Xp▲q\nXpbq\n/ Xp▲q\n15The function α▲: Y p▲q N Xp▲q makes the following assignments: State 0 ÞN State 0, State 1A ÞN\nState 1, State 1B ÞN State 1, State 1C ÞN State 1, State 2A ÞN State 2, State 2B ÞN State 2.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nSince each small square above commutes (as checked by tables 4.11 and 4.12), the big\nouter rectangle commutes too.\nTo recap, the notion of compatibility between Y and X is one that can be checked\nand agreed upon by humans, but doing so it is left implicit, and it may be difficult to\nexplain to an outsider what exactly was agreed to, especially in more complex situations.\nIt is quite convenient to simply claim \"there is a natural transformation from Y to X.\"\n♦♦\nExercise 4.3.1.10. Let F : C N D be a functor. Suppose someone said \"the identity on\nF is a natural transformation from F to itself.\"\na.) What might they mean?\nb.) If it is somehow true, what are the components of this natural transformation?\n♦\nExample 4.3.1.11. Let r1s P ObpCatq be the free arrow category described in Exercise\n4.1.2.31 and let D be any category.\nTo specify a functor F : r1s N D requires the\nspecification of two objects, Fpv1q, Fpv2q P ObpDq and a morphism Fpeq: Fpv1q N Fpv2q\nin D. The identity and composition formulas are taken care of once that much is specified.\nTo recap, a functor F : r1s N D is the same thing as a morphism in D.\nThus, choosing two functors F, G: r1s N D is precisely the same thing as choosing\ntwo morphisms in D. Let us call them f : a0 N a1 and g: b0 N b1, where to be clear we\nhave f \" Fpeq, a0 \" Fpv0q, a1 \" Fpv1q and g \" Gpeq, b0 \" Gpv0q, b1 \" Gpv1q.\nA natural transformation α: F N G consists of two components, h0 :\" αv0 : a0 N b0\nand h1 :\" αv1 : a1 N b1, drawn as dashed lines below:\na0\nh0\n/\nf\n\nb0\ng\n\na1\nh1\n/ b1\nThe condition for α to be a natural transformation is that the above square commutes.\nIn other words, a functor r1s N D is an arrow in D and a natural transformation\nbetween two such functors is just a commutative square in D.\nExample 4.3.1.12. Recall that to any graph G we can associate the so-called paths-graph\nPathspGq, as described in Example 4.1.2.22. This is a functor Paths: Grph N Grph.\nThere is also an identity functor idGrph : Grph N Grph. A natural transformation\nη: idGrph N Paths would consist of a graph homomorphism ηG : idGrphpGq N PathspGq\nfor every graph G. But idGrphpGq \" G by definition, so we need ηG : G N PathspGq.\nRecall that PathspGq has the same vertices as G and every arrow in G counts as a path\n(of length 1). So there is an obvious graph homomorphism from G to PathspGq. It is\nnot hard to see that the necessary naturality squares commute.\nExample 4.3.1.13. For any graph G we can associate the paths-graph PathspGq, and\nnothing stops us from doing that twice to yield a new graph PathspPathspGqq. Let's\nthink through what a path of paths in G is. It's a head-to-tail sequence of arrows in\nPathspGq, meaning a head-to-tail sequence of paths in G. These composable sequences of\npaths (or \"paths of paths\") are the individual arrows in PathspPathspGqq. (The vertices\nin PathspGq and PathspPathspGqq are the same as those in G, and all source and target\nfunctions are as expected.)\n\n4.3. NATURAL TRANSFORMATIONS\nClearly, given such a sequence of paths in G, we could compose them to one big path in\nG with the same endpoints. In other words, there is graph morphism μG : PathspPathspGqq N\nPathspGq, that one might call \"concatenation\". In fact, this concatenation extends to a\nnatural transformation\nμ: Paths Paths N Paths\nbetween functors Grph N Grph. In Example 4.3.1.12, we compared a graph to its\npaths-graph using a natural transformation idGrph N Paths; here we are making a\nsimilar kind of comparison.\nRemark 4.3.1.14. In Example 4.3.1.12 we saw that there is a natural transformation\nsending each graph into its paths-graph. There is a formal sense in which a category is\nnothing more than a kind of reverse mapping. That is, to specify a category is the same\nthing as to specify a graph G together with a graph homomorphism PathspGq N G. The\nformalities involve monads, which we will discuss in Section 5.3.\nExercise 4.3.1.15. Let X and Y be sets, and let f : X N Y .\nThere is a functor\nCX : Grph N Set that sends every graph to the set X and sends every morphism\nof graphs to the identity morphism idX : X N X. This functor is called the constant\nfunctor at X. Similarly there is a constant functor CY : Grph N Set.\na.) Use f to construct a natural transformation CX N CY .\nb.) What are its components?\n♦\nExercise 4.3.1.16. For any graph pV, A, src, tgtq we can extract the set of arrows or the set\nof vertices. Since each morphism of graphs includes a function between their arrow sets\nand a function between their vertex sets, we actually have functors Ar: Grph N Set\nand Ve: Grph N Set.\na.) If someone said \"taking source vertices gives a natural transformation from Ar to\nVe\", what natural transfromation might they be referring to?\nb.) What are its components?\nc.) If a different person, say from a totally different country, were to say \"taking target\nvertices also gives a natural transformation from Ar to Ve,\" would they also be\ncorrect?\n♦\nExample 4.3.1.17 (Graph homomorphisms are natural transformations). As discussed\nabove (see Diagram 4.7), there is a category GrIn for which a functor G: GrIn N Set\nis the same thing as a graph. Namely, we have\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\nA natural transformation of two such functors α: G N G1 involves two components,\nαAr : GpArq N G1pArq and αVe : GpVeq N G1pVeq, and two naturality squares, one for\nsrc and one for tgt. This is precisely the same thing as a graph homomorphism, as\ndefined in Definition 3.3.3.1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.3.2\nVertical and horizontal composition\nIn this section we discuss two types of compositions for natural transformations. The\nterms vertical and horizontal are used to describe them; these terms come from the\nfollowing pictures:\nαo\nC\nF\n\nG\n/\nH\nBD\nβo\nC\nF1\n!\nγ1o\nG1\n= D\nF2\n!\nγ2o\nG2\n= E\nWe generally use to denote both kinds of composition, but if we want to be very clear we\nwill differentiate as follows: β α: F N H for vertical composition, and γ2 γ1 : F2 F1 YN\nG2 G1 for horizontal composition. Of course, the actual arrangement of things on a\npage of text does not correlate with verticality or horizontality--these are just names.\nWe will define them more carefully below.\n4.3.2.1\nVertical composition of natural transformations\nThe following proposition proves that functors and natural transformations (using ver-\ntical composition) form a category.\nProposition 4.3.2.2. Let C and D be categories. There exists a category, called the\ncategory of functors from C to D and denoted FunpC, Dq, whose objects are the functors\nC N D and whose morphisms are the natural transformations,\nHomFunpC,DqpF, Gq \" tα: F N G | α is a natural transformationu.\nThat is, there are identity natural transformations, natural transformations can be com-\nposed, and the identity and associativity laws hold.\nProof. We showed in Exercise 4.3.1.10 that there for any functor F : C N D, there\nis an identity natural transformation idF : F N F (its component at c P ObpCq is\nidF pcq : Fpcq N Fpcq).\nGiven a natural transformation α: F N G and a natural transformation β : G N H,\nwe propose for the composite β α the transformation γ : F N H having components\nβc αc for every c P ObpCq. To see that γ is indeed a natural transformation, one simply\nputs together naturality squares for α and β to get naturality squares for β α.\nThe associativity and identity laws for FunpC, Dq follow from those holding for mor-\nphisms in D.\n□\nNotation 4.3.2.3. We sometimes denote the category FunpC, Dq by DC.\nExample 4.3.2.4. Recall from Exercise 4.1.2.38 that there is a functor Ob: Cat N Set\nsending a category to its set of objects. And recall from Example 4.1.2.35 that there\nis a functor Disc: Set N Cat sending a set to the discrete category with that set of\nobjects (all morphisms in DiscpSq are identity morphisms). Let P : Cat N Cat be the\ncomposition P \" Disc Ob. Then P takes a category and makes a new category with\nthe same objects but no morphisms. It's like crystal meth for categories.\n\n4.3. NATURAL TRANSFORMATIONS\nLet idCat : Cat N Cat be the identity functor. There is a natural transformation\ni: P N idCat. For any category C, the component iC : PpCq N C is pretty easily under-\nstood. It is a morphism of categories, i.e. a functor. The two categories PpCq and C\nhave the same set of objects, namely ObpCq, so our functor is identity on objects; and\nPpCq has no non-identity morphisms, so nothing else needs be specified.\nExercise 4.3.2.5. Let C \"\nA‚ be the category with ObpCq \" tAu, and HomCpA, Aq \"\ntidAu. What is FunpC, Setq? In particular, characterize the objects and the morphisms.\n♦\nExercise 4.3.2.6. Let n P N and let n be the set with n elements, considered as a discrete\ncategory. 16 In other words, we write n to mean what should really be called Discpnq.\nDescribe the category Funp3, 2q.\n♦\nExercise 4.3.2.7. Let 1 denote the discrete category with one object, and let C be any\ncategory.\na.) What are the objects of Funp1, Cq?\nb.) What are the morphisms of Funp1, Cq?\n♦\nExample 4.3.2.8. Let 1 denote the discrete category with one object (also known as the\ntrivial monoid). For any category C, we investigate the category D :\" FunpC, 1q. Its\nobjects are functors C N 1. Such a functor F assigns to each object in C an object in 1\nof which there is one; so there is no choice in what F does on objects. And there is only\none morphism in 1 so there is no choice in what F does on morphisms. The upshot is\nthat there is only one object in D, let's call it F, in D, so D is a monoid. What are its\nmorphisms?\nA morphism α: F N F in D is a natural transformation of functors.\nFor every\nc P ObpCq we need a component αc : Fpcq N Fpcq, which is a morphism 1 N 1 in 1.\nBut there is only one morphism in 1, namely id1, so there is no choice about what these\ncomponents should be: they are all id1. The necessary naturality squares commute, so\nα is indeed a natural transformation. Thus the monoid D is the trivial monoid; that is,\nFunpC, 1q - 1 for any category C.\nExercise 4.3.2.9. Let 0 represent the discrete category on 0 objects; it has no objects and\nno morphisms. Let C be any category. What is Funp0, Cq?\n♦\nExercise 4.3.2.10. Let r1s denote the free arrow category as in Exercise 4.1.2.31, and\nlet C be the graph indexing category from (4.7).\nDraw the underlying graph of the\ncategory Funpr1s, Cq, and then specify which pairs of paths in that graph correspond to\ncommutative diagrams in Funpr1s, Cq.\n♦\n16When we have a functor, such as Disc: Set N Cat, we may sometimes say things like \"Let S\nbe a set, considered as a category\" (or in general, given a functor F : C N D, we may say \"consider\nc P ObpCq, taken as an object in D\"). What this means is that we want to take ideas and methods\navailable in Cat and use them on our set S. Having our functor Disc lying around, we use it to move S\ninto Cat, as DiscpSq P ObpCatq, upon which we can use our intended methods. However, our human\nminds get bogged down seeing DiscpSq because it is bulky (e.g. FunpDiscp3q, Discp2qq is harder to read\nthan Funp3, 2q). So we abuse notation and write S in place of DiscpSq. To add insult to injury, we\ntalk about S as though it was still a set, e.g. discussing its elements rather than its objects. This kind\nof conceptual abbreviation is standard practice in mathematical discussion because it eases the mental\nburden for experts, but when one says \"Let S be an X considered as a Y \" the other may always ask,\n\"How again are you considering X's to be Y 's?\" and expect a functor .\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.3.2.11\nNatural isomorphisms\nLet C and D be categories. We have defined a category FunpC, Dq whose objects are\nfunctors C N D and whose morphisms are natural transformations.\nWhat are the\nisomorphisms in this category?\nLemma 4.3.2.12. Let C and D be categories and let F, G: C N D be functors. A natural\ntransformation α: F N G is an isomorphism in FunpC, Dq if and only if the component\nαc : Fpcq N Gpcq is an isomorphism for each object c P ObpCq. In this case α is called a\nnatural isomorphism.\nProof. First suppose that α is an isomorphism with inverse β : G N F, and let βc : Gpcq N\nFpcq denote its c component. We know that α β \" idG and β α \" idF . Using the\ndefinitions of composition and identity given in Proposition 4.3.2.2, this means that for\nevery c P ObpCq we have αc βc \" idGpcq and βc αc \" idF pcq; in other words αc is an\nisomorphism.\nSecond suppose that each αc is an isomorphism with inverse βc : Gpcq N Fpcq. We\nneed to see that these components assemble into a natural transformation; i.e. for every\nmorphism h: c N c1 in C the right-hand square\nFpcq\n✓\nF phq\n\nαc\n/ Gpcq\nGphq\n\nFpc1q\nαc1 / Gpc1q\nGpcq\n?\nGphq\n\nβc\n/ Fpcq\nF phq\n\nGpc1q\nβc1\n/ Fpc1q\ncommutes. We know that the left-hand square commutes because α is a natural trans-\nformation; we have labeled each square with a ? or a ✓accordingly. In the following\ndiagram we want to show that the left-hand square commutes. We know that the middle\nsquare commutes.\nGpcq\nidGpcq\n&\n?\nGphq\n\nβc\n/ Fpcq\n✓\nF phq\n\nαc\n/ Gpcq\n?\nGphq\n\nβc\n/ Fpcq\nF phq\n\nGpc1q\nβc1\n/ Fpc1q\nαc1\n/\nidF pc1q\nGpc1q\nβc1\n/ Fpc1q\nTo complete the proof we need only to show that Fphq βc \" βc1 Gphq. This can be\nshown by a \"diagram chase.\" We go through it symbolically, for demonstration.\nFphq βc \" βc1 αc1 Fphq βc \" βc1 Gphq αc βc \" βc1 Gphq.\n□\nExercise 4.3.2.13. Recall from Application 4.3.1.9 that a finite state machine on alphabet\nΣ can be understood as a functor M N Set, where M \" ListpΣq is the free monoid\n\n4.3. NATURAL TRANSFORMATIONS\ngenerated by Σ. In that example we also discussed how natural transformations provide\na nice language for changing state machines. Describe what kinds of changes are made\nby natural isomorphisms.\n♦\n4.3.2.14\nHorizontal composition of natural transformations\nExample 4.3.2.15 (Whiskering). Suppose that M \" Listpa, bq and M1 \" Listpm, n, pq\nare free monoids, and let F : M1 N M be given by sending rms ÞN ras, rns ÞN rbs, and\nrps ÞN rb, a, as. An application of this might be if the sequence rb, a, as was commonly\nused in practice and one wanted to add a new button just for that sequence.\nRecall Application 4.3.1.9. Let X : M N Set and Y : M N Set be the functors, and\nlet α: Y N X be the natural transformation found there. We reproduce them here:\nState 0\nState 1\nState 2\na\nb\na\na\nb\nb\nState 0\nState 1A\nState 2B\nb\nState 2A\nState 1B\nState 1C\nb\nb\nb\nb\na\na\na\na\na\na\nb\nOriginal model X : M N Set\nID\na\nb\nState 0\nState 1\nState 2\nState 1\nState 2\nState 1\nState 2\nState 0\nState 0\nProposed model Y : M N Set\nID\na\nb\nState 0\nState 1A\nState 2A\nState 1A\nState 2A\nState 1B\nState 1B\nState 2B\nState 1C\nState 1C\nState 2B\nState 1B\nState 2A\nState 0\nState 0\nState 2B\nState 0\nState 0\nWe can compose X and Y with F as in the diagram below\nM1\nF\n/ M\nY\n(\nX\nαo\nSet\nto get functors Y F and X F, both of type M1 N Set. What would these be? 17\nX F\nID\nm\nn\np\nState 0\nState 1\nState 2\nState 1\nState 1\nState 2\nState 1\nState 0\nState 2\nState 0\nState 0\nState 2\nY F\nID\nm\nn\np\nState 0\nState 1A\nState 2A\nState 1A\nState 1A\nState 2A\nState 1B\nState 0\nState 1B\nState 2B\nState 1C\nState 0\nState 1C\nState 2B\nState 1B\nState 0\nState 2A\nState 0\nState 0\nState 2A\nState 2B\nState 0\nState 0\nState 2A\nThe map α is what sent both State 1A and State 1B in Y to State 1 in X, and\nso on. We can see that \"the same α works now:\" the p column of the table respects\nthat mapping. But α was a natural transformation Y N X where as we need a natural\ntransformation Y F N X F. This is called whiskering. It is a kind of horizontal\ncomposition of natural transformation.\n17The p-column comes from applying b then a then a, as specified above by F.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nDefinition 4.3.2.16 (Whiskering). Let B, C, D, and E be categories, let G1, G2 : C N D\nbe functors, and let α: G1 N G2 a natural transformation. Suppose that F : B N C\n(respectively H : D N E) is a functor, depicted below:\nB\nF\n/ C\nαo\nG1 \"\nG2\n?D\n\nrespectively,\nC\nαo\nG1 \"\nG2\n?D\nH\n/ E\n\n‹‹‚,\nThen the pre-whiskering of α by F, denoted α F : G1 F N G2 F (respectively, the\npost-whiskering of α by H, denoted H α: H G1 N H G2) is defined as follows.\nFor each b P ObpBq the component pα Fqb : G1 Fpbq N G2 Fpbq is defined to\nbe αF pbq.\n(Respectively, for each c P ObpCq the component pH αqc : H G1pcq N\nH G2pcq is defined to be Hpαcq.) Checking that the naturality squares (in each case)\nis straightforward.\nThe rest of this section can safely be skipped; I include it only for my own sense of\ncompleteness.\nDefinition 4.3.2.17 (Horizontal composition of natural transformations). Let B, C, and\nD be categories, let F1, F2 : B N C and G1, G2 : C N D be functors, and let α: F1 N F2\nand β : G1 N G2 be natural transformations, as depicted below:\nB\nαo\nF1\n!\nF2\n? C\nβo\nG1 \"\nG2\n?D\nBy pre- and post-whiskering in one order or the other we get the following diagram\nG1 F1\nG1 α /\nβ F1\n\nG1 F2\nβ F2\n\nG2 F1\nG2 α / G2 F2\nIt is straightforward to show that this diagram commutes, so we can take the composition\nto be our definition of the horizontal composition\nβ α: G1 F1 N G2 F2.\nRemark 4.3.2.18. Whiskering a natural transformation α with a functor F is the same\nthing as horizontally composing α with the identity natural transformation idF . This\nis true for both pre- and post- whiskering. For example in the notation of Definition\n4.3.2.16 we have\nα F \" α idF\nand\nH α \" idH α.\nRemark 4.3.2.19. All of the above is somehow similar to the world of paths inside a\ndatabase schema S, as seen in Definition 3.5.2.3. Indeed, a congruence on the paths of S\nis an equivalence relation that is closed under composition. The equivalence relation part\nis analogous to the fact that natural transformations can be composed vertically. The\nclosure under composition part (Properties (3) and (4) in Definition 3.5.2.3) is analogous\nto pre- and post whiskering. See also Lemma 3.5.2.5.\nThis is being mentioned only as a curiosity and a way for the reader to draw connec-\ntions, not with any additional purpose at this time.\n\n4.3. NATURAL TRANSFORMATIONS\nTheorem 4.3.2.20.\nα1o\nβ1o\nC\nF1\n\nF2\n/\nF3\nBD\nG1\n\nG2\n/\nG3\nBE\nα2o\nβ2o\nGiven a setup of categories, functors, and natural transformations as above, we have\npβ2 β1q pα2 α1q \" pβ2 α2q pβ1 α1q.\nProof. One need only observe that each square in the following diagram commutes, so\nfollowing the outer path pβ2 β1q pα2 α1q yields the same morphism as following the\ndiagonal path ; pβ2 α2q pβ1 α1q:\nG1F1\nG1 α1/\nβ1 F1\n\nG1F2\nG1 α2/\nβ1 F2\n\nG1F3\nβ1 F3\n\nG2F1\nG2 α1/\nβ2 F1\n\nG2F2\nG2 α2/\nβ2 F2\n\nG2F3\nβ2 F3\n\nG3F1 G3 α1\n/ G3F2 G3 α2\n/ G3F3\n□\n4.3.3\nThe category of instances on a database schema\nIn Section 4.2.2 we showed that schemas are presentations of categories, and we will\nshow in Section 4.4 that in fact the category of schemas is equivalent to the category\nof categories. In this section we therefore take license to blur the distinction between\nschemas and categories.\nIf C is a schema, i.e. a category, then as we discussed in Section 4.2.2.5, an instance\non C is a functor I : C N Set. But now we have a notion beyond categories and functors,\nnamely that of natural transformations. So we make the following definition.\nDefinition 4.3.3.1. Let C be a schema (or category). The category of instances on C,\ndenoted C-Set, is FunpC, Setq. Its objects are C-instances (i.e. functors C N Setq and\nits morphisms are natural transformations.\nRemark 4.3.3.2. One might object to Definition 4.3.3.1 on the grounds that database\ninstances should not be infinite. This is a reasonable perspective, so it is a pleasant fact\nthat the above definition can be modified easily to accomodate it. The subcategory Fin\n(see Example 4.1.1.4) of finite sets can be substituted for Set in Definition 4.3.3.1. One\ncould define the category of finite instances on C as C Fin \" FunpC, Finq. Almost all\nof the ideas in this book will make perfect sense in C Fin.\nNatural transformations should serve as some kind of morphism between instances on\nthe same schema. How are we to interpret a natural transformation α: I N J between\ndatabase instances I, J : C N Set?\n\nCHAPTER 4. BASIC CATEGORY THEORY\nOur first clue comes from Application 4.3.1.9.\nThere we considered the case of\na monoid M, and we thought about a natural transformation between two functors\nX, Y : M N Set, considered as different finite state machines. The notion of natural\ntransformation captured the idea of one model being a refinement of another. This same\nkind of idea works for databases with more than one table (categories with more than\none object), but the whole thing is a bit opaque. Let's work it through slowly.\nExample 4.3.3.3. Let us consider the terminal schema, 1 - ‚Grapes . An instance is a\nfunctor 1 N Set and it is easy to see that this is the same thing as just a set. A natural\ntransformation α: I N J is a function from set I to set J. In the standard table view,\nwe might have I and J as below:\nGrapes pIq\nID\nGrape 1\nGrape 3\nGrape 4\nGrapes pJq\nID\nJan1-01\nJan1-02\nJan1-03\nJan1-04\nJan3-01\nJan4-01\nJan4-02\nThere are 343 natural transformations I N J. Perhaps some of them make more sense\nthan others; e.g. we could hope that the numbers in I corresponded to the numbers after\nthe dash in J, or perhaps to what seems to be the date in January. But it could be that\nthe rows in J correspond to batches, and all three grapes in I are part of the first batch\non Jan-1. The notion of natural transformation is a mathematical one.\nExercise 4.3.3.4. Recall the notion of set-indexed sets from Definition 2.7.6.12. Let A be\na set, and come up with a schema A such that instances on A are A-indexed sets. Is our\ncurrent notion of morphism between instances (i.e. natural transformations) well-aligned\nwith the above definition of \"mapping of A-indexed sets\"?\n♦\nFor a general schema (or category) C, let us think through what a morphism α: I N J\nbetween instances I, J : C N Set is. For each object c P ObpCq there is a component\nαc : Ipcq N Jpcq. This means that just like in Example 4.3.3.3, there is for each table c\na function from the rows in I's manifestation of c to the rows in J's manifestation of c.\nSo to make a natural transformation, such a function has to be specified table by table.\nBut then we have to contend with naturality squares, one for every arrow in C. Arrows\nin C correspond to foreign key columns in the database. The naturality requirement was\nalready covered in Application 4.3.1.9 (and see especially how (4.10) is checked in (4.11)\nand (4.12)).\nExample 4.3.3.5. We saw in Section 4.2.1.20 that graphs can be regarded as functors\nG N Set, where G - GrIn is the \"schema for graphs\" shown here:\nG :\"\nArrow\n‚\nsrc /\ntgt /\nVertex\n‚\nA database instance I : G N Set on G consists of two tables. Here is an example\n\n4.3. NATURAL TRANSFORMATIONS\ninstance:\nI :\"\n‚v\nf\n/ ‚w\nh\n=\ng\n#\n‚x\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nTo discuss natural transformations, we need two instances. Here is another, J : G N Set,\nJ :\"\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nu‚\nArrow pJq\nID\nsrc\ntgt\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pJq\nID\nq\nr\ns\nt\nu\nTo give a natural transformation α: I N J, we give two components: one for arrows\nand one for vertices. We need to say where each vertex in I goes in J and we need to\nsay where each arrow in I goes in J. The naturality squares insist that if we specify\nthat g ÞN j, for example, then we better specify thatw ÞN r and that x ÞN s. What a\ncomputer is very good at, but a human is fairly slow at, is checking that a given pair of\ncomponents (arrows and vertices) really is natural.\nThere are 8000 ways to come up with component functions αArrow and αVertex, but\nprecisely four natural transformations, i.e. four graph homomorphisms, I N J; the other\n7996 are haphazard flingings of arrows to arrows and vertices to vertices without any\nregard to sources and targets. We briefly describe the four now.\nFirst off, nothing can be sent to u because arrows must go to arrows and u touches\nno arrows. If we send v ÞN q then f must map to i, and w must map to r, and both g\nand h must map to j, and x must map to s. If we send v ÞN r then there are two choices\nfor g and h. If we send v ÞN s then there's one way to obtain a graph morphism. If we\ntry to send v ÞN? t, we fail. All of this can be seen by staring at the tables rather than\nat the pictorial representations of the graphs; the human eye understands these pictures\nbetter, but the computer understands the tables better.\nExercise 4.3.3.6. If I, J : G N Set are as in Example 4.3.3.5, how many natural trans-\nformations are there J N I?\n♦\nExercise 4.3.3.7. Let YA : G N Set denote the instance below:\nArrow pYAq\nID\nsrc\ntgt\na\nv0\nv1\nVertex pYAq\nID\nv0\nv1\nLet I : G N Set be as in Example 4.3.3.5.\na.) How many natural transformations are there YA N I?\nb.) With J as above, how many natural transformations are there YA N J?\nc.) Do you have any conjecture about the way natural transformations YA N X behave\nfor arbitrary graphs X : G N Set?\n\nCHAPTER 4. BASIC CATEGORY THEORY\n♦\nIn terms of databases, this notion of instance morphism I N J is fairly benign. For\nevery table its a mapping from the set of rows in I's version of the table to J's version\nof the table, such that all the foreign keys are respected. We will see that this notion of\nmorphism has excellent formal properties, so that projections, unions, and joins of tables\n(the typical database operations) would be predicted to be \"obviously interesting\" by a\ncategory theorist who had no idea what a database was. 18\nHowever, something is also missing from the natural transformation picture. A very\nimportant occurrence in the world of databases is the update. Everyone can understand\nthis: a person makes a change in one of the tables, like changing your address from\nCambridge, MA to Hereford, UK. Most such arbitrary changes of database instance are\nnot \"natural\", in that the new linking pattern is incompatible with the old.\nIt is interesting to consider how updates of C-instances should be understood category\ntheoretically. We might want a category UpdC whose objects are C-instances and whose\nmorphisms are updates. But then what is the composition formula? Is there a unique\nmorphism I N J whenever J can be obtained as an update on I? Because in that case,\nwe would be defining UpdC to be the indiscrete category on the set of C-instances (see\nExample 4.3.4.3).\nExercise 4.3.3.8. Research project: Can you come up with a satisfactory way to model\ndatabase updates category-theoretically? Let N be the category\nrNs :\"\n0‚\n/ 1‚\n/ 2‚\n/\nrepresenting a discrete timeline. A place to start might be to use something like the slice\ncategory Cat{rNs where the fiber over each object in N is a snapshot of the database in\ntime. Can you make this work?\n♦\n4.3.4\nEquivalence of categories\nWe have a category Cat of categories, and in every category there is a notion of isomor-\nphism between objects: one morphism each way, such that each round-trip composition\nis the identity. An isomorphism in Cat, therefore, takes place between two categories,\nsay C and D: it is a functor F : C N D and a functor G: D N C such that G F \" idC\nand F G \" idD.\nIt turns out that categories are often similar enough to be considered equivalent\nwithout being isomorphic. For this reason, the notion of isomorphism is considered \"too\nstrong\" to be useful for categories. The feeling to a category theorist might be akin to\nsaying that two material samples are the same if there is an atom-by-atom matching, or\nthat two words are the same if they are written in the same font, of the same size, by\nthe same person, in the same state of mind.\nAs reasonable as isomorphism is as a notion in most categories, it fails to be the\n\"right notion\" about categories. The reason is that in categories there are objects and\nmorphisms, whereas when we talk about categories, we have categories and functors, plus\nnatural transformations. These serve as mappings between mappings, and this is not\npart of the structure of an ordinary category. In cases where a category C does have\nsuch mappings between mappings, it is often a \"better notion\" if we take that extra\n18More precisely, given a functor between schemas F : C N D, the pullback ∆F : D-Set N C-Set, its\nleft ΣF and its right adjoint ΠF constitute these important queries. See Section 5.1.4.\n\n4.3. NATURAL TRANSFORMATIONS\nstructure into account, like we will for categories. This whole subject leads us to the\nstudy of 2-categories (or n-categories, or 8-categories), which we do not discuss in this\nbook. See, for example, [Le1] for an introduction.\nRegardless, our purpose now is to explain this \"good notion\" of sameness for cat-\negories, namely equivalences of categories, which appropriately take natural transfor-\nmations into account. Instead of \"functors going both ways with round trips equal to\nidentity\", which is required in order to be an isomorphism of categories, equivalence of\ncategories demands \"functors going both ways with round trips isomorphic to identity\".\nDefinition 4.3.4.1 (Equivalence of categories). Let C and C1 be categories. A functor\nF : C N C1 is called an equivalence of categories, and denoted F : C\n»\nYN C1, 19 if there exists\na functor F 1 : C1 N C and natural isomorphisms α: idC\n-\nYN F 1 F and α1 : idC1\n-\nYN F F 1.\nIn this case we say that F and F 1 are mutually inverse equivalences.\nUnpacking a bit, suppose we are given functors F : C N C1 and F 1 : C1 N C. We want\nto know something about the roundtrips on C and on C1; we want to know the same\nkind of information about each roundtrip, so let's concentrate on the C side. We want\nto know something about F 1 F : C N C, so let's name it i: C N C; we want to know\nthat i is a natural isomorphism. That is, for every c P ObpCq we want an isomorphism\nαc : c -\nYN ipcq, and we want to know that these isomorphisms are picked carefully enough\nthat given g: c N c1 in C, the choice of isomorphisms for c and c1 are compatible,\nc\nαc /\ng\n\nipcq\nipgq\n\nc1\nαc1 / ipc1q.\nTo be an equivalence, the same has to hold for the other roundtrip, i1 \" F F 1 : C1 N C1.\nExercise 4.3.4.2. Let C and C1 be categories. Suppose that F : C N C1 is an isomorphism\nof categories.\na.) Is it an equivalence of categories?\nb.) What are the components of α and α1 (with notation as in Definition 4.3.4.1)?\n♦\nExample 4.3.4.3. Let S be a set and let S ˆ S D S ˆ S be the complete relation on\nS, which is a preorder KS. Recall from Proposition 4.2.1.17 that we have a functor\ni: PrO N Cat, and the resulting category ipKSq is called the indiscrete category on S;\nit has objects S and a single morphism between every pair of objects. Here is a picture\nof Kt1,2,3u:\n1‚\n\n)\n\n2‚ q\ni\n\n3‚D\nA\nQ\n19The notation » has already been used for equivalences of paths in a schema. We do not mean to\nequate these ideas; we are just reusing the symbol. Hopefully no confusion will arise.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nIt is easy check that K1, the indiscrete category on one element, is isomorphic to 1,\nthe discrete category on one object, also known as the terminal category (see Exercise\n4.1.2.37). The category 1 consists of one object, its identity morphism, and nothing else.\nThe only way that KS can be isomorphic to 1 is if S has one element.\n20 On the\nother hand, there is an equivalence of categories\nKS » 1\nfor every set S % H.\nIn fact, there are many such equivalences, one for each element of S. To see this,\nlet S be a nonempty set and choose an element s0 P S. For every s P S, there is a\nunique isomorphism ks : s\n-\nYN s0 in KS. Let F : KS N 1 be the only possible functor\n(see Exercise 4.1.2.37), and let F 1 : 1 N KS send the unique object in 1 to the object s0.\nNote that F 1 F \" id1 : 1 N 1 is the identity, but that F F 1 : KS N KS sends\neverything to s0. Let α \" id1 and define α1 : idKS N F F 1 by α1\ns \" ks. Note that α1\ns is\nan isomorphism for each s P ObpKSq, and note that α1 is a natural transformation (hence\nnatural isomorphism) because every possible square commutes in KS. This completes\nthe proof, initiated in the paragraph above, that the category KS is equivalent to 1 for\nevery nonempty set S, and that this fact can be witnessed by any element s0 P S.\nExample 4.3.4.4. Consider the category FLin, described in Example 4.1.1.11, of finite\nnonempty linear orders. For every natural number n P N, let rns P ObpFLinq denote the\nlinear order shown in Example 3.4.1.7. Define a category ∆whose objects are given by\nObp∆q \" trns | n P Nu and with Hom∆prms, rnsq \" HomFLinprms, rnsq. The difference\nbetween FLin and ∆is only that objects in FLin may have \"funny labels\", e.g.\n5‚\n/ x‚\n/ \"Sam\"\n‚\nwhereas objects in ∆all have standard labels, e.g.\n0‚\n/ 1‚\n/ 2‚\nClearly FLin is a much larger category, and yet feels like it is \"pretty much the same\nas\" ∆. Justly, they are equivalent, FLin » ∆.\nThe functor F 1 : ∆N FLin is the inclusion; the functor F : FLin N ∆sends every\nfinite nonempty linear order X P ObpFLinq to the object FpXq :\" rns P ∆, where\nObpXq - t0, 1, . . . , nu. For each such X there is a unique isomorphism αX : X\n-\nYN rns,\nand these fit together into 21 the required natural isomorphism idFLin N F 1 F. The\nother natural isomorphism α1 : id∆N F F 1 is the identity.\nExercise 4.3.4.5. Recall from Definition 2.1.2.16 that a set X is called finite if there\nexists a natural number n P N and an isomorphism of sets X N n. Let Fin denote the\ncategory whose objects are the finite sets and whose morphisms are the functions. Let\nS denote the category whose objects are the sets n and whose morphisms are again the\nfunctions. For every object X P ObpFinq there exists an isomorphism pX : X N n for\nsome unique object n P ObpSq. Find an equivalence of categories Fin »\nYN S.\n♦\n20One way to see this is that by Exercise 4.1.2.38, we have a functor Ob: Cat N Set, and we know\nby Exercise 4.1.2.24 that functors preserve isomorphisms, so an isomorphism between categories must\nrestrict to an isomorphism between their sets of objects. The only sets that are isomorphic to 1 have\none element.\n21The phrase \"these fit together into\" is suggestive shorthand for, and thus can be replaced with, the\nphrase \"the naturality squares commute for these components, so together they constitute\".\n\n4.3. NATURAL TRANSFORMATIONS\nExercise 4.3.4.6. We say that two categories C and D are equivalent if there exists an\nequivalence of categories between them. Show that the relation of \"being equivalent\" is\nan equivalence relation on ObpCatq.\n♦\nExample 4.3.4.7. Consider the group Z2 :\" pt0, 1u, 0, `q, where 1`1 \" 0. As a category,\nZ2 has one object ▲and two morphisms, namely 0, 1, such that 0 is the identity. Since\nZ2 is a group, the morphism 1: ▲N ▲must have an inverse x, meaning 1 ` x \" 0, and\nx \" 1 is the only solution.\nThe point is that the morphism 1 in Z2 is an isomorphism. Let C \" 1 be the terminal\ncategory as in Exercise 4.1.2.37. One might accidentally believe that C is equivalent\nto Z2, but this is not the case! The argument in favor of the accidental belief is that\nwe have unique functors F : Z2 N C and F 1 : C N Z2 (and this is true); the roundtrip\nF F 1 : C N C is the identity (and this is true); and for the roundtrip F 1 F : Z2 N Z2\nboth morphisms in Z2 are isomorphisms, so any choice of morphism α▲: ▲N F 1 Fp▲q\nwill be an isomorphism (and this is true). The problem is that no such α▲will be a\nnatural transformation.\nWhen we roundtrip F 1 F : Z2 N Z2, the image of 1: ▲N ▲is F 1 Fp1q \" 0 \" id▲.\nSo the naturality square for the morphism 1 looks like this:\n▲\nα▲\n/\n\n▲\n0\"F 1 F p1q\n\n▲\nα▲\n/ ▲\nwhere we still haven't decided whether we want α▲to be 0 or 1. Unfortunately, neither\nchoice works (i.e. for neither choice will the diagram commute) because x ` 1 % x ` 0 in\nZ2.\nDefinition 4.3.4.8 (Skeleton). Let C be a category. We saw in Lemma 4.1.1.21 that\nthe relation of \"being isomorphic\" is an equivalence relation - on ObpCq. An election in\nC is a choice E of the following sort:\n- for each --equivalence class S D ObpCq a choice of object sE P S, called the elected\nobject for S, and\n- for each object c P ObpCq a choice of isomorphism ic : sE N c and jc : c N sE with\nic jc \" idc and jc ic \" idsE, where sE is an elected object (depending on c).\nGiven an election E in C, there is a category called the E-elected skeleton of C, denoted\nSkelEpCq, whose objects are the elected objects and whose morphisms s N t for any\nelected objects s, t P ObpCq are given by HomSkelEpCqps, tq \" HomCps, tq. Any object\nc P ObpCq is isomorphic to a unique elected object sE; we refer to sE as the elected rep-\nresentative of c; we refer to the isomorphisms ic and jc as the representing isomorphisms\nfor c.\nProposition 4.3.4.9. Let C be a category and let E be an election in C. There is an\nequivalence of categories\nSkelEpCq » C.\nProof. The functor F 1 : SkelEpCq N C is the inclusion. The functor F : C N SkelEpCq\nsends each object in C to its elected representative. Given objects c, c1 P ObpCq with\n\nCHAPTER 4. BASIC CATEGORY THEORY\nelected representatives s, t respectively, and given a morphism g: c N c1 in C, let ic, jc, ic1,\nand jc1 be the representing isomorphisms, and define Fpgq: s N t to be the composite\ns\nic\n/ c\ng\n/ c1\njc1\n/ t.\nThis is functorial because it sends the identity to the identity and Fpg g1q \" Fpgq Fpg1q.\nThe composite F F 1 : SkelEpCq N SkelEpCq is the identity. For each c P ObpCq define\nαc : c -\nYN F 1 Fpcq by αc :\" jc. Given g: c N c1 the required naturality square is shown\nto the left below:\nc\njc\n/\ng\n\n?\ns\nic\n/\nF 1 F pgq\n\nc\ng\n\nc1\nj1\nc\n/ t\nc1\nj1\nc\no\nThe right-hand part commutes by definition of F and F 1; i.e. j1 g ic \" F 1 Fpgq. The\nleft-hand square commutes because ic jc \" idc.\n□\nDefinition 4.3.4.10. A skeleton of C is a category S, equivalent to C, such that for any\ntwo objects s, s1 P ObpSq, if s - s1 then s \" s1.\nExercise 4.3.4.11. Let P be a preorder (considered as a category).\na.) If P1 is a skeleton of P, is it a partial order?\nb.) Is every partial order the skeleton of some preorder?\n♦\nDefinition 4.3.4.12 (Full and faithful functors). Let C and D be categories, and\nlet F : C N D be a functor.\nFor any two objects c, c1 P ObpCq, we have a function\nHomF pc, c1q: HomCpc, c1q N HomDpFpcq, Fpc1qq guaranteed by the definition of functor.\nWe say that F is a full functor if HomF pc, c1q is surjective for every c, c1. We say that\nF is a faithful functor if HomF pc, c1q is injective for every c, c1. We say that F is a fully\nfaithful functor if HomF pc, c1q is bijective for every c, c1.\nExercise 4.3.4.13. Let 1 and 2 be the discrete categories on one and two objects, respec-\ntively. There is only one functor 2 N 1.\na.) Is it full?\nb.) Is it faithful?\n♦\nExercise 4.3.4.14. Let 0 denote the empty category, and let C be any category. There is\na unique functor F : 0 N C.\na.) For general C will F be full?\nb.) For general C will F be faithful?\nc.) For general C will F be an equivalence of categories?\n\n4.4. CATEGORIES AND SCHEMAS ARE EQUIVALENT, CAT » SCH\n♦\nProposition 4.3.4.15. Let C and C1 be categories and let F : C N C1 be an equivalence\nof categories. Then F is fully faithful.\nProof. Suppose F is an equivalence, so we can find a functor F 1 : C1 N C and natural\nisomorphisms α: idC\n-\nYN F 1 F and α1 : idC1\n-\nYN F F 1. We need to know that for any\nobjects c, d P ObpCq, the map\nHomF pc, dq: HomCpc, dq N HomC1pFc, Fdq\nis bijective. Consider the following diagram\nHomCpc, dq\nHomF pc,dq /\nα\n&\nHomC1pFc, Fdq\nα1\n(\nHomF 1pF c,F dq\n\nHomCpF 1Fc, F 1Fdq\nHomF pF 1F c,F 1F dq\n/ HomC1pFF 1Fc, FF 1Fdq\nThe fact that α is bijective implies that the vertical function is surjective. The fact that\nα1 is bijective implies that the vertical function is injective, so it is bijective. This implies\nthat HomF pc, dq is bijective as well.\n□\nExercise 4.3.4.16. Let Z2 be the group (as category) from Example 4.3.4.7. Are there\nany fully faithful functors Z2 N 1?\n♦\n4.4\nCategories and schemas are equivalent, Cat » Sch\nPerhaps it is intuitively clear that schemas are somehow equivalent to categories, and in\nthis section we make that precise. The basic idea was already laid out in Section 4.2.2.\n4.4.1\nThe category Sch of schemas\nRecall from Definition 3.5.2.6 that a schema consists of a pair C :\" pG, »q, where G \"\npV, A, src, tgtq is a graph and » is a congruence, meaning a kind of equivalence relation\non the paths in G (see Definition 3.5.2.3. If we think of a schema as being analogous to a\ncategory, what should fulfill the role of functors? That is, what are to be the morphisms\nin Sch?\nUnfortunately, ones first guess may give the wrong notion if we want an equivalence\nSch » Cat. Since objects in Sch are graphs with additional structure, one might imagine\nthat a morphism C N C1 in Sch should be a graph homomorphism (as in Definition\n3.3.3.1) that preserves said structure. But graph homomorphisms require that arrows be\nsent to arrows, whereas we are more interested in paths than in individual arrows--the\narrows are merely useful for presentation.\nIf instead we define morphisms between schemas to be maps that send paths in C to\npaths in C1, subject to the requirements that path endpoints, path concatenations, and\npath equivalences are preserved, this will turn out to give the correct notion. And since\n\nCHAPTER 4. BASIC CATEGORY THEORY\na path is a concatenation of its arrows, it suffices to give a function F from the arrows of\nC to the paths of C1, which automatically takes care of the first two requirements above;\nwe must only take care that F preserves path equivalences.\nRecall from Examples 4.1.2.22 and 4.3.1.13 the paths-graph functor Paths: Grph N\nGrph, the paths of paths functor Paths Paths: Grph N Grph, and the natural\ntransformations for any graph G,\nηG : G N PathspGq\nand\nμG : PathspPathspGqq N PathspGq.\n(4.13)\nThe function ηG spells out the fact that every arrow in G counts as a path in G, and the\nfunction μG spells out the fact that a head-to-tail sequence of paths (a path of paths) in\nG can be concatenated to a single path in G.\nExercise 4.4.1.1. Let r2s denote the graph\n0‚N\n1‚N\n2‚, and let Loop denote the unique graph\nhaving one vertex and one arrow (pictured in Diagram (3.17)).\na.) Find a graph homomorphism f : r2s N PathspLoopq that is injective on arrows\n(i.e.\nsuch that no two arrows in the graph r2s are sent by f to the same arrow\nin PathspLoopq).\nb.) The graph r2s has 6 paths, so Pathspr2sq has 6 arrows. What are the images of these\narrows under the graph homomorphism Pathspfq: Pathspr2sq N PathspPathspLoopqq?\n♦\nWe are almost ready to give the definition of schema morphism, but before we do, let's\nreturn to our original idea. Given graphs G, G1 (underlying schemas C, C1) we originally\nwanted a function from the paths in G to the paths in G1, but we realized it was more\nconcise to speak of a function from arrows in G to paths in G1. How do we get back\nwhat we originally wanted from the concise version?\nGiven a graph homomorphism\nf : G N PathspG1q, we use (4.13) to form the following composition, which we denote\nsimply by Pathsf : PathspGq N PathspG1q:\nPathspGq\nPathspfq / PathspPathspG1qq\nμG1\n/ PathspG1q\n(4.14)\nThis says that given a function from arrows in G to paths in G1, a path in G becomes\na path of paths in G1, which can be concatenated to a path in G1. This simply and\nprecisely spells out our intuition.\nDefinition 4.4.1.2 (Schema morphism). Let G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q\nbe graphs, and let C \" pG, »Gq and C1 \" pG1, »G1q be schemas. A schema morphism F\nfrom C to D, denoted F : C N D is a graph homomorphism 22\nF : G N PathspG1q\nthat satisfies the following condition for any paths p and q in G:\nif\np »G q\nthen\nPathsF ppq »G1 PathsF pqq.\n(4.15)\nTwo schema morphisms E, F : C N C1 are considered identical if they agree on vertices\n(i.e. E0 \" F0) and if, for every arrow f in G, there is a path equivalence in G1\nE1pfq »G1 F1pfq.\n22By Definition 3.3.3.1, a graph homomorphism F : G N PathspG1q will consist of a vertex part\nF0 : V N V 1 and an arrows part F1 : E N PathpG1q. See also Definition 3.3.2.1.\n\n4.4. CATEGORIES AND SCHEMAS ARE EQUIVALENT, CAT » SCH\nWe now define the category of schemas, denoted Sch, to be the category whose objects\nare schemas as in Definition 3.5.2.6 and whose morphisms are schema morphisms defined\nas above.\nThe identity morphism on schema C \" pG, »Gq is the schema morphism\nidC :\" ηG : G N PathspGq as defined in Equation (4.13). We need only understand\nhow to compose schema morphisms F : C N C1 and F 1 : C1 N C2.\nOn objects their\ncomposition is obvious. Given an arrow in C, it is sent to a path in C1; each arrow in that\npath is sent to a path in C2. We then have a path of paths which we can concatenate\n(via μG2 : PathspPathspG2qq N PathspG2q as in 4.13) to get a path in C2 as desired.\nSlogan 4.4.1.3.\n\" A schema morphism sends vertices to vertices, arrows to paths, and path\nequivalences to path equivalences. \"\nExample 4.4.1.4. Let r2s be the linear order graph of length 2, pictured to the left, and\nlet C denote the schema pictured to the right below:\nr2s :\"\n0‚\nf1\n/ 1‚\nf2\n/ 2‚\nC :\"\na‚\ng\n/\ni\n\nb‚\nh\nc‚\nWe impose on C the path equivalence declaration rg, hs » ris and show that in this case\nC and r2s are isomorphic in Sch. We have a schema morphism F : r2s N C sending\n0 ÞN a, 1 ÞN b, 2 ÞN c, and sending each arrow in r2s to an arrow in C. And we have\na schema morphism F 1 : C N r2s which reverses this mapping on vertices; note that\nF 1 must send the arrow i in C to the path rf1, f2s in r2s, which is ok! The roundtrip\nF 1 F : r2s N r2s is identity.\nThe roundtrip F F 1 : C N C may look like it's not\nthe identity; indeed it sends vertices to themselves but it sends i to the path rg, hs.\nBut according to Definition 4.4.1.2, this schema morphism is considered identical to idC\nbecause there is a path equivalence idCpiq \" ris » rg, hs \" F F 1piq.\nExercise 4.4.1.5. Consider the schema r2s and the schema C pictured above, except where\nthis time we do not impose any path equivalence declarations on C, so rg, hs firis in our\ncurrent version of C.\na.) How many schema morphisms are there r2s N C that send 0 to a?\nb.) How many schema morphisms are there C N r2s that send a to 0?\n♦\nExercise 4.4.1.6. Consider the graph Loop pictured below\nLoop :\"\ns‚\nf\n\nand for any natural number n, let Ln denote the schema pLoop, »nq where »n is the\nPED f n`1 » f n. This is the \"finite hierarchy\" schema of Example 3.5.2.11. Let 1 denote\nthe graph with one vertex and no arrows; consider it as a schema.\n\nCHAPTER 4. BASIC CATEGORY THEORY\na.) Is 1 isomorphic to L1 in Sch?\nb.) Is it isomorphic to any (other) Ln?\n♦\nExercise 4.4.1.7. Let Loop and Ln be the schemas defined in Exercise 4.4.1.6.\na.) What is the cardinality of the set HomSchpL3, L5q?\nb.) What is the cardinality of the set HomSchpL5, L3q? Hint: the cardinality of the set\nHomSchpL4, L9q is 8.\n♦\n4.4.2\nProving the equivalence\nConstruction 4.4.2.1 (From schema to category). We will define a functor L: Sch N\nCat. Let C \" pG, »q be a categorical schema, where G \" pV, A, src, tgtq. Define LpCq to\nbe the category with ObpLpCqq \" V , and with HomLpCqpv1, v2q :\" PathGpv, wq{ », i.e.\nthe set of paths in G, modulo the path equivalence relation for C. The composition of\nmorphisms is defined by concatenation of paths, and Lemma 3.5.2.5 ensures that such\ncomposition is well-defined. We have thus defined L on objects of Sch.\nGiven a schema morphism F : C N C1, where C1 \" pG1, »1q, we need to produce\na functor LpFq: LpCq N LpC1q. The objects of LpCq and LpC1q are the vertices of G\nand G1 respectively, and F provides the necessary function on objects. Diagram (4.14)\nprovides a function PathsF : PathspGq N PathspG1q will provide the requisite function\nfor morphisms.\nA morphism in LpCq is an equivalence class of paths in C. For any representative path\np P PathspGq, we have PathsF ppq P PathspG1q, and if p » q then PathsF ppq »1 PathsF pqq\nby condition 4.15. Thus PathsF indeed provides us with a function HomLpCq N HomLpC1q.\nThis defines L on morphisms in Sch.\nIt is clear that L preserves composition and\nidentities, so it is a functor.\nConstruction 4.4.2.2 (From category to schema). We will define a functor R: Cat N\nSch. Let C \" pObpCq, HomC, dom, cod, ids, q be a category (see Exercise 4.1.1.23). Let\nRpCq \" pG, »q where G is the graph\nG \" pObpCq, HomC, dom, codq,\nand with » defined as the congruence generated by the following path equivalence dec-\nlarations: for any composable sequence of morphisms f1, f2, . . . , fn (with dompfi`1q \"\ncodpfiq for each 1 d i d n 1) we put\nrf1, f2, . . . , fns » rfn f2 f1s.\n(4.16)\nThis defines R on objects of Cat.\nA functor F : C N D induces a schema morphism RpFq: RpCq N RpDq, because\nvertices are sent to vertices, arrows are sent to arrows (as paths of length 1), and path\nequivalence is preserved by (5.14) and the fact that F preserves the composition formula.\nThis defines R on morphisms in Cat. It is clear that R preserves compositions, so it is\na functor.\n\n4.5. LIMITS AND COLIMITS\nTheorem 4.4.2.3. The functors\nL: Sch\n/ Cat: R\no\nare mutually inverse equivalences of categories.\nSketch of proof. It is clear that there is a natural isomorphism α: idCat\n-\nYN L R; i.e.\nfor any category C, there is an isomorphism C - LpRpCqq.\nBefore giving an isomorphism β : idSch\n-\nYN R L, we briefly describe RpLpSqq \":\npG1, »1q for a schema S \" pG, »q. Write G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q.\nOn vertices we have V \" V 1. On arrows we have A1 \" PathG{ ». The congruence »1\nfor RpLpSqq is imposed in (5.14). Under »1, every path of paths in G is made equivalent\nto its concatenation, considered as a path of length 1 in G1.\nThere is a natural transformation β : idSch N R L whose S-component sends each\narrow in G to a certain path of length 1 in G1. We need to see that βS has an inverse.\nBut this is straightforward: every arrow f in R LpSq is an equivalence class of paths\nin S; choose any one and send f there; by Definition 4.4.1.2 any other choice will give\nthe identical morphism of schemas. It is easy to show that the roundtrips are identities\n(again up to the notion of identity given in Definition 4.4.1.2).\n□\n4.5\nLimits and colimits\nLimits and colimits are universal constructions, meaning they represent certain ideals of\nbehavior in a category. When it comes to sets that map to A and B, the pA ˆ Bq-grid is\nideal--it projects on to both A and B as straightforwardly as possible. When it comes\nto sets that can interpret the elements of both A and B, the disjoint union A \\ B is\nideal--it includes both A and B without confusion or superfluity. These are limits and\ncolimits in Set. Limits and colimits exist in other categories as well.\nLimits in a preorder are meets, colimits in a preorder are joins. Limits and colimits\nalso exist for database instances and monoid actions, allowing us to discuss for example\nthe product or union of different state machines. Limits and colimits exist for spaces,\ngiving rise to products and unions, as well as quotients.\nLimits and colimits do not exist in every category; when C is complete with respect\nto limits (or colimits), these limits always seem to mean something valuable to human\nintuition. For example, when a subject has already been studied for a long time before\ncategory theory came around, it often turns out that classically interesting constructions\nin the subject correspond to limits and colimits in its categorification C. For example\nproducts, unions, equivalence relations, etc. are classical ideas in set theory that are\nnaturally captured by limits and colimits in Set.\n4.5.1\nProducts and coproducts in a category\nIn Sections 2.4, we discussed products and coproducts in the category Set of sets. Now\nwe discuss the same notions in an arbitrary category. For both products and coproducts\nwe will begin with examples and then write down the general concept, but we'll work on\nproducts first.\n\nCHAPTER 4. BASIC CATEGORY THEORY\n4.5.1.1\nProducts\nThe product of two sets is a grid, which projects down onto each of the two sets. This\nis good intuition for products in general.\nExample 4.5.1.2. Given two preorders, X1 :\" pX1, d1q and X2 :\" pX2, d2q, we can take\ntheir product and get a new preorder X1 ˆ X2. Both X1 and X2 have underlying sets\n(namely X1 and X2), so we might hope that the underlying set of X1 ˆ X2 is the set\nX1 ˆX2 of ordered pairs, and this turns out to be true. We have a notion of less-than on\nX1 and we have a notion of less-than on X2; we need to construct a notion of less-than\non X1 ˆ X2. So, given two ordered pairs px1, x2q and px1\n1, x1\n2q, when should we say that\npx1, x2q d1,2 px1\n1, x1\n2q holds? The obvious guess is to say that it holds iffboth x1 d1 x1\nand x2 d2 x1\n2 hold, and this works:\nX1 ˆ X2 :\" pX1 ˆ X2, d1,2q\nNote that the projection functions X1 ˆ X2 N X1 and X1 ˆ X2 N X2 induce\nmorphisms of preorders. That is, if px1, x2q d1,2 px1\n1, x1\n2q then in particular x1 d x1\n1. So\nwe have preorder morphisms\nX1 ˆ X2\n\nX1\nX2\nExercise 4.5.1.3. Suppose that you have a partial order pS, dSq on songs (so you know\nsome songs are preferable to others but sometimes you can't compare). And suppose\nyou have a partial order pA, dAq on pieces of art. You're about to be given a pair ps, aq\nincluding a song and a piece of art. Does the product partial order S ˆ A provide a\nreasonable guess for your preferences on pairs?\n♦\nExercise 4.5.1.4. Consider the partial order d on N given by standard \"less-than-or-\nequal-to\", so 5 d 9 etc.\nAnd consider another partial order, divides on N, where\na divides b if \"a goes into b evenly\", i.e. if there exists n P N such that a n \" b, so\n5 divides 35. If we call the product order pX, lq :\" pN, dq ˆ pN, dividesq, which of\nthe following are true:\np2, 4q l p3, 4q?\np2, 4q l p3, 5q?\np2, 4q l p8, 0q?\np2, 4q l p0, 0q?\n♦\nExample 4.5.1.5. Given two graphs G1 \" pV1, A1, src1, tgt1q and G2 \" pV2, A2, src2, tgt2q,\nwe can take their product and get a new graph G1 ˆ G2. The vertices will be the grid\nof vertices V1 ˆ V2, so each vertex in G1 ˆ G2 is labeled by a pair of vertices, one from\nG1 and one from G2. When should an arrow connect pv1, v2q to pv1\n1, v1\n2q? Whenever we\ncan find an arrow in G1 connecting v1 to v1\n1 and we can find an arrow in G2 connecting\nv2 to v1\n2. It turns out there is a simple formula for the set of arrows in G1 ˆ G2, namely\nA1 ˆ A2.\nLet's write G :\" G1ˆG2 and say G \" pV, A, src, tgtq. We now know that V \" V1ˆV2\nand A \" A1 ˆ A2. What should the source and target functions A N V be? Given a\nfunction src1 : A1 N V1 and a function src2 : A2 N V2, the universal property of products\nin Set (Lemma 2.4.1.10 or better Example 2.4.1.16) provides a unique function\nsrc :\" src1 ˆ src2 : A1 ˆ A2 N V1 ˆ V2\n\n4.5. LIMITS AND COLIMITS\nNamely the source of arrow pa1, a2q will be the vertex psrc1pa1q, src2pa2qq. Similarly we\nhave a ready-made choice of target function tgt \" tgt1 ˆ tgt2. We have now defined the\nproduct graph.\nHere's a concrete example. Let I and J be as drawn below:\nI :\"\nv‚\nf\nw‚\ng\n\nh\n\nx‚\nJ :\"\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nArrow pJq\nID\nsrc\ntgt\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pJq\nID\nq\nr\ns\nt\nThe product I ˆJ drawn below has, as expected 3 4 \" 12 vertices and 3 4 \" 12 arrows:\nI ˆ J :\"\npv,qq\n‚\npf,iq\n!\npv,rq\n‚\n!\npv,sq\n‚\n}\n\npv,tq\n‚\npw,qq\n‚\n%\npw,rq\n‚\n%\npw,sq\n‚\ny\n%\npw,tq\n‚\npx,qq\n‚\npx,rq\n‚\npx,sq\n‚\npx,tq\n‚\nArrow\npI ˆ Jq\nID\nsrc\ntgt\npf, iq\npv, qq\npw, rq\npf, jq\npv, rq\npw, sq\npf, kq\npv, sq\npw, rq\npf, lq\npv, sq\npw, tq\npg, iq\npw, qq\npx, rq\npg, jq\npw, rq\npx, sq\npg, kq\npw, sq\npx, rq\npg, lq\npw, sq\npx, tq\nph, iq\npw, qq\npx, rq\nph, jq\npw, rq\npx, sq\nph, kq\npw, sq\npx, rq\nph, lq\npw, sq\npx, tq\nVertex\npI ˆ Jq\nID\npv, qq\npv, rq\npv, sq\npv, tq\npw, qq\npw, rq\npw, sq\npw, tq\npx, qq\npx, rq\npx, sq\npx, tq\nHere is the most important thing to notice.\nLook at the Arrow table for I ˆ J,\nand for each ordered pair, look only at the second entry in all three columns; you will\nsee something that matches with the Arrow table for J. Do the same for I, and again\nyou'll see a perfect match. These \"matchings\" are readily-visible graph homomorphisms\nI ˆ J N I and I ˆ J N J in Grph.\nExercise 4.5.1.6. Let r1s \"\n0‚\nf\nYYN\n1‚ be the linear order graph of length 1 and let P \"\nPathspr1sq be its paths-graph, as in Example 4.1.2.22 (so P should have three arrows\nand two vertices). Draw the graph P ˆ P.\n♦\nExercise 4.5.1.7. Recall from Example 3.5.2.9 that a discrete dynamical system (DDS)\nis a set s together with a function f : s N s. By now it should be clear that if\nLoop :\"\ns‚\nf\n\nCHAPTER 4. BASIC CATEGORY THEORY\nis the loop schema, then a DDS is simply an instance (a functor) I : Loop N Set. We\nhave not yet discussed products of DDS's, but perhaps you can guess how they should\nwork. For example, consider the instances I, J : Loop N Set tabulated below:\ns\n(I)\nID\nf\nA\nC\nB\nC\nC\nC\ns\n(J)\nID\nf\nx\ny\ny\nx\nz\nz\na.) Make a guess and tabulate I ˆ J. Then draw it.23\nb.) Recall the notion of natural transformations between functors (see Example 4.3.3.5),\nwhich in the case of functors Loop N Set are the morphisms of instances. Do you see\nclearly that there is a morphism of instances I ˆ J N I and I ˆ J N J? Just check\nthat if you look only at the left-hand coordinates in your I ˆ J, you see something\ncompatible with I.\n♦\nIn every case above, what's most important to recognize is that there are projection\nmaps IˆJ N I and IˆJ N J, and that the construction of IˆJ seems as straightforward\nas possible, subject to having these projections. It is time to give the definition.\nDefinition 4.5.1.8. Let C be a category and let X, Y P ObpCq be objects. A span on X\nand Y consists of three constituents pZ, p, qq, where Z P ObpCq is an object, and where\np: Z N X and q: Z N Y are morphisms in C.\nZ\np\n\nq\n\nX\nY\nA product of X and Y is a span X\nπ1\nÐY X ˆ Y\nπ2\nYN Y , 24 such that for any other span\nX\npÐY Z\nqYN Y there exists a unique morphism tp,q : Z N X ˆ Y such that the diagram\nbelow commutes:\nX ˆ Y\nπ1\n\nπ2\n\nX\nY\nZ\np\n\\\nq\nB\ntp,q\nO\nRemark 4.5.1.9. Definition 4.5.1.8 endows the product of two objects with something\nknown as a universal property. It says that a product of two objects X and Y maps to\n23The result is not necessarily inspiring, but at least computing it is straightforward.\n24The names X ˆ Y and π1, π2 are not mathematically important, they are pedagogically suggestive.\n\n4.5. LIMITS AND COLIMITS\nthose two objects, and serves as a gateway for all who do the same. \"None shall map\nto X and Y except through me!\" This grandiose property is held by products in all the\nvarious categories we have discussed so far. It is what I meant when I said things like\n\"X ˆY maps to both X and Y and does so as straightforwardly as possible\". The grid of\ndots obtained as the product of two sets has such a property, as was shown in Example\n2.4.1.11.\nExample 4.5.1.10. In Example 4.5.1.2 we discussed products of preorders. In this example\nwe will discuss products in an individual preorder. That is, by Proposition 4.2.1.17, there\nis a functor PrO N Cat that realizes every preorder as a category. If P \" pP, dq is\na preorder, what are products in P? Given two objects a, b P ObpPq we first consider\nspans on a and b, i.e. a Ð z N b. That would be some z such that z d a and z d b. The\nproduct will be such a span a e a ˆ b d b, but such that every other spanning object z\nis less than or equal to a ˆ b. In other words a ˆ b is as big as possible subject to the\ncondition of being less than a and less than b. This is precisely the meet of a and b (see\nDefinition 3.4.2.1).\nExample 4.5.1.11. Note that the product of two objects in a category C may not exist.\nLet's return to preorders to see this phenomenon.\nConsider the set R2, and say that px1, y1q d px2, y2q if there exists le 1 such that\nx1l\" x2 and y1l\" y2; in other words, point p is less than point q if, in order to travel\nfrom q to the origin along a straight line, one must pass through p along the way.\nWe have given a perfectly good partial order, but p :\" p1, 0q and q :\" p0, 1q do not\nhave a product. Indeed, it would have to be a non-zero point that was on the same\nline-through-the origin as p and the same line-through-the-origin as q, of which there are\nnone.\nExample 4.5.1.12. Note that there can be more than one product of two objects in a\ncategory C, but that any two choices will be canonically isomorphic. Let's return once\nmore to preorders to see this phenomenon.\nConsider the set R2 and say that px1, y1q d px2, y2q if x2\n1 ` y2\n1 d x2\n2 ` y2\n2, in other\nwords if the former is on a smaller 0-circle (by which I mean \"circle centered at the\norigin\") than the latter is.\nFor any two points p, q there will be lots of points that serve as products: anything\non the smaller of their two 0-circles will suffice. Given any two points a, b on this smaller\ncircle, we will have a unique isomorphism a - b because a d b and b d a and all\nmorphisms are unique in a preorder.\nExercise 4.5.1.13. Consider the preorder P of cards in a deck, shown in Example 3.4.1.3;\nit is not the entire story of cards in a deck, but take it to be so. In other words, be like\na computer and take what's there at face value. Consider the preorder P as a category\n(by way of the functor PrO N Cat).\na.) For each of the following pairs, what is their product in P (if it exists)?\n⌜a diamond⌝ˆ ⌜a heart⌝?\n⌜a queen⌝ˆ ⌜a black card⌝?\n⌜a card⌝ˆ ⌜a red card⌝?\n⌜a face card⌝ˆ ⌜a black card⌝?\nb.) How would these answers differ if P was completed to the \"whole story\" partial order\nclassifying cards in a deck?\n♦\n25Note that p0, 0q is not related to anything else.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nExercise 4.5.1.14. Let X be a set, and consider it as a discrete category. Given two\nobjects x, y P ObpXq, under what conditions will there exist a product x ˆ y?\n♦\nExercise 4.5.1.15. Let f : R N R be a function, like you would see in 6th grade (maybe\nfpxq \" x ` 7). A typical thing to do is to graph f as a curve running through the plane\nR2 :\" R ˆ R. This curve can be understood as a function F : R N R2.\na.) Given some x P R, what are the coordinates of Fpxq P R2?\nb.) Obtain F : R N R2 using the universal property given in Definition 4.5.1.8.\n♦\nExercise 4.5.1.16. Consider the preorder pN, dividesq, discussed in Exercise 4.5.1.4,\nwhere e.g. 5 d 15 but 5 e 6.\na.) What is the product of 9 and 12 in this category?\nb.) Is there a standard name for products in this category?\n♦\nExample 4.5.1.17. All products exist in the category Cat. Given two categories C and\nD, there is a product category C ˆ D. We have ObpC ˆ Dq \" ObpCq ˆ ObpDq and for\nany two objects pc, dq and pc1, d1q, we have\nHomCˆDppc, dq, pc1, d1qq \" HomCpc, c1q ˆ HomCpd, d1q.\nThe composition formula is \"obvious\".\nLet r1s P ObpCatq denote the linear order category of length 1, drawn\nr1s :\"\n0‚\nf\n/ 1‚\nAs a schema it has one arrow, but as a category it has three morphisms. So we expect\nr1sˆr1s to have 9 morphisms, and that's true. In fact, r1sˆr1s looks like a commutative\nsquare:\np0,0q\n‚\nid0ˆf\n/\nfˆid0\n\np0,1q\n‚\nfˆid1\n\np1,0q\n‚\nid1ˆf\n/ p1,1q\n‚\n(4.17)\nWe see only four morphisms here, but there are also four identities and one morphism\np0, 0q N p1, 1q given by composition of either direction. It is a minor miracle that the\ncategorical product somehow \"knows\" that this square should commute; however, this is\nnot the mere preference of man but instead the dictate of God! By which I mean, this\nfollows rigorously from the definitions we already gave of Cat and products.\n4.5.1.18\nCoproducts\nThe coproduct of two sets is their disjoint union, which includes non-overlapping copies\nof each of the two sets. This is good intuition for coproducts in general.\n\n4.5. LIMITS AND COLIMITS\nExample 4.5.1.19. Given two preorders, X1 :\" pX1, d1q and X2 :\" pX2, d2q, we can take\ntheir coproduct and get a new preorder X1 \\ X2. Both X1 and X2 have underlying sets\n(namely X1 and X2), so we might hope that the underlying set of X1 ˆX2 is the disjoint\nunion X1 \\ X2, and that turns out to be true. We have a notion of less-than on X1 and\nwe have a notion of less-than on X2.\nGiven an element x P X1 \\ X2 and an element x1 P X1 \\ X2, how can we use d1 and\nd2 to compare x1 and x2? The relation d1 only knows how to compare elements of X1\nand the relation d2 only knows how to compare elements of X2. But x and x1 may come\nfrom different homes; e.g. x P X1 and x1 P X2, in which case neither d1 nor d2 gives\nany clue about which should be bigger.\nSo when should we say that x d1\\2 x1 holds? The obvious guess is to say that x is\nless than x1 iffsomebody says it is; that is, if both x and x1 are from the same home and\nthe local ordering has x d x1. To be precise, we say x d1\\2 x1 if and only if either one\nof the following conditions hold:\n- x P X1 and x1 P X1 and x d1 x1, or\n- x P X2 and x1 P X2 and x d2 x1.\nWith d1\\2 so defined, one checks that it is not only a preorder, but that it serves as a\ncoproduct of X1 and X2,\nX1 \\ X2 :\" pX1 \\ X2, d1\\2q.\nNote that the inclusion functions X1 N X1\\X2 and X2 N X1\\X2 induce morphisms\nof preorders. That is, if x, x1 P X1 are elements such that x d1 x1 in X1 then the same\nwill hold in X1 \\ X2. So we have preorder morphisms\nX1 \\ X2\nX1\nA\nX2\n]\nExercise 4.5.1.20. Suppose that you have a partial order A :\" pA, dAq on apples (so\nyou know some apples are preferable to others but sometimes you can't compare). And\nsuppose you have a partial order O :\" pO, dOq on oranges. You're about to be given\ntwo pieces of fruit from a basket of apples and oranges. Is the coproduct partial order\nA \\ O a reasonable guess for your preferences, or does it seem biased?\n♦\nExample 4.5.1.21. Given two graphs G1 \" pV1, A1, src1, tgt1q and G2 \" pV2, A2, src2, tgt2q,\nwe can take their coproduct and get a new graph G1 \\ G2. The vertices will be the dis-\njoint union of vertices V1 \\ V2, so each vertex in G1 \\ G2 is labeled either by a vertex\nin G1 or by one in G2 (and if any labels are shared, then something must be done to\ndifferentiate them). When should an arrow connect v to v1? Whenever both are from the\nsame component (i.e. either v, v1 P V1 or v, v1 P V2) and we can find an arrow connecting\nthem in that component. It turns out there is a simple formula for the set of arrows in\nG1 \\ G2, namely A1 \\ A2.\nLet's write G :\" G1\\G2 and say G \" pV, A, src, tgtq. We now know that V \" V1\\V2\nand A \" A1 \\ A2. What should the source and target functions A N V be? Given\na function src1 : A1 N V1 and a function src2 : A2 N V2, the universal property of\ncoproducts in Set can be used to specify a unique function\nsrc :\" src1 \\ src2 : A1 \\ A2 N V1 \\ V2.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nNamely for any arrow a P A, we know either a P A1 or a P A2 (and not both), so the\nsource of a will be the vertex src1paq if a P A1 and src2paq if a P A2. Similarly we\nhave a ready-made choice of target function tgt \" tgt1 \\ tgt2. We have now defined the\ncoproduct graph.\nHere's a real example. Let I and J be as in Example 4.3.3.5, drawn below:\nI :\"\nv‚\nf\nw‚\ng\n\nh\n\nx‚\nJ :\"\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nu‚\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nArrow pJq\nID\nsrc\ntgt\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pJq\nID\nq\nr\ns\nt\nu\nThe coproduct I \\ J drawn below has, as expected 3 ` 5 \" 8 vertices and 3 ` 4 \" 7\narrows:\nI \\ J :\"\nv‚\nf\nw‚\ng\n\nh\n\nq‚\ni\n/ r‚\nj\ns‚\nk\n_\nl\n/ t‚\nx‚\nu‚\nArrow pI \\ Jq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\ni\nq\nr\nj\nr\ns\nk\ns\nr\nl\ns\nt\nVertex pI \\ Jq\nID\nv\nw\nx\nq\nr\ns\nt\nu\nHere is the most important thing to notice. Look at the Arrow table I and notice\nthat there is a way to send each row to a row in I \\ J, such that all the foreign keys\nmatch. Similarly in the arrow table and the two vertex tables for J. These \"matchings\"\nare readily-visible graph homomorphisms I N I \\ J and J N I \\ J in Grph.\nExercise 4.5.1.22. Recall from Example 3.5.2.9 that a discrete dynamical system (DDS)\nis a set s together with a function f : s N s; if\nLoop :\"\ns‚\nf\n\nis the loop schema, then a DDS is simply an instance (a functor) I : Loop N Set. We\nhave not yet discussed coproducts of DDS's, but perhaps you can guess how they should\n\n4.5. LIMITS AND COLIMITS\nwork. For example, consider the instances I, J : Loop N Set tabulated below:\ns\n(I)\nID\nf\nA\nC\nB\nC\nC\nC\ns\n(J)\nID\nf\nx\ny\ny\nx\nz\nz\nMake a guess and tabulate I \\ J. Then draw it.\n♦\nIn every case above (preorders, graphs, DDSs), what's most important to recognize\nis that there are inclusion maps I N I \\ J and J N I \\ J, and that the construction of\nI \\ J seems as straightforward as possible, subject to having these inclusions. It is time\nto give the definition.\nDefinition 4.5.1.23. Let C be a category and let X, Y P ObpCq be objects. A cospan\non X and Y consists of three constituents pZ, i, jq, where Z P ObpCq is an object, and\nwhere i: X N Z and j : Y N Z are morphisms in C.\nZ\nX\ni\nE\nY\nj\nX\nA coproduct of X and Y is a cospan X\nι1\nYN X \\ Y\nι2\nÐY Y , 26 such that for any other\ncospan X\niYN Z\njÐY Y there exists a unique morphism si,j : X \\ Y N Z such that the\ndiagram below commutes:\nX \\ Y\nsi,j\n\nX\nι1\nB\ni\n\nY\nι2\n\\\nj\n\nZ\nRemark 4.5.1.24. Definition 4.5.1.8 endows the coproduct of two objects with a universal\nproperty. It says that a coproduct of two objects X and Y receives maps from those two\nobjects, and serves as a gateway for all who do the same. \"None shall receive maps from\nX and Y except through me!\" This grandiose property is held by all the coproducts we\nhave discussed so far. It is what I meant when I said things like \"X \\ Y receives maps\nfrom both X and Y and does so as straightforwardly as possible\". The disjoint union\nof dots obtained as the coproduct of two sets has such a property, as can be seen by\nthinking about Example 2.4.2.5.\nExample 4.5.1.25. By Proposition 4.2.1.17, there is a functor PrO N Cat that realizes\nevery preorder as a category. If P \" pP, dq is a preorder, what are coproducts in P?\nGiven two objects a, b P ObpPq we first consider cospans on a and b, i.e. a N z Ð b.\n26The names X \\ Y and ι1, ι2 are not mathematically important, they are pedagogically suggestive.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nA cospan of a and b is any z such that a d z and b d z. The coproduct will be such a\ncospan a d a \\ b e b, but such that every other cospanning object z is greater than or\nequal to a \\ b. In other words a \\ b is as small as possible subject to the condition of\nbeing bigger than a and bigger than b. This is precisely the join of a and b (see Definition\n3.4.2.1).\nJust as for products, the coproduct of two objects in a category C may not exist, or it\nmay not be unique. The non-uniqueness is much less \"bad\" because given two candidate\ncoproducts, they will be canonically isomorphic. They may not be equal, but they are\nisomorphic. But coproducts might not exist at all in certain categories. We will explore\nthat a bit below.\nExample 4.5.1.26. Consider the set R2 and partial order from Example 4.5.1.11 where\npx1, y1q d px2, y2q if there exists le 1 such that x1l\" x2 and y1l\" y2. Again the\npoints p :\" p1, 0q and q :\" p0, 1q do not have a coproduct. Indeed, it would have to\nbe a non-zero point that was on the same line-through-the origin as p and the same\nline-through-the-origin as q, of which there are none.\nExercise 4.5.1.27. Consider the preorder P of cards in a deck, shown in Example 3.4.1.3;\nit is not the entire story of cards in a deck, but take it to be so. In other words, be like a\ncomputer and take what's there at face value. Consider the preorder P as a category (by\nway of the functor PrO N Cat). For each of the following pairs, what is their coproduct\nin P (if it exists)?\na.)\n⌜a diamond⌝\\⌜a heart⌝?\n⌜a queen⌝\\⌜a black card⌝?\n⌜a card⌝\\⌜a red card⌝?\n⌜a face card⌝\\⌜a black card⌝?\nb.) How would these answers differ if P was completed to the \"whole story\" partial order\nclassifying cards in a deck?\n♦\nExercise 4.5.1.28. Let X be a set, and consider it as a discrete category. Given two\nobjects x, y P ObpXq, under what conditions will there exist a coproduct x \\ y?\n♦\nExercise 4.5.1.29. Consider the preorder pN, dividesq, discussed in Exercise 4.5.1.4,\nwhere e.g. 5 d 15 but 5 e 6.\na.) What is the coproduct of 9 and 12 in that category?\nb.) Is there a standard name for coproducts in that category?\n♦\n4.5.2\nDiagrams in a category\nWe have been drawing diagrams since the beginning of the book. What is it that we\nhave been drawing pictures of? The answer is that we have been drawing functors.\nDefinition 4.5.2.1. Let C and I be categories. 27 An I-shaped diagram in C is simply\na functor d: I N C. In this case I is called the indexing category for the diagram.\n27In fact, the indexing category I is usually assumed to be small in the sense of Remark 4.1.1.2,\nmeaning that its collection of objects is a set.\n\n4.5. LIMITS AND COLIMITS\nSuppose given an indexing category I and an I-shaped diagram X : I N C. One\ndraws this as follows. For each object in q P I, draw a dot labeled by Xpqq; if several\nobjects in I point to the same object in C, then several dots will be labeled the same way.\nDraw the images of morphisms f : q N q1 in I by drawing arrows between dots Xpqq\nand Xpq1q, and label each arrow by the image morphism Xpfq in C. Again, if several\nmorphisms in I are sent to the same morphism in C, then several arrows will be labeled\nthe same way. One can abbreviate this process by not drawing every morphism in I, so\nlong as every morphism in I is represented by a unique path in C, i.e. as long as the\ndrawing is sufficiently unambiguous as a depiction of X : I N C.\nExample 4.5.2.2. Consider the commutative diagram in Set drawn below:\nN\n`1 /\n\nN\n\nN\n`2 / Z\n(4.18)\nThis is the drawing of a functor d: r1s ˆ r1s N Set (see Example 4.5.1.17).\nWith\nnotation for the objects and morphisms of r1s ˆ r1s as shown in Diagram (4.17), we have\ndp0, 0q \" dp0, 1q \" dp1, 0q \" N and dp1, 1q \" Z (for some reason..) and dpid0, fq: N N N\ngiven by n ÞN n ` 1, etc.\nThe fact that d is a functor means it must respect composition formulas, which implies\nthat Diagram (4.18) commutes. Recall from Section 2.2 that not all diagrams one can\ndraw will commute; one must specify that a given diagram commutes if he or she wishes\nto communicate this fact. But then how is a non-commuting diagram to be understood\nas a functor?\nLet G P ObpGrphq denote the following graph\np0,0q\n‚\nf\n/\nh\np0,1q\n‚\ng\np1,0q\n‚\ni\n/ p1,1q\n‚\nRecall the free category functor F : Grph N Cat from Example 4.1.2.30.\nThe free\ncategory FpGq P ObpCatq on G looks almost like r1s ˆ r1s except that since rf, gs is a\ndifferent path in G than is rh, is, they become different morphisms in FpGq. A functor\nFpGq N Set might be drawn the same way that (4.18) is, but it would be a diagram\nthat would not be said to commute.\nWe call r1s ˆ r1s the commutative square indexing category. 28\nExercise 4.5.2.3. Consider r2s, the linear order category of length 2.\na.) Is r2s the appropriate indexing category for commutative triangles?\nb.) If not, what is?\n♦\n28We might call what is here denoted by FpGq the noncommutative square indexing category.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nExample 4.5.2.4. Recall that an equalizer in Set was a diagram of sets that looked like\nthis:\nE‚\nf\n/ A‚\ng1\n/\ng2\n/\nB‚\n(4.19)\nwhere g1 f \" g2 f. What is the indexing category for such a diagram? It is the schema\n(4.19) with the PED rf, g1s » rf, g2s. That is, in some sense you're seeing the indexing\ncategory, but the PED needs to be declared.\nExercise 4.5.2.5. Let C be a category, A P ObpCq an object, and f : A N A a morphism\nin C. Consider the two diagrams in C drawn below:\nA‚\nf\n/ A‚\nf\n/ A‚\nf\n/\nA‚\nf\na.) Should these two diagrams have the same indexing category?\nb.) If they should have the same indexing category, what is causing or allowing the\npictures to appear different?\nc.) If they should not have the same indexing category, what coincidence makes the two\npictures have so much in common?\n♦\nDefinition 4.5.2.6. Let I P ObpCatq be a category. The left cone on I, denoted IY, is\nthe category defined as follows. On objects we put ObpIYq \" t 8u\\ObpIq, and we call\nthe new object 8 the cone point of IY. On morphisms we add a single new morphism\nsb : 8 N b for every object b P ObpIq; more precisely,\nHomIYpa, bq \"\n$\n'\n'\n'\n&\n'\n'\n'\n%\nHomIpa, bq\nif a, b P ObpIq\ntsbu\nif a \" 8, b P ObpIq\ntid 8u\nif a \" b \" 8\nH\nif a P ObpIq, b \" 8.\nThe composition formula is in some sense obvious. To compose two morphisms both in\nI, compose as dictated by I; if one has 8 as source then there will be a unique choice\nof composite.\nThere is an obvious inclusion of categories,\nI N IY.\n(4.20)\nRemark 4.5.2.7. Note that the specification of IY given in Definition 4.5.2.6 works just\nas well if I is considered a schema and we are constructing a schema IY: add the new\nobject 8 and the new arrows sb : 8 N b for each b P ObpIq, and for every morphism\nf : b N b1 in I add a PED rsb1s » rsb, fs. We generally will not distinguish between\ncategories and schemas, since they are equivalent.\nExample 4.5.2.8. For a natural number n P N, we define the n-leaf star schema, denoted\nStarn, to be the category (or schema, see Remark 4.5.2.7) nY, where n is the discrete\n\n4.5. LIMITS AND COLIMITS\ncategory on n objects. Below we draw Star0, Star1, Star2, and Star3.\nStar0\n‚\nStar1\n‚\ns1\n\n1‚\nStar2\n‚\ns1\n\ns2\n\n1‚\n2‚\nStar3\n‚\ns1\n\ns2\n\ns3\n\n1‚\n2‚\n3‚\nExercise 4.5.2.9. Let C0 :\" 0 denote the empty category and for any natural number\nn P N, let Cn`1 \" pCnqY. Draw C4.\n♦\nExercise 4.5.2.10. Let C be the graph indexing schema as in (4.7). What is CY and how\ndoes it compare to (4.19)?\n♦\nDefinition 4.5.2.11. Let I P ObpCatq be a category. The right cone on I, denoted IZ,\nis the category defined as follows. On objects we put ObpIZq \" ObpIq\\t8u, and we call\nthe new object 8 the cone point of IZ. On morphisms we add a single new morphism\ntb : b N 8 for every object b P ObpIq; more precisely,\nHomIZpa, bq \"\n$\n'\n'\n'\n&\n'\n'\n'\n%\nHomIpa, bq\nif a, b P ObpIq\nttbu\nif a P ObpIq, b \" 8\ntid8u\nif a \" b \" 8\nH\nif a \" 8, b P ObpIq.\nThe composition formula is in some sense obvious. To compose two morphisms both in\nI, compose as dictated by I; if one has 8 as target then there will be a unique choice of\ncomposite.\nThere is an obvious inclusion of categories I N IZ.\nExercise 4.5.2.12. Let C be the category p2YqZ, where 2 is the discrete category on two\nobjects. Then C is somehow square-shaped, but what category is it exactly? Looking\nat Example 4.5.2.2, is C the commutative diagram indexing category r1s ˆ r1s, is it the\nnon-commutative diagram indexing category FpGq, or is it something else?\n♦\n4.5.3\nLimits and colimits in a category\nLet C be a category, let I be an indexing category (which just means that I is a category\nthat we're about to use as the indexing category for a diagram), and let D: I N C an\nI-shaped diagram (which just means a functor). It is in relation to this setup that we\ncan discuss the limit or colimit. In general the limit of a diagram D: I N C will be a IY\nshaped diagram lim D: IY N C. In the case of products I \" 2 and IY \" Star2 looks\nlike a span (see Example 4.5.2.8). But out of all the IY-shaped diagrams, which is the\nlimit of D? Answer: the one with the universal \"gateway\" property, see Remark 4.5.1.9.\n4.5.3.1\nUniversal objects\nDefinition 4.5.3.2. Let C be a category. An object a P ObpCq is called initial if, for\nall objects c P ObpCq there exists a unique morphism a N c, i.e. |HomCpa, cq| \" 1. An\nobject z P ObpCq is called terminal if, for all objects c P ObpCq there is exists a unique\nmorphism c N z, i.e. |HomCpc, zq| \" 1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nAn object in a category is called universal if it is either initial or terminal, but we\nrarely use that term in practice, preferring to be specific about whether the object is\ninitial or terminal. The word final is synonymous with the word terminal, but we'll try\nto constantly use terminal.\nColimits will end up being defined as initial things of a certain sort, and limits will\nend up being defined as terminal things of a certain sort. But we will get to that in\nSection 4.5.3.15.\nWarning 4.5.3.3. A category C may have more than one initial object; similarly a category\nC may have more than one terminal object. We will see in Example 4.5.3.5 that any set\nwith one element, e.g. t u or t,u, is a terminal object in Set. These terminal sets have\nthe same number of elements, but they are not the exact-same set; two sets having the\nsame cardinality means precisely that there exists an isomorphism between them.\nIn fact, Proposition 4.5.3.4 below shows that in any category C, any two terminal\nobjects in C are isomorphic (similarly, any two initial objects in C are isomorphic).\nWhile there are many isomorphisms in Set between t1, 2, 3u and ta, b, cu, there is only\none isomorphism between t u and ,. This is always the case for universal objects: there\nis a unique isomorphism between any two terminal (respectively initial) objects in any\ncategory.\nAs a result, people often speak of the initial object in C or the terminal object in C,\nas though there was only one. \"It's unique up to unique ismorphism!\" is the justification\nfor this use of the so-called definite article the rather than the indefinite article a. This\nis not a very misleading way of speaking, because just like the president today does not\ncontain exactly the same atoms as the president yesterday, the difference is unimportant.\nBut we still mention this as a warning: if C has a terminal object, we may speak of it as\nthough it were unique, calling it the terminal object, and similarly for initial objects.\nWe will use the definite article throughout this document, e.g. in Example 4.5.3.5\nwe will discuss the initial object in Set and the terminal object in Set. This is common\nthroughout mathematical literature as well.\nProposition 4.5.3.4. Let C be a category and let a1, a2 P ObpCq both be initial objects.\nThen there is a unique isomorphism a1\n-\nYN a2. (Similarly, for any two terminal objects\nin C there is a unique isomorphism between them.)\nProof. Suppose a1 and a2 are initial.\nSince a1 is initial there is a unique morphism\nf : a1 N a2; there is also a unique morphism a1 N a1, which must be ida1. Since a2 is\ninitial there is a unique morphism g: a2 N a1; there is also a unique morphism a2 N a2,\nwhich must be ida2. So g f \" ida1 and f g \" ida2, which means that f is the desired\n(unique) isomorphism.\nThe proof for terminal objects is appropriately \"dual\".\n□\nExample 4.5.3.5. The initial object in Set is the set a for which there is always one way\nto map from a to anything else. Given c P ObpSetq there is exactly one function H N c,\nbecause there are no choices to be made, so the empty set H is the initial object in Set.\nThe terminal object in Set is the set z for which there is always one way to map to\nz from anything else. Given c P ObpSetq there is exactly one function c N t,u, where\nt,u is any set with one element, because there are no choices to be made: everything in\nc must be sent to the single element in t,u. There are lots of terminal objects in Set,\nand they are all isomorphic to 1.\n\n4.5. LIMITS AND COLIMITS\nExample 4.5.3.6. The initial object in Grph is the graph a for which there is always one\nway to map from a to anything else. Given c P ObpGrphq, there is exactly one function\nH N c, where H P Grph is the empty graph; so H is the initial object.\nThe terminal object in Grph is more interesting. It is Loop, the graph with one\nvertex and one arrow. In fact there are infinitely many terminal objects in Grph, but\nall of them are isomorphic to Loop.\nExercise 4.5.3.7. Let X be a set, let PpXq be the set of subsets of X (see Definition\n2.7.4.9). We can regard PpXq as a preorder under inclusion of subsets (see for example\nSection 3.4.2). And we can regard preorders as categories using a functor PrO N Cat\n(see Proposition 4.2.1.17).\na.) What is the initial object in PpXq?\nb.) What is the terminal object in PpXq?\n♦\nExample 4.5.3.8. The initial object in the category Mon of monoids is the trivial monoid,\n1. For any monoid M, a morphism of monoids 1 N M is a functor between 1-object\ncategories and these are determined by where they send morphisms. Since 1 has only\nthe identity morphism and functors must preserve identities, there is no choice involved\nin finding a monoid morphism 1 N M.\nSimilarly, the terminal object in Mon is also the trivial monoid, 1. For any monoid\nM, a morphism of monoids M N 1 sends everything to the identity; there is no choice.\nExercise 4.5.3.9.\na.) What is the initial object in Grp, the category of groups?\nb.) What is the terminal object in Grp?\n♦\nExample 4.5.3.10. Recall the preorder Prop of logical propositions from Section 4.2.4.1.\nThe initial object is a proposition that implies all others. It turns out that \"FALSE\" is\nsuch a proposition. The proposition \"FALSE\" is like \"1 % 1\"; in logical formalism it can\nbe shown that if \"FALSE\" is true then everything is true.\nThe terminal object in Prop is a proposition that is implied by all others. It turns\nout that \"TRUE\" is such a proposition. In logical formalism, everything implies that\n\"TRUE\" is true.\nExample 4.5.3.11. The discrete category 2 has no initial object and no terminal ob-\nject. The reason is that it has two objects 1, 2, but no maps from one to the other, so\nHom2p1, 2q \" Hom2p2, 1q \" H.\nExercise 4.5.3.12. Recall the divides preorder from Exercise 4.5.1.4, where 5 divides 15.\na.) Considering this preorder as a category, does it have an initial object?\nb.) Does it have a terminal object?\n♦\nExercise 4.5.3.13. Let M \" pListpta, buq, r s, ``q denote the free monoid on ta, bu (see\nDefinition 3.1.1.15), considered as a category (via Theorem 4.2.1.3).\na.) Does it have an initial object?\n\nCHAPTER 4. BASIC CATEGORY THEORY\nb.) Does it have a terminal object?\nc.) Which monoids have initial (respectively terminal) objects?\n♦\nExercise 4.5.3.14. Let S be a set and consider the indiscrete category KS P ObpCatq on\nobjects S (see Example 4.3.4.3).\na.) For what S does KS have an initial object?\nb.) For what S does KS have a terminal object?\n♦\n4.5.3.15\nExamples of limits\nLet C be a category and let X, Y P ObpCq be objects. Definition 4.5.1.8 defines a product\nof X and Y to be a span X\nπ1\nÐY X ˆY\nπ2\nYN Y such that for every other span X\npÐY Z\nqYN Y\nthere exists a unique morphism Z N X ˆ Y making the triangles commute. It turns out\nthat we can enunciate this in our newly formed language of universal objects by saying\nthat the span X\nπ1\nÐY X ˆ Y\nπ2\nYN Y is itself a terminal object in the category of spans\non X and Y . Phrasing the definition of products in this way will be generalizable to\ndefining arbitrary limits.\nConstruction 4.5.3.16 (Products). Let C be a category and let X1, X2 be objects. We can\nconsider this setup as a diagram X : 2 N C, where Xp1q \" X1 and Xp2q \" X2. Consider\nthe category 2Y \" Star2, which is drawn in Example 4.5.2.8; the inclusion i: 2 N 2Y, as\nin (4.20); and the category of functors Funp2Y, Cq. The objects in Funp2Y, Cq are spans\nin C and the morphisms are natural transformations between them. Given a functor\nS : 2Y N C we can compose with i: 2 N 2Y to get a functor 2 N C. We want that to be\nX.\nX\n/\ni\n\nC\n2Y\nS\n?\nSo we are ready to define the category of spans on X1 and X2.\nDefine the category of spans on X, denoted C{X, to be the category whose objects\nand morphisms are as follows:\nObpC{Xq \" tS : 2Y N C | S i \" Xu\n(4.21)\nHomC{XpS, S1q \" tα: S N S1 | α i \" idXu.\nThe product of X1 and X2 was defined in Definition 4.5.1.8; we can now recast X1 ˆ X2\nas the terminal object in C{X.\nTo bring this down to earth, an object in C{X can be pictured as a diagram in C of\nthe following form:\nZ\np\n\nq\n\nX1\nX2\n\n4.5. LIMITS AND COLIMITS\nIn other words, the objects of C{X are spans, each of which we might write in-line as\nX1\npÐY Z\nqYN X2. A morphism in C{X from object X1\npÐY Z\nqYN X2 to object X1\np1\nÐY Z1\nq1\nYN\nX2 consists of a morphism l: Z N Z1, such that p1 l\" p and q1 l\" q. So the set of\nsuch morphisms in C{X are all the l's that make the right-hand diagram commute: 29\nHomC{X\n\nZ\np\n\nq\n\nX1\nX2\n,\nZ1\np1\n\nq1\n\nX1\nX2\n\n‹‹‚\n\"\n$\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n&\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n%\nZ\np\n\nq\n\nl\n\nX1\nX2\nZ1\np1\nY\nq1\nE\n,\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n.\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n-\n(4.22)\nEach object in C{X is a span on X1 and X2, and each morphism in C{X is a \"morphism\nof cone points in C making everything in sight commute\". The terminal object in C{X is\nthe product of X1 and X2; see Definition 4.5.1.8.\nIt may be strange to have a category in which the objects are spans in another\ncategory. But once you admit this possibility, the notion of morphism between spans\nis totally sensible. Or if it isn't, then stare at (4.22) for 30 seconds and say to yourself\n\"When in Rome..!\" These are the aqueducts of category theory, and they work wonders.\nExample 4.5.3.17. Consider the arbitrary 6-object category C drawn below, in which the\n29To be completely pedantic, according to (4.21), the morphisms in C{X should be drawn like this:\nHomC{X\n\nZ\np\n\nq\n\nX1\nX2\n,\nZ1\np1\n\nq1\n\nX1\nX2\n\n‹‹‹‹‚\n\"\n$\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n&\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n'\n%\nZ\np\n\nq\n\nα 8\n\nX1\nα1\nX2\nα2\nX1\nX2\nZ1\np1\nY\nq1\nE\n,\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n.\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n/\n-\nBut this is going a bit overboard. The point is, the set HomC{X is the set of morphisms serving the role\nof α 8 : Z N Z1.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nthree diagrams that can commute do:\nC :\"\nX1‚\nA‚\na\nB‚\nf\no\n✓\nb1\n@\nb2\n\nC‚\n✓\n✓\nc1\n^\nc2\ng\n/ D‚\nd1\nl\nd2\nr\nX2‚\nLet X : 2 N C be given by Xp1q \" X1 and Xp2q \" X2. Then the category of spans on\nX might be drawn\nC{X -\npB,b1,b2q\n‚\npC,c1,c2q\n‚\ng\n/ pD,d1,d2q\n‚\n4.5.3.18\nDefinition of limit\nDefinition 4.5.3.19. Let C be a category, let I be a category; let IY be the left cone on\nI, and let i: I N IY be the inclusion. Suppose that X : I N C is an I-shaped diagram\nin C. The slice category of C over X denoted C{X is the category whose objects and\nmorphisms are as follows:\nObpC{Xq \" tS : IY N C | S i \" Xu\nHomC{XpS, S1q \" tα: S N S1 | α i \" idXu.\nA limit of X, denoted limI X or lim X, is a terminal object in C{X.\nPullbacks\nThe relevant indexing category for pullbacks is the cospan, I \" 2Z drawn\nas to the left below:\nI\n0‚\n\n1‚\n\n2‚\nX : I N C\nX0‚\n\nX1‚\nX2‚\nA I-shaped diagram in C is a functor X : I N C, which we might draw as to the right\nabove (e.g. X0 P ObpCq).\n30We use a dash box here because we're not drawing the whole category but merely a diagram existing\ninside C.\n\n4.5. LIMITS AND COLIMITS\nAn object S in the slice category C{X is a commutative diagram S : IY N C over X,\nwhich looks like the box to the left below:\nS P ObpC{Xq\nS 8\n!\n}\nX0‚\n\nX1‚\n~\nX2‚\nf : S N S1\nS 8\n\nf\n\nS1\n\n~\nX0‚\n\nX1‚\n~\nX2‚\nA morphism in C{X is drawn in the dashbox to the right above. A terminal object in\nC{X is precisely the \"gateway\" we want, i.e. the limit of X is the pullback X0 ˆX2 X1.\nExercise 4.5.3.20. Let I be the graph indexing category (see 4.7).\na.) What is IY?\nb.) Now let G: I N Set be the graph from Example 3.3.1.2. Give an example of an\nobject in Set{G.\nc.) We have already given a name to the limit of G: I N Set; what is it?\n♦\nExercise 4.5.3.21. Let C be a category and let I \" H be the empty category. There is a\nunique functor X : H N C.\na.) What is the slice category C{X?\nb.) What is the limit of X?\n♦\nExample 4.5.3.22. Often one wants to take the limit of some strange diagram. We have\nnow constructed the limit for any shape diagram. For example, if we want to take the\nproduct of more than two, say n, objects, we could use the diagram shape I \" n whose\ncone is Starn from Example 4.5.2.8.\nExample 4.5.3.23. We have now defined limits in any category, so we have defined limits\nin Cat. Let r1s denote the category depicted\n0‚\ne\n/ 1‚\nand let C be a category. Naming two categories is the same thing as naming a functor\nX : 2 N Cat, so we now have such a functor. Its limit is denoted r1s ˆ C. It turns\nout that r1s ˆ C looks like a \"C-shaped prism\". It consists of two panes, front and back\nsay, each having the precise shape as C (same objects, same arrows, same composition),\nand morphisms from the front pane to the back pane making all front-to-back squares\n\nCHAPTER 4. BASIC CATEGORY THEORY\ncommute. For example, if C looked was the category generated by the schema to the left\nbelow, then C ˆ r1s would be the category generated by the schema to the right below:\nA‚\nf\n/\ng\n\nB‚\nh\n\nC‚\nD‚\nA1‚\nf1\n/\ng1\nB1‚\nh1\n\nA0‚\nAe\n@\nf0\n/\ng0\n\nB0‚\nBe\n@\nh0\n\nC1‚\nD1‚\nC0‚\nCe\n@\nD0‚\nDe\n@\nIt turns out that a natural transformation α: F N G between functors F, G: C N D\nis the same thing as a functor C ˆ r1s N D such that the front pane is sent via F\nand the back pane is sent via G. The components are captured by the front-to-back\nmorphisms, and the naturality is captured by the commutativity of the front-to-back\nsquares in C ˆ r1s.\nRemark 4.5.3.24. Recall in Section 2.7.6.6 we described relative sets. In fact, Definition\n2.7.6.7 basically defines a category of relative sets over any fixed set B. Let 1 denote the\ndiscrete category on one object, and note that providing a functor 1 N Set is the same\nas simply providing a set, so consider B : 1 N Set. Then the slice category Set{B, as\ndefined in Definition 4.5.3.19 is precisely the category of relative sets over B: it has the\nsame objects and morphisms as was described in Definition 2.7.6.7.\n4.5.3.25\nDefinition of colimit\nThe definition of colimits is appropriately \"dual\" to the definition of limits.\nInstead\nof looking at left cones, we look at right cones; instead of being interested in terminal\nobjects, we are interested in initial objects.\nDefinition 4.5.3.26. Let C be a category, let I be a category; let IZ be the right cone\non I, and let i: I N IZ be the inclusion. Suppose that X : I N C is an I-shaped diagram\nin C. The coslice category of C over X denoted CX{ is the category whose objects and\nmorphisms are as follows:\nObpCX{q \" tS : IZ N C | S i \" Xu\nHomCX{pS, S1q \" tα: S N S1 | α i \" idXu.\nA colimit of X, denoted colimI X or colim X, is an initial object in CX{.\n\n4.5. LIMITS AND COLIMITS\nPushouts\nThe relevant indexing category for pushouts is the span, I \" 2Y drawn as\nto the left below:\nI\n1‚\n2‚\n0‚\n\\\nB\nX : I N C\nX1‚\nX2‚\nX0‚\n^\n@\nAn I-shaped diagram in C is a functor X : I N C, which we might draw as to the right\nabove (e.g. X0 P ObpCq).\nAn object S in the coslice category CX{ is a commutative diagram S : IZ N C over\nX, which looks like the box to the left below:\nS P ObpCX{q\nS8\nX1‚\n>\nX2‚\n`\nX0‚\n_\n?\nf : S N S1\nS1\nS8\nf\nO\nX1‚\n>\n<\nX2‚\n`\na\nX0‚\n?\n_\nA morphism in CX{ is drawn in the dashbox to the right above. An initial object in CX{\nis precisely the \"gateway\" we want; i.e. the colimit of X is the pushout, X1 \\X0 X2.\nExercise 4.5.3.27. Let I be the graph indexing category (see 4.7).\na.) What is IZ?\nb.) Now let G: I N Set be the graph from Example 3.3.1.2. Give an example of an\nobject in SetG{.\nc.) We have already given a name to the colimit of G: I N Set; what is it?\n♦\nExercise 4.5.3.28. Let C be a category and let I \" H be the empty category. There is a\nunique functor X : H N C.\na.) What is the coslice category CX{?\nb.) What is the colimit of X (assuming it exists)?\n♦\n\nCHAPTER 4. BASIC CATEGORY THEORY\nExample 4.5.3.29 (Cone as colimit). We have now defined colimits in any category, so we\nhave defined colimits in Cat. Let C be a category and recall from Example 4.5.3.23 the\ncategory C ˆ r1s. The inclusion of the front pane is a functor i0 : C N C ˆ r1s (similarly,\nthe inclusion of the back pane is a functor i1 : C N C ˆ r1s). Finally let t: C N 1 be the\nunique functor to the terminal category (see Exercise 4.1.2.37). We now have a diagram\nin Cat of the form\nC\ni0 /\nt\n\nC ˆ r1s\nThe colimit (i.e. the pushout) of this diagram in Cat slurps down the entire front pane\nof C ˆ r1s to a point, and the resulting category is isomorphic to CY. Figure 4.23 is a\ndrawing of this phenomenon.\n\n4.5. LIMITS AND COLIMITS\nC :\"\nA0‚\n/\n\nB0‚\n\nC0‚\nD0‚\ni0\n/\nC ˆ r1s\nA1‚\n/\n\nB1‚\n\nA0‚\n@\n/\n\nB0‚\n@\n\nC1‚\nD1‚\nC0‚\n@\nD0‚\n@\nt\n\n‚\n/\nA1‚\n/\n\nB1‚\n\n‚\n?\n\n_\n\nC1‚\nD1‚\nCY - pC ˆ r1sq \\C 1\nFigure 4.23: Let C be the category drawn in the upper left corner. The left cone CY on\nC is obtained as a pushout in Cat. We first make a prism C ˆ r1s, and then identify the\nfront pane with a point.\n(Similarly, the pushout of the analogous diagram for i1 would give CZ.)\nExample 4.5.3.30. Consider the category Top of topological spaces. The (hollow) circle\nis a topological space which people often denote S1 (for \"1-dimensional sphere\"). The\nfilled-in circle, also called a 2-dimensional disk, is denoted D2. The inclusion of the circle\ninto the disk is continuous so we have a morphism in Top of the form i: S1 N D2. The\nterminal object in Top is the one-point space t,u, and so there is a unique morphism\nt: S1 N t,u.\nThe pushout of the diagram D2\niÐY S1\ntYN t,u is isomorphic to the\n2-dimensional sphere (the exterior of a tennis ball), S2. The reason is that we have\nslurped the entire bounding circle to a point, and the category of topological spaces has\nthe right morphisms to ensure that the resulting space really is a sphere.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nApplication 4.5.3.31. Consider the symmetric graph Gn consisting of a chain of n vertices,\n1‚\n2‚\n\nn‚\nThink of this as modeling a subway line.\nThere are n-many graph homomorphisms\nG1 N Gn given by the various vertices. One can create transit maps using colimits. For\nexample, the colimit of the diagram to the left is the symmetric graph drawn to the right\nbelow.\ncolim\n\nG1\n/\n\nG7\nG1\no\n\nG5\nG3\nG1\nO\n/ G7\nG1\nO\no\n\n‹‹‹‹‹‹‹‹‹‹‚\ncan be drawn\n‚5\n1‚\n2‚\n3‚\n4‚4\n5‚\n6‚1\n7‚\n‚3\n1‚\n2‚\n3‚2\n4‚\n5‚2\n6‚\n7‚\n‚1\n‚3\n♦♦\n4.6\nOther notions in Cat\nIn this section we discuss some leftover notions about categories. For example in Section\n4.6.1 we explain a kind of duality for categories, in which arrows are flipped. For example\nreversing the order in a preorder is an example of this duality, as is the similarity between\nlimits and colimits. In Section 4.6.2 we discuss the so-called Grothendieck construction\nwhich in some sense graphs functors, and we show that it is useful for transforming\ndatabases into the kind of format (RDF) used in scraping data offwebpages. We define\na general construction for creating categories in Section 4.6.4. Finally, in Section 4.6.5\nwe show that precisely the same arithmetic statements that held for sets in Section 2.7.3\nhold for categories.\n4.6.1\nOpposite categories\nPeople used to discuss two different kinds of functors between categories: the so-called\ncovariant functors and the so-called contravariant functors.\nCovariant functors are\nwhat we have been calling functors.\nThe reader may have come across the idea of\ncontravariance when considering Exercise 4.2.3.2.31\nThere we saw that a continuous\nmapping of topological spaces f : X N Y does not induce a morphism of orders on\ntheir open sets OpenpXq N OpenpY q; that is not required by the notion of continuity.\nInstead, a morphism of topological spaces f : X N Y induces a morphism of orders\nOpenpY q N OpenpXq, going backwards. So we do not have a functor Top N PrO\nin this way, but it's quite close. One used to say that Open is a contravariant functor\nTop N PrO.\n31Similarly, see Exercise 4.2.4.4.\n\n4.6. OTHER NOTIONS IN CAT\nAs important and common as contravariance is, people found that keeping track of\nwhich functors were covariant and which were contravariant was a big hassle. Luck-\nily, there is a simple work-around, which simplifies everything: the notion of opposite\ncategories.\nDefinition 4.6.1.1. Let C be a category. The opposite category of C, denoted Cop, has\nthe same objects as C, i.e. ObpCopq \" ObpCq, and for any two objects c, c1, one defines\nHomCoppc, c1q :\" HomCpc1, cq.\nExample 4.6.1.2. If n P N is a natural number and n the corresponding discrete category,\nthen nop \" n. Recall the span category I \" 2Y from Definition 4.5.1.8. Its opposite is\nthe cospan category Iop \" 2Z, from Definition 4.5.1.23.\nExercise 4.6.1.3. Let C be the category from Example 4.5.3.17. Draw Cop.\n♦\nLemma 4.6.1.4. Let C and D be categories.\nOne has pCopqop \" C.\nAlso we have\nFunpC, Dq - FunpCop, Dopq. This implies that a functor Cop N D can be identified with\na functor C N Dop.\nProof. This follows straightforwardly from the definitions.\n□\nExercise 4.6.1.5. In Exercises 4.2.3.2, 4.2.4.3, and 4.2.4.4 there were questions about\nwhether a certain function ObpCq N ObpDq extended to a functor C N D. In each case,\nsee if the proposed function would extend to a \"contravariant functor\" i.e. to a functor\nCop N D.\n♦\nExample 4.6.1.6 (Simplicial sets). Recall from Example 4.3.4.4 the category ∆of linear\norders rns. For example, r1s is the linear order 0 d 1 and r2s is the linear order 0 d 1 d 2.\nBoth r1s and r2s are objects of ∆. There are 6 morphisms from r1s to r2s, which we\ncould denote\nHom∆pr1s, r2sq \" tp0, 0q, p0, 1q, p0, 2q, p1, 1q, p1, 2q, p2, 2qu.\nIt may seem strange, but the category ∆op turns out to be quite useful in algebraic\ntopology.\nIt is the indexing category for a combinatorial approach to the homotopy\ntheory of spaces. That is, we can represent something like the category of spaces and\ncontinuous maps using the functor category sSet :\" Funp∆op, Setq, which is called the\ncategory of simplicial sets.\nThis may seem very complicated compared to something we did earlier, namely sim-\nplicial complexes. But simplicial sets have excellent formal properties that simplicial\ncomplexes do not. We will not go further with this here, but through the work of Dan\nKan, Andr e Joyal, Jacob Lurie, and many others, simplicial sets have allowed category\ntheory to pierce deeply into the realm of topology and vice versa.\n4.6.2\nGrothendieck construction\nLet C be a database schema (or category) and let J : C N Set be an instance. We have\nbeen drawing this in table form, but there is another standard way of laying out the data\nin J, called the resource descriptive framework or RDF. Developed for the web, RDF is a\nuseful format when one does not have a schema in hand, e.g. when scraping information\n\nCHAPTER 4. BASIC CATEGORY THEORY\noffof a website, one does not know what schema will be best. In these cases, information\nis stored in so-called RDF triples, which are of the form\nxSubject, Predicate, Objecty\nFor example, one might see something like\nSubject\nPredicate\nObject\nA01\noccurredOn\nD13114\nA01\nperformedBy\nP44\nA01\nactionDescription\nTold congress to raise debt ceiling\nD13114\nhasYear\nD13114\nhasMonth\nJanuary\nD13114\nhasDay\nP44\nFirstName\nBarack\nP44\nLastName\nObama\n(4.24)\nCategory-theoretically, it is quite simple to convert a database instance J : C N Set\ninto an RDF triple store. To do so, we use the Grothendieck construction, which is more\naptly named the category of elements construction, defined below.32\nDefinition 4.6.2.1. Let C be a category and let J : C N Set be a functor. The category\nof elements of J, denoted\ns\nC J, is defined as follows:\nObp\nw\nC\nJq :\" tpC, xq | C P ObpCq, x P JpCqu.\nHoms\nC JppC, xq, pC1, x1qq :\" tf : C N C1 | Jpfqpxq \" x1u.\nThere is a natural functor πJ :\ns\nC J YN C. It sends each object pC, xq P Obp\ns\nC Jq to\nthe object C P ObpCq. And it sends each morphism f : pC, xq N pC1, x1q to the morphism\nf : C N C1. We call πJ the projection functor.\nExample 4.6.2.2. Let A be a set, and consider it as a discrete category.\nWe saw in\nExercise 4.3.3.4 that a functor S : A N Set is the same thing as an A-indexed set, as\ndiscussed in Section 2.7.6.10. We will follow Definition 2.7.6.12 and for each a P A write\nSa :\" Spaq.\nWhat is the category of elements of a functor S : A N Set? The objects of\ns\nA S are\npairs pa, sq where a P A and s P Spaq. Since A has nothing but identity morphisms,\ns\nA S\nhas nothing but identity morphisms; i.e. it is the discrete category on a set. In fact that\nset is the disjoint union\nw\nA\nS \"\ng\naPA\nSa.\nThe functor πS :\ns\nA S N A sends each element in Sa to the element a P A.\n32Apparently, Alexander Grothendieck did not invent this construction, it was discussed prior to\nGrothendieck's use of it, e.g. by Mac Lane. But more to the point, the term Grothendieck construction is\nnot grammatically suited in the sense that both the following are awkward in English: \"the Grothendieck\nconstruction of J is ...\" (awkward because J is not being constructed but used in a construction) and\n\"the Grothendieck construct for J is...\" (awkward because it just is). The term category of elements is\nmore descriptive and easier to use grammatically.\n\n4.6. OTHER NOTIONS IN CAT\nOne can see this as a kind of histogram. For example, let A \" tBOS, NYC, LA, DCu and\nlet S : A N Set assign\nSBOS \" tAbby, Bob, Casandrau,\nSNYC \" H,\nSLA \" tJohn, Jimu, and\nSDC \" tAbby, Carlau.\nThen the category of elements of S would look like the (discrete) category at the top:\nw\nA\nS \"\npBOS,Abbyq\n‚\npBOS,Bobq\n‚\npLA,Johnq\n‚\npDC,Abbyq\n‚\npBOS,Casandraq\n‚\npLA,Jimq\n‚\npDC,Carlaq\n‚\n(4.25)\nπS\n\nA \"\nBOS\n‚\nNYC\n‚\nLA‚\nDC‚\nWe also see that the category of elements construction has converted an A-indexed\nset into a relative set over A, as in Definition 2.7.6.7.\nThe above example does not show at all how the Grothendieck construction trans-\nforms a database instance into an RDF triple store. The reason is that our database\nschema was A, a discrete category that specifies no connections between data (it simply\ncollects the data into bins). So lets examine a more interesting database schema and\ninstance. This is taken from [Sp2].\nApplication 4.6.2.3. Consider the schema below, which we first encountered in Example\n3.5.2.1:\nC :\"\nEmployee manager worksIn » Employee worksIn\nDepartment secretary worksIn » Department\nEmployee\n‚\nworksIn\n/\nmanager\n\nfirst\n~\nlast\n\nDepartment\n‚\nsecretary\no\nname\n\nFirstNameString\n‚\nLastNameString\n‚\nDepartmentNameString\n‚\n(4.26)\n\nCHAPTER 4. BASIC CATEGORY THEORY\nAnd consider the instance J : C N Set, which we first encountered in (3.13) and (3.15)\nEmployee\nID\nfirst\nlast\nmanager\nworksIn\nDavid\nHilbert\nq10\nBertrand\nRussell\nx02\nEmmy\nNoether\nq10\nDepartment\nID\nname\nsecretary\nq10\nSales\nx02\nProduction\nFirstNameString\nID\nAlan\nBertrand\nCarl\nDavid\nEmmy\nLastNameString\nID\nArden\nHilbert\nJones\nNoether\nRussell\nDepartmentNameString\nID\nMarketing\nProduction\nSales\nThe category of elements of J : C N Set looks like this:\nw\nC\nJ \"\n‚\nfirst\n\nlast\n,\nmanager\nA\nworksIn\n(\n‚\n‚\nq10\n‚\nx02\n‚\nsecretary\nh\nname\n}\nAlan\n‚\nHilbert\n‚\nProduction\n‚\nBertrand\n‚\nRussell\n‚\nSales\n‚\nDavid\n‚\nNoether\n‚\nMarketing\n‚\nEmmy\n‚\nArden\n‚\nCarl\n‚\nJones\n‚\nπJ\n\n(4.27)\nC \"\nEmployee\n‚\nworksIn\n/\nmanager\n\nfirst\n\nlast\n\nDepartment\n‚\nsecretary\no\nname\n\nFirstNameString\n‚\nLastNameString\n‚\nDepartmentNameString\n‚\n\n4.6. OTHER NOTIONS IN CAT\nIn the above drawing (4.27) of\ns\nC J, we left out 10 arrows for ease of readability, for\nexample, we left out an arrow\n‚\nfirst\nYYYYYYN\nBertrand\n‚\n.\nFor the punchline, how do we see the category of elements\ns\nC J as an RDF triple\nstore? For each arrow in\ns\nC J, we take the triple consisting of the source vertex, the\narrow name, and the target vertex. So our triple store would include triples such as\nx102 first Bertrandy and x101 manager 103y.\n♦♦\nExercise 4.6.2.4. Come up with a schema and instance whose category of elements con-\ntains (at least) the data from (4.24).\n♦\nSlogan 4.6.2.5.\n\" The Grothendieck construction takes structured, boxed-up data and flattens\nit by throwing it all into one big space. The projection functor is then tasked\nwith remembering which box each datum originally came from. \"\nExercise 4.6.2.6. Recall from Section 3.1.2.10 that a finite state machine is a free monoid\npListpΣq, r s, ``q acting on a set X. Recall also that we can consider a monoid as a\ncategory M with one object and a monoid action as a set-valued functor F : M N Set,\n(see Section 4.2.1.1). In the case of Figure 3.1 the monoid in question is Listpa, bq, which\ncan be drawn as the schema\n▲\na\nb\ne\nand the functor F : M N Set is recorded in an action table in Example 3.1.3.1. What\nis\ns\nM F? How does it relate to the picture in Figure 3.1?\n♦\n4.6.3\nFull subcategory\nDefinition 4.6.3.1. Let C be a category and let X D ObpCq be a set of objects in C.\nThe full subcategory of C spanned by X is the category, which we denote by COb\"X, with\nobjects ObpCOb\"Xq :\" X and with morphisms HomCOb\"Xpx, x1q :\" HomCpx, x1q.\nExample 4.6.3.2. The following are examples of full subcategories. We will name them in\nthe form \"X inside of Y \", and each time we mean that X and Y are names of categories,\nthe category X can be considered as a subcategory of the category Y in some sense, and\nit is full. In other words, all morphisms in Y \"count\" as morphisms in X.\n- Finite sets inside of sets, Fin D Set;\n- Finite sets of the form n inside of Fin;\n- Linear orders of the form rns inside of all finite linear orders, ∆D FLin;\n- Groups inside of monoids, Grp D Mon;\n- Monoids inside of categories, Mon D Cat;\n- Sets inside of graphs, Set D Grph;\n- Partial orders (resp. linear orders) inside of PrO;\n\nCHAPTER 4. BASIC CATEGORY THEORY\n- Discrete categories (resp. indiscrete categories) inside of Cat;\nRemark 4.6.3.3. A subcategory C D D is (up to isomorphism) just a functor i: C N D\nthat happens to be injective on objects and arrows. The subcategory is full if and only\nif i is a full functor in the sense of Definition 4.3.4.12.\nExample 4.6.3.4. Let C be a category, let X D ObpCq be a set of objects, and let COb\"X\ndenote the full subcategory of C spanned by X. We can realize this as a fiber product\nof categories. Indeed, recall that for any set, we can form the indiscrete category on\nthat set; see Example 4.3.4.3.\nIn fact, we have a functor Ind: Set N Cat.\nThus\nour function X N ObpCq can be converted into a functor between indiscrete categories\nIndpXq N IndpObpCqq. There is also a functor C N IndpObpCqq sending each object to\nitself. Then the full subcategory of C spanned by X is the fiber product of categories,\nCOb\"X\n/\n\nC\n\nIndpXq\n/ IndpObpCqq\nExercise 4.6.3.5. Including all identities and all compositions, how many morphisms are\nthere in the full subcategory of Set spanned by the objects t0, 1, 2u? Write them out. ♦\n4.6.4\nComma categories\nCategory theory includes a highly developed and interoperable catalogue of materials\nand production techniques. One such is the comma category.\nDefinition 4.6.4.1. Let A, B, and C be categories and let F : A N C and G: B N C\nbe functors. The comma category of C morphisms from F to G, denoted pF OC Gq or\nsimply pF O Gq, is the category with objects\nObpF O Gq \" tpa, b, fq | a P ObpAq, b P ObpBq, f : Fpaq N Gpbq in Cu\nand for any two objects pa, b, fq and pa1, b1, f 1q the set HompF OGqppa, b, fq, pa1, b1, f 1qq of\nmorphisms pa, b, fq YN pa1, b1, f 1q is\ntpq, rq | q: a N a1 in A, r: b N b1 in B, such that f 1 Fpqq \" Gprq fu.\nIn pictures,\nHompF OGqppa, b, fq, pa1, b1, f 1qq :\"\n$\n'\n'\n'\n'\n'\n&\n'\n'\n'\n'\n'\n%\na\nq\n\nFpaq\n✓\nf\n/\nF pqq\n\nGpbq\nGprq\n\nb\nr\n\na1\nFpa1q\nf 1\n/ Gpb1q\nb1\n,\n/\n/\n/\n/\n/\n.\n/\n/\n/\n/\n/\n-\nWe refer to the diagram A\nFYN C\nG\nÐY B (in Cat) as the setup for the comma category\npF O Gq.\nThere is a canonical functor pF O Gq N A called left projecton, sending pa, b, fq to a,\nand a canonical functor pF O Gq N B called right projection, sending pa, b, fq to b.\n\n4.6. OTHER NOTIONS IN CAT\nA setup A\nFYN C\nG\nÐY B is reversable; i.e. we can flip it to obtain B\nG\nYN C\nF\nÐY A.\nHowever, note that pF O Gq is different than (i.e. almost never equivalent to) pG O Fq,\nunless every arrow in C is an isomorphism.\nSlogan 4.6.4.2.\n\" When two categories A, B can be interpreted in a common setting C, the\ncomma category integrates them by recording how to move from A to B\ninside C. \"\nExample 4.6.4.3. Let C be a category and I : C N Set a functor. In this example we\nshow that the comma category construction captures the notion of taking the category\nof elements\ns\nC I; see Definition 4.6.2.1.\nConsider the set 1, the category Discp1q, and the functor F : Discp1q N Set sending\nthe unique object to the set 1. We use the comma category setup 1\nF\nYYYN Set\nI\nÐYYY C.\nThere is an isomorphism of categories\nz\nC\nI - pF O Iq.\nIndeed, an object in pF O Iq is a triple pa, b, fq where a P Obp1q, b P ObpCq, and\nf : Fpaq N Ipbq is a morphism in Set. There is only one object in 1, so this reduces to\na pair pb, fq where b P ObpCq and f : t,u N Ipbq. The set of functions t,u N Ipbq is\nisomorphic to Ipbq, as we saw in Exercise 2.1.2.14. So we have reduced ObpF O Iq to the\nset of pairs pb, xq where b P ObpCq and x P Ipbq; this is Obp\ns\nC Iq. Because there is only\none function 1 N 1, a morphism pb, xq N pb1, x1q in pF O Iq boils down to a morphism\nr: b N b1 such that the diagram\nx / Ipbq\nIprq\n\nx1 / Ipb1q\ncommutes.\nBut such diagrams are in one-to-one correspondence with the diagrams\nneeded for morphisms in\ns\nC I.\nExercise 4.6.4.4. Let C be a category and let c, c1 P ObpCq be objects. Consider them\nas functors c, c1 : 1 N C, and consider the setup 1\nc\nYYYN C\nc1\nÐYYY 1. What is the comma\ncategory pc O c1q?\n♦\n4.6.5\nArithmetic of categories\nIn Section 2.7.3, we summarized some of the properties of products, coproducts, and\nexponentials for sets, attempting to show that they lined up precisely with familiar\narithmetic properties of natural numbers. Astoundingly, we can do the same for cate-\ngories.\nIn the following proposition, we denote the coproduct of two categories A and B by\nthe notation A ` B rather than A \\ B. We also denote the functor category FunpA, Bq\nby BA. Finally, we use 0 and 1 to refer to the discrete category on 0 and on 1 object,\nrespectively.\n\nCHAPTER 4. BASIC CATEGORY THEORY\nProposition 4.6.5.1. The following isomorphisms exist for any small categories A, B,\nand C.\n- A ` 0 - A\n- A ` B - B ` A\n- pA ` Bq ` C - A ` pB ` Cq\n- A ˆ 0 - 0\n- A ˆ 1 - A\n- A ˆ B - B ˆ A\n- pA ˆ Bq ˆ C - A ˆ pB ˆ Cq\n- A ˆ pB ` Cq - pA ˆ Bq ` pA ˆ Cq\n- A0 - 1\n- A1 - A\n- 0A - 0,\nif A % 0\n- 1A - 1\n- AB`C - AB ˆ AC\n- pABqC - ABˆC\nProof. These are standard results; see [Mac].\n□\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996Category Theory for Scientist\nSpring 2013\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Textbook: Categories and Functors, without Admitting it",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/27c14ddd6a3e9911888a138fb0b712e3_MIT18_S996S13_chapter3.pdf",
      "content": "Chapter 3\nCategories and functors,\nwithout admitting it\nIn this chapter we begin to use our understanding of sets to build more interesting\nmathematical devices, each of which organizes our understanding of a certain kind of\ndomain. For example, monoids organize our thoughts about agents acting on objects;\ngroups are monoids except restricted to only allow agents to act reversibly. We will\nthen study graphs, which are systems of nodes and arrows that can capture ideas like\ninformation flow through a network or model connections between building blocks in a\nmaterial. We will discuss orders, which can be used to study taxonomies or hierarchies.\nFinally we take a mathematical look at databases, which actually subsume everything\nelse in the chapter. Databases are connection patterns for structuring information.\nWe will see in Chapter 4 that everything we study in the present chapter is an example\nof a category. So is Set, the category of sets studied in Chapter 2. One way to think of\na category is as a set of objects and a connection pattern between them; sets are objects\n(ovals full of dots if you wish) connected by functions. But each set is itself a category:\nthe objects inside it are just disconnected! Just like a set has an interior view and an\nexterior view, so will all the categories in this chapter. Each monoid is a category, but\nthere is also a category of monoids.\nHowever, we will not really say the word \"category\" much if at all in this chapter.\nIt seems preferable to let the ideas rise on their own accord as interesting structures in\ntheir own right before explaining that everything in site fits into a single framework.\nThat will be the pleasant reward to come in Chapter 4.\n3.1\nMonoids\nA common way to interpret phenomena we see around us is to say that agents are acting\non objects. For example, in a computer drawing program, the user acts on the canvas\nin certain prescribed ways. Choices of actions from an available list can be performed in\nsequence to transform one image into another. As another example, one might investigate\nthe notion that time acts on the position of hands on a clock in a prescribed way. A\nfirst rule for actions is this: the performance of a sequence of several actions is itself the\nperformance of an action--a more complex action, but an action nonetheless.\nMathematical objects called monoids and groups are tasked with encoding the agent's\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nperspective in all this, i.e. what the agent can do, and what happens when different\nactions are done in succession. A monoid can be construed as a set of actions, together\nwith a formula that encodes how a sequence of actions is itself considered an action. A\ngroup is the same as a monoid, except that every action is required to be reversible. In\nthis section we concentrate on monoids; we will get to groups in Section 3.2.\n3.1.1\nDefinition and examples\nDefinition 3.1.1.1 (Monoid). A monoid is a sequence pM, e, ‹q, where M is a set, e P M\nis an element, and ‹: M ˆM N M is a function, such that the following conditions hold\nfor all m, n, p P M:\n- m ‹ e \" m,\n- e ‹ m \" m, and\n- pm ‹ nq ‹ p \" m ‹ pn ‹ pq.\nWe refer to e as the identity element and to ‹ as the multiplication formula for the\nmonoid.\n1 We call the first two rules identity laws and the third rule the associativity\nlaw for monoids.\nRemark 3.1.1.2. To be pedantic, the conditions from Definition 3.1.1.1 should be stated\n- ‹pm, eq \" m,\n- ‹pe, mq \" m, and\n- ‹p‹pm, nq, pq \" ‹pm, p‹pn, pqq.\nThe way they are written in Definition 3.1.1.1 is called infix notation, and we often use\ninfix notation without mentioning it. That is, given a function : A ˆ B N C, we may\nwrite a b rather than pa, bq.\nExample 3.1.1.3 (Additive monoid of natural numbers). Let M \" N be the set of natural\nnumbers. Let e \" 0 and let ‹: M ˆ M N M denote addition, so that ‹p4, 18q \" 22.\nThen the equations m ‹ 0 \" m and 0 ‹ m \" m hold, and pm ‹ nq ‹ p \" m ‹ pn ‹ pq. By\nassigning e and ‹ in this way, we have \"given N the structure of a monoid\".\nRemark 3.1.1.4. Sometimes we are working with a monoid pM, e, ‹q, and the identity\ne and multiplication ‹ are somehow clear from context. In this case we might refer to\nthe set M as though it were the whole monoid. For example, if we were discussing the\nmonoid from Example 3.1.1.3, we might refer to it as N. The danger comes because sets\nmay have multiple monoid structures, as we see below in Exercise 3.1.1.6.\nExample 3.1.1.5 (Non-monoid). If M is a set, we might call a function f : M ˆ M N M\nan operation on M. For example, if M \" N is the set of natural numbers, we can consider\nthe operation f : N N N called exponentiation. For example fp2, 5q \" 2 2 2 2 2 \" 32\nand fp7, 2q \" 49. This is indeed an operation, but it is not part of any monoid. For one\nthing there is no possible unit. Trying the obvious choice of e \" 1, we see that a1 \" a\n(good), but that 1a \" 1 (bad: we need it to be a). For another thing, this operation is\nnot associative because in general abc % pabqc. For example, 212 \" 2 but p21q2 \" 4.\n1Although the function ‹: M ˆ M N M is called the multiplication formula, it may have nothing\nto do with multiplication. It is nothing more than a formula for taking two inputs and returning an\noutput; calling it \"multiplication\" is suggestive of its origins, rather than prescriptive of its behavior.\n\n3.1. MONOIDS\nOne might also attempt to consider an operation f : M ˆ M N M that, upon closer\ninspection, aren't even operations. For example, if M \" Z then exponentiation is not\neven an operation. Indeed, fp2, 1q \" 2 1 \" 1\n2, and this is not an integer. To have a\nfunction f : M ˆ M N M, we need that every element of the domain, in this case every\npair of integers, has an output under f. So there is no such function f.\nExercise 3.1.1.6. Let M \" N be the set of natural numbers. Taking e \" 1, come up with\na formula for ‹ that gives N the structure of a monoid.\n♦\nExercise 3.1.1.7. Come up with an operation on the set M \" t1, 2, 3, 4u, i.e. a legitimate\nfunction f : M ˆM N M, such that f cannot be the multiplication formula for a monoid\non M. That is, either it is not associative, or no element of M can serve as a unit.\n♦\nExercise 3.1.1.8. In both Example 3.1.1.3 and Exercise 3.1.1.6, the monoids pM, e, ‹q\nsatisfied an additional rule called commutativity, namely m‹n \" n‹m for every m, n P M.\nThere is a monoid pM, e, ‹q lurking in linear algebra textbooks that is not commutative;\nif you have background in linear algebra try to answer this: what M, e, and ‹ might I\nbe referring to?\n♦\nExercise 3.1.1.9. Recall the notion of commutativity for monoids from Exercise 3.1.1.8.\na.) What is the smallest set M that you can give the structure of a non-commutative\nmonoid?\nb.) What is the smallest set M that you can give the structure of a monoid?\n♦\nExample 3.1.1.10 (Trivial monoid). There is a monoid with only one element, M \"\npteu, e, ‹q where ‹: teu ˆ teu N teu is the unique function. We call this monoid the\ntrivial monoid, and sometimes denote it 1.\nExample 3.1.1.11. Suppose that pM, e, ‹q is a monoid. Given elements m1, m2, m3, m4\nthere are five different ways to parenthesize the product m1 ‹ m2 ‹ m3 ‹ m4, and the\nassociativity law for monoids will show them all to be the same. We have\nppm1 ‹ m2q ‹ m3q ‹ m4 \" pm1 ‹ m2q ‹ pm3 ‹ m4q\n\" pm1 ‹ pm2 ‹ m3qq ‹ m4\n\" m1 ‹ pm2 ‹ pm3 ‹ m4qq\n\" m1 ‹ ppm2 ‹ m3q ‹ m4q\nIn fact, the product of any list of monoid elements is the same, regardless of parenthe-\nsization. Therefore, we can unambiguously write m1m2m3m4m5 rather than any given\nparenthesization of it. This is known as the coherence theorem and can be found in\n[Mac].\n3.1.1.12\nFree monoids and finitely presented monoids\nDefinition 3.1.1.13. Let X be a set. A list in X is a pair pn, fq where n P N is a natural\nnumber (called the length of the list) and f : n N X is a function, where n \" t1, 2, . . . , nu.\nWe may denote such a list by\npn, fq \" rfp1q, fp2q, . . . , fpnqs.\nThe empty list is the unique list in which n \" 0; we may denote it by r s. Given an\nelement x P X the singleton list on x is the list rxs. Given a list L \" pn, fq and a number\ni P N with i d n, the ith entry of L is the element fpiq P X.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nGiven two lists L \" pn, fq and L1 \" pn1, f 1q, define the concatenation of L and L1,\ndenoted L ``L1, to be the list pn ` n1, f ``f 1q, where f ``f 1 : n ` n1 N X is given on\ni d n ` n1 by\npf ``f 1qpiq :\"\n#\nfpiq\nif i d n\nf 1pi nq\nif i e n ` 1\nExample 3.1.1.14. Let X \" ta, b, c, . . . , zu. The following are elements of ListpXq:\nra, b, cs, rps, rp, a, a, a, ps, r s, . . .\nThe concatenation of ra, b, cs and rp, a, a, a, ps is ra, b, c, p, a, a, a, ps. The concatenation\nof any list A with r s is just A.\nDefinition 3.1.1.15. Let X be a set. The free monoid generated by X is the sequence\nM :\" pListpXq, r s, ``q, where ListpXq is the set of lists of elements in X, where r s P\nListpXq is the empty list, and where `` is the operation of list concatenation. We refer\nto X as the set of generators for the monoid M.\nExercise 3.1.1.16. Let t,u denote a one-element set.\na.) What is the free monoid generated by t,u?\nb.) What is the free monoid generated by H?\n♦\nIn the definition below, we will define a monoid M by specifying some generators\nand some relations. Lists of generators provide us all the possible ways to write elements\nof M. The relations allow us to have two such ways of writing the same element. The\nfollowing definition is a bit dense, so see Example 3.1.1.19 for a concrete example.\nDefinition 3.1.1.17 (Presented monoid). Let G be a finite set, let n P N be a natural\nnumber, 2 and for each 1 d i d n, let mi and m1\ni be elements of ListpGq.\nThe\nmonoid presented by generators G and relations tpmi, m1\niq | 1 d i d nu is the monoid\nM \" pM, e, ‹q defined as follows.\nLet „ denote the equivalence relation on ListpGq\ngenerated by tpxmiy „ xm1\niyq | x, y P ListpGq, 1 d i d nu, and define M \" ListpGq{ „.\nLet e \" r s and let a b be obtained by concatenating representing lists.\nRemark 3.1.1.18. Every free monoid is a presented monoid, because we can just take the\nset of relations to be empty.\nExample 3.1.1.19. Let G \" ta, b, c, du. Think of these as buttons that can be pressed.\nThe free monoid ListpGq is the set of all ways of pressing buttons, e.g. pressing a then a\nthen c then c then d corresponds to the list ra, a, c, c, ds. The idea of presented monoids\nis that you notice that pressing ra, a, cs always gives the same result as pressing rd, ds.\nYou also notice that pressing rc, a, c, as is the same thing as doing nothing.\nIn this case, we would have m1 \" ra, a, cs, m1\n1 \" rd, ds, and m2 \" rc, a, c, as, m1\n2 \" r s\nand relations tpm1, m1\n1q, pm2, m1\n2qu. Really this means that we're equating m1 with m1\nand m2 with m1\n2, which for convenience we'll write out:\nra, a, cs \" rd, ds\nand\nra, c, a, cs \" r s\n2The number n P N is going to stand for the number of relations we declare.\n3Each mi and m1\ni are going to be made equal in the set M.\n\n3.1. MONOIDS\nTo see how this plays out, we give an example of a calculation in M \" ListpGq{ „.\nNamely,\nrb, c, b, d, d, a, c, a, a, c, ds \" rb, c, b, a, a, c, a, c, a, a, c, ds \" rb, c, b, a, a, a, c, ds\n\" rb, c, b, a, d, d, ds.\nApplication 3.1.1.20 (Buffer). Let G \" ta, b, c, . . . zu. Suppose we have a buffer of 32\ncharacters and we want to consider the set of lists of length at most 32 to be a monoid.\nWe simply have to decide what happens when someone types a list of length more than\n32.\nOne option is to say that the last character typed overwrites the 32nd entry,\nra1, a2, . . . , a31, a32, bs „1 ra1, a2, . . . , a31, bs.\nAnother option is to say that any character typed after 32 entries is discarded,\nra1, a2, . . . , a31, a32, bs „2 ra1, a2, . . . , a31, a32s.\nBoth of these yield finitely presented monoids, generated by G. (In case it's useful, the\nnumber of necessary relations in both cases is 2633.)\n♦♦\nExercise 3.1.1.21. Let's consider the buffer concept again (see Application 3.1.1.20), but\nthis time only having size 3 rather than size 32. Show using Definition 3.1.1.17 that with\nrelations given by „1 we indeed have ra, b, c, d, e, fs \" ra, b, fs and that with relations\ngiven by „2 we indeed have ra, b, c, d, e, fs \" ra, b, cs.\n♦\nExercise 3.1.1.22. Let K :\" tBS, a, b, c, . . . , zu, a set having 27 elements. Suppose you\nwant to think of BS P K as the \"backspace key\" and the elements a, b, . . . z P K as the\nletter keys on a keyboard. Then the free monoid ListpKq is not quite appropriate as a\nmodel because we want ra, b, d, BSs \" ra, bs.\na.) Choose a set of relations for which the monoid presented by generators K and the\nchosen relations is appropriate to this application.\nb.) Under your relations, how does rBSs compare with r s? Is that suitable?\n♦\n3.1.1.23\nCyclic monoids\nDefinition 3.1.1.24. A monoid is called cyclic if it has a presentation involving only\none generator.\nExample 3.1.1.25. Let Q be a symbol; we look at some cyclic monoids generated by\ntQu. With no relations the monoid would be the free monoid on one generator, and\nwould have underlying set tr s, rQs, rQ, Qs, rQ, Q, Qs, . . .u, with identity element r s and\nmultiplication given by concatenation (e.g. rQ, Q, Qs ``rQ, Qs \" rQ, Q, Q, Q, Qs). This\nis just N, the additive monoid of natural numbers.\nWith the really strong relation rQs „ r s we would get the trivial monoid, a monoid\nhaving only one element (see Example 3.1.1.10).\nAnother possibility is given in the first part of Example 3.1.2.3, where the relation\nQ12 „ r s is used, where Q12 is shorthand for rQ, Q, Q, Q, Q, Q, Q, Q, Q, Q, Q, Qs.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nExample 3.1.1.26. Consider the cyclic monoid with generator Q and relation Q7 \" Q4.\nThis monoid has seven elements, te \" Q0, Q \" Q1, Q2, Q3, Q4, Q5, Q6u, and we know\nthat Q6 ‹ Q5 \" Q7 Q4 \" Q4 Q4 \" Q7 Q \" Q5. One might depict this monoid as\nfollows\ne‚\n/ Q‚\n/ Q2\n‚\n/ Q3\n‚\n/ Q4\n‚\n\nQ6\n‚\nA\nQ5\n‚\no\nTo see the mathematical source of this intuitive depiction, see Example 5.2.1.17.\nExercise 3.1.1.27 (Classify the cyclic monoids). Classify all the cyclic monoids up to\nisomorphism. That is, come up with a naming system such that every cyclic monoid can\nbe given a name in your system, such that no two non-isomorphic cyclic monoids have\nthe same name, and such that no name exists in the system unless it refers to a cyclic\nmonoid.\nHint: one might see a pattern in which the three monoids in Example 3.1.1.25 corre-\nspond respectively to 8, 1, and 12, and then think \"Cyclic monoids can be classified by\n(i.e. systematically named by elements of) the set N \\ t8u.\" That idea is on the right\ntrack, but is not correct.\n♦\n3.1.2\nMonoid actions\nDefinition 3.1.2.1 (Monoid action). Let pM, e, ‹q be a monoid and let S be a set. An\naction of pM, e, ‹q on S, or simply an action of M on S or an M-action on S, is a\nfunction\nu : M ˆ S N S\nsuch that the following conditions hold for all m, n P M and all s P S:\n- e u s \" s\n- m u pn u sq \" pm ‹ nq u s. 4\nRemark 3.1.2.2. To be pedantic (and because it's sometimes useful), we may rewrite u\nas α: M ˆ S N S and restate the conditions from Definition 3.1.2.1 as\n- αpe, sq \" s, and\n- αpm, αpn, sqq \" αpm ‹ n, sq.\nExample 3.1.2.3. Let S \" t0, 1, 2, . . . , 11u and let N \" pN, 0, `q be the additive monoid\nof natural numbers (see Example 3.1.1.3). We define a function u: NˆS N S by taking\na pair pn, sq to the remainder that appears when n ` s is divided by 12. For example\n4 u 2 \" 6 and 8 u 9 \" 5. This function has the structure of a monoid action because\nthe two rules from Definition 3.1.2.1 hold.\n4 Definition 3.1.2.1 actually defines a left action of pM, e, ‹q on S. A right action is like a left action\nexcept the order of operations is somehow reversed. We will not really use right-actions in this text, but\nwe briefly define it here for completeness. With notation as above, the only difference is in the second\ncondition. We replace it by the condition that for all m, n P M and all s P S we have\nm u pn u sq \" pn ‹ mq u s\n\n3.1. MONOIDS\nSimilarly, let T denote the set of points on a circle, elements of which are denoted by\na real number in the interval r0, 12q, i.e.\nT \" tx P R | 0 d x a 12u\nand let R \" pR, 0, `q denote the additive monoid of real numbers. Then there is an\naction R ˆ T N T, similar to the one above (see Exercise 3.1.2.4).\nOne can think of this as an action of the monoid of time on the clock.\nExercise 3.1.2.4.\na.) Realize the set T :\" r0, 12q D R as the coequalizer of a pair of arrows R N R.\nb.) For any x P R, realize the mapping x : T N T, implied by Example 3.1.2.3, using\nthe universal property of coequalizers.\nc.) Prove that it is an action.\n♦\nExercise 3.1.2.5. Let B denote the set of buttons (or positions) of a video game controller\n(other than, say 'start' and 'select'), and consider the free monoid ListpBq on B.\na.) What would it mean for ListpBq to act on the set of states of some game? Imagine\na video game G1 that uses the controller, but for which ListpBq would not be said to\nact on the states of G1. Now imagine a simple game G for which ListpBq would be\nsaid to act.\nb.) Can you think of a state s of G, and two distinct elements l, l1 P ListpBq such that\nlu s \" l1 u s? In video game parlance, what would you call an element b P B such\nthat, for every state s P G, one has b u s \" s?\nc.) In video game parlance, what would you call a state s P S such that, for every\nsequence of buttons lP ListpBq, one has lu s \" s?\n♦\nApplication 3.1.2.6. Let f : R N R be a differentiable function of which we want to find\nroots (points x P R such that fpxq \" 0). Let x0 P R be a starting point. For any n P N\nwe can apply Newton's method to xn to get\nxn`1 \" xn fpxnq\nf 1pxnq.\nThis is a monoid (namely N, the free monoid on one generator) acting on a set (namely\nR).\nHowever, Newton's method can get into trouble. For example at a critical point it\ncauses division by 0, and sometimes it can oscillate or overshoot. In these cases we want\nto perturb a bit to the left or right. To have these actions available to us, we would add\n\"perturb\" elements to our monoid. Now we have more available actions at any point,\nbut at the cost of using a more complicated monoid.\nWhen publishing an experimental finding, there may be some deep methodological\nquestions that are not considered suitably important to mention. For example, one may\nnot publish the kind solution finding method (e.g. Newton's method or Runge-Kutta)\nthat was used, nor the set of available actions, e.g. what kinds of perturbation were used\nby the researcher. However, these may actually influence the reproducibility of results.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nBy using a language such as that of monoid actions, we can align our data model with\nour unspoken assumptions about how functions are analyzed.\n♦♦\nRemark 3.1.2.7. A monoid is useful for understanding how an agent acts on the set of\nstates of an object, but there is only one kind of action. At any point, all actions are\navailable. In reality it is often the case that contexts can change and different actions\nare available at different times. For example on a computer, the commands available in\none application have no meaning in another. This will get us to categories in the next\nchapter.\n3.1.2.8\nMonoids actions as ologs\nIf monoids are understood in terms of how they act on sets, then it is reasonable to think\nof them in terms of ologs. In fact, the ologs associated to monoids are precisely those\nologs that have exactly one type (and possibly many arrows and commutative diagrams).\nExample 3.1.2.9. In this example we show how to associate an olog to a monoid action.\nConsider the monoid M generated by the set tu, d, ru, standing for \"up, down, right\",\nand subject to the relations\nru, ds „ r s,\nrd, us „ r s,\nru, rs \" rr, us,\nand\nrd, rs \" rr, ds.\nWe might imagine that M acts on the set of positions for a character in an old video\ngame. In that case the olog corresponding to this action should look something like the\nfollowing:\na character\nposition\nwhen moved up\nresults in\nwhen moved\ndown results in\nwhen moved right\nresults in\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved up results in a character position, which\nwhen moved down results in a character position that we'll call P(x). We also\nknow that x is a character position that we'll call Q(x). Fact: whenever x is a\ncharacter position we will have P(x)=Q(x). Summary: [up, down] = [ ]\n\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved down results in a character position,\nwhich when moved up results in a character position that we'll call P(x). We also\nknow that x is a character position that we'll call Q(x). Fact: whenever x is a\ncharacter position we will have P(x)=Q(x). Summary: [down, up] = [ ]\n\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved up results in a character position, which\nwhen moved right results in a character position that we'll call P(x). We also\nknow that x is a character position, which when moved right results in a\ncharacter position, which when moved up results in a character position that\nwe'll call Q(x). Fact: whenever x is a character position we will have P(x)=Q(x).\nSummary: [up, right] = [right, up]\n\nGiven x, a character position, consider the following. We know that x is a\ncharacter position, which when moved down results in a character position,\nwhich when moved right results in a character position that we'll call P(x). We\nalso know that x is a character position, which when moved right results in a\ncharacter position, which when moved down results in a character position that\nwe'll call Q(x). Fact: whenever x is a character position we will have P(x)=Q(x).\nSummary: [down, right] = [right, down]\n3.1.2.10\nFinite state machines\nAccording to Wikipedia, a deterministic finite state machine is a quintuple pΣ, S, s0, δ, Fq,\nwhere\n1. Σ is a finite non-empty set of symbols, called the input alphabet,\n2. S is a finite, non-empty set, called the state set,\n3. δ: Σ ˆ S N S is a function, called the state-transition function, and\n\n3.1. MONOIDS\n4. s0 P S is an element, called the initial state,\n5. F D S is a subset, called the set of final states.\nIn this book we will not worry about the initial state and the set of final states,\nconcerning ourselves more with the interaction via δ of the alphabet Σ on the set S of\nstates.\nState 0\nState 1\nState 2\na\nb\na\na\nb\nb\nFigure 3.1:\nA finite state machine with alphabet Σ \" ta, bu and state set S \"\ntState 0, State 1, State 2u. If pressed, we will make State 0 the initial state and {State\n2} the set of final states.\nThe following proposition expresses the notion of finite state automata in terms of\nfree monoids and their actions on finite sets.\nProposition 3.1.2.11. Let Σ, S be finite non-empty sets. Giving a function δ: ΣˆS N\nS is equivalent to giving an action of the free monoid ListpΣq on S.\nProof. By Definition 3.1.2.1, we know that function ε: ListpΣq ˆ S N S constitutes an\naction of the monoid ListpΣq on the set S if and only if, for all s P S we have εpr s, sq \" s,\nand for any two elements m, m1 P ListpΣq we have εpm, εpm1, sqq \" εpm ‹ m1, sq, where\nm ‹ m1 is the concatenation of lists. Let\nA \" tε: ListpΣq ˆ S N S | ε constitutes an actionu.\nWe need to prove that there is an isomorphism of sets\nφ: A -\nYN HomSetpΣ ˆ S, Sq.\nGiven an element ε: ListpΣqˆS N S in A, define φpεq on an element pσ, sq P ΣˆS by\nφpεqpσ, sq :\" εprσs, sq, where rσs is the one-element list. We now define ψ: HomSetpΣ ˆ\nS, Sq N A.\nGiven an element f P HomSetpΣ ˆ S, Sq, define ψpfq: ListpΣq ˆ S N S on a pair\npL, sq P ListpΣq ˆ S, where L \" rε1, . . . , εns as follows. By induction, if n \" 0, put\nψpfqpL, sq \" s; if n e 1, let L1 \" rε1, . . . , εn 1s and put ψpfqpL, sq \" ψpfqpL1, fpεn, sqq.\nOne checks easily that ψpfq satisfies the two rules above, making it an action of ListpΣq\non S. It is also easy to check that φ and ψ are mutually inverse, completing the proof.\n□\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nWe sum up the idea of this section as follows:\nSlogan 3.1.2.12.\n\" A finite state machine is an action of a free monoid on a finite set. \"\nExercise 3.1.2.13. Consider the functions φ and ψ above.\na.) Show that for any f : Σ ˆ S N S, the map ψpfq: ListpΣq ˆ S N S constitutes an\naction.\nb.) Show that φ and ψ are mutually inverse functions (i.e. φ ψ \" idHompΣˆS,Sq and\nψ φ \" idA.)\n♦\n3.1.3\nMonoid action tables\nLet M be a monoid generated by the set G \" tg1, . . . , gmu, and with some relations,\nand suppose that α: M ˆ S N S is an action of M on a set S \" ts1, . . . , snu. We can\nrepresent the action α using an action table whose columns are the elements of G and\nwhose rows are the elements of S. In each cell prow, colq, where row P S and col P G,\nwe put the element αpcol, rowq P S.\nExample 3.1.3.1 (Action table). If Σ and S are the sets from Figure 3.1, the displayed\naction of ListpΣq on S would be given by the action table\nAction from 3.1\nID\na\nb\nState 0\nState 1\nState 2\nState 1\nState 2\nState 1\nState 2\nState 0\nState 0\n(3.2)\nExample 3.1.3.2 (Multiplication action table). Every monoid acts on itself by its multi-\nplication formula, M ˆM N M. If G is a generating set for M, we can write the elements\nof G as the columns and the elements of M as rows, and call this a multiplication table.\nFor example, let pN, 1, q denote the multiplicative monoid of natural numbers. The\nmultiplication table is as follows:\nMultiplication of natural numbers\nN\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n...\n...\n...\n...\n...\n...\n...\n...\n(3.3)\n\n3.1. MONOIDS\nTry to understand what is meant by this: \"applying column 2 and then column 2 returns\nthe same thing as applying column 4.\"\nIn the above table, we were implicitly taking every element of N as a generator (since\nwe had a column for every natural number).\nIn fact, there is a smallest generating\nset for the monoid pN, 1, q, so that every element of the monoid is a product of some\ncombination of these generators, namely the primes and 0.\nMultiplication of natural numbers\nN\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n...\n...\n...\n...\n...\n...\n...\n...\nExercise 3.1.3.3. Let N be the additive monoid of natural numbers, let S \" t0, 1, 2, . . . , 11u,\nand let : NˆS N S be the action given in Example 3.1.2.3. Using a nice small generating\nset for the monoid, write out the corresponding action table.\n♦\n3.1.4\nMonoid homomorphisms\nA monoid pM, e, ‹q involves a set, an identity element, and a multiplication formula. For\ntwo monoids to be comparable, their sets, their identity elements, and their multiplication\nformulas should be appropriately comparable. For example the additive monoids N and\nZ should be comparable because N D Z is a subset, the identity elements in both cases\nare the same e \" 0, and the multiplication formulas are both integer addition.\nDefinition 3.1.4.1. Let M :\" pM, e, ‹q and M1 :\" pM 1, e1, ‹1q be monoids. A monoid\nhomomorphism f from M to M1, denoted f : M N M1, is a function f : M N M 1\nsatisfying two conditions:\n- fpeq \" e1, and\n- fpm1 ‹ m2q \" fpm1q ‹1 fpm2q, for all m1, m2 P M.\nThe set of monoid homomorphisms from M to M1 is denoted HomMonpM, M1q.\nExample 3.1.4.2 (From N to Z). As stated above, the inclusion map i: N N Z induces a\nmonoid homomorphism pN, 0, `q N pZ, 0, `q because ip0q \" 0 and ipn1 ` n2q \" ipn1q `\nipn2q.\nLet i5 : N N Z denote the function i5pnq \" 5 n, so i5p4q \" 20. This is also a monoid\nhomomorphism because i5p0q \" 5 0 \" 0 and i5pn1`n2q \" 5 pn1`n2q \" 5 n1`5 n2 \"\ni5pn1q ` i5pn2q.\nApplication 3.1.4.3. Let R \" ta, c, g, uu and let T \" R3, the set of triplets in R. Let\nR \" ListpRq be the free monoid on R and let T \" ListpTq denote the free monoid on\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nT. There is a monoid homomorphism F : T N R given by sending t \" pr1, r2, r3q to the\nlist rr1, r2, r3s. 5\nIf A be the set of amino acids and A \" ListpAq the free monoid on A, the process\nof translation gives a monoid homomorphism G: T N A, turning a list of RNA triplets\ninto a polypeptide. But how do we go from a list of RNA nucleotides to a polypeptide?\nThe answer is that there is no good way to do this mathematically. So what is going\nwrong?\nThe answer is that there should not be a monoid homomorphism R N A because not\nall sequences of nucleotides produce a polypeptide; for example if the sequence has only\ntwo elements, it does not code for a polypeptide. There are several possible remedies to\nthis problem. One is to take the image of F, which is a submonoid R1 D R. It is not\nhard to see that there is a monoid homomorphism F 1 : R1 N T , and we can compose it\nwith G to get our desired monoid homomorphism G F 1 : R1 N A. 6\n♦♦\nExample 3.1.4.4. Given any monoids M there is a unique monoid homomorphism from\nM to the trivial monoid 1 (see Example 3.1.1.10). There is also a unique homomorphism\n1 N M. These facts together have an upshot: between any two monoids M and M1 we\ncan always construct a homomorphism\nM\n!\nYYYN 1\n!\nYYYN M1\nwhich we call the trivial homomorphism M N M1. A morphism M N M1 that is not\ntrivial is called a nontrivial homomorphism.\nProposition 3.1.4.5. Let M \" pZ, 0, `q and M1 \" pN, 0, `q. The only monoid homo-\nmorphism f : M N M1 sends every element m P Z to 0 P N.\nProof. Let f : M N M1 be a monoid homomorphism, and let n \" fp1q and n1 \" fp 1q\nin N. Then we know that since 0 \" 1`p 1q in Z we must have 0 \" fp0q \" fp1`p 1qq \"\nfp1q ` fp 1q \" n ` n1 P N. But if n e 1 then this is impossible, so n \" 0. Similarly\nn1 \" 0. Any element m P Z can be written m \" 1`1` `1 or as m \" 1` 1` ` 1,\nand it is easy to see that fp1q ` fp1q ` ` fp1q \" 0 \" fp 1q ` fp 1q ` ` fp 1q.\nTherefore, fpmq \" 0 for all m P Z.\n□\nExercise 3.1.4.6. For any m P N let im : N N Z be the function impnq \" m n. All\nsuch functions are monoid homomorphisms pN, 0, `q N pZ, 0, `q. Do any monoid homo-\nmorphisms pN, 0, `q N pZ, 0, `q not come in this way? For example, what about using\nn ÞN 5 n 1 or n ÞN n2, or some other function?\n♦\nExercise 3.1.4.7. Let M :\" pN, 0, `q be the additive monoid of natural numbers, let N \"\npRe0, 0, `q be the additive monoid of nonnegative real numbers, and let P :\" pRa0, 1, q\nbe the multiplicitive monoid of positive real numbers. Can you think of any nontrivial\nmonoid homomorphisms of the following sorts:\nM N N,\nM N P,\nN N P,\nN N M,\nP N N?\n♦\n5More\nprecisely,\nthe\nmonoid\nhomomorphism\nF\nsends\na\nlist\nrt1, t2, . . . , tns\nto\nthe\nlist\nrr1,1, r1,2, r1,3, r2,1, r2,2, r2,3, . . . , rn,1, rn,2, rn,3s, where for each 0 d i d n we have ti \" pri,1, ri,2, ri,3q.\n6Adding stop-codons to the mix we can handle more of R, e.g. sequences that don't have a multiple-\nof-three many nucleotides.\n\n3.1. MONOIDS\n3.1.4.8\nHomomorphisms from free monoids\nRecall that pN, 0, `q is the free monoid on one generator. It turns out that for any other\nmonoid M \" pM, e, ‹q, the set of monoid homomorphisms N N M is in bijection with\nthe set M. This is a special case (in which G is a set with one element) of the following\nproposition.\nProposition 3.1.4.9. Let G be a set, let FpGq :\" pListpGq, r s, ``q be the free monoid\non G, and let M :\" pM, e, ‹q be any monoid. There is a natural bijection\nHomMonpFpGq, Mq -\nYN HomSetpG, Mq.\nProof. We provide a function φ: HomMonpFpGq, Mq N HomSetpG, Mq and a function\nψ: HomSetpG, Mq N HomMonpFpGq, Mq and show that they are mutually inverse. Let\nus first construct φ. Given a monoid homomorphism f : FpGq N M, we need to provide\nφpfq: G N M. Given any g P G we define φpfqpgq :\" fprgsq.\nNow let us construct ψ. Given p: G N M, we need to provide ψppq: ListpGq N M\nsuch that ψppq is a monoid homomorphism. For a list L \" rg1, . . . , gns P ListpGq, define\nψppqpLq :\" ppg1q ‹ ‹ ppgnq P M. In particular, ψppqpr sq \" e. It is not hard to see\nthat this is a monoid homomorphism. It is also easy to see that φ ψppq \" p for all\np P HomSetpG, Mq. We show that ψ φpfq \" f for all f P HomMonpFpGq, Mq. Choose\nL \" rg1, . . . , gns P ListpGq. Then\nψpφfqpLq \" pφfqpg1q ‹ ‹ pφfqpgnq \" frg1s ‹ ‹ frgns \" fprg1, . . . , gnsq \" fpLq.\n□\nExercise 3.1.4.10. Let G \" ta, bu, let M :\" pM, e, ‹q be any monoid, and let f : G N M\nbe given by fpaq \" m and fpbq \" n, where m, n P M.\nIf ψ: HomSetpG, Mq N\nHomMonpFpGq, Mq is the function from the proof of Proposition 3.1.4.9 and L \"\nra, a, b, a, bs, what is ψpfqpLq ?\n♦\n3.1.4.11\nRestriction of scalars\nA monoid homomorphism f : M N M 1 (see Definition 3.1.4.1) ensures that the elements\nof M have a reasonable interpretation in M 1; they act the same way over in M 1 as\nthey did back home in M. If we have such a homomorphism f and we have an action\nα: M 1 ˆ S N S of M 1 on a set S, then we have a method for allowing M to act on S as\nwell. Namely, we take an element of M, send it over to M 1, and act on S. In terms of\nfunctions, we compose α with the function f ˆ idS : M ˆ S N M 1 ˆ S, to get a function\nwe'll denote\n∆fpαq: M ˆ S N S.\nAfter Proposition 3.1.4.12 we will know that ∆fpαq is indeed a monoid action, and we\nsay that it is given by restriction of scalars along f.\nProposition 3.1.4.12. Let M :\" pM, e, ‹q and M1 :\" pM 1, e1, ‹1q be monoids, f : M N\nM1 a monoid homomorphism, S a set, and suppose that α: M 1 ˆ S N S is an action of\nM1 on S. Then ∆fpαq: M ˆ S N S, defined as above, is a monoid action as well.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nProof. Refer to Remark 3.1.2.2; we assume α is a monoid action and want to show that\n∆fpαq is too. We have ∆fpαqpe, sq \" αpfpeq, sq \" αpe1, sq \" s. We also have\n∆fpαqpm, ∆fpαqpn, sqq \" αpfpmq, αpfpnq, sqq \" αpfpmq ‹1 fpnq, sq\n\" αpfpm ‹ nq, sq\n\" ∆fpαqpm ‹ n, sq.\n□\nExample 3.1.4.13. Let N and Z denote the additive monoids of natural numbers and\nintegers, respectively, and let i: N N Z be the inclusion, which we saw in Example\n3.1.4.2 is a monoid homomorphism. There is an action α: Z ˆ R N R of the monoid\nZ on the set R of real numbers, given by αpn, xq \" n ` x. Clearly, this action works\njust as well if we restrict our scalars to N D Z, allowing ourselves only to add natural\nnumbers to reals. The action ∆iα: N ˆ R N R is given on pn, xq P N ˆ R by ∆iαpn, xq \"\nαpipnq, xq \" αpn, xq \" n ` x, just as expected.\nExample 3.1.4.14. Suppose that V is a complex vector space. In particular, this means\nthat the monoid C of complex numbers (under multiplication) acts on the elements of V .\nIf i: R N C is the inclusion of the real line inside C, then i is a monoid homomorphism.\nRestriction of scalars in the above sense turns V into a real vector space, so the name\n\"restriction of scalars\" is apt.\nExercise 3.1.4.15. Let N be the free monoid on one generator, let Σ \" ta, bu, and let\nS \" tState 0, State 1, State 2u. Consider the map of monoids f : N N ListpΣq given by\nsending 1 ÞN ra, b, bs. The monoid action α: ListpΣq ˆ S N S given in Example 3.1.3.1\ncan be transformed by restriction of scalars along f to an action ∆fpαq of N on S. Write\ndown its action table.\n♦\n3.2\nGroups\nGroups are monoids in which every element has an inverse. If we think of these structures\nin terms of how they act on sets, the difference between groups and monoids is that the\naction of every group element can be undone. One way of thinking about groups is in\nterms of symmetries. For example, the rotations and reflections of a square form a group.\nAnother way to think of the difference between monoids and groups is in terms of\ntime. Monoids are likely useful in thinking about diffusion, in which time plays a role and\nthings cannot be undone. Groups are more likely useful in thinking about mechanics,\nwhere actions are time-reversible.\n3.2.1\nDefinition and examples\nDefinition 3.2.1.1. Let pM, e, ‹q be a monoid. An element m P M is said to have an\ninverse if there exists an m1 P M such that mm1 \" e and m1m \" e. A group is a monoid\npM, e, ‹q in which every element m P M has an inverse.\nProposition 3.2.1.2. Suppose that M :\" pM, e, ‹q is a monoid and let m P M be an\nelement. Then m has at most one inverse. 7\n7If M is a group then every element m has exactly one inverse.\n\n3.2. GROUPS\nProof. Suppose that both m1 and m2 are inverses of m; we want to show that m1 \" m2.\nThis follows by the associative law for monoids:\nm1 \" m1pmm2q \" pm1mqm2 \" m2.\n□\nExample 3.2.1.3. The additive monoid pN, 0, `q is not a group because none of its ele-\nments are invertible, except for 0. However, the monoid of integers pZ, 0, `q is a group.\nThe monoid of clock positions from Example 3.1.1.25 is also a group. For example the\ninverse of Q5 is Q7 because Q5 ‹ Q7 \" e \" Q7 ‹ Q5.\nExample 3.2.1.4. Consider a square centered at the origin in R2. It has rotational and\nmirror symmetries. There are eight of these, which we denote\nte, ρ, ρ2, ρ3, φ, φρ, φρ2, φρ3u,\nwhere ρ stands for 90 counterclockwise rotation and φ stands for horizontal-flip (across\nthe vertical axis). So relations include ρ4 \" e, φ2 \" e, and ρ3φ \" φρ.\nExample 3.2.1.5. The set of 3ˆ3 matrices can be given the structure of a monoid, where\nthe identity element is the 3 ˆ 3 identity matrix, the multiplication is matrix multiplica-\ntion. The subset of invertible matrices forms a group, called the general linear group of\ndimension 3 and denoted GL3. Inside of GL3 is the so-called orthogonal group, denoted\nO3, of matrices M such that M 1 \" M J. These matrices correspond to symmetries of\nthe sphere centered at the origin.\nAnother interesting group is the Euclidean group Ep3q which consists of all isometries\nof R3, i.e. all functions R3 N R3 that preserve distances.\nApplication 3.2.1.6. In crystallography one is often concerned with the symmetries that\narise in the arrangement A of atoms in a molecule. To think about symmetries in terms of\ngroups, we first define an atom-arrangement to be a finite subset i: A D R3. A symmetry\nin this case is an isometry of R3 (see Example 3.2.1.5), say f : R3 N R3 such that there\nexists a dotted arrow making the diagram below commute:\nA\n/\ni\nA\ni\nR3\nf\n/ R3\nThat is, it's an isometry of R3 such that each atom of A is sent to a position currently\noccupied by an atom of A. It is not hard to show that the set of such isometries forms\na group, called the space group of the crystal.\n♦♦\nExercise 3.2.1.7. Let S be a finite set. A permutation of S is an isomorphism f : S\n-\nYN S.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nS\ns1\ns4\ns2\ns3\nS\ns1\ns4\ns2\ns3\na.) Come up with an identity, and a multiplication formula, such that the set of permu-\ntations of S forms a monoid.\nb.) Is it a group?\n♦\nExercise 3.2.1.8. In Exercise 3.1.1.27 you classified the cyclic monoids. Which of them\nare groups?\n♦\nDefinition 3.2.1.9 (Group action). Let pG, e, ‹q be a group and S a set. An action of\nG on S is a function u: G ˆ S N S such that for all s P S and g, g1 P G, we have\n- e u s \" s and\n- g u pg1 u sq \" pg ‹ g1q u s.\nIn other words, considering G as a monoid, it is an action in the sense of Definition\n3.1.2.1.\nExample 3.2.1.10. When a group acts on a set, it has the character of symmetry. For\nexample, consider the group whose elements are angles θ. This group may be denoted\nUp1q and is often formalized as the unit circle in C of complex numbers z \" a ` bi\nsuch that |z| \" a2 ` b2 \" 1. The set of such points is given the structure of a group\npUp1q, e, ‹q by defining the identity element to be e :\" 1 ` 0i and the group law to be\ncomplex multiplication. But for those unfamiliar with complex numbers, this is simply\nangle addition where we understand that 360 \" 0 . If θ1 \" 190 and θ2 \" 278 , then\nθ1 ‹ θ2 \" 468 \" 108 . In the language of complex numbers, z \" eiθ.\nThe group Up1q acts on any set that we can picture as having rotational symmetry\nabout a fixed axis, such as the earth around the north-south axis. We will define S \"\ntpx, y, zq P R3 | x2 ` y2 ` z2 \" 1u, the unit sphere, and understand the rotational action\nof Up1q on S.\nWe first show that Up1q acts on R3 by θ u px, y, zq \" px cos θ ` y sin θ, x sin θ `\ny cos θ, zq, or with matrix notation as\nθ u px, y, zq :\" px, y, zq\n\ncospθq\nsinpθq\nsinpθq\ncospθq\n\n‚\nTrigonometric identities ensure that this is indeed an action.\n\n3.2. GROUPS\nIn terms of action tables, we would need infinitely many columns to express this\naction. Here is a sample\nAction of Up1q on R3\nR3\nθ \" 45\nθ \" 90\nθ \" 100\n(0,0,0)\n(0,0,0)\n(0,0,0)\n(0,0,0)\n(1,0,0)\n(.71,.71,0)\n(0,1,0)\n(-.17,.98,0)\n(0,1,-4.2)\n(-.71,.71,-4.2)\n(-1,0,-4.2)\n(-.98,-.17,-4.2)\n(3,4,2)\n(4.95,.71,2)\n(-4,3,2)\n(3.42,-3.65,2)\n...\n...\n...\n...\nFinally, we are looking to see that the action preserves length so that if px, y, zq P S\nthen θ u px, y, zq P S; this way we will have confirmed that Up1q indeed acts on S. The\ncalculation begins by assuming x2 ` y2 ` z2 \" 1 and checks\npx cos θ ` y sin θq2 ` p x sin θ ` y cos θq2 ` z2 \" x2 ` y2 ` z2 \" 1.\nExercise 3.2.1.11. Let X be a set and consider the group of permutations of X (see\nExercise 3.2.1.7), which we will denote ΣX. Find a canonical action of ΣX on X.\n♦\nDefinition 3.2.1.12. Let G be a group acting on a set X. For any point x P X, the\norbit of x, denoted Gx, is the set\nGx :\" tx1 P X | Dg P G such that gx \" x1u.\nApplication 3.2.1.13. Let S be the surface of the earth, understood as a sphere, and let\nG \" Up1q be the group of angles acting on S as in Example 3.2.1.10. The orbit of any\npoint p \" px, y, zq P S is the set of points on the same latitude line as p.\nOne may also consider a small band around the earth, i.e. the set A \" tpx, y, zq | 1.0 d\nx2 ` y2 ` z2 d 1.05u. The action of Up1q u S extends to an action Up1q u A. The\norbits are latitude-lines-at-altitude. A simplifying assumption in climatology may be\ngiven by assuming that Up1q acts on all currents in the atmosphere in an appropriate\nsense. That way, instead of considering movement within the whole space A, we only\nallow movement that behaves the same way throughout each orbit of the group action.\n♦♦\nExercise 3.2.1.14.\na.) Consider the Up1q action on R3 given in Example 3.2.1.10. Describe the set of orbits\nof this action.\nb.) What are the orbits of the action of the permutation group Σt1,2,3u on the set t1, 2, 3u?\n(See Exercise 3.2.1.11.)\n♦\nExercise 3.2.1.15. Let G be a group and X a set on which G acts by u: G ˆ X N X.\nIs \"being in the same orbit\" an equivalence relation on X?\n♦\nDefinition 3.2.1.16. Let G and G1 be groups. A group homomorphism f : G N G1 is\ndefined to be a monoid homomorphism G N G1, where G and G1 are being regarded as\nmonoids in accordance with Definition 3.2.1.1.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n3.3\nGraphs\nIn this course, unless otherwise specified, whenever we speak of graphs we are not talking\nabout curves in the plane, such as parabolas, or pictures of functions generally. We are\nspeaking of systems of vertices and arrows.\nWe will take our graphs to be directed, meaning that every arrow points from a vertex\nto a vertex; rather than merely connecting vertices, arrows will have direction. If a and\nb are vertices, there can be many arrows from a to b, or none at all. There can be arrows\nfrom a to itself. Here is the formal definition in terms of sets and functions.\n3.3.1\nDefinition and examples\nDefinition 3.3.1.1. A graph G consists of a sequence G :\" pV, A, src, tgtq where\n- V is a set, called the set of vertices of G (singular:vertex),\n- A is a set, called the set of arrows of G,\n- src: A N V is a function, called the source function for G, and\n- tgt: A N V is a function, called the target function for G.\nGiven an arrow a P A we refer to srcpaq as the source vertex of a and to tgtpaq as the\ntarget vertex of a.\nTo draw a graph, first draw a dot for every element of V . Then for every element\na P A, draw an arrow connecting dot srcpaq to dot tgtpaq.\nExample 3.3.1.2 (Graph). Here is a picture of a graph G \" pV, A, src, tgtq:\nG :\"\n‚v\nf\n/ ‚w\nh\n=\ng\n#\n‚x\n‚y\ni\n\nj\n#\n‚z\nk\na\n(3.4)\nWe have V \" tv, w, x, y, zu and A \" tf, g, h, i, j, ku. The source and target functions\nsrc, tgt: A N V can be captured in the table to the left below:\nA\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\ni\ny\ny\nj\ny\nz\nk\nz\ny\nV\nv\nw\nx\ny\nz\nIn fact, all of the data of the graph G is captured in the two tables above--together they\ntell us the sets A and V and the functions src and tgt.\n\n3.3. GRAPHS\nExample 3.3.1.3. Every olog has an underlying graph. The additional information in an\nolog has to do with which pairs of paths are declared equivalent, as well as text that has\ncertain English-readability rules.\nExercise 3.3.1.4. a.) Draw the graph corresponding to the following tables:\nA\nsrc\ntgt\nf\nv\nw\ng\nv\nw\nh\nv\nw\ni\nx\nw\nj\nz\nw\nk\nz\nz\nV\nu\nv\nw\nx\ny\nz\nb.) Write down two tables, as above, corresponding to the following graph:\na‚\n/ b‚\n/\nc‚\n_\n/ d‚\ne‚\nf‚\no\n/ g‚\nB\n♦\nExercise 3.3.1.5. Let A \" t1, 2, 3, 4, 5u and B \" ta, b, cu. Draw them and choose an\narbitrary function f : A N B and draw it.\nLet A \\ B be the coproduct of A and\nB (Definition 2.4.2.1) and let A\ni1\nYN A \\ B\ni2\nÐY B be the two inclusions.\nConsider\nthe two functions src, tgt: A N A \\ B, where src \" i1 and tgt is the composition\nA\nfYN B\ni2\nYN A \\ B. Draw the associated graph pA \\ B, A, src, tgtq.\n♦\nExercise 3.3.1.6.\na.) Let V be a set. Suppose we just draw the elements of V as vertices and have no\narrows between them. Is this a graph?\nb.) Given V , is there any other \"canonical\" or somehow automatic non-random proce-\ndure for generating a graph with those vertices?\n♦\nExample 3.3.1.7. Recall from Construction 2.5.2.5 the notion of bipartite graph, which\nwe defined to be a span (i.e. pair of functions, see Definition 2.5.2.1) A\nfÐY R\ngYN B. Now\nthat we have a formal definition of graph, we might hope that bipartite graphs fit in,\nand they do. Let V \" A \\ B and let i: A N V and j : B N V be the inclusions. Let\nsrc \" i f : R N V and let tgt \" j g: R N V be the composites.\nA\ni\n\nR\nsrc\n'\ntgt\nf\n?\ng\n\nV\nB\nj\n>\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nThen pV, R, src, tgtq is a graph that would be drawn exactly as we specified the drawing\nof spans in Construction 2.5.2.5.\nExample 3.3.1.8. Let n P N be a natural number. The chain graph of length n, denoted\nrns is the graph depicted here:\n0‚\n/ 1‚\n/\n/ n‚\nIn general rns has n arrows and n ` 1 vertices. In particular, when n \" 0 we have that\nr0s is the graph consisting of a single vertex and no arrows.\nExample 3.3.1.9. Let G \" pV, A, src, tgtq be a graph; we want to spread it out over\ndiscrete time, so that each arrow does not occur within a given time-slice but instead\nover a quantum unit of time.\nLet N \" pN, N, n ÞN n, n ÞN n ` 1q be the graph depicted\n0‚\n/ 1‚\n/ 2‚\n/\nWhen we get to limits in a category, we will understand that products can be taken in\nthe category of graphs (see Example 4.5.1.5), and N ˆ G will make sense. For now, we\nconstruct it by hand.\nLet TpGq \" pV ˆ N, A ˆ N, src1, tgt1q be a new graph, where for a P A and n P N we\nhave src1pa, nq :\" psrcpaq, nq and tgt1pa, nq \" ptgtpaq, n ` 1q. This may be a bit much to\nswallow, so try to simply understand what is being done in the following example.\nLet G be the graph drawn below\na‚\nf\n\ng\nb‚\nThen TpGq will be the graph\na0‚\nf0\n/\ng0\n\na1‚\nf1\n/\ng1\n\na2‚\nf2\n/\ng2\n\nb0‚\nb1‚\nb2‚\n\nAs you can see, f-arrows still take a's to a's and g-arrows still take a's to b's, but they\nalways march forward in time.\nExercise 3.3.1.10. Let G be the graph depicted below:\na‚\nw\n%\nx\n:\nb‚\ny\ne\nz\nd\nDraw (using ellipses \" \" if necessary) the graph TpGq defined in Example 3.3.1.9.\n♦\n\n3.3. GRAPHS\nExercise 3.3.1.11. Consider the infinite graph G \" pV, A, src, tgtq depicted below,\n...\n...\n...\np0, 2q\n/\nO\np1, 2q\n/\nO\np2, 2q\n/\nO\n\np0, 1q\n/\nO\np1, 1q\n/\nO\np2, 1q\n/\nO\n\np0, 0q\n/\nO\np1, 0q\n/\nO\np2, 0q\n/\nO\n\na.) Write down the sets A and V .\nb.) What are the source and target function A N V ?\n♦\nExercise 3.3.1.12. A graph is a pair of functions A N V . This sets up the notion of\nequalizer and coequalizer (see Definitions 2.5.3.1 and 2.6.3.1).\na.) What feature of a graph is captured by the equalizer of its source and target func-\ntions?\nb.) What feature of a graph is captured by the coequalizer of its source and target\nfunctions?\n♦\n3.3.2\nPaths in a graph\nWe all know what a path in a graph is, especially if we understand that a path must\nalways follow the direction of arrows. The following definition makes this idea precise.\nIn particular, one can have paths of any finite length n P N, even length 0 or 1. Also,\nwe want to be able to talk about the source vertex and target vertex of a path, as well\nas concatenation of paths.\nDefinition 3.3.2.1. Let G \" pV, A, src, tgtq be a graph.\nA path of length n in G,\ndenoted p P Pathpnq\nG\nis a head-to-tail sequence\np \" pv0\na1\nYN v1\na2\nYN v2\na3\nYN . . . an\nYYN vnq\n(3.5)\nof arrows in G, which we denote by v0a1a2 . . . an. In particular we have canonical iso-\nmorphisms Pathp1q\nG - A and Pathp0q\nG - V ; we refer to the path of length 0 on vertex v\nas the trivial path on v and denote it simply by v. We denote by PathG the set of paths\nin G,\nPathG :\"\nd\nnPN\nPathpnq\nG .\nEvery path p P PathG has a source vertex and a target vertex, and we may denote these\nby src, tgt: PathG N V . If p is a path with srcppq \" v and tgtppq \" w, we may denote\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nit by p: v N w. Given two vertices v, w P V , we write PathGpv, wq to denote the set of\nall paths p: v N w.\nThere is a concatenation operation on paths. Given a path p: v N w and q: w N x,\nwe define the concatenation, denoted pq: v N x in the obvious way. If p \" va1, a2 . . . am\nand q \" wb1b2 . . . bn then pq \" va1 . . . amb1 . . . bn. In particular, if p (resp. r) is the\ntrivial path on vertex v (resp. vertex w) then for any path q: v N w, we have pq \" q\n(resp. qr \" q).\nExample 3.3.2.2. In Diagram (3.4), page 86, there are no paths from v to y, one path\n(f) from v to w, two paths (fg and fh) from v to x, and infinitely many paths\ntyip1pjkqq1 ipnpjkqqn | n, p1, q1, . . . , pn, qn P Nu\nfrom y to y. There are other paths as well, including the five trivial paths.\nExercise 3.3.2.3. How many paths are there in the following graph?\n1‚\nf\n/ 2‚\ng\n/ 3‚\n♦\nExercise 3.3.2.4. Let G be a graph and consider the set PathG of paths in G. Suppose\nsomeone claimed that there is a monoid structure on the set PathG, where the multipli-\ncation formula is given by concatenation of paths. Are they correct? Why or why not?\nHint: what should be the identity element?\n♦\n3.3.3\nGraph homomorphisms\nA graph pV, A, src, tgtq involves two sets and two functions. For two graphs to be com-\nparable, their two sets and their two functions should be appropriately comparable.\nDefinition 3.3.3.1. Let G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q be graphs. A\ngraph homomorphism f from G to G1, denoted f : G N G1, consists of two functions\nf0 : V N V 1 and f1 : A N A1 such that the two diagrams below commute:\nA\nf1\n/\nsrc\n\nA1\nsrc1\n\nV\nf0\n/ V 1\nA\nf1\n/\ntgt\n\nA1\ntgt1\n\nV\nf0\n/ V 1\n(3.6)\nRemark 3.3.3.2. The above conditions (3.6) may look abstruse at first, but they encode\na very important idea, roughly stated \"arrows are bound to their vertices\". Under a map\nof graphs G N G1 , one cannot flippantly send an arrow of G any old arrow of G1: it\nmust still connect the vertices it connected before. Below is an example of a mapping\nthat does not respect this condition: a connects 1 and 2 before, but not after:\n1‚\na\n/ 2‚\n1ÞN11,2ÞN21,aÞNa1\n/\n‚\n‚\na1\n/ 31\n‚\nThe commutativity of the diagrams in (3.6) is exactly what is needed to ensure that\narrows are handled in the expected way by a proposed graph homomorphism.\n\n3.3. GRAPHS\nExample 3.3.3.3 (Graph homomorphism). Let G \" pV, A, src, tgtq and G1 \" pV 1, A1, src1, tgt1q\nbe the graphs drawn to the left and right (respectively) below:\n1‚\na\n/\nd\n\nc\n\n2‚\nb\n/ 3‚\n4‚\n5‚\ne\n/ 6‚\n1 ÞN 11, 2 ÞN 21,\n3 ÞN 11, 4 ÞN 41,\n5 ÞN 51, 6 ÞN 51\n/\n‚\nw\n/\ny\n‚\nx\no\n‚\n‚\nz\n\n(3.7)\nThe colors indicate our choice of function f0 : V N V 1. Given that choice, condition (3.6)\nimposes in this case that there is a unique choice of graph homomorphism f : G N G1.\nExercise 3.3.3.4.\na.) Where are a, b, c, d, e sent under f1 : A N A1 in Diagram (3.7)?\nb.) Choose a couple elements of A and check that they behave as specified by Diagram\n(3.6).\n♦\nExercise 3.3.3.5. Let G be a graph, let n P N be a natural number, and let rns be the\nchain graph of length n, as in Example 3.3.1.8. Is a path of length n in G the same thing\nas a graph homomorphism rns N G, or are there subtle differences? More precisely, is\nthere always an isomorphism between the set of graph homomorphisms rns N G and the\nset Pathpnq\nG\nof length-n paths in G?\n♦\nExercise 3.3.3.6. Given a morphism of graphs f : G N G1, there an induced function\nPathpfq: PathpGq N PathpG1q.\na.) Is it the case that for every n P N, the function Pathpfq carries PathpnqpGq to\nPathpnqpG1q, or can path lengths change in this process?\nb.) Suppose that f0 and f1 are injective (meaning no two distinct vertices in G are sent\nto the same vertex (respectively for arrows) under f). Does this imply that Pathpfq\nis also injective (meaning no two distinct paths are sent to the same path under f)?\nc.) Suppose that f0 and f1 are surjective (meaning every vertex in G1 and every arrow\nin G1 is in the image of f). Does this imply that Pathpfq is also surjective? Hint: at\nleast one of the answers to these three questions is \"no\".\n♦\nExercise 3.3.3.7. Given a graph pV, A, src, tgtq, let i: A N V ˆV be function guaranteed\nby the universal property for products, as applied to src, tgt: A N V . One might hope\nto summarize Condition (3.6) for graph homomorphisms by the commutativity of the\nsingle square\nA\nf1\n/\ni\n\nA1\ni1\n\nV ˆ V\nf0ˆf0\n/ V 1 ˆ V 1.\n(3.8)\nIs the commutativity of the diagram in (3.8) indeed equivalent to the commutativity of\nthe diagrams in (3.6)?\n♦\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n3.3.3.8\nBinary relations and graphs\nDefinition 3.3.3.9. Let X be a set. A binary relation on X is a subset R D X ˆ X.\nIf X \" N is the set of integers, then the usual d defines a relation on X: given\npm, nq P N ˆ N, we put pm, nq P R iffm d n. As a table it might be written as to the\nleft\nm d n\nm\nn\n...\n...\nn \" 5m\nm\nn\n...\n...\n|n m| d 1\nm\nn\n...\n...\n(3.9)\nThe middle table is the relation tpm, nq P N ˆ N | n \" 5mu D N ˆ N and the right-hand\ntable is the relation tpm, nq P N ˆ N | |n m| d 1u D N ˆ N.\nExercise 3.3.3.10. A relation on R is a subset of RˆR, and one can indicate such a subset\nof the plane by shading. Choose an error bound ε a 0 and draw the relation one might\nrefer to as \"ε-approximation\". To say it another way, draw the relation \"x is within ε of\ny\".\n♦\nExercise 3.3.3.11 (Binary relations to graphs). a.) If R D SˆS is a binary relation, find\na natural way to make a graph out of it, having vertices S.\nb.) What is the set A of arrows?\nc.) What are the source and target functions src, tgt: A N S?\nd.) Take the left-hand table in (3.9) and consider its first 7 rows (i.e. forget the\n...). Draw\nthe corresponding graph (do you see a tetrahedron?).\ne.) Do the same for the right-hand table.\n♦\nExercise 3.3.3.12 (Graphs to binary relations).\na.) If pV, A, src, tgtq is a graph, find a natural way to make a binary relation R D V ˆ V\nout of it.\nb.) Take the left-hand graph G from (3.7) and write out the corresponding binary relation\nin table form.\n♦\nExercise 3.3.3.13 (Going around the loops). a.) Given a binary relation R D S ˆS, you\nknow from Exercise 3.3.3.11 how to construct a graph out of it, and from Exercise\n3.3.3.12 how to make a new binary relation out of that. How does the resulting\nrelation compare with the original?\n\n3.4. ORDERS\nb.) Given a graph pV, A, src, tgtq, you know from Exercise 3.3.3.12 how to make a new\nbinary relation out of it, and from Exercise 3.3.3.11 how to construct a new graph\nout of that. How does the resulting graph compare with the original?\n♦\n3.4\nOrders\nPeople usually think of certain sets as though they just are ordered, e.g. that an order is\nordained by God. For example the natural numbers just are ordered. The letters in the\nalphabet just are ordered. But in fact we put orders on sets, and some are simply more\ncommonly used in culture. One could order the letters in the alphabet by frequency of\nuse and e would come before a. Given different purposes, we can put different orders\non the same set. For example in Exercise 4.5.1.4 we will give a different ordering on the\nnatural numbers that is useful in elementary number theory.\nIn science, we might order the set of materials in two different ways. In the first, we\nconsider material A to be \"before\" material B if A is an ingredient or part of B, so water\nwould be before concrete. But we could also order materials based on how electrically\nconductive they are, whereby concrete would be before water. This section is about\ndifferent kinds of orders.\n3.4.1\nDefinitions of preorder, partial order, linear order\nDefinition 3.4.1.1. Let S be a set and R D S ˆ S a binary relation on S; if ps, s1q P R\nwe will write s d s1. Then we say that R is a preorder if, for all s, s1, s2 P S we have\nReflexivity: s d s, and\nTransitivity: if s d s1 and s1 d s2, then s d s2.\nWe say that R is a partial order if it is a preorder and, in addition, for all s, s1 P S we\nhave\nAntisymmetry: If s d s1 and s1 d s, then s \" s1.\nWe say that R is a linear order if it is a partial order and, in addition, for all s, s1 P S\nwe have\nComparability: Either s d s1 or s1 d s.\nWe denote such a preorder (or partial order or linear order) by pS, dq.\nExercise 3.4.1.2.\na.) Decide whether the table to the left in Display (3.9) constitutes a linear order.\nb.) Show that neither of the other tables are even preorders.\n♦\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nExample 3.4.1.3 (Partial order not linear order). We will draw an olog for playing cards.\na dia-\nmond\nis\n\"\na heart\nis\n|\na club\nis\n#\na spade\nis\n{\na red\ncard\nis\n)\na black\ncard\nis\nu\na 4 of di-\namonds\nis\n\nis\nO\na card\na black\nqueen\nis\n\nis\nc\na 4\nis\n/\na num-\nbered\ncard\nis\n<\na face\ncard\nis\na\na queen\nis\no\n(3.10)\nWe can put a binary relation on the set of boxes here by saying A d B if there is a\npath A N B. One can see immediately that this is a preorder because length=0 paths\ngive reflexivity and concatenation of paths gives transitivity. To see that it is a partial\norder we only note that there are no loops. But this partial order is not a linear order\nbecause there is no path (in either direction) between, e.g., ⌜a 4 of diamonds⌝and ⌜a\nblack queen⌝, so it violates the comparability condition.\nRemark 3.4.1.4. Note that olog (3.10) in Example 3.4.1.3 is a good olog in the sense that\ngiven any collection of cards (e.g. choose 45 cards at random from each of 7 decks and\nthrow them in a pile), they can be classified according to the boxes of (3.10) such that\nevery arrow indeed constitutes a function (which happens to be injective). For example\nthe arrow ⌜a heart⌝\nis\nYYYN ⌜a red card⌝is a function from the set of chosen hearts to the\nset of chosen red cards.\nExample 3.4.1.5 (Preorder not partial order). Every equivalence relation is a preorder\nbut rarely are they partial orders. For example if S \" t1, 2u and we put R \" S ˆS, then\nthis is an equivalence relation. It is a preorder but not a partial order (because 1 d 2\nand 2 d 1, but 1 % 2, so antisymmetry fails).\nApplication 3.4.1.6. Classically, we think of time as linearly ordered. A nice model is\npR, dq, the usual linear order on the set of real numbers. But according to the theory\nof relativity, there is not actually a single order to the events in the universe. Different\nobservers correctly observe different orders on the set of events, and so in some sense on\ntime itself.\n♦♦\nExample 3.4.1.7 (Finite linear orders). Let n P N be a natural number. Define a linear\norder on the set t0, 1, 2, . . . , nu in the standard way. Pictorially,\nrns :\"\n0‚\n/ 1‚\n/ 2‚\n/\n/ n‚\nEvery finite linear order, i.e. linear order on a finite set, is of the above form. That\nis, though the labels might change, the picture would be the same. We can make this\nprecise when we have a notion of morphism of orders (see Definition 3.4.4.1)\n\n3.4. ORDERS\nExercise 3.4.1.8. Let S \" t1, 2, 3, 4u.\na.) Find a preorder R D S ˆ S such that the set R is as small as possible. Is it a partial\norder? Is it a linear order?\nb.) Find a preorder R1 D S ˆS such that the set R1 is as large as possible. Is it a partial\norder? Is it a linear order?\n♦\nExercise 3.4.1.9.\na.) List all the preorder relations possible on the set t1, 2u.\nb.) For any n P N, how many linear orders exist on the set t1, 2, 3, . . . , nu.\nc.) Does your formula work when n \" 0?\n♦\nRemark 3.4.1.10. We can draw any preorder pS, dq as a graph with vertices S and with\nan arrow a N b if a d b. These are precisely the graphs with the following two properties\nfor any vertices a, b P S:\n1. there is at most one arrow a N b, and\n2. if there is a path from a to b then there is an arrow a N b.\nIf pS, dq is a partial order then the associated graph has an additional \"no loops\" prop-\nerty,\n3. if n P N is an integer with n e 2 then there are no paths of length n that start\nat a and end at a.\nIf pS, dq is a linear order then there is an additional \"comparability\" property,\n4. for any two vertices a, b there is an arrow a N b or an arrow b N a.\nGiven a graph G, we can create a binary relation d on its set S of vertices as follows.\nSay a d b if there is a path in G from a to b. This relation will be reflexive and transitive,\nso it is a preorder. If the graph satisfies Property 3 then the preorder will be a partial\norder, and if the graph also satisfies Property 4 then the partial order will be a linear\norder. Thus graphs give us a nice way to visualize orders.\nSlogan 3.4.1.11.\n\" A graph generates a preorder: v d w if there is a path v N w. This is a\ngreat way to picture a preorder. \"\nExercise 3.4.1.12. Let G \" pV, A, src, tgtq be the graph below.\na‚\n/ b‚\nc‚\n_\n/ d‚\ne‚\nf‚\no\n/ g‚\nB\nIn the corresponding pre-order which of the following are true:\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\na.) a d b?\nb.) a d c?\nc.) c d b?\nd.) b \" c?\ne.) e d f?\nf.) f d d?\n♦\nExercise 3.4.1.13.\na.) Let S \" t1, 2u. The subsets of S form a partial order; draw the associated graph.\nb.) Repeat this for Q \" H, R \" t1u, and T \" t1, 2, 3u.\nc.) Do you see n-dimensional cubes?\n♦\nDefinition 3.4.1.14. Let pS, dq be a preorder. A clique is a subset S1 D S such that\nfor each a, b P S1 one has a d b.\nExercise 3.4.1.15. True or false: a partial order is a preorder that has no cliques. (If\nfalse, is there a \"nearby\" true statement?)\n♦\nExample 3.4.1.16. Let X be a set and R D X ˆ X a relation. For elements x, y P X\nwe will say there is an R-path from x to y if there exists a natural number n P N and\nelements x0, x1, . . . , xn such that\n1. x0 \" x,\n2. xn \" y, and\n3. for all i P N, if 0 d i d n 1 then pxi, xi`1q P R.\nLet R denote the relation where px, yq P R if there exists an R-path from x to y. We call\nR the preorder generated by R. We note some facts about R.\nContainment. If px, yq P R then px, yq P R. That is R D R.\nReflexivity . For all x P X we have px, xq P R.\nTransitivity. For all x, y, z P X, if px, yq P R and py, zq P R then px, zq P R.\nTo check the containment claim, just use n \" 1 so x0 \" x and xn \" y. To check the\nreflexivity claim, use n \" 0 so x0 \" x \" y and condition 3 is vacuously satisfied. To check\ntransitivitiy, suppose given R-paths x \" x0, x1, . . . , xn \" y and y \" y0, y1, . . . , yp \" z;\nthen x \" x0, x1, . . . xn, y1, . . . , yp \" z will be an R-path from x to z.\nThe point is that we can turn any relation into a preorder in a canonical way. Here\nis a concrete case of the above idea.\nLet X \" ta, b, c, du and suppose given the relation tpa, bq, pb, cq, pb, dq, pd, cq, pc, cqu.\nThis is neither reflexive nor transitive, so it's not a preorder. To make it a preorder\nwe follow the above prescription.\nStarting with R-paths of length n \" 0 we put\ntpa, aq, pb, bq, pc, cq, pd, dqu into R. The R-paths of length 1 add our original elements,\n\n3.4. ORDERS\ntpa, bq, pb, cq, pb, dq, pd, cq, pc, cqu. We don't mind redundancy (e.g. pc, cq), but from now\non in this example we will only write down the new elements. The R-paths of length 2\nadd tpa, cq, pa, dqu to R. One can check that R-paths of length 3 and above do not add\nanything new to R, so we are done. The relation\nR \" tpa, aq, pb, bq, pc, cq, pd, dq, pa, bq, pb, cq, pb, dq, pd, cq, pa, cq, pa, dqu\nis reflexive and transitive, hence a preorder.\nExercise 3.4.1.17. Let X \" ta, b, c, d, e, fu and let R \" tpa, bq, pb, cq, pb, dq, pd, eq, pf, aqu.\na.) What is the preorder R generated by R?\nb.) Is it a partial order?\n♦\nExercise 3.4.1.18. Let X be the set of people and let R D X ˆ X be the relation with\npx, yq P R if x is the child of y. Describe the preorder generated by R.\n♦\n3.4.2\nMeets and joins\nLet X be any set. Recall from Definition 2.7.4.9 that the powerset of X, denoted PpXq is\nthe set of subsets of X. There is a natural order on PpXq given by the subset relationship,\nas exemplified in Exercise 3.4.1.13. Given two elements a, b P PpXq we can consider them\nas subsets of X and take their intersection as an element of PpXq which we denote a ^ b.\nWe can also consider them as subsets of X and take their union as an element of PpXq\nwhich we denote a _ b. The intersection and union operations are generalized in the\nfollowing definition.\nDefinition 3.4.2.1. Let pS, dq be a preorder and let s, t P S be elements. A meet of s\nand t is an element w P S satisfying the following universal property:\n- w d s and w d t and,\n- for any x P S, if x d s and x d t then x d w.\nIf w is a meet of s and t, we write w - s ^ t.\nA join of s and t is an element w P S satisfying the following universal property:\n- s d w and t d w and,\n- for any x P S, if s d x and t d x then w d x.\nIf w is a join of s and t, we write w - s _ t.\nThat is, the meet of s and t is the biggest thing smaller than both, i.e. a greatest\nlower bound, and the join of s and t is the smallest thing bigger than both, i.e. a least\nupper bound. Note that the meet of s and t might be s or t itself. Note that s and t may\nhave more than one meet (or more than one join). However, any two meets of s and t\nmust be in the same clique, by the universal property (and the same for joins).\nExercise 3.4.2.2. Consider the partial order from Example 3.4.1.3.\na.) What is the join of ⌜a diamond⌝and ⌜a heart⌝?\nb.) What is the meet of ⌜a black card⌝and ⌜a queen⌝?\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nc.) What is the meet of ⌜a diamond⌝and ⌜a card⌝?\n♦\nNot every two elements in a preorder need have a meet, nor need they have a join.\nExercise 3.4.2.3.\na.) If possible, find two elements in the partial order from Example 3.4.1.3 that do not\nhave a meet. 8\nb.) If possible, find two elements that do not have a join (in that preorder).\n♦\nExercise 3.4.2.4. As mentioned in the introduction to this section, the power set S :\"\nPpXq of any set X naturally has the structure of a partial order. Its elements s P S\ncorrespond to subsets s D X, and we put s d t if and only if s D t as subsets of X. The\nmeet of two elements is their intersection as subsets of X, s ^ t \" s X t, and the join of\ntwo elements is their union as subsets of X, s _ t \" s Y t.\na.) Is it possible to put a monoid structure on the set S in which the multiplication\nformula is given by meets? If so, what would the identity element be?\nb.) Is it possible to put a monoid structure on the set S in which the multiplication\nformula is given by joins? If so, what would the identity element be?\n♦\nExample 3.4.2.5 (Trees). A tree, i.e. a system of nodes and branches, all of which emanate\nfrom a single node called the root, is a partial order, but generally not a linear order. A\ntree pT, dq can either be oriented toward the root (so the root is the largest element) or\naway from the root (so the root is the smallest element); let's only consider the latter.\nBelow is a tree, pictured as a graph. The root is labeled e.\na‚\nb‚\n/ c‚\n;\n/\n#\nd‚\ne‚\n;\n#\nf‚\ng‚\n/\n#\nh‚\ni‚\n(3.11)\nIn a tree, every pair of elements s, t P T has a meet s ^ t (their closest mutual\nancestor). On the other hand if s and t have a join c \" s _ t then either c \" s or c \" t.\nExercise 3.4.2.6. Consider the tree drawn in (3.11).\na.) What is the meet i ^ h?\nb.) What is the meet h ^ b?\nc.) What is the join b _ a?\nd.) What is the join b _ g?\n♦\n8Use the displayed preorder, not any kind of \"completion of what's there\".\n\n3.4. ORDERS\n3.4.3\nOpposite order\nDefinition 3.4.3.1. Let S :\" pS, dq be a preorder. The opposite preorder, denoted Sop\nis the preorder pS, dopq having the same set of elements but where s dop s1 iffs1 d s.\nExample 3.4.3.2. Recall the preorder N :\" pN, dividesq from Exercise 4.5.1.4. Then\nN op is the set of natural numbers but where m d n iffm is a multiple of n. So 6 d 2\nand 6 d 3.\nExercise 3.4.3.3. Suppose that S :\" pS, dq is a preorder.\na.) If S is a partial order, is Sop also a partial order?\nb.) If S is a linear order, is Sop a linear order?\n♦\nExercise 3.4.3.4. Suppose that S :\" pS, dq is a preorder, and that s1, s2 P S have join t\nin S. The preorder Sop has the same elements as S. Is t the join of s1 and s2 in Sop, or\nis it their meet, or is it not necessarily their meet nor their join?\n♦\n3.4.4\nMorphism of orders\nAn order pS, dq, be it a preorder, a partial order, or a linear order, involves a set and a\nbinary relations. For two orders to be comparable, their sets and their relations should\nbe appropriately comparable.\nDefinition 3.4.4.1. Let S :\" pS, dq and S1 :\" pS1, d1q be preorders (respectively partial\norders or linear orders). A morphism of preorders (resp. of partial orders or of linear\norders) f from S to S1, denoted f : S N S1, is a function f : S N S1 such that, for every\npair of elements s1, s2 P S, if s1 d s2 then fps1q d1 fps2q.\nExample 3.4.4.2. Let X and Y be sets, let f : X N Y be a function. Then for every\nsubset X1 D X, its image fpX1q D Y is a subset (see Section 2.1.2). Thus we have a\nfunction F : PpXq N PpY q, given by taking images. This is a morphism of partial orders\npPpXq, Dq N pPpY q, Dq. Indeed, if a D b in PpXq then fpaq D fpbq in PpY q.\nApplication 3.4.4.3. It's often said that \"a team is only as strong as its weakest member\".\nIs this true for materials? The hypothesis that a material is only as strong as its weakest\nconstituent can be understood as follows.\nRecall from the introduction to this section (see 3.4, page 93) that we can put several\ndifferent orders on the set M of materials. One example there was the order given by\nconstituency (m dC m1 if m is an ingredient or constituent of m1). Another order is\ngiven by strength: m dS m1 if m1 is stronger than m (in some fixed setting).\nIs it true that if material m is a constituent of material m1 then the strength of\nm1 is less than or equal to the strength of m?\nThis is the substance of our quote\nabove. Mathematically the question would be posed, \"is there a morphism of preorders\npM, dCq YN pM, dop\nS q?\"\n♦♦\nExercise 3.4.4.4. Let X and Y be sets, let f : X N Y be a function. Then for every\nsubset Y 1 D Y , its preimage f 1pY 1q D X is a subset (see Definition 2.5.1.12). Thus we\nhave a function F : PpY q N PpXq, given by taking preimages. Is it a morphism of partial\norders?\n♦\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nExample 3.4.4.5. Let S be a set. The smallest preorder structure that can be put on\nS is to say a d b iffa \" b. This is indeed reflexive and transitive, and it is called the\ndiscrete preorder on S.\nThe largest preorder structure that can be put on S is to say a d b for all a, b P S.\nThis again is reflexive and transitive, and it is called the indiscrete preorder on S.\nExercise 3.4.4.6. Let S be a set and let pT, dT q be a preorder. Let dD be the discrete\npreorder on S. Given a morphism of preorders pS, dDq N pT, dT q we get a function\nS N T.\na.) Which functions S N T arise in this way?\nb.) Given a morphism of preorders pT, dT q N pS, dDq, we get a function T N S. In\nterms of dT , which functions T N S arise in this way?\n♦\nExercise 3.4.4.7. Let S be a set and let pT, dT q be a preorder. Let dI be the indiscrete\npreorder on S. Given a morphism of preorders pS, dIq N pT, dT q we get a function\nS N T.\na.) In terms of dT , which functions S N T arise in this way?\nb.) Given a morphism of preorders pT, dT q N pS, dIq, we get a function T N S. In\nterms of dT , which functions T N S arise in this way?\n♦\n3.4.5\nOther applications\n3.4.5.1\nBiological classification\nBiological classification is a method for dividing the set of organisms into distinct classes,\ncalled taxa. In fact, it turns out that such a classification, say a phylogenetic tree, can\nbe understood as a partial order C on the set of taxa. The typical ranking of these taxa,\nincluding kingdom, phylum, etc., can be understood as morphism of orders f : C N rns,\nfor some n P N.\nFor example we may have a tree (see Example 3.4.2.5) that looks like this\nArchaea\n‚\n/ Pyrodicticum\n‚\nSpirochetes\n‚\nLife\n‚\n/\n\n?\nBacteria\n‚\n/\nAquifex\n‚\nFungi\n‚\nEukaryota\n‚\n/\nAnimals\n‚\n/ HomoSapien\n‚\nWe also have a linear order that looks like this:\nLife\n‚\n/ Domain\n‚\n/ Kingdom\n‚\n/ Phylum\n‚\n/\n/ Genus\n‚\n/ Species\n‚\n\n3.4. ORDERS\nand the ranking system that puts Eukaryota at Domain and Hopo Sapien at Species is\nan order-preserving function from the dots upstairs to the dots downstairs; that is, it is\na morphism of preorders.\nExercise 3.4.5.2. Since the phylogenetic tree is a tree, it has all meets.\na.) Determine the meet of dogs and humans.\nb.) If we did not require the phylogenetic partial order to be a tree, what would it mean\nif two taxa (nodes in the phylogenetic partial order), say a and b, had join c with\nc % a and c % b?\n♦\nExercise 3.4.5.3.\na.) In your favorite scientific realm, are there any interesting classification systems that\nare actually orders?\nb.) Choose one; what would meets and joins mean in that setting?\n♦\n3.4.5.4\nSecurity\nSecurity, say of sensitive information, is based on two things: a security clearance and\n\"need to know.\" The former, security clearance might have levels like \"confidential\",\n\"secret\", \"top secret\". But maybe we can throw in \"president\" and some others too, like\n\"plebe\".\nExercise 3.4.5.5. Does it appear that security clearance is a preorder, a partial order, or\na linear order?\n♦\nNeed-to-know is another classification of people. For each bit of information, we do\nnot necessarily want everyone to know about it, even everyone of the specified clearance.\nIt is only disseminated to those that need to know.\nExercise 3.4.5.6. Let P be the set of all people and let I be the set of all pieces of\ninformation known by the government. For each subset I D I, let KpIq D P be the set\nof people that need to know every piece of information in I. Let S \" tKpIq | I D Iu be\nthe set of all \"need-to-know groups\", with the subset relation denoted d.\na.) Is pS, dq a preorder? If not, find a nearby preorder.\nb.) If I1 D I2 do we always have KpI1q D KpI2q or KpI2q D KpI1q or possibly neither?\nc.) Should the preorder pS, dq have all meets?\nd.) Should pS, dq have all joins?\n♦\n3.4.5.7\nSpaces, e.g. geography\nConsider closed curves that can be drawn in the plane R2, e.g. circles, ellipses, and\nkidney-bean shaped curves. The interiors of these closed curves (not including the bound-\nary itself) are called basic open sets in R2. The good thing about such an interior U is\nthat any point p P U is not on the boundary, so no matter how close p is to the boundary\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nof U, there will always be a tiny basic open set surrounding p and completely contained\nin U. In fact, the union of any collection of basic open sets still has this property. An\nopen set in R2 is any subset U D R2 that can be formed as the union of a collection of\nbasic open sets.\nExample 3.4.5.8. Let U \" tpx, yq P R2 | x a 0u.\nTo see that U is open, define the\nfollowing sets: for any a, b P R, let Spa, bq be the square parallel to the axes, with side\nlength 1, where the upper left corner is pa, bq. Let S1pa, bq be the interior of Spa, bq. Then\neach S1pa, bq is open, and U is the union of S1pa, bq over the collection of all a a 0 and\nall b,\nU \"\nd\na, b P R,\na a 0\nS1pa, bq.\nThe idea of open sets extends to spaces beyond R2. For example, on the earth one\ncould define a basic open set to be the interior of any region one can \"draw a circle\naround\" (with a metaphorical pen), and define open sets to be unions of basic open sets.\nExercise 3.4.5.9. Let S be the set of open subsets on earth, as defined in the above\nparagraph.\na.) If d is the subset relation, is pS, dq a preorder or a partial order?\nb.) Does it have meets, does it have joins?\n♦\nExercise 3.4.5.10. Let S be the set of open subsets of earth as defined above. To each\nopen subset of earth suppose we know the range of recorded temperature throughout s\n(i.e. the low and high throughout the region). Thus to each element s P S we assign an\ninterval Tpsq :\" tx P R | a d x d bu. If we order the set V of intervals of R by the subset\nrelation, it gives a partial order on V .\na.) Does our assignment T : S N V amount to a morphism of orders?\nb.) Does it preserve meets or joins? (Hint: it doesn't preserve both.)\n♦\nExercise 3.4.5.11.\na.) Can you think of a space relevant to your favorite area of science for which it makes\nsense to assign an interval of real numbers to each open set somehow, analogously to\nExercise 3.4.5.10? For example for a sample of some material under stress, perhaps\nthe strain on each open set is somehow an interval?\nb.) Repeat the questions from Exercise 3.4.5.10.\n♦\n3.5\nDatabases: schemas and instances\nThe first three sections of this chapter were about classical objects from mathematics.\nThe present section is about databases, which are classical objects from computer science.\nThese are truly \"categories and functors, without admitting it\" (see Theorem 4.4.2.3).\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\n3.5.1\nWhat are databases?\nData, in particular the set of observations made during experiment, plays 9 a primary\nrole in science of any kind. To be useful data must be organized, often in a row-and-\ncolumn display called a table. Columns existing in different tables can refer to the same\ndata.\nA database is a collection of tables, each table T of which consists of a set of columns\nand a set of rows. We roughly explain the role of tables, columns, and rows as follows.\nThe existence of table T suggests the existence of a fixed methodology for observing\nobjects or events of a certain type.\nEach column c in T prescribes a single kind or\nmethod of observation, so that the datum inhabiting any cell in column c refers to an\nobservation of that kind. Each row r in T has a fixed sourcing event or object, which\ncan be observed using the methods prescribed by the columns. The cell pr, cq refers to\nthe observation of kind c made on event r. All of the rows in T should refer to uniquely\nidentifiable objects or events of a single type, and the name of the table T should refer\nto that type.\nExample 3.5.1.1. When graphene is strained (lengthened by a factor of x e 1), it becomes\nstressed (carries a force in the direction of the lengthening). The following is a made-up\nset of data.\nGraphene sample\nID\nSource\nStress\nStrain\nA118-1\nC Smkt\nA118-2\nC Smkt\n0.02\nA118-3\nC Smkt\n0.05\nA118-4\nAC\n0.04\nA118-5\nAC\n0.1\nA118-6\nC Plat\n0.1\nSupplier\nID\nFull name\nPhone\nC Smkt\nCarbon Supermarket\n(541)781-6611\nAC\nAdvanced Chemical\n(410) 693-0818\nC Plat\nCarbon Platform\n(510) 719-2857\nMcD\nMcDonard's Burgers\n(617) 244-4400\nAPP\nAcme Pen and Paper\n(617) 823-5603\n(3.12)\nIn the first table, titled \"Graphene sample\", the rows refer to graphene samples, and\nthe table is so named. Each graphene sample can be observed according to the source\nsupplier from which it came, the strain that it was subjected to, and the stress that\nit carried. These observations are the columns. In the second table, the rows refer to\nsuppliers of various things, and the table is so named. Each supplier can be observed\naccording to its full name and its phone number; these are the columns.\nIn the left-hand table it appears either that each graphene sample was used only\nonce, or that the person recording the data did not keep track of which samples were\nreused. If such details become important later, the lab may want to change the layout\nof the first table by adding on the appropriate column. This can be accomplished using\nmorphisms of schemas, which will be discussed in Section 4.4.1.\n9The word data is generally considered to be the plural form of the word datum. However, individual\ndatum elements are only useful when they are organized into structures (e.g. if one were to shuffle the\ncells in a spreadsheet, most would consider the data to be destroyed). It is the whole organized structure\nthat really houses the information; the data must be in formation in order to be useful. Thus I will use\nthe word data as a collective noun (akin to the word \"sand\"); it bridges the divide between the individual\ndatum elements (akin to the grains of sand) and the data set (akin to a sand pile). In particular, I will\noften use the word data as a singular noun.\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n3.5.1.2\nPrimary keys, foreign keys, and data columns\nThere is a bit more structure in the above tables (Example 3.12) then may first meet\nthe eye. Each table has a primary ID column, found on the left, as well as some data\ncolumns and some foreign key columns. The primary key column is tasked with uniquely\nidentifying different rows. Each data column houses elementary data of a certain sort.\nPerhaps most interesting from a structural point of view are the foreign key columns,\nbecause they link one table to another, creating a connection pattern between tables.\nEach foreign key column houses data that needs to be further unpacked. It thus refers us\nto another foreign table, in particular the primary ID column of that table. In Example\n3.12 the Source column was a foreign key to the Supplier table.\nHere is another example, lifted from [Sp2].\nExample 3.5.1.3. Consider the bookkeeping necessary to run a department store. We\nkeep track of a set of employees and a set of departments. For each employee e, we keep\ntrack of\nE.1 the first name of e, which is a FirstNameString,\nE.2 the last name of e, which is a LastNameString,\nE.3 the manager of e, which is an Employee, and\nE.4 the department that e works in, which is a Department.\nFor each department d, we keep track of\nD.1 the name of d, which is a DepartmentNameString, and\nD.2 the secretary of d, which is an Employee.\nAbove we can suppose that E.1, E.2, and D.1 are data columns (referring to names\nof various sorts), and E.3, E.4, and D.2 are foreign key columns (referring to managers,\nsecretaries, etc.).\nDisplay (3.13) shows how such a database might look at a particular moment in time.\nEmployee\nID\nfirst\nlast\nmanager\nworksIn\nDavid\nHilbert\nq10\nBertrand\nRussell\nx02\nEmmy\nNoether\nq10\nDepartment\nID\nname\nsecretary\nq10\nSales\nx02\nProduction\n(3.13)\n3.5.1.4\nBusiness rules\nLooking at the tables from Example 3.5.1.3, one may notice a few patterns. First, every\nemployee works in the same department as his or manager. Second, every department's\nsecretary works in that department. Perhaps the business counts on these rules for the\nway it structures itself. In that case the database should enforce those rules, i.e. it\nshould check that whenever the data is updated, it conforms to the rules:\nRule 1 For every employee e, the manager of e works in the same department\nthat e works in.\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\nRule 2 For every department d, the secretary of d works in department d.\n(3.14)\nTogether, the statements E.1, E.2, E.3, E.4, D.1, and D.2 from Example 3.5.1.3 and\nRule 1 and Rule 2, constitute what we will call the schema of the database. We will\nformalize this idea in Section 3.5.2.\n3.5.1.5\nData columns as foreign keys\nTo make everything consistent, we could even say that data columns are specific kinds of\nforeign keys. That is, each data column constitutes a foreign key to some non-branching\nleaf table, which has no additional data.\nExample 3.5.1.6. Consider again Example 3.5.1.3. Note that first names and last names\nhad a particular type, which we all but ignored above. We could cease to ignore them\nby adding three tables, as follows.\nFirstNameString\nID\nAlan\nAlice\nBertrand\nCarl\nDavid\nEmmy\n...\nLastNameString\nID\nArden\nHilbert\nJones\nNoether\nRussell\n...\nDepartmentNameString\nID\nMarketing\nProduction\nSales\n...\n(3.15)\nIn combination, Displays (3.13) and (3.15) form a collection of tables with the prop-\nerty that every column is either a primary key or a foreign key. The notion of data\ncolumn is now subsumed under the notion of foreign key column. Everything is either a\nprimary key (one per table, labeled ID) or a foreign key column (everything else).\n3.5.2\nSchemas\nThe above section may all seem intuitive or reasonable in some ways, but also a bit\ndifficult to fully grasp, perhaps. It would be nice to summarize what is happening in a\npicture. Such a picture, which will basically be a graph, should capture the conceptual\nlayout to which the data conforms, without yet being concerned with the individual data\nthat may populate the tables in this instant. We proceed at first by example, giving the\nprecise definition in Definition 3.5.2.6.\nExample 3.5.2.1. In Examples 3.5.1.3 and 3.5.1.6, the conceptual layout for a department\nstore was given, and some example tables were shown. We were instructed to keep track\nof employees, departments, and six types of data (E.1, E.2, E.3, E.4, D.1, and D.2), and\nwe were instructed to follow two rules (Rule 1, Rule 2). All of this is summarized in the\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nfollowing picture:\nC:\" Schema for tables (3.13) and (3.15) conforming to (3.14)\nEmployee manager worksIn » Employee worksIn\nDepartment secretary worksIn » Department\nEmployee\n‚\nworksIn\n/\nmanager\n\nfirst\n~\nlast\n\nDepartment\n‚\nsecretary\no\nname\n\nFirstNameString\n‚\nLastNameString\n‚\nDepartmentNameString\n‚\n(3.16)\nThe five tables from (3.13) and (3.15) are seen as five vertices; this is also the number of\nprimary ID columns. The six foreign key columns from (3.13) and (3.15) are seen as six\narrows; each points from a table to a foreign table. The two rules from (3.14) are seen as\nstatements at the top of Display (3.16).We will explain path equivalences in Definition\n3.5.2.3.\nExercise 3.5.2.2. Come up with a schema (consisting of dots and arrows) describing the\nconceptual layout of information presented in Example 3.5.1.1.\n♦\nIn order to define schemas, we must first define the notion of schematic equivalence\nrelation, which is to hold on the set of paths of a graph G (see Section 3.3.2). Such\nan equivalence relation (in addition to being reflexive, symmetric, and transitive) has\ntwo sorts of additional properties: equivalent paths must have the same source and\ntarget, and the composition of equivalent paths with other equivalent paths must yield\nequivalent paths. Formally we have Definition 3.5.2.3.\nDefinition 3.5.2.3.\nLet G \" pV, A, src, tgtq be a graph, and let PathG denote the set of paths in G\n(see Definition 3.3.2.1). A path equivalence declaration (or PED) is an expression of the\nform p » q where p, q P PathG have the same source and target, srcppq \" srcpqq and\ntgtppq \" tgtpqq.\nA congruence on G is a relation » on PathG that has the following properties:\n1. The relation » is an equivalence relation.\n2. If p » q then srcppq \" srcpqq.\n3. If p » q then tgtppq \" tgtpqq.\n4. Suppose p, q: b N c are paths, and m: a N b is an arrow. If p » q then mp » mq.\n5. Suppose p, q: a N b are paths, and n: b N c is an arrow. If p » q then pn » qn.\nAny set of path equivalence declarations (PEDs) generates a congruence. We tend\nto elide the difference between a congruence and the set of PEDs that generates it.\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\nExercise 3.5.2.4. Consider the graph shown in (3.16), and the two declarations shown at\nthe top. They generate a congruence.\na.) Is it true that the following PED is an element of this congruence?\nEmployee manager manager worksIn\n?» Employee worksIn\nb.) What about this one?\nEmployee worksIn secretary\n?» Employee\nc.) What about this one?\nDepartment secretary manager worksIn name\n?» Department name\n♦\nLemma 3.5.2.5. Suppose that G is a graph and » is a congruence on G. Suppose\np » q: a N b and r » s: b N c. Then pr » qs.\nProof. The picture to have in mind is this:\n‚\n/\n/ ‚\n\n‚\n/\n/ ‚\n\na‚\n»\nA\n\np\n%\nq\nb‚\n»\nA\n\nr\n%\ns\nc‚\n‚\n/\n/ ‚\nA\n‚\n/\n/ ‚\nA\nApplying condition (3) from Definition 3.5.2.3 to each arrow in path p, it follows by\ninduction that pr » ps.\nApplying condition (4) to each arrow in path s, it follows\nsimilarly that ps » qs. Because » is an equivalence relation, it follows that pr » qs.\n□\nDefinition 3.5.2.6. A database schema (or simply schema) C consists of a pair C :\"\npG, »q where G is a graph and » is a congruence on G.\nExample 3.5.2.7. The picture drawn in (3.16) has the makings of a schema. Pictured is\na graph with two PEDs; these generate a congruence, as discussed in Exercise 3.5.2.4.\nA schema can be converted into a system of tables each with a primary key and some\nnumber of foreign keys referring to other tables, as discussed in Section 3.5.1. Definition\n3.5.2.6 gives a precise conceptual understanding of what a schema is, and the following\nrules describe how to convert such a thing into a table layout.\nRules of good practice 3.5.2.8. Converting a schema C \" pG, »q into a table layout should\nbe done as follows:\n(i) There should be a table for every vertex in G and if the vertex is named, the table\nshould have that name;\n(ii) Each table should have a left-most column called ID, set apart from the other\ncolumns by a double vertical line; and\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\n(iii) To each arrow a in G having source vertex s :\" srcpaq and target vertex t :\" tgtpaq,\nthere should be a foreign key column a in table s, referring to table t; if the arrow\na is named, column a should have that name.\nExample 3.5.2.9 (Discrete dynamical system). Consider the schema\nLoop :\"\ns‚\nf\n\n(3.17)\nin which the congruence is trivial (i.e.\ngenerated by the empty set of PEDs.)\nThis\nschema is quite interesting. It encodes a set s and a function f : s N s. Such a thing\nis called a discrete dynamical system. One imagines s as the set of states and, for any\nstate x P s, a notion of \"next state\" fpxq P s. For example\ns\nID\nf\nA\nB\nB\nC\nC\nC\nD\nB\nE\nC\nF\nG\nG\nH\nH\nG\n...pictured...\nA‚\n/ B‚\n/ C‚ q\nD‚\n;\nE‚\n;\nF‚\n/ G‚\n( H‚\nh\n(3.18)\nApplication 3.5.2.10. Imagine a quantum-time universe in which there are discrete time\nsteps. We model it as a discrete dynamical system, i.e. a table of the form (3.18). For\nevery possible state of the universe we include a row in the table. The state in the next\ninstant is recorded in the second column.\n♦♦\nExample 3.5.2.11 (Finite hierarchy). The schema Loop can also be used to encode hier-\narchies, such as the manager relation from Examples 3.5.1.3 and 3.5.2.1,\nE‚\nmgr\n\nOne problem with this, however, is if a schema has even one loop, then it can have in-\nfinitely many paths (corresponding, e.g. to an employees manager's manager's manager's\n... manager).\nSometimes we know that in a given company that process eventually ends, a famous\nexample being that at Ben and Jerry's ice cream, there were only seven levels. In that\ncase we know that an employee's 8th level manager is equal to his or her 7th level\nmanager. This can be encoded by the PED\nE mgr mgr mgr mgr mgr mgr mgr mgr » E mgr mgr mgr mgr mgr mgr mgr\nor more concisely, mgr8 \" mgr7.\nExercise 3.5.2.12. Is there any nontrivial PED on Loop that holds for the data in Example\n3.5.2.9? If so, what is it and how many equivalence classes of paths in Loop are there\nafter you impose that relation?\n♦\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\nExercise 3.5.2.13. Let P be a chess-playing program. Given any position (including the\nhistory of the game and choice of whose turn it is), P will make a move.\na.) Is this an example of a discrete dynamical system?\nb.) How do the rules for ending the game in a win or draw play out in this model? (Look\nup online how chess games end if you don't know.)\n♦\n3.5.2.14\nOlogging schemas\nIt should be clear that a database schema is nothing but an olog in disguise.\nThe\ndifference is basically the readability requirements for ologs. There is an important new\naddition in this section, namely that we can fill out an olog with data. Conversely, we\nhave seen that databases are not any harder to understand than ologs are.\nExample 3.5.2.15. Consider the olog\na moon\norbits\nYYYYYYN a planet\n(3.19)\nWe can document some instances of this relationship using the following tables:\norbits\na moon\na planet\nThe Moon\nEarth\nPhobos\nMars\nDeimos\nMars\nGanymede\nJupiter\nTitan\nSaturn\n(3.20)\nClearly, this table of instances can be updated as more moons are discovered by the\nauthor (be it by telescope, conversation, or research).\nExercise 3.5.2.16. In fact, Example 3.5.2.15 did not follow Rules 3.5.2.8. Strictly follow-\ning those rules, copy over the data from (3.20) into tables that are in accordance with\nschema (3.19).\n♦\nExercise 3.5.2.17.\na.) Write down a schema, in terms of the boxes ⌜a thing I own⌝and ⌜a place⌝and one\nadditional arrow, that might help one remember where they decided to put \"random\"\nthings.\nb.) What is a good label for the arrow?\nc.) Fill in some rows of the corresponding set of tables for your own case.\n♦\nExercise 3.5.2.18. Consider the olog\nC\na child\nhas\n/\nF\na father\nhas as first\nk\nhas as tallest\nt\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\na.) What path equivalence declarations would be appropriate for this olog? You can use\nf : F N C, t: F N C, and h: C N F if you prefer.\nb.) How many PEDs are in the congruence?\n♦\n3.5.3\nInstances\nGiven a database schema pG, »q, an instance of it is just a bunch of tables whose data\nconform to the specified layout. These can be seen throughout the previous section, most\nexplicitly in the relationship between schema (3.16) and tables (3.13) and (3.15), and\nbetween schema (3.17) and table (3.18). Below is the mathematical definition.\nDefinition 3.5.3.1. Let C \" pG, »q where G \" pV, A, src, tgtq.\nAn instance on C,\ndenoted pPK, FKq: C N Set, is defined as follows: One announces some constituents\n(A. primary ID part, B. foreign key part) and asserts that they conform to a law (1.\npreservation of congruence). Specifically, one announces\nA. a function PK: V N Set; i.e. to each vertex v P V one provides a set PKpvq;10\nand\nB. for every arrow a P A with v \" srcpaq and w \" tgtpaq, a function FKpaq: PKpvq N\nPKpwq. 11\nOne asserts that the following law holds for any vertices v, w and paths p \" va1a2 . . . am\nand q \" va1\n1a1\n2 . . . a1\nn from v to w:\n1. If p » q then for all x P PKpvq, we have\nFKpamq FKpa2q FKpa1qpxq \" FKpa1\nnq FKpa1\n2q FKpa1\n1qpxq\nin PKpwq.\nExercise 3.5.3.2. Consider the olog pictured below:\nC :\"\na self-email\nis\n/ an email\nis sent by,\nis sent to\na person\nGiven x, a self-email, consider the following.\nWe know that x is a self-email, which is an email,\nwhich is sent by a person that we'll call Ppxq.\nWe also know that x is a self-email, which is an\nemail, which is sent to a person that we'll call Qpxq.\nFact: whenever x is a self-email, we will have Ppxq \"\nQpxq\n10The elements of PKpvq will be listed as the rows of table v, or more precisely as the leftmost cells\nof these rows.\n11The arrow a will correspond to a column, and to each row r P PKpvq the pr, aq cell will contain the\ndatum FKpaqprq.\n\n3.5. DATABASES: SCHEMAS AND INSTANCES\na self-email\nID\nis\nSEm1207\nEm1207\nSEm1210\nEm1210\nSEm1211\nEm1211\nan email\nID\nis sent by\nis sent to\nEm1206\nBob\nSue\nEm1207\nCarl\nCarl\nEm1208\nSue\nMartha\nEm1209\nChris\nBob\nEm1210\nChris\nChris\nEm1211\nJulia\nJulia\nEm1212\nMartha\nChris\na person\nID\nBob\nCarl\nChris\nJulia\nMartha\nSue\n(3.21)\na.) What is the set PKp⌜an email⌝q?\nb.) What is the set PKp⌜a person⌝q?\nc.) What is the function FKpis sent byq: PKp⌜an email⌝q N PKp⌜a person⌝q?\nd.) Interpret the sentences at the bottom of C as the Englishification of a simple path\nequivalence declaration. Is it satisfied by the instance (3.21); that is, does law 1.\nfrom Definition 3.5.3.1 hold?\n♦\nExample 3.5.3.3 (Monoid action table). In Example 3.1.2.9, we saw how a monoid M\ncould be captured as an olog with only one object. As a database schema, this means\nthere is only one table. Every generator of M would be a column of the table. The\nnotion of database instance for such a schema is precisely the notion of action table from\nSection 3.1.3. Note that a monoid can act on itself, in which case this action table is the\nmonoid's multiplication table as in Example 3.1.3.2, but it can also act on any other set\nas in Example 3.1.3.1. If M acts on a set S, then the set of rows in the action table will\nbe S.\nExercise 3.5.3.4. Draw (as a graph) the schema for which Table 3.2 is an instance.\n♦\nExercise 3.5.3.5. Suppose that M is a monoid and some instance of it is written out in\ntable form. It's possible that M is a group. What evidence in an instance table for M\nmight suggest that M is a group?\n♦\n3.5.3.6\nPaths through a database\nLet C :\" pG, »q be a schema and let pPK, FKq: C N Set be an instance on C. Then\nfor every arrow a: v N w in G we get a function FKpaq: PKpvq N PKpwq. Functions\ncan be composed, so in fact for every path through G we get a function. Namely, if\np \" v0a1, a2, . . . , an is a path from v0 to vn then the instance provides a function\nFKppq :\" FKpanq FKpa2q FKpa1q: PKpv0q N PKpvnq,\nwhich first made an appearance as part of Law 1 in Definition 3.5.3.1.\nExample 3.5.3.7. Consider the department store schema from Example 3.5.2.1, and in\n(3.16) the path rworksIn, secretary, lasts which points from Employee to LastNameString.\nThe instance will let us interpret this path as a function from the set of employees to\nthe set of last names; this could be a useful function to have around. The instance from\n(3.13) would yield the following function\n\nCHAPTER 3. CATEGORIES AND FUNCTORS, WITHOUT ADMITTING IT\nEmployee\nID\nSecr. name\nHilbert\nRussell\nHilbert\nExercise 3.5.3.8. Consider the path p :\" rf, fs on the Loop schema from (3.17). Using the\ninstance from (3.18), where PKpsq \" tA, B, C, D, E, F, G, Hu, interpret p as a function\nPKpsq N PKpsq, and write this as a 2-column table, as above in Example 3.5.3.7.\n♦\nExercise 3.5.3.9.\na.) Given an instance pPK, FKq on a schema C, and given a trivial path p (i.e. p has\nlength 0; it starts at some vertex but doesn't go anywhere), what function does p\nyield?\nb.) What are the domain and codomain of p?\n♦\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996Category Theory for Scientist\nSpring 2013\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Textbook: Categories at Work",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/92cc1ab1c1b99e3208ce2fe7f69220c2_MIT18_S996S13_chapter5.pdf",
      "content": "Chapter 5\nCategories at work\nWe have now set up an understanding of the basic notions of category theory: categories,\nfunctors, natural transformations, and universal properties. We have discussed many\nsources of examples: orders, graphs, monoids, and databases. We begin this chapter with\nthe notion of adjoint functors (also known as adjunctions), which are like dictionaries\nthat translate back and forth between different categories.\n5.1\nAdjoint functors\nJust above, in the introduction to this chapter, I said that adjoint functors are like\ndictionaries that translate back and forth between different categories. How far can we\ntake that analogy?\nIn the common understanding of dictionaries, we assume that the two languages (say\nFrench and English) are equally expressive, and that a good dictionary will be an even\nexchange of ideas. But in category theory we often have two categories that are not\non the same conceptual level. This is most clear in the case of so-called free-forgetful\nadjunctions. In Section 5.1.1 we will explore the sense in which each adjunction provides\na dictionary between two categories that are not necessarily on an equal footing, so to\nspeak.\n5.1.1\nDiscussion and definition\nConsider the category of monoids and the category of sets. A monoid pM, e, ‹q is a set\nwith an identity element and a multiplication formula that is associative. A set is just\na set. A dictionary between Mon and Set should not be required to set up an even\nexchange, but instead an exchange that is appropriate to the structures at hand. It will\nbe in the form of two functors, one we'll denote by L: Set N Mon, and one we'll denote\nby R: Mon N Set. But to say what \"appropriate\" means requires more work.\nLet's bring it down to earth with an analogy. A one-year-old can make repeatable\nnoises and an adult can make repeatable noises. One might say \"after all, talking is noth-\ning but making repeatable noises.\" But the adult's repeatable noises are called words,\nthey form sentences, and these sentences can cause nuclear wars. There is something\nmore in adult language than there is simply in repeatable sounds. In the same vein, a\ntennis match can be viewed as physics, but you won't see the match. So we have some-\nthing analogous to two categories here: ((repeated noises)) and ((meaningful words)).\n\nCHAPTER 5. CATEGORIES AT WORK\nWe are looking for adjoint functors going back and forth, serving as the appropriate sort\nof dictionary.\nTo translate baby talk into adult language we would make every repeated noise a\nkind of word, thereby granting it meaning. We don't know what a given repeated noise\nshould mean, but we give it a slot in our conceptual space, always pondering \"I wonder\nwhat she means by Konnen..\" On the other hand, to translate from meaningful words to\nrepeatable noises is easy. We just hear the word as a repeated noise, which is how the\nbaby probably hears it.\nAdjoint functors often come in the form of \"free\" and \"forgetful\". Here we freely\nadd Konnen to our conceptual space without having any idea how it adheres to the\nrest of the child's noises or feelings. But it doesn't act like a sound to us, it acts like\na word; we don't know what it means but we figure it means something. Conversely,\nthe translation going the other way is \"forgetful\", forgetting the meaning of our words\nand just hearing them as sounds. The baby hears our words and accepts them as mere\nsounds, not knowing that there is anything extra to get.\nBack to sets and monoids, the sets are like the babies from our story: they are\nsimple objects full of unconnected dots. The monoids are like adults, forming words and\nperforming actions. In the monoid, each element means something and combines with\nother elements in some way. There are lots of different sets and lots of different monoids,\njust as there are many babies and many adults, but there are patterns to the behavior\nof each kind and we put them in different categories.\nApplying free functor L: Set N Mon to a set X makes every element x P X a word,\nand these words can be strung together to form more complex words. (We discussed\nthe free functor in Section 3.1.1.12.) Since a set such as X carries no information about\nthe meaning or structure of its various elements, the free monoid FpXq does not relate\ndifferent words in any way. To apply the forgetful functor R: Mon N Set to a monoid,\neven a structured one, is to simply forget that its elements are anything but mere elements\nof a set. It sends a monoid pM, 1, ‹q to the set M.\nThe analogy is complete. However, this is all just ideas. Let's give a definition, then\nreturn to our sets, monoids, sounds, and words.\nDefinition 5.1.1.1. Let B and A be categories. 1 An adjunction between B and A is a\npair of functors\nL: B N A\nand\nR: A N B\ntogether with a natural isomorphism 2 whose component for any objects A P ObpAq and\nB P ObpBq is:\nαB,A : HomApLpBq, Aq\n-\nYYYN HomBpB, RpAqq.\n(5.1)\nThis isomorphism is called the adjunction isomorphism for the pL, Rq adjunction, and\nfor any morphism f : LpBq N A in A, we refer to αB,Apfq: B N RpAq as the adjunct of\nf. 3\n1Throughout this definition, notice that B's come before A's, especially in (5.1), which might be\nconfusing. It was a stylistic choice to match with the Babies and Adults discussion above and below\nthis definition.\n2The natural isomorphism α (see Lemma 4.3.2.12) is between two functors Bop ˆ A N Set, namely\nthe functor pB, Aq ÞN HomApLpBq, Aq and the functor pB, Aq ÞN HomBpB, RpAqq.\n3Conversely, for any g : B N RpAq in B we refer to α 1\nB,Apgq: LpBq N A as the adjunct of g.\n\n5.1. ADJOINT FUNCTORS\nThe functor L is called the left adjoint and the functor R is called the right adjoint.\nWe may say that L is the left adjoint of R or that R is the right adjoint of L.\n4 We\noften denote this setup by\nL: B\n/ A :R\no\nProposition 5.1.1.2. Let L: Set N Mon be the functor sending X P ObpSetq to the\nfree monoid LpXq :\" pListpXq, r s, ``q, as in Definition 3.1.1.15. Let R: Mon N Set\nbe the functor sending each monoid M :\" pM, 1, ‹q to its underlying set RpMq :\" M.\nThen L is left adjoint to R.\nProof. If we can find a natural isomorphism of sets\nαX,M : HomMonpLpXq, Mq N HomSetpX, RpMqq\nwe will have succeeded in showing that these functors are adjoint.\nSuppose given an element f P HomMonpLpXq, Mq, i.e. a monoid homomorphism\nf : ListpXq N M (sending r s to 1 and list concatenation to ‹). Then in particular we\ncan apply f to the singleton list rxs for any x P X. This gives a function X N M by\nx ÞN fprxsq, and this is αX,Mpfq: X N M \" RpMq. We need only to supply an inverse\nβX,M : HomSetpX, RpMqq N HomMonpLpXq, Mq.\nSuppose given an element g P HomSetpX, RpMqq, i.e. a function g: X N M. Then to\nany list l\" rx1, x2, . . . , xns P ListpXq we can assign βX,Mplq :\" gpx1q‹gpx2q‹ ‹gpxnq\n(if l\" r s is the empty list, assign βX,Mpr sq :\" 1). We now have a function ListpXq N M.\nIt is a monoid homomorphism because it respects identity and composition. It is easy\nto check that β and α are mutually inverse, completing the proof.\n□\nExample 5.1.1.3. We need to ground our discussion in some concrete mathematics. In\nProposition 5.1.1.2 we provided our long-awaited adjunction between sets and monoids.\nA set X gets transformed into a monoid by considering lists in X; a monoid M gets\ntransformed into a set by forgetting the multiplication law. So we have a functor going\none way and the other,\nL: Set N Mon,\nR: Mon N Set,\nbut an adjunction is more than that: it includes a guarantee about the relationship\nbetween these two functors. What is the relationship between L and R? Consider an\narbitrary monoid M \" pM, 1, q.\nIf I want to pick out 3 elements of the set M, that's the same thing as giving a\nfunction ta, b, cu N M. But that function exists in the category of sets; in fact it is\nan element of HomSetpta, b, cu, Mq. But since M \" RpMq is the underlying set of our\nmonoid, we can view the current paragraph in the light of our adjunction Equation (5.1)\nby saying it has been about the set\nHomSetpta, b, cu, RpMqq.\nThis set classifies all the ways to pick three elements out of the underlying set of our\nmonoid M. It was constructed completely from within the category Set.\n4The left adjoint does not have to be called L, nor does the right adjoint have to be called R, of\ncourse. This is suggestive.\n\nCHAPTER 5. CATEGORIES AT WORK\nNow we ask what Equation (5.1) means. The equation\nHomMonpLpta, b, cuq, Mq - HomSetpta, b, cu, RpMqq.\ntells us that somehow we can answer the same question completely from within the cat-\negory of monoids. In fact it tells us how to do so, namely as HomMonpListpt1, 2, 3u, Mq.\nExercise 5.1.1.4 looks at how that should go. The answer is \"hidden\" in the proof of\nProposition 5.1.1.2.\nExercise 5.1.1.4. Let X \" ta, b, cu and let M \" pN, 1, q be the multiplicative monoid\nof natural numbers (see Example 3.1.3.2).\nLet f : X N N be the function given by\nfpaq \" 7, fpbq \" 2, fpcq \" 2, and let βX,M : HomSetpX, RpMqq N HomMonpLpXq, Mq\nbe as in the proof of Proposition 5.1.1.2. What is βX,Mpfqprb, b, a, csq?\n♦\nLet us look once more at the adjunction between adults and babies.\nUsing the\nnotation of Definition 5.1.1.1 A is the \"adult category\" of meaningful words and B is the\n\"baby category\" of repeated noises. The left adjoint turns every repeated sound into a\nmeaningful word (having \"free\" meaning) and the right adjoint \"forgets\" the meaning of\nany word and considers it merely as a sound.\nAt the risk of taking this simple analogy too far, let's have a go at the heart of the\nissue: how to conceive of the isomorphism (5.1) of Hom's. Once we have freely given a\nslot to each of baby's repeated sounds, we try to find a mapping from the lexicon LpBq\nof these new words to our own lexicon A of meaningful words; these are mappings in\nthe adult category A of the form LpBq N A. And (stretching it) the baby tries to find\na mapping (which we might see as emulation) from her set B of repeatable sounds to\nthe set RpAq of the sounds the adult seems to repeat. If there was a global system for\nmaking these transformations that would establish (5.1) and hence the adjunction.\nNote that the directionality of the adjunction makes a difference. If L: B N A is left\nadjoint to R: A N B we rarely have an isomorphism HomApA, LpBqq - HomBpRpAq, Bq.\nIn the case of babies and adults, we see that it would make little sense to look for a\nmapping in the category of meaningful words from the adult lexicon to the wordifications\nof baby-sounds, because there is unlikely to be a good candidate for most of our words.\nThat is, to which of our child's repeated noises would we assign the concept \"weekday\"?\nAgain, the above is simply an analogy, and almost certainly not formalizable. The\nnext example shows mathematically the point we tried to make in the previous para-\ngraph, that the directionality of an adjunction is not arbitrary.\nExample 5.1.1.5. Let L: Set N Mon and R: Mon N Set be the free and forgetful\nfunctors from Proposition 5.1.1.2. We know that L is left adjoint to R; however L is not\nright adjoint to R. In other words, we can show that the necessary natural isomorphism\ncannot exist.\nLet X \" ta, bu and let M \" pt1u, 1, !q be the trivial monoid. Then the necessary\nnatural isomorphism would need to give us a bijection\nHomMonpM, LpXqq -? HomSetpt1u, Xq.\nBut the left-hand side has one element, because M is the initial object in Mon (see Ex-\nample 4.5.3.8), whereas the right-hand side has two elements. Therefore no isomorphism\ncan exist.\nExample 5.1.1.6. Preorders have underlying sets, giving rise to a functor U : PrO N Set.\nThe functor U has both a left adjoint and a right adjoint.\nThe left adjoint of U is\nD: Set N PrO, sending a set X to the discrete preorder on X (the preorder with\n\n5.1. ADJOINT FUNCTORS\nunderlying set X, having the fewest possible d's). The right adjoint of U is I : Set N\nPrO, sending a set X to the indiscrete preorder on X (the preorder with underlying set\nX, having the most possible d's). See Example 3.4.4.5.\nExercise 5.1.1.7. Let U : Grph N Set denote the functor sending a graph to its under-\nlying set of vertices. This functor has both a left and a right adjoint.\na.) What functor Set N Grph is the left adjoint of U?\nb.) What functor Set N Grph is the right adjoint of U?\n♦\nExample 5.1.1.8. Here are some other adjunctions:\n- Ob: Cat N Set has a left adjoint Set N Cat given by the discrete category.\n- Ob: Cat N Set has a right adjoint Set N Cat given by the indiscrete category.\n- The underlying graph functor Cat N Grph has a left adjoint Grph N Cat given\nby the free category.\n- The functor PrO N Grph, given by drawing edges for d's, has a left adjoint given\nby existence of paths.\n- The forgetful functor from posets to preorders has a left adjoint given by quotient\nby isomorphism relation.\n- Given a set A, the functor p ˆ Aq: Set N Set has a right adjoint HompA, q\n(this was called currying in Section 2.7.2).\nExercise 5.1.1.9. Let F : C N D and G: D N C be mutually inverse equivalences of\ncategories (see Definition 4.3.4.1). Are they adjoint in one direction or the other?\n♦\nExercise 5.1.1.10. The discrete category functor Disc: Set N Cat has a left adjoint\np: Cat N Set.\na.) For an arbitrary object X P ObpSetq and an arbitrary object C P ObpCatq, write\ndown the adjunction isomorphism.\nb.) Let C be the free category on the graph G:\nG :\"\nv‚\nf\n/ w‚\nh\n?\ng\nx‚\ny‚\ni\n\nj\nz‚\nk\n_\nand let X \" t1, 2, 3u. How many elements does the set HomSetpC, DiscpXqq have?\nc.) What can you do to an arbitrary category C to make a set ppCq such that the\nadjunction isomorphism holds? That is, how does the functor p behave on objects?\n♦\n\nCHAPTER 5. CATEGORIES AT WORK\nThe following proposition says that all adjoints to a given functor are isomorphic to\neach other.\nProposition 5.1.1.11. Let C and D be categories, let F : C N D be a functor, and\nlet G, G1 : D N C also be functors. If both G and G1 are right adjoint (respectively left\nadjoint) to F then there is a natural isomorphism φ: G N G1.\nProof. Suppose that both G and G1 are right adjoint to F (the case of G and G1 being\nleft adjoint is similarly proved). We first give a formula for the components of φ: G N G1\nand its inverse ψ: G1 N G. Given an object d P ObpDq, we use c \" Gpdq to obtain two\nnatural isomorphisms, one from each adjunction:\nHomCpGpdq, Gpdqq - HomDpFpGpdqq, dq - HomCpGpdq, G1pdqq.\nThe identity component idGpdq is then sent to some morphism Gpdq N G1pdq, which we\ntake to be φd. Similarly, we use c1 \" G1pdq to obtain two natural isomorphisms, one from\neach adjunction:\nHomCpG1pdq, G1pdqq - HomDpFpG1pdqq, dq - HomCpG1pdq, Gpdqq.\nAgain, the identity component idG1pdq is sent to some morphism G1pdq N Gpdq, which\nwe take to be ψd. The naturality of the isomorphisms implies that φ and ψ are natural\ntransformations, and it is straightforward to check that they are mutually inverse.\n□\n5.1.1.12\nQuantifiers as adjoints\nOne of the simplest but neatest places that adjoints show up is between preimages and\nthe logical quantifiers D and @, which we first discussed in Notation 2.1.1.1.\nThe setting\nin which to discuss this is that of sets and their power preorders. That is, if X is a set\nthen recall from Section 3.4.2 that the power set PpXq has a natural ordering by inclusion\nof subsets.\nGiven a function f : X N Y and a subset V D Y the preimage is f 1pV q :\" tx P\nX | fpxq P V u. If V 1 D V then f 1pV 1q D f 1pV q, so in fact f 1 : PpY q N PpXq can be\nconsidered a functor (where of course we are thinking of preorders as categories). The\nquantifiers appear as adjoints of f 1.\nLet's begin with the left adjoint of f 1 : PpY q N PpXq. It is a functor Lf : PpXq N\nPpY q. Choose an object U D X in PpXq. It turns out that\nLfpUq \" ty P Y | Dx P f 1pyq such that x P Uu.\nAnd the right adjoint Rf : PpXq N PpY q, when applied to U is\nRfpUq \" ty P Y | @x P f 1pyq, x P Uu.\nIn fact, the functor Lf is generally denoted Df : PpXq N PpY q, and Rf is generally\ndenoted @f : PpXq N PpY q.\nPpXq\nDf\n(\n@f\n6 PpY q.\nf 1\no\nWe will see in the next example why this notation is apt.\n\n5.1. ADJOINT FUNCTORS\nExample 5.1.1.13. In logic or computer science, the quantifiers D and @ are used to\nask whether any or all elements of a set have a certain property.\nFor example, one\nmay have a set of natural numbers and want to know whether any or all are even or\nodd. Let Y \" teven, oddu, and let p: N N Y be the function that takes assigns to\neach natural number its parity (even or odd). Because the elements of PpNq and PpY q\nare ordered by \"inclusion of subsets\", we can construe these orders as categories (by\nProposition 4.2.1.17). That's all old; what's new is that we have adjunctions between\nthese categories\nPpNq\nDp\n(\n@p\n6 PpY q.\np 1\no\nGiven a subset U D N, i.e.\nan object U P ObpPpNqq, we investigate the objects\nDppUq, @ppUq. These are both subsets of teven, oddu. The set DppUq includes the el-\nement even if there exists an even number in U; it includes the element odd if there\nexists an odd number in U. Similarly, the set @ppUq includes the element even if every\neven number is in U and it includes odd if every odd number is in U. 5\nWe explain just one of these in terms of the definitions. Let V \" tevenu D Y . Then\nf 1pV q D N is the set of even numbers, and there is a morphism f 1pV q N U in PpNq\nif and only if U contains all the even numbers. Therefore, the adjunction isomorphism\nHomPpNqpf 1pV q, Uq - HomPpY qpV, @pUq says that V D @pU, i.e. @ppUq includes the\nelement even if and only if U contains all the even numbers, as we said above.\nExercise 5.1.1.14. The national Scout jamboree is a gathering of Boy Scouts from troops\nacross the US. Let X be the set of Boy Scouts in the US, and let Y be the set of Boy\nScout troops in the US. Let t: X N Y be the function that assigns to each Boy Scout\nhis troop. Let U D X be the set of Boy Scouts in attendance at this years jamboree.\nWhat is the meaning of the objects DtU and @tU?\n♦\nExercise 5.1.1.15. Let X be a set and U D X a subset. Find a set Y and a function\nf : X N Y such that DfpUq somehow tells you whether U is non-empty, and such that\n@fpUq somehow tells you whether U \" X.\n♦\nIn fact, \"quantifiers as adjoints\" is part of a larger story. Suppose we think of elements\nof a set X as bins, or storage areas. An element of PpXq can be construed as an injection\nU aN X, i.e. an assignment of a bin to each element of U, with at most one element of U\nin each bin. Relaxing that restriction, we may consider arbitrary sets U and assignments\nU N X of a bin to each element u P U. Given a function f : X N Y , we can generalize\nDf and @f to functors denoted Σf and Πf, which will parameterize disjoint unions and\nproducts (respectively) over y P Y . This will be discussed in Section 5.1.4.\n5.1.2\nUniversal concepts in terms of adjoints\nIn this section we discuss how universal concepts, i.e. initial objects and terminal objects,\ncolimits and limits, are easily phrased in the language of adjoint functors. We will say\nthat a functor F : C N D is a left adjoint if there exists a functor G: D N C such that F\nis a left adjoint of G. We showed in Proposition 5.1.1.11 that if F is a left adjoint of some\nfunctor G, then it is isomorphic to every other left adjoint of G, and G is isomorphic to\nevery other right adjoint of F.\n5It may not be clear that by this point we have also handled the question, \"is every element of U\neven?\" One simply checks that odd is not an element of DpU.\n\nCHAPTER 5. CATEGORIES AT WORK\nExample 5.1.2.1. Let C be a category and t: C N 1 the unique functor to the terminal\ncategory. Then t is a left adjoint if and only if C has a terminal object, and t is a right\nadjoint if and only if C has an initial object. The proofs are dual, so let's focus on the\nfirst.\nThe functor t has a right adjoint R: 1 N C if and only if there is an isomorphism\nHomCpc, rq - Hom1ptpcq, 1q,\nwhere r \" Rp1q. But Hom1ptpcq, 1q has one element. Thus t has a right adjoint iffthere\nis a unique morphism c N r in C. This is the definition of r being a terminal object.\nWhen we defined colimits and limits in Definitions 4.5.3.26 and 4.5.3.19 we did so for\nindividual I-shaped diagrams X : I N C. Using adjoints we can define the limit of every\nI-shaped diagram in C at once.\nLet t: C N 1 denote the unique functor to the terminal category. Given an object\nc P ObpCq, consider it as a functor c: 1 N C. Then c t: I N C is the constant functor\nat c, sending each object in I to the same C-object c, and every morphism in I to idc.\nThis induces a functor that we denote by ∆t : C N FunpI, Cq.\nSuppose we want to take the colimit or limit of X. We are given an object X of\nFunpI, Cq and we want back an object of C. We could hope, and it turns out to be true,\nthat the adjoints of ∆t are the limit and colimit. Indeed let Σt : FunpI, Cq N C be the\nleft adjoint of ∆t, and let Πt : FunpI, Cq N C be the right adjoint of ∆t. Then Σt is the\nfunctor that takes colimits, and Πt is the functor that takes limits.\nWe will work with a generalization of colimits and limits in Section 5.1.4. But for\nnow, let's bring this down to earth with a concrete example.\nExample 5.1.2.2. Let C \" Set, and let I \" 3. The category FunpI, Setq is the category\nof t1, 2, 3u-indexed sets, e.g. pZ, N, Zq P ObpFunpI, Setqq is an object of it. The functor\n∆t : Set N FunpI, Setq acts as follows.\nGiven a set c P ObpSetq, consider it as a\nfunctor c: 1 N Set, and the composite c t: I N Set is the constant functor. That is,\n∆tpcq: I N Set is the t1, 2, 3u-indexed set pc, c, cq.\nTo say that ∆t has a right adjoint called Πt : FunpI, Setq N Set and that it \"takes\nlimits\" should mean that if we look through the definition of right adjoint, we will see\nthat the formula will somehow yield the appropriate limit. Fix a functor D: I N Set, so\nDp1q, Dp2q, and Dp3q are sets. The limit lim D of D is the product Dp1q ˆ Dp2q ˆ Dp3q.\nFor example, if D \" pZ, N, Zq then lim D \" Z ˆ N ˆ Z. How does this fact arise in the\ndefinition of adjoint?\nThe definition of Πt being the right adjoint to ∆t says that there is a natural isomor-\nphism of sets,\nHomFunpI,Setqp∆tpcq, Dq - HomSetpc, ΠtpDqq.\n(5.2)\nThe left-hand side has elements f P HomFunpI,Setqp∆tpcq, Dq that look like the left below,\nbut having these three maps is equivalent to having the diagram to the right below:\nc\nfp1q\n\nc\nfp2q\n\nc\nfp3q\n\nDp1q\nDp2q\nDp3q\nc\nfp1q\n\nfp2q\n\nfp3q\n\nDp1q\nDp2q\nDp3q\n\n5.1. ADJOINT FUNCTORS\nThe isomorphism in (5.2) says that choosing the three maps fp1q, fp2q, fp3q is the same\nthing as choosing a function c N ΠtpDq. But this is very close to the universal property\nof limits: there is a unique map l: c N Dp1q ˆ Dp2q ˆ Dp3q, so this product serves well\nas Πt as we have said. We're not giving a formal proof here, but what is missing at\nthis point is the fact that certain diagrams have to commute. This comes down to the\nnaturality of the isomorphism (5.2). The map linduces a naturality square\n∆tpcq\n∆tplq/\nf\n\n∆tΠtD\nπ\n\nD\nD\nwhich says that the following diagram commutes:\nc\nfp1q\n|\nfp2q\n\nfp3q\n\"\nl\n\nDp1q\nDp2q\nDp3q\nDp1q ˆ Dp2q ˆ Dp3q\nπ1\nb\nπ2\nO\nπ3\n<\nIt is not hard to show that the composition of left adjoints is a left adjoint, and the\ncomposition of right adjoints is a right adjoint. In the following example we show how\ncurrying (as in Sections 2.7.2 and 5.1.1.8) arises out of a certain combination of data\nmigration functors.\nExample 5.1.2.3 (Currying via ∆, Σ, Π). Let A, B, and C be sets. Consider the unique\nfunctor a: A N 1 and consider B and C as functors 1\nB\nYYYN Set and 1\nC\nYYYN Set\nrespectively.\nA\na\n/ 1\nB\n#\nC\n=Set\nNote that 1-Set - Set, and we will elide the difference. Our goal is to see currying\narise out of the adjunction between Σa ∆a and Πa ∆a, which tells us that there is an\nisomorphism\nHomSetpΣa∆apBq, Cq - HomSetpB, Πa∆apCqq.\n(5.3)\nBy definition, ∆apBq: A N Set assigns to each element a P A the set B. Since ΣA\ntakes disjoint unions, we have a bijection\nΣap∆apBqq \"\nz\naPA\nB\n\n- A ˆ B.\n\nCHAPTER 5. CATEGORIES AT WORK\nSimilarly ∆apCq: A N Set assigns to each element a P A the set C. Since ΠA takes\nproducts, we have a bijection\nΠap∆apCqq \"\nz\naPA\nC\n\n- CA.\nThe currying isomorphism HomSetpA ˆ B, Cq - HomSetpB, CAq falls out of (5.3).\n5.1.3\nPreservation of colimits or limits\nOne useful fact about adjunctions is that left adjoints preserve all colimits and right\nadjoints preserve all limits.\nProposition 5.1.3.1. Let L: B\n/ A :R\no\nbe an adjunction. For any indexing cate-\ngory I and functor D: I N B, if D has a colimit in B then there is a unique isomorphism\nLpcolim Dq - colimpL Dq.\nSimilarly, for any I P ObpCatq and functor D: I N A, if D has a limit in A then\nthere is a unique isomorphism\nRplim Dq - limpR Dq.\nProof. The proof is simple if one knows the Yoneda lemma (Section 5.2.1.12). I have\ndecided to skip it to keep the book shorter. See [Mac].\n□\nExample 5.1.3.2. Since Ob: Cat N Set is both a left adjoint and a right adjoint, it must\npreserve both limits and colimits. This means that if you want to know the set of objects\nin the fiber product of some categories, you can simply take the fiber product of the set\nof objects in those categories,\nObpA ˆC Bq - ObpAq ˆObpCq ObpBq.\nWhile the right-hand side might look daunting, it is just a fiber product in Set which is\nquite understandable.\nThis is greatly simplifying. If one thinks through what defines a limit in Cat, one\nis dragged through notions of slice categories and terminal objects in them. These slice\ncategories are in Cat so they involve several categories and functors, and it gets hairy\nor even hopeless to a beginner. Knowing that the objects are given by a simple fiber\nproduct makes the search for limits in Cat much simpler.\nFor example, if rns is the linear order category of length n then rns ˆ rms has nm `\nn ` m ` 1 objects because rns has n ` 1 objects and rms has m ` 1 objects.\nExample 5.1.3.3. The \"path poset\" functor L: Grph N PrO given by existence of paths\n(see Exercise 4.1.2.11) is left adjoint to the functor R: PrO N Grph given by replacing\nd's by arrows. This means that L preserves colimits. So taking the union of graphs G\nand H results in a graph whose path poset LpG \\ Hq is the union of the path posets of\nG and H. But this is not so for products.\n\n5.1. ADJOINT FUNCTORS\nLet G \" H \"\na‚\nf\n/ b‚ . Then LpGq \" LpHq \" r1s, the linear order of length 1.\nBut the product G ˆ H in Grph looks like the graph\npa,aq\n‚\n\npa,bq\n‚\npb,aq\n‚\npb,bq\n‚\nIts preorder LpG ˆ Hq does not have pa, aq d pa, bq, whereas this is the case in LpGq ˆ\nLpHq.\n5.1.4\nData migration\nAs we saw in Sections 4.2.2 and 4.2.2.5, a database schema is a category C and an instance\nis a functor I : C N Set.\nNotation 5.1.4.1. Let C be a category. Throughout this section we denote by C-Set\nthe category FunpC, Setq of functors from C to Set, i.e. the category of instances on C.\nIn this section we discuss what happens to the resulting instances when different\nschemas are connected by a functor, say F : C N D. It turns out that three adjoint func-\ntors emerge: ∆F : D-Set N C-Set, ΣF : C-Set N D-Set, and ΠF : C-Set N D-Set,\nwhere ∆F is adjoint to both,\nΣF : C-Set\n/ D-Set :∆F\no\n∆F : D-Set\n/ C-Set :ΠF .\no\nIt turns out that almost all the basic database operations are captured by these three\nfunctors. For example, ∆F handles the job of duplicating or deleting tables, as well as\nduplicating or deleting columns in a single table. The functor ΣF handles taking unions,\nand the functor ΠF handles joining tables together, matching columns, or selecting the\nrows with certain properties (e.g. everyone whose first name is Mary).\n5.1.4.2\nPullback: ∆\nGiven a functor F : C N D and a functor I : D N Set, we can compose them to get a\nfunctor I F : C N Set. In other words, the presence of F provides a way to convert D-\ninstances into C-instances. In fact this conversion is functorial, meaning that morphisms\nof D-instances are sent to morphisms of C-instances. We denote the resulting functor by\n∆F : D-Set N C-Set and call it pullback along F.\nWe have seen an example of this before in Example 4.3.2.15, where we showed how a\nmonoid homomorphism F : M1 N M could add functionality to a finite state machine.\nMore generally, we can use pullbacks to reorganize data, copying and deleting tables and\ncolumns.\nRemark 5.1.4.3. Given a functor F : C N D, which we think of as a schema translation,\nthe functor ∆F : D-Set N C-Set \"goes the opposite way\". The reasoning is simple to\nany explain (composition of functors) but something about it is often very strange to\npeople, at first. The rough idea of this \"contravariance\" is captured by the role-reversal\nin the following slogan:\nSlogan 5.1.4.4.\n\nCHAPTER 5. CATEGORIES AT WORK\n\" If I get my information from you, then your information becomes my infor-\nmation. \"\nConsider the following functor F : C N D: 6\nC :\"\nSSN\n‚\nFirst\n‚\nT1‚\nF\n=\n!\nT2‚\na\n}\n\nLast\n‚\nSalary\n‚\nF\nYYYN\nSSN\n‚\nFirst\n‚\nT‚\nF\n>\n\nLast\n‚\nSalary\n‚\n\": D\n(5.4)\nLet's spend a moment recalling how to \"read\" schemas. In schema C there are leaf\ntables SSN, First, Last, Salary, which represent different kinds of basic data. More\ninterestingly, there are two fact tables. The first is called T1 and it relates SSN, First,\nand Last. The second is called T2 and it relates First, Last, and Salary.\nThe functor F : C N D relates C to a schema with a single fact table relating all four\nattributes: SSN, First, Last, and Salary. We are interested in ∆F : D-Set N C-Set.\nSuppose given the following database instance I : D N Set on D:\nT\nID\nSSN\nFirst\nLast\nSalary\nXF667\n115-234\nBob\nSmith\n$250\nXF891\n122-988\nSue\nSmith\n$300\nXF221\n198-877\nAlice\nJones\n$100\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nHow do you get the instance ∆F pIq: C N Set?\nThe formula was given above:\ncompose I with F. In terms of tables, it feels like duplicating table T as T1 and T2, but\ndeleting a column from each in accordance with the definition of C in (5.4). Here is the\nresult, ∆F pIq, in table form:\n6This example was taken from [Sp1], http://arxiv.org/abs/1009.1166.\n\n5.1. ADJOINT FUNCTORS\nT1\nID\nSSN\nFirst\nLast\nXF667\n115-234\nBob\nSmith\nXF891\n122-988\nSue\nSmith\nXF221\n198-877\nAlice\nJones\nT2\nID\nFirst\nLast\nSalary\nXF221\nAlice\nJones\n$100\nXF667\nBob\nSmith\n$250\nXF891\nSue\nSmith\n$300\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nExercise 5.1.4.5. Let C \" pG, »q be a schema. A leaf table is an object c P ObpCq with\nno outgoing arrows.\na.) Write the condition of being a \"leaf table\" mathematically in three different lan-\nguages: that of graphs (using symbols V, A, src, tgt), that of categories (using HomC,\netc.), and that of tables (in terms of columns, tables, rows, etc.).\nb.) In the language of categories, is there a difference between a terminal object and a\nleaf table? Explain.\n♦\nExercise 5.1.4.6. Consider the schemas\nr1s \"\n0‚\nf\nYYYN\n1‚\nand\nr2s \"\n0‚\ng\nYYYN\n1‚\nh\nYYYN\n2‚ ,\nand the functor F : r1s N r2s given by sending 0 ÞN 0 and 1 ÞN 2.\na.) How many possibilities are there for Fpfq?\nb.) Now suppose I : r2s N Set is given by the following tables.\nID\ng\nAm\nTo be verb\nBaltimore\nPlace\nCarla\nPerson\nDevelop\nAction verb\nEdward\nPerson\nFoolish\nAdjective\nGreen\nAdjective\nID\nh\nAction verb\nVerb\nAdjective\nAdjective\nPlace\nNoun\nPerson\nNoun\nTo be verb\nVerb\nID\nAdjective\nNoun\nVerb\nWrite out the two tables associated to the r1s-instance ∆F pIq: r1s N Set.\n♦\n\nCHAPTER 5. CATEGORIES AT WORK\n5.1.4.7\nLeft pushforward: Σ\nLet F : C N D be a functor.\nThe functor ∆F : D-Set N C-Set has a left adjoint,\nΣF : C-Set N D-Set.\nThe rough idea is that ΣF performs parameterized colimits.\nGiven an instance I : C N Set, we get an instance on D that acts as follows. For each\nobject d P ObpDq, the set ΣF pIqpdq is the colimit (think, union) of some diagram back\nhome in C.\nLeft pushforwards (also known as left Kan extensions) are discussed at length in\n[Sp1]; here we begin with some examples from that paper.\nExample 5.1.4.8. We again use the functor F : C N D drawn below\nC :\"\nSSN\n‚\nFirst\n‚\nT1‚\nF\n=\n!\nT2‚\na\n}\n\nLast\n‚\nSalary\n‚\nF\nYYYN\nSSN\n‚\nFirst\n‚\nT‚\nF\n>\n\nLast\n‚\nSalary\n‚\n\": D\n(5.4)\nWe will be applying the left pushforward ΣF : C-Set N D-Set to the following instance\nI : C N Set:\nT1\nID\nSSN\nFirst\nLast\nT1-001\n115-234\nBob\nSmith\nT1-002\n122-988\nSue\nSmith\nT1-003\n198-877\nAlice\nJones\nT2\nID\nFirst\nLast\nSalary\nT2-001\nAlice\nJones\n$100\nT2-002\nSam\nMiller\n$150\nT2-004\nSue\nSmith\n$300\nT2-010\nCarl\nPratt\n$200\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nThe functor F : C N D sent both tables T1 and T2 to table T. Applying ΣF will take\nthe what was in T1 and T2 and put the union in T. The result ΣF I : D N Set is as\nfollows:\n\n5.1. ADJOINT FUNCTORS\nT\nID\nSSN\nFirst\nLast\nSalary\nT1-001\n115-234\nBob\nSmith\nT1-001.Salary\nT1-002\n122-988\nSue\nSmith\nT1-002.Salary\nT1-003\n198-877\nAlice\nJones\nT1-003.Salary\nT2-001\nT2-A101.SSN\nAlice\nJones\n$100\nT2-002\nT2-A102.SSN\nSam\nMiller\n$150\nT2-004\nT2-004.SSN\nSue\nSmith\n$300\nT2-010\nT2-A110.SSN\nCarl\nPratt\n$200\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nT2-001.SSN\nT2-002.SSN\nT2-004.SSN\nT2-010.SSN\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\nT1-001.Salary\nT1-002-Salary\nT1-003-Salary\nAs you can see, there was no set salary information for any data coming from table\nT1 nor any set SSN information for any data coming form table T2. But the definition\nof adjoint, given in Definition 5.1.1.1, yielded the universal response: freely add new\nvariables that take the place of missing information. It turns out that this idea already\nhas a name in logic, Skolem variables, and a name in database theory, labeled nulls.\nExercise 5.1.4.9. Consider the functor F : 3 N 2 sending 1 ÞN 1, 2 ÞN 2, 3 ÞN 2.\na.) Write down an instance I : 3 N Set.\nb.) Given the description that \"ΣF performs a parameterized colimit\", make an educated\nguess about what ΣF pIq will be. Give your answer in the form of two sets that are\nmade up from the three sets you already wrote down.\n♦\nWe now briefly give the actual formula for computing left pushforwards. Suppose\nthat F : C N D is a functor and let I : C N Set be a set-valued functor on C. Then\nΣF pIq: D N Set is defined as follows. Given an object d P ObpDq we first form the\ncomma category (see Definition 4.6.4.1) for the setup\nC\nFYN D\nd\nÐY 1\nand denote it by pF O dq. There is a canonical projection functor π: pF O dq N C, which\nwe can compose with I : C N Set to obtain a functor pF O dq N Set. We are ready to\ndefine ΣF pIqpdq to be its colimit,\nΣF pIqpdq :\" colim\npF Odq I π.\nWe have defined ΣF pIq: D N Set on objects d P ObpDq. As for morphisms we will be\neven more brief, but one can see [Sp1] for details. Given a morphism g: d N d1 one\n\nCHAPTER 5. CATEGORIES AT WORK\nnotes that there is an induced functor pF O gq: pF O dq N pF O d1q and a commutative\ndiagram of categories:\npF O dq\npF Ogq\n/\nπ\n\nI π\n\npF O d1q\nπ1\nI π1\n\nC\nI\n\nSet\nBy the universal property of colimits, this induces the required function\ncolim\npF Odq I π\nΣF pIqpgq\nYYYYYYYYN colim\npF Od1q I π1.\n5.1.4.10\nRight pushforward: Π\nLet F : C N D be a functor. We heard in Section 5.1.4.7 that the functor ∆F : D-Set N\nC-Set has a left adjoint. Here we explain that it has a right adjoint, ΠF : C-Set N D-Set\nas well. The rough idea is that ΠF performs parameterized limits. Given an instance\nI : C N Set, we get an instance on D that acts as follows. For each object d P ObpDq,\nthe set ΠF pIqpdq is the limit (think, fiber product) of some diagram back home in C.\nRight pushforwards (also known as right Kan extensions) are discussed at length in\n[Sp1]; here we begin with some examples from that paper.\nExample 5.1.4.11. We once again use the functor F : C N D from Example 5.1.4.8. We\nwill apply the right pushforward ΠF to instance I : C N Set from that example. 7\nThe instance ΠF pIq will put data in all 5 tables in D. In T it will put pairs pt1, t2q\nwhere t1 is a row in T1 and t2 is a row in T2 for which the first and last names agree.\n7To repeat for convenience,\nC :\"\nSSN\n‚\nFirst\n‚\nT1‚\nF\n>\n\nT2‚\n`\n~\n\nLast\n‚\nSalary\n‚\nF\nYYYYN\nSSN\n‚\nFirst\n‚\nT‚\nG\n>\n\nLast\n‚\nSalary\n‚\n\": D\n(5.4)\nI : C N Set is\nT1\nID\nSSN\nFirst\nLast\nT1-001\n115-234\nBob\nSmith\nT1-002\n122-988\nSue\nSmith\nT1-003\n198-877\nAlice\nJones\nT2\nID\nFirst\nLast\nSalary\nT2-001\nAlice\nJones\n$100\nT2-002\nSam\nMiller\n$150\nT2-004\nSue\nSmith\n$300\nT2-010\nCarl\nPratt\n$200\n\n5.1. ADJOINT FUNCTORS\nIt will copy the leaf tables exactly, so we do not display them here; the following is the\ntable T for ΠF pIq:\nT\nID\nSSN\nFirst\nLast\nSalary\nT1-002T2-A104\n122-988\nSue\nSmith\n$300\nT1-003T2-A101\n198-877\nAlice\nJones\n$100\nLooking at T1 and T2, there were only two ways to match first and last names.\nExercise 5.1.4.12. Consider the functor F : 3 N 2 sending 1 ÞN 1, 2 ÞN 2, 3 ÞN 2.\na.) Write down an instance I : 3 N Set.\nb.) Given the description that \"ΠF performs a parameterized limit\", make an educated\nguess about what ΠF pIq will be. Give your answer in the form of two sets that are\nmade up from the three sets you already wrote down.\n♦\nWe now briefly give the actual formula for computing right pushforwards. Suppose\nthat F : C N D is a functor and let I : C N Set be a set-valued functor on C. Then\nΠF pIq: D N Set is defined as follows. Given an object d P ObpDq we first form the\ncomma category (see Definition 4.6.4.1) for the setup\n1 dYN D\nF\nÐY C\nand denote it by pd O Fq. There is a canonical projection functor π: pd O Fq N C, which\nwe can compose with I : C N Set to obtain a functor pd O Fq N Set. We are ready to\ndefine ΠF pIqpdq to be its limit,\nΠF pIqpdq :\" lim\npdOF q I π.\nWe have defined ΠF pIq: D N Set on objects d P ObpDq. As for morphisms we will be\neven more brief, but one can see [Sp1] for details. Given a morphism g: d N d1 one\nnotes that there is an induced functor pg O Fq: pd1 O Fq N pd O Fq and a commutative\ndiagram of categories:\npd1 O Fq\npgOF q\n/\nπ1\n\nI π1\n\npd O Fq\nπ\n\nI π\n\nC\nI\n\nSet\nSSN\nID\n115-234\n118-334\n122-988\n198-877\n342-164\nFirst\nID\nAdam\nAlice\nBob\nCarl\nSam\nSue\nLast\nID\nJones\nMiller\nPratt\nRichards\nSmith\nSalary\nID\n$100\n$150\n$200\n$250\n$300\n\nCHAPTER 5. CATEGORIES AT WORK\nBy the universal property of limits, this induces the required function\nlim\npdOF q I π\nΠF pIqpgq\nYYYYYYYYN lim\npd1OF q I π1.\n5.2\nCategories of functors\nFor any two categories C and D, 8 we discussed the category FunpC, Dq of functors and\nnatural transformations between them. In this section we discuss functor categories a bit\nmore and give some important applications within mathematics (sheaves) that extend\nto the real world.\n5.2.1\nSet-valued functors\nLet C be a category. Then we have been writing C-Set to denote the functor category\nFunpC, Setq. Here is a nice result about these categories.\nProposition 5.2.1.1. Let C be a category. The category C-Set is closed under colimits\nand limits.\nSketch of proof. Let J be an indexing category and D: J N C-Set a functor. For each\nobject c P ObpCq, we have a functor Dc : J N Set defined by Dcpjq \" Dpjqpcq. Define a\nfunctor L: C N Set by Lpcq \" limJ Dc, and note that for each f : c N c1 in C there is\nan induced function Lpfq: Lpcq N Lpc1q. One can check that L is a limit of J, because\nit satisfies the relevant universal property.\nThe dual proof holds for colimits.\n□\nApplication 5.2.1.2. When taking in data about a scientific subject, one often finds\nthat the way one thinks about the problem changes over time.\nWe understand this\nphenomenon in the language of databases in terms of a series of schemas C1, C2, . . . , Cn,\nperhaps indexed chronologically. The problem is that old data is held in old schemas\nand we want to see it in our current understanding. The first step is to transfer all the\nold data to our new schema in the freest possible way, that is, making no assumptions\nabout how to fill in the new fields. If one creates functors Fi : Ci N Ci`1 from each of\nthese schemas to the next, then we can push the data forward using ΣFi.\nDoing this we will have n datasets on D :\" Cn, namely one for each \"epoch of\nunderstanding\". Since the category D-Set has all colimits, we can take the union of\nthese datasets and get one. It will have many Skolem variables (see Example 5.1.4.8),\nand these need to be handled in a coherent way. However, the universality of left adjoints\ncould be interpreted as saying that any reasonable formula for handling this old data\ncan be applied to our results.\n♦♦\nExercise 5.2.1.3. By Proposition 5.2.1.1, the category C-Set is closed under taking limits.\nBy Exercises 4.5.3.21 and 4.5.3.28, this means in particular that C-Set has an initial\nobject and a terminal object.\na.) Let A P ObpC-Setq be the initial object, considered as a functor A: C N Set. For\nany c P ObpCq, what is the set Apcq?\n8Technically C has to be small (see Remark 4.1.1.2), but as we said there, we are not worrying about\nthat distinction in this book.\n\n5.2. CATEGORIES OF FUNCTORS\nb.) Let Z P ObpC-Setq be the terminal object, considered as a functor Z : C N Set. For\nany c P ObpCq, what is the set Zpcq?\n♦\nProposition 5.2.1.1 says that we can add or multiply database states together. In\nfact, database states on C form what is called a topos which means that just about every\nconsideration we made for sets holds for instances on any schema. Perhaps the simplest\nschema is C \"\n‚ , on which the relevant topos is indeed Set.\nBut schemas can be\narbitrarily complex, and it is impressive that all of these considerations make sense in\nsuch generality. Here is a table that makes a comparison between these domains.\nDictionary between Set and C-Set\nConcept in Set\nConcept in C-Set\nSet\nObject in C-Set\nFunction\nMorphism in C-Set\nElement\nRepresentable functor\nEmpty set\nInitial object\nNatural numbers\nNatural numbers object\nImage\nImage\n(Co)limits\n(Co)limits\nExponential objects\nExponential objects\n\"Familiar\" arithmetic\n\"Familiar\" arithmetic\nPower sets 2X\nPower objects ΩX\nCharacteristic functions\nCharacteristic morphisms\nSurjections, injections\nEpimorphisms, monomorphisms\nIn the above table we said that elements of a set are akin to representable functors\nin C-Set, but we have not yet defined those; we do so in Section 5.2.1.6. First we briefly\ndiscuss monomorphisms and epimorphisms in general (Definition 5.2.1.4) and then in\nC-Set (Proposition 5.2.1.5).\nDefinition 5.2.1.4 (Monomorphism, Epimorphism). Let S be a category and let f : X N\nY be a morphism. We say that f is a monomorphism if it has the following property.\nFor all objects A P ObpSq and morphisms g, g1 : A N X in S,\nA\ng\n\"\ng1\n=X\nf\n/ Y\nif f g \" f g1 then g \" g1.\nWe say that f : X N Y is an epimorphism if it has the following property. For all\nobjects B P ObpSq and morphisms h, h1 : Y N B in S,\nX\nf\n/ Y\nh\n\"\nh1\n=B\nif h f \" h1 f then h \" h1.\n\nCHAPTER 5. CATEGORIES AT WORK\nIn the category of sets, monomorphisms are the same as injections and epimorphisms\nare the same as surjections (see Proposition 2.7.5.4). The same is true in C-Set: one\ncan check \"table by table\" that a morphism of instances is mono or epi.\nProposition 5.2.1.5. Let C be a category and let X, Y : C N Set be objects in C-Set\nand let f : X N Y be a morphism in C-Set. Then f is a monomorphism (respectively an\nepimorphism) if and only if, for every object c P ObpCq, the function fpcq: Xpcq N Y pcq\nis injective (respectively surjective).\nSketch of proof. We first show that if f is mono (respectively epi) then so is fpcq for all\nc P ObpCq. Considering c as a functor c: 1 N C, this result follows from the fact that ∆c\npreserves limits and colimits, hence monos and epis.\nWe now check that if fpcq is mono for all c P ObpCq then f is mono. Suppose that\ng, g1 : A N X are morphisms in C-Set such that f g \" f g1. Then for every c we have\nf gpcq \" f g1pcq which implies by hypothesis that gpcq \" g1pcq. But the morphisms\nin C-Set are natural transformations, and if two natural transformations g, g1 have the\nsame components then they are the same.\nA similar argument works to show the analogous result for epimorphisms.\n□\n5.2.1.6\nRepresentable functors\nGiven a category C, there are certain functors C N Set that come with the package, one\nfor every object in C. So if C is a database schema, then for every table c P ObpCq there\nis a certain database instance associated to it. These instances, i.e. set-valued functors,\nare called representable functors, and they'll be defined in Definition ??. The idea is\nthat if a database schema represents a conceptual layout of types (e.g. as an olog), then\neach type T has an instance associated to it, standing for \"the generic thing of type T\nwith all its generic attributes\".\nDefinition 5.2.1.7. Let C be a category and let c P ObpCq be an object. The functor\nHomCpc, q: C N Set, sending d P ObpCq to the set HomCpc, dq and acting similarly\non morphisms d N d1, is said to be represented by c.\nIf a functor F : C N Set is\nisomorphic to HomCpc, q, we say that F is a representable functor. We sometimes write\nYc :\" HomCpc, q for short.\nExample 5.2.1.8. Given a category C and an object c P ObpCq, we get a representable\nfunctor. If we think of C as a database schema and c as a table, then what does the\nrepresentable functor Yc : C N Set look like in terms of databases? It turns out that the\nfollowing procedure will generate it.\nBegin by writing a new row, say \",\", in the ID column of table c. For each foreign\nkey column f : c N c1, add a row in the ID column of table c1 called \"fp,q\" and record\nthat result (i.e. \"fp,q\") in the f column of table c. Repeat as follows: for each table d,\nidentify all rows r that have blank cell in column g: d N e. Add a new row called \"gprq\"\nto table e and record that result in the pr, gq cell of table d.\nHere is a concrete example. Let C be the following schema:\nA‚\nf\n/ B‚\ng1\n/\ng2\n/\nh\nC‚\ni\n/ D‚\nE‚\n\n5.2. CATEGORIES OF FUNCTORS\nThen YB : C N Set is the following instance\nA\nID\nf\nB\nID\ng1\ng2\nh\n,\ng1p,q\ng2p,q\nhp,q\nC\nID\ni\ng1p,q\nipg1p,qq\ng2p,q\nipg2p,qq\nD\nID\nipg1p,qq\nipg2p,qq\nE\nID\nhp,q\nWe began with a single element in table B and followed the arrows, putting new\nentries wherever they were required. One might call this the schematically implied ref-\nerence spread or SIRS of the element , in table B. Notice that the table at A is empty,\nbecause there are no morphisms B N A.\nRepresentable functors Yc yield databases states that are as free as possible, subject\nto having the initial row , in table c. We have seen things like this before (by the name\nof Skolem variables) when studying the left pushforward Σ. Indeed, if c P ObpCq is an\nobject, we can consider it as a functor c: 1 N C. A database instance on 1 is the same\nthing as a set X. The left pushforward ΣcpXq has the same kinds of Skolem variables.\nIf X \" t,u is a one element set, then we get the representable functor Σcpt,uq - Yc.\nExercise 5.2.1.9. Consider the schema for graphs,\nGrIn :\"\nAr‚\nsrc /\ntgt /\nVe‚\na.) Write down the representable functor YAr : GrIn N Set as two tables.\nb.) Write down the representable functor YVe as two tables.\n♦\nExercise 5.2.1.10. Consider the loop schema\nLoop :\"\ns‚\nf\n\n.\nWhat is the representable functor Ys : Loop N Set?\n♦\nLet B be a box in an olog, say ⌜a person⌝, and recall that an aspect of B is an\noutgoing arrow, such as ⌜a person⌝\nhas as height in inches\nYYYYYYYYYYYYYYN ⌜an integer⌝.\nThe following\nslogan explains representable functors in those terms.\nSlogan 5.2.1.11.\n\" The functor represented by ⌜a person⌝simply leaves a placeholder, like\nxperson's name herey or xperson's height herey, for every aspect of ⌜a person⌝.\nIn general, there is a representable functor for every type in an olog. The\nrepresentable functor for type T simply encapsulates the most generic or\nabstract example of type T, by leaving a placeholder for each of its attributes.\n\"\n\nCHAPTER 5. CATEGORIES AT WORK\n5.2.1.12\nYoneda's lemma\nOne of the most powerful tools in category theory is Yoneda's lemma. It is often consid-\nered by new students to be quite abstract, but grounding it in databases may help.\nThe idea is this. Suppose that I : C N Set is a database instance, and let c P ObpCq\nbe an object. Because I is a functor, we know that for every row r P Ipcq in table c a\nvalue has been recorded in the f-column, where f : c N c1 is any outgoing arrow. The\nvalue in the pr, fq-cell refers to some row in table c1. What we're saying is that each row\nin table c induces SIRS throughout the database. They may not be \"Skolem\", or in any\nsense \"freely generated\", but they are there nonetheless. The point is that to each row\nin c there is a unique mapping Yc N I.\nLemma 5.2.1.13 (Yoneda's lemma, part 1.). Let C be a category, c P ObpCq an object,\nand I : C N Set a set-valued functor. There is a natural bijection\nHomC-SetpYc, Iq\n-\nYYYYN Ipcq.\nProof. See [Mac].\n□\nExample 5.2.1.14. Consider the category C drawn below:\nC :\"\nmother firstChild = idMother\nChild\n‚\nmother\n/ Mother\n‚\nfirstChild\nh\nThere are two representable functors, YChild and YMother. The latter, when written as a\ndatabase instance, will consist of a single row in each table. The former, YChild : C N Set\nis shown here:\nChild\nID\nmother\n,\nmother(,)\nfirstChild(mother(,))\nmother(,)\nMother\nID\nfirstChild\nmother(,)\nfirstChild(mother(,))\nThe representable functor YChild is the freest instance possible, starting with one element\nin the Child table and satisfying the constraints.\nHere is another instance I : C N Set:\nChild\nID\nmother\nAmy\nMs. Adams\nBob\nMs. Adams\nCarl\nMs. Jones\nDeb\nMs. Smith\nMother\nID\nfirstChild\nMs. Adams\nBob\nMs. Jones\nCarl\nMs. Smith\nDeb\nYoneda's lemma (5.2.1.13) is about the set of natural transformations YChild N I.\nRecall from Definition 4.3.1.2 that a search for natural transformations can get a bit\ntedious.\nYoneda's lemma makes the calculation quite trivial.\nIn our case there are\nexactly four such natural transformations, and they are completely determined by where\n, goes. In some sense the symbol , represents child-ness in our database.\n\n5.2. CATEGORIES OF FUNCTORS\nExercise 5.2.1.15. Consider the schema C and instance I : C N Set from Example\n5.2.1.14. Let YChild be the representable functor as above.\na.) Let α: YChild N I be the natural transformation sending , to Amy.\nWhat is\nαChildpfirstChild(motherp,qqq? 9\nb.) Let α: YChild N I be the natural transformation sending , to Bob.\nWhat is\nαChildpfirstChild(motherp,qqq?\nc.) Let α: YChild N I be the natural transformation sending , to Carl.\nWhat is\nαChildpfirstChild(motherp,qqq?\nd.) Let α: YChild N I be the natural transformation sending , to Deb.\nWhat is\nαChildpfirstChild(motherp,qqq?\ne.) Let α: YChild N I be the natural transformation sending , to Amy.\nWhat is\nαMotherpmotherp,qq?\n♦\nWe saw in Section 5.2.1.6 that a representable functor is a mathematically-generated\ndatabase instance for an abstract thing of type T.\nIt creates placeholders for every\nattribute that things of type T are supposed to have.\nSlogan 5.2.1.16.\n\" Yoneda's lemma says the following. Specifying an actual thing of type T is\nthe same as filling in all placeholders found in the generic thing of type T. \"\nYoneda's lemma is considered by many category theory lovers to be the most im-\nportant tool in the subject. While its power is probably unclear to students whose sole\nbackground in category theory comes from this book, Yoneda's lemma is indeed ex-\ntremely useful for reasoning. It allows us to move the notion of functor application into\nthe realm of morphisms between functors (i.e. morphisms in C-Set, which are natural\ntransformations). This keeps everything in one place -- it's all in the morphisms -- and\nthus more interoperable.\nExample 5.2.1.17. In Example 3.1.1.26, we discussed the cyclic monoid M generated by\nthe symbol Q and subject to the relation Q7 \" Q4. We drew a picture like this:\nQ0\n‚\n/ Q1\n‚\n/ Q2\n‚\n/ Q3\n‚\n/ Q4\n‚\n\nQ6\n‚\nA\nQ5\n‚\no\n(5.5)\nWe are finally ready to give the mathematical foundation for this picture. Since M is a\ncategory with one object, ▲, there is a unique representable functor (up to isomorphism)\nY :\" Y▲: M N Set. A functor M N Set can be thought of as a set with an M-action,\nas discussed in Section 4.2.1.1. Here the required set is\nY p▲q \" HomMp▲, ▲q - tQ0, Q1, Q2, Q3, Q4, Q5, Q6u\n9There is a lot of clutter, perhaps. Note that \"firstChild(mother(,))\" is a row in the Child table.\nAssuming that the math follows the meaning, if , points to Amy, where should firstChild(Mother(,))\npoint?\n\nCHAPTER 5. CATEGORIES AT WORK\nand the action is pretty straightforward (it is called the principal action). We might say\nthat (5.5) is a picture of this principal action of M.\nHowever, we can go one step further. Given a functor Y : M N Set, we can take\nits category of elements,\ns\nM Y as in Section 4.6.2.\nThe category\ns\nM Y has objects\nY p▲q P ObpSetq, i.e. the set of dots in (5.5), and it has a unique morphism Qi N Qj for\nevery path of length d 6 from Qi to Qj in that picture.\nExercise 5.2.1.18. Let c P ObpCq be an object and let I P ObpC-Setq be another object.\nConsider c also as a functor c: 1 N C and recall the pullback functor ∆c : C-Set N Set\nand its left adjoint Σc : Set N C-Set from Section 5.1.4.\na.) What is the set ∆cpIq?\nb.) What is HomSetpt,u, ∆cpIqq?\nc.) What is HomC-SetpΣcpt,uq, Iq?\nd.) How does Σcpt,uq compare to Yc, the functor represented by c, as objects in C-Set?\n♦\nLemma 5.2.1.19 (Yoneda's lemma, part 2). Let C be a category.\nThe assignment\nc ÞN Yc from Lemma 5.2.1.13 extends to a functor Y : Cop N C-Set, and this functor is\nfully faithful.\nIn particular, if c, c1 P ObpCq are objects and there is an isomorphism Yc - Yc1 in\nC-Set, then there is an isomorphism c - c1 in C.\nProof. See [Mac].\n□\nExercise 5.2.1.20. The distributive law for addition of natural numbers says pa`bqˆc \"\na ˆ c ` b ˆ c. Below we will give a proof of the distributive law, using category-theoretic\nreasoning. Annotate anything in red ink with a justification for why it is true.\nProposition 5.2.1.21. For any natural numbers a, b, c P N, the distributive law\npa ` bqc \" ac ` bc\nholds.\nSketch of proof. To finish, justify red stuff.\nLet A, B, C be finite sets and let X be another finite set.\nHomSetppA ` Bq ˆ C, Xq-HomSetpA ` B, XCq\n-HomSetpA, XCq ˆ HomSetpB, XCq\n-HomSetpA ˆ C, Xq ˆ HomSetpB ˆ C, Xq\n-HomSetppA ˆ Cq ` pB ˆ Cq, Xq.\nBy the appropriate application of Yoneda's lemma, we see that there is an isomorphism\npA ` Bq ˆ C - pA ˆ Cq ` pB ˆ Cq\nin Fin. The result about natural numbers follows.\n□\n♦\n\n5.2. CATEGORIES OF FUNCTORS\n5.2.1.22\nThe subobject classifier ΩP ObpC-Setq\nIf C is a category then the functor category C-Set is a very nice kind of category, called\na topos. Note that when C \" 1 is the terminal category, then we have an isomorphism\nC-Set - Set, so the category of sets is a special case of a topos. What is so interesting\nabout toposes (or topoi) is that they so nicely generalize many properties of Set. In this\nshort section we investigate only one such property, namely that C-Set has a subobject\nclassifier, denoted ΩP ObpC-Setq. In the case C \" 1, we saw back in Section 2.7.4.9\nthat the subobject classifier is tTrue, Falseu P ObpSetq.\nAs usual, we consider the matter of subobject classifiers by grounding the discussion\nin terms of databases.\nDefinition 5.2.1.23. Let C be a category, let C-Set denote its category of instances,\nand let 1 P ObpC-Setq denote the terminal object. A subobject classifier for C-Set is an\nobject ΩC P ObpC-Setq and a morphism t: 1 N ΩC with the following property. For any\nmonomorphism f : X N Y in C-Set, there exists a unique morphism charpfq: Y N ΩC\nsuch that the following diagram is a pullback in C-Set:\nX\n!\n/\nf\n\n⌟\nt\n\nY\ncharpfq\n/ ΩC\nIn terms of databases, what this means is that for every schema C there is some special\ninstance ΩC P ObpC-Setq that somehow classifies sub-instances. When our schema is\nthe terminal category, C \" 1, instances are sets and we saw in Definition 2.7.4.9 that the\nsubobject classifier is Ω1 \" tTrue, Falseu. One might think that the subobject classifier\nfor C-Set should just consist of a two-element set table-by-table, i.e. that for every\nc P ObpCq we should have ΩC \"? tTrue, Falseu, but this is not correct.\nIn fact, for any object c P ObpCq, it is easy to say what ΩCpcq should be. We know\nby Yoneda's lemma (Lemma 5.2.1.13) that ΩCpcq \" HomC-SetpYc, ΩCq, where Yc is the\nfunctor represented by c. There is a bijection between HomC-SetpYc, ΩCq and the set of\nsub-instances of Yc. Each morphism f : c N d in C induces a morphism Yf : Yd N Yc,\nand the map ΩCpfq: ΩCpcq N ΩCpdq sends a sub-instance A D Yc to the pullback\nY 1\nf\npAq\n/\n\n⌟\nA\n\nYd\nYf\n/ Yc\nBut this is all very abstract. We now give an example of a subobject classifier.\nExample 5.2.1.24. Consider the category C - r3s depicted below\nC :\"\n✓\n0‚\nafter 1\n/\nafter 2\nafter 3\n$\n1‚\nafter 1\n/\nafter 2\n2‚\nafter 1\n/ 3‚\n✓\n✓\n\nCHAPTER 5. CATEGORIES AT WORK\nTo write down ΩC we need to understand the representable functors Yc P ObpC-Setq,\nfor c \" 0, 1, 2, 3, as well as their subobjects. Here is Y0 as an instance:\nY0p0q\nID\nafter 1\nafter 2\nafter 3\n,\nafter 1(,)\nafter 2(,)\nafter 3(,)\nY0p1q\nID\nafter 1\nafter 2\nafter 1p,q\nafter 2p,q\nafter 3p,q\nY0p2q\nID\nafter 1\nafter 2p,q\nafter 3p,q\nY0p3q\nID\nafter 3p,q\nWhat are the sub-instances of this? There is the empty sub-instance H D Y0 and the\nidentity sub-instance Y0 D Y0. But there are three more as well. Note that if we want\nto keep the , row of table 0 then we have to keep everything. But if we throw away the\n, row of table 0 we can still keep the rest and get a sub-instance. If we want to keep\nthe after 1p,q row of table 1 then we have to keep its images in tables 2 and 3. But we\ncould throw away both the , row of table 0 and the after 1p,q row of table 1 and still\nkeep the rest. And so on. In other words, the subobjects of Y0 are in bijection with the\nset ΩCp0q :\" tyes, in 1, in 2, in 3, neveru.\nThe same analysis holds for the other tables of ΩC. It looks like this:\nΩCp0q\nID\nafter 1\nafter 2\nafter 3\nyes\nyes\nyes\nyes\nin 1\nyes\nyes\nyes\nin 2\nin 1\nyes\nyes\nin 3\nin 2\nin 1\nyes\nnever\nnever\nnever\nnever\nΩCp1q\nID\nafter 1\nafter 2\nyes\nyes\nyes\nin 1\nyes\nyes\nin 2\nin 1\nyes\nnever\nnever\nnever\nΩCp2q\nID\nafter 1\nyes\nyes\nin 1\nyes\nnever\nnever\nΩCp3q\nID\nyes\nnever\nThe morphism 1 N ΩC picks out the yes row of every table.\nNow that we have constructed ΩC P ObpC-Setq, we are ready to see it in action.\nWhat makes ΩC special is that for any instance X : C N Set, the subinstances if X\nare in one-to-one correspondence with the morphisms X N ΩC. Consider the following\narbitrary instance X, where the blue rows denote a sub-instance A D X.\nXp0q\nID\nafter 1\nafter 2\nafter 3\na1\nb1\nc1\nd1\na2\nb2\nc1\nd1\na3\nb2\nc1\nd1\na4\nb3\nc2\nd2\na5\nb5\nc3\nd1\nXp1q\nID\nafter 1\nafter 2\nb1\nc1\nd1\nb2\nc1\nd1\nb3\nc2\nd2\nb4\nc1\nd1\nb5\nc3\nd1\nXp2q\nID\nafter 1\nc1\nd1\nc2\nd2\nc3\nd1\nXp3q\nID\nd1\nd2\n(5.6)\n\n5.2. CATEGORIES OF FUNCTORS\nThis blue sub-instance A D X corresponds to a map charpAq: X N ΩC. That is for\neach c P ObpCq the rows in the c-table of X are sent to the rows in the c-table of ΩC.\nThe way charpAq works is as follows. For each table i and row x P Xpiq, find the first\ncolumn f in which the entry is blue (i.e. fpxq P A), and send x to the corresponding\nelement of ΩCpiq. For example, charpAqp0q sends a1 to in 2 and sends a4 to never, and\ncharpAqp2q sends c1 to yes and sends c2 to never.\nExercise 5.2.1.25. a.) Write out the blue subinstance A D X shown in (5.6) as an in-\nstance of C, i.e. as four tables.\nb.) This subinstance A D X corresponds to a map l:\" charpAq: X N ΩC. For all c P\nObpCq we have a function lpcq: Xpcq N ΩCpcq. With c \" 1, write out lp1q: Xp1q N\nΩCp1q.\n♦\nExercise 5.2.1.26. Let Loop be the loop schema\nLoop \"\ns‚\nf\n\n.\na.) What is the subobject classifier ΩLoop P ObpLoop-Setq?\nb.) How does ΩLoop compare to the representable functor Ys?\n♦\nExercise 5.2.1.27. Let GrIn \"\nAr‚\nsrc /\ntgt /\nVe‚\nbe the indexing category for graphs.\na.) Write down the subobject classifier ΩGrIn P ObpGrIn-Setq in tabular form, i.e. as\ntwo tables.\nb.) Draw ΩGrIn as a graph.\nc.) Let G be the graph below and G1 D G the blue part.\nw‚\nf\n\ng\n/\nh\nx‚\ny‚\nj\nM\ni\n/ z‚\nWrite down G P ObpGrIn-Setq in tabular form.\nd.) Write down the components of the natural transformation charpG1q: G N ΩGrIn.\n♦\n5.2.2\nDatabase instances in other categories\n5.2.2.1\nRepresentations of groups\nThe classical mathematical subject of representation theory is the study of FunpG, Vectq\nwhere G is a group and Vect is the category of vector spaces (over say R). Every such\n\nCHAPTER 5. CATEGORIES AT WORK\nfunctor F : G N Vect is called a representation of G. Since G is a category with one\nobject ▲, F consists of a single vector space V \" Fp▲q together with an action of G on\nit.\nWe can think of this in terms of databases if we have a presentation of G in terms of\ngenerators and relations. The schema corresponding to G has one table and this table\nhas a column for each generator. Giving a representation F is the same as giving an\ninstance on our schema, with some properties that stem from the fact that our target\ncategory is Vect rather than Set. There are many possibilities for expressing 10 such\ndata.\nOne possibility is if we could somehow draw V , say if V is 1-, 2-, or 3-dimensional.\nIf so, let P be our chosen picture of V , e.g. P is the standard drawing of a Cartesian\ncoordinate plane. Then every column of our table would consist entirely of the picture\nP instead of a set of rows. Drawing a point in the ID-column picture would result in\na point being drawn in each other column's picture, in accordance with the G-action.\nEach column would of course respect addition and scalar multiplication.\nAnother possibility is to use the fact that there is a functor U : Vect N Set, so our\ninstance F : G N Vect can be converted to an ordinary instance U F : G N Set. We\nwould have an ordinary set of rows. This set would generally be infinite, but it would\nbe structured by addition and scalar multiplication. For example, assuming V is finite\ndimensional, one could find a few rows that generated the rest.\nA third possibility is to use monads, which allow the table to have only as many rows\nas V has dimensions. This is a considerable savings of space. See Section 5.3.\n5.2.2.2\nRepresentations of quivers\nRepresentation theory also studies representations of quivers. A quiver is just the free\ncategory (see Example 4.1.2.30) on a graph. If P is a graph with free category P then a\nrepresentation of the quiver P is a functor F : P N Vect. Such a representation consists\nof a vector space at every vertex of P and a linear transformation for every arrow. All of\nthe discussion from Section 5.2.2.1 works in this setting, except that there is more than\none table.\n5.2.2.3\nOther target categories\nOne can imagine the value of using target categories other than Set or Vect for databases.\nApplication 5.2.2.4. Geographic data consists of maps of the earth together with various\nfunctions on it. For example for any point on the earth one may want to know the\naverage temperature recorded in the past 10 years, or the precise temperature at this\nmoment. Earth can be considered as a topological space, E. Similarly, temperatures\non earth reside on a continuum, say the space T of real numbers r 100, 200s. Thus the\ntemperature record is a function E N T.\nOther records such as precipitation, population density, elevation, etc. can all be\nconsidered as continuous functions from E to some space. Agencies like the US Geological\nSurvey hold databases of such information. By modeling them on functors C N Top,\nthey may be able to employ mathematical tools such as persistent homology [WeS] to\nfind interesting invariants of the data.\n♦♦\n10We would use the term \"representing\" or \"presenting\", but they are both taken in the context of\nour narrative!\n\n5.2. CATEGORIES OF FUNCTORS\nApplication 5.2.2.5. Many other scientific disciplines could use the same kind of tool. For\nexample, in studying the mechanics of materials, one may want to consider the material\nas a topological space M and measure values such as energy as a continuous M N E.\nSuch observations could be modeled by databases with target category Top or Vect\nrather than Set.\n♦♦\n5.2.3\nSheaves\nLet X be a topological space (see Example 4.2.3.1), such as a sphere. In Section 5.2.2.3\nwe discussed continuous functions out of X, and their use in science (e.g. recording\ntemperatures on the earth as a continuous map X N r 100, 200s). Sheaves allow us to\nconsider the local-global nature of such maps, taking into account reparable discrepancies\nin data gathering tools.\nApplication 5.2.3.1. Suppose that X is the topological space corresponding to the earth;\nby a region we mean an open subset U D X. Suppose that we cover X with 10,000 regions\nU1, U2, . . . , U10000, such that some of the regions overlap in a non-empty subregion (e.g.\nperhaps U5 X U9 % Hq. For each i, j let Ui,j \" Ui X Uj.\nFor each region Ui D X we have a temperature recording device, which gives a\nfunction Ti : Ui N r 100, 200s. If Ui X Uj % H then two different recording devices\ngive us temperature data for the intersection Ui,j. Suppose we find that they do not give\nprecisely the same data, but that there is a translation formula between their results. For\nexample, Ti might register 3 warmer than Tj registers, throughout the region Ui X Uj.\nA consistent system of translation formulas is called a sheaf. It does not demand a\nuniversal \"true\" temperature function, but only a consistent translation system between\nthem.\n♦♦\nThe following definitions (Definitions 5.2.3.2, 5.2.3.5) make the notion of sheaf precise,\nbut we must go slowly (because it will already feel quick to the novice). For every region\nU, we can record the value of some function (say temperature) throughout U; although\nthis record might consist of a mountain of data (a temperature for each point in U!),\nwe think of it as one thing. That is, it is one element in the set of value-assignments\nthroughout U. A sheaf holds the set of possible values-assignments-throughout-U's for\nall the different regions U, as well as how a value-assignment-throughout-U restricts to\na value-assignment-throughout-V for any subset V D U.\nDefinition 5.2.3.2. Let X be a topological space, let OpenpXq denote its partial order\nof open sets, and let OpenpXqop be the opposite category. A presheaf on X is a functor\nO: OpenpXqop N Set. For every open set U D X we refer to the set OpUq as the set\nof values-assignments throughout U of O. If V D U is an open subset, it corresponds to\nan arrow in OpenpXq and applying the functor O yields a function called the restriction\nmap from U to V and denoted ρV,U : OpUq N OpV q. Given a P OpUq, we may denote\nρV,Upaq by a|V ; it is called the restriction of a to V .\nThe category of presheaves on X is simply OpenpXqop-Set; see Definition 4.3.3.1.\nExercise 5.2.3.3.\na.) Come up with 4 overlapping open subsets that cover the square X :\" r0, 3sˆr0, 3s D\nR2. Write down a label for each open set as well as a label for each overlap (2-fold,\n3-fold, etc.); you now have labeled n open sets. For each of these open sets, draw\n\nCHAPTER 5. CATEGORIES AT WORK\na dot with the appropriate label, and then draw an arrow from one dot to another\nwhen the first refers to an open subset of the second. This is a preorder; call it\nOpenpXq. Now make up and write down formulas R1 : X N R and R2 : X N R with\nR1 d R2, expressing a range of temperatures R1ppq d x d R2ppq that an imaginary\nexperiment shows can exist at each point p in the square.\nb.) Suppose we now tried to make our presheaf O: OpenpXqop N Set as follows. For\neach of your open sets, say A, we could put\nOpAq :\" tf : A N R | R1paq d fpaq d R2paqu.\nWhat are the restriction maps? Do you like the name \"value-assignment throughout\nA\" for elements of OpAq?\nc.) We can now make another presheaf O1 given the same experiment. For each of your\nopen sets, say A, we could put\nO1pAq :\" tf : A N R | f is continuous, and R1paq d fpaq d R2paqu.\nAre you comfortable with the idea that there is a morphism of presheaves O1 N O?\n♦\nBefore we define sheaves, we need to clarify the notion of covering. Suppose that U\nis a region and that V1, . . . , Vn are subregions (i.e. for each 1 d i d n we have Vi D U).\nThen we say that the Vi cover U if every point in U is in Vi for some i. Another way to\nsay this is that the natural function \\iVi N U is surjective.\nExample 5.2.3.4. Let X \" R be the space of real numbers, and define the following open\nsubsets: U \" p5, 10q, V1 \" p5, 7q, V2 \" p6, 9q, V3 \" p7, 10q. 11 Then V1, V2, V3 is a cover of\nU. It has overlaps V12 \" V1 X V2 \" p6, 7q, V13 \" V1 X V3 \" H, V23 \" V2 X V3 \" p7, 9q.\nGiven a presheaf O: OpenpXqop N Set, we have sets and functions as in the following\n(incomplete) diagram\nOpV1q\n)\nOpV1 X V2q\nOpUq\n>\n/\n\nOpV2q\n)\nOpV2 X V3q\nOpV3q\nA presheaf O on X tells us what value-assignments throughout U can exist for each\nU. Suppose we have a value-assignment a P OpUq throughout U and another value-\nassignment a1 P OpU 1q throughout U 1, and suppose that they agree as value-assignments\nthroughout U X U 1, i.e. a|UXU1 \" a1|UXU1. In this case we should have a unique value-\nassignment b P OpU Y U 1q throughout U Y U 1 that agrees on the U-part with a and\nagrees on the U 1-part with a1; i.e. b|U \" a and b|U 1 \" a1. This is the sheaf condition.\n11We use parentheses to denote open intervals of real numbers. For example p6, 9q denotes the set\ntx P R | 6 a x a 9u.\n\n5.2. CATEGORIES OF FUNCTORS\nDefinition 5.2.3.5. Let X be a topological space, let OpenpXq be its partial order of\nopen sets, and let O: OpenpXqop N Set be a presheaf. Given an open set U D X and a\ncover V1, . . . , Vn of U, the following condition is called the sheaf condition for that cover.\nSheaf condition Given a sequence a1, . . . , an where each is a value-assignment ai P\nOpViq throughout Vi, suppose that for all i, j we have ai|ViXVj \" aj|ViXVj; then\nthere is a unique value-assignment b P OpUq such that b|Vi \" ai.\nThe presheaf O is called a sheaf if it satisfies the sheaf condition for every cover.\nExample 5.2.3.6. Let X \" R and let U, V1, V2, V3 be the open cover given in Example\n5.2.3.4. Given a measurement taken throughout V1, a measurement taken throughout\nV2, and a measurement taken throughout V3, we have elements a1 P OpV1q, a2 P OpV2q,\nand a3 P OpV3q. If they are in agreement on the overlap intervals, we can glue them to\ngive a measurement throughout U.\nRemark 5.2.3.7. In Application 5.2.3.1, we said that sheaves would help us patch together\ninformation from different sources. Even if different temperature-recording devices Ti\nand Tj registered different temperatures on an overlapping region Ui X Uj, we said they\ncould be patched together if there was a consistent translation system between their\nresults. What is actually needed is a set of isomorphisms\npi,j : Ti|Ui,j\n-\nYN Tj|Ui,j\nthat translate between them, and that these pi,j's act in concert with one another. This\n(when precisely defined,) is called descent data.. The way it interacts with our definition\nof sheaf given in Definitions 5.2.3.2 and 5.2.3.5 is buried in the restriction maps ρ for the\noverlaps as subsets Ui,j D Ui and Ui,j D Uj. We will not explain further here. One can\nsee [Gro].\nApplication 5.2.3.8. Consider outer space as a topological space X. Different astronomers\nrecord observations. Let C \" r390, 700s denote the set of wavelengths in the visible light\nspectrum (written in nanometers). Given an open subset U D X let OpUq denote the\nset of functions U N C. The presheaf O satisfies the sheaf condition; this is the taken-\nfor-granted fact that we can patch together different observations of space.\nBelow are three views of the night sky. Given a telescope position to obtain the first\nview, one moves the telescope right and a little down to obtain the second and one moves\nit down and left to obtain the third. 12\n12Image credit: NASA, ESA, Digitized Sky Survey Consortium.\n\nCHAPTER 5. CATEGORIES AT WORK\nThese are value-assignments a1 P OpV1q, a2 P OpV2q, and a3 P OpV3q throughout subsets\nV1, V2, V3 D X (respectively). These subsets V1, V2, V3 cover some (strangely-shaped)\nsubset U D X. The sheaf condition says that these three value-assignments glue together\nto form a single value-assignment throughout U:\n\n5.2. CATEGORIES OF FUNCTORS\n♦♦\nExercise 5.2.3.9. Find an application of sheaves in your own domain of expertise.\n♦\nApplication 5.2.3.10. Suppose we have a sheaf for temperatures on earth.\nFor every\nregion U we have a set of theoretically possible temperature-assignments throughout U.\nFor example we may know that if it is warm in Texas, warm in Arkansas, and warm\nin Kansas, then it cannot be cold in Oklahoma. With such a sheaf O in hand, one can\nuse facts about the temperature in one region U to predict the temperature in another\nregion V .\nThe mathematics is as follows. Suppose given regions U, V D X and a subset A D\nOpUq corresponding to what we know about the temperature assignment throughout U.\nWe take the following fiber product\npρU,Xq 1pAq\n⌟\n/\n\nOpXq\nρU,X\n\nρV,X / OpV q\nA\n/ OpUq\nThe image of the top map is a subset of OpV q telling us which temperature-assignments\nare possible throughout V given our knowledge A about the temperature throughout U.\nWe can imagine the same type of prediction systems for other domains as well, such\nas the energy of various parts of a material.\n♦♦\nExample 5.2.3.11. In Exercises 4.2.4.3 and 4.2.4.4 we discussed the idea of laws being\ndictated or respected throughout a jurisdiction.\nIf X is earth, to every jurisdiction\nU D X we assign the set OpUq of laws that are dictated to hold throughout U. Given\na law on U and a law on V , we can see if they amount to the same law on U X V . For\nexample, on U a law might say \"no hunting near rivers\" and on V a law might say \"no\nhunting in public areas\". It just so happens that on U XV all public areas are near rivers\nand vice versa, so the laws agree there. These laws patch together to form a single rule\nabout hunting that is enforced throughout the union U YV , respected by all jurisdictions\nwithin it.\n\nCHAPTER 5. CATEGORIES AT WORK\n5.2.3.12\nSheaf of ologged concepts\nDefinition 5.2.3.5 defines what should be called a sheaf of sets. We can discuss sheaves\nof groups or even sheaves of categories. Here is an application of the latter.\nRecall the notion of simplicial complexes discussed in Section 2.7.4.3. They look like\nthis:\nA\nB\nD\nC\nE\nF\nG\nH\nI\nJ\nK\nL\nM\n(5.7)\nGiven such a simplicial complex X, we can imagine each vertex v P X0 as an entity with\na worldview (e.g. a person) and each simplex as the common worldview shared by its\nvertices. To model this, we will assign to each vertex v P X an olog Opvq, corresponding\nto the worldview held by that entity, and to each simplex u P Xn, we assign an olog Opuq\ncorresponding to a common ground worldview.. Recall that X is a subset of PpX0q; it is\na preorder and its elements (the simplices) are ordered by inclusion. If u, v are simplices\nwith u D v then we want a map of ologs (i.e.\na schema morphism) Opvq N Opuq\ncorresponding to how any idea that is shared among the people in v is shared among\nthe people in u. Thus we have a functor O: X N Sch (where we are forgetting the\ndistinction between ologs and databases for notational convenience).\nTo every simplicial complex (indeed every ordered set) one can associate a topological\nspace; in fact we have a functor Alx: PrO N Top, called the Alexandrov functor.\nApplying AlxpXopq we have a space which we denote by X. One can visualize X as X,\nbut the open sets include unions of simplices. There is a unique sheaf of categories on\nX that behaves like X on simplices.\nHow does this work in the case of our sheaf O of worldviews? For simplices such as\npAq or pCIq, the sheaf returns the olog corresponding to that person or shared worldview.\nBut for open sets like the union of pCIJq and pIJKq, what we get is the olog consisting\nof the types shared by C, I, and J for which I and J affirm agreement with types shared\nby I, J, and K.\nExample 5.2.3.13. Imagine two groups of people G1 and G2 each making observations\nabout the world. Suppose that there is some overlap H \" G1 XG2. Then it may happen\nthat there is a conversation including G1 and G2 and both groups are talking about\nsomething and, although using different words, H says \"you guys are talking about the\n\n5.3. MONADS\nsame things, you just use different words.\" In this case there is an object-assignment\nthroughout G1 Y G2 that agrees with both those on G1 and those on G2.\n5.2.3.14\nTime\nOne can use sheaves to model objects in time; Goguen gave an approach to this in [Gog].\nFor another approach, let C be a database schema. The lifespan of information about the\nworld is generally finite; that is, what was true yesterday is not always the case today.\nThus we can associate to each interval U of time the information that we deem to hold\nthroughout U. This is sometimes called the valid time of the data.\nIf something is the case throughout U and we have a subset V D U then of course\nit is the case throughout V . And the sheaf condition holds too: if some information\nholds throughout U and some other information holds throughout U 1, and if these two\nthings restrict to the same information on the overlap U X V , then they can be glued to\ninformation that holds throughout the union U Y V .\nSo we can model information-change over time by using a sheaf of C-sets on the\ntopological space R. One way to think of this is simply as an instance on the schema\nC ˆ OpenpRqop. The sheaf condition is just an added property that our instances have\nto obey.\nExample 5.2.3.15. Consider a hospital in which babies are born. In our scenario, mothers\nenter the hospital, babies are born, mothers and babies leave the hospital. Let C be the\nschema\nc\na baby\nwas birthed by\n/\nm\na mother\nConsider the 8-hour intervals\nShift1 :\" pJan 1 00 : 00, Jan 1 08 : 00q,\nShift2 :\" pJan 1 04 : 00, Jan 1 12 : 00q,\nShift3 :\" pJan 1 8 : 00, Jan 1 16 : 00q.\nThe nurses take shifts of 8 hours, overlapping with their predecessors by 4 hours, and they\nrecord in the database only patients that were there throughout their shift or throughout\nany overlapping shift. A mother might be in the hospital throughout shift 1, arriving\nbefore the new year. A baby is born at 05:00 on Jan 1, and thus does not make it into\nthe Shift1-table, but does make it into the pShift1 X Shift2q-table. The two are there\nuntil 17:00 on Jan 1, and so they are recorded in the Shift2 and Shift3 tables.\nWhether or not this implementation of the sheaf semantics is most useful in practice\nis certainly debatable. But something like this could easily be useful as a semantics, i.e.\na way of thinking about, the temporal nature of data.\n5.3\nMonads\nMonads would probably not have been invented without category theory, but they have\nbeen quite useful in formalizing algebra, calculating invariants of topological spaces, and\nimbedding non-functional operations into functional programming languages. We will\nmainly discuss monads in terms of how they can help us make modeling contexts explicit,\nand in so doing allow us to simplify the language we use in the model.\nMuch of the following material on monads is taken from [Sp3].\n\nCHAPTER 5. CATEGORIES AT WORK\n5.3.1\nMonads formalize context\nMonads can formalize assumptions about the way one will do business throughout a\ndomain. For example, suppose that we want to consider functions that do not have to\nreturn a value for all inputs. Such partial functions can be composed. Indeed, given a\npartial function f : A N B and a partial function g: B N C, one gets a partial function\ng f : A N C in an obvious way.\nHere we are drawing arrows as though we are talking about functions, but there is an\nimplicit context in which we are actually talking about partial functions. Monads allow\nus to write things in the \"functional\" way while holding the underlying context. What\nmakes them useful is that the notion of context we are using here is made formal.\nExample 5.3.1.1 (Partial functions). Partial functions can be modeled by ordinary func-\ntions, if we add a special \"no answer\" element to the codomain. That is, the set of\npartial functions A N B is in one-to-one correspondence with the set of ordinary func-\ntions A N B \\ t,u.\nFor example, suppose we want to model the partial function\nfpxq :\"\nx2 1 : R N R in this way, we would use the function\nfpxq :\"\n$\n'\n&\n'\n%\nx2 1\nif x % 1 and x % 1,\n,\nif x \" 1,\n,\nif x \" 1.\nAn ordinary function f : A N B can be considered a partial function because we can\ncompose with the inclusion\nB N B \\ t,u\n(5.8)\nBut how do we compose two partial functions written in this way? Suppose f : A N\nB \\ t,u and g: B N C \\ t,u are functions. First form a new function\ng1 :\" g \\ t,u: B \\ t,u N C \\ t,u \\ t,u\n(5.9)\nthen compose to get pg1 fq: A N C \\ t,u \\ t,u, and finally send both ,'s to the same\nelement by composing with\nC \\ t,u \\ t,u N C \\ t,u.\n(5.10)\nWhat does this mean? Every element a P A is sent by f to either an element b P B\nor \"no answer\". If it has an answer fpaq P B, this is either sent by g to an element\ngpfpaqq P C or to \"no answer\". We get a partial function A N C by sending a to gpfpaqq\nif possible or to \"no answer\" if it gets stopped along the way.\nThis monad is sometimes called the maybe monad in computer science, because a\npartial function f : A N B takes every element of A and either outputs just an element\nof B or outputs nothing; more succinctly, it outputs a \"maybe B\".\nApplication 5.3.1.2. Experiments are supposed to be performed objectively, but suppose\nwe imagine that changing the person who performs the experiment, say in psychology,\nmay change the outcome. Let A be the set of experimenters, let X be the parameter space\nfor the experimental variables (e.g. X \" Age ˆ Income) and let Y be the observation\nspace (e.g. Y \" propensity for violence). Then whereas we want to think of such an\nexperiment as telling us about a function f : X N Y , we may want to make some of the\ncontext explicit by including information about who performed the experiment. That is,\nwe are really finding a function f : X ˆ A N Y .\n\n5.3. MONADS\nHowever, it may be the case that even ascertaining someones age or income, which\nis done by asking that person, is subject to who in A is doing the asking, and so we\nagain want to consider the experimenter as part of the equation. In this case, we can\nuse a monad to hide the fact that everything in sight is assumed to be influenced by\nA. In other words, we want to announce once and for all our modeling context--that\nevery observable is possibly influenced by the observer--so that it can recede into the\nbackground.\nWe will return to this in Examples 5.3.2.6 and 5.3.3.4.\n♦♦\n5.3.2\nDefinition and examples\nWhat aspects of Example 5.3.1.1 are really about monads, and what aspects are just\nabout partial functions in particular? It is a functor and a pair of natural transformations\nthat showed up in (5.9), (5.8), and (5.10). In this section we will give the definition and\na few examples. We will return to our story about how monads formalize context in\nSection 5.3.3.\nDefinition 5.3.2.1 (Monad). A monad on Set is defined as follows: One announces\nsome constituents (A. functor, B. unit map, C. multiplication map) and asserts that they\nconform to some laws (1. unit laws, 2. associativity law). Specifically, one announces\nA. a functor T : Set N Set,\nB. a natural transformation η: idSet N T, and\nC. a natural transformation μ: T T N T\nWe sometimes refer to the functor T as though it were the whole monad; we call η the\nunit map and we call μ the multiplication map. One asserts that the following laws hold:\n1. The following diagrams of functors Set N Set commute:\nT idSet\nidT η /\n\"\n%\nT T\nμ\n\nT\nidSet T\nη idT /\n\"\n%\nT T\nμ\n\nT\n2. The following diagram of functors Set N Set commutes:\nT T T\nμ idT /\nidT μ\n\nT T\nμ\n\nT T\nμ\n/ T\nExample 5.3.2.2 (List monad). We now go through Definition 5.3.2.1 using what is called\nthe List monad. The first step is to give a functor List: Set N Set, which we did in\nExample 4.1.2.18. Recall that if X \" tp, q, ru then ListpXq includes the empty list r s,\nsingleton lists, such as rps, and any other list of elements in X, such as rp, p, r, q, ps. Given\n\nCHAPTER 5. CATEGORIES AT WORK\na function f : X N Y , one obtains a function Listpfq: ListpXq N ListpY q by entry-wise\napplication of f.\nAs a monad, the functor List comes with two natural transformations, a unit map\nη and a multiplication map μ. Given a set X, the unit map ηX : X N ListpXq returns\nsingleton lists as follows\nX\nηX\n/ ListpXq\np\n/ rps\nq\n/ rqs\nr\n/ rrs\nGiven a set X, the multiplication map μX : ListpListpXqq N ListpXq flattens lists of lists\nas follows.\nListpListpXqq\nμX\n/ ListpXq\n\"\nrq, p, rs, rs, rq, r, p, rs, rrs\n%\n/ rq, p, r, q, r, p, r, rs\nThe naturality of η and μ just mean that these maps work appropriately well under\nterm-by-term replacement by a function f : X N Y . Finally the three monad laws from\nDefinition 5.3.2.1 can be exemplified as follows:\nrp, q, qs idList η / \"\nrps, rqs, rqs\n%\n_\nμ\n\nrp, q, qs\nrp, q, qs η idList / \"\nrp, q, qs\n%\n_\nμ\n\nrp, q, qs\n\"\"\nrp, qs, rrs\n%\n,\n\"\nrs, rr, q, qs\n%ı μ idList /\n_\nidList μ\n\n\"\nrp, qs, rrs, rs, rr, q, qs\n%\n_\nμ\n\n\"\nrp, q, rs, rr, q, qs\n%\nμ\n/ rp, q, r, r, q, qs\nExercise 5.3.2.3. Let P: Set N Set be the powerset functor, so that given a function\nf : X N Y the function Ppfq: PpXq N PpY q is given by taking images.\na.) Make sense of the following statement: \"with η defined by singleton subsets and with\nμ defined by union, J :\" pP, η, μq is a monad\".\nb.) With X \" ta, bu, write down the function ηX as a 2-row, 2-column table, and write\ndown the function μX as a 16-row, 2-column table (you can stop after 5 rows if you\nfully get it).\nc.) Check that you believe the monad laws from Definition 5.3.2.1.\n\n5.3. MONADS\n♦\nExample 5.3.2.4 (Partial functions as a monad). Here is the monad for partial functions.\nThe functor T : Set N Set sends a set X to the set X \\ t,u. Clearly, given a function\nf : X N Y there is an induced function f \\ t,u: X \\ t,u N Y \\ t,u, so this is a\nfunctor. The natural transformation η: id N T is given on a set X by the component\nfunction\nηX : X N X \\ t,u\nthat includes X aN X \\ t,u. Finally, the natural transformation μ: T T N T is given\non a set X by the component function\nμX : X \\ t,u \\ t,u YN X \\ t,u\nthat collapses both copies of ,.\nExercise 5.3.2.5. Let E be a set, elements we will refer to as exceptions. We imagine\nthat a function f : X N Y either outputs a value or one of these exceptions, which might\nbe things like \"overflow!\" or \"division by zero!\", etc. Let T : Set N Set be the functor\nX ÞN X\\E. Follow Example 5.3.2.4 and come up with a unit map η and a multiplication\nmap μ for which pT, η, μq is a monad.\n♦\nExample 5.3.2.6. Fix a set A. Let T : Set N Set be given by TpXq \" XA \" HomSetpA, Xq;\nthis is a functor. For a set X, let ηX : X N TpXq be given by the constant function,\nx ÞN cx : A N X where cxpaq \" x for all a P A. To specify a function\nμX : HomSetpA, TpXqq N HomSetpA, Xq,\nwe curry and need a function AˆHomSetpA, TpXqq N X. We have an evaluation function\n(see Exercise 2.7.2.5) ev: A ˆ HomSetpA, TpXqq N TpXq, and we have an identity func-\ntion idA : A N A, so we have a function pidAˆevq: AˆHomSetpA, TpXqq YN AˆTpXq.\nComposing that with another evaluation function A ˆ HomSetpA, Xq N X yields our\ndesired μX. Namely, for all b P A and f P HompA, TpXqq we have\nμXpfqpbq \" fpbqpbq.\nRemark 5.3.2.7. Monads can be defined on categories other than Set. In fact, for any\ncategory C one can take Definition 5.3.2.1 and replace every occurrence of Set with C\nand obtain the definition for monads on C. We have actually seen a monad pPaths, η, μq\non the category Grph of graphs before, namely in Examples 4.3.1.12 and 4.3.1.13. That\nis, Paths: Grph N Grph, which sends a graph to its paths-graph is the functor part.\nThe unit map η includes a graph into its paths-graph using the observation that every\narrow is a path of length 1. And the multiplication map μ concatenates paths of paths.\nThe Kleisli category of this monad (see Definition 5.3.3.1) is used, e.g. in (4.14) to define\nmorphisms of database schemas.\n5.3.3\nKleisli category of a monad\nGiven a monad J :\" pT, η, μq, we can form a new category KlspJq.\nDefinition 5.3.3.1. Let J \" pT, η, μq be a monad on Set. Form a new category, called\nthe Kleisli category for J, denoted KlspJq, with sets as objects, ObpKlspJqq :\" ObpSetq,\nand with\nHomKlspJqpX, Y q :\" HomSetpX, TpY qq\n\nCHAPTER 5. CATEGORIES AT WORK\nfor sets X, Y . The identity morphism idX : X N X in KlspJq is given by η: X N TpXq\nin Set. The composition of morphisms f : X N Y and g: Y N Z in KlspJq is given as\nfollows. Writing them as functions, we have f : X N TpY q and g: Y N TpZq. The first\nstep is to apply the functor T to g, giving Tpgq: TpY q N TpTpZqq. Then compose with\nf to get Tpgq f : X N TpTpZqq. Finally, compose with μZ : TpTpZqq N TpZq to get\nthe required function X N TpZq. The associativity of this composition formula follows\nfrom the associativity law for monads.\nExample 5.3.3.2. Recall the monad J for partial functions, TpXq \" X \\ t,u, from\nExample 5.3.2.4.\nThe Kleisli category KlspJq has sets as objects, but a morphism\nf : X N Y means a function X N Y \\ t,u, i.e a partial function.\nGiven another\nmorphism g: Y N Z, the composition formula in KlspJq ensures that g f : X N Z has\nthe appropriate behavior.\nNote how this monad allows us to make explicit our assumption that all functions\nare partial, and then hide it away from our notation.\nRemark 5.3.3.3. For any monad J \" pT, η, μq on Set, there is a functor i: Set N KlspJq\ngiven as follows. On objects we have ObpKlspJqq \" ObpSetq, so take i \" idObpSetq.\nGiven a morphism f : X N Y in Set, we need a morphism ipfq: X N Y in KlspJq, i.e.\na function ipfq: X N TpY q. We assign ipfq to be the composite X\nfYN Y\nηYN TpY q. The\nfunctoriality of this mapping follows from the unit law for monads.\nThe point is that any ordinary function (morphism in Set) has an interpretation as\na morphism in the Kleisli category of any monad. More categorically, there is a functor\nSet N KlspJq.\nExample 5.3.3.4. In this example we return to the setting laid out by Application 5.3.1.2\nwhere we had a set A of experimenters and assumed that the person doing the experiment\nmay affect the outcome. We use the monad J \" pT, η, μq from Example 5.3.2.6 and\nhope that KlspJq will conform to our understanding of how to manage the affect of the\nexperimenter on data.\nThe objects of KlspJq are ordinary sets, but a map f : X N Y in KlspJq is a function\nX N Y A. By currying this is the same as a function X ˆA N Y , as desired. To compose\nf with g: Y N Z in KlspJq, we follow the formula. It turns out to be equivalent to the\nfollowing. We have a function X ˆ A N Y and a function Y ˆ A N Z. Modifying the\nfirst slightly, we have a function X ˆ A N Y ˆ A, by identity on A, and we can now\ncompose to get X ˆ A N Z.\nWhat does this say in terms of experimenters affecting data gathering? It says that\nif we work within KlspJq then we will be able to assume that the experimenter is being\ntaken into account; all proposed functions X N Y are actually functions A ˆ X N Y .\nThe natural way to compose these experiments is that we only consider the data from\none experiment to feed into another if the experimenter is the same in both experiments.\nExercise 5.3.3.5. In Exercise 5.3.2.3 we discussed the power set monad J \" pP, η, μq.\na.) Can you find a way to relate the morphisms in KlspJq to relations? That is, given\na morphism f : A N B in KlspJq, is there a natural way to associate to it a relation\nR D A ˆ B?\n13This requirement seems a bit stringent, but it can be mitigated in a variety of ways. One such way\nis to notice that by Remark 5.3.3.3 that we have not added any requirement, because any old way of\ndoing business yields a valid new way of doing business (we just say \"every experimenter would get the\nsame result\"). Another way would be to hand offthe experiment results to another person, who could\ncarry it forward (see Example 5.3.3.8).\n\n5.3. MONADS\nb.) How does the composition formula in KlspJq relate to the composition of relations\ngiven in Definition 2.5.2.3? 14\n♦\nExercise 5.3.3.6. Let J \" pP, η, μq be the power set monad. The category KlspJq is\nclosed under binary products, i.e.\nevery pair of objects A, B P ObpKlspJqq have a\nproduct in KlspJq. What is the product of A \" t1, 2, 3u and B \" ta, bu?\n♦\nExercise 5.3.3.7. Let J \" pP, η, μq be the power set monad. The category KlspJq is\nclosed under binary coproducts, i.e. every pair of objects A, B P ObpKlspJqq have a\ncoproduct in KlspJq. What is the coproduct of A \" t1, 2, 3u and B \" ta, bu?\n♦\nExample 5.3.3.8. Let A be any preorder. We speak of A throughout this example as\nthough it was the linear order given by time because this is a nice case, however the\nmathematics works for any A P ObpPrOq.\nThere is a monad J \" pT, η, μq that captures the idea that a function f : X N Y\noccurs in the context of time in the following sense: The output of f is determined not\nonly by the element x P X on which it is applied but also by the time at which it was\napplied to x; and the output of f occurs at another time, which is not before the time\nof input.\nThe functor part of the monad is given on X P ObpSetq by\nTpXq \" tp: A N A ˆ X | if ppaq \" pa1, xq then a1 e au.\nThe unit ηX : X N TpXq sends x to the function a ÞN pa, xq. The multiplication map\nμX : TpTpXqq N TpXq is roughly described as follows. If for every a P A you have a\nlater element a1 e a and a function p: A N A ˆ X that takes elements of A to later\nelements of A and values of X, then ppa1q is a still later element of A and a value of X,\nas desired.\nMorphisms in the Kleisli category KlspJq can be curried to be functions f : AˆX N\nA ˆ Y such that if fpa, xq \" pa1, yq then a1 e a.\nRemark 5.3.3.9. One of the most important monads in computer science is the so-called\nstate monad. It is used when one wants to allow a program to mutate state variables\n(e.g. in the program\nif x a 4 then x :\" x ` 1 else Print \"done\")\nx is a state variable. The state monad is a special case of the monad discussed in Example\n5.3.3.8. Given any set A, the usual state monad of type A is obtained by giving A the\nindiscrete preorder (see Example 3.4.4.5). More explicitly it is a monad with functor\npart\nX ÞN pA ˆ XqX,\nand it will be briefly discussed in Example 5.3.5.4.\nExample 5.3.3.10. Here we reconsider the image from the front cover of this book, re-\nproduced here.\n14Actually, Definition 2.5.2.3 is about composing spans, but a relation R D A ˆ B is a kind of span,\nR N A ˆ B.\n\nCHAPTER 5. CATEGORIES AT WORK\nan observa*on\na predic*on\nan experiment\nanalyzed by a\nperson yields\nanalyzed by a\nperson produces\nmo*vates the\nspecifica*on of\nwhen executed\nresults in\na hypothesis\nIt looks like an olog, and all ologs are database schemas (see Section 3.5.2.14). But\nhow is \"analyzed by a person yields\" a function from observations to hypotheses? The\nvery name belies the fact that it is an invalid aspect in the sense of Section 2.3.2.1, because\ngiven an observation there may be more than one hypothesis yielded, corresponding to\nwhich person is doing the observing. In fact, all of the arrows in this diagram correspond\nto some hidden context involving people: the prediction is dependent on who analyzes\nthe hypothesis, the specification of an experiment is dependent on who is motivated to\nspecify it, and experiments may result in different observations by different observers.\nWithout monads, the model of science proposed by this olog would be difficult to\nbelieve in. But by choosing a monad we can make explicit (and then hide from discourse)\nour implicit assumption that \"of course this is all dependent on which human is doing\nthe science\". The choice of monad is an additional modeling choice. Do we want to\nincorporate the partial order of time? Do we want the scientist to be modified by each\nfunction (i.e. the person is changed when analyzing an observation to yield a hypothesis)?\nThese are all interesting possibilities.\nOne reasonable choice would be to use the state monad of type A, where A is the\nset of scientific models. This implies the following context: every morphism f : X N Y\nin the Kleisli category of this monad is really a morphism f : X ˆ A N Y ˆ A; while\nostensibly giving a map from X to Y , it is influenced by the scientific model under which\nit is performed, and its outcome yields a new scientific model.\nReading the olog in this context might look like this:\nA hypothesis (in the presence of a scientific model) analyzed by a person\nproduces a prediction (in the presence of a scientific model), which motivates\nthe specification of an experiment (in the presence of a scientific model),\nwhich when executed results in an observation (in the presence of a scientific\nmodel), which analyzed by a person yields a hypothesis (in the presence of a\nscientific model).\nThe parenthetical statements can be removed if we assume them to always be around,\nwhich can be done using the monad above.\n\n5.3. MONADS\n5.3.3.11\nRelaxing functionality constraint for ologs\nIn Section 2.3.2 we said that every arrow in an olog has to be English-readable as a\nsentence, and it has to correspond to a function. For example, the arrow\na person\nhas / a child\n(5.11)\ncomprises an readable sentence, but does not correspond to a function because a person\nmay have no children or more than one child.\nWe'll call olog in which every arrow\ncorresponds to a function (the only option proposed so far in the book) a functional\nolog. Requiring that ologs be functional as we have been doing, comes with advantages\nand disadvantages. The main advantage is that creating a functional olog requires more\nconceptual clarity about the situation, and this has benefits for the olog-creator as well\nas for anyone to whom he or she tries to explain the situation. The main disadvantage\nis that creating a functional olog takes more time, and the olog takes up more space on\nthe page.\nIn the context of the power set monad (see Exercise 5.3.2.3), a morphism f : X N Y\nbetween sets X and Y becomes a binary relation on X and Y , rather than a function,\nas seen in Exercise 5.3.3.5. So in that context, the arrow in (5.11) becomes valid. An\nolog in which arrows correspond to mere binary relations rather than functions might be\ncalled a relational olog.\n5.3.4\nMonads in databases\nIn this section we discuss how to record data in the presence of a monad. The idea is quite\nsimple. Given a schema (category) C, an ordinary instance is a functor I : C N Set. But\nif J \" pT, η, μq is a monad, then a Kleisli J-instance on C is a functor J : C N KlspJq.\nSuch a functor associates to every object c P ObpCq a set Jpcq, and to every arrow\nf : c N c1 in C a morphism Jpfq: Jpcq N Jpc1q in KlspJq. How does this look in terms\nof tables?\nRecall that to represent an ordinary database instance I : C N Set, we use a tabular\nformat in which every object c P ObpCq is displayed as a table including one ID column\nand an additional column for every arrow emanating from c. In the ID column of table\nc were elements of the set Ipcq and in the column assigned to some arrow f : c N c1 the\ncells were elements of the set Ipc1q.\nTo represent a Kleisli database instance J : C N KlsJ is similar; we again use a\ntabular format in which every object c P ObpCq is displayed as a table including one ID\ncolumn and an additional column for every arrow emanating from c. In the ID column\nof table c are again elements of the set Jpcq; however in the column assigned to some\narrow f : c N c1 are not elements of Jpc1q but T-values in Jpc1q, i.e. elements of TpJpc1qq.\nExample 5.3.4.1. Let J \" pT, η, μq be the monad for partial functions, as discussed in\nExample 5.3.1.1. Given any schema C, we can represent a Kleisli J-instance I : C N\nKlspJq in tabular format. To every object c P ObpCq we'll have a set Ipcq of rows, and\ngiven a column c N c1 every row will produce either a value in Ipc1q or fail to produce\na value; this is the essence of partial functions. We might denote the absence of a value\nusing ,.\nConsider the schema indexing graphs\nC :\"\nArrow\n‚\nsrc /\ntgt /\nVertex\n‚\n\nCHAPTER 5. CATEGORIES AT WORK\nAs we discussed in Section 4.2.1.20, an ordinary instance on C represents a graph.\nI :\"\n‚v\nf\n/ ‚w\nh\n=\ng\n#\n‚x\nArrow pIq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\nVertex pIq\nID\nv\nw\nx\nA Kleisli J-instance on C represents graphs in which edges can fail to have a source\nvertex, fail to have a target vertex, or both.\nJ :\"\n‚v\ni\n\nf\n/ ‚w\nh\n=\ng\n#\n‚x\nj\n/\nArrow pJq\nID\nsrc\ntgt\nf\nv\nw\ng\nw\nx\nh\nw\nx\ni\nv\n,\nj\n,\n,\nVertex pJq\nID\nv\nw\nx\nThe context of these tables is that of partial functions, so we do not need a reference for\n, in the vertex table. Mathematically, the morphism Jpsrcq: JpArrowq N JpVertexq\nneeds to be a function JpArrowq N JpVertexq \\ t,u, and it is.\n5.3.4.2\nProbability distributions\nLet r0, 1s D R denote the set of real numbers between 0 and 1. Let X be a set and\np: X N r0, 1s a function. We say that p is a finitary probability distribution on X if\nthere exists a finite subset W D X such that\ny\nwPW\nppwq \" 1,\n(5.12)\nand such that ppxq a 0 if and only if x P W. Note that W is unique if it exists; we call\nit the support of p and denote it Suppppq. Note also that if X is a finite set then every\nfunction p satisfying (5.12) is a finitary probability distribution on X.\nFor any set X, let DistpXq denote the set of finitary probability distributions on X. It\nis easy to check that given a function f : X N Y one obtains a function Distpfq: DistpXq N\nDistpY q by Distpfqpyq \" r\nfpxq\"y ppxq. Thus we can consider Dist: Set N Set as a\nfunctor, and in fact the functor part of a monad. Its unit η: X N DistpXq is given by the\nKronecker delta function x ÞN δx where δxpxq \" 1 and δxpx1q \" 0 for x1 % x. Its multipli-\ncation μ: DistpDistpXqq N DistpXq is given by weighted sum: given a finitary proba-\nbility distribution w: DistpXq N r0, 1s and x P X, put μpwqpxq \" r\npPSupppwq wppqppxq.\nExample 5.3.4.3 (Markov chains). Let Loop be the loop schema,\nLoop :\"\ns‚\nf\n\nas in Example 3.5.2.9. A Dist-instance on Loop is equivalent to a time-homogeneous\nMarkov chain. To be explicit, a functor δ: Loop N KlsDist assigns to the unique object\n\n5.3. MONADS\ns P ObpLoopq a set S \" δpsq, which we call the state space, and to f : s N s a function\nδpfq: S N DistpSq, which sends each element x P S to some probability distribution on\nelements of S. For example, the table δ on the left corresponds to the Markov matrix\nM on the right below:\nδ :\"\ns\nID\nf\n.5(1)+.5(2)\n1(2)\n.7(1)+.3(3)\n.4(1)+.3(2)+.3(4)\nM :\"\n\n0.5\n0.5\n0.7\n0.3\n0.4\n0.3\n0.3\n\n‹‹‚\n(5.13)\nAs one might hope, for any natural number n P N the map f n : S N DistpSq\ncorresponds to the matrix M n, which sends an element in S to its probable location\nafter n iterations of the transition map.\nApplication 5.3.4.4. Every star emits a spectrum of light, which can be understood as\na distribution on the electromagnetic spectrum. Given an object B on earth, different\nparts of B will absorb radiation at different rates. Thus B produces a function from the\nelectromagnetic spectrum to distributions of energy absorption. In the context of the\nprobability distributions monad, we can record data on the schema\nstar\n‚\nemits\n/ wavelengths\n‚\nabsorbed by B\n/ energies\n‚\nThe composition formula for Kleisli categories is the desired one: to each star we associate\nthe weighted sum of energy absorption rates over the set of wavelengths emitted by the\nstar.\n♦♦\n5.3.5\nMonads and adjunctions\nThere is a strong connection between monads and adjunctions: every adjunction creates\na monad, and every monad \"comes from\" an adjunction. For example, the List monad\n(Example 5.3.2.2) comes from the free-forgetful adjunction between sets and monoids\nSet\nF\n/Mon\nU\no\n(see Proposition 5.1.1.2). That is, for any set X, the free monoid on X is\nFpXq \" pListpXq, r s, ``q,\nand the underlying set of that monoid is UpFpXqq \" ListpXq. Now it may seem like\nthere was no reason to use monoids at all--the set ListpXq was needed in order to discuss\nFpXq--but it will turn out that the unit η and multiplication μ will come drop out of\nthe adjunction too. First, we discuss the unit and counit of an adjunction.\nDefinition 5.3.5.1. Let C and D be categories, and let L: C N D and R: D N C be\nfunctors with adjunction isomorphism\nαc,d : HomDpLpcq, dq\n-\nYYYN HomCpc, Rpdqq\n\nCHAPTER 5. CATEGORIES AT WORK\nfor any objects c P ObpCq and d P ObpDq. The unit η: idC N R L (respectively the\ncounit ε: L R N idD) are natural transformations defined as follows.\nGiven an object c P ObpCq, we apply α to idLpcq : Lpcq N Lpcq to get\nηc : c N R Lpcq;\nsimilarly given an object d P ObpDq we apply α 1 to idRpdq : Rpdq N Rpdq to get\nεd : L Rpdq N d.\nBelow we will show how to use the unit and counit of any adjunction to make a\nmonad. We first walk through the process in Example 5.3.5.2.\nExample 5.3.5.2. Consider the adjunction Set\nF\n/Mon\nU\no\nbetween sets and monoids.\nLet T \" U F : Set N Set; this will be the functor part of our monad, and we have\nT \" List. Then the unit of the adjunction, η: idSet N U F is precisely the unit of the\nmonad: for any set X P ObpSetq the component ηX : X N ListpXq is the function that\ntakes x P X to the singleton list rxs P ListpXq. The monad also has a multiplication\nmap μX : TpTpXqq N TpXq, which amounts to flattening a list of lists. This function\ncomes about using the counit ε, as follows\nT T \" U F U F\nidU ε idF\nYYYYYYYYYN U F \" T.\nThe general procedure for extracting a monad from an adjunction is analogous to\nthat shown in Example 5.3.5.2. Given any adjunction\nC\nL\n/D\nR\no\nWe define J \" R L: C N C, we define η: idC N J to be the unit of the adjunction\n(as in Definition 5.3.5.1), and we define μ: J J N J to be the natural transformation\nidR ε idL : RLRL N RL, obtained by applying the counit ε: LR N idD.\nThe above procedure produces monads on arbitrary categories C, whereas our def-\ninition of monad (Definition 5.3.2.1) considers only the case C \" Set. However, this\ndefinition can be generalized to arbitrary categories C by simply replacing every occur-\nrence of the string Set with the string C. Similarly, our definition of Kleisli categories\n(Definition 5.3.3.1) considers only the case C \" Set, but again the generalization to\narbitrary categories C is straightforward. In Proposition 5.3.5.3, it may be helpful to\nagain put C \" Set if one is at all disoriented.\nProposition 5.3.5.3. Let C be a category, let pJ, η, μq be a monad on C, and let K :\"\nKlsCpJq be the Kleisli category. Then there is an adjunction\nC\nL\n/K\nR\no\nsuch that the monad pJ, η, μq is obtained (up to isomorphism) by the above procedure.\nSketch of proof. The functor L: C N K was discussed in Remark 5.3.3.3. We define it\nto be identity on objects (recall that ObpKq \" ObpCq). Given objects c, c1 P ObpCq the\nfunction\nHomCpc, c1q\nL\nYYYN HomKpc, c1q \" HomCpc, Jpc1qq\n\n5.4. OPERADS\nis given by f ÞN ηc1 f. The fact that this is a functor (i.e. that it preserves composition)\nfollows from a monad axiom.\nThe functor R: K N C acts on objects by sending c P ObpKq \" ObpCq to Jpcq P\nObpCq. For objects c, c1 P ObpKq the function\nHomCpc, Jpc1qq \" HomKpc, c1q\nR\nYYYN HomCpJpcq, Jpc1qq\nis given by sending the C-morphism f : c N Jpc1q to the composite\nJpcq\nJpfq\nYYYYYN JJpc1q\nμc1\nYYYYN Jpc1q.\nAgain, the functoriality follows from monad axioms.\nWe will not continue on to show that these are adjoint or that they produce the\nmonad pJ, η, μq, but see [Mac, VI.5.1] for the remainder of the proof.\n□\nExample 5.3.5.4. Let A P ObpSetq be a set, and recall the currying adjunction\nSet\nAˆ /Set\nA\no\ndiscussed briefly in Example 5.1.1.8. The corresponding monad StA is typically called\nthe state monad of type A in programming language theory. Given a set X, we have\nStApXq \" pA ˆ XqA.\nIn the Kleisli category KlspStAq a morphism from X to Y is a function of the form\nX N pA ˆ Y qA, but this can be curried to a function A ˆ X N A ˆ Y .\nThis monad is related to holding on to an internal state variable of type A. Every\nmorphism ostensibly from X to Y actually takes as input not only an element of X but\nalso the current state a P A, and it produces as output not only an element of Y but an\nupdated state as well.\nComputer scientists in programming language theory have found monads to be very\nuseful ([Mog]). In much the same way, monads on Set can be useful in databases, as\ndiscussed in Section 5.3.4. Another, totally different way to use monads in databases is by\nusing a mapping between schemas to produce in each one an internal model of the other.\nThat is, for any functor F : C N D, i.e. mapping of database schemas, the adjunction\npΣF , ∆F q produces a monad on C-Set, and the adjunction p∆F , ΠF q produces a monad\non D-Set. If one interprets the List monad as producing in Set an internal model of\nthe category Mon of monoids, one can similarly interpret the above monads on C-Set\nand D-Set as producing internal models of each within the other.\n5.4\nOperads\nIn this section we briefly introduce operads, which are generalizations of categories.\nThey often are useful for speaking about self-similarity of structure. For example, we\nwill use them to model agents made up of smaller agents, or materials made up of smaller\nmaterials. This association with self-similarity is not really inherent in the definition,\nbut it tends to emerge in our thinking about many operads used in practice.\nLet me begin with a warning.\n\nCHAPTER 5. CATEGORIES AT WORK\nWarning 5.4.0.5. My use of the term operad is not entirely standard and conflicts with\nwidespread usage. The more common term for what I am calling an operad is symmetric\ncolored operad or a symmetric multicategory. An operad classically is a multicategory\nwith one object, and a colored operad is a multicategory. The analogy is that \"operad is\nto multicategory as monoid is to category\". The term multicategory stems from the fact\nthat the morphisms in a multicategory have many, rather than one, input. But there\nis nothing really \"multi\" about the multicategory itself, only its morphisms. Probably\nthe real reason though is that I find the term multicategory to be clunky and the term\noperad to be sleek, clocking in at half the syllables. I apologize if my break with standard\nterminology causes any confusion.\nThis introduction to operads is quite short. One should see [Le1] for an excellent\ntreatment.\n5.4.1\nDefinition and classical examples\nAn operad is like a category in that it has objects, morphisms, and a composition formula,\nand it follows an identity law and an associativity law.\nThe difference is that each\nmorphism has many inputs (and one output).\nA\nB\nC\nS\nf\nThe description of composition in an operad is a bit heavier than it is in a category, but\nthe idea fairly straightforward. Here is a picture of morphisms being composed.\n\n5.4. OPERADS\nA\nB\nC\nS\nD\nT\nf1\nf2\ng\nX\ng ⚬ (f1,f2)\nX\nA\nB\nC\nD\nthe arrows above compose to give\nNote that S and T disappear from the composition, but this is analogous to the way the\nmiddle object disappears from the composition of morphisms in a category\nA\nf\nYYYN S\ng\nYYYN X\nthe arrows to the left compose to give\nA\ng f\nYYYYYN X\nHere is the definition, which we take directly from [Sp4].\nDefinition 5.4.1.1. An operad O is defined as follows: One announces some constituents\n(A. objects, B. morphisms, C. identities, D. compositions) and asserts that they conform\nto some laws (1. identity law, 2. associativity law). Specifically,\nA. one announces a collection ObpOq, each element of which is called an object of\nO.\nB. for each object y P ObpOq, finite set n P ObpFinq, and n-indexed set of objects\nx: n N ObpOq, one announces a set Onpx; yq P ObpSetq. Its elements are called\nmorphisms from x to y in O.\nC. for every object x P ObpOq, one announces a specified morphism denoted idx P\nO1px; xq called the identity morphism on x.\nD. Let s: m N n be a morphism in Fin. Let z P ObpOq be an object, let y: n N\nObpOq be an n-indexed set of objects, and let x: m N ObpOq be an m-indexed\nset of objects. For each element i P n, write mi :\" s 1piq for the pre-image of s\nunder i, and write xi \" x|mi : mi N ObpOq for the restriction of x to mi. Then\n\nCHAPTER 5. CATEGORIES AT WORK\none announces a function\n: Onpy; zq ˆ\nz\niPn\nOmipxi; ypiqq YN Ompx; zq,\n(5.14)\ncalled the composition formula.\nGiven an n-indexed set of objects x: n N ObpOq and an object y P ObpOq, we sometimes\nabuse notation and denote the set of morphisms from x to y by Opx1, . . . , xn; yq. 15 We\nmay write HomOpx1, . . . , xn; yq, in place of Opx1, . . . , xn; yq, when convenient. We can\ndenote a morphism φ P Onpx; yq by φ: x N y or by φ: px1, . . . , xnq N y; we say that\neach xi is a domain object of φ and that y is the codomain object of φ. We use infix\nnotation for the composition formula, e.g. writing ψ pφ1, . . . , φnq.\nOne asserts that the following laws hold:\n1. for every x1, . . . , xn, y P ObpOq and every morphism φ: px1, . . . , xnq N y, we\nhave\nφ pidx1, . . . , idxnq \" φ\nand\nidy φ \" φ;\n2. Let m\nsYN n\ntYN p be composable morphisms in Fin.\nLet z P ObpOq be an\nobject, let y: p N ObpOq, x: n N ObpOq, and w: m N ObpOq respectively\nbe a p-indexed, n-indexed, and m-indexed set of objects. For each i P p, write\nni \" t 1piq for the pre-image and xi : ni N ObpOq for the restriction. Similarly,\nfor each k P n write mk \" s 1pkq and wk : mk N ObpOq; for each i P p, write\nmi, \" pt sq 1piq and wi, : mi, N ObpOq; for each j P ni, write mi,j :\" s 1pjq\nand wi,j : mi,j N ObpOq. Then the diagram below commutes:\ns\nOppy; zq ˆ s\niPp Onipxi; ypiqq ˆ s\niPp, jPni Omi,jpwi,j; xipjqq\n*\nt s\nOnpx; zq ˆ s\nkPn Omkpwk; xpkqq\n)\ns\nOppy; zq ˆ s\niPp Omi, pwi, ; ypiqq\nu\nOmpw; zq\nRemark 5.4.1.2. In this remark we will discuss the abuse of notation in Definition 5.4.1.1\nand how it relates to an action of a symmetric group on each morphism set in our\ndefinition of operad. We follow the notation of Definition 5.4.1.1, especially following\nthe use of subscripts in the composition formula.\nSuppose that O is an operad, z P ObpOq is an object, y: n N ObpOq is an n-indexed\nset of objects, and φ: y N z is a morphism.\nIf we linearly order n, enabling us to\nwrite φ: pyp1q, . . . , yp|n|qq N z, then changing the linear ordering amounts to finding an\nisomorphism of finite sets σ: m -\nYN n, where |m| \" |n|. Let x \" y σ and for each i P n,\nnote that mi \" σ 1ptiuq \" tσ 1piqu, so xi \" x|σ 1piq \" ypiq. Taking idxi P Omipxi; ypiqq\nfor each i P n, and using the identity law, we find that the composition formula induces\na bijection Onpy; zq -\nYN Ompx; zq, which we might denote by\nσ: Opyp1q, yp2q, . . . , ypnq; zq - O\n`\nypσp1qq, ypσp2qq, . . . , ypσpnqq; z\n\n.\n15There are three abuses of notation when writing Opx1, . . . , xn; yq, which we will fix one by one. First,\nit confuses the set n P ObpFinq with its cardinality |n| P N. But rather than writing Opx1, . . . , x|n|; yq,\nit would be more consistent to write Opxp1q, . . . , xp|n|q; yq, because we have assigned subscripts another\nmeaning in part D. But even this notation unfoundedly suggests that the set n has been endowed with\na linear ordering, which it has not. This may be seen as a more serious abuse, but see Remark 5.4.1.2.\n\n5.4. OPERADS\nIn other words, there is an induced group action of Autpnq on Onpx; zq, where Autpnq is\nthe group of permutations of an n-element set.\nThroughout this book, we will permit ourselves to abuse notation and speak of mor-\nphisms φ: px1, x2, . . . , xnq N y for a natural number n P N, without mentioning the\nabuse inherent in choosing an order, so long as it is clear that permuting the order of\nindices would not change anything up to canonical isomorphism.\nExample 5.4.1.3. Let Sets denote the operad defined as follows. For objects we put\nObpSetsq \" ObpSetq. For a natural number n P N and sets X1, . . . , Xn, Y , put\nHomSetspX1, . . . , Xn; Y q :\" HomSetpX1 ˆ ˆ Xn, Y q.\nGiven functions f1 : pX1,1 ˆ ˆ X1,m1q N Y1 through fn : pXn,1 ˆ ˆ Xn,mnq N Yn\nand a function Y1 ˆ ˆ Yn N Z, the universal property provides us a unique function\nof the form pX1,1 ˆ ˆ Xn,mnq YN Z, giving rise to our composition formula.\nExample 5.4.1.4 (Little squares operad). An operad commonly used in mathematics is\ncalled the little n-cubes operad. We'll focus on n \" 2 and talk about the little squares\noperad O. Here the set of objects has only one element, which we denote by a square,\nObpOq \" t u.\nFor a natural number n P N, a morphism f : p , , . . . , q YN is a\npositioning of n non-overlapping squares inside of a square.\nHere is a picture of a\nmorphism pX1, X2, X3q N Y , where X1 \" X2 \" X3 \" Y \" .\nX1\nX2\nX3\nY\nThe composition law says that given a positioning of small squares inside a large square,\nand given a positioning of tiny squares inside each of those small squares, we get a\npositioning of tiny squares inside a large square. A picture is shown in Figure 5.15.\n\nCHAPTER 5. CATEGORIES AT WORK\nX1\nX2\nX3\nY\nX1\nX2\nX3\n=\nY\nFigure 5.15: Here we show a morphism pX1, X2, X3q N Y and morphisms pW1,1, W1,2q N\nX1, pW2,1, W2,2, W2,3q N X2, and pW3,1q N X3, each of which is a positioning of squares\ninside a square. The composition law scales and positions the squares in the \"obvious\"\nway.\nHopefully, what we meant by \"self-similarity\" in the introduction to this section (see\npage 247) is becoming clear.\nExercise 5.4.1.5. Consider an operad O like the little squares operad from Example\n5.4.1.4, except with three objects: square, circle, equilateral triangle. A morphism is\nagain a non-overlapping positioning of shapes inside of a shape.\na.) Draw an example of a morphism f from two circles and a square to a triangle.\nb.) Find three other morphisms that compose into f, and draw the composite.\n♦\n5.4.1.6\nOperads: functors and algebras\nIf operads are like categories, then we can define things like functors and call them operad\nfunctors. Before giving the definition, we give a warning.\n\n5.4. OPERADS\nWarning 5.4.1.7. What we call operad functors in Definition 5.4.1.8 are usually (if not\nalways) called operad morphisms. We thought that the terminology clash between mor-\nphisms of operads and morphisms in an operad was too confusing. It is similar to what\nwould occur in regular category theory (e.g. Chapter 4) if we replaced the term \"functor\"\nwith the term \"category morphism\".\nDefinition 5.4.1.8. Let O and O1 be operads. An operad functor from O to O1, denoted\nF : O N O1 consists of some constituents (A. on-objects part, B. on-morphisms part)\nconforming to some laws (1. preservation of identities, 2. preservation of composition),\nas follows:\nA. There is a function ObpFq: ObpOq N ObpO1q.\nB. For each object y P ObpOq, finite set n P ObpFinq, and n-indexed set of objects\nx: n N ObpOq, there is a function\nFn : Onpx; yq N O1\nnpFx; Fyq.\nAs in B. above, we often denote ObpFq, and also each Fn, simply by F. The laws that\ngovern these constituents are as follows:\n1. For each object x P ObpOq, the equation Fpidxq \" idF x holds.\n2. Let s: m N n be a morphism in Fin. Let z P ObpOq be an object, let y: n N\nObpOq be an n-indexed set of objects, and let x: m N ObpOq be an m-indexed\nset of objects. Then, with notation as in Definition 5.4.1.1, the following diagram\nof sets commutes:\nOnpy; zq ˆ s\niPn Omipxi; ypiqq\nF\n/\n\nO1\nnpFy; Fzq ˆ s\niPn O1\nmipFxi; Fypiqq\n\nOmpx; zq\nF\n/ O1\nmpFx; Fzq\n(5.16)\nWe denote the category of operads and operad functors by Oprd.\nExercise 5.4.1.9. Let O denote the little squares operad from Example 5.4.1.4 and let\nO1 denote the operad you constructed in Exercise 5.4.1.5.\na.) Can you come up with an operad functor O N O1?\nb.) Is it possible to find an operad functor O1 N O?\n♦\nDefinition 5.4.1.10 (Operad algebra). Let O be an operad. An algebra on O is an\noperad functor A: O N Sets.\nRemark 5.4.1.11. Every category can be construed as an operad (yes, there is a functor\nCat N Oprd), by simply not including non-unary morphisms. That is, given a category\nC, one makes an operad O with ObpOq :\" ObpCq and with\nHomOpx1, . . . , xn; yq \"\n#\nHomCpx1, yq\nif n \" 1;\nH\nif n % 1\n\nCHAPTER 5. CATEGORIES AT WORK\nJust like a schema is a category presentation, it is possible to discuss operad presentations\nby generators and relations. Under this analogy, an algebra on an operad corresponds\nto an instance on a schema.\n5.4.2\nApplications of operads and their algebras\nHierarchical structures may be well-modeled by operads.\nDescribing such structures\nusing operads and their algebras allows one to make appropriate distinctions between\ndifferent types of thinking. For example, the allowable formations are encoded in the\noperad, whereas the elements that will fit into those formations are encoded in the\nalgebra. Morphisms of algebras are high-level understandings of how elements of very\ndifferent types (such as materials vs. numbers) can occupy the same place in the structure\nand be compared. We will give examples below.\nApplication 5.4.2.1. Every material is composed of constituent materials, arranged in\ncertain patterns. (In case the material is \"pure\", we consider the material to consist\nof itself as the sole constituent.) Each of these constituent materials each is itself an\narrangement of constituent materials. Thus we see a kind of self-similarity which we can\nmodel with operads.\nOne material is a structured\ncomposite of other materials,\neach of which is a structured\ncomposite of other materials.\n(5.17)\nFor example, a tendon is made of collagen fibers that are assembled in series and\nthen in parallel, in a specific way. Each collagen fibre is made of collagen fibrils that are\nagain assembled in series and then in parallel, with slightly different specifications. We\ncan continue down, perhaps indefinitely, though our resolution fails at some point. A\n\n5.4. OPERADS\ncollagen fibril is made up of tropocollagen collagen molecules, which are twisted ropes\nof collagen molecules, etc.16\nHere is how operads might be employed. We want the same operad to model both\nactual materials, theoretical materials, and functional properties; that is we want more\nthan one algebra on the same operad.\nThe operad O should abstractly model the structure, but not the substance being\nstructured.\nImagine that each of the shapes (including the background \"shape\") in\nDiagram (5.17) is a place-holder, saying something like \"your material here\".\nEach\nmorphism (that's what (5.17) is a picture of) represents a construction of a material out\nof parts. In our picture, it appears we are only concerned with the spacial arrangements,\nbut there is far more flexibility than that. Whether we want to allow for additional\ndetails beyond spacial arrangements is the kinds of choice we make in a meeting called\n\"what operad should we use?\"\n♦♦\nApplication 5.4.2.2. Suppose we have chosen an operad O to model the structure of\nmaterials. Each object of O might correspond to a certain quality of material, and each\nmorphism corresponds to an arrangement of various qualities to form a new quality. An\nalgebra A: O N Sets on O forces us to choose what substances will fill in for these\nqualities. For every object x P ObpOq, we want a set Apxq which will be the set of\nmaterials with that quality. For every arrangement, i.e. morphism, f : px1, . . . , xnq N y,\nand every choice a1 P Apx1q, . . . , an P Apxnq of materials, we need to understand what\nmaterial a1 \" Apfqpa1, . . . , anq P Apyq will emerge when these materials are arranged in\naccordance with f. We are really pinning ourselves down here.\nBut there may be more than one interesting algebra on O. Suppose that B : O N Sets\nis an algebra of strengths rather than materials. For each object x P ObpOq, which\nrepresents some quality, we let Bpxq be the set of possible strengths that something of\nquality x can have. Then for each arrangement, i.e. morphism, f : px1, . . . , xnq N y,\nand every choice b1 P Bpx1q, . . . , bn P Bpxnq of strengths, we need to understand what\nstrength b1 \" Bpfqpb1, . . . , bnq P Bpyq will emerge when these strengths are arranged in\naccordance with f. Certainly an impressive achievement!\nFinally, a morphism of algebras S : A N B would consist of a coherent system for\nassigning to each material a P ApXq of a given quality x a specific strength Spaq P BpXq,\nin such a way that morphisms behaved appropriately. In this language we have stated a\nvery precise goal for the field of material mechanics.\n♦♦\nExercise 5.4.2.3. Consider again the little squares operad O from Example 5.4.1.4. Sup-\npose we wanted to use this operad to describe those photographic mosaics.\na.) Come up with an algebra P : O N Sets that sends the square to the set of all photos\nthat can be pasted into that square. What does P do on morphisms in O?\nb.) Come up with an algebra C : O N Sets that sends each square to the set of all colors\n(visible frequencies of light). In other words, Cp q is the set of colors, not the set of\nways to color the square. What does C do on morphisms in O. Hint: use some kind\nof averaging scheme for the morphisms.\nc.) Guess: if someone were to appropriately define morphisms of O-algebras (something\nakin to natural transformations between functors O N Sets), do you think there\n16Thanks to Professor Sandra Shefelbine for explaining the hierarchical nature of collagen to me. Any\nerrors are my own.\n\nCHAPTER 5. CATEGORIES AT WORK\nwould some a morphism of algebras P N C?\n♦\n5.4.2.4\nWiring diagrams\nExample 5.4.2.5. Here we describe an operad of relations, which we will denote by R.\nThe objects are sets, ObpRq \" ObpSetq. A morphism f : px1, x2, . . . , xnq YN x1 in R is\na diagram in Set of the form\nR\nf1\nw\nf2\n{\n\nfn\n\nf 1\n\nx1\nx2\n\nxn\nx1\n(5.18)\nsuch that the induced function R YN px1 ˆ x2 ˆ ˆ xn ˆ x1q is an injection.\nWe use a composition formula similar to that in Definition 2.5.2.3. Namely, we form\na fiber product\nFP\n\"\ny\ns\niPn Ri\nw\n$\nS\n}\n\ns\niPn\ns\njPmi xi,j\ns\niPn yi\nz\nOne can show that the induces function FP YN\ns\niPn\ns\njPmi xi\n\nˆ y is an injection, so\nwe have a valid composition formula. Finally, the associativity and identity laws hold.\nApplication 5.4.2.6. Suppose we are trying to model life in the following way. We define\nan entity as a set of phenomena, but in order to use colloquial language we say the entity\nis able to experience that set of phenomena. We also want to be able to put entities\ntogether to form a super-entity, so we have a notion of morphism f : pe1, . . . , enq YN e1\ndefined as a relation as in (5.18). The idea is that the morphism f is a way of translating\nbetween the phenomena that may be experienced by the sub-entities and the phenomena\nthat may be experienced by the super-entity.\nThe operad R from Example 5.4.2.5 becomes useful as a language for discussing issues\nin this domain.\n♦♦\nExample 5.4.2.7. Let R be the operad of relations from Example 5.4.2.5. Consider the\nalgebra S : R N Sets given by Spxq \" Ppxq. Given a morphism s\ni xi Ð R N y and\nsubsets x1\ni D xi, we have a subset s\ni x1\ni D s\ni xi. We take the fiber product\nFP\n/\n{\nR\n|\n\ns\ni x1\ni\n/ s\ni xi\ny\n17Technically we need to use isomorphism classes of cone points, but we don't worry about this here.\n\n5.4. OPERADS\nand the image of FP N y is a subset of y.\nApplication 5.4.2.8. Following Application 5.4.2.6 we can use Example 5.4.2.7 as a model\nof survival. Each entity survives only for a subset of the phenomena that it can expe-\nrience. Under this interpretation, the algebra from Example 5.4.2.7 defines survival as\nthe survival of all parts. That is, suppose that we understand how a super-entity is\ncomposed of sub-entities in the sense that we have a translation between the set of phe-\nnomena that may be experienced across the sub-entities and the set of phenomena that\nmay be experienced by the super-entity. Then the super-entity will survive exactly those\nphenomena which translate to phenomena for which each sub-entity desires.\nPerhaps a better term than survival would be \"allowance\". A bureaucracy consists of\na set of smaller bureaucracies, each of which allows certain phenomena to pass; the whole\nbureaucracy allows something to pass if and only if, when translated to the perspective\nof each sub-bureaucracy, it is allowed to pass there.\n♦♦\nExample 5.4.2.9. In this example we discuss wiring diagrams that look like this:\nE is composed of\nE1, E2, and E3\nin the following way:\nE\nE1\nE2\nE3\nThe operad in question will be denoted W; it is discussed in greater detail in [Sp4]. The\nobjects of W are pairs pC, sq where C is a finite set and v: C N ObpSetq is a function.\nThink of such an object as a circle with C-many cables sticking out of it; each cable c is\nassigned a set vpcq corresponding to the set of values that can be carried on that cable.\nFor example E2 \" pC, vq where |C| \" 11 and we consider v to be specified by declaring\nthat black wires carry Z and red wires carry tsweet, sour, salty, bitter, umamiu.\nThe morphisms in W will be pictures as above, formalized as follows. Given ob-\njects pC1, v1q, . . . , pCn, vnq, pD, wq, a morphism F : ppC1, v1q, . . . , pCn, vnqq YN pD, wq is\n\nCHAPTER 5. CATEGORIES AT WORK\na commutative diagram of sets 18\nU\niPn Ci\n\\ivi\n%\ni\n/ G\nx\n\nD\nj\no\nw\n{\nObpSetq\nsuch that i and j are jointly surjective.\nComposition of morphisms is easily understood in pictures: given wiring diagrams\ninside of wiring diagrams, we can throw away the intermediary circles. In terms of sets,\nwe perform a pushout.\nThere is an operad functor W N S given by sending pC, vq to s\ncPC vpcq. The idea is\nthat to an entity defined as having a bunch of cables carrying variables, a phenomenon is\nthe same thing as a choice of value on each cable. A wiring diagram translates between\nvalues experienced locally and values experienced globally.\nApplication 5.4.2.10. In cognitive neuroscience or in industrial economics, it may be that\nwe want to understand the behavior of an entity such as a mind, a society, or a business\nin terms of its structure. Knowing the connection pattern (connectome, supply chain) of\nsub-entities should help us understand how big changes are generated from small ones.\nUnder the functor W N S the algebra S N Sets from Application 5.4.2.8 becomes an\nalgebra W N Sets. To each entity we now associate some subset of the value-assignments\nit can carry.\n♦♦\nApplication 5.4.2.11. In [RS], Radul and Sussman discuss propagator networks. These\ncan presumably be understood in terms of wiring diagrams and their algebra of relations.\n♦♦\n18If one is concerned with cardinality issues, fix a cardinality κ and replace ObpSetq everywhere with\nObpSetaκq.\n\nIndex\na category\nCat, 126\nFLin, 115\nFin, 113, 160\nGrp, 113\nGrpd, 137\nGrph, 115\nMon, 113\nPrO, 113\nProp, 138\nSch, 165\nSet, 113\nStarn, 178\nTop, 136\nVect, 136, 225\n∆, 160, 191\nC-Set, 155\nsSet, 191\nGrIn, 132\nterminal, 127\na functor\nDisc: Set N Cat, 127, 150\nDisc: Set N Grph, 127\nInd: Set N Cat, 196\nCat N Grph, 127, 202\nCat N Sch, 166\nFLin N PrO, 121\nGrp N Cat, 129\nGrp N Grpd, 137\nGrp N Mon, 120\nGrpd N Cat, 137\nGrph N Cat, 126, 202\nGrph N PrO, 122\nGrph N Set, 122, 149, 202\nList: Set N Set, 142\nMon N Cat, 128\nMon N Set, 119, 199\nOb: Cat N Set, 127, 150, 202\nPaths: Grph N Grph, 125, 126, 148,\nΠ1 : Top N Grpd, 138\nPrO N Cat, 131, 132, 159, 171, 175\nPrO N Grph, 121, 132, 202\nPrO N Set, 122, 202\nPrO N Top, 231\nSch N Cat, 166\nSet N Mon, 123, 199\nSet N PrO, 202\nTop N PrOop, 136\nTop N Set, 136\nVectR N Grp, 136\nVectR N PrO, 137\nVectR N Top, 137\n∆N FLin, 160\na group\nE3, 81\nGL3, 81\nUp1q, 82\nΣX, 83\na monad\nPaths, 236\nexceptions, 236\nList, 234\nmaybe, 233\npartial functions, 233\na schema\nLoop, 170, 241\ndepartment store, 102\nindexing graphs, 156\na symbol\npF O Gq, 196\nX{ „, 48\nrns, 92\nFun, 150\nHomSet, 16\nHomC, 112\nN, 13\nOb, 112\nΩ, 59\nP, 58\n\nINDEX\nPath, 87\nR, 32\nZ, 13\nu, 72\n, 16, 112\ncolim, 186\n, 154\nH, 13\nD, 14, 203\nD!, 14\n@, 14, 203\nidX, 17\ns\n, 192\n-, 17\nY, 178\nlim, 184\n⌟, 39\nÞN, 15\nCop, 191\nC{X, 184\nCX{, 186\n``, 70\nZ, 179\n„, 48\n», 28, 159\n\\, 35\nˆ, 31\n⌜, 51\nf 1, 42\n:=, 14\na warning\n\"set\" of objects in a category, 112\ndifferent worldviews, 23\nmisuse of the, 180\nnotation for composition, 28\noperad functors, 249\noperads vs. multicategories, 245\noversimplified science, 9\naction\nleft, 72\nof a group, 82\nof a monoid, 72\norbit of, 83\nright, 72\naction table, 76\nadjoint functors, 199\nadjunct, 200\nadjunction, 200\nadjunction isomorphism, 200\nanalogy: babies and adults, 199\ncounit, 242\nunit, 242\nalgebra\noperad, 250\nan operad\nSets, 248\nlittle n-cubes, 248\nlittle squares, 248\nappropriate comparison, 77, 88, 97, 112,\narrow, 84\nBaez, John, 8\nbiological classification, 98\ncanonical, 18\ncardinality, 19\ncategory, 112\narithmetic of, 198\nas equivalent to schema, 163\ncartesian closed, 140\ncomma, 196\ncoslice, 186\ndiscrete, 127\nequivalence of, 159\nfree category, 126, 225\nKleisli, 236\nnon-example, 113, 114\nof elements, 192\nopposite, 191\npresentation, 134\nslice, 184\nsmall, 112\nunderlying graph of, 126\nCCCs, 140\ncharacteristic function, 60\ncoequalizer, 54\ncolimit, 186\ncommon ground, 231\ncommuting diagram, 20\ncomponent, 142\ncomposition\nclassical order, 28\ndiagrammatic order, 28\nof functions, 16\nof morphisms, 112\nconcatenation\nof lists, 70\nof paths, 88\n\nINDEX\ncone\nleft, 178\nright, 179\ncongruence, 104\ncontext, 233\ncoproduct\ninclusion functions, 35\ncoproducts, 172\nof sets, 35\nuniversal property of, 36\ncorrespondence\none-to-one, 17\ncoslice, 186\ncospan, 175\ncurrying, 54\nas adjunction, 202\nvia data migration functors, 207\ndata, 101\nvalid time, 232\ndata migration, 208\nleft pushforward Σ, 211\npullback ∆, 209\nright pushforward Π, 213\ndatabase\nbusiness rules, 102\ncategory of instances on, 155\nforeign key, 102\ninstance, 108, 135\nKleisli, 240\nprimary key, 102\nschema, 103, 105\ntables, 101\ndescent data, 228\ndiagam\ncommutes, 20\ndiagram, 176\nin Set, 20\nDolan, James, 8\ndynamical system\ncontinuous, 136\ndiscrete, 106\nEilenberg, Samuel, 7\nEnglishification, 29\nEnglishifiication, 109\nentry\nin list, 69\nepimorphism, 217\nin Set, 60\nequalizer, 47, 185\nequivalence relation, 48\nas partition, 48\nequivalence classes, 48\ngenerated, 49\nquotient by, 48\nexceptions, 236\nexponentials\nevaluation of, 55\nexponentials\nin Set, 55\nfiber product, 39\nfiber sum, 50\nfinite state machine, 74, 195\nfunction, 14\nbijection, 60\ncodomain, 14\ncomposition, 16\ndomain, 14\nequality of, 16\nidentity, 17\ninjection, 60\ninverse, 17\nisomorphism, 17\nsurjection, 60\nfunctor, 119\nadjoint, 200\nconstant, 205\ncontravariant, 190\ncovariant, 190\nfaithful, 162\nfull, 162\nrepresentable, 218\ngateway, 170\ngeography, 100, 226\ngraph, 84\nas functor, 132\nbipartite, 46\nchain, 86\nconverting to a preorder, 93\nfree category on, 126, 225\nhomomorphism, 88\npaths, 87\npaths-graph, 124, 236\nsymmetric, 133\ngraph homomorphism\nas functor, 156\nGrothendieck, 192\n\nINDEX\nconstruction, 191\nexpanding universes, 112\nin history, 8\ngroup, 80\naction, 82\nas category, 129\nhomomorphism of, 83\nof automorphisms, 130\ngroupoid, 137\nfundamental, 137\nof material states, 137\nhierarchy, 106\nhom-set, 112\niff, 50\nimage, 16\nin olog, 30\ninclusion functions, 35\nindexed set, 64, 65\nas functor, 156\nindexing category, 176\ninduced function, 34\ninfix notation, 68\ninformation theory, 141\ninitial object, 179\nin C-Set, 216\ninstance, 108, 135\nKleisli, 240\nisomorphism, 116\nof sets, 17\njoin, 95\nJoyal, Andr e, 8\nKan extension\nleft, 211\nright, 213\nKan, Daniel, 8\nKleisli category, 236\nlabeled null, 212\nLambek, Joachim, 8\nLawvere, William, 8\nleaf table, 210\nlimit, 184\nlinear order\nfinite, 92\nlist, 69, 234\nas functor, 124\nconcatenation, 70\nlocal-to-global, 7\nMac Lane, Saunders, 7\nMarkov chain, 241\nmaterials\nforce extension curves, 54\nforce-extension curves, 15\nmeet, 95\nMoggi, Eugenio, 8\nmonad, 232, 234\nformalizing context, 233\nKleisli category of, 236\non Grph, 236\non Set, 234\non arbitrary category, 243\nmonoid, 67\naction, 72\nadditive natural numbers, 68\nas category, 128\ncommutative, 69\ncyclic, 71\nfree, 70, 123\nhomomorphism, 77\nidentity element of, 68\ninitial, 181\ninverse of an element in, 80\nmultiplication formula, 68\nof endomorphisms, 130\nolog of, 74\npresented, 70\nterminal, 181\ntrivial, 69\ntrivial homomorphism, 78\nmonomorphism, 217\nin Set, 60\nmorphism, 112\ninverse, 116\nmulticategory, 245\nmultiset, 63\nnatural isomorphism, 152\nnatural transformation, 142\nas functor, 185\nas refinement of model, 146\nfor adding functionality, 153\nhorizontal composition of, 154\ninterchange, 154\nvertical composition of, 150\nwhiskering of, 154\n\nINDEX\nolog, 21\nas database schema, 107\naspects, 22\nfacts, 27\nfacts in English, 28\nimages, 30\ninvalid aspects, 23\npath in, 27\nrelational, 240\nrules, 22, 26, 105\nsheaf of, 231\ntypes, 21\nunderlying graph, 85\none-to-one correspondence, 17\nopen cover, 227\noperad\nalgebra of, 250\ncolored, 245\nmorphism of, 250\norbit, 83\nrotating earth, 82\norder, 91\nlinear order, 91\nmorphism, 97\nopposite, 97\npartial order, 91\npreorder, 91\ntree, 96\npartial function, 233\npartial functions, 233\npath, 87\nPED, 104\npermutation, 81\npower set, 58\nas poset, 94\npreimage, 42, 203\npreorder\nas category, 130\nclique in, 94\nconverting to graph, 93\ndiscrete, 98\ngenerated, 94\nindiscrete, 98\njoin, 95\nmeet, 95\npresheaf, 226\nproduct\nas grid, 31\nprojection functions, 31\nproducts, 168, 170, 182\nas not always existing, 171\nof sets, 31\nuniversal property of, 32\nprojection functions, 31\npullback, 184\nof sets, 39\npushout, 186\nof topological spaces, 189\nRDF, 192\nas category of elements, 193\nrelation\nbinary, 90\nequivalence, 48\ngraph of, 90\nrelative set, 64\nas slice category, 186\nrepresentable functor, 218\nrepresentation theory, 225\nrestriction of scalars, 79\nretraction, 54\nRNA transcription, 17\nschema, 105\nas category presentation, 134\nas equivalent to category, 163\nas syntax, 134\ncongruence, 104\nfact table, 209\nleaf table, 103, 209\nmorphism, 164\nof a database, 103\nPath equivalence declaration (PED),\nschematically implied reference spread, 219\nsecurity, 99\nset, 13\narithmetic of, 56\nLawvere's description of, 140\npermutation of, 81\nset builder notation, 14\nsheaf\ncondition, 228\ndescent data, 228\nglueing, 228\nsheaves, 226\nsimplex, 58\nsimplicial complex, 58, 231\n\nINDEX\nsimplicial set, 191\nskeleton, 161\nSkolem, 219\nSkolem variable, 212\nslice, 184\nspace, 99, 135\ntopological, 135\nspace group, 81\nspan, 45\ncomposite, 45\nsubcategory\nfull, 115, 195\nsubobject classifier\nin C-Set, 222\nin Set, 59\nsubset, 13\nas function, 15\ncharacteristic function of, 60\nsubway, 189\nsymmetry, 81\nterminal object, 179\nin C-Set, 216\nin Set, 47\ntopological space, 136\ntopology, 135\ntopos, 222\ntree, 96\nroot, 96\ntrivial homomorphism\nof monoids, 78\nuniversal property, 170\nproducts, 32\npullback, 184\nvector field, 116, 138\nconservative, 138\nvector space, 136, 225\nvertex, 84\nwiring diagram, 254\nYoneda's lemma, 220\n\nBibliography\n[Ati]\nAtiyah, M. (1989) \"Topological quantum field theories\". Publications\nMath ematiques de l'IH ES 68 (68), pp. 175-186.\n[Axl]\nAxler, S. (1997) Linear algebra done right. Springer.\n[Awo]\nS. Awodey. (2010) Category theory. Second edition. Oxford Logic Guides, 52.\nOxford University Press, Oxford.\n[Bar]\nBralow, H. (1961) \"Possible principles underlying the transformation of\nsensory messages\". Sensory communication, pp. 217 - 234.\n[BD]\nBaez, J.C.; Dolan, J. (1995) \"Higher-dimensional algebra and topological\nquantum field theory\". Journal of mathematical physics vol 36, 6073.\n[BFL]\nBaez, J.C.; Fritz, T.; Leinster, T. (2011) \"A characterization of entropy in\nterms of information loss.\" Entropy 13, no. 11.\n[BS]\nBaez, J.C.; Stay, M. (2011) \"Physics, topology, logic and computation: a\nRosetta Stone.\" New structures for physics, 95Ð172. Lecture Notes in Phys.,\n813, Springer, Heidelberg.\n[BP1]\nBrown, R.; Porter, T. (2006) \"Category Theory: an abstract setting for\nanalogy and comparison, In: What is Category Theory? Advanced Studies in\nMathematics and Logic, Polimetrica Publisher, Italy, pp. 257-274.\n[BP2]\nBrown, R.; Porter, T. (2003) \"Category theory and higher dimensional\nalgebra: potential descriptive tools in neuroscience\", Proceedings of the\nInternational Conference on Theoretical Neurobiology, Delhi, edited by\nNandini Singh, National Brain Research Centre, Conference Proceedings 1\n80-92.\n[BW]\nM. Barr, C. Wells. (1990) Category theory for computing science. Prentice\nHall International Series in Computer Science. Prentice Hall International,\nNew York.\n[Big]\nBiggs, N.M. (2004) Discrete mathematics. Oxford University Press, NY.\n[Dia]\nDiaconescu, R. (2008) Institution-independent model theory Springer.\n[DI]\nD oring, A.; Isham, C. J. \"A topos foundation for theories of physics. I.\nFormal languages for physics.\" J. Math. Phys. 49 (2008), no. 5, 053515.\n\nBIBLIOGRAPHY\n[EV]\nEhresmann, A.C.; Vanbremeersch, J.P. (2007) Memory evolutive systems;\nhierarchy, emergence, cognition. Elsevier.\n[Eve]\nEverett III, H. (1973). \"The theory of the universal wave function.\" In The\nmany-worlds interpretation of quantum mechanics (Vol. 1, p. 3).\n[Gog]\nGoguen, J. (1992) \"Sheaf semantics for concurrent interacting objects\"\nMathematical structures in Computer Science Vol 2, pp. 159 - 191.\n[Gro]\nGrothendieck, A. (1971). S eminaire de G eom etrie Alg ebrique du Bois Marie -\n1960-61 - Revˆetements etales et groupe fondamental - (SGA 1) (Lecture notes\nin mathematics 224) (in French). Berlin; New York: Springer-Verlag.\n[Kro]\nKr omer, R. (2007). Tool and Object: A History and Philosophy of Category\nTheory, Birkhauser.\n[Lam]\nLambek, J. (1980) \"From λ-calculus to Cartesian closed categories\". In\nFormalism, Academic Press, London, pp. 375 - 402.\n[Law]\nLawvere, F.W. (2005) \"An elementary theory of the category of sets (long\nversion) with commentary.\" (Reprinted and expanded from Proc. Nat. Acad.\nSci. U.S.A. 52 (1964)) Repr. Theory Appl. Categ. 11, pp. 1 - 35.\n[Kho]\nKhovanov, M. (2000) \"A categorificiation of the Jones polynomial\" Duke\nMath J..\n[Le1]\nLeinster, T. (2004) Higher Operads, Higher Categories. London Mathematical\nSociety Lecture Note Series 298, Cambridge University Press.\n[Le2]\nLeinster, T. (2012) \"Rethinking set theory\". ePrint available\nhttp://arxiv.org/abs/1212.6543.\n[Lin]\nLinsker, R. (1988) \"Self-organization in a perceptual network\". Computer 21,\nno. 3, pp. 105 - 117.\n[LM]\nLandry, E.; Marquis, J-P., 2005, \"Categories in Contexts: historical,\nfoundational, and philosophical.\" Philosophia Mathematica, (3), vol. 13, no. 1,\n1 - 43.\n[LS]\nF.W. Lawvere, S.H. Schanuel. (2009) Conceptual mathematics. A first\nintroduction to categories. Second edition. Cambridge University Press,\nCambridge.\n[MacK]\nMacKay, D.J. (2003). Information theory, inference and learning algorithms.\nCambridge university press.\n[Mac]\nMac Lane, S. (1998) Categories for the working mathematician. Second\nedition. Graduate Texts in Mathematics, 5. Springer-Verlag, New York.\n[Mar1]\nMarquis, J-P. (2009) From a Geometrical Point of View: a study in the\nhistory and philosophy of category theory, Springer.\n[Mar2]\nMarquis, J-P, \"Category Theory\", The Stanford Encyclopedia of Philosophy\n(Spring 2011 Edition), Edward N. Zalta (ed.), http:\n//plato.stanford.edu/archives/spr2011/entries/category-theory\n\nBIBLIOGRAPHY\n[Min]\nMinsky, M. The Society of Mind. Simon and Schuster, NY 1985.\n[Mog]\nMoggi, E. (1989) \"A category-theoretic account of program modules.\"\nCategory theory and computer science (Manchester, 1989), 101Ð117, Lecture\nNotes in Comput. Sci., 389, Springer, Berlin.\n[nLa]\nnLab authors. http://ncatlab.org/nlab/show/HomePage\n[Pen]\nPenrose, R. (2006) The road to reality. Random house.\n[RS]\nRadul, A.; Sussman, G.J. (2009). \"The art of the propagator\". MIT Computer\nscience and artificial intelligence laboratory technical report.\n[Sp1]\nSpivak, D.I. (2012) \"Functorial data migration\". Information and\ncommunication\n[Sp2]\nSpivak, D.I. (2012) \"Queries and constraints via lifting problems\". Submitted\nto Mathematical structures in computer science. ePrint available:\nhttp://arxiv.org/abs/1202.2591\n[Sp3]\nSpivak, D.I. (2012) \"Kleisli database instances\". ePrint available:\nhttp://arxiv.org/abs/1209.1011\n[Sp4]\nSpivak, D.I. (2013) \"The operad of wiring diagrams: Formalizing a graphical\nlanguage for databases, recursion, and plug-and-play circuits\". Available\nonline: http://arxiv.org/abs/1305.0297\n[SGWB] Spivak D.I., Giesa T., Wood E., Buehler M.J. (2011) \"Category Theoretic\nAnalysis of Hierarchical Protein Materials and Social Networks.\" PLoS ONE\n6(9): e23911. doi:10.1371/journal.pone.0023911\n[SK]\nSpivak, D.I., Kent, R.E. (2012) \"Ologs: A Categorical Framework for\nKnowledge Representation.\" PLoS ONE 7(1): e24274.\ndoi:10.1371/journal.pone.0024274.\n[WeS]\nWeinberger, S. (2011) \"What is... Persistent Homology?\" AMS.\n[WeA]\nWeinstein, A. (1996) \"Groupoids: unifying internal and external symmetry.\nNotices of the AMS Vol 43, no. 7, pp. 744 - 752.\n[Wik]\nWikipedia (multiple authors). Various articles, all linked with a\nhyperreference are scattered throughout this text. All accessed December 6,\n2012 - September 17, 2013.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996Category Theory for Scientist\nSpring 2013\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Textbook: Category of Sets",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/7cb36ef846a0cff84b34cda2e7742122_MIT18_S996S13_chapter2.pdf",
      "content": "Chapter 2\nThe category of sets\nThe theory of sets was invented as a foundation for all of mathematics. The notion of\nsets and functions serves as a basis on which to build our intuition about categories in\ngeneral. In this chapter we will give examples of sets and functions and then move on\nto discuss commutative diagrams. At this point we can introduce ologs which will allow\nus to use the language of category theory to speak about real world concepts. Then we\nwill introduce limits and colimits, and their universal properties. All of this material is\nbasic set theory, but it can also be taken as an investigation of our first category, the\ncategory of sets, which we call Set. We will end this chapter with some other interesting\nconstructions in Set that do not fit into the previous sections.\n2.1\nSets and functions\n2.1.1\nSets\nIn this course I'll assume you know what a set is. We can think of a set X as a collection\nof things x P X, each of which is recognizable as being in X and such that for each pair\nof named elements x, x1 P X we can tell if x \" x1 or not. 1 The set of pendulums is the\ncollection of things we agree to call pendulums, each of which is recognizable as being a\npendulum, and for any two people pointing at pendulums we can tell if they're pointing\nat the same pendulum or not.\nNotation 2.1.1.1. The symbol H denotes the set with no elements. The symbol N\ndenotes the set of natural numbers, which we can write as\nN :\" t0, 1, 2, 3, 4, . . . , 877, . . .u.\nThe symbol Z denotes the set of integers, which contains both the natural numbers and\ntheir negatives,\nZ :\" t. . . , 551, . . . , 2, 1, 0, 1, 2, . . .u.\nIf A and B are sets, we say that A is a subset of B, and write A D B, if every element\nof A is an element of B. So we have N D Z. Checking the definition, one sees that\n1Note that the symbol x1, read \"x-prime\", has nothing to do with calculus or derivatives. It is simply\nnotation that we use to name a symbol that is suggested as being somehow like x. This suggestion\nof kinship between x and x1 is meant only as an aid for human cognition, and not as part of the\nmathematics.\n\nCHAPTER 2. THE CATEGORY OF SETS\nFigure 2.1: A set X with 9 elements and a set Y with no elements, Y \" H.\nfor any set A, we have (perhaps uninteresting) subsets H D A and A D A. We can\nuse set-builder notation to denote subsets. For example the set of even integers can be\nwritten tn P Z | n is evenu. The set of integers greater than 2 can be written in many\nways, such as\ntn P Z | n a 2u\nor\ntn P N | n a 2u\nor\ntn P N | n e 3u.\nThe symbol D means \"there exists\". So we could write the set of even integers as\ntn P Z | n is evenu\n\"\ntn P Z | Dm P Z such that 2m \" nu.\nThe symbol D! means \"there exists a unique\". So the statement \"D!x P R such that x2 \"\n0\" means that there is one and only one number whose square is 0. Finally, the symbol\n@ means \"for all\". So the statement \"@m P N Dn P N such that m a n\" means that for\nevery number there is a bigger one.\nAs you may have noticed, we use the colon-equals notation \" A :\" XY Z \" to mean\nsomething like \"define A to be XY Z\". That is, a colon-equals declaration is not denoting\na fact of nature (like 2 ` 2 \" 4), but a choice of the speaker. It just so happens that the\nnotation above, such as N :\" t0, 1, 2, . . .u, is a widely-held choice.\nExercise 2.1.1.2. Let A \" t1, 2, 3u. What are all the subsets of A? Hint: there are 8. ♦\n2.1.2\nFunctions\nIf X and Y are sets, then a function f from X to Y , denoted f : X N Y , is a mapping\nthat sends each element x P X to an element of Y , denoted fpxq P Y . We call X the\ndomain of the function f and we call Y the codomain of f.\n\n2.1. SETS AND FUNCTIONS\n(2.2)\nNote that for every element x P X, there is exactly one arrow emanating from x,\nbut for an element y P Y , there can be several arrows pointing to y, or there can be no\narrows pointing to y.\nApplication 2.1.2.1. In studying the mechanics of materials, one wishes to know how a\nmaterial responds to tension. For example a rubber band responds to tension differently\nthan a spring does. To each material we can associate a force-extension curve, recording\nhow much force the material carries when extended to various lengths.\nOnce we fix\na methodology for performing experiments, finding a material's force-extension curve\nwould ideally constitute a function from the set of materials to the set of curves. 2\n♦♦\nExercise 2.1.2.2. Here is a simplified account of how the brain receives light. The eye\ncontains about 100 million photoreceptor (PR) cells. Each connects to a retinal ganglion\n(RG) cell. No PR cell connects to two different RG cells, but usually many PR cells can\nattach to a single RG cell.\nLet PR denote the set of photoreceptor cells and let RG denote the set of retinal\nganglion cells.\na.) According to the above account, does the connection pattern constitute a function\nRG N PR, a function PR N RG or neither one?\nb.) Would you guess that the connection pattern that exists between other areas of the\nbrain are \"function-like\"?\n♦\nExample 2.1.2.3. Suppose that X is a set and X1 D X is a subset. Then we can consider\nthe function X1 N X given by sending every element of X1 to \"itself\" as an element of\nX. For example if X \" ta, b, c, d, e, fu and X1 \" tb, d, eu then X1 D X and we turn that\ninto the function X1 N X given by b ÞN b, d ÞN d, e ÞN e. 3\nAs a matter of notation, we may sometimes say something like the following: Let X\nbe a set and let i: X1 D X be a subset. Here we are making clear that X1 is a subset of\nX, but that i is the name of the associated function.\n2In reality, different samples of the same material, say samples of different sizes or at different\ntemperatures, may have different force-extension curves. If we want to see this as a true function whose\ncodomain is curves it should have as domain something like the set of material samples.\n3This kind of arrow, ÞN , is read aloud as \"maps to\". A function f : X N Y means a rule for assigning\nto each element x P X an element fpxq P Y . We say that \"x maps to fpxq\" and write x ÞN fpxq.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExercise 2.1.2.4. Let f : N N N be the function that sends every natural number to its\nsquare, e.g. fp6q \" 36. First fill in the blanks below, then answer a question.\na.) 2 ÞN\nb.) 0 ÞN\nc.) 2 ÞN\nd.) 5 ÞN\ne.) Consider the symbol N and the symbol ÞN. What is the difference between how\nthese two symbols are used in this book?\n♦\nGiven a function f : X N Y , the elements of Y that have at least one arrow pointing\nto them are said to be in the image of f; that is we have\nimpfq :\" ty P Y | Dx P X such that fpxq \" yu.\n(2.3)\nExercise 2.1.2.5. If f : X N Y is depicted by (2.2) above, write its image, impfq as a\nset.\n♦\nGiven a function f : X N Y and a function g: Y N Z, where the codomain of f is\nthe same set as the domain of g (namely Y ), we say that f and g are composable\nX\nf\nYYYN Y\ng\nYYYN Z.\nThe composition of f and g is denoted by g f : X N Z.\nFigure 2.4: Functions f : X N Y and g: Y N Z compose to a function g f : X N Z;\njust follow the arrows.\nLet X and Y be sets. We write HomSetpX, Y q to denote the set of functions X N Y .\n4 Note that two functions f, g: X N Y are equal if and only if for every element x P X\nwe have fpxq \" gpxq.\nExercise 2.1.2.6. Let A \" t1, 2, 3, 4, 5u and B \" tx, yu.\n4The strange notation HomSetp , q will make more sense later, when it is seen as part of a bigger\nstory.\n\n2.1. SETS AND FUNCTIONS\na.) How many elements does HomSetpA, Bq have?\nb.) How many elements does HomSetpB, Aq have?\n♦\nExercise 2.1.2.7.\na.) Find a set A such that for all sets X there is exactly one element in HomSetpX, Aq.\nHint: draw a picture of proposed A's and X's.\nb.) Find a set B such that for all sets X there is exactly one element in HomSetpB, Xq.\n♦\nFor any set X, we define the identity function on X, denoted idX : X N X, to be\nthe function such that for all x P X we have idXpxq \" x.\nDefinition 2.1.2.8 (Isomorphism). Let X and Y be sets. A function f : X N Y is\ncalled an isomorphism, denoted f : X\n-\nYN Y , if there exists a function g: Y N X such\nthat g f \" idX and f g \" idY . We also say that f is invertible and we say that g\nis the inverse of f. If there exists an isomorphism X\n-\nYN Y we say that X and Y are\nisomorphic sets and may write X - Y .\nExample 2.1.2.9. If X and Y are sets and f : X N Y is an isomorphism then the\nanalogue of Diagram 2.2 will look like a perfect matching, more often called a one-to-\none correspondence. That means that no two arrows will hit the same element of Y ,\nand every element of Y will be in the image. For example, the following depicts an\nisomorphism X\n-\nYN Y .\n(2.5)\nApplication 2.1.2.10. There is an isomorphism between the set NucDNA of nucleotides\nfound in DNA and the set NucRNA of nucleotides found in RNA. Indeed both sets have\nfour elements, so there are 24 different isomorphisms. But only one is useful. Before we\nsay which one it is, let us say there is also an isomorphism NucDNA - tA, C, G, Tu and\nan isomorphism NucRNA - tA, C, G, Uu, and we will use the letters as abbreviations for\nthe nucleotides.\nThe convenient isomorphism NucDNA\n-\nYN NucRNA is that given by RNA transcription;\nit sends\nA ÞN U, C ÞN G, G ÞN C, T ÞN A.\n\nCHAPTER 2. THE CATEGORY OF SETS\n(See also Application 4.1.2.19.) There is also an isomorphism NucDNA\n-\nYN NucDNA (the\nmatching in the double-helix) given by\nA ÞN T, C ÞN G, G ÞN C, T ÞN A.\nProtein production can be modeled as a function from the set of 3-nucleotide se-\nquences to the set of eukaryotic amino acids. However, it cannot be an isomorphism\nbecause there are 43 \" 64 triplets of RNA nucleotides, but only 21 eukaryotic amino\nacids.\n♦♦\nExercise 2.1.2.11. Let n P N be a natural number and let X be a set with exactly n\nelements.\na.) How many isomorphisms are there from X to itself?\nb.) Does your formula from part a.) hold when n \" 0?\n♦\nLemma 2.1.2.12. The following facts hold about isomorphism.\n1. Any set A is isomorphic to itself; i.e. there exists an isomorphism A -\nYN A.\n2. For any sets A and B, if A is isomorphic to B then B is isomorphic to A.\n3. For any sets A, B, and C, if A is isomorphic to B and B is isomorphic to C then\nA is isomorphic to C.\nProof.\n1. The identity function idA : A N A is invertible; its inverse is idA because\nidA idA \" idA.\n2. If f : A N B is invertible with inverse g: B N A then g is an isomorphism with\ninverse f.\n3. If f : A N B and f 1 : B N C are each invertible with inverses g: B N A and\ng1 : C N B then the following calculations show that f 1 f is invertible with\ninverse g g1:\npf 1 fq pg g1q \" f 1 pf gq g1 \" f 1 idB g1 \" f 1 g1 \" idC\npg g1q pf 1 fq \" g pg1 f 1q f \" g idB f \" g f \" idA\n□\nExercise 2.1.2.13. Let A and B be the sets drawn below:\nA:=\na‚\n7‚\nQ‚\nB:=\nr8‚\n\"Bob\"\n‚\n♣‚\n\n2.1. SETS AND FUNCTIONS\nNote that the sets A and B are isomorphic. Supposing that f : B N t1, 2, 3, 4, 5u sends\n\"Bob\" to 1, sends ♣to 3, and sends r8 to 4, is there a canonical function A N t1, 2, 3, 4, 5u\ncorresponding to f? 5\n♦\nExercise 2.1.2.14. Find a set A such that for any set X there is a isomorphism of sets\nX - HomSetpA, Xq.\nHint: draw a picture of proposed A's and X's.\n♦\nFor any natural number n P N, define a set\nn :\" t1, 2, 3, . . . , nu.\n(2.6)\nSo, in particular, 2 \" t1, 2u, 1 \" t1u, and 0 \" H.\nLet A be any set. A function f : n N A can be written as a sequence\nf \" pfp1q, fp2q, . . . , fpnqq.\nExercise 2.1.2.15.\na.) Let A \" ta, b, c, du. If f : 10 N A is given by pa, b, c, c, b, a, d, d, a, bq, what is fp4q?\nb.) Let s: 7 N N be given by spiq \" i2. Write s out as a sequence.\n♦\nDefinition 2.1.2.16. Cardinality of finite sets][\nLet A be a set and n P N a natural number. We say that A is has cardinality n,\ndenoted\n|A| \" n,\nif there exists an isomorphism of sets A - n. If there exists some n P N such that A has\ncardinality n then we say that A is finite. Otherwise, we say that A is infinite and write\n|A| e 8.\nExercise 2.1.2.17.\na.) Let A \" t5, 6, 7u. What is |A|?\nb.) What is |N|?\nc.) What is |tn P N | n d 5u|?\n♦\nLemma 2.1.2.18. Let A and B be finite sets. If there is an isomorphism of sets f : A N\nB then the two sets have the same cardinality, |A| \" |B|.\nProof. Suppose f : A N B is an isomorphism. If there exists natural numbers m, n P\nN and isomorphisms a: m\n-\nYN A and b: n\n-\nYN B then m\na 1\nYYN A\nfYN B\nbYN n is an\nisomorphism. One can prove by induction that the sets m and n are isomorphic if and\nonly if m \" n.\n□\n5Canonical means something like \"best choice\", a choice that stands out as the only reasonable one.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.2\nCommutative diagrams\nAt this point it is difficult to precisely define diagrams or commutative diagrams in\ngeneral, but we can give the heuristic idea. 6 Consider the following picture:\nA\nf\n/\nh\n\nB\ng\n\nC\n(2.7)\nWe say this is a diagram of sets if each of A, B, C is a set and each of f, g, h is a function.\nWe say this diagram commutes if g f \" h. In this case we refer to it as a commutative\ntriangle of sets.\nApplication 2.2.1.1. The central dogma of molecular biology is that \"DNA codes for\nRNA codes for protein\". That is, there is a function from DNA triplets to RNA triplets\nand a function from RNA triplets to amino acids. But sometimes we just want to discuss\nthe translation from DNA to amino acids, and this is the composite of the other two.\nThe commutative diagram is a picture of this fact.\n♦♦\nConsider the following picture:\nA\nf\n/\nh\n\nB\ng\n\nC\ni\n/ D\nWe say this is a diagram of sets if each of A, B, C, D is a set and each of f, g, h, i is a\nfunction. We say this diagram commutes if g f \" i h. In this case we refer to it as a\ncommutative square of sets.\nApplication 2.2.1.2. Given a physical system S, there may be two mathematical ap-\nproaches f : S N A and g: S N B that can be applied to it. Either of those results in\na prediction of the same sort, f 1 : A N P and g1 : B N P. For example, in mechanics\nwe can use either Lagrangian approach or the Hamiltonian approach to predict future\nstates. To say that the diagram\nS\n/\n\nA\n\nB\n/ P\ncommutes would say that these approaches give the same result.\n♦♦\nAnd so on. Note that diagram (2.7) is considered to be the same diagram as each of\n6We will define commutative diagrams precisely in Section 4.5.2.\n\n2.3. OLOGS\nthe following:\nA\nf\n/\nh\n\nB\ng\n\nC\nA\nf\n/\nh\nB\ng\n/ C\nB\ng\n\nC\nA\nh\n?\nf\nO\n2.3\nOlogs\nIn this course we will ground the mathematical ideas in applications whenever possible.\nTo that end we introduce ologs, which will serve as a bridge between mathematics and\nvarious conceptual landscapes. The following material is taken from [SK], an introduction\nto ologs.\nD\nan amino acid\nfound in dairy\nis\n&\nA\narginine\n✓\n✓\nhas\n/\nis\no\nis\n\nE\nan electrically-\ncharged side\nchain\nis\n\nX\nan amino acid\nhas\nw\nhas\n'\nhas\n/\nR\na side chain\nN\nan amine group\nC\na carboxylic acid\n(2.8)\n2.3.1\nTypes\nA type is an abstract concept, a distinction the author has made. We represent each\ntype as a box containing a singular indefinite noun phrase. Each of the following four\nboxes is a type:\na man\nan automobile\na pair pa, wq, where w is\na woman and a is an au-\ntomobile\na pair pa, wq where w is\na woman and a is a blue\nautomobile owned by w\n(2.9)\nEach of the four boxes in (2.9) represents a type of thing, a whole class of things,\nand the label on that box is what one should call each example of that class. Thus ⌜a\nman⌝does not represent a single man, but the set of men, each example of which is\ncalled \"a man\". Similarly, the bottom right box represents an abstract type of thing,\n\nCHAPTER 2. THE CATEGORY OF SETS\nwhich probably has more than a million examples, but the label on the box indicates the\ncommon name for each such example.\nTypographical problems emerge when writing a text-box in a line of text, e.g. the\ntext-box a man seems out of place here, and the more in-line text-boxes there are, the\nworse it gets. To remedy this, I will denote types which occur in a line of text with\ncorner-symbols; e.g. I will write ⌜a man⌝instead of a man .\n2.3.1.1\nTypes with compound structures\nMany types have compound structures; i.e. they are composed of smaller units. Exam-\nples include\na man and\na woman\na food portion f and\na child c such that c\nate all of f\na triple pp, a, jq where p is\na paper, a is an author of\np, and j is a journal in\nwhich p was published\n(2.10)\nIt is good practice to declare the variables in a \"compound type\", as I did in the last\ntwo cases of (2.10). In other words, it is preferable to replace the first box above with\nsomething like\na man m and\na woman w\nor\na pair pm, wq\nwhere m is a man\nand w is a woman\nso that the variables pm, wq are clear.\nRules of good practice 2.3.1.2. A type is presented as a text box. The text in that box\nshould\n(i) begin with the word \"a\" or \"an\";\n(ii) refer to a distinction made and recognizable by the olog's author;\n(iii) refer to a distinction for which instances can be documented;\n(iv) declare all variables in a compound structure.\nThe first, second, and third rules ensure that the class of things represented by\neach box appears to the author as a well-defined set. The fourth rule encourages good\n\"readability\" of arrows, as will be discussed next in Section 2.3.2.\nI will not always follow the rules of good practice throughout this document.\nI\nthink of these rules being followed \"in the background\" but that I have \"nicknamed\"\nvarious boxes. So ⌜Steve⌝may stand as a nickname for ⌜a thing classified as Steve⌝\nand ⌜arginine⌝as a nickname for ⌜a molecule of arginine⌝. However, when pressed, one\nshould always be able to rename each type according to the rules of good practice.\n2.3.2\nAspects\nAn aspect of a thing x is a way of viewing it, a particular way in which x can be regarded\nor measured. For example, a woman can be regarded as a person; hence \"being a person\"\nis an aspect of a woman. A molecule has a molecular mass (say in daltons), so \"having\na molecular mass\" is an aspect of a molecule. In other words, by aspect we simply mean\n\n2.3. OLOGS\na function. The domain A of the function f : A N B is the thing we are measuring, and\nthe codomain is the set of possible \"answers\" or results of the measurement.\na woman\nis\n/ a person\n(2.11)\na molecule\nhas as molecular mass (Da) / a positive real number\n(2.12)\nSo for the arrow in (2.11), the domain is the set of women (a set with perhaps 3 billion\nelements); the codomain is the set of persons (a set with perhaps 6 billion elements).\nWe can imagine drawing an arrow from each dot in the \"woman\" set to a unique dot in\nthe \"person\" set, just as in (2.2). No woman points to two different people, nor to zero\npeople -- each woman is exactly one person -- so the rules for a function are satisfied.\nLet us now concentrate briefly on the arrow in (2.12). The domain is the set of molecules,\nthe codomain is the set Ra0 of positive real numbers. We can imagine drawing an arrow\nfrom each dot in the \"molecule\" set to a single dot in the \"positive real number\" set. No\nmolecule points to two different masses, nor can a molecule have no mass: each molecule\nhas exactly one mass. Note however that two different molecules can point to the same\nmass.\n2.3.2.1\nInvalid aspects\nI tried above to clarify what it is that makes an aspect \"valid\", namely that it must be\na \"functional relationship.\" In this subsection I will show two arrows which on their face\nmay appear to be aspects, but which on closer inspection are not functional (and hence\nare not valid as aspects).\nConsider the following two arrows:\na person\nhas / a child\n(2.13*)\na mechanical pencil\nuses / a piece of lead\n(2.14*)\nA person may have no children or may have more than one child, so the first arrow is\ninvalid: it is not a function. Similarly, if we drew an arrow from each mechanical pencil\nto each piece of lead it uses, it would not be a function.\nWarning 2.3.2.2. The author of an olog has a world-view, some fragment of which is\ncaptured in the olog. When person A examines the olog of person B, person A may or\nmay not \"agree with it.\" For example, person B may have the following olog\na marriage\nincludes\n&\nincludes\nx\na man\na woman\nwhich associates to each marriage a man and a woman. Person A may take the position\nthat some marriages involve two men or two women, and thus see B's olog as \"wrong.\"\n\nCHAPTER 2. THE CATEGORY OF SETS\nSuch disputes are not \"problems\" with either A's olog or B's olog, they are discrepancies\nbetween world-views. Hence, throughout this paper, a reader R may see a displayed olog\nand notice a discrepancy between R's world-view and my own, but R should not worry\nthat this is a problem. This is not to say that ologs need not follow rules, but instead\nthat the rules are enforced to ensure that an olog is structurally sound, rather than that\nit \"correctly reflects reality,\" whatever that may mean.\nConsider the aspect ⌜an object⌝\nhas\nYYYYN ⌜a weight⌝. At some point in history, this\nwould have been considered a valid function.\nNow we know that the same object\nwould have a different weight on the moon than it has on earth.\nThus as world-\nviews change, we often need to add more information to our olog. Even the validity\nof ⌜an object on earth⌝\nhas\nYYYYN ⌜a weight⌝is questionable. However to build a model\nwe need to choose a level of granularity and try to stay within it, or the whole model\nevaporates into the nothingness of truth!\nRemark 2.3.2.3. In keeping with Warning 2.3.2.2, the arrows (2.13*) and (2.14*) may\nnot be wrong but simply reflect that the author has a strange world-view or a strange\nvocabulary. Maybe the author believes that every mechanical pencil uses exactly one\npiece of lead. If this is so, then ⌜a mechanical pencil⌝\nuses\nYYN ⌜a piece of lead⌝is indeed\na valid aspect! Similarly, suppose the author meant to say that each person was once\na child, or that a person has an inner child. Since every person has one and only one\ninner child (according to the author), the map ⌜a person⌝has as inner child\nYYYYYYYYYYYN ⌜a child⌝is a\nvalid aspect. We cannot fault the olog if the author has a view, but note that we have\nchanged the name of the label to make his or her intention more explicit.\n2.3.2.4\nReading aspects and paths as English phrases\nEach arrow (aspect) X\nfYN Y can be read by first reading the label on its source box\n(domain of definition) X, then the label on the arrow f, and finally the label on its\ntarget box (set of values) Y . For example, the arrow\na book\nhas as first author\n/ a person\n(2.15)\nis read \"a book has as first author a person\".\nRemark 2.3.2.5. Note that the map in (2.15) is a valid aspect, but that a similarly\nbenign-looking map ⌜a book⌝\nhas as author\nYYYYYYYYN ⌜a person⌝would not be valid, because it\nis not functional. The authors of an olog must be vigilant about this type of mistake\nbecause it is easy to miss and it can corrupt the olog.\nSometimes the label on an arrow can be shortened or dropped altogether if it is\nobvious from context. We will discuss this more in Section 2.3.3 but here is a common\n\n2.3. OLOGS\nexample from the way I write ologs.\nA\na pair px, yq where\nx and y are integers\nx\nx\ny\n&\nB\nan integer\nB\nan integer\n(2.16)\nNeither arrow is readable by the protocol given above (e.g. \"a pair px, yq where x and\ny are integers x an integer\" is not an English sentence), and yet it is obvious what each\nmap means. For example, given p8, 11q in A, arrow x would yield 8 and arrow y would\nyield 11. The label x can be thought of as a nickname for the full name \"yields, via the\nvalue of x,\" and similarly for y. I do not generally use the full name for fear that the\nolog would become cluttered with text.\nOne can also read paths through an olog by inserting the word \"which\" after each\nintermediate box. 7 For example the following olog has two paths of length 3 (counting\narrows in a chain):\na child\nis\n/ a person\nhas as parents\n/\nhas, as birthday\n!\na pair pw, mq\nwhere w is a\nwoman and m\nis a man\nw\n/ a woman\na date\nincludes / a year\n(2.17)\nThe top path is read \"a child is a person, who has as parents a pair pw, mq where w is a\nwoman and m is a man, which yields, via the value of w, a woman.\" The reader should\nread and understand the content of the bottom path, which associates to every child a\nyear.\n2.3.2.6\nConverting non-functional relationships to aspects\nThere are many relationships that are not functional, and these cannot be considered\naspects. Often the word \"has\" indicates a relationship -- sometimes it is functional as in\n⌜a person⌝\nhas\nYYYN ⌜a stomach⌝, and sometimes it is not, as in ⌜a father⌝\nhas\nYYN ⌜a child⌝.\nObviously, a father may have more than one child. This one is easily fixed by realizing\nthat the arrow should go the other way: there is a function ⌜a child⌝has\nYYN ⌜a father⌝.\nWhat about ⌜a person⌝\nowns\nYYYN ⌜a car⌝. Again, a person may own no cars or more\nthan one car, but this time a car can be owned by more than one person too. A quick fix\nwould be to replace it by ⌜a person⌝owns\nYYYN ⌜a set of cars⌝. This is ok, but the relationship\nbetween ⌜a car⌝and ⌜a set of cars⌝then becomes an issue to deal with later. There is\n7If the intended elements of an intermediate box are humans, it is polite to use \"who\" rather than\n\"which\", and other such conventions may be upheld if one so desires.\n\nCHAPTER 2. THE CATEGORY OF SETS\nanother way to indicate such \"non-functional\" relationships. In this case it would look\nlike this:\na pair pp, cq where\np is a person, c is a\ncar, and p owns c.\np\n~\nc\n\na person\na car\nThis setup will ensure that everything is properly organized. In general, relationships\ncan involve more than two types, and the general situation looks like this\nR\n{\n\nA1\nA2\n\nAn\nFor example,\nR\na sequence pp, a, jq where p\nis a paper, a is an author\nof p, and j is a journal in\nwhich p was published\np\n}\na\n\nj\n!\nA1\na paper\nA2\nan author\nA3\na journal\nExercise 2.3.2.7. On page 25 we indicate a so-called invalid aspect, namely\na person\nhas / a child\n(2.13*)\nCreate a (valid) olog that captures the parent-child relationship; your olog should still\nhave boxes ⌜a person⌝and ⌜a child⌝but may have an additional box.\n♦\nRules of good practice 2.3.2.8. An aspect is presented as a labeled arrow, pointing from\na source box to a target box. The arrow text should\n\n2.3. OLOGS\n(i) begin with a verb;\n(ii) yield an English sentence, when the source-box text followed by the arrow text\nfollowed by the target-box text is read; and\n(iii) refer to a functional relationship: each instance of the source type should give rise\nto a specific instance of the target type.\n2.3.3\nFacts\nIn this section I will discuss facts, which are simply \"path equivalences\" in an olog. It is\nthe notion of path equivalences that make category theory so powerful.\nA path in an olog is a head-to-tail sequence of arrows. That is, any path starts at\nsome box B0, then follows an arrow emanating from B0 (moving in the appropriate\ndirection), at which point it lands at another box B1, then follows any arrow emanating\nfrom B1, etc, eventually landing at a box Bn and stopping there. The number of arrows\nis the length of the path. So a path of length 1 is just an arrow, and a path of length 0\nis just a box. We call B0 the source and Bn the target of the path.\nGiven an olog, the author may want to declare that two paths are equivalent. For\nexample consider the two paths from A to C in the olog\nA\na person\nhas as parents /\nhas as mother\n&\nB\na pair pw, mq\nwhere w is a\nwoman and\nm is a man\n✓\nyields as w\n\nC\na woman\n(2.18)\nWe know as English speakers that a woman parent is called a mother, so these two paths\nA N C should be equivalent. A more mathematical way to say this is that the triangle in\nOlog (2.18) commutes. That is, path equivalences are simply commutative diagrams as\nin Section 2.2. In the example above we concisely say \"a woman parent is equivalent to\na mother.\" We declare this by defining the diagonal map in (2.18) to be the composition\nof the horizontal map and the vertical map.\nI generally prefer to indicate a commutative diagram by drawing a check-mark, ✓,\nin the region bounded by the two paths, as in Olog (2.18). Sometimes, however, one\ncannot do this unambiguously on the 2-dimensional page. In such a case I will indicate\nthe commutative diagrams (fact) by writing an equation. For example to say that the\ndiagram\nA\nf\n/\nh\n\nB\ng\n\nC\ni\n/ D\ncommutes, we could either draw a checkmark inside the square or write the equation\n\nCHAPTER 2. THE CATEGORY OF SETS\nA f g » A h i above it. 8 Either way, it means that \"f then g\" is equivalent to \"h then\ni\".\nHere is another, more scientific example:\na DNA sequence\nis transcribed to /\ncodes for\n*\nan RNA sequence\n✓\nis translated to\n\na protein\nNote how this diagram gives us the established terminology for the various ways in which\nDNA, RNA, and protein are related in this context.\nExercise 2.3.3.1. Create an olog for human nuclear biological families that includes the\nconcept of person, man, woman, parent, father, mother, and child. Make sure to label\nall the arrows, and make sure each arrow indicates a valid aspect in the sense of Section\n2.3.2.1. Indicate with check-marks (✓) the diagrams that are intended to commute. If the\n2-dimensionality of the page prevents a check-mark from being unambiguous, indicate\nthe intended commutativity with an equation.\n♦\nExample 2.3.3.2 (Non-commuting diagram). In my conception of the world, the following\ndiagram does not commute:\na person\nhas as father /\nlives in\n#\na man\nlives in\n\na city\n(2.19)\nThe non-commutativity of Diagram (2.19) does not imply that, in my conception, no\nperson lives in the same city as his or her father. Rather it implies that, in my conception,\nit is not the case that every person lives in the same city as his or her father.\nExercise 2.3.3.3. Create an olog about a scientific subject, preferably one you think\nabout often. The olog should have at least five boxes, five arrows, and one commutative\ndiagram.\n♦\n2.3.3.4\nA formula for writing facts as English\nEvery fact consists of two paths, say P and Q, that are to be declared equivalent. The\npaths P and Q will necessarily have the same source, say s, and target, say t, but their\n8We defined function composition on page 2.1.2, but here we're using a different notation. There we\nwould have said g f \" i h, which is in the backwards-seeming classical order. Category theorists\nand others often prefer the diagrammatic order for writing compositions, which is f; g \" h; i. For ologs,\nwe follow the latter because it makes for better English sentences, and for the same reason we add the\nsource object to the equation, writing Afg » Ahi.\n\n2.3. OLOGS\nlengths may be different, say m and n respectively. 9 We draw these paths as\nP :\na0\"s\n‚\nf1\n/ a1‚\nf2 / a2‚\nf3 /\nfm 1/ am 1\n‚\nfm / am\"t\n‚\n(2.20)\nQ :\nb0\"s\n‚\ng1\n/ b1‚\ng2\n/ b2‚\ng3 /\ngn 1 / bn 1\n‚\ngn / bn\"t\n‚\nEvery part lof an olog (i.e. every box and every arrow) has an associated English phrase,\nwhich we write as \"l\". Using a dummy variable x we can convert a fact into English too.\nThe following general formula is a bit difficult to understand, see Example 2.3.3.5, but\nhere goes. The fact P » Q from (2.20) can be Englishified as follows:\nGiven x, \"s\", consider the following. We know that x is \"s\",\n(2.21)\nwhich \"f1\" \"a1\", which \"f2\" \"a2\", which . . . \"fm 1\" \"am 1\", which \"fm\" \"t\"\nthat we'll call Ppxq.\nWe also know that x is \"s\",\nwhich \"g1\" \"b1\", which \"g2\" \"b2\", which . . . \"gn 1\" \"bn 1\", which \"gn\" \"t\"\nthat we'll call Qpxq.\nFact: whenever x is \"s\", we will have Ppxq \" Qpxq.\nExample 2.3.3.5. Consider the olog\nA\na person\nhas\n/\nlives in\n'\nB\nan address\n✓\nis in\n\nC\na city\n(2.22)\nTo put the fact that Diagram 2.22 commutes into English, we first Englishify the two\npaths: F=\"a person has an address which is in a city\" and G=\"a person lives in a city\".\nThe source of both is s=\"a person\" and the target of both is t=\"a city\". write:\nGiven x, a person, consider the following. We know that x is a person,\nwhich has an address, which is in a city\nthat we'll call Ppxq.\nWe also know that x is a person,\nwhich lives in a city\nthat we'll call Qpxq.\nFact: whenever x is a person, we will have Ppxq \" Qpxq.\n9If the source equals the target, s \" t, then it is possible to have m \" 0 or n \" 0, and the ideas below\nstill make sense.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExercise 2.3.3.6. This olog was taken from [Sp1].\nN\na phone number\nhas\n/\nC\nan area code\n✓\ncorresponds to\n\nOLP\nan operational land-\nline phone\nis assigned\nis\n/\nP\na physical phone\nis currently\nlocated in\n/\nR\na region\n(2.23)\nIt says that a landline phone is physically located in the region that its phone number\nis assigned. Translate this fact into English using the formula from 2.21.\n♦\nExercise 2.3.3.7. In the above olog (2.23), suppose that the box ⌜an operational landline\nphone⌝is replaced with the box ⌜an operational mobile phone⌝. Would the diagram still\ncommute?\n♦\n2.3.3.8\nImages\nIn this section we discuss a specific kind of fact, generated by any aspect. Recall that\nevery function has an image, meaning the subset of elements in the codomain that are\n\"hit\" by the function. For example the function fpxq \" 2 x: Z N Z has as image the\nset of all even numbers.\nSimilarly the set of mothers arises as is the image of the \"has as mother\" function,\nas shown below\nP\na person\nhas\n$\nf : P NP\nhas as mother\n/\nP\na person\nM\"impfq\na mother\nis\n:\n✓\nExercise 2.3.3.9. For each of the following types, write down a function for which it is\nthe image, or say \"not clearly an image type\"\na.) ⌜a book⌝\nb.) ⌜a material that has been fabricated by a process of type T⌝\nc.) ⌜a bicycle owner⌝\nd.) ⌜a child⌝\ne.) ⌜a used book⌝\nf.) ⌜an inhabited residence⌝\n♦\n2.4\nProducts and coproducts\nIn this section we introduce two concepts that are likely to be familiar, although perhaps\nnot by their category-theoretic names, product and coproduct. Each is an example of a\n\n2.4. PRODUCTS AND COPRODUCTS\nlarge class of ideas that exist far beyond the realm of sets.\n2.4.1\nProducts\nDefinition 2.4.1.1. Let X and Y be sets. The product of X and Y , denoted X ˆ Y , is\ndefined as the set of ordered pairs px, yq where x P X and y P Y . Symbolically,\nX ˆ Y \" tpx, yq | x P X, y P Y u.\nThere are two natural projection functions π1 : X ˆ Y N X and π2 : X ˆ Y N Y .\nX ˆ Y\nπ2\n\nπ1\n\nX\nY\nExample 2.4.1.2. [Grid of dots]\nLet X \" t1, 2, 3, 4, 5, 6u and Y \" t♣, ♦, ♥, ♠u. Then we can draw X ˆ Y as a 6-by-4\ngrid of dots, and the projections as projections\nX ˆ Y\np1,♣q\n‚\np2,♣q\n‚\np3,♣q\n‚\np4,♣q\n‚\np5,♣q\n‚\np6,♣q\n‚\np1,♦q\n‚\np2,♦q\n‚\np3,♦q\n‚\np4,♦q\n‚\np5,♦q\n‚\np6,♦q\n‚\np1,♥q\n‚\np2,♥q\n‚\np3,♥q\n‚\np4,♥q\n‚\np5,♥q\n‚\np6,♥q\n‚\np1,♠q\n‚\np2,♠q\n‚\np3,♠q\n‚\np4,♠q\n‚\np5,♠q\n‚\np6,♠q\n‚\nπ2\n/\nY\n♣‚\n♦‚\n♥‚\n♠‚\n(2.24)\nπ1\n\n1‚\n2‚\n3‚\n4‚\n5‚\n6‚\nX\nApplication 2.4.1.3. A traditional (Mendelian) way to predict the genotype of offspring\nbased on the genotype of its parents is by the use of Punnett squares. If F is the set of\npossible genotypes for the female parent and M is the set of possible genotypes of the\nmale parent, then F ˆ M is drawn as a square, called a Punnett square, in which every\ncombination is drawn.\n♦♦\nExercise 2.4.1.4. How many elements does the set ta, b, c, du ˆ t1, 2, 3u have?\n♦\n\nCHAPTER 2. THE CATEGORY OF SETS\nApplication 2.4.1.5. Suppose we are conducting experiments about the mechanical prop-\nerties of materials, as in Application 2.1.2.1. For each material sample we will produce\nmultiple data points in the set ⌜extension⌝ˆ ⌜force⌝- R ˆ R.\n♦♦\nRemark 2.4.1.6. It is possible to take the product of more than two sets as well. For\nexample, if A, B, and C are sets then A ˆ B ˆ C is the set of triples,\nA ˆ B ˆ C :\" tpa, b, cq | a P A, b P B, c P Cu.\nThis kind of generality is useful in understanding multiple dimensions, e.g. what\nphysicists mean by 10-dimensional space. It comes under the heading of limits, which\nwe will see in Section 4.5.3.\nExample 2.4.1.7. Let R be the set of real numbers. By R2 we mean R ˆ R (though see\nExercise 2.7.2.6). Similarly, for any n P N, we define Rn to be the product of n copies of\nR.\nAccording to [Pen], Aristotle seems to have conceived of space as something like\nS :\" R3 and of time as something like T :\" R.\nSpacetime, had he conceived of it,\nwould probably have been S ˆ T - R4. He of course did not have access to this kind of\nabstraction, which was probably due to Descartes.\nExercise 2.4.1.8. Let Z denote the set of integers, and let `: Z ˆ Z N Z denote the\naddition function and : Z ˆ Z N Z denote the multiplication function. Which of the\nfollowing diagrams commute?\na.)\nZ ˆ Z ˆ Z\npa,b,cqÞNpa b,a cq\n/\npa,b,cqÞNpa`b,cq\n\nZ ˆ Z\npx,yqÞNx`y\n\nZ ˆ Z\npx,yqÞNxy\n/ Z\nb.)\nZ\nxÞNpx,0q /\nidZ\n'\nZ ˆ Z\npa,bqÞNa b\n\nZ\nc.)\nZ\nxÞNpx,1q /\nidZ\n'\nZ ˆ Z\npa,bqÞNa b\n\nZ\n♦\n2.4.1.9\nUniversal property for products\nLemma 2.4.1.10 (Universal property for product). Let X and Y be sets. For any set\nA and functions f : A N X and g: A N Y , there exists a unique function A N X ˆ Y\n\n2.4. PRODUCTS AND COPRODUCTS\nsuch that the following diagram commutes 10\nX ˆ Y\nπ1\n\nπ2\n\nX\n✓\nY\n✓\nA\n@f\n\\\n@g\nB\nD!\nO\n(2.25)\nWe might write the unique function as\nxf, gy: A N X ˆ Y.\nProof. Suppose given f, g as above. To provide a function l: A N X ˆ Y is equivalent\nto providing an element lpaq P X ˆ Y for each a P A. We need such a function for which\nπ1 l\" f and π2 l\" g. An element of X ˆ Y is an ordered pair px, yq, and we can\nuse lpaq \" px, yq if and only if x \" π1px, yq \" fpaq and y \" π2px, yq \" gpaq. So it is\nnecessary and sufficient to define\nxf, gypaq :\" pfpaq, gpaqq\nfor all a P A.\n□\nExample 2.4.1.11 (Grid of dots, continued). We need to see the universal property of\nproducts as completely intuitive. Recall that if X and Y are sets, say of cardinalities\n|X| \" m and |Y | \" n respectively, then X ˆ Y is an m ˆ n grid of dots, and it comes\nwith two canonical projections X\nπ1\nÐY X ˆ Y\nπ2\nYN Y . These allow us to extract from\nevery grid element z P X ˆ Y its column π1pzq P X and its row π2pzq P Y .\nSuppose that each person in a classroom picks an element of X and an element of\nY . Thus we have functions f : C N X and g: C N Y . But isn't picking a column and a\nrow the same thing as picking an element in the grid? The two functions f and g induce\na unique function C N X ˆ Y . And how does this function C N X ˆ Y compare with\nthe original functions f and g? The commutative diagram (2.25) sums up the obvious\nconnection.\nExample 2.4.1.12. Let R be the set of real numbers. The origin in R is an element of R.\nAs you showed in Exercise 2.1.2.14, we can view this (or any) element of R as a function\nz : t,u N R, where t,u is any set with one element. Our function z \"picks out the\norigin\". Thus we can draw functions\nt,u\nz\n\nz\n\nR\nR\n10The symbol @ is read \"for all\"; the symbol D is read \"there exists\", and the symbol D! is read \"there\nexists a unique\". So this diagram is intended to express the idea that for any functions f : A N X and\ng : A N Y , there exists a unique function A N X ˆ Y for which the two triangles commute.\n\nCHAPTER 2. THE CATEGORY OF SETS\nThe universal property for products guarantees a function t,u N R ˆ R, which will be\nthe origin in R2.\nRemark 2.4.1.13. Given sets X, Y, and A, and functions f : A N X and g: A N Y , there\nis a unique function A N X ˆ Y that commutes with f and g. We call it the induced\nfunction A N X ˆ Y , meaning the one that arises in light of f and g.\nExercise 2.4.1.14. For every set A there is some nice relationship between the following\nthree sets:\nHomSetpA, Xq,\nHomSetpA, Y q,\nand\nHomSetpA, X ˆ Y q.\nWhat is it?\nHint: Do not be alarmed: this problem is a bit \"recursive\" in that you'll use products\nin your formula.\n♦\nExercise 2.4.1.15.\na.) Let X and Y be sets. Construct the \"swap map\" s: X ˆ Y N Y ˆ X using only\nthe universal property for products. If π1 : X ˆ Y N X and π2 : X ˆ Y N Y are the\nprojection functions, write s in terms of the symbols \"π1\", \"π2\", \"p , q\", and \" \".\nb.) Can you prove that s is a isomorphism using only the universal property for product?\n♦\nExample 2.4.1.16. Suppose given sets X, X1, Y, Y 1 and functions m: X N X1 and n: Y N\nY 1. We can use the universal property of products to construct a function s: X ˆ Y N\nX1 ˆ Y 1. Here's how.\nThe universal property (Lemma 2.4.1.10) says that to get a function from any set A\nto X1 ˆ Y 1, we need two functions, namely some f : A N X1 and some g: A N Y 1. Here\nA \" X ˆ Y .\nWhat we have readily available are the two projections π1 : X ˆY N X and π2 : X ˆ\nY N Y . But we also have m: X N X1 and n: Y N Y 1. Composing, we set f :\" m π1\nand g :\" n π2.\nX1 ˆ Y 1\nπ1\nz\nπ1\n#\nX1\nY 1\nX\nm\nO\nY\nn\nO\nX ˆ Y\nπ1\nd\nπ2\n:\nO\nThe dotted arrow is often called the product of m: X N X1 and n: Y N Y 1 and is\ndenoted simply by\nm ˆ n: X ˆ Y N X1 ˆ Y 1.\n2.4.1.17\nOlogging products\nGiven two objects c, d in an olog, there is a canonical label \"cˆd\" for their product cˆd,\nwritten in terms of the labels \"c\" and \"d\". Namely,\n\"c ˆ d\" :\" a pair px, yq where x is \"c\" and y is \"d\".\n\n2.4. PRODUCTS AND COPRODUCTS\nThe projections c Ð c ˆ d N d can be labeled \"yields, as x,\" and \"yields, as y,\" respec-\ntively.\nSuppose that e is another object and p: e N c and q: e N d are two arrows. By\nthe universal property of products (Lemma 2.4.1.10), p and q induce a unique arrow\ne N c ˆ d making the evident diagrams commute. This arrow can be labeled\nyields, insofar as it \"p\" \"c\" and \"q\" \"d\",\nExample 2.4.1.18. Every car owner owns at least one car, but there is no obvious function\n⌜a car owner⌝N ⌜a car⌝because he or she may own more than one. One good choice\nwould be the car that the person drives most often, which we'll call his or her primary\ncar. Also, given a person and a car, an economist could ask how much utility the person\nwould get out of the car. From all this we can put together the following olog involving\nproducts:\nO\na car owner\nis\n\nowns,\nas\nprimary,\n#\nyields, insofar\nas it is a person\nand owns, as\nprimary, a car, /\n✓\nP ˆC\na\npair\npx, yq\nwhere\nx\nis\na\nperson and y is\na car\nyields, as x,\nv\nyields, as y,\n\nhas as associ-\nated utility\n/\nV\na dollar value\nP\na person\nC\na car\n2.4.2\nCoproducts\nDefinition 2.4.2.1. Let X and Y be sets. The coproduct of X and Y , denoted X \\ Y ,\nis defined as the \"disjoint union\" of X and Y , i.e. the set for which an element is either\nan element of X or an element of Y . If something is an element of both X and Y then\nwe include both copies, and distinguish between them, in X \\ Y . See Example 2.4.2.2\nThere are two natural inclusion functions i1 : X N X \\ Y and i2 : Y N X \\ Y .\nX\ni1\n\nY\ni2\n\nX \\ Y\nExample 2.4.2.2. The coproduct of X :\" ta, b, c, du and Y :\" t1, 2, 3u is\nX \\ Y - ta, b, c, d, 1, 2, 3u.\nThe coproduct of X and itself is\nX \\ X - ti1a, i1b, i1c, i1d, i2a, i2b, i2c, i2du\nThe names of the elements in X \\ Y are not so important. What's important are the\ninclusion maps i1, i2, which ensure that we know where each element of X \\ Y came\nfrom.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExample 2.4.2.3 (Airplane seats).\nX\nan economy-\nclass seat in\nan airplane\nis\n\nY\na first-class\nseat in an\nairplane\nis\n\nX\\Y\na seat in an\nairplane\n(2.26)\nExercise 2.4.2.4. Would you say that ⌜a phone⌝is the coproduct of ⌜a cellphone⌝and\n⌜a landline phone⌝?\n♦\nExample 2.4.2.5 (Disjoint union of dots).\nX \\ Y\n♣‚\n1‚\n2‚\n3‚\n4‚\n5‚\n6‚\n♦‚\n♥‚\n♠‚\ni2\no\nY\n♣‚\n♦‚\n♥‚\n♠‚\n(2.27)\ni1\nO\n1‚\n2‚\n3‚\n4‚\n5‚\n6‚\nX\n2.4.2.6\nUniversal property for coproducts\nLemma 2.4.2.7 (Universal property for coproduct). Let X and Y be sets. For any set\nA and functions f : X N A and g: Y N A, there exists a unique function X \\ Y N A\n\n2.4. PRODUCTS AND COPRODUCTS\nsuch that the following diagram commutes\nA\nX\n@f\nB\ni1\n\nY\n@g\n\\\ni2\n\nX \\ Y\nD!\nO\nWe might write the unique function as 11\n\"\nf\ng : X \\ Y N A.\nProof. Suppose given f, g as above. To provide a function l: X \\ Y N A is equivalent\nto providing an element fpmq P A is for each m P X \\ Y . We need such a function such\nthat l i1 \" f and l i2 \" g. But each element m P X \\ Y is either of the form i1x or\ni2y, and cannot be of both forms. So we assign\n\"\nf\ng pmq \"\n#\nfpxq\nif m \" i1x,\ngpyq\nif m \" i2y.\nThis assignment is necessary and sufficient to make all relevant diagrams commute.\n□\nExample 2.4.2.8 (Airplane seats, continued). The universal property of coproducts says\nthe following. Any time we have a function X N A and a function Y N A, we get a\nunique function X \\ Y N A. For example, every economy class seat in an airplane and\nevery first class seat in an airplane is actually in a particular airplane. Every economy\nclass seat has a price, as does every first class seat.\nA\na dollar figure\nX\nan economy-\nclass seat in\nan airplane\nhas as price\nis\n/\nis in\n%\nX\\Y\na seat in an\nairplane\nD!\n\nD!\nO\n✓\n✓\n✓\n✓\nY\na first-class\nseat in an\nairplane\nis\no\nhas as price\ne\nis in\ny\nB\nan airplane\n(2.28)\nThe universal property of coproducts formalizes the following intuitively obvious fact:\n11We are about to use a two-line symbol, which is a bit unusual. In what follows a certain function\nX \\ Y N A is being denoted by the symbol\n\"\nf\ng .\n\nCHAPTER 2. THE CATEGORY OF SETS\nIf we know how economy class seats are priced and we know how first class\nseats are priced, and if we know that every seat is either economy class or\nfirst class, then we automatically know how all seats are priced.\nTo say it another way (and using the other induced map):\nIf we keep track of which airplane every economy class seat is in and we\nkeep track of which airplane every first class seat is in, and if we know that\nevery seat is either economy class or first class, then we require no additional\ntracking for any airplane seat whatsoever.\nApplication 2.4.2.9 (Piecewise defined curves). In science, curves are often defined or\nconsidered piecewise. For example in testing the mechanical properties of a material,\nwe might be interested in various regions of deformation, such as elastic, plastic, or\npost-fracture. These are three intervals on which the material displays different kinds of\nproperties.\nFor real numbers a a b P R, let ra, bs :\" tx P R | a d x d bu denote the closed\ninterval. Given a function ra, bs N R and a function rc, ds N R, the universal property\nof coproducts implies that they extend uniquely to a function ra, bs \\ rc, ds N R, which\nwill appear as a piecewise defined curve.\nOften we are given a curve on ra, bs and another on rb, cs, where the two curves agree\nat the point b. This situation is described by pushouts, which are mild generalizations\nof coproducts; see Section 2.6.2.\n♦♦\nExercise 2.4.2.10. Write the universal property for coproduct in terms of a relationship\nbetween the following three sets:\nHomSetpX, Aq,\nHomSetpY, Aq,\nand\nHomSetpX \\ Y, Aq.\n♦\nExample 2.4.2.11. In the following olog the types A and B are disjoint, so the coproduct\nC \" A \\ B is just the union.\nA\na person\nis\n/\nC\"A\\B\na person or a cat\nB\na cat\nis\no\nExample 2.4.2.12. In the following olog, A and B are not disjoint, so care must be taken\nto differentiate common elements.\nA\nan animal\nthat can fly\nlabeled \"A\" is /\nC\"A\\B\nan animal that can fly\n(labeled \"A\") or an\nanimal that can swim\n(labeled \"B\")\nB\nan animal that\ncan swim\nlabeled \"B\" is\no\nSince ducks can both swim and fly, each duck is found twice in C, once labeled as a\nflyer and once labeled as a swimmer. The types A and B are kept disjoint in C, which\njustifies the name \"disjoint union.\"\n\n2.5. FINITE LIMITS IN SET\nExercise 2.4.2.13. Understand Example 2.4.2.12 and see if a similar idea would make\nsense for particles and waves. Make an olog, and choose your wording in accordance with\nRules 2.3.1.2. How do photons, which exhibit properties of both waves and particles, fit\ninto the coproduct in your olog?\n♦\nExercise 2.4.2.14. Following the section above, \"Ologging products\" page 36, come up\nwith a naming system for coproducts, the inclusions, and the universal maps. Try it out\nby making an olog (involving coproducts) discussing the idea that both a .wav file and\na .mp3 file can be played on a modern computer. Be careful that your arrows are valid\nin the sense of Section 2.3.2.1.\n♦\n2.5\nFinite limits in Set\nIn this section we discuss what are called limits of variously-shaped diagrams of sets.\nWe will make all this much more precise when we discuss limits in arbitrary categories\nin Section 4.5.3.\n2.5.1\nPullbacks\nDefinition 2.5.1.1 (Pullback). Suppose given the diagram of sets and functions below.\nY\ng\n\nX\nf\n/ Z\n(2.29)\nIts fiber product is the set\nX ˆZ Y :\" tpx, w, yq | fpxq \" w \" gpyqu.\nThere are obvious projections π1 : X ˆZ Y N X and π2 : X ˆZ Y N Y (e.g. π2px, w, yq \"\ny). Note that if W \" X ˆZ Y then the diagram\nW\n⌟\nπ2\n/\nπ1\n\nY\ng\n\nX\nf\n/ Z\n(2.30)\ncommutes. Given the setup of Diagram 2.29 we define the pullback of X and Y over Z\nto be any set W for which we have an isomorphism W\n-\nYN X ˆZ Y . The corner symbol\n⌟in Diagram 2.30 indicates that W is the pullback.\nExercise 2.5.1.2. Let X, Y, Z be as drawn and f : X N Z and g: Y N Z the indicated\nfunctions.\n\nCHAPTER 2. THE CATEGORY OF SETS\nWhat is the pullback of the diagram X\nf\nYYYN Z\ng\nÐYYY Y ?\n♦\nExercise 2.5.1.3.\na.) Draw a set X with five elements and a set Y with three elements.\nColor each\nelement of X and each element of Y either red, blue, or yellow, 12 and do so in a\n\"random-looking\" way. Considering your coloring of X as a function X N C, where\nC \" tred, blue, yellowu, and similarly obtaining a function Y N C, draw the fiber\nproduct X ˆC Y . Make sure it is colored appropriately.\nb.) The universal property for products guarantees a function X ˆC Y N X ˆ Y , which\nI can tell you will be an injection. This means that the drawing you made of the\nfiber product can be imbedded into the 5 ˆ 3 grid; please draw the grid and indicate\nthis subset.\n♦\nRemark 2.5.1.4. Some may prefer to denote this fiber product by f ˆZ g rather than\nX ˆZ Y . The former is mathematically better notation, but human-readability is often\nenhanced by the latter, which is also more common in the literature. We use whichever\nis more convenient.\nExercise 2.5.1.5.\na.) Suppose that Y \" H; what can you say about X ˆZ Y ?\nb.) Suppose now that Y is any set but that Z has exactly one element; what can you\nsay about X ˆZ Y ?\n♦\nExercise 2.5.1.6. Let S \" R3, T \" R, and think of them as (Aristotelian) space and time,\nwith the origin in S ˆ T given by the center of mass of MIT at the time of its founding.\nLet Y \" S ˆT and let g1 : Y N S be one projection and g2 : Y N T the other projection.\nLet X \" t,u be a set with one element and let f1 : X N S and f2 : X N T be given by\nthe origin in both cases.\na.) What are the fiber products W1 and W2:\nW1\n/\n\n⌟\nY\ng1\n\nX\nf1\n/ S\nW2\n/\n\n⌟\nY\ng2\n\nX\nf2\n/ T\n12You can use shadings rather than coloring, if coloring would be annoying.\n\n2.5. FINITE LIMITS IN SET\nb.) Interpret these sets in terms of the center of mass of MIT at the time of its founding.\n♦\n2.5.1.7\nUsing pullbacks to define new ideas from old\nIn this section we will see that the fiber product of a diagram can serve to define a new\nconcept. For example, in (2.33) we define what it means for a cellphone to have a bad\nbattery, in terms of the length of time for which it remains charged. By being explicit,\nwe reduce the chance of misunderstandings between different groups of people. This can\nbe useful in situations like audits and those in which one is trying to reuse or understand\ndata gathered by others.\nExample 2.5.1.8. Consider the following two ologs. The one on the right is the pullback\nof the one on the left.\nC\na loyal\ncustomer\nis\n\nB\na wealthy\ncustomer\nis\n/\nD\na customer\nA\"BˆDC\na customer\nthat is wealthy\nand loyal\nis\n\nis\n/\nC\na loyal\ncustomer\nis\n\nB\na wealthy\ncustomer\nis\n/\nD\na customer\n(2.31)\nCheck from Definition 2.5.1.1 that the label, \"a customer that is wealthy and loyal\", is\nfair and straightforward as a label for the fiber product A \" B ˆD C, given the labels\non B, C, and D.\nRemark 2.5.1.9. Note that in Diagram (2.31) the top-left box could have been (non-\ncanonically named) ⌜a good customer⌝. If it was taken to be the fiber product, then the\nauthor would be effectively defining a good customer to be one that is wealthy and loyal.\nExercise 2.5.1.10. For each of the following, an author has proposed that the diagram\non the right is a pullback. Do you think their labels are appropriate or misleading; that\nis, is the label on the upper-left box reasonable given the rest of the olog, or is it suspect\nin some way?\na.)\nC\nblue\nis\n\nB\na person\nhas as favorite\ncolor\n/\nD\na color\nA\"BˆDC\na person whose\nfavorite color is blue\nis\n\nhas as favorite\ncolor\n/\nC\nblue\nis\n\nB\na person\nhas as favorite\ncolor\n/\nD\na color\n\nCHAPTER 2. THE CATEGORY OF SETS\nb.)\nC\na woman\nis\n\nB\na dog\nhas as owner\n/\nD\na person\nA\"BˆDC\na dog whose owner\nis a woman\nis\n\nhas as owner\n/\nC\na woman\nis\n\nB\na dog\nhas as owner\n/\nD\na person\nc.)\nC\na piece of\nfurniture\nhas\n\nB\na space in\nour house\nhas\n/\nD\na width\nA\"BˆDC\na good fit\ns\n\nf\n/\nC\na piece of\nfurniture\nhas\n\nB\na space in\nour house\nhas\n/\nD\na width\n♦\nExercise 2.5.1.11.\na.) Consider your olog from Exercise 2.3.3.1. Are any of the commutative squares there\nactually pullback squares?\nb.) Now use ologs with products and pullbacks to define what a brother is and what a\nsister is (again in a human biological nuclear family), in terms of types such as ⌜an\noffspring of mating pair pa, bq⌝, ⌜a person⌝, ⌜a male person⌝, ⌜a female person⌝, and\nso on.\n♦\nDefinition 2.5.1.12 (Preimage). Let f : X N Y be a function and y P Y an element.\nThe preimage of y under f, denoted f 1pyq, is the subset f 1pyq :\" tx P X | fpxq \" yu.\nIf Y 1 D Y is any subset, the preimage of Y 1 under f, denoted f 1pY 1q, is the subset\nf 1pY 1q \" tx P X | fpxq P Y 1u.\nExercise 2.5.1.13. Let f : X N Y be a function and y P Y an element. Draw a pullback\ndiagram in which the fiber product is isomorphic to the preimage f 1pyq.\n♦\nLemma 2.5.1.14 (Universal property for pullback). Suppose given the diagram of sets\nand functions as below.\nY\nu\n\nX\nt\n/ Z\n\n2.5. FINITE LIMITS IN SET\nFor any set A and commutative solid arrow diagram as below (i.e. functions f : A N X\nand g: A N Y such that t f \" u g),\nX ˆZ Y\nπ1\n\nπ2\n\nA\nD!\nO\n@f\nz\n@g\n$\nX\nt\n$\nY\nu\nz\nZ\n(2.32)\nthere exists a unique arrow xf, fyZ : A N X ˆZ Y making everything commute, i.e.\nf \" π1 xf, fyZ\nand\ng \" π2 xf, fyZ.\nExercise 2.5.1.15. Create an olog whose underlying shape is a commutative square. Now\nadd the fiber product so that the shape is the same as that of Diagram (2.32). Assign\nEnglish labels to the projections π1, π2 and to the dotted map A\nxf,fyZ\nYYYYN X ˆZ Y , such\nthat these labels are as canonical as possible.\n♦\n2.5.1.16\nPasting diagrams for pullback\nConsider the diagram drawn below, which includes a left-hand square, a right-hand\nsquare, and a big rectangle.\nA1\nf 1\n/\ni\n\n⌟\nB1\ng1\n/\nj\n\n⌟\nC1\nk\n\nA\nf\n/ B\ng\n/ C\nThe right-hand square has a corner symbol indicating that B1 - B ˆC C1 is a pullback.\nBut the corner symbol on the left is ambiguous; it might be indicating that the left-hand\nsquare is a pullback, or it might be indicating that the big rectangle is a pullback. It\nturns out that if B1 - B ˆC C1 then it is not ambiguous because the left-hand square is\na pullback if and only if the big rectangle is.\nProposition 2.5.1.17. Consider the diagram drawn below\nB1\ng1\n/\nj\n\n⌟\nC1\nk\n\nA\nf\n/ B\ng\n/ C\nwhere B1 - B ˆC C1 is a pullback. Then there is an isomorphism A ˆB B1 - A ˆC C1.\nSaid another way,\nA ˆB pB ˆC C1q - A ˆC C1.\n\nCHAPTER 2. THE CATEGORY OF SETS\nProof. We first provide a map φ: A ˆB pB ˆC C1q N A ˆC C1. An element of A ˆB\npB ˆC C1q is of the form pa, b, pb, c, c1qq such that fpaq \" b, gpbq \" c and kpc1q \" c. But\nthis implies that g fpaq \" c \" kpc1q so we put φpa, b, pb, c, c1qq :\" pa, c, c1q P A ˆC C1.\nNow we provide a proposed inverse, ψ: AˆC C1 N AˆB pB ˆC C1q. Given pa, c, c1q with\ng fpaq \" c \" kpc1q, let b \" fpaq and note that pb, c, c1q is an element of B ˆC C1. So we\ncan define ψpa, c, c1q \" pa, b, pb, c, c1qq. It is easy to see that φ and ψ are inverse.\n□\nProposition 2.5.1.17 can be useful in authoring ologs.\nFor example, the type ⌜a\ncellphone that has a bad battery⌝is vague, but we can lay out precisely what it means\nusing pullbacks:\nA-BˆDC\na cellphone that\nhas a bad battery\n/\n\nC-DˆF E\na bad battery\n/\n\nE-F ˆHG\nless than\n1 hour\n/\n\nG\nbetween\n0 and 1\n\nB\na cellphone\nhas\n/\nD\na battery\nremains\ncharged\nfor\n/\nF\na duration\nof time\nin hours\nyields /\nH\na range of\nnumbers\n(2.33)\nThe category-theoretic fact described above says that since A - B ˆD C and C -\nD ˆF E, it follows that A - B ˆF E. That is, we can deduce the definition \"a cellphone\nthat has a bad battery is defined as a cellphone that has a battery which remains charged\nfor less than one hour.\"\nExercise 2.5.1.18.\na.) Create an olog that defines two people to be \"of approximately the same height\" if\nand only if their height difference is less than half an inch, using a pullback. Your\nolog can include the box ⌜a real number x such that .5 a x a .5⌝.\nb.) In the same olog, make a box for those people whose height is approximately the\nsame as a person named \"The Virgin Mary\". You may need to use images, as in\nSection 2.3.3.8.\n♦\nExercise 2.5.1.19. Consider the diagram on the left below, where both squares commute.\nY 1\n\nY\n>\n\nX1\n/ Z1\nX\n/\n=\nZ\n>\nW 1\n/\n\n⌟\nY 1\n\nW\n/\n\n⌟\nY\n>\n\nX1\n/ Z1\nX\n/\n=\nZ\n>\nLet W \" X ˆZ Y and W 1 \" X1 ˆZ1 Y 1, and form the diagram to the right. Use the\nuniversal property of fiber products to construct a map W N W 1 such that all squares\ncommute.\n♦\n\n2.5. FINITE LIMITS IN SET\n2.5.2\nSpans, experiments, and matrices\nDefinition 2.5.2.1. Given sets A and B, a span on A and B is a set R together with\nfunctions f : R N A and g: R N B.\nR\nf\n\ng\n\nA\nB\nApplication 2.5.2.2. Think of A and B as observables and R as a set of experiments\nperformed on these two variables. For example, let's say T is the set of possible tem-\nperatures of a gas in a fixed container and let's say P is the set of possible pressures of\nthe gas. We perform 1000 experiments in which we change and record the temperature\nand we simultaneously also record the pressure; this is a span T\nfÐY E\ngYN P. The results\nmight look like this:\nExperiment\nID\nTemperature\nPressure\n...\n...\n...\n♦♦\nDefinition 2.5.2.3. Let A, B, and C be sets, and let A\nfÐY R\ngYN B and B\nf 1\nÐY R1\ng1\nYN C\nbe spans. Their composite span is given by the fiber product R ˆB R1 as in the diagram\nbelow:\nR ˆB R1\n\nR\nf\n\ng\n\nR1\nf 1\n\ng1\n\nA\nB\nC\nApplication 2.5.2.4. Let's look back at our lab's experiment from Application 2.5.2.2,\nwhich resulted in a span T\nfÐY E\ngYN P. Suppose we notice that something looks a little\nwrong. The pressure should be linear in the temperature but it doesn't appear to be.\nWe hypothesize that the volume of the container is increasing under pressure. We look\nup this container online and see that experiments have been done to measure the volume\nas the interior pressure changes. The data has generously been made available online,\nwhich gives us a span P\nf 1\nÐY E1\ng1\nYN V .\nThe composite of our lab's span with the online data span yields a span T Ð E2 N V ,\nwhere E2 :\" E ˆP E1. What information does this span give us? In explaining it, one\n\nCHAPTER 2. THE CATEGORY OF SETS\nmight say \"whenever an experiment in our lab yielded the same pressure as one they\nrecorded, let's call that a data point. Every data point has an associated temperature\n(from our lab) and an associated volume (from their experiment). This is the best we\ncan do.\"\nThe information we get this way might be seen by some as unscientific, but it certainly\nis the kind of information people use in business and in every day life calculation--we get\nour data from multiple sources and put it together. Moreover, it is scientific in the sense\nthat it is reproducible. The way we obtained our T-V data is completely transparent.\n♦♦\nWe can relate spans to matrices of natural numbers, and see a natural \"categorifica-\ntion\" of matrix addition and matrix multiplication. If our spans come from experiments\nas in Applications 2.5.2.2 and 2.5.2.4 the matrices involved will look like huge but sparse\nmatrices. Let's go through that.\nLet A and B be sets and let A Ð R N B be a span. By the universal property of\nproducts, we have a unique map R\npYN A ˆ B.\nWe make a matrix of natural numbers out of this data as follows. The set of rows\nis A, the set of columns is B. For elements a P A and b P B, the pa, bq-entry is the\ncardinality of its preimage, |p 1pa, bq|, i.e. the number of elements in R that are sent by\np to pa, bq.\nSuppose we are given two pA, Bq-spans, i.e. A Ð R N B and A Ð R1 N B; we might\nthink of these has having the same dimensions, i.e. they are both |A| ˆ |B|-matrices.\nWe can take the disjoint union R \\ R1 and by the universal property of coproducts we\nhave a unique span A Ð R \\ R1 N B making the requisite diagram commute. 13 The\nmatrix corresponding to this new span will be the sum of the matrices corresponding to\nthe two previous spans out of which it was made.\nGiven a span A Ð R N B and a span B Ð S N C, the composite span can be formed\nas in Definition 2.5.2.3. It will correspond to the usual multiplication of matrices.\nConstruction 2.5.2.5. Given a span A\nfÐY R\ngYN B, one can draw a bipartite graph with\neach element of A drawn as a dot on the left, each element of B drawn as a dot on the\nright, and each element r P R drawn as an arrow connecting vertex fprq on the left to\nvertex gprq on the right.\nExercise 2.5.2.6.\na.) Draw the bipartite graph (as in Construction 2.5.2.5) corresponding to the span\nT\nfÐY E\ngYN P in Application 2.5.2.2.\nb.) Now make up your own span P\nf 1\nÐY E1\ng1\nYN V and draw it. Finally, draw the composite\nspan below.\nc.) Can you say how the composite span graph relates to the graphs of its factors?\nR\n{\n#\n\nA\nR \\ R1\no\n/ B\nR1\n<\nb\nO\n\n2.6. FINITE COLIMITS IN SET\n♦\n2.5.3\nEqualizers and terminal objects\nDefinition 2.5.3.1. Suppose given two parallel arrows\nX\nf\n/\ng\n/ Y.\nEqpf, gq\np\n/ X\nf\n/\ng\n/ Y\n(2.34)\nThe equalizer of f and g is the commutative diagram as to the right in (2.34), where we\ndefine\nEqpf, gq :\" tx P X | fpxq \" gpxqu\nand where p is the canonical inclusion.\nExample 2.5.3.2. Suppose one has designed an experiment to test a theoretical prediction.\nThe question becomes, \"when does the theory match the experiment?\" The answer is\ngiven by the equalizer of the following diagram:\nan input\nshould, according to theory, yield /\naccording to experiment yields / an output\nThe equalizer is the set of all inputs for which the theory and the experiment yield the\nsame output.\nExercise 2.5.3.3. Come up with an olog that uses equalizers in a reasonably interest-\ning way. Alternatively, use an equalizer to specify those published authors who have\npublished exactly one paper. Hint: find a function from authors to papers; then find\nanother.\n♦\nExercise 2.5.3.4. Find a universal property enjoyed by the equalizer of two arrows, and\npresent it in the style of Lemmas 2.4.1.10, 2.4.2.7, and 2.5.1.14.\n♦\nExercise 2.5.3.5.\na.) A terminal set is a set S such that for every set X, there exists a unique function\nX N S. Find a terminal set.\nb.) Do you think that the notion terminal set belongs in this section (Section 2.5)? How\nso?\nIf products, pullbacks, and equalizers are all limits, what do limits have in\ncommon?\n♦\n2.6\nFinite colimits in Set\nThis section will parallel Section 2.5--I will introduce several types of finite colimits and\nhope that this gives the reader some intuition about them, without formally defining\nthem yet. Before doing so, I must define equivalence relations and quotients.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.6.1\nBackground: equivalence relations\nDefinition 2.6.1.1 (Equivalence relations and equivalence classes). Let X be a set. An\nequivalence relation on X is a subset R D X ˆ X satisfying the following properties for\nall x, y, z P X:\nReflexivity: px, xq P R;\nSymmetry: px, yq P R if and only if py, xq P R; and\nTransitivity: if px, yq P R and py, zq P R then px, zq P R.\nIf R is an equivalence relation, we often write x „R y, or simply x „ y, to mean px, yq P R.\nFor convenience we may refer to the equivalence relation by the symbol „, saying that\n„ is an equivalence relation on X.\nAn equivalence class of „ is a subset A D X such that\n- A is nonempty, A % H;\n- if x P A and x1 P A, then x „ x1; and\n- if x P A and x „ y, then y P A.\nSuppose that „ is an equivalence relation on X. The quotient of X by „, denoted X{ „\nis the set of equivalence classes of „.\nExample 2.6.1.2. Let Z denote the set of integers. Define a relation R D Z ˆ Z by\nR \" tpx, yq | Dn P Z such that x ` 7n \" yu.\nThen R is an equivalence relation because x ` 7 0 \" x (reflexivity); x ` 7 n \" y if and\nonly if y ` 7 p nq \" x (symmetry); and x ` 7n \" y and y ` 7m \" z together imply\nthat x ` 7pm ` nq \" z (transitivity).\nExercise 2.6.1.3. Let X be the set of people on earth; define a binary relation R D X ˆX\non X as follows. For a pair px, yq of people, say px, yq P R if x spends a lot of time thinking\nabout y.\na.) Is this relation reflexive?\nb.) Is it symmetric?\nc.) Is it transitive?\n♦\nExample 2.6.1.4 (Partitions). An equivalence relation on a set X can be thought of as a\nway of partitioning X. A partition of X consists of a set I, called the set of parts, and\nfor every element i P I a subset Xi D X such that two properties hold:\n- every element x P X is in some part (i.e. for all x P X there exists i P I such that\nx P Xi); and\n- no element can be found in two different parts (i.e. if x P Xi and x P Xj then\ni \" j).\n\n2.6. FINITE COLIMITS IN SET\nGiven a partition of X, we define an equivalence relation „ on X by saying x „ x1\nif x and x1 are in the same part (i.e. if there exists i P I such that x, x1 P Xi). The\nparts become the equivalence classes of this relation. Conversely, given an equivalence\nrelation, one makes a partition on X by taking I to be the set of equivalence classes and\nfor each i P I letting Xi be the elements in that equivalence class.\nExercise 2.6.1.5. Let X and B be sets and let f : X N B be a function. Define a subset\nR D X ˆ X by\nR \" tpx, yq | fpxq \" fpyqu.\na.) Is R an equivalence relation?\nb.) Are all equivalence relations on X obtainable in this way (as the fibers of some\nfunction having domain X)?\nc.) Does this viewpoint on equivalence classes relate to that of Example 2.6.1.4?\n♦\nExercise 2.6.1.6. Take a set I of sets; i.e. suppose that for each element i P I you are\ngiven a set Xi. For every two elements i, j P I say that i „ j if Xi and Xj are isomorphic.\nIs this relation an equivalence relation on I?\n♦\nLemma 2.6.1.7 (Generating equivalence relations). Let X be a set and R D X ˆ X a\nsubset. There exists a relation S D X ˆ X such that\n- S is an equivalence relation,\n- R D S, and\n- for any equivalence relation S1 such that R D S1, we have S D S1.\nThe relation S1 will be called the equivalence relation generated by R.\nProof. Let LR be the set of all equivalence relations on X that contain R; in other words,\neach element lP LR is an equivalence relation, lP X ˆ X. The set LR is non-empty\nbecause X ˆ X D X ˆ X is an equivalence relation.\nLet S denote the set of pairs\npx1, x2q P X ˆ X that appear in every element of LR. Note that R D S by definition.\nWe need only show that S is an equivalence relation.\nIt is clearly reflexive, because R is. If px, yq P S then px, yq P lfor all lP LR. But\nsince each lis an equivalence relation, py, xq P ltoo, so py, xq P S. This shows that S\nis symmetric. The proof that it is transitive is similar: if px, yq P S and py, zq P S then\nthey are both in each lwhich puts px, zq in each l, which puts it in S.\n□\nRemark 2.6.1.8. Let X be a set and R D X ˆ X a relation. The proof of Lemma 2.6.1.7\nhas the benefit of working even if |X| e 8, but it has the cost that it is not very intuitive,\nnor useful in practice when X is finite. The intuitive way to think about the idea of\nequivalence relation generated by R is as follows.\n1. First add to R what is demanded by reflexivity, R1 :\" R Y tpx, xq | x P Xu.\n2. Then add to R what is demanded by symmetry, R2 :\" R1 Y tpx, yq | py, xq P R1u.\n3. Finally, add to R what is demanded by transitivity,\nS \" R2 Y tpx, zq | px, yq P R2, and py, zq P R2u.\n\nCHAPTER 2. THE CATEGORY OF SETS\nExercise 2.6.1.9. Consider the set R of real numbers. Draw the coordinate plane R ˆ R,\ngive it coordinates x and y. A binary relation on R is a subset S D R ˆ R, which can be\ndrawn as a set of points in the plane.\na.) Draw the relation tpx, yq | y \" x2u.\nb.) Draw the relation tpx, yq | y e x2u.\nc.) Let S0 be the equivalence relation on R generated (in the sense of Lemma 2.6.1.7)\nby the empty set. Draw S as a subset of the plane.\nd.) Consider the equivalence relation S1 generated by tp1, 2q, p1, 3qu. Draw S1 in the\nplane. Highlight the equivalence class containing p1, 2q.\ne.) The reflexivity property and the symmetry property have pleasing visualizations in\nR ˆ R; what are they?\nf.) Is there a nice heuristic for visualizing the transitivity property?\n♦\nExercise 2.6.1.10. Consider the binary relation R \" tpn, n ` 1q | n P Zu D Z ˆ Z.\na.) What is the equivalence relation generated by R?\nb.) How many equivalence classes are there?\n♦\nExercise 2.6.1.11. Suppose N is a network (or graph). Let X be the nodes of the network,\nand let R D X ˆ X denote the relation such that px, yq P R iffthere exists an arrow\nconnecting x to y. 14\na.) What is the equivalence relation „ generated by R?\nb.) What is the quotient X{ „?\n♦\n2.6.2\nPushouts\nDefinition 2.6.2.1 (Pushout). Suppose given the diagram of sets and functions below:\nW\nf\n/\ng\n\nX\nY\n(2.35)\nIts fiber sum, denoted X\\W Y , is defined as the quotient of X\\W \\Y by the equivalence\nrelation „ generated by w „ fpwq and w „ gpwq for all w P W.\nX \\W Y :\" pX \\ W \\ Y q{ „\nwhere @w P W, w „ fpwq\nand\nw „ gpwq.\n14The word iffmeans \"if and only if\". In this case we are saying that the pair px, yq is in R if and\nonly if there exists an arrow connecting x and y.\n\n2.6. FINITE COLIMITS IN SET\nThere are obvious inclusions i1 : X N X \\W Y and i2 : Y N X \\W Y . 15 Note that if\nZ \" X \\W Y then the diagram\nW\ng\n/\nf\n\nY\ni2\n\nX\ni1\n/ Z\n⌜\n(2.36)\ncommutes. Given the setup of Diagram 2.35 we define the pushout of X and Y over W\nto be any set Z for which we have an isomorphism Z\n-\nYN X \\W Y . The corner symbol\n⌜in Diagram 2.36 indicates that Z is the pushout.\nExample 2.6.2.2. Let X \" tx P R | 0 d x d 1u be the set of numbers between 0 and 1,\ninclusive, let Y \" ty P R | 1 d y d 2u by the set of numbers between 1 and 2, inclusive,\nand let W \" t1u. Then the pushout X\nfÐY W\ngYN Y , where f and g are the \"obvious\"\nfunctions (1 ÞN 1) is X \\W Y - tz P R | 0 d z d 2u, as expected. When we eventually\nget to general colimits, one can check that the whole real line can be made by patching\ntogether intervals in this way.\nExample 2.6.2.3 (Pushout). In each example below, the diagram to the right is intended\nto be a pushout of the diagram to the left. The new object, D, is the union of B and\nC, but instances of A are equated to their B and C aspects. This will be discussed after\nthe two diagrams.\nA\na cell in the\nshoulder\nis\n/\nis\n\nC\na cell in\nthe arm\nB\na cell in the\ntorso\nA\na cell in the\nshoulder\nis\n/\nis\n\nC\na cell in\nthe arm\n\nB\na cell in the\ntorso\n/\nD\"B\\AC\na cell in the\ntorso or arm\n(2.37)\nIn the left-hand olog (2.37, the two arrows are inclusions: the author considers every cell\nin the shoulder to be both in the arm and in the torso. The pushout is then just the\nunion, where cells in the shoulder are not double-counted.\n15Note that our term inclusions is not too good, because it seems to suggest that i1 and i2 are injective\n(see Definition 2.7.5.1) and this is not always the case.\n\nCHAPTER 2. THE CATEGORY OF SETS\nA\na college\nmathematics\ncourse\nyields/\nis\nC\nan utterance\nof the phrase\n\"too hard\"\nB\na college\ncourse\nA\na college\nmathematics\ncourse\nyields /\nis\n\nC\nan utterance\nof the phrase\n\"too hard\"\n\nB\na college\ncourse\n/\nD \" B\\A C\na college course,\nwhere every\nmathematics\ncourse is\nreplaced by an\nutterance of the\nphrase \"too\nhard\"\n(2.38)\nIn Olog (2.37), the shoulder is seen as part of the arm and part of the torso. When\ntaking the union of these two parts, we do not want to \"double-count\" the shoulder (as\nwould be done in the coproduct B \\ C, see Example 2.4.2.12). Thus we create a new\ntype A for cells in the shoulder, which are considered the same whether viewed as cells in\nthe arm or cells in the torso. In general, if one wishes to take two things and glue them\ntogether, with A as the glue and with B and C as the two things to be glued, the union\nis the pushout B \\A C. (A nice image of this can be seen in the setting of topological\nspaces, see Example 4.5.3.30.)\nIn Olog (2.38), if every mathematics course is simply \"too hard,\" then when reading\noffa list of courses, each math course will not be read aloud but simply read as \"too\nhard.\" To form D we begin by taking the union of B and C, and then we consider\neverything in A to be the same whether one looks at it as a course or as the phrase \"too\nhard.\" The math courses are all blurred together as one thing. Thus we see that the\npower to equate different things can be exercised with pushouts.\nExercise 2.6.2.4. Let W, X, Y be as drawn and f : W N X and g: W N Y the indicated\nfunctions.\nThe pushout of the diagram X\nf\nÐYYY W\ng\nYYYN Y is a set P. Write down the cardinality\nof P - n as a natural number n P N.\n♦\n\n2.6. FINITE COLIMITS IN SET\nExercise 2.6.2.5. Suppose that W \" H; what can you say about X \\W Z?\n♦\nExercise 2.6.2.6. Let W :\" N \" t0, 1, 2, . . .u denote the set of natural numbers, let X \" Z\ndenote the set of integers, and let Y \" t,u denote a one-element set. Define f : W N X\nby fpwq \" pw ` 1q, and define g: W N Y to be the unique map. Describe the set\nX \\W Y .\n♦\nExercise 2.6.2.7. Let i: R D X ˆ X be an equivalence relation (see Example 2.1.2.3\nfor notation). Composing with the projections π1, π2 : X ˆ X N X, we have two maps\nπ1 i, : R N X and π2 i: R N X.\na.) What is the pushout\nX\nπ1 i\nÐYYY R π2 i\nYYYN X?\nb.) If i: R D X ˆ X is not assumed to be an equivalence relation, we can still define the\npushout above. Is there a relationship between the pushout X\nπ1 i\nÐYYY R π2 i\nYYYN X and\nthe equivalence relation generated by R D X ˆ X?\n♦\nLemma 2.6.2.8 (Universal property for pushout). Suppose given the diagram of sets\nand functions as below.\nW\nu\n/\nt\n\nY\nX\nFor any set A and commutative solid arrow diagram as below (i.e. functions f : X N A\nand g: Y N A such that f t \" g u),\nW\nu\n$\nt\nz\nX\ni1\n\nf\n$\nY\ni2\n\ng\nz\nA\nX \\W Y\nD!\nO\n(2.39)\nthere exists a unique arrow\n\"\nf\ng : X \\W Y N A making everything commute,\nf \"\n\"\nf\ng i1\nand\ng \"\n\"\nf\ng i2.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.6.3\nOther finite colimits\nDefinition 2.6.3.1. [Coequalizer]\nSuppose given two parallel arrows\nX\nf\n/\ng\n/ Y.\nX\nf\n/\ng\n/ Y\nq\n/ Coeqpf, gq\n(2.40)\nThe coequalizer of f and g is the commutative diagram as to the right in (2.40), where\nwe define\nCoeqpf, gq :\" Y { fpxq „ gpxq\ni.e. the coequalizer of f and g is the quotient of Y by the equivalence relation generated\nby tpfpxq, gpxqq | x P Xu D Y ˆ Y\nExercise 2.6.3.2. Let X \" R be the set of real numbers. What is the coequalizer of the\ntwo maps X N X given by x ÞN x and x ÞN px ` 1q respectively?\n♦\nExercise 2.6.3.3. Find a universal property enjoyed by the coequalizer of two arrows. ♦\nExercise 2.6.3.4 (Initial object). An initial set is a set S such that for every set A, there\nexists a unique function S N A.\na.) Find an initial set.\nb.) Do you think that the notion initial set belongs in this section (Section 2.6)? How\nso? If coproducts, pushouts, and coequalizers are all colimits, what do colimits have\nin common?\n♦\n2.7\nOther notions in Set\nIn this section we discuss some left-over notions in the category of Sets.\n2.7.1\nRetractions\nDefinition 2.7.1.1. Suppose we have a function f : X N Y and a function g: Y N X\nsuch that g f \" idX. In this case we call f a retract section and we call g a retract\nprojection.\nExercise 2.7.1.2. Create an olog that includes sets X and Y , and functions f : X N Y\nand g: Y N X such that g f \" idX but such that f g % idY ; that is, such that f is a\nretract section but not an isomorphism.\n♦\n2.7.2\nCurrying\nCurrying is the idea that when a function takes many inputs, we can input them one at\na time or all at once. For example, consider the function that takes a material M and\nan extension E and returns the force transmitted through the material when it is pulled\nto that extension. This is a function e: ⌜a material⌝ˆ ⌜an extension⌝N ⌜a force⌝. This\nfunction takes two inputs at once, but it is convenient to \"curry\" the second input. Recall\n\n2.7. OTHER NOTIONS IN SET\nthat HomSetp⌜an extension⌝, ⌜a force⌝q is the set of theoretical force-extension curves.\nCurrying transforms e into a function\ne1 : ⌜a material⌝N HomSetp⌜an extension⌝, ⌜a force⌝q.\nThis is a more convenient way to package the same information.\nIn fact, it may be convenient to repackage this information another way. For any\nextension, we may want the function that takes a material and returns how much force\nit can transmit at that extension. This is a function\ne2 : ⌜an extension⌝N HomSetp⌜a material⌝, ⌜a force⌝q.\nNotation 2.7.2.1. Let A and B be sets. We sometimes denote the set of functions from\nA to B by\nBA :\" HomSetpA, Bq.\n(2.41)\nExercise 2.7.2.2. For a finite set A, let |A| P N denote the cardinality of (number of\nelements in) A. If A and B are both finite (including the possibility that one or both\nare empty), is it always true that |BA| \" |B||A|?\n♦\nProposition 2.7.2.3 (Currying). Let A denote a set. For any sets X, Y there is a\nbijection\nφ: HomSetpX ˆ A, Y q -\nYN HomSetpX, Y Aq.\n(2.42)\nProof. Suppose given f : X ˆ A N Y . Define φpfq: X N Y A as follows: for any x P X\nlet φpfqpxq: A N Y be defined as follows: for any a P A, let φpfqpxqpaq :\" fpx, aq.\nWe now construct the inverse, ψ: HomSetpX, Y Aq N HomSetpX ˆ A, Y q. Suppose\ngiven g: X N Y A. Define ψpgq: X ˆ A N Y as follows: for any pair px, aq P X ˆ A let\nψpgqpx, aq :\" gpxqpaq.\nThen for any f P HomSetpX ˆ A, Y q we have ψ φpfqpx, aq \" φpfqpxqpaq \" fpx, aq,\nand for any g P HomSetpX, Y Aq we have φ ψpgqpxqpaq \" ψpgqpx, aq \" gpxqpaq, Thus we\nsee that φ is an isomorphism as desired.\n□\nExercise 2.7.2.4. Let X \" t1, 2u, A \" ta, bu, and Y \" tx, yu.\na.) Write down three distinct elements of L :\" HomSetpX ˆ A, Y q.\nb.) Write down all the elements of M :\" HomSetpA, Y q.\nc.) For each of the three elements lP L you chose in part (a), write down the corre-\nsponding function φplq: X N M guaranteed by Proposition 2.7.2.3.\n♦\nExercise 2.7.2.5. Let A and B be sets.\nWe know that HomSetpA, Bq \" BA, so we\nhave a function idBA : HomSetpA, Bq N BA. Look at Proposition 2.7.2.3, making the\nsubstitutions X \" HomSetpA, Bq, Y \" B, and A \" A. Consider the function\nφ 1 : HomSetpHomSetpA, Bq, BAq N HomSetpHomSetpA, Bq ˆ A, Bq\nobtained as the inverse of (2.42).\nWe have a canonical element idBA in the domain\nof φ 1.\nWe can apply the function φ 1 and obtain an element ev \" φ 1pidBAq P\nHomSetpHomSetpA, Bq ˆ A, Bq, which is itself a function,\nev: HomSetpA, Bq ˆ A N B.\n\nCHAPTER 2. THE CATEGORY OF SETS\na.) Describe the function ev in terms of how it operates on elements in its domain.\nb.) Why might one be tempted to denote this function by ev?\n♦\nIf n P N is a natural number, recall from (2.6) that there is a nice set n \" t1, 2, . . . , nu.\nIf A is a set, we often make the abbreviation\nAn :\" An.\n(2.43)\nExercise 2.7.2.6. In Example 2.4.1.7 we said that R2 is an abbreviation for R ˆ R, but\nin (2.43) we say that R2 is an abbreviation for R2. Use Exercise 2.1.2.14, Proposition\n2.7.2.3, Exercise 2.4.2.10, and the fact that 1+1=2, to prove that these are isomorphic,\nR2 - R ˆ R.\n(The answer to Exercise 2.1.2.14 was A \" t,u: i.e. HomSetpt,u, Xq - X for all X.)\n♦\n2.7.3\nArithmetic of sets\nProposition 2.7.3.1 summarizes the properties of products, coproducts, and exponentials,\nand shows them all in a familiar light, namely that of arithmetic. In fact, one can think\nof the natural numbers as literally being the isomorphism classes of finite sets--that's\nwhat they are used for in counting. Consider the standard procedure for counting the\nelements of a set S, say cows in a field: one points to an element in S and simultaneously\nsays \"1\", points to another element in S and simultaneously says \"2\", and so on until\nfinished. This procedure amounts to nothing more than creating an isomorphism (one-\nto-one mapping) between S and some set n.\nAgain, the natural numbers are the isomorphism classes of finite sets. Their behavior,\ni.e. the arithmetic of natural numbers, reflects the behavior of sets. For example the fact\nthat multiplication distributes over addition is a fact about grids of dots as in Example\n2.4.1.2. The following proposition lays out such arithmetic properties of sets.\nIn this proposition, we denote the coproduct of two sets A and B by the notation\nA ` B rather than A \\ B. It is a reasonable notation in general, and one that is often\nused.\nProposition 2.7.3.1. The following isomorphisms exist for any sets A, B, and C (except\nfor one caveat, see Exercise 2.7.3.2).\n- A ` 0 - A\n- A ` B - B ` A\n- pA ` Bq ` C - A ` pB ` Cq\n- A ˆ 0 - 0\n- A ˆ 1 - A\n- A ˆ B - B ˆ A\n- pA ˆ Bq ˆ C - A ˆ pB ˆ Cq\n- A ˆ pB ` Cq - pA ˆ Bq ` pA ˆ Cq\n\n2.7. OTHER NOTIONS IN SET\n- A0 - 1\n- A1 - A\n- 0A - 0\n- 1A - 1\n- AB`C - AB ˆ AC\n- pABqC - ABˆC\nExercise 2.7.3.2. Everything in Proposition 2.7.3.1 is true except in one case, namely\nthat of\n00.\nIn this case, we get conflicting answers, because for any set A, including A \" H \" 0, we\nhave claimed both that A0 - 1 and that 0A - 0.\nWhat is the correct answer for 00, based on the definitions of 0 and 1, given in (2.6),\nand of AB, given in (2.41)?\n♦\nExercise 2.7.3.3. It is also true of natural numbers that if a, b P N and ab \" 0 then either\na \" 0 or b \" 0. Is the analogous statement true of all sets?\n♦\nProposition 2.7.3.1 is in some sense about isomorphisms. It says that understanding\nisomorphisms of sets reduces to understanding natural numbers. But note that there is\nmuch more going on in Set than isomorphisms; in particular there are functions that\nare not invertible.\nIn grade school you probably never saw anything that looked like this:\n53 ˆ 3 YN 5\nAnd yet in Exercise 2.7.2.5 we found a function ev: BA ˆ A N B that exists for any\nsets A, B. This function ev is not an isomorphism so it somehow does not show up as\nan equation of natural numbers. But it still has important meaning.\n16 In terms of\nmere number, it looks like we are being told of an important function 575 N 5, which is\nbizarre. The issue here is precisely the one you confronted in Exercise 2.1.2.13.\nExercise 2.7.3.4. Explain why there is a canonical function 53 ˆ 3 YN 5 but not a\ncanonical function 575 N 5.\n♦\nSlogan 2.7.3.5.\n\" It is true that a set is isomorphic to any other set with the same number\nof elements, but don't be fooled into thinking that the study of sets reduces\nto the study of numbers. Functions that are not isomorphisms cannot be\ncaptured within the framework of numbers. \"\n16Roughly, the existence of ev : 53 ˆ 3 YN 5 says that given a dot in a 5 ˆ 5 ˆ 5 grid of dots, and given\none of the three axes, you can tell me the coordinate of that dot along that axis.\n\nCHAPTER 2. THE CATEGORY OF SETS\n2.7.4\nSubobjects and characteristic functions\nDefinition 2.7.4.1. For any set B, define the power set of B, denoted PpBq, to be the\nset of subsets of B.\nExercise 2.7.4.2.\na.) How many elements does PpHq have?\nb.) How many elements does Ppt,uq have?\nc.) How many elements does Ppt1, 2, 3, 4, 5, 6uq have?\nd.) Any idea why they may have named it \"power set\"?\n♦\n2.7.4.3\nSimplicial complexes\nDefinition 2.7.4.4. Let V be a set and let PpV q be its powerset. A subset X D PpV q\nis called downward-closed if, for every u P X and every u1 D u, we have u1 P X. We say\nthat X contains all atoms if for every v P V the singleton set tvu is an element of X.\nA simplicial complex is a pair pV, Xq where V is a set and X D PpV q is a downward-\nclosed subset that contains all atoms. The elements of X are called simplices (singular:\nsimplex). Any subset u D V has a cardinality |u|, so we have a function X N N sending\neach simplex to its cardinality. The set of simplices with cardinality n ` 1 is denoted Xn\nand each element x P Xn is called an n-simplex. 17 Since X contains all atoms (subsets\nof cardinality 1), we have X0 - V , and we may also call the 0-simplices vertices. We\nsometimes call the 1-simplices edges. 18\nSince X0 - V , we may denote a simplicial complex pV, Xq simply by X.\nExample 2.7.4.5. Let n P N be a natural number and let V \" n ` 1. Define the n-simplex,\ndenoted ∆n, to be the simplicial complex PpV q D PpV q, i.e. the whole power set, which\nindeed is downward-closed and contains all atoms.\nWe can draw a simplicial complex X by first putting all the vertices on the page as\ndots. Then for every x P X1, we see that x \" tv, v1u consists of 2 vertices, so we draw\nan edge connecting v and v1. For every y P X2 we see that y \" tw, w1, w2u consists of 3\nvertices, so we draw a (filled-in) triangle connecting them. All three edges will be drawn\ntoo because X is assumed to be downward closed.\nThus, the 0-simplex ∆0, the 1-simplex ∆1, the 2-simplex ∆2, and the 3-simplex ∆3\nare drawn here:\n17It is annoying at first that the set of subsets with cardinality 1 is denoted X0, etc. But this is\nstandard convention because as we will see, Xn will be n-dimensional.\n18The reason we wrote X0 - V rather than X0 \" V is that X0 is the set of 1-element subsets of V .\nSo if V \" ta, b, cu then X0 \" ttau, tbu, tcuu. This is really just pedantry.\n\n2.7. OTHER NOTIONS IN SET\nThe n-simplices for various n's are in no way all of the simplicial complexes.\nIn\ngeneral a simplicial complex is a union or \"gluing together\" of simplices in a prescribed\nmanner. For example, consider the simplicial complex X with vertices X0 \" t1, 2, 3, 4u,\nedges X1 \" tt1, 2u, t2, 3u, t2, 4uu, and no higher simplices X2 \" X3 \" \" H. We\nmight draw X as follows:\n1‚\n2‚\n3‚\n4‚\nExercise 2.7.4.6. Let X be the following simplicial complex, so that X0 \" tA, B, . . . , Mu.\nIn this case X1 consists of elements like tA, Bu and tD, Ku but not tD, Ju.\nWrite out X2 and X3 (hint: the drawing of X indicates that X3 should have one\nelement).\n♦\nExercise 2.7.4.7. The 2-simplex ∆2 is drawn as a filled-in triangle with vertices V \"\nt1, 2, 3u. There is a simplicial complex X \" B∆2 that would be drawn as an empty\ntriangle with the same set of vertices.\na.) Draw ∆2 and X side by side and make clear the difference.\nb.) Write down the data for X as a simplicial complex. In other words what are the sets\nX0, X1, X2, X3, . . .?\n♦\n2.7.4.8\nSubobject classifier\nDefinition 2.7.4.9. Define the subobject classifier for Set, denoted Ω, to be the set\nΩ:\" tTrue, Falseu, together with the function t,u N Ωsending the unique element to\nTrue.\n\nCHAPTER 2. THE CATEGORY OF SETS\nProposition 2.7.4.10. Let B be a set. There is an isomorphism\nφ: HomSetpB, Ωq -\nYN PpBq.\nProof. Given a function f : B N Ω, let φpfq \" tb P B | fpbq \" Trueu D B. We now\nconstruct a function ψ: PpBq N HomSetpB, Ωq to serve as the inverse of φ. Given a\nsubset B1 D B, define ψpB1q: B N Ωas follows:\nψpiqpbq \"\n#\nTrue\nif b P B1,\nFalse\nif b R B1.\nOne checks easily that φ and ψ are mutually inverse.\n□\nDefinition 2.7.4.11 (Characteristic function). Given a subset B1 D B, we call the\ncorresponding function B N Ωthe characteristic function of B1 in B.\nLet B be any set and let PpBq be its power set. By Proposition 2.7.4.10 there is a\nbijection between PpBq and ΩB. Since Ωhas cardinality 2, the cardinality of PpBq is\n2|B|, which explains the correct answer to Exercise 2.7.4.2.\nExercise 2.7.4.12. Let f : A N Ωdenote the characteristic function of some A1 D A, and\ndefine A2 D A to be its complement, A2 :\" A A1 (i.e. a P A2 if and only if a R A1).\na.) What is the characteristic function of A2 D A?\nb.) Can you phrase it in terms of some function ΩN Ω?\n♦\n2.7.5\nSurjections, injections\nThe classical definition of injections and surjections involves elements, which we give now.\nBut a more robust notion involves all maps and will be given in Proposition 2.7.5.4.\nDefinition 2.7.5.1. Let f : X N Y be a function. We say that f is surjective if, for all\ny P Y there exists some x P X such that fpxq \" y. We say that f is injective if, for all\nx P X and all x1 P X with fpxq \" fpx1q we have x \" x1.\nA function that is both injective and surjective is called bijective.\nRemark 2.7.5.2. It turns out that a function that is bijective is always an isomorphism\nand that all isomorphisms are bijective. We will not show that here, but it is not too\nhard; see for example [Big, Theorem 5.4].\nDefinition 2.7.5.3 (Monomorphisms, epimorphisms). Let f : X N Y be a function.\nWe say that f is a monomorphism if for all sets A and pairs of functions g, g1 : A N X,\nA\ng\n\"\ng1\n=X\nf\n/ Y\nif f g \" f g1 then g \" g1.\n\n2.7. OTHER NOTIONS IN SET\nWe say that f is an epimorphism if for all sets B and pairs of functions h, h1 : Y N B,\nX\nf\n/ Y\nh\n\"\nh1\n=B\nif h f \" h1 f then h \" h1.\nProposition 2.7.5.4. Let f : X N Y be a function. Then f is injective if and only if\nit is a monomorphism; f is surjective if and only if it is an epimorphism.\nProof. If f is a monomorphism it is clearly injective by putting A \" t,u. Suppose that\nf is injective and let g, g1 : A N X be functions such that f g \" f g1, but suppose for\ncontradiction that g % g1. Then there is some element a P A such gpaq % g1paq P X. But\nby injectivity fpgpaqq % fpg1paqq, contradicting f g \" f g1.\nSuppose that f : X N Y is an epimorphism and choose some y0 P Y (noting that if\nY is empty then the claim is vacuously true). Let h: Y N Ωdenote the characteristic\nfunction of the subset ty0u D Y and let h1 : Y N Ωdenote the characteristic function\nof H D Y ; note that hpyq \" h1pyq for all y % y0. Then since f is an epimorphism and\nh % h1, we must have h f % h1 f, so there exists x P X with hpfpxqq % h1pfpxqq, which\nimplies that fpxq \" y0. This proves that f is surjective.\nFinally, suppose that f is surjective, and let h, h1 : Y N B be functions with h f \"\nh1 f. For any y P Y , there exists some x P X with fpxq \" y, so hpyq \" hpfpxqq \"\nh1pfpxqq \" h1pyq. This proves that f is an epimorphism.\n□\nProposition 2.7.5.5. Let f : X N Y be a monomorphism.\nThen for any function\ng: A N Y , the top map f 1 : X ˆY A N A in the diagram\nX ˆY A\nf 1\n/\ng1\n\n⌟\nA\ng\n\nX\nf\n/ Y\nis a monomorphism.\nProof. To show that f 1 is a monomorphism, we take an arbitrary set B and two maps\nm, n: B N X ˆY A such that f 1 m \" f 1 n, denote that function by p :\" f 1 m: B N A.\nNow let q \" g1 m and r \" g1 n. The diagram looks like this:\nB\nm\n/\nn\n/\np\n%\nq\n(\nr\n(\nX ˆY A\nf 1\n/\ng1\n\n⌟\nA\ng\n\nX\nf\n/ Y\nWe have that\nf q \" f g1 m \" g f 1 m \" g f 1 n \" f g1 n \" f r\n\nCHAPTER 2. THE CATEGORY OF SETS\nBut we assumed that f is a monomorphism so this implies that q \" r. By the universal\nproperty of pullbacks, Lemma 2.5.1.14, we have m \" n.\n□\nExercise 2.7.5.6. Show, in analogy to Proposition 2.7.5.5, that pushouts preserve epi-\nmorphisms.\n♦\nExample 2.7.5.7. Suppose an olog has a fiber product square\nX ˆZ Y\ng1\n/\nf 1\n\nY\nf\n\nX\ng\n/ Z\nsuch that f is intended to be an injection and g is any map. 19 In this case, there are\nnice labeling systems for f 1, g1, and X ˆZ Y . Namely:\n- \"is\" is an appropriate label for f 1,\n- the label for g is an appropriate label for g1,\n- (the label for X, then \"which\", then the label for g, then the label for Y ) is an\nappropriate label for X ˆZ Y .\nTo give an explicit example,\nXˆZY\na rib which is\nmade by a cow\nis made by\n/\nis\n\nY\na cow\nis\n\nX\na rib\nis made by\n/\nZ\nan animal\nCorollary 2.7.5.8. Let i: A N X be a monomorphism. Then there is a fiber product\nsquare of the form\nA\nf 1 /\ni\n\n⌟\nt,u\nT rue\n\nX\nf\n/ Ω.\n(2.44)\nProof. Let X1 D X denote the image of i and let f : X N Ωdenote the characteristic\nfunction of X1 D X. Then it is easy to check that Diagram 2.44 is a pullback.\n□\nExercise 2.7.5.9. Consider the subobject classifier Ω, the singleton t,u and the map\nt,u T rue\nYYYN Ωfrom Definition 2.7.4.9. Look at diagram 2.44 and in the spirit of Exercise\n2.7.5.7, come up with a label for Ω, a label for t,u, and a label for True. Given a label\nfor X and a label for f, come up with a label for A, a label for i and a label for f 1, such\nthat the English smoothly fits the mathematics.\n♦\n19Of course, this diagram is symmetrical, so the same ideas hold if g is an injection and f is any map.\n\n2.7. OTHER NOTIONS IN SET\n2.7.6\nMultisets, relative sets, and set-indexed sets\nIn this section we prepare ourselves for considering categories other than Set, by looking\nat some categories related to Set.\n2.7.6.1\nMultisets\nConsider the set X of words in a given document. If WCpXq is the wordcount of the\ndocument, we will not generally have WCpXq \" |X|. The reason is that a set cannot\ncontain the same element more than once, so words like \"the\" might be undercounted in\n|X|. A multiset is a set in which elements can be assigned a multiplicity, i.e. a number\nof times they are to be counted.\nBut if X and Y are multisets, what is the appropriate type of mapping from X\nto Y ?\nSince every set is a multiset (in which each element has multiplicity 1), let's\nrestrict ourselves to notions of mapping that agree with the usual one on sets. That\nis, if multisets X and Y happen to be sets then our mappings X N Y should just be\nfunctions.\nExercise 2.7.6.2.\na.) Come up with some notion of mapping for multisets that generalizes functions when\nthe notion is restricted to sets.\nb.) Suppose that X \" p1, 1, 2, 3q and Y \" pa, b, b, bq, i.e. X \" t1, 2, 3u with 1 having\nmultiplicity 2, and Y \" ta, bu with b having multiplicity 3. What are all the maps\nX N Y in your notion?\n♦\nIn Chapter 4 we will be getting to the definition of category, and you can test whether\nyour notion of mapping in fact defines a category. Here is my definition of mapping for\nmultisets.\nDefinition 2.7.6.3. A multiset is a sequence X :\" pE, B, πq where E and B are sets\nand π: E N B is a surjective function. We refer to E as the set of element instances\nof X, we refer to B as the set of element names of X, and we refer to π as the naming\nfunction for X. Given an element name x P B, let π 1pxq D E be the preimage; the\nnumber of elements in π 1pxq is called the multiplicity of x.\nSuppose that X \" pE, B, πq and X1 \" pE1, B1, π1q are multisets. A mapping from\nX to Y , denoted f : X N Y , consists of a pair pf1, f0q such that f1 : E N E1 and\nf0 : B N B1 are functions and such that the following diagram commutes:\nE\nf1\n/\nπ\n\nE1\nπ1\n\nB\nf0\n/ B1.\n(2.45)\nExercise 2.7.6.4. Suppose that a pseudo-multiset is defined to be almost the same as a\nmultiset, except that π is not required to be surjective.\na.) Write down a pseudo-multiset that is not a multi-set.\nb.) Describe the difference between the two notions in terms of multiplicities.\n\nCHAPTER 2. THE CATEGORY OF SETS\nc.) Complexity of names aside, which do you think is a more useful notion: multiset or\npseudo-multisets?\n♦\nExercise 2.7.6.5. Consider the multisets described in Exercise 2.7.6.2.\na.) Write each of them in the form pE, B, πq, as in Definition 2.7.6.3.\nb.) In terms of the same definition, what are the mappings X N Y ?\nc.) If we remove the restriction that diagram 2.45 must commute, how many mappings\nX N Y are there?\n♦\n2.7.6.6\nRelative sets\nLet's continue with our ideas from multisets, but now suppose that we have a fixed set B\nof names that we want to keep once and for all. Whenever someone discusses a set, each\nelement must have a name in B. And whenever someone discusses a mapping, it must\npreserve the names. For example, if B is the set of English words, then every document\nconsists of an ordered set mapping to B (e.g. 1 ÞN Suppose, 2 ÞN that, 3 ÞN we, etc.) A\nmapping from document A to document B would send each word found somewhere in\nA to the same word found somewhere in B. This notion is defined carefully below.\nDefinition 2.7.6.7 (Relative set). Let B be a set. A relative set over B, or simply a\nset over B, is a pair pE, πq such that E is a set and π: E N B is a function. A mapping\nof relative sets over B, denoted f : pE, πq N pE1, π1q, is a function f : E N E1 such that\nthe triangle below commutes, i.e. π \" π1 f,\nE\nf\n/\nπ\n\nE1\nπ1\n\nB\nExercise 2.7.6.8. Given sets X, Y, Z and functions f : X N Y and g: Y N Z, we can\ncompose them to get a function X N Z. If B is a set, if pX, pq, pY, qq, and pZ, rq are\nrelative sets over B, and if f : pX, pq N pY, qq and g: pY, qq N pZ, rq are mappings, is\nthere a reasonable notion of composition such that we get a mapping of relative sets\npX, pq N pZ, rq? Hint: draw diagrams.\n♦\nExercise 2.7.6.9.\na.) Let t,u denote a set with one element. What is the difference between sets over t,u\nand simply sets?\nb.) Describe the sets relative to H. How many are there?\n♦\n2.7.6.10\nIndexed sets\nLet A be a set. Suppose we want to assign to each element a P A a set Sa. This is called\nan A-indexed set. In category theory we are always interested in the legal mappings\nbetween two different structures of the same sort, so we need a notion of A-indexed\nmappings; we do the \"obvious thing\".\n\n2.7. OTHER NOTIONS IN SET\nExample 2.7.6.11. Let C be a set of classrooms. For each c P C let Pc denote the set of\npeople in classroom c, and let Sc denote the set of seats (chairs) in classroom c. Then P\nand S are C-indexed sets. The appropriate kind of mapping between them respects the\nindexes. That is, a mapping of multi-sets P N S should, for each classroom c P C, be a\nfunction Pc N Sc.20\nDefinition 2.7.6.12. Let A be a set. An A-indexed set is a collection of sets Sa, one for\neach element a P A; for now we denote this by pSaqaPA. If pS1\naqaPA is another A-indexed\nset, a mapping of A-indexed sets from pSaqaPA to pS1\naqaPA, denoted\npfaqaPA : pSaqaPA N pS1\naqaPA\nis a collection of functions fa : Sa N S1\na, one for each element a P A.\nExercise 2.7.6.13. Let t,u denote a one element set. What are t,u-indexed sets and\nmappings between them?\n♦\nExercise 2.7.6.14. There is a strong relationship between A-indexed sets and relative sets\nover A. What is it?\n♦\n20If we wanted to allow people from any classroom to choose a chair from just any classroom, category\ntheory would tell us to reconsider P and S as sets, forgetting their indices. See Section 5.1.4.7.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996Category Theory for Scientist\nSpring 2013\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Textbook: Introduction",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/4b7221e4a44bf9ad512eae6efe9d76b8_MIT18_S996S13_chapter1.pdf",
      "content": "Chapter 1\nIntroduction\nThe title page of this book contains a graphic that we reproduce here.\nan observa*on\na predic*on\nan experiment\nanalyzed by a\nperson yields\nanalyzed by a\nperson produces\nmo*vates the\nspecifica*on of\nwhen executed\nresults in\na hypothesis\n(1.1)\nIt is intended to evoke thoughts of the scientific method.\nA hypothesis analyzed by a person produces a prediction, which motivates the\nspecification of an experiment, which when executed results in an observation,\nwhich analyzed by a person yields a hypothesis.\nThis sounds valid, and a good graphic can be exceptionally useful for leading a reader\nthrough the story that the author wishes to tell.\nInterestingly, a graphic has the power to evoke feelings of understanding, without\nreally meaning much. The same is true for text: it is possible to use a language such as\nEnglish to express ideas that are never made rigorous or clear. When someone says \"I\nbelieve in free will,\" what does she believe in? We may all have some concept of what\nshe's saying--something we can conceptually work with and discuss or argue about. But\nto what extent are we all discussing the same thing, the thing she intended to convey?\nScience is about agreement. When we supply a convincing argument, the result of\nthis convincing is agreement.\nWhen, in an experiment, the observation matches the\nhypothesis--success!--that is agreement. When my methods make sense to you, that is\n\nCHAPTER 1. INTRODUCTION\nagreement. When practice does not agree with theory, that is disagreement. Agreement\nis the good stuffin science; it's the high fives.\nBut it is easy to think we're in agreement, when really we're not.\nModeling our\nthoughts on heuristics and pictures may be convenient for quick travel down the road,\nbut we're liable to miss our turnoffat the first mile. The danger is in mistaking our\nconvenient conceptualizations for what's actually there. It is imperative that we have\nthe ability at any time to ground out in reality. What does that mean?\nData. Hard evidence. The physical world. It is here that science touches down and\nheuristics evaporate. So let's look again at the diagram on the cover. It is intended\nto evoke an idea of how science is performed. Is there hard evidence and data to back\nthis theory up? Can we set up an experiment to find out whether science is actually\nperformed according to such a protocol? To do so we have to shake offthe stupor evoked\nby the diagram and ask the question: \"what does this diagram intend to communicate?\"\nIn this course I will use a mathematical tool called ologs, or ontology logs, to give\nsome structure to the kinds of ideas that are often communicated in pictures like the\none on the cover. Each olog inherently offers a framework in which to record data about\nthe subject. More precisely it encompasses a database schema, which means a system of\ninterconnected tables that are initially empty but into which data can be entered. For\nexample consider the olog below\na mass\nan object of mass\nm held at height h\nabove the ground\nhas as mass\no\nwhen dropped has\nas number of sec-\nonds till hitting the\nground\n&\nhas as height\nin meters\n\na real number h\n?\n?\n2h 9.8\n/ a real number\nThis olog represents a framework in which to record data about objects held above the\nground, their mass, their height, and a comparison (the ?-mark in the middle) between\nthe number of seconds till they hit the ground and a certain real-valued function of their\nheight. We will discuss ologs in detail throughout this course.\nThe picture in (1.1) looks like an olog, but it does not conform to the rules that\nwe lay out for ologs in Section 2.3. In an olog, every arrow is intended to represent a\nmathematical function. It is difficult to imagine a function that takes in predictions and\noutputs experiments, but such a function is necessary in order for the arrow\na prediction\nmotivates the specification of\nYYYYYYYYYYYYYYYYYYN an experiment\nin (1.1) to make sense. To produce an experiment design from a prediction probably\nrequires an expert, and even then the expert may be motivated to specify a different\nexperiment on Tuesday than he is on Monday. But perhaps our criticism has led to a\nway forward: if we say that every arrow represents a function when in the context of\na specific expert who is actually doing the science at a specific time, then Figure (1.1)\nbegins to make sense. In fact, we will return to the figure in Section 5.3 (specifically\nExample 5.3.3.10), where background methodological context is discussed in earnest.\n\n1.1. A BRIEF HISTORY OF CATEGORY THEORY\nThis course is an attempt to extol the virtues of a new branch of mathematics,\ncalled category theory, which was invented for powerful communication of ideas between\ndifferent fields and subfields within mathematics. By powerful communication of ideas I\nactually mean something precise. Different branches of mathematics can be formalized\ninto categories. These categories can then be connected together by functors. And the\nsense in which these functors provide powerful communication of ideas is that facts and\ntheorems proven in one category can be transferred through a connecting functor to\nyield proofs of analogous theorems in another category. A functor is like a conductor of\nmathematical truth.\nI believe that the language and toolset of category theory can be useful throughout\nscience. We build scientific understanding by developing models, and category theory is\nthe study of basic conceptual building blocks and how they cleanly fit together to make\nsuch models. Certain structures and conceptual frameworks show up again and again in\nour understanding of reality. No one would dispute that vector spaces are ubiquitous.\nBut so are hierarchies, symmetries, actions of agents on objects, data models, global\nbehavior emerging as the aggregate of local behavior, self-similarity, and the effect of\nmethodological context.\nSome ideas are so common that our use of them goes virtually undetected, such as set-\ntheoretic intersections. For example, when we speak of a material that is both lightweight\nand ductile, we are intersecting two sets. But what is the use of even mentioning this\nset-theoretic fact? The answer is that when we formalize our ideas, our understanding\nis almost always clarified. Our ability to communicate with others is enhanced, and the\npossibility for developing new insights expands. And if we are ever to get to the point\nthat we can input our ideas into computers, we will need to be able to formalize these\nideas first.\nIt is my hope that this course will offer scientists a new vocabulary in which to think\nand communicate, and a new pipeline to the vast array of theorems that exist and are\nconsidered immensely powerful within mathematics. These theorems have not made their\nway out into the world of science, but they are directly applicable there. Hierarchies are\npartial orders, symmetries are group elements, data models are categories, agent actions\nare monoid actions, local-to-global principles are sheaves, self-similarity is modeled by\noperads, context can be modeled by monads.\n1.1\nA brief history of category theory\nThe paradigm shift brought on by Einstein's theory of relativity brought on the real-\nization that there is no single perspective from which to view the world. There is no\nbackground framework that we need to find; there are infinitely many different frame-\nworks and perspectives, and the real power lies in being able to translate between them.\nIt is in this historical context that category theory got its start. 1\nCategory theory was invented in the early 1940s by Samuel Eilenberg and Saunders\nMac Lane.\nIt was specifically designed to bridge what may appear to be two quite\ndifferent fields: topology and algebra. Topology is the study of abstract shapes such as\n7-dimensional spheres; algebra is the study of abstract equations such as y2z \" x3 xz2.\nPeople had already created important and useful links (e.g. cohomology theory) between\nthese fields, but Eilenberg and Mac Lane needed to precisely compare different links with\n1The following history of category theory is far too brief, and perhaps reflects more of the author's\naesthetic than any kind of objective truth, whatever that may mean.\nHere are some much better\nreferences: [Kro], [Mar1], [LM].\n\nCHAPTER 1. INTRODUCTION\none another. To do so they first needed to boil down and extract the fundamental nature\nof these two fields. But the ideas they worked out amounted to a framework that fit not\nonly topology and algebra, but many other mathematical disciplines as well.\nAt first category theory was little more than a deeply clarifying language for existing\ndifficult mathematical ideas. However, in 1957 Alexander Grothendieck used category\ntheory to build new mathematical machinery (new cohomology theories) that granted\nunprecedented insight into the behavior of algebraic equations. Since that time, cat-\negories have been built specifically to zoom in on particular features of mathematical\nsubjects and study them with a level of acuity that is simply unavailable elsewhere.\nBill Lawvere saw category theory as a new foundation for all mathematical thought.\nMathematicians had been searching for foundations in the 19th century and were reason-\nably satisfied with set theory as the foundation. But Lawvere showed that the category\nof sets is simply a category with certain nice properties, not necessarily the center of\nthe mathematical universe. He explained how whole algebraic theories can be viewed\nas examples of a single system. He and others went on to show that higher order logic\nwas beautifully captured in the setting of category theory (more specifically toposes).\nIt is here also that Grothendieck and his school worked out major results in algebraic\ngeometry.\nIn 1980 Joachim Lambek showed that the types and programs used in computer\nscience form a specific kind of category. This provided a new semantics for talking about\nprograms, allowing people to investigate how programs combine and compose to create\nother programs, without caring about the specifics of implementation. Eugenio Moggi\nbrought the category theoretic notion of monads into computer science to encapsulate\nideas that up to that point were considered outside the realm of such theory.\nIt is difficult to explain the clarity and beauty brought to category theory by people\nlike Daniel Kan and Andr e Joyal. They have each repeatedly extracted the essence of a\nwhole mathematical subject to reveal and formalize a stunningly simple yet extremely\npowerful pattern of thinking, revolutionizing how mathematics is done.\nAll this time, however, category theory was consistently seen by much of the mathe-\nmatical community as ridiculously abstract. But in the 21st century it has finally come\nto find healthy respect within the larger community of pure mathematics. It is the lan-\nguage of choice for graduate-level algebra and topology courses, and in my opinion will\ncontinue to establish itself as the basic framework in which mathematics is done.\nAs mentioned above category theory has branched out into certain areas of science\nas well. Baez and Dolan have shown its value in making sense of quantum physics, it\nis well established in computer science, and it has found proponents in several other\nfields as well. But to my mind, we are the very beginning of its venture into scientific\nmethodology. Category theory was invented as a bridge and it will continue to serve in\nthat role.\n1.2\nIntention of this book\nThe world of applied mathematics is much smaller than the world of applicable math-\nematics. As alluded to above, this course is intended to create a bridge between the\nvast array of mathematical concepts that are used daily by mathematicians to describe\nall manner of phenomena that arise in our studies, and the models and frameworks of\nscientific disciplines such as physics, computation, and neuroscience.\nTo the pure mathematician I'll try to prove that concepts such as categories, func-\ntors, natural transformations, limits, colimits, functor categories, sheaves, monads, and\n\n1.2. INTENTION OF THIS BOOK\noperads--concepts that are often considered too abstract for even math majors--can\nbe communicated to scientists with no math background beyond linear algebra. If this\nmaterial is as teachable as I think, it means that category theory is not esoteric but\nsomehow well-aligned with ideas that already make sense to the scientific mind. Note,\nhowever, that this book is example-based rather than proof-based, so it may not be\nsuitable as a reference for students of pure mathematics.\nTo the scientist I'll try to prove the claim that category theory includes a formal\ntreatment of conceptual structures that the scientist sees often, perhaps without realizing\nthat there is well-oiled mathematical machinery to be employed. We will work on the\nstructure of information; how data is made meaningful by its connections, both internal\nand outreaching, to other data. Note, however, that this book should most certainly\nnot be taken as a reference on scientific matters themselves. One should assume that\nany account of physics, materials science, chemistry, etc. has been oversimplified. The\nintention is to give a flavor of how category theory may help us model scientific ideas,\nnot to explain these ideas in a serious way.\nData gathering is ubiquitous in science. Giant databases are currently being mined\nfor unknown patterns, but in fact there are many (many) known patterns that simply\nhave not been catalogued. Consider the well-known case of medical records. A patient's\nmedical history is often known by various individual doctor-offices but quite inadequately\nshared between them. Sharing medical records often means faxing a hand-written note\nor a filled-in house-created form between offices.\nSimilarly, in science there exists substantial expertise making brilliant connections\nbetween concepts, but it is being conveyed in silos of English prose known as journal\narticles. Every scientific journal article has a methods section, but it is almost impossible\nto read a methods section and subsequently repeat the experiment--the English language\nis inadequate to precisely and concisely convey what is being done.\nThe first thing to understand in this course is that reusable methodologies can be\nformalized, and that doing so is inherently valuable. Consider the following analogy.\nSuppose you want to add up the area of a region in space (or the area under a curve).\nYou break the region down into small squares, each of which you know has area A; then\nyou count the number of squares, say n, and the result is that the region has an area of\nabout nA. If you want a more precise and accurate result you repeat the process with\nhalf-size squares. This methodology can be used for any area-finding problem (of which\nthere are more than a first-year calculus student generally realizes) and thus it deserves\nto be formalized. But once we have formalized this methodology, it can be taken to its\nlimit and out comes integration by Riemann sums.\nI intend to show that category theory is incredibly efficient as a language for exper-\nimental design patterns, introducing formality while remaining flexible. It forms a rich\nand tightly woven conceptual fabric that will allow the scientist to maneuver between\ndifferent perspectives whenever the need arises. Once one builds that fabric for oneself,\nhe or she has an ability to think about models in a way that simply would not occur\nwithout it. Moreover, putting ideas into the language of category theory forces a person\nto clarify their assumptions. This is highly valuable both for the researcher and for his\nor her audience.\nWhat must be recognized in order to find value in this course is that conceptual chaos\nis a major problem. Creativity demands clarity of thinking, and to think clearly about a\nsubject requires an organized understanding of how its pieces fit together. Organization\nand clarity also lead to better communication with others. Academics often say they are\npaid to think and understand, but that is not true. They are paid to think, understand,\n\nCHAPTER 1. INTRODUCTION\nand communicate their findings.\nUniversal languages for science--languages such as\ncalculus and differential equations, matrices, or simply graphs and pie-charts--already\nexist, and they grant us a cohesiveness that makes scientific research worthwhile. In this\nbook I will attempt to show that category theory can be similarly useful in describing\ncomplex scientific understandings.\n1.3\nWhat is requested from the student\nI will do my best to make clear the value of category theory in science, but I am not a\nscientist. To that end I am asking for your help in exploring how category theory may\nbe useful in your specific field.\nI also want you to recognize that the value of mathematics is not generally obvious\nat first. A good student learning a good subject with a good teacher will see something\ncompelling almost immediately, but may not see how it will be useful in real life. This\nwill come later. I hope you will work hard to understand even without yet knowing what\nits actual value in your life and research will be. Like a student of soccer is encouraged\nto spend hours juggling the ball when he or she could be practicing penalty shots, it\nis important to gain facility with the materials you will be using. Doing exercises is\nimperative for learning mathematics.\n1.4\nCategory theory references\nI wrote this book because the available books on category theory are almost all written\nfor mathematicians (the rest are written for computer scientists). There is one book by\nLawvere and Schanuel, called Conceptual Mathematics [LS], that offers category theory\nto a wider audience, but its style is not appropriate for this course. Still, it is very well\nwritten and clear.\nThe \"bible\" of category theory is Categories for the working mathematician by Mac\nLane [Mac]. But as the title suggests, it was written for working mathematicians and\nwill be quite opaque to my target audience. However, once a person has read my book,\nMac Lane's book may become a valuable reference.\nOther good books include Steve Awodey's book Category theory [Awo] and Barr and\nWells book Category theory for computing science, [BW]. A paper by Brown and Porter\ncalled Category Theory: an abstract setting for analogy and comparison [BP1] is more\nin line with the style of this book, only much shorter. Online, I find wikipedia and a site\ncalled the nlab to be quite useful.\nThis book attempts to explain category theory by examples and exercises rather than\nby theorems and proofs. I hope this approach will be valuable to the working scientist.\n1.5\nAcknowledgments\nI would like to express my deep appreciation for the many scientists who I have worked\nwith over the past five years. It all started with Paea LePendu who first taught me about\ndatabases when I was naively knocking on doors in the University of Oregon computer\nscience department. This book would never have been written if Tristan Nguyen and\nDave Balaban had not noticed my work and encouraged me to continue. Dave Balaban\nand Peter Gates have been my scientific partners since the beginning, working hard to\n\n1.5. ACKNOWLEDGMENTS\nunderstand what I'm offering and working just as hard to help me understand all that\nI'm missing. Peter Gates has deepened my understanding of data in profound ways.\nI have also been tremendously lucky to know Haynes Miller, who made it possible\nfor me set down at MIT, with the help of Clark Barwick and Jacob Lurie. I knew that\nMIT would be the best place in the world for me to pursue this type of research, and\nit has really come through. Researchers like Markus Buehler and his graduate students\nTristan Giesa and Dieter Brommer have been a pleasure to work with, and the many\nmaterials science examples scattered throughout this book is a testament to how much\nour work together has influenced my thinking.\nI'd also like to thank my collaborators and conversation partners with whom I have\ndiscussed subjects written about in this book. Other than people mentioned above, these\ninclude Steve Awodey, Allen Brown, Adam Chlipala, Carlo Curino, Dan Dugger, Henrik\nForssell, David Gepner, Jason Gross, Bob Harper, Ralph Hutchison, Robert Kent, Jack\nMorava, Scott Morrison, David Platt, Joey Perricone, Dylan Rupel, Guarav Singh, Sam\nShames, Nat Stapleton, Patrick Schultz, Ka Yu Tam, Ryan Wisnesky, Jesse Wolfson,\nand Elizabeth Wood.\nI would like to thank Peter Kleinhenz and Peter Gates for reading this book and\nproviding invaluable feedback before I began teaching the 18-S996 class at MIT in Spring\n2013. In particular the cover image is a mild alteration of something Gates sent me to\nhelp motivate the book to scientists.\nI would also like to greatly thank the 18-S996\ncourse grader Darij Grinberg, who was not only the best grader I've had in my 14 years\nof teaching, but gave me more comments than anyone else on the book itself. I'd also like\nto thank the students from the 18-S996 class at MIT who helped me find typos, pointed\nme to unclear explanations, and generally helped me improve the book in many ways.\nOther than the people listed above, these include Aaron Brookner, Leon Dimas, Dylan\nErb, Deokhwan Kim, Taesoo Kim, Owen Lewis, Yair Shenfeld, and Adam Strandberg.\nI would like to thank my teacher, Peter Ralston, who taught me to repeatedly question\nthe obvious. My ability to commit to a project like this one and to see it to fruition has\ncertainly been enhanced since studying with him.\nFinally, I acknowledge my appreciation for support from the Office of Naval Research\n2 without which this book would not have been remotely possible. I believe that their\nfunding of basic research is an excellent way of ensuring that the US remains a global\nleader in the years to come.\n2Grant numbers: N000140910466, N000141010841, N000141310260\n\nCHAPTER 1. INTRODUCTION\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996Category Theory for Scientist\nSpring 2013\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Project: English To Olog Translation",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/0392ab0e0aa477e888a974e7633faab0_MIT18_S996S13_Eng2Ologs.pdf",
      "content": "English to Olog Translation\nor: how I learned to stop worrying and love the Olog.\nEnglish\nOlog\nMagic?\nA proof of concept\nby a M.I.T. Student\nAn Olog is a great\nand powerful tool.\n\nInspiration\n\nInspiration continued\nIf aspects can be read as English sentences... can English\nsentences be turned into aspects?\nCould we take a list of aspects written in English, and back out\nthe Olog?\n\nPerhaps even more inferences could be made\nDISCLAIMER - Because English is not always functional... we\nwill not always get true Ologs out of our sentences...\n\nMonads are the solution\n\nKleisli Category - relations are cool\nInstead of X->Y\n\nWhere the arrows in the Olog represent functions\nWe can use X->PY\n\nWhere the arrows in this context represent relations\n\nThe powerset of Y contains all possible subsets of Y,\nand so any relation from X to Y is kosher.\nThis allows arrows in the Olog to represent\nrelations instead of functions.\n\nMission Statement and Approach\nMission Statement\n\nCreate a proof of concept that can take a list of English sentences,\npull out some relationships, and display them as an Olog.\n\nPeople speak English... why can't we translate for them?\nDecompose the problem\n\nConvert English sentences to parts of speech\n\nGiven parts of speech, find boxes and arrows\n\nGiven boxes and arrows, display the resulting Olog automatically\n\nDraw Ologs Automatically\nSearched for a tool for drawing graphs\n\nFound a program called Graphviz\n\"Graph Visualization Software\" developed by AT&T\nUses DOT language scripts.\nIt's free\n\nThe kicker... it has a Python wrapper called PyGraphviz!\nA.add_edge(1,2)\n\nEnglish sentences to parts of speech\n\nSearched for a tool for identifying parts of speech (POS) in a sentence\n\nFound a python module called topia.termextract\n\nThis module can tokenize a sentence...\n>>> tagger.tokenize('This is a simple example.')\n\n*'This', 'is', 'a', 'simple', 'example', '.']\n\nAnd then determine the parts of speech\n>>> tagger('This is a simple example.')\n\n[['This', 'DT', 'This'],\n\n['is', 'VBZ', 'is'],\n\n['a', 'DT', 'a'],\n\n['simple', 'JJ', 'simple'],\n\n['example', 'NN', 'example'],\n\n['.', '.', '.']]\n\nGiven POS, find boxes and arrows\nWith PyGraphviz and topia.termextract both available for free,\ncoding the POS -> (boxes and arrows) portion in Python made\nthe most sense\nAfter looking at a few Ologs, a method for doing this was\ndetermined (assuming a NF, VF, NF structure):\n1.\nFirst NF starts at the beginning and goes until the first verb.\n2.\nVF starts at the verb and goes until the first \"a\" or \"an\".\n3.\nAnd the second NF goes from the \"a\" or \"an\" to the end.\n\nA simple example\nBook author\nA book has as first author a person.\n\nMore features\nRecursively tear down adjective phrases\nDeal with prepositional phrases\nRemove adverbs from verb phrases\nCheck box for verbose output\nOpen Source\nDecided to avoid pull outs for now\n\nBlows up quickly\n\nAdjective phrases\nAdjective phrases\n\nA jolly rabbit is a happy animal.\nStandard Output\nAdjective phrases\n\nA jolly rabbit is a happy animal.\nVerbose Output\n\nMore Adjective Phrases\nWhat happens if we add more adjectives?\nAdjective phrases\n\nA jolly and silly rabbit is a happy animal.\n\nEven More Adjective Phrases\nWhat happens if we add even more adjectives?\nAdjective phrases\n\nA jolly bouncy silly rabbit is a happy animal.\n\nEven More Adjective Phrases\nWhat happens if we add even more adjectives?\nAdjective phrases\n\nA jolly bouncy silly and hungry rabbit is a happy and troublesome animal.\nA rabbit steals cereal from a kid.\nA trick is for a kid.\n\nPrepositional phrases\nPrepositional phrases\n\nA man with a broom is a person.\nStandard Output\nPrepositional phrases\n\nA man with a broom is a person.\nVerbose Output\n\nMore Prepositional Phrases\nWhat happens if we add more sentences?\nPrepositional phrases\n\nA man with a broom is a person.\nA wizard with transportation is a man with a broom.\n\nEven More Prepositional Phrases\nWhat happens if we add even more sentences?\nPrepositional phrases\n\nA man with a broom is a person.\nA wizard with transportation is a man with a broom.\nA wizard is a man with magical abilities.\n\nAdverbs\nWe can remove adverbs from verb phrases...\nRemove adverbs\n\nA man always has a biological mother.\n\nMore examples\nThis is a test\n\nA force equals a mass times an acceleration.\nA mildly overweight man is a man.\nA child has a mother.\nA mother has a mother.\nA father has a mother.\n\nMore examples\nAdjective phrases\n\nA jolly bouncy crazy silly and hungry rabbit is a happy annoying and troublesome animal.\nA rabbit steals cereal from a kid.\nA trick is for a kid.\n\nA vision for the future\nAdditional Features\n\nWeb/graphical interface\nLike Google translate\n\nNoun phrase parsing\n\nOlog to English output\n\nFQL output\n\nProper nouns to data\nFuture applications\n\nOlog wikipedia and\nthe dictionary\n\nScientific paper Ologging\nVision for the future.\n\nAn Olog nation is a vision for the future.\n\nQuestions and comments?\n\nQuestions?\n\nAn inquisitive and thoughtful audience asks questions after an exciting\npresentation.\n\nA math class at MIT is a thoughtful audience.\nhttp://sourceforge.net/projects/olognation/files/English2Olog.py/download\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996 Category Theory for Scientist\nSpring 2013\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Project: Illustration of Category Hilb",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/55c2ef590fc4492a177149aeebbc2dc5_MIT18_S996S13_CategoryHilb.pdf",
      "content": "IllustraKon of Category Hilb\nwith examples in\nAtomic and OpKcal Physics\nM.I.T. Student\nDepartment of Physics\nMIT\nMay 13, 2013\n\nOutline\n- What is Atomic and OpKcal physics?\ne.g. atoms and photons\n- What is Hilbert space?\n- What is Category Hilb?\n- Monoidal structure of Hilb\n- Feynman diagram in the language of category\ne.g. Quantum Harmonic oscillator\n- Conclusions and interests\n\nWhat is Atomic and OpKcal Physics about?\nPhysics: Quantum phenomena of parKcles\n*Atoms, from one to an ensemble\n*Photons, from one to a bunch, from lasers, or trapped in a cavity\n*simulate other quantum systems\nuse opKcal laNce to simulate crystal\nuse quantum double well to simulate Josephson juncKon\n\nWhat is Atomic and OpKcal Physics about?\nMath: Hilbert space\nDef. A real or complex inner product space that is also a complete metric\nspace with respect to the distance funcKon induced by the inner product.\n* One atom in a harmonic trap induced by lasers\npˆ\nˆ\nm!2 ˆ\nH =\n+\nx 2\n= ( + n)~!\n2m\nEn\nX\nx = {\nX\nci|φi > |ci 2 C,\n|ci|2= 1}\ni\ni\n* A cavity that trapped any number of photons\nHˆ = 1 ✏Eˆ2\nEj = j~!\nX\ny = {\nX\ncj |j > |cj 2 C,\n|cj |2= 1}\nj\nj\n\nWhat is Atomic and OpKcal Physics about?\n* a single atom with two hyperfine states\n|2\nz = {cs|s > +cp|p > ||cs +|cp|2= 1}\n* a single atom with two hyperfine states\ninteracKng with photons in a cavity\nw = z ⇥ y\n\nCategory Hilb\nContent removed due to copyright restrictions.\nTo view definitions of category Hilb, go to: \"Hilb category of Hilbert Spaces\" by bc1.\nhttp://planetmath.org/sites/default/files/texpdf/41070.pdf\n\nCategory Hilb\n- Ob(Hilb)\nX\nx = {\nX\nci|ri > |ci 2 C,\n|ci|2= 1}\ni\ni X\ny = {\nX\ncj |j > |cj 2 C,\n|cj |2= 1}\nj\nj\n|2\nz = {cs|s > +cp|p > ||cs +|cp|2= 1}\nw\n- Morphism\nHom_Hilb (x, x) : ˆ p, ˆ\np...\nx, ˆ x + ˆ\nHom_Hilb (y, y) : ˆE, e↵Eˆ2 ...\nHom_Hilb (x, y) : mˆ : |¢i >! |i >, i = 0, 1, 2...\nPhysics: phonon - photon mapping, massless, parKcle - wave duality\n\n|s>\n|0, p >\nCategory Hilb is monoidal\n- Physics: InteracKon of two system -‐> joint system\nMath: tensor product\n-‐> monoidal category\n⇤(y, z) = w\n- Monoidal category[2]\ni)\na category Hilb\nii)\na functor\n|1>\n⇤ : Hilb ⇥ Hilb ! Hilb\nPhysics: morphism is as important as\nobjects, so that we can form\nσ- ⇥ ˆ\n( ˆ\na+)(|p >, |0 >) = |s, 1 >\ninteracKon in the Hamiltonian\n\nCategory Hilb is monoidal\niii) a unit object\nC 2 Hilb\niv) le< unit law:\nla : C ⇥ a ! a\nright unit law:\nra : a ⇥ C ! a\nPhysics: states in Hilbert space is normalized.\nnatural isomorphism called the associator:\nContent removed due to copyright restrictions.\nTo view the diagram, go to: \"Section 4. The Monoidal Category of Hilbert Spaces\" by John Baez.\nhttp://math.ucr.edu/home/baez/quantum/node4.html\nsuch that the following diagrams commute for all objects A, B, C, D,\nv)\nContent removed due to copyright restrictions.\nTo view the diagram, go to: \"Section 4. The Monoidal Category of Hilbert Spaces\" by John Baez.\nhttp://math.ucr.edu/home/baez/quantum/node4.html\n\nCategory Hilb is monoidal\n- Associator is natural in a precise sense\nContent removed due to copyright restrictions.\n\nTo view the diagram, go to: \"Section 4. The Monoidal Category of Hilbert Spaces\" by John Baez.\nhttp://math.ucr.edu/home/baez/quantum/node4.html\nPhysics:\nS, T, L can be viewed as base transformaKon.\nThe diagram is commute indicates that associator is defined in a base\nindependent manner.\n\nFeynman diagram\n- states processed by\nevoluKon operators Exp(-‐iHt)\ninteracKon operators\no+ˆ\n( ˆ\noAaˆ+ + ˆ a)\nevoluKon operators\nto final states\n- This is true for all Hilbert spaces.\n- For one Hilbert space that has a specific interacKon form, one can also\ncategorize it alone.\n\nFeynman diagram[3]\n- Quantum harmonic oscillator represented in Fock space.\nCategorize Fock space to FinSet_0\nCategorize states to a functors from a Grp to FinSet_0\nInner Product: a Grp\nOperators: a Grp with two \"projecKon\" functors\ninto FinSet_0.\nDiagrams are taken from the paper \"Categorifying the Quantum Harmonic Oscillator\" by Jeffrey Morton and are used by permission.\n\nFeynman diagram\nKme evoluKon\nphonon creaKon and annihilaKon\nDiagrams are taken from the paper \"Categorifying the Quantum Harmonic Oscillator\" by Jeffrey Morton and are used by permission.\n\nFeynman diagram\naˆ+aˆ+aˆaˆ\n: atom-‐atom short range interacKon in our lab\nDiagrams are taken from the paper \"Categorifying the Quantum Harmonic Oscillator\" by Jeffrey Morton and are used by permission.\n\nConclusions and interests\n- Hilb has Hilbert space as objects, operators as morphisms\n- Hilb is a monoidal category\nQuantum systems can have interacKon with each other, joining together\nas a new system\n-\nMore than one way to categorize quantum systems\nCategorize Fock space into FinSet_0, due to observaKon of its\nrelaKonships with enumeraKve combinatorics.\n- Feynman diagram can be translated to diagrams in category.\n* Non-‐trivial morphism from finite Hilbert space to an infinite one or vice\nversa?\n* Benefit of Feynman diagram in category language?\n* Similarity of nCob and Hilb[4], relaKon of general relaKvity and quantum\nmechanics? Physics predicaKon?\n* Topological field theory, quantum gravity...\n\nBibliography\n[1] bci1, Hilb category of Hilbert spaces\nhMp://planetmath.org/sites/default/files/texpdf/41070.pdf\n[2] John Baez, The Monoidal Category of Hilbert Spaces, 2004\nhttp://math.ucr.edu/home/baez/quantum/node4.html\n[3] Jeffrey Morton, Categorifying the Quantum Harmonic Oscillator, 2006\nhMp://math.ucr.edu/home/baez/morton_ct06talk.ps\n[4] John Baez, Quantum Quandaries: A Category -‐TheoreKc PerspecKve, 2004\nhttp://arxiv.org/abs/quant-ph/0404040v2\n[5] David Spivak, Category Theory for ScienKsts, 2013\nhMp://arxiv.org/pdf/1302.6946.pdf\n[6] Bob Coecke, Kindergarten Quantum Mechanics, 2005\nhttp://arxiv.org/abs/quant-ph/0510032\n[7] John Baez, James Dolan, From Finite Sets to Feynman Diagrams, 2000\nhMp://arxiv.org/abs/math/0004133\n\nBibliography\n[8] John Baez, Mike Stay, Physics, Topology, Logic and ComputaKon: A\nRoseMa Stone, 2009\nhMp://arxiv.org/pdf/0903.0340v3.pdf\n[9] Chris Heunen, Categorical quantum models and logics, 2010\nhMp://books.google.com/books?\nid=nsd8EExdKIwC&printsec=frontcover#v=onepage&q&f=false\n[10] nLab\nhMp://ncatlab.org/nlab/show/HomePage\n\nThank you!\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6 &DWHJRU\\7KHRU\\IRU6FLHQWLVW\n6SULQJ 201\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Project: In search of a Monad",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/1920eed7eb325a4172a28b4aa7132b92_MIT18_S996S13_Monad.pdf",
      "content": "In search of a Monad for system call abstractions\nTaesoo Kim\n(Instructor: David Spivak)\nMIT CSAIL\nAbstract\nFor programmers, Monads are a well-known way to represent an abstract data\nstructure, but without knowing its true nature. Admittedly, the definition of Monads\nin Category Theory is too subtle and obscure so makes people to avoid from trying\nto understand them. In this paper, we attempt to explore popular Monads in a purely\nfunctional programming language, Haskell, with a Category-theoretic mindset.\nStarting from the definition of Monads, we describe how they are defined and\nimplemented in Haskell. In particular, we classify Monads by their implementation\nstyle, and it turns out that a common fallacy of using Monad metaphors can be\nunderstood in this vein. Also, we explain why IO Monad is particularly important in\nHaskell and what its role is, in a programmer's perspective. Furthermore, we design\na new Monad, called S Monad, in order to represent the system call abstractions,\nand shed light on a future Haskell OS using S Monad to represent the system call\nabstractions.\n1 Introduction\nMonads are too subtle to grasp their true meaning. To explain Monads, people proposed\nvarious metaphors like composable computations [3, 6], boxes [2], convey belts [11], or\neven burrito [19] and lemonade [14]. Those metaphors seem to help in understanding\none aspect of Monads, especially for beginners. Alas, when they start using Monads in\ndepth, what they understood via metaphors contradicts to each other, and even doesn't\nmake sense anymore. In this perspective, some people consider using metaphors in\nteaching Monads as a bad practice [17], or even as a common fallacy [19].\nAfter learning the basics of Category Theory, I want to write down own interpretation\nof Monads for working programmers, so they can understand the heart of Monads. In\nthis paper, we won't use metaphors to explain Monads; that makes people construct an\nabstract concept from example metaphors. Instead, this paper starts from an abstract\nknowledge and applies it to the concrete use cases. The main reason is as follows.\nSuppose you are learning about ducks. You might first want to find some species of\nducks 1. After researching what they eat, where they live, and how they look like, you\nmight have an idea of how they differ from each other and be able to explain what duck\nis. Suddenly, you might wonder about swans and geese, whether they are duck or not?\nor what are the differences from birds? In fact, duck is nothing but a name of animals\nwho walk and quark like a duck!\n\n(a) Wild Duck\n(b) Mandarin Duck\n(c) Pacific Black Duck\nFigure 1: If an object walks like a duck and quacks like a duck, we say it is a duck.\nLikewise, if a data type follows Monad rules, the data type is an instance of the Monad\ntype class.\nThe Monad is a term of abstractions that satisfy certain, but general, rules. Since\nrules are so general, Monads in fact are not very interesting until you describe a specific\ninstance of Monads, say Maybe or State Monad for example. As you can distinguish\nducks from tigers (tigers do not walk like a duck nor quack like a duck, for sure), you\ncan differentiate Monads from Set (yes, apples and oranges!). Also, it doesn't help in\nunderstanding Monads in details. In this paper, we rather admit the Monad as an abstract\nstructure first and then dive into the specific instances of them. Then, what are the rules\nand constituents for Monads? They at least give you a sense of \"not weird\", \"non-sense\"\nand so \"natural\", as a user. However, it is always fun to see how each Monad satisfies\nthose rules and what are the constituents, as we will discuss in §2.\nOutlilne This paper consists of three parts. First, we provide a way of understanding\nMonads, especially for system programmers, so hope to bridge some gaps between\nCategory Theory and a practice in Haskell (§2). Second, we articulate the necessity of\nIO Monad in Haskell (§3). Last, but most importantly, we propose a new Monad, called\nS Monad, to solve specific (yet practical) problems in the operating system, representing\nthe system call abstractions (§4).\n2 Monads\nFor programmers, a Monad is a consistent way of giving a semantic representation to\nan abstraction. We say \"consistent\" because a Monad consists of certain constituents\nand follow specific rules, \"semantic\" because each Monad has own goal in handing\nsituations such as uncertainty and side-effects, and \"abstraction\" because Monads (more\nprecisely, the Kleisli category of a Monad) abstract the idea of composition from users.\nIn other words, Monads generalize the idea by encapsulating the internal detail; an\ninterface as a simple term. Let's first see its definition in Category Theory [18] and\ncompare it with the realized code in Haskell.\nImage (a) Wild Duck appears courtesy of Kitkatcrazy. Source: Wikimedia Commons.\nImage (b) Mandarin Duck appears courtesy of Arpingstone. Source: Wikimedia Commons.\nImage (c) Pacific Black Duck appears courtesy of Fir0002/Flagstaffotos. Source: Wikimedia Commons.\n\n1 -- Monad type class: 'm' is a specific instance of Monads, like Maybe and State\n2 class Monad m where\nreturn :: a -> m a\n-- unit: construct a Monad\n(>>=)\n:: m a -> (a -> m b) -> m b -- bind: bind a Monad to a function\n-- useful functions (not strictly follow the definition of Monads in CT)\n(>>)\n:: m a -> m b -> m b\n-- weaving two instances of Monads\nfail\n:: String -> m a\n-- plan for failures of Monads\nFigure 2: Definition of the Monad type constructor in Haskell. In addition to unit\nand bind, the Monad class provides two more functions, a fail to escape out of the\ncomposed computations, and » to enforce orders. In particular, » can be implemented as\nma » mb = ma »= λ → mb in any Monad. Note that each Monad, m, should first be an\ninstance of the Functor class in Haskell.\n2.1 Definition\nDefinition 1. A Monad on Set consists of three constituents (A. fuctor, B. unit map,\nC. multiplication map) conforming to two laws (1. unit laws, 2. associativity laws) as\nfollows:\nA. a functor T : Set → Set\nB. a natural transformation η : idSet → T\nC. a natural transformation μ : T * T → T\n(See. two commutative diagrams for unit laws and associativity laws in the book [18])\nA functor First of all, Haskell is a category, called Hask in the literature [5]: objects\nare types (small sets per se) and homomorphisms are functions in Haskell. Interestingly\nenough, a polymorphic data type (kinds of ∗→∗ in Haskell) can be considered as a\nfunctor 1 For example, the Maybe and State are functors (in fact, they are instances of\nthe Functor class in Haskell), so we can use both for the first constituent of a Monad,\ntrivially.\nTwo natural transformations Second, given a functor, we still need to provide two\nmore constituents to make it as a Monad. Here is the place where two functions, return\n(unit) and »= (bind) in the Figure 2 play a role. In the Category-theoretic definition,\nthere is no bind function, rather it has a multiplication map, called join in Haskell.\nAlthough they are equivalent [13], we found a few reasons why Haskell prefers to use\nbind instead; free variables in Haskell's do-notation can be constructed by passing\nthem as arguments for subsequently composed functions; the implementation of bind\nis shorter than the one of join (we don't have to unwrap Monads for join); and some\nMonads such as the State Monad and the Cont Monad do not fit into the definitions\nof join very well. Note that Maybe and Exception Monads align to the definition of\njoin because threading two Monads is a good analogy in understanding Maybe and\nException. However, the State and Cont Monads are, in fact, a function so threading\ntwo functions is possible, but it is hard to get it intuitively.\n1Disclaimer. This is my personal opinion so it might be controversial or even incorrect.\n\nMonad\nSemantics\nT A\nDescribtion\nIdentity\nIdentity\nA\nReturn as it is, useful in Monad Transformers.\nMaybe\nError\nPartiality\nException\nA + {⊥}\nA + E\nReturn may not contain a value.\nReturn may contain some errors.\nList\nNon-determinism\nP (A)\nReturn can be one of multiple values.\nReader\nInput\nC ∗ + A\nComputations can read shared input.\nWriter\nOutput\nC ∗ × A\nComputations can write some output.\nCont\nContinuation\nR(RA)\nComputations can be interrupted.\nState\nSide-effects\n(A × S)S\nComputations maintain state.\nIO\nRealworld State\n(A × S)S\nComputations maintain IO state.\nA = Object P = Power-set E = Exceptions C = Set of characters S = Set of states\nTable 1: Short summary of example Monads available in the mtl Haskell library [1]\nwith their Category Theoretic semantics [15]. Monads are ordered based on their\nimplementation styles of the composition code, which we described in §2.2 more\ndetails.\nMonad Laws Third, Haskell doesn't have any safe mechanism (verification in compile\ntime) to catch violations of Monad laws. If a Monad instance syntactically provides all\nconstituents, Haskell considers it as a Monad. By convention, however, all Monads in\nthe standard libraries conform to the Monad laws, and also programmers expect it from\nany custom Monad as well.\n1. Left identity law: return x »= f == f x\n2. Right identity law: c »= return == c\n3. Associativity law: c »= ( λ x → f x »= g) == (c »= f) »= g\nLeft and right identity laws are basically the unit law in Category Theory. Those\nrules are trivially satisfied in most of \"sane\" data structures that represent an abstraction\nfor actual uses. Then, what do the rules mean for programmers in Haskell? It means\nthat the data type does not work weirdly when using it as a do-notation.\n2.2 Examples\nEach Monad is deserved for a few pages of an explanation, but in this paper, we will\nexplore Monads in terms of their implementation structures. In particular, metaphors of\none type of structures never fit well into the other types of structures, and importantly we\nbelieve this is the reason why people think using metaphors in understanding Monads is\na common fallacy to learn Monads.\nIn Table 1, we classified Monads based on their implementation styles of the bind\nfunction. The first type of Monads, from Identity to List, implements the composition\nas a value (kinds of ∗→∗ in Haskell), and the second type of Monads, from Reader\nto IO, implements them as a function (kinds of ∗→∗→∗ in Haskell). For example,\nthe constructor of the Maybe Monad (Maybe a in Figure 3(a)) abstracts a type a as a\n\nvalue, the State Monad (State s a in Figure 3(b)) embeds a type a in a function getting\na state s as an argument, even though its type signature is just State s a 2.\n1 data Maybe a = Nothing | Just a\n1 data State s a = State (s -> (a, s))\n3 instance\nMonad Maybe\nwhere\n3 instance Monad (State s) where\nreturn = Just\nreturn x = State $ \\s -> (x, s)\n...\n...\n(a) Maybe Monad\n(b) State Monad\nFigure 3: Maybe and State Monad in Haskell (simplified for clarity).\nWhy do I differentiate two types of Monads? It enables somewhat subtle implemen\ntation tricks. The first type of Monads uses a composition logic to combine two values,\nMonad instances, but the second type utilizes a composition logic to enforce orders.\nThe latter purpose becomes particularly important in IO Monad that we will see in the\nnext section, §3.\n3 IO Monad\nAmong various interesting features in Haskell, one that is remarkably different from\nother program languages is IO Monad. In fact, IO Monad is exactly same as the State\nMonad that enables computations to maintain state in the Monad compositions. Then,\nwhy Haskell has the definition of the IO Monad separately from the State Monad?\nAnswering this question is one of our goals in this section, and we will conclude it at\nthe end. Before going further, let's understand the role of the IO Monad in Haskell.\nHaskell is a purely functional programming language, in which there are no side-\neffects allowed. However, purely functional programs are useless in the real world; they\ncan not print out the computed results at all. For this reason, Haskell uses the IO Monad\nto interact with the real world, where there are full of dirty side-effects. A common\nway to understand benefits of using the IO Monad is with a tagging metaphor, thereby\nenforcing the clear separation of pure functions from the real world. With the IO Monad,\nall inputs and outputs from the real world are tagged with the IO type constructor. For\nexample,\n1 getLine :: IO String\ngetLine() inputs a line from a user and returns the line with the IO tag attached,\nIO String instead of String along. Since there is no way to drop the IO tag and extract\nthe actual String value, Haskell programs that want to access the String inside the\nIO String should use the standard Monad interfaces, »= (bind) and return (unit). In\nother words, without using the Monad interfaces, functions can not interact with the\nexternal worlds, and thus can maintain their pure functions that are separated from the\nreal world.\nIO Monad as tagging is not an incorrect way of describing its useful properties in\ngeneral, but it does not answer an important question, why IO Monad is particularly\n2For the purpose of juxtaposing two Monads, I simplified the code a lot because Haskell libraries implement\neach Monad by using a corresponding Monad Transformer with the Identity Monad.\n\n1 -- IO data constructor\n2 data IO a = IO (RealWorld -> (RealWorld, a))\n4 -- IO Monad instance\n5 instance Monad IO where\n-- unit: return the state with the input\nreturn x = IO $ \\s -> (s, x)\n-- bind: run the first computation and return the next one\n(>>=) (IO m) f = IO $ \\s ->\ncase m s of (s', a) ->\nunIO (f a) s'\nFigure 4: The implementation of IO Monad in Haskell (simplified for clarity).\nuseful, or even required, in Haskell. As we stated before, Haskell is purely functional\nso there are no side-effects allowed. Since every function does not have side-effects, it\nshould have the same return value whenever we call it with the same input arguments.\nThen, how can we implement the getLine() function in Haskell? getLine() might\nreturn different values whenever we call, depending on what users typed. The magic\nbehind the getLine() function is its type signature, IO String.\nAs we discussed in §2, the IO Monad is the second type as we classified, returning a\nfunction in its composition, so the return type, IO String, of getLine(), is a function.\nIn fact, given an argument (none!), getLine() consistently returns the same output\nvalue, the function, IO String. In other words, if we run getLine() with a state of the\nreal world, it will return one line that the user typed, along with the state of another\nworld. Let's see the actual implementation of the IO Monad in §3. In fact, the definition\nis exactly same as the one of the State Monad in Figure 3(b), except the IO Monad gets\nRealWorld instead of State as a state argument.\nWhat is RealWorld and how it differs from State? Surprisingly, unlike the State\ntype contains an arbitrary type s, the RealWorld type is nothing but its name, imple\nmented as below:\n1 data RealWorld\nThis kind of types is called a phantom type because it contains nothing, and used\nto enforce evaluation orders in the IO Monad. Since Haskell is a lazy (non-strict)\nlanguage, it never evaluates expressions until they are actually used. The laziness\nenables Haskell programs to skip unused expressions and thus gives some performance\nbenefits. However, it makes a programmer embarrassingly hard to write an imperative\ncode, which is, sadly, often required in system software programs.\nHow does Haskell enforce orders with the execution of Monads? Suppose we\nare implementing a function, three(), adding two return values of one() and two()\nfunctions, as in Figure 5(a) and Figure 5(d). Both implementations are clean and pure,\nbut for some reasons, we want to switch the evaluation orders of one() and two(). In C,\nthe program runs as written down in code (imperative), so swapping both statements\ndirectly changes the invocation orders, as in Figure 5(b). In Haskell, however, we need\nto use a Monad to thread the sequence of two computations (declarative and functional).\nIn Figure 5(e), the IO Monad of two() depends on the RealWorld state returned by the\n\n1 int one(void) {\n1 int one(void) {\n1 int one(void) {\nreturn 1;\nreturn 1;\nprintf(\"1\"); return 1;\n3 }\n3 }\n3 }\n4 int two(void) {\n4 int two(void) {\n4 int two(void) {\nreturn 2;\nreturn 2;\nprintf(\"2\"); return 2;\n6 }\n6 }\n6 }\n7 int three(void) {\n7 int three(void) {\n7 int three(void) {\nint a = one();\nint b = two();\nint a = one();\nint b = two();\nint a = one();\nint b = two();\nreturn a + b;\nreturn a + b;\nreturn a + b;\n11 }\n11 }\n11 }\n(a) Pure functions\n(b) Enforced orders\n(c) Side-effects (IO)\n1 one = 1\n1 one = return 1\n1 one = print 1 >> return 1\n2 two = 2\n2 two = return 2\n2 two = print 2 >> return 2\n3 three = a + b\n3 three = do\n3 three = do\nwhere a = one\nb <- two\na < one\nb = two\na < one\nb < two\nreturn (a + b)\nreturn (a + b)\n(d) Pure functions\n(e) Enforced orders\n(f) Side-effects (IO)\nFigure 5: Examples of code in C and Haskell to demonstrate three constructions;\ncomposing pure functions in (a) and (d); enforcing orders in (b) and (e); and embedding\nside-effects in (c) and (f). In all examples, three() invoke one() and two(), and returns\nthe sum of their return values.\nIO Monad of one(), and thus the sequence of invocations is enforced. In other worlds,\nall of the IO Monads are threaded via the RealWorld state that each Monad gets as an\nargument and returns as an output, thereby keeping the sequence of side-effects in the\nHaskell program, Figure 5(f).\nIn summary, the IO Monad is nothing but the State Monad but composing with the\nshared RealWorld state. Whereas the State can change its internal state, RealWorld\ndoesn't have an interface to change its state. Therefore, IO Monad can separate the\npure functions from the real world. In fact, RealWorld of the IO Monad is nothing (a\nphantom type) but to enforce the execution orders in a lazy language.\n4 S Monad\nSince Haskell has been defined and used for nearly 30 years now, there are a variety of\nattempts to use Haskell for writing system software programs: x86 assembler [4], web\nframework [7, 8], even OSes [9] or embedded systems [12]. All system programs use\nMonads, one way or another, to enable imperative style programmings in the purely\nfunctional and lazy Haskell programming language [16].\nHowever, their main purpose of using Monads is to make them easy to translate a\nalready-written imperative program to a working piece of Haskell code. For example,\nHouseOS [9], whose large body of the kernel logic is written in Haskell, defines H\nMonad to access hardware such as memory and registers in the x86 machine, but its\nbody in fact is just the IO Monad. Although H provides a proof of the memory safety,\nensuring that all memory operations never corrupt the Haskell heap, it was failed to\n\nescape the traditional interfaces that every commodity OSes strictly follows, the system\ncall abstraction.\nThe main purpose of using the system call abstraction in OSes is to provide the clear\nseparation of privileges between user processes (ring 3) and the kernel (ring 0), thereby\nprotecting the system from the failures of the user processes. In other words, the system\ncall abstraction is an interface to interact with the operating system. In the perspective\nof user programs, it is nothing but a list of available APIs that they can freely invoke.\nHere is a running example that we will explore in this section.\n4.1 Motivation\n1 // exit if file is not writable\n2 if (access(\"file\", W_OK) != 0) {\nerr(1, \"access\");\n4 }\n6 // open file and write buf to the file\n7 fd = open(\"file\", O_WRONLY);\n8 write(fd, \"hello world\", 12);\n9 close(fd);\nFigure 6: A code snippet to open a file and write a string to it, if the file is writable.\nThe example code invokes four system calls in order; access() to check if a file\npath is writable; open() to create a corresponding file descriptor; write() to write a\nstring buffer to a filesystem; and finally close() to close the opened file descriptor. This\nis a very simple code snippet, but there are a few interesting properties to be explained\nbefore going further.\nFirst of all, any system call can fail; they are dealing with a fragile hardware for\nus. For example, access() can fail if the path is not writable, and write() can also\nfail if the disk is full. In the above code, the error condition of access() is properly\nhandled, but the code is still vulnerable to the failures of open(), write() and close().\nIt is common to ignore error checking in software programs, because humans are lazy\nand importantly it rarely occurs in practice, like out-of-memory or lack of disk storage\nfor example.\nSecond, those system calls encode error conditions inconsistently: access() returns\n-1 on errors, and open() returns a negative integer on errors. It is hardly consistent\nin embedding a failure (called a bottom condition, ⊥) in the return type, Int, of each\nsystem call, so they use a special global variable errno to inform user programs. For\nexample, errno of open() can contain EEXIST if a file already exists, and ENOMEM if the\nOS is out of system resources.\nThird, the system state can change during the execution of a user program, thereby\nmaking it vulnerable to the time-of-check-to-time-of-use (TOCTOU) attacks. The above\ncode, in fact, is insecure, so should not be used in a production code. For example, if an\nattacker can interleave between access() and open() system calls, and link a private\nfile to the one that this program is going to overwrite, then the attacker can successfully\ndelete any user's private file, without acquiring user's permission.\n\n4.2 Properties\n1 main = do\nerr <- runS $ do\naccess \"file\" W_OK\nfd <- open \"file\" O_WRONLY\nwrite fd \"hello world\"\nFigure 7: An ideal implementation of the running example in Haskell.\nSuppose we have an imaginary Monad to solve above problems, and call it the S\nMonad. Using the S Monad, the example code becomes simple and clean--the second\ndo block runs S Monad and returns err to abstract possible errors. In the syntax wise,\nwe at least need neither trivial error handling, nor manual de-allocation of the opened\nfile descriptor in the S Monad. Here is a list of benefits that we expect from the S\nMonad.\nUnified error handling. The S Monad should abstract the possible failures in system\ncalls, by using an Error Monad Transformer, ErrorT e m a. To handle errors uniformly,\nall system calls should return ErrorT SysErr S a, where SysErr represents an error\ntype when it fails, and a represents a return type of the system call, like a file descriptor.\nSince we embed the S Monad in the context of ErrorT, all computations stop imme\ndiately after any failure, unless programmers explicitly check errors from the system\ncalls.\nPrivileged execution. When executing the S Monad with runS, it changes its privilege\nfrom the user mode (ring 3) to the kernel mode (ring 0), and unwraps the Monad with\ntwo states, OSState and UProcState. In other words, the composed S Monads executes in\nthe context of the kernel mode (ring 0), and thus can avoid the cost of context switching\nbetween privileged code and the user space. Since the S Monad is well-managed and\nall errors immediately short-circuit to the user mode, user programs can not exploit the\nprivileged execution at any moment.\nTransactional execution. The S Monad executes as a single unit, whether all succeed\nor all fail (as one transaction). By using the S Monad, we can avoid the TOCTOU\nsecurity problem. If one of system calls failed, OSState is restored to the previous state\nin which runS initiated, like Software Transcational Memory (STM) [10]. If the whole\nS Monad succeed, OSState will be updated atomically, so other user processes will see\nOSState after that.\nAutomatically de-allocating resources. Instead of de-allocating the opened file de\nscriptors in C code, the S Monad should manage the life time of resources that the\ncurrent process created. This technique has been explored in terms of region-based\nanalysis, meaning that the life time of each resource is same as the life time of the\nregion it allocate that resource. By keeping track of the ownership of each resource\nand corresponding regions, the S Monad can automatically de-allocate process-specific\nresources like file descriptors [12].\n\n4.3 Toward implementation\nFirst two properties are immediately achievable with minor modifications in the Haskell\nstandard library, because ErrorT provides a standard way to lift a Monad for handling\nerrors and MonadIO allows any computation to embed IO with liftIO. However, last two\nproperties require to combine two discrete projects, namely Position [12] for reclaiming\nresources and STM [10] for enabling the transactional execution. In particular, Position\nencodes a number into the type as a type label (tagging), which is not known widely\nbut deserved to emphasize its importance. To adopt its structure in the S Monad,\nwe first need to verify what Position proposed can be applied in managing multiple\nresources simultaneously in the OS context. In addition, we need to verify that all of data\nstructures that STM provides, such as TArray and TQueue, are enough for constructing\nbasic primitives to represent OSState too. Here are the type signatures of the S Monad\nand related data structures that I expected from S Monad.\n1 -- types for system IO and return value\n2 data SysIO a\n= StateT (UProcState, OSState) IO a\n3 data SysRet a = ErrorT SysErr (SysIO a) a\n5 -- S Monad\n6 data S a = S {unS :: STM SysRet a}\n8 -- types definitions of each system call\n9 access :: Path -> IOMode -> SysRet Bool\n10 open\n:: Path -> IOMode -> SysRet Handle\n11 write\n:: Handle -> Path -> SysRet Int\n13 -- run S Monad atomically\n14 runS :: S a -> SysRet a\n15 runS m = atomically $ unS m\nFigure 8: The S Monad and related data types.\nThis paper never tells you about how to implement them, but realizing the idea of\nthe S Monad is my next project; it probably takes longer than a half year. Over the\ncourse of this journey, it was a great opportunity for me to formalize the goals, benefits,\nand possibility of the S Monad.\n5 Summary\nStarting from the Category-theoretic definition of Monads, we explored how they are\nimplemented in a purely functional programming language, Haskell. We also classified\nMonads by their implementation styles and it turns out that a common fallacy of using\nmetaphors for teaching Monads can be understood in this vein. Furthermore, we have\nfigured out why the IO Monad is particularly important in Haskell and what its roles\nare. Lastly, we proposed a new Monad, the S Monad, to represent the system call\nabstractions, and shed some light on the possibility in implementing a new Haskell OS\nin the future.\n\nReferences\n[1] mtl-2.1.2: Monad classes, using functional dependencies, 2013. http://hackage.haskell.org/\npackage/mtl-2.1.2.\n[2] HaskellWiki: Monads as containers, 2013. http://www.haskell.org/haskellwiki/Monads_as_\ncontainers.\n[3] HaskellWiki: Monad, 2013. http://www.haskell.org/haskellwiki/Monad.\n[4] The Potential Programming Language: A type-safe x86-64 systems programming language, 2013.\nhttp://potential-lang.org.\n[5] Haskell/Category theory, 2013. http://en.wikibooks.org/wiki/Haskell/Category_theory.\n[6] Haskell/Understanding\nmonads,\n2013.\nhttp://en.wikibooks.org/wiki/Haskell/\nUnderstanding_monads.\n[7] Yesod Web Framework for Haskell, 2013. http://www.yesodweb.com.\n[8] D. B. Giffin, A. Levy, D. Stefan, D. Terei, D. Mazieres, J. C. Mitchell, and A. Russo. Hails: protecting\ndata privacy in untrusted web applications. In Proceedings of the 10th USENIX conference on Operating\nSystems Design and Implementation, OSDI'12, pages 47-60, Berkeley, CA, USA, 2012. USENIX\nAssociation.\n[9] T. Hallgren, M. P. Jones, R. Leslie, and A. Tolmach. A principled approach to operating system\nconstruction in haskell. In Proceedings of the 10th ACM SIGPLAN international conference on\nFunctional programming, ICFP '05, pages 116-128, New York, NY, USA, 2005. ACM.\n[10] T. Harris, S. Marlow, S. Peyton-Jones, and M. Herlihy. Composable memory transactions. In Proceedings\nof the tenth ACM SIGPLAN symposium on Principles and practice of parallel programming, PPoPP '05,\npages 48-60, New York, NY, USA, 2005. ACM.\n[11] J. Hughes. Generalising monads to arrows. Science of Computer Programming, 37:67-111, 1998.\n[12] O. Kiselyov and C. chieh Shan. Position: Lightweight Static Resources: Sexy types for embedded and\nsystems programming. In Proceedings of the 8th Symposium on Trends in Functional Programming,\nTFP '07, 2007.\n[13] C. Mcbride and R. Paterson. Applicative programming with effects. J. Funct. Program., 18(1):1-13,\nJan. 2008. ISSN 0956-7968.\n[14] T. McGuire. Quote o' the day: Bestest monad metaphor ever!, 2013. http://maniagnosis.crsr.\nnet/2012/06/quote-o-day-bestest-monad-metaphor-ever.html.\n[15] E. Moggi. Notions of computation and monads. Inf. Comput., 93(1):55-92, July 1991. ISSN 0890-5401.\n[16] S. L. Peyton Jones and P. Wadler. Imperative functional programming. In Proceedings of the 20th\nACM SIGPLAN-SIGACT symposium on Principles of programming languages, POPL '93, pages 71-\n84, New York, NY, USA, 1993. ACM. ISBN 0-89791-560-7. doi: 10.1145/158511.158524. URL\nhttp://doi.acm.org/10.1145/158511.158524.\n[17] D. Spiewak.\nMonads are not metaphors, 2013.\nhttp://www.codecommit.com/blog/ruby/\nmonads-are-not-metaphors.\n[18] D. Spivak. Category theory for scientists. 2013.\n[19] B.\nYorgey. Abstraction, intuition, and the \"monad tutorial fal-lacy\", 2013.\nhttp://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad\ntutorial-fallacy.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6 &DWHJRU\\7KHRU\\IRU6FLHQWLVW\n6SULQJ 201\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "18.S996S13 Project: Proving Causality In Social Science",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/18-s996-category-theory-for-scientists-spring-2013/a9f2a10cc75e30365207f9c81cb9ccf5_MIT18_S996S13_ProCausality.pdf",
      "content": "PROVING CAUSALITY IN SOCIAL\nSCIENCE: A POTENTIAL APPLICATION OF\nOLOGS\n\nBy Noam Angrist\n\nTHE GOALS OF SOCIAL SCIENCE\nExplain the world around us. What is really happening and why.\nExample: do Kindles boost test scores?\nImage courtesy of Dekuwa on Flickr. Available CC BY-NC-SA.\n\nTHE GOALS OF SOCIAL SCIENCE\nDid the Kindle intervention work?\nBefore\nAfter\nAverage for students with Kindles\n\nWHAT'S WRONG WITH THIS?\nSome (not all) Key Biases:\n\n(1) Self Selection Bias\n(2) Omitted Variable Bias\n(3) Attrition Bias\n(4) Counterfactual\nRich\n\nKindle Program\n\nTest Scores\n\nCONVENTIONAL METHODS OF ADDRESSING\nBIASES\nAdd a control group - addresses counterfactual\nbias\nBefore\nAfter\nKindle\nControl\n\nMATHEMATICAL-BASED METHODS OF\nADDRESSING BIASES\nEconometrics\n\nA) Regressions\n\nB) Controlling\n\nC) Instrumental variables\n\nD) Randomized trials\n\nE) Other methods\nWoodridge, Jeffrey M. Introductory Econometrics: A Modern Approach.\nCengage Learning, 2008. (c) Cengage Learning. All rights reserved.\nThis content is excluded from our Creative Commons license. For\nmore information, see http://ocw.mit.edu/fairuse.\n\nSIMPLE LINEAR REGRESSION: OVERVIEW\n\n(xi x)\n\n(yi y)\n(xi x)2\n\ny x\nwhere\nYi Xi i\nSlope\nIntercept\nResidual\n\nSIMPLE LINEAR REGRESSION: DERIVATION\n,\nminQ(,)\nThe goal is to minimize the sum of square residuals\nin order to find the line of best fit:\nwhere\n\nQ(,)\ni\ni1\nn\n\n(y xi)2\ni1\nn\n\nb\n(y ixi)2\ni1\nn\n\na\n(y ixi)2\ni1\nn\n\n1)\n2)\n\nSIMPLE LINEAR REGRESSION: DERIVATION\n\na\n(y ixi)2\ni1\nn\n\n1)\n\n2(yixi)(1)\ni1\nn\n\n(yixi)\ni1\nn\n\nyin\nxi\ni1\nn\n\ni1\nn\n\ny x\n2)\n\n2(y ixi)(xi)\ni1\nn\n\n(yixi xi xi\n2)\ni1\nn\n\nxiyi\nxi\n\nxi\ni1\nn\n\ni1\nn\n\nPlug in alpha from equation (1) into equation (2):\n\nSIMPLE LINEAR REGRESSION: DERIVATION\n\nxiyi\nxi\n\nxi\ni1\nn\n\ni1\nn\n\ny x\n1)\n2)\n\nxiyi(y x)\nxi\n\nxi\ni1\nn\n\ni1\nn\n\nxiy inyx\ni1\nn\n\nxi\n2 nx 2\n\nSIMPLE LINEAR REGRESSION\n\n(xi x)\n\n(yi y)\n(xi x)2\n\ny x\nYi Xi i\nSlope\nIntercept\n\nY\nX\n\nSIMPLE LINEAR REGRESSION: AN EXAMPLE\nDoes a kindle club (as described before) boost test\nscores?\n\nLet's find out!\n\nYi Xi i\nwhere\n\nY2 testscores\nXi participatinginKC\nDependent\nVariable\n\nIndependent\nVariable\n\nREADING PROGRAM: TEST SCORES\nThus, we have:\n.213468\n.244532\nResult:\n\nParticipation in the Kindle Club results in an\nincrease of .2134 on standardized test scores\nrelative to all students in the school (everyone\nelse increased around .22 naturally)\nWhere:\n\ndiff is the difference in test\nscore over 8 weeks\n\nand\n\nKc is a dummy variable that\nequals 1 id a student\nparticipated in the club and\n0 if they didn't\n\nECONOMETRICS: CONTROLLING\nYi i,1Xi,1 i,2Xi,2 i,3Xi,3 i,nXi,n i\nI expand the simple linear regression to include more independent (or\npredictor) variables:\nMultiple regression allows me to control for certain characteristics (i.e. I\ncan determine relationships holding/given certain variables constant).\n\nThis takes into account covariance among variables.\nIntuition: conditional probabilities\n\nREADING PROGRAM: CONTROLLING\nI control for (1) income status and (2) grade level:\nResult: our\nestimate for\nimpact of kindle\nclub participation\non test score\nincrease relative\nto the whole\nschool goes up by\n.04\nExplanation 1: free lunch, harder to improve, so had more kids with\nfree lunch such that when we control, we have a higher impact\nExplanation 2: higher grade level, less room for improvement since\nhigher baseline so we had more kids at a higher grade level in group\n\nDID IT WORK!?\nMore issues\n\nOmitted Variable Bias\n(can't control for everything) - factors not included in\nregression which impact independent and dependent\nvariable\nSelection Bias\nAttrition bias\n\nECONOMETRICS: INSTRUMENTAL VARIABLES\n\nBirth Date\n\nGender\n\nTwins\nExamples of Zi\nCausal Outcome\n\nReturns of an extra year\nof schooling\n\nTitle IX affect on labor\nmarket outcomes\n\nFamily size effect on\nschooling\n\nECONOMETRICS: INSTRUMENTAL VARIABLES\nUsing a random variable to \"instrument\" for causality\nsuch that Z has no correlation with Y outcome\nvariable, but is highly correlated with X such that you\ncan attribute a causal impact of X on Y\n\nYi Zi i\nYi Xi i\n\nCov(Zi,i) 0\n\nCov(Zi,Xi) 0\nWhere\nand\n\nECONOMETRICS: RANDOMIZED TRIALS\nProgram design: randomly assign treatment and\ncontrol group (like clinical trials in medicine) - eliminates\nmotivation/demographics biases in intervention\nIn this case Zi can act as an instrumental variable since\nour treatment dummy variable is determined by random\nlottery\nYi Zi i\nNow, β has a casual interpretation, not just correlation\n\nUSING RANDOM ASSIGNMENT FOR IV APPROACH\n\nAdd a random control group - addresses\ncounterfactual bias, omitted variable bias, self-\nselection\nBefore\nAfter\nKindle\nControl\n\nREADING PROGRAM: RANDOMIZED TRIAL\nI regress the dummy treatment variable X (1 if randomly selected into\nthe KC, 0 if randomly not selected) on the difference in test scores after\n8 weeks\nResult: our\nestimate for\nimpact of kindle\nclub on test score\nincrease is .26 of\na reading level\n(causal since\nrelative to random\ncontrol group)\nNote 1: this is a rigorous result. Also, notice that the regression with\ncontrols yields a result closest to the controlled regression\nNote 2: it is critical to check for statistical significance\nNote 3: measuring intention to treat effect, so underestimate of impact\n\nIS CATEGORY THEORY USEFUL FOR SOCIAL\nSCIENTISTS?\n\nSO WHERE DOES CATEGORY THEORY COME\nIN?\nDefining and determining Omitted Variable Bias\nthrough some comprehensive olog\nRich\n\nKindle Program\n\nTest Scores\n\nSafe\nNeighborhood\nTestSctoresi Kindlei,1Xi,1Richi,2Xi,2 SafeNeighborhoodi,3Xi,3 i\n\nONE POTENTIAL OLOG: KINDLES AND TEST SCORES...WHICH\nDOESN'T WORK BUT IS USEFUL NONETHELESS (NOT\nFUNCTIONS FROM SETS TO SETS)\nA Kindle\nF&P reading\nscores\nBooks\nenables students to read\nthrough exposure to reading increases\nA person from a\nwealthy family\nA safe\nneighborhood\nGrade\nLevel\nTest\npreparation\nSpace to study\neffectively\nhas access to\nhas access to affects ability to improve\nincreases\nlives in\nhas\nThrough more study time increases can purchase\n\nA REAL OLOG\n\nA pair (u,v) where\nu and v are\ndistinct students\nA number\nA pair of scores\n(s1', s2') for one\ntest\nA pair of scores\n(s1, s2) for one\ntest\nf\ng\nThe difference\nThe difference\nf: sends v to a bad school without a Kindle; send u to a good school without a Kindle.\ng: send v to a bad school with a Kindle; send u to a good school with a Kindle.\nNote: choose a global variable which captures effects from other variables\n\nWHAT CAN I CONCLUDE FROM THIS OLOG?\nCreating an olog helps the social scientist think through\nthe various processes and factors which might affect our\noutcomes of interest\n\nThere are multiple sources of omitted variable bias\nThe process of creating an olog helps a scientist determine a\ncomprehensive system which can includes as many factors\nas the social scientist deems relevant\n\n\"A wealthy family\" captures many of the omitted\nvariables, seen by the connecting arrows\nthus controlling for having a wealthy family should yield\nestimates close to those causal estimated using a\nrandomized controlled trial\n\nREADING PROGRAM: CONTROLLING\nI control for (1) income status and (2) grade level:\n\nINSTRUMENTAL VARIABLES APPLICATION USING\nOLOGGY-LIKE STUFF (ANOTHER BROKEN BUT\nUSEFUL OLOG)\nTwins\nZ\n\nX\n\nY\nFamily Size\nA person in a\nwealthy family\neducation level of\na child\nincrease\nthrough dividing up resources\nper child affects has access to\nBirth control influences\ncan\nafford\ngoing\nto\nA type of\nschool\nyields\n\nCONCLUSION\nIf we design ologs before our analysis phase we\ncan make sure that:\n(1) we come up with credible instrumental variables\n(2) when we control for all relevant variables that might\nhave otherwise been omitted and determine which\nvariables can proxy for others\nThis is important because:\nRandomized trials are expensive and we often resort to\ncontrolling as an alternative option to determine causal\nrelationships\nIn the absence of randomized trials, we also need good\ninstruments to determine causal relationships\n\nQUESTIONS/COMMENTS\nImage by MIT OpenCourseWare.An illustration of a man leaning against a question mark.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n18.S996 Category Theory for Scientist\nSpring 2013\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    }
  ]
}