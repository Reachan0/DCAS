{
  "course_name": "Software Construction",
  "course_description": "6.005 Software Construction introduces fundamental principles and techniques of software development, i.e., how to write software that is safe from bugs, easy to understand, and ready for change. The course includes problem sets and a final project. Important topics include specifications and invariants; testing; abstract data types; design patterns for object-oriented programming; concurrent programming and concurrency; and functional programming.\nThe 6.005 website homepage from Spring 2016, along with all course materials, is available to OpenCourseWare users.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Algorithms and Data Structures",
    "Computer Networks",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Algorithms and Data Structures",
    "Computer Networks",
    "Software Design and Engineering"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1.5 hours / session\n\nRecitations: 1 sessions / week, 1 hour / session\n\nCourse Description\n\n6.005 Software Construction\nintroduces fundamental principles and techniques of software development, i.e., how to write software that is safe from bugs, easy to understand, and ready for change. Topics include specifications and invariants; testing, test-case generation, and coverage; abstract data types and representation independence; design patterns for object-oriented programming; concurrent programming, including message passing and shared concurrency, and defending against races and deadlock; and functional programming with immutable data and higher-order functions. Includes weekly programming exercises and larger group programming projects.\n\nThe\n6.005 website homepage\nfrom Spring 2016, along with all course materials, is available to OpenCourseWare users.\n\nClass\n\nClass meetings\n\nThere are two 90-minute class meetings each week on Monday and Wednesday and one 1-hour class meeting each week on Friday. You are expected to attend all class meetings and to participate actively in exercises and discussions.\n\nLaptops required\n\nClasses will include multiple-choice questions and programming exercises that require a laptop.\n\nReadings\n\nMost classes will have a reading that you must read before coming to class. There is no course textbook.\n\nNanoquizzes\n\nEvery class meeting will begin with a short quiz on the required reading for the class, plus recent class meetings. Nanoquizzes are closed-book and closed-notes, with a 3-minute time limit. There will be approximately 25 nanoquizzes. Your lowest 5 nanoquiz grades will be automatically dropped, and you can make up missed nanoquizzes or low grades. More info can be found on the\nnanoquiz grading and makeup\npage.\n\nProject\n\nYou will complete a group software development project at the end of the semester. The project will be done in teams of three students. Each team member is required to participate roughly equally in every activity (design, implementation, test, documentation), and we may ask for an accounting of what each team member did. A single grade will be assigned to all members of the team.\n\nTeam Meetings\n\nDuring the project, you and your project team will meet with your Teaching Assistant to discuss the work. Your TA will assign a grade based in part on this meeting. Team meetings will usually be scheduled during class times that will be reserved for this purpose.\n\nQuizzes\n\nThere will be two quizzes, on dates specified on the course calendar. Each quiz will be comprehensive, drawing on any topics covered up to that point in the course, so e.g. Quiz 2 may include topics that were already covered on Quiz 1.\n\nQuizzes are closed-book, but you may bring a single 8.5×11\" double-sided page of notes, readable without magnification, that was created by you. Since the process of creating a crib sheet is most of its benefit, you may not share these notes or use someone else's.\n\nAn\narchive of past quizzes\nis available.\n\nGrading Policy\n\nGrades will be roughly computed as follows:\n\nACTIVITIES\n\nPERCENTAGES\n\nQuizzes\n\n30%\n\nProblem Sets\n\n50%\n\nProject\n\n10%\n\nCode Review\n\n5%\n\nParticipation\n\n5%\n\nLetter grades are determined at the end of the semester. The default cutoffs are: a final average of 90 and above is an A, 80 and above is a B, 70 and above is a C. These boundaries may be adjusted downwards if necessary because of the difficulty of the assignments or quizzes, but the boundaries will never be adjusted upwards, so a final average of 90 is guaranteed to be an A. The boundary adjustment is done heuristically, and there are no grade quotas, no grade targets, and no centering of the class on a particular grade boundary.\n\nEvery student is considered individually in the final grading meeting, judging from their entire performance in the course. A single bad mark in an otherwise consistent record will often be discounted.\n\nProblem Set Grading\n\nThe overall grade for a problem set will typically be computed as follows:\n\noverall grade = 40% × beta-autograde + 45% × final-autograde + 15% × manual-grade\n\nwhere beta-autograde and final-autograde are determined by automated tests, and manual-grade is determined by graders reading the code. One part of manual-grade is fixing code in response to code reviews.\n\nThe breakdown may vary by 5-10% from problem set to problem set, depending on how much of the problem set can be autograded and how much requires human eyes. Each problem set's breakdown will be announced when final grades are released.\n\nProblems Sets, Beta & Final Problem Set Deadlines, and Slack Days\n\nProblem Sets\n\nTo consolidate your understanding of the ideas from class, you will do five problem sets, PS0 to PS4, involving both design and implementation work. Problem sets will be done individually. Please review the page on\ncollaboration on problem sets\n.\n\nCode review\n\nAs part of each problem set, there will be a 2-day code-reviewing period when other students and staff will give you feedback about the code you submitted, using a web-based system. You will be expected to participate in this process by reviewing some of your classmates' code. More details about objectives and guidelines for the\ncode reviewing\nprocess are available.\n\nBeta and final submission\n\nEach problem set will have beta and final submission. The beta submission will be graded by an automated tester, and will be subject to code review. The final submission is due a week later. You will be expected to fix any failed test cases and revise your code based on code review feedback.\n\nThe final submission must address all the code reviews received by the beta submission - all the human comments plus all the automated checkstyle comments that are marked #important. You can address a code review either by changing the code to reflect the review or by including a source code comment in your code that explains why the code wasn't changed. If code reviews are unclear, you can discuss them with the reviewers, but you still must edit your own code in reaction to the review. A grader will check the submission and deduct points if it hasn't addressed the code reviews.\n\nSince the final submission inevitably happens after code review for the problem set, it's understood that you've looked at other students' written solutions, and been inspired by other ways to solve the problems. You must be exceedingly scrupulous, therefore, in not using those written solutions during your revision. Both your original code and your revised code must be your own. Looking at other students' answers to the problem set while you are revising your solution will be considered a violation of the\ncollaboration policy\n.\n\nCollaboration and Public Sharing\n\nIn line with MIT's policy on academic honesty, please review the detailed page on\ncollaboration and public sharing.\n\nFAQ\n\nWhy is this course structured the way it is?\n\nPractice and feedback are key to learning, and the course is structured to provide as many opportunities for practice and feedback as possible. That means we don't want to spend class time on lectures, we want to spend it on exercises to practice the concepts and skills of building software.\n\nCitations:\nWieman et al.,\nCourse Transformation Guide\n·\nDeslauriers et al.,\nImproved Learning in a Large-Enrollment Physics Class\n\nWhy is attendance in class required?\n\nClass meetings are all about practice and feedback . The individual, pair, and small group questions, exercises, and coding problems we work on in class, and the discussions and feedback led by instructors, are a required component of this class.\n\nClass is like swim/judo/math team practice: you don't get good unless you show up, and practicing with others is a necessary complement to practicing alone.\n\nWhy are we sometimes asked to close laptops during class?\n\nYour laptop is a necessary tool for in-class programming, but it also presents a huge opportunity for distraction. The price of that distraction is paid not only by you, but by all those around you who can see your screen. In one study linked below:\n\nFor note-takers with laptops, multi-tasking led to a 11% drop in comprehension test scores.\n\nFor note-takers without laptops, merely having a laptop multi-tasker in their field of view led to a 17% drop in comprehension test scores!\n\nIf you want to use a smartphone in your lap, so that the screen is not visible and not distracting to others, we have no objection, but you'll still be hurting yourself.\n\nCitations:\nSana et al.,\nLaptop multitasking hinders classroom learning for both users and nearby peers\n·\nMueller and Oppenheimer,\nThe Pen Is Mightier Than the Keyboard\n\nHow is participation in class graded?\n\nIn general, participation in class is graded based on whether you attempted the questions, exercises, coding problems, etc., not on correctness.\n\nProgramming exercises are graded based on whether you've attempted the exercise and made some progress, even if you don't complete it. You are not expected to complete unfinished exercises after class, but TAs and LAs will be happy to help you review or finish them.\n\nWhy do I need to read the readings and complete the reading exercises the night before coming to class?\n\nReading the material before class prepares you to spend class time practicing the concepts and skills you're learning. Reading in advance gives you time to think and ask questions, and repeated exposure to material spaced out over time improves learning.\n\nSee:\nSpacing effect\n\nWhy does the class have nanoquizzes on topics before we practice them in class?\n\nNanoquizzes assess whether you did the reading and practiced with the reading exercises before coming to class, and they provide feedback to you on your comprehension. Nanoquizzes are themselves part of the practice we do in class: recalling information from the readings benefits learning more than just re-reading or re-hearing it.\n\nSee:\nTesting effect",
  "files": [
    {
      "category": "Exam",
      "title": "Quiz 1",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-software-construction-spring-2016/1f33f4c51693fb6d295e334f28bfc225_MIT6_005S16_Quiz1.pdf",
      "content": "MIT\n6.005: Software Construction\nMax Goldman\nrevised Sunday 13th March, 2016, 15:30\nQuiz 1 (March 14, 2016)\nYour name:\nYour Athena username:\nYou have 50 minutes to complete this quiz. It contains 12 pages (including this page) for a total\nof 100 points.\nThe quiz is closed-book and closed-notes, but you are allowed one two-sided page of notes.\nPlease check your copy to make sure that it is complete before you start. Turn in all pages,\ntogether, when you finish. Before you begin, write your name on the top of every page.\nPlease write neatly. No credit will be given if we cannot read what you write.\nFor questions which require you to choose your answer(s) from a list, do so clearly and unam-\nbiguously by circling the letter(s) or entire answer(s). Do not use check marks, underlines, or\nother annotations - they will not be graded.\nGood luck!\nDO NOT WRITE BELOW THIS LINE\nProblem\nPoints\nGrade\nGrader\n1: Multiple Choice\n2: Specifications\n3: AFs & RIs\n4: Testing\n5: Rep Exposure\nTotal\nThis course makes use of Athena, MIT's UNIX-based computing environment.\nOCW does not provide access to this environment.\n\nYour name:\nQuiz 1 (March 14, 2016)\nProblem 1 (Multiple Choice) (20 points).\n(a) Which of the following must be true of an underdetermined function specification? (choose all that\napply)\nA. An underdetermined spec means the implementation is unwritten.\nB. An underdetermined spec means the implementation is nondeterministic.\nC. An underdetermined spec allows multiple valid outputs for some input.\nD. An underdetermined spec allows multiple valid inputs that give some output.\n(b) After the following code is executed, what is the value of array arr? (choose one answer)\nfinal String[] arr = new String[2];\nString s = \"6.005\";\narr[0] = s;\ns = \"is\";\narr[1] = s;\nString t = arr[0];\nt = \"fun\";\nA. [ \"is\", \"is\" ]\nB. [ \"6.005\", \"is\" ]\nC. [ \"fun\", \"is\" ]\nD. none of the above\n(c) The line of Java code String t = arr[0]; involves... (choose all that apply)\nA. assignment\nB. equivalence relation\nC. mutation\nD. static typing\n\nQuiz 1 (March 14, 2016)\nYour name:\n(d) Alyssa P. Hacker is designing an immutable type to represent users in her computer system. The User's\nlogin name is stored as:\nprivate final String kerberos;\nShe defines two User objects as equal if their login names are the same, ignoring case:\n@Override public boolean equals(Object other) {\nif (!(other instanceof User)) { return false; }\nUser that = (User)other;\nreturn this.kerberos.equalsIgnoreCase(that.kerberos);\n}\n@Override public int hashCode() { /* TODO */ }\nWhich of the following implementations of hashCode() would be valid, satisfying the Object contract?\n(choose all that apply)\nA. return 31;\nB. return this.kerberos.hashCode();\nC. return this.kerberos.toLowerCase().hashCode();\nD. return this.kerberos.toUpperCase().hashCode();\n(e) If the code in answer choice (A) above appeared in your 6.005 code review assignment, which of the\nfollowing comments would be appropriate criticisms? (choose all that apply)\nA. The code isn't DRY.\nB. The code uses magic numbers.\nC. The code exposes User's representation.\nD. The code is unnecessary, we don't need to override hashCode if we only return a constant.\n\nYour name:\nQuiz 1 (March 14, 2016)\nProblem 2 (Specifications) (20 points).\nA tetromino is a shape made out of four adjacent squares. These shapes are most famous from the game\nTetris where the player must rotate and translate falling tetrominoes in order to fit them together. There are\nseven possible tetrominoes that lie on the 2D plane, and each is identified by a letter it looks like:\nI\nO\nT\nJ\nL\nS\nZ\nDefine a tetromino shape letter as one of the seven letters I O T J L S Z, either upper- or lowercase.\nTetrominoes may be rotated by 0, 90, 180, or 270 degrees.\nA diagram of all seven tetrominoes in all four orientations is on the last page of this quiz.\nLet's define an abstract data type to represent tetrominoes:\npublic class Tetromino {\n// determine if a character is a valid tetromino shape letter\npublic static boolean isValidShape(char shape) { ... }\n// make a new tetromino\npublic Tetromino(char shapeLetter, int rotationDegrees) { ... }\n// rotate this tetromino\npublic void rotateClockwise() { ... }\n// get the shape of this tetromino\npublic char shape() { ... }\n}\n(a) Fill in this table with information about the operations of Tetromino.\nThe answers for isValidShape are already given.\noperation\ntype signature\nclassify the type of\nADT operation\nJava implementation\nstrategy\nisValidShape\nchar →boolean\nnot applicable\nstatic method\nTetromino\nrotateClockwise\nshape\n\nQuiz 1 (March 14, 2016)\nYour name:\n(b) Consider these different specifications for the isValidShape function:\npublic static boolean isValidShape(char shape)\n/**\n* @param shape any character\nSpec A\n* @return true iff shape is a lowercase tetromino shape letter\n*/\n/**\n* @param shape an English alphabetic character\nSpec B\n* @return true iff shape is a lowercase tetromino shape letter\n*/\n/**\n* @param shape a lowercase tetromino shape letter\nSpec C\n* @return true\n*/\nCompare these specifications. For each pair below, circle one correct option and write write a brief\nexplanation to complete the sentence.\nA vs. B:\nequivalent to\nweaker than\nSpec A is\nspec B because\nstronger than\nincomparable to\nB vs. C:\nequivalent to\nweaker than\nSpec B is\nspec C because\nstronger than\nincomparable to\n\nYour name:\nQuiz 1 (March 14, 2016)\nProblem 3 (AFs & RIs) (20 points).\nHere is an implementation of the Tetromino ADT.\n/** A rotatable tetromino. */\npublic class Tetromino {\n// ... static method isValidShape ...\nprivate final char shape;\nprivate int rotation;\n// Abstraction function\n//\nTODO\n// Representation invariant\n//\nTODO\n// Safety from rep exposure\n//\nTODO\n/**\n* Make a new Tetromino with the given shape and rotation.\n* @param shapeLetter uppercase tetromino shape letter\n* @param rotationDegrees clockwise rotation in degrees,\n*\nmust be 0, 90, 180, or 270\n*/\npublic Tetromino(char shapeLetter, int rotationDegrees) {\nthis.shape = shapeLetter;\nthis.rotation = rotationDegrees / 90;\n}\n/**\n* TODO\n*/\npublic void rotateClockwise() {\nrotation = (rotation + 1) % 4;\n}\n/**\n* @return shape of this tetromino: 'I' 'O' 'T' 'J' 'L' 'S' or 'Z'\n*/\npublic char shape() {\nreturn shape;\n}\n@Override\npublic String toString() {\nreturn shape + \"-shape@\" + rotation * 90 + \"deg\";\n}\n}\n\nQuiz 1 (March 14, 2016)\nYour name:\n(a) For each of the statements below, say whether it should be included in the internal documentation of\nTetromino by writing:\nAF if the statement belongs in the abstraction function\nRI\n...\nthe rep invariant\nEXP\n...\nthe argument that type has no rep exposure\nNONE if it should not be included in any of those\nYou should include in the AF, RI, or EXP all good statements that are compatible with the code and specs\non the previous page.\nDo not include statements that are not compatible with the code and specs.\nshape is private and an immutable value\nrotation is private and an immutable value\nthis Tetromino is never returned to clients\nshape is an uppercase tetromino shape letter\nshapeLetter is an uppercase tetromino shape letter\nthe tetromino has the shape given by shape\nrotation = 0\nthe tetromino is rotated clockwise by rotation\nthe tetromino is rotated clockwise rotation times 90 degrees\n0 <= rotation < 4\n0 <= rotation < 360\nrotation is one of { 0, 90, 180, 270 }\n\nYour name:\nQuiz 1 (March 14, 2016)\nConsider these different specifications for the rotateClockwise method:\npublic void rotateClockwise()\nFor each possible specification below, write a one-sentence code review comment that identifies the most\nserious problem with the spec.\n(b) /**\n* Update this tetromino's rotation number to add 1, mod 4.\n*/\nComment:\n(c) /**\n* @return this tetromino rotated by 90 degrees clockwise\n*/\nComment:\n(d) /**\n* Rotate this tetromino (does not otherwise modify the tetromino).\n*/\nComment:\n\nQuiz 1 (March 14, 2016)\nYour name:\nProblem 4 (Testing) (20 points).\nLet's consider the problem of packing tetrominoes into a rectangle by rotating and translating them in the\n2D plane. For example, here are tetrominoes I, L, & Z packed into a 5 × 4 rectangle, and a 7 × 2 rectangle:\nFor those three tetrominoes, the minimum area they can be packed into is 7 × 2 = 14 squares.\n(a) /**\n* @param shapes string of tetromino shape letters\n* @return a 2-element list representing a minimum-area rectangle into which\n*\nthe tetrominoes given by shapes can be packed\n*\n(for example, pack(\"ILZ\") might return the list [ 2, 7 ])\n*/\npublic static List<Integer> pack(String shapes) { ... }\nStart writing a black box testing strategy for pack(..) by giving one good partitioning for input shapes:\nFor each of the test cases below, in the first box write YES or NO in the first box to say whether the test\nvalid or not. If the test is not valid, write a one-sentence reason why not. We'll use Python's syntax to\nrepresent lists for brevity.\n(b) shapes = \"X\"\nrectangle = [ 0, 0 ]\nValid?\nReason if invalid:\n(c) shapes = \"I\"\nrectangle = [ 1, 4 ]\nValid?\nReason if invalid:\n(d) shapes = \"LO\"\nrectangle = [ 3, 3 ]\nValid?\nReason if invalid:\n\nYour name:\nQuiz 1 (March 14, 2016)\nProblem 5 (Rep Exposure) (20 points).\nLet's define a mutable abstract data type TetrominoGrid to represent tetrominoes arranged on a fixed-size\ngrid, where every tetromino fits on the grid and none of the tetrominoes overlap. For example:\nOn the next page is an implementation of TetrominoGrid. In its rep, TetrominoGrid stores the\nlocation of each tetromino using a map from integers to tetrominoes. The integer keys are square numbers:\nEach square in the grid is numbered starting from 0 in the upper-left corner.\nOn a grid of width width, square at row row and column col is numbered row × width + col.\nFor example, here's how our type would represent the example above:\nwidth = 5, height = 4\ntetrominoLocations = {\n0: (Tetromino: I-shape rotated 0 degrees),\n3: (Tetromino: L-shape rotated 0 degrees),\n6: (Tetromino: Z-shape rotated 90 degrees)\n}\nThe TetrominoGrid ADT is implemented using the same mutable Tetromino ADT from previous\nquestions.\n(a) Identify all instances of rep exposure in TetrominoGrid on the next page. For each one, write:\n1. the line number most directly responsible for the problem,\n2. at most one-sentence description of the rep exposure, and\n3. at most one-sentence description of how to fix the problem, or a single corrected line of code.\nThere may be more boxes than you need.\nLine #:\nExplanation:\nLine #:\nExplanation:\nLine #:\nExplanation:\nLine #:\nExplanation:\nLine #:\nExplanation:\n\nQuiz 1 (March 14, 2016)\nYour name:\nYou may detach this page from your quiz, but you must write your name above and turn in all pages.\n/**\n* Mutable type representing a fixed-size grid with a valid arrangement of\n* tetrominoes: every tetromino fits on the grid without overlapping.\n*/\npublic class TetrominoGrid {\n1)\nprivate final int width;\n2)\nprivate final int height;\n3)\npublic final Map<Integer, Tetromino> tetrominoLocations;\n// create a new grid and try to add some tetrominoes\npublic TetrominoGrid(int width, int height, List<Tetromino> initial) {\n4)\nthis.width = width;\n5)\nthis.height = height;\n6)\nthis.tetrominoLocations = new HashMap<>();\nfor (Tetromino tetromino : initial) {\n7)\nthis.add(tetromino.shape());\n}\n}\n// get the tetromino whose upper-left corner is the given square\npublic Tetromino getTetrimino(int row, int col) {\n8)\nreturn tetrominoLocations.get(row * width + col);\n}\n// return a list of all tetriminos currenty on the grid\npublic List<Tetromino> getTetriminosOnBoard() {\n9)\nList<Tetromino> tetrominoes = new ArrayList<>();\nfor (Tetromino tetromino : tetrominoLocations.values()) {\n10)\ntetrominoes.add(tetromino);\n}\n11)\nreturn Collections.unmodifiableList(tetrominoes);\n}\n// try to add a tetromino to the grid, if it can fit without overlap\npublic boolean add(char shape) {\n12)\nboolean canBePlaced = false; // can we fit the tetromino anywhere?\n13)\nint topLeft = -1;\n14)\nint rotation = 0;\n// ... code to check whether the new tetromino fits and doesn't overlap ...\n// ... updates the values of the local variables accordingly ...\nif (canBePlaced) {\n15)\ntetrominoLocations.put(topLeft, new Tetromino(shape, rotation));\n}\n16)\nreturn canBePlaced;\n}\n// ... other operations ...\n}\n\nYour name:\nQuiz 1 (March 14, 2016)\nYou may detach this page from your quiz, but you must write your name above and turn in all pages.\n0 degrees\n90 degrees\n180 degrees\n270 degrees\nI\nO\nT\nJ\nL\nS\nZ\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.005 Software Construction\nSpring 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Exam",
      "title": "Quiz 1 Solutions",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-software-construction-spring-2016/b041ab0cec88df93e808e908aca1af5f_MIT6_005S16_Quiz1_soln.pdf",
      "content": "MIT\n6.005: Software Construction\nMax Goldman\nrevised Wednesday 16th March, 2016, 14:08\nSolutions to Quiz 1 (March 14, 2016)\nProblem 1 (Multiple Choice) (20 points).\n(a) Which of the following must be true of an underdetermined function specification? (choose all that\napply)\nA. An underdetermined spec means the implementation is unwritten.\nB. An underdetermined spec means the implementation is nondeterministic.\nC. An underdetermined spec allows multiple valid outputs for some input.\nD. An underdetermined spec allows multiple valid inputs that give some output.\nSolution. C. None of the other options must be true.\n■\n(b) After the following code is executed, what is the value of array arr? (choose one answer)\nfinal String[] arr = new String[2];\nString s = \"6.005\";\narr[0] = s;\ns = \"is\";\narr[1] = s;\nString t = arr[0];\nt = \"fun\";\nA. [ \"is\", \"is\" ]\nB. [ \"6.005\", \"is\" ]\nC. [ \"fun\", \"is\" ]\nD. none of the above\nSolution. B. The reassignment of s to \"is\" or t to \"fun\" do not affect arr[0].\n■\n(c) The line of Java code String t = arr[0]; involves... (choose all that apply)\nA. assignment\nB. equivalence relation\nC. mutation\nD. static typing\nSolution. A, D. This line assigns to t, which has static type String.\n■\n(d) Alyssa P. Hacker is designing an immutable type to represent users in her computer system. The User's\nlogin name is stored as:\n\nSolutions to Quiz 1 (March 14, 2016)\nprivate final String kerberos;\nShe defines two User objects as equal if their login names are the same, ignoring case:\n@Override public boolean equals(Object other) {\nif (!(other instanceof User)) { return false; }\nUser that = (User)other;\nreturn this.kerberos.equalsIgnoreCase(that.kerberos);\n}\n@Override public int hashCode() { /* TODO */ }\nWhich of the following implementations of hashCode() would be valid, satisfying the Object contract?\n(choose all that apply)\nA. return 31;\nB. return this.kerberos.hashCode();\nC. return this.kerberos.toLowerCase().hashCode();\nD. return this.kerberos.toUpperCase().hashCode();\nSolution. A, C, D.\nA is correct, although not necessarily a good hash function.\nC and D are correct because Strings that are equal ignoring case will have the same value for both\ntoLowerCase() and toUpperCase().\nB is incorrect because two Users with with login names that differ only in case will have different hash\ncodes even though the User objects are equal.\n■\n(e) If the code in answer choice (A) above appeared in your 6.005 code review assignment, which of the\nfollowing comments would be appropriate criticisms? (choose all that apply)\nA. The code isn't DRY.\nB. The code uses magic numbers.\nC. The code exposes User's representation.\nD. The code is unnecessary, we don't need to override hashCode if we only return a constant.\nSolution. B. 31 is a magic number.\n■\nProblem 2 (Specifications) (20 points).\nA tetromino is a shape made out of four adjacent squares. These shapes are most famous from the game\nTetris where the player must rotate and translate falling tetrominoes in order to fit them together. There are\nseven possible tetrominoes that lie on the 2D plane, and each is identified by a letter it looks like:\nI\nO\nT\nJ\nL\nS\nZ\n\nSolutions to Quiz 1 (March 14, 2016)\nDefine a tetromino shape letter as one of the seven letters I O T J L S Z, either upper- or lowercase.\nTetrominoes may be rotated by 0, 90, 180, or 270 degrees.\nA diagram of all seven tetrominoes in all four orientations is on the last page of this quiz.\nLet's define an abstract data type to represent tetrominoes:\npublic class Tetromino {\n// determine if a character is a valid tetromino shape letter\npublic static boolean isValidShape(char shape) { ... }\n// make a new tetromino\npublic Tetromino(char shapeLetter, int rotationDegrees) { ... }\n// rotate this tetromino\npublic void rotateClockwise() { ... }\n// get the shape of this tetromino\npublic char shape() { ... }\n}\n(a) Fill in this table with information about the operations of Tetromino.\nThe answers for isValidShape are already given.\noperation\ntype signature\nclassify the type of\nADT operation\nJava implementation\nstrategy\nisValidShape\nchar →boolean\nnot applicable\nstatic method\nTetromino\nchar×int→Tetromino\ncreator\nconstructor\nrotateClockwise\nTetromino →void\nmutator\ninstance method\nshape\nTetromino →char\nobserver\ninstance method\n(b) Consider these different specifications for the isValidShape function:\npublic static boolean isValidShape(char shape)\n/**\n* @param shape any character\nSpec A\n* @return true iff shape is a lowercase tetromino shape letter\n*/\n/**\n* @param shape an English alphabetic character\nSpec B\n* @return true iff shape is a lowercase tetromino shape letter\n*/\n\nSolutions to Quiz 1 (March 14, 2016)\n/**\n* @param shape a lowercase tetromino shape letter\nSpec C\n* @return true\n*/\nCompare these specifications. For each pair below, circle one correct option and write write a brief\nexplanation to complete the sentence.\nA vs. B:\nequivalent to\nweaker than\nSpec A is\nspec B because\nstronger than\nincomparable to\nSolution. Spec A is stronger than spec B because its precondition is weaker and its postcondition is the\nsame.\n■\nB vs. C:\nequivalent to\nweaker than\nSpec B is\nspec C because\nstronger than\nincomparable to\nSolution. Spec B is stronger than spec C because it has a weaker precondition, and it satisfies C's postcon-\ndition for any input that satisfies C's precondition.\n■\nProblem 3 (AFs & RIs) (20 points).\nHere is an implementation of the Tetromino ADT.\n/** A rotatable tetromino. */\npublic class Tetromino {\n// ... static method isValidShape ...\nprivate final char shape;\nprivate int rotation;\n// Abstraction function\n//\nTODO\n// Representation invariant\n//\nTODO\n// Safety from rep exposure\n//\nTODO\n/**\n* Make a new Tetromino with the given shape and rotation.\n* @param shapeLetter uppercase tetromino shape letter\n* @param rotationDegrees clockwise rotation in degrees,\n*\nmust be 0, 90, 180, or 270\n*/\npublic Tetromino(char shapeLetter, int rotationDegrees) {\n\nSolutions to Quiz 1 (March 14, 2016)\nthis.shape = shapeLetter;\nthis.rotation = rotationDegrees / 90;\n}\n/**\n* TODO\n*/\npublic void rotateClockwise() {\nrotation = (rotation + 1) % 4;\n}\n/**\n* @return shape of this tetromino: 'I' 'O' 'T' 'J' 'L' 'S' or 'Z'\n*/\npublic char shape() {\nreturn shape;\n}\n@Override\npublic String toString() {\nreturn shape + \"-shape@\" + rotation * 90 + \"deg\";\n}\n}\n(a) For each of the statements below, say whether it should be included in the internal documentation of\nTetromino by writing:\nAF if the statement belongs in the abstraction function\nRI\n...\nthe rep invariant\nEXP\n...\nthe argument that type has no rep exposure\nNONE if it should not be included in any of those\nYou should include in the AF, RI, or EXP all good statements that are compatible with the code and specs\non the previous page.\nDo not include statements that are not compatible with the code and specs.\nshape is private and an immutable value\nrotation is private and an immutable value\nthis Tetromino is never returned to clients\nshape is an uppercase tetromino shape letter\nshapeLetter is an uppercase tetromino shape letter\nthe tetromino has the shape given by shape\nrotation = 0\nthe tetromino is rotated clockwise by rotation\nthe tetromino is rotated clockwise rotation times 90 degrees\n0 <= rotation < 4\n0 <= rotation < 360\nrotation is one of { 0, 90, 180, 270 }\n\nSolutions to Quiz 1 (March 14, 2016)\nSolution.\nEXP\nEXP\nNONE (doesn't make sense)\nRI\nNONE (part of the precondition of the constructor)\nAF\nNONE\nNONE\nAF (see e.g. toString)\nRI (established by constructor, maintained by rotateClockwise)\nNONE\nNONE\n■\nConsider these different specifications for the rotateClockwise method:\npublic void rotateClockwise()\nFor each possible specification below, write a one-sentence code review comment that identifies the most\nserious problem with the spec.\n(b) /**\n* Update this tetromino's rotation number to add 1, mod 4.\n*/\nComment:\nSolution. The specification must be abstract, it should not talk about the representation.\nThe specification should be declarative, not operational.\n■\n(c) /**\n* @return this tetromino rotated by 90 degrees clockwise\n*/\nComment:\nSolution. The specification, which says a Tetromino is returned, does not agree with return type void.\n■\n(d) /**\n* Rotate this tetromino (does not otherwise modify the tetromino).\n*/\nComment:\n\nSolutions to Quiz 1 (March 14, 2016)\nSolution. This specification is too weak, it does not specify the amount of rotation.\n■\nProblem 4 (Testing) (20 points).\nLet's consider the problem of packing tetrominoes into a rectangle by rotating and translating them in the\n2D plane. For example, here are tetrominoes I, L, & Z packed into a 5 × 4 rectangle, and a 7 × 2 rectangle:\nFor those three tetrominoes, the minimum area they can be packed into is 7 × 2 = 14 squares.\n(a) /**\n* @param shapes string of tetromino shape letters\n* @return a 2-element list representing a minimum-area rectangle into which\n*\nthe tetrominoes given by shapes can be packed\n*\n(for example, pack(\"ILZ\") might return the list [ 2, 7 ])\n*/\npublic static List<Integer> pack(String shapes) { ... }\nStart writing a black box testing strategy for pack(..) by giving one good partitioning for input shapes:\nFor each of the test cases below, in the first box write YES or NO in the first box to say whether the test\nvalid or not. If the test is not valid, write a one-sentence reason why not. We'll use Python's syntax to\nrepresent lists for brevity.\n(b) shapes = \"X\"\nrectangle = [ 0, 0 ]\nValid?\nReason if invalid:\nSolution. Invalid: shape X violates the precondition.\n■\n(c) shapes = \"I\"\nrectangle = [ 1, 4 ]\nValid?\nReason if invalid:\nSolution. Invalid: rectangle [ 4, 1 ] is also allowed by the postcondition.\n■\n(d) shapes = \"LO\"\nrectangle = [ 3, 3 ]\nValid?\nReason if invalid:\nSolution. Valid.\n■\n\nSolutions to Quiz 1 (March 14, 2016)\nProblem 5 (Rep Exposure) (20 points).\nLet's define a mutable abstract data type TetrominoGrid to represent tetrominoes arranged on a fixed-size\ngrid, where every tetromino fits on the grid and none of the tetrominoes overlap. For example:\nOn the next page is an implementation of TetrominoGrid. In its rep, TetrominoGrid stores the\nlocation of each tetromino using a map from integers to tetrominoes. The integer keys are square numbers:\nEach square in the grid is numbered starting from 0 in the upper-left corner.\nOn a grid of width width, square at row row and column col is numbered row × width + col.\nFor example, here's how our type would represent the example above:\nwidth = 5, height = 4\ntetrominoLocations = {\n0: (Tetromino: I-shape rotated 0 degrees),\n3: (Tetromino: L-shape rotated 0 degrees),\n6: (Tetromino: Z-shape rotated 90 degrees)\n}\nThe TetrominoGrid ADT is implemented using the same mutable Tetromino ADT from previous\nquestions.\n(a) Identify all instances of rep exposure in TetrominoGrid on the next page. For each one, write:\n1. the line number most directly responsible for the problem,\n2. at most one-sentence description of the rep exposure, and\n3. at most one-sentence description of how to fix the problem, or a single corrected line of code.\nThere may be more boxes than you need.\nLine #:\nExplanation:\nLine #:\nExplanation:\nLine #:\nExplanation:\nLine #:\nExplanation:\nLine #:\nExplanation:\nSolution.\nLine 3: tetrominoLocations can be accessed and mutated by clients. It should be private.\nLine 8: returns a Tetromino that is in the rep, clients could mutate it and break the rep invariant. Should\nreturn a defensive copy.\nLine 11 (or 10): returns an unmodifiable list, but the Tetromino objects are still mutable parts of the rep.\nShould return defensive copies.\n■\nYou may detach this page from your quiz, but you must write your name above and turn in all pages.\n/**\n* Mutable type representing a fixed-size grid with a valid arrangement of\n* tetrominoes: every tetromino fits on the grid without overlapping.\n*/\n\nSolutions to Quiz 1 (March 14, 2016)\npublic class TetrominoGrid {\n1)\nprivate final int width;\n2)\nprivate final int height;\n3)\npublic final Map<Integer, Tetromino> tetrominoLocations;\n// create a new grid and try to add some tetrominoes\npublic TetrominoGrid(int width, int height, List<Tetromino> initial) {\n4)\nthis.width = width;\n5)\nthis.height = height;\n6)\nthis.tetrominoLocations = new HashMap<>();\nfor (Tetromino tetromino : initial) {\n7)\nthis.add(tetromino.shape());\n}\n}\n// get the tetromino whose upper-left corner is the given square\npublic Tetromino getTetrimino(int row, int col) {\n8)\nreturn tetrominoLocations.get(row * width + col);\n}\n// return a list of all tetriminos currenty on the grid\npublic List<Tetromino> getTetriminosOnBoard() {\n9)\nList<Tetromino> tetrominoes = new ArrayList<>();\nfor (Tetromino tetromino : tetrominoLocations.values()) {\n10)\ntetrominoes.add(tetromino);\n}\n11)\nreturn Collections.unmodifiableList(tetrominoes);\n}\n// try to add a tetromino to the grid, if it can fit without overlap\npublic boolean add(char shape) {\n12)\nboolean canBePlaced = false; // can we fit the tetromino anywhere?\n13)\nint topLeft = -1;\n14)\nint rotation = 0;\n// ... code to check whether the new tetromino fits and doesn't overlap ...\n// ... updates the values of the local variables accordingly ...\nif (canBePlaced) {\n15)\ntetrominoLocations.put(topLeft, new Tetromino(shape, rotation));\n}\n16)\nreturn canBePlaced;\n}\n// ... other operations ...\n}\nYou may detach this page from your quiz, but you must write your name above and turn in all pages.\n\nSolutions to Quiz 1 (March 14, 2016)\n0 degrees\n90 degrees\n180 degrees\n270 degrees\nI\nO\nT\nJ\nL\nS\nZ\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.005 Software Construction\nSpring 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Exam",
      "title": "Quiz 2",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-software-construction-spring-2016/99b780633e102ebbca5fea790a69444d_MIT6_005S16_Quiz2.pdf",
      "content": "MIT\n6.005: Software Construction\nMax Goldman\nrevised Friday 22nd April, 2016, 10:11\nQuiz 2 (April 22, 2016)\nYour name:\nYour Athena username:\nYou have 50 minutes to complete this quiz. It contains 10 pages (including this page) for a total\nof 100 points.\nThe quiz is closed-book and closed-notes, but you are allowed one two-sided page of notes.\nPlease check your copy to make sure that it is complete before you start. Turn in all pages,\ntogether, when you finish. Before you begin, write your name on the top of every page.\nPlease write neatly. No credit will be given if we cannot read what you write.\nFor questions which require you to choose your answer(s) from a list, do so clearly and unam-\nbiguously by circling the letter(s) or entire answer(s). Do not use check marks, underlines, or\nother annotations - they will not be graded.\nGood luck!\nDO NOT WRITE BELOW THIS LINE\nProblem\nPoints\nGrade\nGrader\n1: Multiple Choice\n2: Map/Filter/Reduce\n3: Abstract Data Types\n4: Recursive Data Types\n5: Thread Safety\nTotal\nThis course makes use of Athena, MIT's UNIX-based computing environment.\nOCW does not provide access to this environment.\n\nQuiz 2 (April 22, 2016)\nYour name:\nProblem 1 (Multiple Choice) (20 points).\nFor each question, choose all correct answers.\n(a) Which of the following are true of thread confinement?\nA. all private final fields are confined\nB. all immutable values are confined\nC. the values of all local variables are confined\nD. a BlockingQueue used to implement message passing should be confined\nE. the view tree in a Swing GUI should be confined\n(b) Select all the strings below where the entire string is matched by the regular expression:\n([a-z]+[1-9]+)*[1-9]\nA. bb8b8b\nB. r2d222\nC. c3po000\nD. 8\nE. r5d4\n(c) Consider an immutable class ComplexNum for representing complex numbers:\nprivate final double realPart;\nprivate final double imaginaryPart;\n// AF: represents (realPart + i * imaginaryPart)\n// RI: true\n// ... other creators, producers, observers ...\npublic double absoluteValue() {\nreturn Math.sqrt(realPart*realPart + imaginaryPart*imaginaryPart)\n}\n@Override public boolean equals(Object other) {\nif (!(other instanceof ComplexNum)) { return false; }\nComplexNum that = (ComplexNum)other;\nreturn this.absoluteValue() == that.absoluteValue();\n}\nThis implementation of equals...\nA. is reflexive\nB. is symmetric\nC. is transitive\nD. returns true for ComplexNum pairs that should not be equal according to the AF\nE. returns false for ComplexNum pairs that should be equal according to the AF\n\nYour name:\nQuiz 2 (April 22, 2016)\n(d) Since ServerSocket.accept() is a blocking method, we can conclude that...\nA. accept() will not return until a client makes a connection\nB. accept() will throw an exception if called when no clients are connecting\nC. calling accept() could prevent the program from terminating\nD. it is safe to call accept() simultaneously from multiple threads\nE. while accept() is blocking, calling other methods on the same ServerSocket instance from other\nthreads will block\n\nQuiz 2 (April 22, 2016)\nYour name:\nProblem 2 (Map/Filter/Reduce) (18 points).\nBen Bitdiddle is trying to select a new password for his social media accounts. Given the following interface\nfor representing passwords:\npublic interface Password {\npublic String plainText();\npublic int strength();\n}\nFor each method below, fill in the blanks to implement the specification using map, filter, and reduce. You\nmust use exactly two operations, but you may use the same operation twice. On each line, fill in the first\nblank with map, filter, or reduce, and fill in the second blank with a lambda expression. Solutions will\nbe graded for correctness and clarity.\n(a) /**\n* @param passwords the passwords to consider\n* @param minStrength the minimum strength a password should have\n* @return the plaintext strings of passwords that have strength at least minStrength\n*/\npublic static List<String> strongEnough(List<Password> passwords, int minStrength) {\nreturn passwords.stream()\n.\n(\n)\n.\n(\n)\n.collect(toList());\n}\n(b) /**\n* @param passwords the passwords to consider\n* @param substring required substring\n* @return the plaintext strings of passwords that contain substring\n*/\npublic static List<String> containing(List<Password> passwords, String substring) {\nreturn passwords.stream()\n.\n(\n)\n.\n(\n)\n.collect(toList());\n}\n(c) /**\n* @param passwords the passwords to consider\n* @return the average strength of the passwords\n*/\npublic static double averageStrength(List<Password> passwords) {\nreturn passwords.stream()\n.\n(\n)\n.\n(0,\n)\n/ (double)passwords.size();\n}\n\nYour name:\nQuiz 2 (April 22, 2016)\nProblem 3 (Abstract Data Types) (25 points).\nA tree is a data structure that consists of a root node and zero or more children which themselves are also\ntrees. A binary tree is a tree in which each node has at most two children, designated left and right. For\nexample:\nSimon Straightforward is an enthusiastic 6.005 student who just learned about ADTs and wants to build\na class to represent binary trees of positive integers. He comes up with this internal representation:\n/** A binary tree of positive integers. */\npublic class PosIntBinaryTree {\nprivate final List<List<Integer>> nodes;\n}\nSimon wants each sub-list in nodes to represent a level in the binary tree, using 0 in place of missing\nelements. For example, the binary tree shown above is represented by the following list of lists:\n[ [ 1 ]\n[ 3, 5 ]\n[ 0, 2, 6, 4 ] ]\n(a) Silly Simon forgot to document his abstraction function and rep invariant!\nSelect statements to put into the AF and RI of PosIntBinaryTree by circling the letters of all statements\nto include from the list below. Include all good statements that are compatible with Simon's design.\nAF:\nA\nB\nC\nD\nE\nF\nG\nRI:\nA\nB\nC\nD\nE\nF\nG\nA. for all 0 <= i < nodes.size(), nodes.get(i).get(0) > 0\nB. if nodes.size() == 0, represents the empty tree\nC. if nodes.size() > 0, nodes.get(0).get(0) is the root node\nD. nodes.get(i).size() == 2^i\nE. nodes.size() == 2^k for some nonnegative integer k\nF. for node nodes.get(i).get(j),\nits left child (if any) is nodes.get(i+1).get(j*2)\nG. for node nodes.get(i).get(j),\nits right child (if any) is nodes.get(i+1).get(j*2+1)\n\nQuiz 2 (April 22, 2016)\nYour name:\nRob Recursive, an even more enthusiastic student, wants to represent binary trees of any integers.\n(b) What bad practice in Simon's rep prevents Rob from easily extending it?\n(c) Rob decides to implement the binary trees recursively, using an interface IntBinaryTree with two\nconcrete variants, one of which represents the empty tree. He also decides the type will be immutable.\n/** An immutable binary tree of integers. */\npublic interface IntBinaryTree { ... }\nWrite a recursive datatype definition for IntBinaryTree:\n(d) Start implementing the concrete variant that represents the empty tree by writing its field declarations,\nabstraction function, and rep invariant. If parts of the AF or RI would normally be assumed in 6.005, write\nthem explicitly.\nFields:\nAF:\nRI:\n(e) Start implementing the other concrete variant by writing its field declarations, abstraction function, and\nrep invariant. If parts of the AF or RI would normally be assumed in 6.005, write them explicitly.\nFields:\nAF:\nRI:\n\nYour name:\nQuiz 2 (April 22, 2016)\nProblem 4 (Recursive Data Types) (20 points).\nA Boolean formula is a propositional expression consisting of variables, ∧(and) and ∨(or) binary operators,\nand ¬ (not) unary operators.\nFor example, the following expression means \"either P or Q is true, and either P is false or R is true\":\n(P ∨Q) ∧(¬P ∨R)\nA formula is in negation normal form if the negation operator (¬) is only applied directly to variables.\nFor example, P ∧(¬Q ∨R) is in negation normal form, but P ∧¬(Q ∨R) and ¬(P ∧(¬Q ∨R)) are not.\nHere is a datatype definition for an ADT to represent negation normal form Boolean formulas:\nNegNormFormula = Variable(name: String, isNegated: boolean) +\nAnd(left: NegNormFormula, right: NegNormFormula) +\nOr(left: NegNormFormula, right: NegNormFormula)\nNow consider this specification:\n// returns a negation of the input formula\nnegate : NegNormFormula -> NegNormFormula\n\nQuiz 2 (April 22, 2016)\nYour name:\n(a) Classify this operation according to our types of ADT operations:\n(b) Implement the operation. Use De Morgan's laws and the rule for double negation:\n¬(P ∧Q) = ¬P ∨¬Q\nand\n¬(P ∨Q) = ¬P ∧¬Q\nand\n¬¬P = P\npublic class Variable implements NegNormFormula {\nprivate final String name;\nprivate final boolean isNegated;\npublic Variable(String name, boolean isNegated) { ... }\n@Override public NegNormFormula negate() {\n}\n}\npublic class And implements NegNormFormula {\nprivate final NegNormFormula left;\nprivate final NegNormFormula right;\npublic And(NegNormFormula left, NegNormFormula right) { ... }\n@Override public NegNormFormula negate() {\n}\n}\npublic class Or implements NegNormFormula {\nprivate final NegNormFormula left;\nprivate final NegNormFormula right;\npublic Or(NegNormFormula left, NegNormFormula right) { ... }\n@Override public NegNormFormula negate() {\n}\n}\n\nYour name:\nQuiz 2 (April 22, 2016)\nProblem 5 (Thread Safety) (17 points).\nIt's election season! With the tight race for president of Fictional Dystopia, you've been asked to develop a\nsecure online voting system.\nIn Fictional Dystopian elections, each voter has exactly two votes. Each voter can vote twice for the same\ncandidate, or split their vote between two different candidates.\npublic class TwoVotesEachElection {\nprivate final AtomicInteger[] voteCounts;\nprivate final Set<String> voters;\n// ... constructor initializes voteCounts to an array of AtomicIntegers,\n//\neach with value zero, and initializes voters to a threadsafe Set ...\npublic int getNumberOfCandidates() { return voteCounts.length; }\n// requires: 0 <= can1, can2 < getNumberOfCandidates()\n// effects: if and only if the voter hasn't already voted, casts both votes\npublic void vote(final String voterID, final int can1, final int can2) {\nif (voters.contains(voterID)) { return; }\nvoters.add(voterID);\n// use the atomic incrementAndGet operation\n// (we don't need the \"get\" part, but there is no plain \"increment\")\nvoteCounts[can1].incrementAndGet();\nvoteCounts[can2].incrementAndGet();\n}\n// ...\n}\nSuppose election is a TwoVotesEachElection with 4 candidates (so voteCounts.length = 4).\n(a) Unfortunately, even though TwoVotesEachElection uses threadsafe datatypes, the vote() opera-\ntion is not threadsafe. Explain clearly an interleaving that violates thread safety for TwoVotesEachElection.\n\nQuiz 2 (April 22, 2016)\nYour name:\nLouis Reasoner is convinced that using AtomicInteger is unnecessary, so he changes the code to use\nprimitive integers instead:\npublic class LouisTwoVotesEachElection {\nprivate final int[] voteCounts;\nprivate final Set<String> voters;\n// ... constructor initializes voteCounts to an array of zeros,\n//\nand initializes voters to a threadsafe Set ...\npublic int getNumberOfCandidates() { return voteCounts.length; }\n// requires: 0 <= can1, can2 < getNumberOfCandidates()\n// effects: if and only if the voter hasn't already voted, casts both votes\npublic void vote(final String voterID, final int can1, final int can2) {\nif (voters.contains(voterID)) { return; }\nvoters.add(voterID);\nvoteCounts[can1]++;\nvoteCounts[can2]++;\n}\n// ...\n}\nOf course, this just makes the problem worse.\n(b) Suppose 100 voters, each using a different thread, participate in our 4-candidate election by concur-\nrently calling Louis' vote(). Every voter uses a unique ID, and no one casts both of their votes for the\nsame candidate. The value of the sum\nvoteCounts[0] + voteCounts[1] + voteCounts[2] + voteCounts[3]\ncould be which of the following? Choose all that apply.\nA. 0\nB. 1\nC. 2\nD. 4\nE. 100\nF. 200\nG. 400\n(c) Louis wants to fix the thread safety problems by putting all the code inside vote() in a synchronized\nblock. Of the following objects in Louis' version of the code, which are suitable for us to synchronize on in\norder to ensure thread safety for concurrent calls to vote()? Choose all that apply.\nA. this\nB. voterID\nC. voters\nD. voteCounts\nE. voteCounts[0]\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.005 Software Construction\nSpring 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Exam",
      "title": "Quiz 2 Solution",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-software-construction-spring-2016/66c639668774e0da3262968754a41f12_MIT6_005S16_Quiz2_soln.pdf",
      "content": "MIT\n6.005: Software Construction\nMax Goldman\nrevised Monday 25th April, 2016, 14:52\nSolutions to Quiz 2 (April 22, 2016)\nProblem 1 (Multiple Choice) (20 points).\nFor each question, choose all correct answers.\n(a) Which of the following are true of thread confinement?\nA. all private final fields are confined\nB. all immutable values are confined\nC. the values of all local variables are confined\nD. a BlockingQueue used to implement message passing should be confined\nE. the view tree in a Swing GUI should be confined\nSolution. E.\n■\n(b) Select all the strings below where the entire string is matched by the regular expression:\n([a-z]+[1-9]+)*[1-9]\nA. bb8b8b\nB. r2d222\nC. c3po000\nD. 8\nE. r5d4\nSolution. B, D.\n■\n(c) Consider an immutable class ComplexNum for representing complex numbers:\nprivate final double realPart;\nprivate final double imaginaryPart;\n// AF: represents (realPart + i * imaginaryPart)\n// RI: true\n// ... other creators, producers, observers ...\npublic double absoluteValue() {\nreturn Math.sqrt(realPart*realPart + imaginaryPart*imaginaryPart)\n}\n@Override public boolean equals(Object other) {\nif (!(other instanceof ComplexNum)) { return false; }\nComplexNum that = (ComplexNum)other;\nreturn this.absoluteValue() == that.absoluteValue();\n}\n\nSolutions to Quiz 2 (April 22, 2016)\nThis implementation of equals...\nA. is reflexive\nB. is symmetric\nC. is transitive\nD. returns true for ComplexNum pairs that should not be equal according to the AF\nE. returns false for ComplexNum pairs that should be equal according to the AF\nSolution. A, B, C, D.\n■\n(d) Since ServerSocket.accept() is a blocking method, we can conclude that...\nA. accept() will not return until a client makes a connection\nB. accept() will throw an exception if called when no clients are connecting\nC. calling accept() could prevent the program from terminating\nD. it is safe to call accept() simultaneously from multiple threads\nE. while accept() is blocking, calling other methods on the same ServerSocket instance from other\nthreads will block\nSolution. A, C.\n■\nProblem 2 (Map/Filter/Reduce) (18 points).\nBen Bitdiddle is trying to select a new password for his social media accounts. Given the following interface\nfor representing passwords:\npublic interface Password {\npublic String plainText();\npublic int strength();\n}\nFor each method below, fill in the blanks to implement the specification using map, filter, and reduce. You\nmust use exactly two operations, but you may use the same operation twice. On each line, fill in the first\nblank with map, filter, or reduce, and fill in the second blank with a lambda expression. Solutions will\nbe graded for correctness and clarity.\n(a) /**\n* @param passwords the passwords to consider\n* @param minStrength the minimum strength a password should have\n* @return the plaintext strings of passwords that have strength at least minStrength\n*/\npublic static List<String> strongEnough(List<Password> passwords, int minStrength) {\nreturn passwords.stream()\n.\n(\n)\n.\n(\n)\n.collect(toList());\n}\n\nSolutions to Quiz 2 (April 22, 2016)\n(b) /**\n* @param passwords the passwords to consider\n* @param substring required substring\n* @return the plaintext strings of passwords that contain substring\n*/\npublic static List<String> containing(List<Password> passwords, String substring) {\nreturn passwords.stream()\n.\n(\n)\n.\n(\n)\n.collect(toList());\n}\n(c) /**\n* @param passwords the passwords to consider\n* @return the average strength of the passwords\n*/\npublic static double averageStrength(List<Password> passwords) {\nreturn passwords.stream()\n.\n(\n)\n.\n(0,\n)\n/ (double)passwords.size();\n}\nSolution.\n(a) .filter(p -> p.strength() >= minStrength)\n.map(p -> p.plainText())\n(b) .map(p -> p.plainText())\n.filter(p -> p.contains(substring))\n(c) .map(p -> p.length())\n.reduce(0, (a,b) -> a+b)\n■\nProblem 3 (Abstract Data Types) (25 points).\nA tree is a data structure that consists of a root node and zero or more children which themselves are also\ntrees. A binary tree is a tree in which each node has at most two children, designated left and right. For\nexample:\n\nSolutions to Quiz 2 (April 22, 2016)\nSimon Straightforward is an enthusiastic 6.005 student who just learned about ADTs and wants to build\na class to represent binary trees of positive integers. He comes up with this internal representation:\n/** A binary tree of positive integers. */\npublic class PosIntBinaryTree {\nprivate final List<List<Integer>> nodes;\n}\nSimon wants each sub-list in nodes to represent a level in the binary tree, using 0 in place of missing\nelements. For example, the binary tree shown above is represented by the following list of lists:\n[ [ 1 ]\n[ 3, 5 ]\n[ 0, 2, 6, 4 ] ]\n(a) Silly Simon forgot to document his abstraction function and rep invariant!\nSelect statements to put into the AF and RI of PosIntBinaryTree by circling the letters of all statements\nto include from the list below. Include all good statements that are compatible with Simon's design.\nAF:\nA\nB\nC\nD\nE\nF\nG\nRI:\nA\nB\nC\nD\nE\nF\nG\nA. for all 0 <= i < nodes.size(), nodes.get(i).get(0) > 0\nB. if nodes.size() == 0, represents the empty tree\nC. if nodes.size() > 0, nodes.get(0).get(0) is the root node\nD. nodes.get(i).size() == 2^i\nE. nodes.size() == 2^k for some nonnegative integer k\nF. for node nodes.get(i).get(j),\nits left child (if any) is nodes.get(i+1).get(j*2)\nG. for node nodes.get(i).get(j),\nits right child (if any) is nodes.get(i+1).get(j*2+1)\nSolution. AF: B, C, F, and G. RI: D.\n■\nRob Recursive, an even more enthusiastic student, wants to represent binary trees of any integers.\n(b) What bad practice in Simon's rep prevents Rob from easily extending it?\nSolution. Magic number 0.\n■\n(c) Rob decides to implement the binary trees recursively, using an interface IntBinaryTree with two\nconcrete variants, one of which represents the empty tree. He also decides the type will be immutable.\n/** An immutable binary tree of integers. */\npublic interface IntBinaryTree { ... }\nWrite a recursive datatype definition for IntBinaryTree:\nSolution. IntBinaryTree = Empty() + Tree(value: int, left,right: IntBinaryTree)\n■\n\nSolutions to Quiz 2 (April 22, 2016)\n(d) Start implementing the concrete variant that represents the empty tree by writing its field declarations,\nabstraction function, and rep invariant. If parts of the AF or RI would normally be assumed in 6.005, write\nthem explicitly.\nFields:\nAF:\nRI:\nSolution.\nNo fields\nAF: represents the empty immutable binary tree of integers\nRI: true\n■\n(e) Start implementing the other concrete variant by writing its field declarations, abstraction function, and\nrep invariant. If parts of the AF or RI would normally be assumed in 6.005, write them explicitly.\nFields:\nAF:\nRI:\nSolution.\nprivate final int value;\nprivate final IntBinaryTree left, right;\nAF: represents the immutable binary tree of integers with root node value, left subtree left, and right\nsubtree right\nRI: left,right != null\n■\nProblem 4 (Recursive Data Types) (20 points).\nA Boolean formula is a propositional expression consisting of variables, ∧(and) and ∨(or) binary operators,\nand ¬ (not) unary operators.\nFor example, the following expression means \"either P or Q is true, and either P is false or R is true\":\n(P ∨Q) ∧(¬P ∨R)\nA formula is in negation normal form if the negation operator (¬) is only applied directly to variables.\nFor example, P ∧(¬Q ∨R) is in negation normal form, but P ∧¬(Q ∨R) and ¬(P ∧(¬Q ∨R)) are not.\nHere is a datatype definition for an ADT to represent negation normal form Boolean formulas:\nNegNormFormula = Variable(name: String, isNegated: boolean) +\nAnd(left: NegNormFormula, right: NegNormFormula) +\nOr(left: NegNormFormula, right: NegNormFormula)\nNow consider this specification:\n// returns a negation of the input formula\nnegate : NegNormFormula -> NegNormFormula\n(a) Classify this operation according to our types of ADT operations:\n\nSolutions to Quiz 2 (April 22, 2016)\nSolution. Producer.\n■\n(b) Implement the operation. Use De Morgan's laws and the rule for double negation:\n¬(P ∧Q) = ¬P ∨¬Q\nand\n¬(P ∨Q) = ¬P ∧¬Q\nand\n¬¬P = P\npublic class Variable implements NegNormFormula {\nprivate final String name;\nprivate final boolean isNegated;\npublic Variable(String name, boolean isNegated) { ... }\n@Override public NegNormFormula negate() {\nSolution.\nreturn new Variable(name, ! isNegated);\n■\n}\n}\npublic class And implements NegNormFormula {\nprivate final NegNormFormula left;\nprivate final NegNormFormula right;\npublic And(NegNormFormula left, NegNormFormula right) { ... }\n@Override public NegNormFormula negate() {\nSolution.\nreturn new Or(left.negated(), right.negated());\n■\n}\n}\npublic class Or implements NegNormFormula {\nprivate final NegNormFormula left;\nprivate final NegNormFormula right;\npublic Or(NegNormFormula left, NegNormFormula right) { ... }\n@Override public NegNormFormula negate() {\nSolution.\nreturn new And(left.negated(), right.negated());\n■\n}\n}\nProblem 5 (Thread Safety) (17 points).\nIt's election season! With the tight race for president of Fictional Dystopia, you've been asked to develop a\nsecure online voting system.\nIn Fictional Dystopian elections, each voter has exactly two votes. Each voter can vote twice for the same\ncandidate, or split their vote between two different candidates.\n\nSolutions to Quiz 2 (April 22, 2016)\npublic class TwoVotesEachElection {\nprivate final AtomicInteger[] voteCounts;\nprivate final Set<String> voters;\n// ... constructor initializes voteCounts to an array of AtomicIntegers,\n//\neach with value zero, and initializes voters to a threadsafe Set ...\npublic int getNumberOfCandidates() { return voteCounts.length; }\n// requires: 0 <= can1, can2 < getNumberOfCandidates()\n// effects: if and only if the voter hasn't already voted, casts both votes\npublic void vote(final String voterID, final int can1, final int can2) {\nif (voters.contains(voterID)) { return; }\nvoters.add(voterID);\n// use the atomic incrementAndGet operation\n// (we don't need the \"get\" part, but there is no plain \"increment\")\nvoteCounts[can1].incrementAndGet();\nvoteCounts[can2].incrementAndGet();\n}\n// ...\n}\nSuppose election is a TwoVotesEachElection with 4 candidates (so voteCounts.length = 4).\n(a) Unfortunately, even though TwoVotesEachElection uses threadsafe datatypes, the vote() opera-\ntion is not threadsafe. Explain clearly an interleaving that violates thread safety for TwoVotesEachElection.\nSolution. Two threads enter vote with the same voterID not yet in voters.\nBoth threads call voters.contains and obtain false, then both call voters.add successfully.\nAt this point, both threads will increment the vote counts for their can1 and can2, giving this voter 4 votes\ninstead of 2, in violation of the postcondition.\n■\nLouis Reasoner is convinced that using AtomicInteger is unnecessary, so he changes the code to use\nprimitive integers instead:\npublic class LouisTwoVotesEachElection {\nprivate final int[] voteCounts;\nprivate final Set<String> voters;\n// ... constructor initializes voteCounts to an array of zeros,\n//\nand initializes voters to a threadsafe Set ...\npublic int getNumberOfCandidates() { return voteCounts.length; }\n// requires: 0 <= can1, can2 < getNumberOfCandidates()\n// effects: if and only if the voter hasn't already voted, casts both votes\npublic void vote(final String voterID, final int can1, final int can2) {\nif (voters.contains(voterID)) { return; }\n\nSolutions to Quiz 2 (April 22, 2016)\nvoters.add(voterID);\nvoteCounts[can1]++;\nvoteCounts[can2]++;\n}\n// ...\n}\nOf course, this just makes the problem worse.\n(b) Suppose 100 voters, each using a different thread, participate in our 4-candidate election by concur-\nrently calling Louis' vote(). Every voter uses a unique ID, and no one casts both of their votes for the\nsame candidate. The value of the sum\nvoteCounts[0] + voteCounts[1] + voteCounts[2] + voteCounts[3]\ncould be which of the following? Choose all that apply.\nA. 0\nB. 1\nC. 2\nD. 4\nE. 100\nF. 200\nG. 400\nSolution. C, D, E, F.\nAt least one thread will successfully increment the count for its first candidate; same for some thread and its\nsecond candidate. With no races at all, 200 votes will be counted.\n■\n(c) Louis wants to fix the thread safety problems by putting all the code inside vote() in a synchronized\nblock. Of the following objects in Louis' version of the code, which are suitable for us to synchronize on in\norder to ensure thread safety for concurrent calls to vote()? Choose all that apply.\nA. this\nB. voterID\nC. voters\nD. voteCounts\nE. voteCounts[0]\nSolution. A, C, D.\nLocking on different voterID strings doesn't help. voteCounts[0] is a primitive in Louis' code.\n■\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.005 Software Construction\nSpring 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    }
  ]
}