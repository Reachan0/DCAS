{
  "course_name": "Biological Engineering Programming",
  "course_description": "No description found.",
  "topics": [
    "Engineering",
    "Biological Engineering",
    "Computer Science",
    "Theory of Computation",
    "Systems Engineering",
    "Computational Science and Engineering",
    "Systems Design",
    "Engineering",
    "Biological Engineering",
    "Computer Science",
    "Theory of Computation",
    "Systems Engineering",
    "Computational Science and Engineering",
    "Systems Design"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1 hour / session\n\nOverview\n\nWelcome to 20.180, MIT Biological Engineering's programming course! For many of you this will be the first time learning to program computers; others may already be programming gurus. Regardless of your background, upon completing 20.180 you'll have learned how to solve complex biological engineering problems using computational approaches. You'll also discover the rudiments of how to program DNA, the genetic material that runs inside all living organisms. Along the way, you'll be exposed to powerful ideas that underlie all of modern engineering. We hope that you have a great experience with the course!\n\nAssignments and Exams\n\nWe expect that all assignments will be turned in by 5pm on the day they are due. You may discuss assignments with your classmates but we expect that you will submit your own work. Late assignments will be assigned a grade of zero (your lowest assignment grade will be dropped from your final grade). A family crisis or severe illness requiring attention from the infirmary and prohibiting you from all your coursework are acceptable reasons for missing an exam; every effort will be made to accommodate you in these exceptional circumstances.\n\nGrading\n\nACTIVITIES\n\nPERCENTAGES\n\nExam 1\n\n20%\n\nExam 2\n\n20%\n\nClass Participation\n\n10%\n\nProgramming Assignments\n\n50%",
  "files": [
    {
      "category": "Assignment",
      "title": "psetfour_final.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/3932b703a8d890957903970cf54b9063_psetfour_final.pdf",
      "content": "20.180 - Homework Assignment #3\nDue on Tuesday, April 25 at 5pm\n\nStandard genetic code table via Ben Fry, http://acg.media.mit.edu/people/fry/\n\nCreate a new Python script called yourUserName_4.py. This file should contain all of your code for this\nproblem set, but you should clearly separate the code for the two problems (for example, with a line).\n\nProblem 1: Reverse translation (25 points)\n\nMost amino acids are coded for by more than one triplet codon (e.g., table above). In biological engineering,\ncodon redundancy can allow the redesign of the exact DNA sequence of open reading frames. The goal of\nproblem 1 is explore the redundancy in translational coding by \"reverse translating\" a protein's amino acid\nsequence in order to produce a mRNA sequence that would, when translated, yield the protein [please note that\nreverse translation is not known to occur inside living cells; it's \"only\" a computational tool]. You can read\nmore about the genetic code here:\nhttp://en.wikipedia.org/wiki/Genetic_code\n\nTo get started, read in the files GeneticCode.dict and Protein.txt, and open them to see what they contain. You\ncan assume that the Protein.txt file will contain the amino acid sequence of a single protein (on one line), and\nthat the standard single-letter abbreviations for amino acids will be used. Your task is to write a computer\nprogram that produces the mRNA sequence that would, when translated, encode the protein. You should\nuse a standard degenerate nucleotide alphabet (below) in order to produce a single mRNA sequence.\n\nAdenine and guanine are both 'purines', which consist of a pyrimidine ring fused to an imidazole ring.\nCytosine and uracil are both 'pyrimidines', and contain a single pyrimidine ring. Thus, whenever an amino acid\nis encoded by more than one codon, you should use the following rules and symbols:\nIf the first positions of all codons encoding an amino acid are the same, write that nucleotide's letter to\nthe mRNA string (i.e., A, C, T, G).\nOtherwise:\nIf all the nucleotides at the first position are purines (A or G), write the letter \"R\" to the mRNA.\nIf all the nucleotides at the first position are pyrimidines (C or U), write the letter \"Y\" to the mRNA.\nIf all the nucleotides at the first position are either U, C, or A, write the letter \"H\" to the mRNA.\nIn all other cases, write \"N\" to the mRNA, indicating that any base is possible.\n\n(Repeat for the second and third position of the codon.)\n\nFor example, the amino acid methionine would be reverse translated into \"AUG\", whereas the amino acid\ncysteine would be reverse translated into \"UGY\". The protein \"ENDY\" should give the mRNA sequence\n\"GARAAYGAYUAY\". Use tester sequences like this one to make sure your code is working.\n\nStore your final mRNA sequence (derived from the amino acid sequence in Protein.txt) as a string with the\nvariable name \"RT\". Your mRNA should be in capital letters.\n\nCourtesy of Ben Fry. Used with permission.\n\nProblem 2: Signing DNA (50 points)\n\nEngineers whose work impacts the public take responsibility for the safety of their designs. For any engineered\nDNA fragment that might escape a controlled laboratory setting this could require taking steps to ensure that it\nis easy to detect the DNA fragment within an uncharacterized environmental sample. One possible way to\nenable easy detection would be to add a signature tag to the DNA itself (for example, a short sequence of DNA\nthat could be readily recognized by a unique PCR primer). Such a signature tag would be most useful if its\nsequence was not found or, at least, was maximally different from known natural DNA sequences. More\ninformation on these ideas are online here:\nhttp://parts.mit.edu/r/parts/htdocs/barcodes.cgi\nhttp://openwetware.org/wiki/Barcodes\n\nFor Problem 2, you will create all possible sequences of 8 bases (\"8-mers\") and return the one(s) with the\nlowest sequence homology to a given viral genome. Your code for this problem should be placed below and\nclearly separated from your code for Problem 1. You should place all functions for this problem above the main\ncode.\n\nRead in the genome of the Bhendi yellow vein mosaic virus (found in the file NC_003418.txt) and store the\ngenome as a string. For more information, go to http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=Genome\nand search for NC_003418.\n\na. First, write a function called createMers that will create all possible 8-mers from the four bases of DNA.\nThis function will take in no arguments and will return all possible 8-mers as a list. Before coding, think about\nthe number of 8-mers you would expect. For example, the list of all 2-mers is\n['AA', 'CA', 'GA', 'TA', 'AC', 'CC', 'GC', 'TC', 'AG', 'CG', 'GG', 'TG', 'AT', 'CT', 'GT', 'TT']\nCall the function from the main body of your program and store the output to the variable merList.\n\nb. Notice that in part (a), you had to hard-code the length of the mer into the function, thus making it\nimpossible to reuse what you have already written to create mers of a different length. You will now write a\nfunction called createMersRec, which will take in the length of the mer and use recursion to create all\npossible n-mers.\n\nRecursion involves a function calling on itself over and over until it reaches an end state. You can read about\nrecursion at http://en.wikipedia.org/wiki/Recursion. Make sure you understand the example there with factorial\nbefore you try to write your own recursive function. In our case, the end state will be when createMersRec\ncalls itself with a length of one. As practice, try writing the function to create all 2-mers first.\n\nAs in part (a), return all possible n-mers as a list from within your function definition. Call the function from\nthe main body of your program with 8 as the argument to create all possible 8-mers. Store the result to the\nvariable merListRec, and note that this list should be equivalent to merList.\n\nc. Here, you will go through merListRec and find the mers with the lowest overall homology to the viral\ngenome you read in. You should comment out (but not delete) your call to the function createMers since\nthere is no reason to create the list of mers twice. When coding, you should create short, practice genomes and\nshort n-mer lists to make sure your code is working the way you would like.\n\nLoop through each of the mers in merListRec. For a given mer, slide it along the genome, and score each\nalignment as you go. Think about how many alignments of that mer to subsequences of the genome there\nshould be. Create a scoring function called scoreMer that takes in two arguments. The first argument is the\nsubsequence of the genome that you want to compare with the specific mer from merListRec, and the\nsecond argument is that mer. For example, if you wanted to align the 2-mer \"GT\" and the genome \"AGTCT\",\nyou would call scoreMer(\"AG\", \"GT\"), then scoreMer(\"GT\", \"GT\"), then scoreMer(\"TC\", \"GT\"), then\n\nscoreMer(\"CT\", \"GT\"). The score for each alignment is the total number of exact matches. Thus, for the\nabove example, the function scoreMer would return 0, then 2, then 0, then 1.\n\nFor a given mer, you should keep track of the worst ('worst' meaning highest, or best alignment) score of all of\nits sliding window alignments with the genome. For the above example, this would be the number 2. Once you\nhave gone through each mer in merListRec, you will need to pick out the best mer(s). The set of best mers\n(will use the plural, but there may be only one) is the set of mers with the lowest worst score. Store this score in\nthe variable bestScore, and the list of all mers with this score in the list listOfBestMers.\n\nFor example, the mer \"TT\" gives scores [0, 1, 1, 1] for the genome \"AGTCT\". The worst score for this mer\nwould be 1. To obtain the set of best mers, you would compare 2 and 1, the worst scores for the two mers in\nquestion. The lowest worst score is 1, so you would store the value 1 in the variable bestScore, and the mer\n\"TT\" in the listOfBestMers.\n\nYou may have noticed that for a merListRec of 8-mers and a ~3,000bp genome, your program may take a\nlong time to run. Shorten your runtime to under 10 minutes by only keeping track of the mer(s) with the best\nscore so far, for example as a variable bestScoreSoFar. In addition, when sliding a given mer along the\ngenome, notice that you can stop sliding once you encounter an alignment that produces a score that is larger\nthan the best score so far. You can use break to break a loop.\n\nProblem 3: Dangerous DNA? (25 points)\n\nShould the DNA sequence information specifying the genomes of human pathogens that are difficult or\nimpossible to obtain from nature (e.g., smallpox, Ebola, 1918 influenza) be freely available via the internet?\nPlease explain your decision but keep your answers shorter than 200 words in length. Please submit your\nanswers via the body of the email containing your answers to Q1 and Q2.\n\nIf you would like to consider other's opinions on this question, here are two representative points of view:\n\na. \"Recipe for Destruction,\" Ray Kurzweil & Bill Joy, NY Times, 17 October 2005\nhttp://www.commondreams.org/views05/1017-23.htm\n\nb. \"1918 Flu & Responsible Science,\" Phillip Sharp, Science, 7 October 2005\nhttp://www.sciencemag.org/cgi/reprint/310/5745/17.pdf"
    },
    {
      "category": "Resource",
      "title": "asg1_add_info.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/c00031f823e6d0ed3dbdc3a55d0c4460_asg1_add_info.pdf",
      "content": "20.180:Assignment1\nParts\n-\nPromoter - taatacgactcactatagggaga\n\n-\nRBS - attaaagaggagaaa\n\n-\nORF -\natggcttcctccgaagacgttatcaaagagttcatgcgtttcaaagttcgtatggaaggttccgttaacggtcacgagtt\ncgaaatcgaaggtgaaggtgaaggtcgtccgtacgaaggtacccagaccgctaaactgaaagttaccaaaggtggt\nccgctgccgttcgcttgggacatcctgtccccgcagttccagtacggttccaaagcttacgttaaacacccggctgac\natcccggactacctgaaactgtccttcccggaaggtttcaaatgggaacgtgttatgaacttcgaagacggtggtgttg\nttaccgttacccaggactcctccctgcaagacggtgagttcatctacaaagttaaactgcgtggtaccaacttcccgtc\ncgacggtccggttatgcagaaaaaaaccatgggttgggaagcttccaccgaacgtatgtacccggaagacggtgct\nctgaaaggtgaaatcaaaatgcgtctgaaactgaaagacggtggtcactacgacgctgaagttaaaaccacctacat\nggctaaaaaaccggttcagctgccgggtgcttacaaaaccgacatcaaactggacatcacctcccacaacgaagac\ntacaccatcgttgaacagtacgaacgtgctgaaggtcgtcactccaccggtgcttaataa\n\n-\nTerminator -\nccaggcatcaaataaaacgaaaggctcagtcgaaagactgggcctttcgttttatctgttgtttgtcggtgaacgctctc\ntactagagtcacactggctcaccttcgggtgggcctttctgcgtttata\n\n-\nBarcode - CGCTGATAGTGCTAGTGTAGATCGC\n-\nUse Parts.txt as your input.\nWrite your code so that it could take in any input file which has the\nfollowing structure:\nkey1\nvalue1\nkey2\nvalue2\nkey3\nvalue3...\n-\nPlease plan to submit one .py file containing the code for both question 1 and\nquestion 2, named as yourathenaname_assignmentnumber.py. For example, for\nthe first assignment, my file would be called spencers_1.py.\n-\nYour code should create two output files, one for question 1, called output1.txt,\nand one for question 2, called output2.txt.\n-\nNEW! output1.txt should contain only the DNA sequence as a single string.\n-\nNEW! output2.txt should contain one ORF per line, and nothing else.\n\nSubmission instructions\n-\nOn a paper copy of the pset pdf, please hand write your answers to question 0 as\nwell as the answer to this question: What will this composite part do when placed\ninside a living bacterium?\n-\nLate psets will NOT be accepted.\nQuestions and Clarifications\n-\nNote that the stop codon TAA must be in frame, i.e. a multiple of 3 basepairs\naway from the ATG. For example, ATGxxxxxxTAA would be in frame, but\nATGxxxxxTAA would not be. (x is any basepair)\n-\nIs it significant that the barcode is CAPS and the other parts are lower case?\no NO/no.\n-\nCan an ORF be any length over 50, or should its length be a multiple of some\nsmall integer?\no An ORF should be a length that is a multiple of three, the number of base\npairs that comprise a codon\n-\nDoes the ORF include the start ATG and stop TAA? Suppose the DNA string is\n\"ATG...TAA\": is the ORF \"...\" or \"ATG...\" or \"ATG...TAA\" or \"...TAA\"?\no The ORF includes the \"start\" ATG and \"stop\" TAA.\n-\nCan ORFs overlap? Suppose the DNA string is \"ATG...TAAxxxTAA\". The first\nORF is obviously (modulo previous question) \"ATG...TAA\". Is\n\"ATG...TAAxxxTAA\" also an ORF? It meets the specification of \"a string\nstarting with ATG and ending with TAA\". One could imagine a similar situation\nwith overlapping starting tags: \"ATG...ATGxxxTAA\" might have both\n\"ATG...ATGxxxTAA\" and \"ATGxxxTAA\".\no Yes, ORFs can overlap.\no Although \"ATG...TAAxxxTAA\" has a small chance of occurring in\nbiology, for the purposes of this programming assignment, please end\nORFs at the first in-frame TAA.\n-\nFor Q2, ATG...TAA...TAA isn't an ORF, but what if ATG...TAA is less than 50\nbp and ATG...TAA...TAA is >50bp?\no Still not an ORF (assuming the TAA's are in frame). The >50bp is\nsomething humans have used as a qualifier to weed out things that are not\nORFs, since we've observed that ORFs are usually >50bp. The biology of\ntranslation will still see TAA as a stop codon and stop translation at the\nfirst TAA, making the sequence less than 50bp."
    },
    {
      "category": "Resource",
      "title": "asg1_sol_comts.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/dc46ce133868e6a15d7cc73bb1c04721_asg1_sol_comts.pdf",
      "content": "20.180:Assignment1\nSolutions and General Comments\n-\nAnswers to Q0:\no False, because == checks for equality\no 4\no True, because we previously set a equal to b, so now a and b are equal\no 1 2 3 4 (each of these will be on a new line)\no 2 3 4 5 (each of these will be on a new line)\n\n-\nAnswer to written Q1 section:\no Under certain conditions, the bacteria will express the mRFP protein\nencoded by the ORF. (-2pts for not noting that the protein made is mRFP)\n\n-\nOne possible way of writing the code for assignment 1 is provided in the file\nlabeled 'Code.'\no Common mistakes for Q1: not printing the concatenated sequence to the\nscreen or output file as the question asked (-5pts), naming files incorrectly\n(-5pts), not concatenating by calling the keys in the dictionary (you would\nget the incorrect answer for any other input file; -10pts)\no The file used to grade Q1 is provided and is labeled 'Test file.' Use this txt\nfile as the file you read in for Q1 and compare your answer with the\nanswer found with the Q1q2code.txt provided above.\no Common mistakes for Q2: not checking for in-frame TAA's <50bps from\nan ATG and excluding them from your list of ORFs (-3pts), not stopping\nat the first in-frame TAA (-4pts), finding the first TAA for each ATG and\nnot continuing to look for another TAA if the first is not in-frame, index\nout of range (-2pts), not printing ORFs to output file correctly (-2pts)\n\nThis test sequence was used to grade Q2:\ntaaatgxxatgxxxatgxxxxxxxxxxxxxxxxxxxxxxxxxtaaxxxxxxxxxxxx\nxxxxxxxxxxxxxxxxxxtaaxxtaataa\n\nUse this sequence as the input to Q2 (basically, overwrite your\nconcatenated sequence with this one) and compare the ORFs you\nfind with your code to the ORFs found with the Q1q2code.txt code\nprovided above.\n\n-\nIf you still have questions after reviewing these solutions and trying out the test\nsequence, please email the TAs."
    },
    {
      "category": "Exam",
      "title": "exam1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/609c28f3617c1fb2de887fc1c5c7b0a1_exam1.pdf",
      "content": "20.180 Exam 1\nName: _______Answer Key___________\n23 March 2006\n50 minutes, closed book\nQuestion 1 (40 points):\nBioBricks & Mortar, Inc. has been having some staffing problems in their Department of\nAbstraction; they've produced the following set of bizarre genetic devices:\nUsing only the parts from these devices, remake three functionally independent and\nreusable inverters - include a sketch for how each inverter device works, including labels\non device input and output signals and internal device logic. Then, sketch (at the device\nlevel) two different ring oscillator systems that can be built from your inverters. Finally,\nnote that a simpler oscillator can be made connecting the output of an amplifier device to\nits own input, while simultaneously regulating the input to the amplifier via an inverter\nthat is also connected to the amplifier's output. Define a reusable amplifier device and\nsketch (at the device-level) a two-device oscillator.\nThree functionally independent and reusable inverter devices made from the above parts:\nTwo different ring oscillators built from the above inverters:\nA PoPS-based amplifier device and a two-device oscillator:\n\nQuestion 2 (30 points):\nGeneral Biologics, Inc. has asked you to design a microorganism that can detect and\nrespond to levels of TNT in the environment. Above some threshold level of TNT (TL),\nand only if nutrients are present in the local environment, the microorganism should turn\norange and express enzymes that degrade TNT. However, if the TNT level is above TL\nbut nutrients are not present in the environment, the microorganism should do nothing\nexcept turn red. In the absence of TNT (i.e., for TNT < TL) the organism should be\ngreen. Using PoPS-based devices, sketch out the device-level block diagram for the\ndesign of such an engineered biological system. Do not define the individual parts that\nmake up the devices.\n\n20.180 Exam 1\nName: _______Answer Key___________\nQuestion 3 (30 points):\nPfizer, Inc. has given you the sequence of a genome containing many open reading\nframes (ORFs). Each of the genome's ORFs starts with \"ATG\" and ends with\n\"UAGUGA.\" They want you to find each ORF and append the DNA sequence\n\"TAGTGCTA\" to the end (you're told not to worry about minimum ORF length).\nMeanwhile, you and your friends have designed another genome that contains 50 new\nsynthetic DNA binding proteins. Each of these DNA binding protein ORFs starts with\n\"ATG\" and ends with \"UAAUAA.\" Your friends want you to find each DNA binding\nprotein ORF and add the DNA sequence \"GTGTAGATCA\" to the end. Write down a\nsingle Python program that can perform both of these tasks. Please note any instances of\nreusable code.\n#\n# Declare two reusable functions, one for finding ORFs and a second for suffixing.\n#\n# ORF finding function\n#\ndef find_ORFs(seq, start_seq, stop_seq):\nfound_ORFs = [] # start a new list\ntmp = seq\n# create temporary variable to store sequence\nwhile True:\n# create loop\nstart = tmp.find(start_seq) # look for a start, set start to first occurence\nif start == -1: break\n# if no start sequence found break loop\ntmp\n= tmp[start:len(seq)] # redefine tmp sequence\nstop = tmp.find(stop_seq) # look for a stop, set stop to first occurence\nif stop == -1: break\n# if no stop sequence found break loop\ntmpORF= tmp[0:stop+len(stop_seq)] # create tmpORF from start & stop points (keep stop)\nif len(tmpORF)%3==0:\n# check is stop sequence is in frame\nfound_ORFs.append(tmpORF)# if OK then add to found orf list\ntmp\n= tmp [3:] # set new starting boundary of sequence to downstream of last found start\nreturn found_ORFs\n# send the ORFs back to main\n#\n# ORF suffixing function\n#\ndef suffix_ORFs(ORF_list, suffix_seq):\nsuffixed_ORFs = [] # start a new list\nfor i in range(len(ORF_list)): # for all the found ORFs\nsuffixed_ORFs.append(ORF_list[i]+suffix_seq) # add the suffix\nreturn suffixed_ORFs # send the modified ORFs back to main\n#\n# Main Program\n#\n# Read in genome sequences; define start, stop, and suffix sequences\n#\nfriends\n= open('friends.txt').read()\nfriends_start = 'atg'\nfriends_stop\n= 'uaauaa'\nfriends_suffix = 'gtgtagatca'\n# call ORF finding function\nfriends_ORFs\n= find_ORFs(friends, friends_start, friends_stop)\nnew_friends_ORFs = suffix_ORFs(friends_ORFs, friends_suffix)\n#\n# Repeat the above for other like tasks (i.e., Pfizer)\n#"
    },
    {
      "category": "Exam",
      "title": "exam2_key.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/6ddb75c1ce282ba7ded6f84566a04436_exam2_key.pdf",
      "content": "20.180 Exam 2\n\nName ___________________\n11 May 2006\nClosed Book\n\nQuestion 1 (35 points total)\n\nRefer to the standard genetic code table if needed.\n\nA. Circle any open reading frame(s) encoded in the double\nstranded DNA fragment shown below (10 points).\n\n5'-TTAATGGTGCCGCGGCATTAA-3'\n3'-AATTACCACGGCGCCGTAATT-5'\n\nThe restriction endonuclease SacII cuts the DNA sequence\nshown here:\n\n5'-CCGCGG-3'\n\n3'-GGCGCC-5'\n\nB. Underline any SacII site(s) on the DNA shown in part A\n(5 points).\n\nC. Design a new piece of DNA that does not contain any SacII\nsite(s) but that still encodes the same protein(s) as the\nDNA shown in part A (15 points).\n\nBefore\n\nDNA:\nTTAATGGTGCCGCGGCATTAA\nAATTACCACGGCGCCGTAATT\n\nORF1:\nATG GTG CCG CGG CAT TAA\n\nMet Val Pro Arg His *\n\nORF2:\nATG CCG CGG CAC CAT TAA\n\nMet Pro Arg His His *\n\nAfter\n\nDNA:\nTTAATGGTGCCtCGGCATTAA\n\nAATTACCACGGaGCCGTAATT\n\nORF1:\nATG GTG CCt CGG CAT TAA\n\nMet Val Pro Arg His *\n\nORF2:\nATG CCG aGG CAC CAT TAA\n\nMet Pro Arg His His *\n\n20.180 Exam 2\n\nName ___________________\n11 May 2006\nClosed Book\n\nQuestion 2 (30 points total)\n\nCaltech has decided to start a new undergraduate course of\nstudy in Biological Engineering. The Caltech second years\nare promulgating a new signal carrier for genetic devices\ncalled RiPS (for Ribosomes Per Second). They claim that\nRiPS represents the rate at which ribosomes flow along mRNA,\ninto and out of genetic devices (Figure below).\n\nA. Can RiPS-based devices be re-used in combination with one\nanother? That is, is RiPS a common signal carrier? (8 points)\nYes. The device is sending and receiving signals via the same\nsignal carrier. Thus, RiPS is a common signal carrier.\n\nB. Can the output of a RiPS-based device be usefully connected\nto the input of a PoPS-based device? (8 points)\nYes. RiPS-based devices end with a RBS. PoPS-based devices\nstart with a RBS. Although a RiPS:PoPS junction would produce\ntwo RBSs in tandem, the devices will still function in\ncombination.\n\nC. Can the output of a PoPS-based device be usefully connected\nto the input of a RiPS-based device? (8 points)\nNo. PoPS-based devices end with an operator. RiPS-based\ndevices start with an ORF. Thus, while an mRNA will be\nproduced, the mRNA will not contain a RBS and thus the devices\nwill not function in combination.\n\nD. Is there any reason to favor PoPS over RiPS, or vice versa?\nWhy? (6 points, please keep your answers short)\nPoPS is based at the level of transcription, so it is a\n\"lower-level\" signal carrier. However, RiPS, in practice,\ncombines the operator part with the RBS part, which may make\ndevice composition more reliable.\n\n20.180 Exam 2\n\nName ___________________\n11 May 2006\nClosed Book\n\nQuestion 3 (35 points total)\n\nConsider a two-dimensional field of cells, with each cell\ncontaining a set of genetic devices organized as shown\nbelow; each device's transfer function is depicted just\nbelow the device itself.\n\nA continuous point source of A is turned ON in the middle of\nthe field of cells (below). Sketch the spatial pattern that\nthe cells produce at steady state (35 points).\n\nFrom working through the chain of device transfer functions,\nas the signal A increases, the B Generator will respond\nwhich in turn will trigger full response of the B Receiver.\nNote that this response will occur before the Cell Toxin\ndevice responds. Because the B Receiver is producing full\noutput, there will be full Toxin Immunity before the A\nReceiver's about rises high enough to activate the Cell\nToxin device. Note also that the B Receiver feeds back into\nthe B Generator. Thus, even after the A Receiver saturates\n(i.e., turns off) at high input levels, all cells will be\ngenerating and responding to B, and thus Immune and Green.\n\n20.180 Exam 2\n\nName ___________________\n11 May 2006\nClosed Book\n\nA\n\nNote that certain other sketches are possible depending on\nthe subtleties of transcription/translation delay times."
    },
    {
      "category": "Exam",
      "title": "exam2review_ques.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/cf75ca28ff381cdb154a5f2138f39cac_exam2review_ques.pdf",
      "content": "20.180:Exam2reviewQ\nHere are a few simple questions that should remind you of the four sections of our\ncourse:\n1. Python programming\n2. DNA programming\n3. DNA->mRNA->Protein coding\n4. Spatial programming\nQ1. Consider the following two simple Python code examples:\nCase A.\ndef multiply(x,y):\n___prod=x*y\n___return prod\nprint multiply(2,3.14159265)\nprint multiply(4,'MIT')\n\nCase B.\ny=2*3.14159265\nprint y\nz=4*'MIT'\nprint z\n\nWhich is better? Why?\nA1. Case A is better because a reusable function, multiply, has been defined that can be\ncalled many times other as needed (i.e., in different programs).\n\nQ2. What is the difference between an engineered biological part and an engineered\nbiological device?\nA2. A part is a basic biological function that can be encoded as genetic material (e.g., a\nopen reading frame encoding a specific protein). A device is a combination of one or\nmore biological parts that performs a human-defined function (e.g., a genetically encoded\ninverter). Devices are made from parts. Functions encoded by parts are defined by the\nunderlying biology. Functions encoded by devices are defined by the people making the\ndevices.\n\nQ3. How many different codons encode the amino acid methionine? What about\nleucine?\n[please note, I'm not expecting that you have memorized the standard genetic code, rather\nthat you appreciate and could exploit the facts of the answer to this question].\nA3. In the standard genetic code, six different codons can specify the amino acid leucine\n(UUA, UUG, CUU, CUC, CUA, CUG) whereas only a single AUG codon specifies\nmethionine.\n\nQ4. The luxR open reading frame encodes a transcription factor that activates gene\nexpression in the presence of the cell-cell signaling molecule, AHL. Using other\nbiological parts of your choosing (e.g,. ribosome binding sites (RBS), transcription\nterminators, promoters, et cetera), draw a parts-level device diagram for a\ngenetically-encoded receiver device that accepts AHL as an input signal and\nproduces a generic PoPS signal as output. On your sketch, be sure to include the\ndevice boundaries and label the input and output signals. Finally, how would cells\ncontaining this device respond across a spatial gradient of AHL?\n\nA4.\n\nGene-expression RECEIVER gate. A standard PoPS input signal enters from the left\ndriving expression of a gene encoding a receiver protein (LuxR). When a cell-cell\nsignaling molecule (AHL) is also present, the receiver protein activates a standard PoPS\noutput signal leaving from the right. Note that the left side of this device can be\nconnected to a BATTERY device (not shown, simply a constitutive promoter (i.e., a\npromoter that is always ON, providing a constant PoPS signal)) in order to provide a\nmodified device that is always ready to receive."
    },
    {
      "category": "Resource",
      "title": "firstorderdecay.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/21927062023578d6af161b09f4787514_firstorderdecay.pdf",
      "content": "20.180:FirstOrderDecay\nFirst Order Decay (of anything)\nGivens:\n-\nA pile of some thing, X.\n-\nA first-order chemical process by which X is destroyed (or transformed into\nsomething else).\nTasks:\n-\nCompute amount of X remaining as a function of time.\n-\nCompute amount of time until there is half as much X as there is now (this length\nof time is called the \"half-life\" of X or t1 / 2).\nApproach:\n-\nWrite differential equation for change in X over time.\n\n-\nSolve equation for [X] as a function of time, t.\n\n-\nIntegrating from X(t = 0) to X(t = t)\n\n-\nSolving at the limits produces...\n\n-\nWhich provides a general analytical solution for X as a function of time, t\n\n-\nNow, note that at t1 / 2, X\n/ X\n= 0.5\n(t = t)\n(t = 0)\nby definition. So we can substitute and\nget...\nln(0.5) = - k * t\nd\n1 / 2\n-\nWhich is the same as...\n0.69 = k * t\nd\n1 / 2"
    },
    {
      "category": "Resource",
      "title": "sec_orderbinding.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/66c84d9e32393c403362181efe7bc463_sec_orderbinding.pdf",
      "content": "20.180:SecondOrderBinding\nSecond Order Binding (of two things)\nGivens:\n-\nA physical interaction between molecules A and B.\n-\nA system that contains some initial concentration of molecules A and B (A0 and\nB0, respectively).\nTasks:\n-\nCompute the steady state concentrations of free A, free B, and the A:B complex.\nApproach:\n-\nWrite differential equation for change in A:B over time.\n\n-\nSolve equation at steady state (that is, no change in concentration of the A:B\ncomplex.\n0 = + k * [A] * [B] - k * [A:B]\non\noff\n-\nSolve for KD, the dissociation constant.\nEquation 1:\n\n-\nNote constraints on system due to conservation of mass.\nEquation 2: [A ] = [A] + [A:B]\nEquation 3: [B ] = [B] + [A:B]\n-\nNote system of three unknowns with three equations (1-3 above)! Solve for\nunknowns A, B, and A:B (takes you through a quadratic)."
    },
    {
      "category": "Resource",
      "title": "aisb_vol1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/fe34be98647651a3e962efd13e9c32cf_aisb_vol1.pdf",
      "content": ""
    },
    {
      "category": "Resource",
      "title": "20_180_devices.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/d552c57f65c82e37755e28d21bbae131_20_180_devices.pdf",
      "content": "20.180:Devices\nSummary\nThe material on this page covers three topics. First, we briefly review how to make\ndifferent sorts of gene-expression based devices. Second, we develop a simple framework\nfor modeling the behavior of genetic devices. Third, we use the models to estimate some\nphysical characteristics of our devices (for example, device latency).\nIntroduction\nFrom before, you know that a genetically encoded inverter (i.e., a Boolean NOT gate) can\nbe made by combining a ribosome binding site (RBS), driving expression of an open\nreading frame (ORF) encoding a repressor protein, followed by a transcription terminator.\nThe signal is inverted when the repressor protein binds an operator site elsewhere on the\nDNA, resulting in repression of gene expression from the operator site. Click on Figures\n1 and 2 below for more information (See Comic reference if you need more background\ninformation for how genetically encoded inverters work).\n\nFigure 1. Parts of an inverter.\n\nFigure 2. How to make an inverter.\nGenetic Devices\nAn inverter is one type of device. We can produce many different types of gene-\nexpression based devices. For example, all sorts of logic gates can be implemented as\ngene-expression devices. We can also implement other sorts of devices such as sensors,\nactuators, and even cell-cell communication devices. Simple sketches and explanations of\ndifferent gene-expression devices are given below. You can make many more types of\ngenetic devices. The important concept to remember is that you want to make devices\nthat allow subsequent hiding of the details for how the device actually works, so that\nother people can easily use your devices!\n\nFigure 3a. Gene-expression OR gate. Two standard PoPS input signals enter from the left,\ndriving independent expression of identical copies of a gene encoding an activator protein.\nThe activator turns ON a standard PoPS output signal from the operator site on the right.\n\nFigure 3b. Gene-expression NOR gate. Two standard PoPS input signals enter from the\nleft, driving independent expression of identical copies of a gene encoding an repressor\nprotein. The repressor turns OFF a standard PoPS output signal from the operator site on\nthe right.\n\nFigure 3c. Gene-expression AND gate. Two standard PoPS input signals enter from the\nleft, driving independent expression of different genes each encoding one half of a\nheterodimeric activator protein. The heterodimeric activator protein turns ON a standard\nPoPS output signal from the operator site on the right.\n\nFigure 3d. Gene-expression NAND gate. Two standard PoPS input signals enter from the\nleft, driving independent expression of different genes each encoding one half of a\nheterodimeric repressor protein. The heterodimeric repressor protein turns OFF a\nstandard PoPS output signal from the operator site on the right.\n\nFigure 3e. Gene-expression SENDER gate. A standard PoPS input signal enters from the\nleft driving expression of an enzyme that produces a molecule that can travel between\ncells. The molecule defines a cell-cell communication signal specific to the SENDER\ndevice.\n\nFigure 3f. Gene-expression RECEIVER gate. A standard PoPS input signal enters from\nthe left driving expression of a gene encoding a receiver protein. When a cell-cell\nsignaling molecule is also present, the receiver protein activates a standard PoPS output\nsignal leaving from the right. Note that the left side of this device can be connected to a\nBATTERY device (not shown, simply a constitutive promoter (i.e., a promoter that is\nalways ON, providing a constant PoPS signal)) in order to provide a modified device that\nis always ready to receive.\n\nDevice Modeling\nThe above depictions of genetic devices provide qualitative descriptions of device\nfunction (for example, if the input signal to an inverter is HIGH then the output signal\nfrom the inverter will be LOW). But, in reality, each device is a physical object, which\nimposes constraints on its exact operation and use. Here, we will use some simple\nmodeling to get a sense for the physical behavior of our genetic devices. To start, let's\ndefine some of the device characteristics that we might care about. We'll use an inverter\ndevice as an example. One important property of our inverter is its transfer function,\nwhich is the steady state relationship between the device input and output signals. A\nsecond property is the device latency, which is the time it takes the device output signal\nto change in response to a change in the device input signal. To begin to model the\ninverter device we'll need to revisit the physical processes that are required for device\noperation. Our goal will be to build a model from these details that can be used to make\nsome simple mathematical estimates of the inverter's transfer function and latency.\nTo make our analysis simpler let's split (decouple) an inverter into two sub-devices\n(Figure 4). The first sub-device is a \"protein generator\" (a protein generator takes a\ngeneric PoPS input signal and produces a specific protein as output). The second sub-\ndevice is a \"PoPS regulator\" (a PoPS regulator takes a specific regulatory protein as input\nand produces a generic PoPS signal as output). We'll model the transfer function and\nlatency of each device individually and then combine the results in order to produce an\noverall model for our inverter.\n\nFigure 4. A decoupled genetic inverter.\n\nProtein Generator Modeling\nWe need to develop a model that lets us estimate the transfer function (input:output\nrelationship) and latency of the protein generator. The input to the protein generator is a\nPoPS input signal (let's call this P_in). The output is the concentration of the repressor\nprotein (let's call this R). The transfer function should describe R as a function of P_in.\nWe can get started by writing down the physical processes that take place between arrival\nof a RNA polymerase molecule and the production of a repressor protein. First, the RNA\npolymerase enters the device and carries out transcription, producing a messenger RNA\n(mRNA) molecule. The RNA polymerase molecules will move basepair-by-basepair\ndown the DNA encoding our protein generator device until they arrive at the terminator\npart (at which point they will stop transcription). Then, ribosomes will bind the newly\nproduced mRNA molecules at the ribosome binding site (RBS) and start the process of\nprotein synthesis (translation). The ribosomes will move nucleotide-by-nucleotide down\nthe mRNA molecule until they arrive at a stop codon (in bacteria the triplets UAA, UGA\n& UAG can act as stop codons). To complete our model we should also account for the\nloss of mRNA and protein via mRNA and protein degradation, respectively. Furthermore,\nif the cell in which our device is operating is itself growing, then we may also need to\naccount for the dilution of mRNA and protein levels via cell division. Phew! This is a lot\nof stuff to remember and pay attention to. How are we going to estimate transfer function\nand latency? Let's make a big simplification by writing down a differential equation that\ndescribes how the concentration of R changes over time:\nEquation 1:\n\nWe've introduced two new variables, f(P )\nin and kd. Here, f(P )\nin is a placeholder function\nthat describes the relationship between P_in, the PoPS input signal, and the rate of\nrepressor protein synthesis. kd is just a first-order decay rate for the loss of R. The first\nterm in this equation makes a big leap directly from PoPS to protein synthesis (we're\nhiding all the details of transcription and translation). The second term in this equation\ncaptures the rate of destruction of R due to degradation (and dilution due to growth, if we\nwant to include that too). If we can come up with some values for these terms in then we\ncan estimate how R will change as a function of P_in and how quickly these changes will\nhappen.\nLet's start with kd. kd is the rate constant for protein degradation. The exact value of kd\nwill depend on the particular protein used in our device. Some proteins are incredibly\nstable and for all practical purposes don't degrade (for example, green fluorescent\nprotein). Other proteins are actively degraded by the cell and will disappear quickly if\nthey are not continuously being synthesized. Protein stability is typically reported in\nterms of a \"half-life\" (half-life, t1 / 2, is the amount of time it takes for one half of\nsomething, repressor protein in this case, to be degraded). So, a stable protein will have\nwhereas an unstable protein will have\nminutes. You can quickly\n\nconvert between a t1 / 2 and first-order kd value via the following formula: k = 0.69 / t\nd\n1 / 2.\nSee First Order Decay reference if you don't know where this formula comes from.\nWithout going through all the details, the value for f(P )\nin might range from 0 to 100\nproteins per minute (for a device that is present at single \"copy number\" per cell; copy\nnumber is the number of DNA molecules inside the cell carrying a particular gene, part,\ndevice or system). For this first example, let's use t\n= 10\n1 / 2\nminutes and an input range of\nf(P ) =\nin\n0 to 70 proteins per minute. From t\n= 10\n1 / 2\nminutes we get\nper\nminute. We can solve for the low and high steady state values of R by using the above\nequation. For example, at the low input value we get:\n\nwhich at steady state reduces to 0 = 0 - 0.07 * [R ]\nss or [R ] = 0\nss\nproteins per cell.\nThis shouldn't be surprising. Since we are not producing any R the steady state value of\nR is zero.\nNext, at the high input value we get:\n\nwhich at steady state reduces to 0 = 70 - 0.07 * [R ]\nss or [R ] = 1000\nss\nproteins per cell.\nThus, we now know the low and high range of the output signal R from our protein\ngenerator device. Furthermore, by setting the left side of equation 1 (above) to zero, we\ncan provide a general formula for the steady-state output level of R as a function of P_in\n(Figure 5):\nEquation 2:\n\nFigure 5. Steady state transfer function for protein generator device.\n\nThe next (last) thing to estimate using our model is the latency of the protein generator\ndevice. Again, latency is defined as the time it takes for the output signal of a device to\nreach a new level in response to a change in the input signal level. Because gene\nexpression is a slow process (when compared, for example, to silicon-based computers)\nwe'll need to pay close attention to issues of latency. Figure 6 below details the two types\nof latency we are interested in, low->high and high->low.\n\nFigure 6. Latency is the time it takes for the output signal of a device to reach a new level\ngiven a change in the level of the input signal. The green curve shows the input signal as\na function of time; the red curve is the output signal as a function of time. Note that as the\ninput signal level changes that it takes some time (L) for the output signal to reach its\nnew level.\n\nTo estimate the latency during a LOW-to-HIGH transition (LLH) we can again return to\nEquation 1 above. Imagine that there is no R present in the cell. How long does it take for\nthe R level to reach its steady state concentration [R s] = 1000\ns\nin response to a change in\nP_in from 0 to 70? One rough estimate is 1000/70 or ~14 minutes. However, this will be\nan underestimate because as the R level increases the newly produced R molecules will\nbe subject to degradation. For now, we'll simply increase our LLH estimate to ~20 minutes.\nTo estimate the latency during a HIGH-to-LOW transition (LHL) start by imagining a cell\nin which there are 1000 R molecules when, suddenly, the value of P_in drops from 70 to\n0. How long will it take the level of R to drop to zero? From above we know that the\nlevel of R will drop by a factor of two every 10 minutes. For example, in 20 minutes the\nR level will drop to ~250 molecules per cell.\nThus, we've already been able to make a simple model and use it to estimate the transfer\nfunction and latency of our protein generator:\n\nf(P_in) ranges from 0 to 70 proteins per minute.\nR ranges from 0 to 1000 proteins per cell.\nThe full relationship between input and output can be expressed via Equation 2 (above).\nIt takes ~20 minutes for the output signal to respond to an increase in the input signal\nfrom 0 to 70 proteins per minute.\nIt also takes ~20 minutes for the output signal to respond to a decrease in the output\nsignal from 70 to 0.\nPoPS Regulator Modeling\nNext, let's develop a model that we can use to estimate the transfer function and latency\nof the right half of our inverter, the \"PoPS regulator.\" The input to the PoPS regulator is\nthe concentratration of repressor protein, R. The output is a standard PoPS signal (let's\ncall this P_out). Again, we'll get started by writing down the physical processes that take\nplace during device operation.\nFirst, R protein binds and interacts with an operator site on the DNA. Binding of the\nrepressor protein to the operator site physically blocks (occludes) binding by RNA\npolymerase. When R is bound to the operator, no RNA polymerase can bind, so that the\nP_out signal is zero. When R is absent from the system RNA polymerase can bind the\noperator and initiation transcription, creating a high P_out signal.\nThe interaction between the R protein and the operator site can be modeled as a generic\nsecond order binding system, A+B<->AB (note that this is the same framework used to\nrepresent a simple ligand:receptor binding system); see Second Order Binding reference\nfor a refresher. Using such a model, we'll want to estimate the fraction of operator site\nthat is occupied by R protein at any instant in time. Let's start by using a simple\ndifferential equation that tracks the amount of repressor:DNA complex, R:D as a\nfunction of time:\n\nLet's estimate some typical values for our rate constants. k n\no is the rate at which R bind\nthe operator site on DNA. Let's estimate that this is near the \"diffusion limit\" for proteins\ninside cells or 1E9/M*second. Next, let's consider what happens for a R:D complex that\nhas a dissociation constant of 1nM (K = 1E - 9M\nD\n). From the Second Order Binding\nreference we know that K = k / k\nD\noff\non. From this we can compute that koff for our system\nis 1/second. We're almost ready to substitute these values into the above equation, but\nfirst we need to estimate one more thing, the concentration of DNA inside the cell.\nBacteria usually a single copy of their genome inside the cell (fast growing bacteria and\nradiation resistant bacteria sometimes have multiple copies of their genomes). The\nvolume of E.coli is approx. 1E-15L (it's a pretty small critter). Note that 1 moleculeper\n1E-15L is the same concentration as 1E15 molecules per liter, which is about 1E-9M. Or,\nin other words, 1 molecule per E.coli cell is a concentration of ~1nM. Phew. Now we can\nstart substituting into the above equation.\n\nWhich simplifies to:\n\nFrom this equation alone we can get a sense for what the latency of our PoPS regulator\nwill look like. Imagine that the input concentration of R goes instantly from 0 to 1000\nproteins per cell. It will only take a couple seconds for the P_out signal to update.\nSimilarly, if the R level drops from 1000 to 0, it should take a couple seconds for the\nP_out signal to rise. Thus, the latency of our PoPS regulator should be neglible compared\nto the tens of minutes required for our protein generator to respond.\nWhat about a transfer function for the PoPS regulator? Like before, we need a function\nthat will let us estimate P_out as a function of the input R concentration. To start, we\nknow that at a zero R input level the P_out level will be maximum. We also know that at\nan infinite R input level that the P_out level should be zero. For the in between regions,\nif we can estimate the fraction of time that the operator site is bound by R then we can\nscale the maximum P_out level to reflect the actual P_out level as a function of R. Let's\nrevisit some simple models. First, repressor and DNA form a complex with dissociation\nconstant KD:\nand\n\nNext, the repressor conservation of mass equation is:\n[D\n] = [D] + [R:D]\ntotal\nSubstitution gets us:\n\nSolving for [R:D] produces:\n\nSubstituting into the conservation of mass equation (above) and dividing by [D_total]\ngets us the fraction of operator bound by R:\n\nOne minus this value is the fraction of operator unoccupied by R:\n\nPhew! So, our P_out as a function of R looks like:\n\nFigure 7. Steady state transfer function for PoPS regulator device.\n\nWe won't go derive it here but note that you can tune the shape of the PoPS regulator's\ntransfer function by using an activator in place of a repressor, or by using a\nrepressor/activator molecule that binds as a dimer, tetramer or even a higher-order\nmolecular complex. Many natural biological systems use dimeric and tetrameric DNA\nregulatory molecules to \"sharpen\" their dose-response transfer functions. This is useful\nfor producing a \"switch-like\" dose response. For example, here's the generic form of the\ntranser function for a repressor protein that binds as a N-mer (where N is the number of\nmolecules required to bind the operator site on the DNA):\n\nWhat sort of transfer function is produced for N=4?\n\nCombining Models\nOK. Now we can combine our two sub-device models to produce an estimate for overall\ndevice latency and input/output transfer function. Note that latency will be dominated by\nthat of our protein generator sub-device. So, the device latency is still on a timescale of\n10s of minutes. What about the transfer function? We want to go from PoPS_in to\nPoPS_out. Can we somehow combine the two sub-device transfer functions?\n\nFigure 8. What happens when we combine the steady state transfer functions of our two\nsub-devices?\n\nThe short answer is YES but what happens and whether or not the resulting behavior is\nuseful to us will depend on how the exact (that is, quantitative) signal levels match\nbetween our two devices. For example, is the R_out level from the protein generator\ndevice is much lower than the K_D value in our PoPS regulator device, no amount of\nresponse from the protein generator device will drive a response in the PoPS regulator.\nIdeally, we might want to start by designing our two sub-devices so that the middle R_out\nlevel from the protein generator is roughly equal to the K_D of the PoPS regulator. This\nwill result in signal level matching between the two devices.\nCombining the two steady state transfer functions from our subdevices produces an\noverall transfer function for our inverter device:"
    },
    {
      "category": "Resource",
      "title": "20_180_introduct.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/20-180-biological-engineering-programming-spring-2006/8b2a352d4c6009141fc21408c5f799cd_20_180_introduct.pdf",
      "content": "20.180:Introduction\n\nKey Concepts from Day 1\n1. Develop a crisp answer to the question \"What is Biological Engineering?\" (see\nbelow).\n2. Understand how DNA synthesis lets you \"write\" DNA.\n3. Understand how DNA sequencing and synthesis technologies complement one\nanother, allowing interconversion between genetic material (DNA) and genetic\ninformation (...ATCG...).\n4. Recognize the challenge of going from (A) imagining an engineered biological\nsystem that you might want (for example, a genetic oscillator or a self-growing\ntree house) to (B) the actual DNA sequence that programs a living system to\nproduce your imaginable system.\nPreliminary Assessment Q&A\n-\nWhat is Biological Engineering?\no Biological Engineering is the characterization, analysis, and design of\nnatural and synthetic biological systems for useful purposes.\n\n-\nWhat does DNA do?\no DNA is the genetic material that encodes the information which defines\nsome of the behavior of biological systems.\n\n-\nWhat is DNA sequencing?\no DNA sequencing is a technology that allows physical genetic material to\nbe \"read out,\" producing a string of information (for example,\nATCGTACA...).\n\n-\nWhat is DNA synthesis?\no DNA synthesis is a technology that allows raw chemicals to be combined\nwith information to produce physical genetic material.\n\n-\nWhat are some tools or approaches that are useful for solving complex\nproblems?\no Decoupling and decomposition, abstraction, standardization, working in a\ngroup, taking a deep breath, and many more.\n\n-\nWrite down, at whatever level of resolution you most prefer, the genetic\nprogram that would make a bacterium blink over time - like a little\nmicroscopic lighthouse:\ngtaatacggttataggcatcaaataaaacgaaaggctcagtcgaaagactgggcctttcgttttatctgttgtttgtcggtgaacgct\nctcctgagtaggacaaatccgccgggagcggatttgaacgttgcgaagcaacggcccggagggtggcgggcaggacgccc\ngccataaactgccaccacagaatcaggggataaatatctaacaccgtgcgtgttgactattttacctctggcggtgataatggttgc\natgtactagatgtgaaaccagtaacgttatacgatgtcgcagagtatgccggtgtctcttatcagaccgtttcccgcgtggtgaacc\naggccagccacgtttctgcgaaaacgcgggaaaaagtggaagcggcgatggcggagctgaattacattcccaaccgcgtggc\nacaacaactggcgggcaaacagtcgttgctgattggcgttgccacctccagtctggccctgcacgcgccgtcgcaaattgtcgc\nggcgattaaatctcgcgccgatcaactgggtgccagcgtggtggtgtcgatggtagaacgaagcggcgtcgaagcctgtaaag\ncggcggtgcacaatcttctcgcgcaacgcgtcagtgggctgatcattaactatccgctggatgaccaggatgccattgctgtgga\nagctgcctgcactaatgttccggcgttatttcttgatgtctctgaccagacacccatcaacagtattattttctcccatgaagacggta\ncgcgactgggcgtggagcatctggtcgcattgggtcaccagcaaatcgcgctgttagcgggcccattaagttctgtctcggcgc\ngtctgcgtctggctggctggcataaatatctcactcgcaatcaaattcagccgatagcggaacgggaaggcgactggagtgcca\ntgtccggttttcaacaaaccatgcaaatgctgaatgagggcatcgttcccactgcgatgctggttgccaacgatcagatggcgctg\nggcgcaatgcgcgccattaccgagtccgggctgcgcgttggtgcggatatctcggtagtgggatacgacgataccgaagaca\ngctcatgttatatcccgccgtcaaccaccatcaaacaggattttcgcctgctggggcaaaccagcgtggaccgcttgctgcaact\nctctcagggccaggcggtgaagggcaatcagctgttgcccgtctcactggtgaaaagaaaaaccaccctggcgcccaatacgc\naaaccgcctctccccgcgcgttggccgattcattaatgcagctggcacgacaggtttcccgactggaaagcgggcaggcagca\naacgacgaaaactacgctttagcagcttgaaacgcaggaaagaccaggcatcaaataaaacgaaaggctcagtcgaaagact\ngggcctttcgttttatctgttgtttgtcggtgaacgctctcctgagtaggacaaatccgccgggagcggatttgaacgttgcgaagc\naacggcccggagggtggcgggcaggacgcccgccataaactgccacacgctcaccggctccagatttatcagcaattccctat\ncagtgatagagattgacatccctatcagtgatagagatactgagcacatcagcaggacgcactgaccaaatgagcacaaaaaa\ngaaaccattaacacaagagcagcttgaggacgcacgtcgccttaaagcaatttatgaaaaaaagaaaaatgaacttggcttatcc\ncaggaatctgtcgcagacaagatggggatggggcagtcaggcgttggtgctttatttaatggcatcaatgcattaaatgcttataa\ncgccgcattgcttgcaaaaattctcaaagttagcgttgaagaatttagcccttcaatcgccagagaaatctacgagatgtatgaagc\nggttagtatgcagccgtcacttagaagtgagtatgagtaccctgttttttctcatgttcaggcagggatgttctcacctgagcttagaa\ncctttaccaaaggtgatgcggagagatgggtaagcacaaccaaaaaagccagtgattctgcattctggcttgaggttgaaggtaa\nttccatgaccgcaccaacaggctccaagccaagctttcctgacggaatgttaattctcgttgaccctgagcaggctgttgagccag\ngtgatttctgcatagccagacttgggggtgatgagtttaccttcaagaaactgatcagggatagcggtcaggtgtttttacaaccac\ntaaacccacagtacccaatgatcccatgcaatgagagttgttccgttgtggggaaagttatcgctagtcagtggcctgaagagac\ngtttggcgcagcaaacgacgaaaactacgctttagcagcttgaaccagccagcaggcatcaaataaaacgaaaggctcagtcg\naaagactgggcctttcgttttatctgttgtttgtcggtgaacgctctcctgagtaggacaaatccgccgggagcggatttgaacgtt\ngcgaagcaacggcccggagggtggcgggcaggacgcccgccataaactgccacggaagggccgagcgcgacccacgct\ncaccggctccagatttatcagcaataaaccagccagccggaagggccgagcgcaagaacatgtgagcaaaaggccagcaaa\naggccaggaaccgtaaaaaggccgcgttgctggcgtttttccataggctccgcccccctgacgagcatcacaaaaatcgacgct\ncaagtcagaggtggcgaaacccgacaggactataaagataccaggcgtttccccctggaagctccctcgtgcgctctcctgttc\ncgaccctgctccctatatgagtaaaaggcatcaaataaaacgaaaggctcagtcgaaagactgggcctttcgttttatctgttgtttg\ntcggtgaacgctctcctgagtaggacaaatccgccgggagcggatttgaacgttgcgaagcaacggcccggagggtggcgg\ngcaggacgcccgccataaactgccacttggtctgacagttaccaatgcttaatcagtgaggcacctatctcagcgatctgtctattt\ncgttcatccatagttgcctgactccccgtcgtgtagataactacgatacgggagggcttaccatctggccccagtgctgcaatgat\naccgcgagacccacgctcaccggctccagatttatcagcaataaaccagccagccggaagggccgagcgcagaagtggtcct\ngcaactttatccgcctccatccagtctattaattgttgccgggaagctagagtaagtagttcgccagttaatagtttgcgcaacgttgt\ntgccattgctgcaggcatcgtggtgtcacgctcgtcgtttggtatggcttcattcagctccggttcccaacgatcaaggcgagttac\natgatcccccatgttgtgcaaaaaagcggttagctccttcggtcctccgatcgttgtcagaagtaagttggccgcagtgttatcact\n\ncatggttatggcagcactgcataattctcttactgtcatgccatccgtaagatgcttttctgtgactggtgagtactcaaccaagtcatt\nctgagaatagtgtatgcggcgaccgagttgctcttgcccggcgtcaacacgggataataccgcgccacatagcagaactttaaa\nagtgctcatcattggaaaacgttcttcggggcgaaaactctcaaggatcttaccgctgttgagatccagttcgatgtaacccactcg\ntgcacccaactgatcttcagcatcttttactttcaccagcgtttctgggtgagcaaaaacaggaaggcaaaatgccgcaaaaaag\nggaataagggcgacacggaaatgttgaatactcatactcttcctttttcaatattattgaagcatttatcagggttattgtctcatgagc\nggatacatatttgaatgtatttagaaaaataaacaaataggggttccgctcgatcgagaattgtgagcggataacaattgacattgt\ngagcggataacaagatactgagcacatcagcaggacgcactgaccatggcacggctgaacagagaatcggttattgatgcgg\ncactggaactgctgaatgagacagggattgacgggctgacgacccgcaagctggcgcagaagctgggaatagaacagccga\ncactttactggcatgtgaaaaataaacgggcgttactggatgcgctggcggtggagatcttggcgcgtcatcatgattattcactg\ncctgcggcgggggaatcttggcagtcatttctgcgcaataatgcaatgagtttccgccgggcgctgctgcgttaccgtgacggg\ngcaaaagtgcacctcggcacccgccctgatgaaaaacagtatgatacggtggaaacccagttacgctttatgacagaaaacgg\ncttttcactgcgcgacgggttatatgcgatttcagcggtcagtcattttacccttggtgccgtactggagcagcaggagcatactgc\ncgccctgaccgaccgccctgcagcaccggacgaaaacctgccgccgctattgcgggaagcgctgcagattatggacagtgat\ngatggtgagcaggcctttctgcatggcctggagagcctgatccgggggtttgaggtgcagcttacggcactgttgcaaatagtcg\ngtggtgataaacttatcatccccttttgcgcagcaaacgacgaaaactacgctttagcagcttgagtaatacggttataggcatcaa\nataaaacgaaaggctcagtcgaaagactgggcctt"
    }
  ]
}