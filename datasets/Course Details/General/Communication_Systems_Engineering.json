{
  "course_name": "Communication Systems Engineering",
  "course_description": "This course will cover fundamentals of digital communications and networking. We will study the basics of information theory, sampling and quantization, coding, modulation, signal detection and system performance in the presence of noise. The study of data networking will include multiple access, reliable packet transmission, routing and protocols of the internet. The concepts taught in class will be discussed in the context of aerospace communication systems: aircraft communications, satellite communications, and deep space communications.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Computer Networks",
    "Electrical Engineering",
    "Digital Systems",
    "Telecommunications",
    "Systems Engineering",
    "Engineering",
    "Computer Science",
    "Computer Networks",
    "Electrical Engineering",
    "Digital Systems",
    "Telecommunications",
    "Systems Engineering"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1.5 hours / session\n\nOverview\n\nThis course will cover fundamentals of digital communications and networking. We will study the basics of information theory, sampling and quantization, coding, modulation, signal detection and system performance in the presence of noise. The study of data networking will include multiple access, reliable packet transmission, routing and protocols of the internet. The concepts taught in class will be discussed in the context of aerospace communication systems: aircraft communications, satellite communications, and deep space communications.\n\nPrerequisites\n\n16.001-16.004\nUnified Engineering\nor 6.003\nSignals and Systems\n; 6.041\nProbabilistic Systems Analysis\n\nRequirements and Grading\n\nACTIVITIES\n\nPERCENTAGES\n\nProblem sets (about one per week)\n\n10%\n\nAttendance, participation, short quizzes\n\n15%\n\nQuiz 1\n\n25%\n\nQuiz 2\n\n25%\n\nQuiz 3 (during finals week)\n\n25%\n\nTextbook\n\nProakis, John, and Masoud Salehi.\nCommunication Systems Engineering\n. 2nd ed. Upper Saddle River, NJ: Prentice Hall, 2001. ISBN: 9780130617934.\n\nSupplementary Texts and References\n\nHaykin, Simon.\nCommunication Systems\n. 5th ed. New York, NY: Wiley, 2009. ISBN: 9780470169964.\n\nTanenbaum, Andrew.\nComputer Networks\n. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2002. ISBN: 9780130661029.",
  "files": [
    {
      "category": "Assignment",
      "title": "Problem Set No. 1",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/c04991953430d41751bb4acd73de98a0_MIT16_36s09_assn01.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nDepartment of Aeronautics and Astronautics\n16.36: Comm. Sys. Engineering\nProblem Set No. 1\nProblem 1: Text problem 2.12, choose any four of the six\nProblem 2: Text problem 2.13\nProblem 3:\na) Derive the Fourier transform for Cos(2!fot); (see Table 2.1 for the answer, but provide\nthe derivation!)\nb) Suppose fo = 10, and that the signal is sampled at sampling rate of 30 samples per second.\nSketch the frequency response of the sampled signal and show how a low-pass filter can\nrecover the original signal.\nc) Now suppose that the signal is sampled at a rate of 15 samples per second; sketch the\nfrequency response of the sampled signal.\nNote: In your sketches, you can limit yourselves to a bandwidth of 40Hz.\nProblem 4: Text problem 2.40 (part 1 only). Instead of x(.005), solve for x(.01).\nProblem 5: Matlab Exercise\na) Generate a sinusoidal waveform with two frequency components, 5 Hz and 10 Hz. Since\nMatlab only uses discrete (sampled, not continuous) signals, a sampling rate must be\nchosen to properly produce the waveform without aliasing. Any rate above 20 Hz will\nsuffice, so use 30 Hz. Produce a one second plot of the waveform.\nb) We next will find the frequency spectrum of the signal from part a. To do so, first use the\nFast Fourier Transform function (fft) to bring the signal into the frequency domain. Use\nthe fftshift function to produce a plot that will zero center the signal.\nc) Now, create a lowpass filter to recover the 5 Hz component of the signal. Produce a plot\nof the filter and the filtered signal in the frequency domain.\nd) With the filtered signal, take the Inverse Fast Fourier Transform (ifft) to bring the\nsignal back into the time domain. Produce a plot with one second of the signal to show\nthat the 5 Hz signal was recovered. Hint: ifft needs the signal to be in the same form as\nthe output of the fft, so if you were working with the shifted signal, you will need to\nshift it again before inputting it to the ifft.\nBe sure to turn in commented code and clearly labeled plots.\nUsage information with examples on the Fast Fourier Transform (fft) is located at\nhttp://www.mathworks.com/access/helpdesk/help/techdoc/math/brentm1-1.html (same as located\nin the Matlab documentation).\nFor information on the Inverse Fast Fourier Transform function (ifft), see Matlab\ndocumentation for usage details."
    },
    {
      "category": "Assignment",
      "title": "Problem Set No. 2",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/b772f54a4ee1946175f7240e72136f41_MIT16_36s09_assn02.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nDepartment of Aeronautics and Astronautics\n16.36: Comm. Systems Engineering\nProblem Set No. 2\nProblem 1: Text problem 6.6\nProblem 2: Text problem 6.11\nPart 3) What is the mean squared-error distortion for the quantization rule in part 2?\nPart 4) Now consider the quantization rule in part 2 of the question. Can a different three-\nlevel quantization rule have been chosen to yield a higher entropy? If so, describe\nthe rule and the resulting entropy and mean squared-error distortion. Did the\ndistortion increase or decrease?\nProblem 3: Text problem 6.41, solve using Table 6.3 (Optimal Non-Uniform Quantizer for a\nGuassian Source).\nProblem 4: Text problem 6.46* (not part 4)\n*Note that the tables give the distortion (D) and ! values for a Gaussian source with 0 mean and\n\"2 = 1. To adjust your results for a source with Power \"2=Px, you must multiply the distortion\nvalues by \"2 and the ! values by \" = (Px)1/2\nProblem 5: Matlab Exercise\nIn this exercise, you will implement a quantizer for a sampled audio stream and see the effects of\nreducing the number of quantization levels on sound quality.\na) Download the audio file clip.wav from the materials section on the course\nwebsite. Use the Matlab function wavread to read the audio clip into Matlab. Be\nsure to capture all the outputs, as you will need these to properly play back the\nquantized version you will produce. You can play back a vector using the sound\nfunction.\nb) Create a function called quantize that will take as input the sound vector produced\nfrom wavread and the number of quantization levels, N, as a power of two (an input\nof 4 would be 2 quantization levels). For simplicity, implement a uniform quantizer\nwith the region size, !, being evenly spaced across the range of the input sound and\nxi being assigned the middle of the region.\nc) The quantizer function should return the following:\na. Quantized waveform ready for playback\nb. Entropy of the quantized waveform\nc. Mean squared-error distortion between the quantized waveform and the\noriginal input\nd) Run your function for N = 1, 2,..., 8. Play back the result using sound to hear the\ndistortion (remember to use the values returned from wavread). Note: As the\nnumber of quantization levels increases, the running time will take longer.\nTurn in your commented code with resulting entropy and distortion for the different quantization\nlevels."
    },
    {
      "category": "Assignment",
      "title": "Problem Set No. 3",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/fc4dce23b2e5b625e03192a3d1b68cf5_MIT16_36s09_assn03.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nDepartment of Aeronautics and Astronautics\n16.36: Comm. Sys. Engineering\nProblem Set No. 3\nProblem 1: Text Problem 6.22\nAssume the source alphabet {a1, a2, a3, a4} has corresponding probabilities {.15, .2, .3, .35}\nProblem 2: Text Problem 6.23\nProblem 3: Text Problem 6.25\nAssume a source with output alphabet probabilities of {.05, .1, .15, .1, .25, .15, .2}\nProblem 4: Matlab Exercise\nIn this exercise, you will take the quantized waveform from Problem Set 2 and compress\nit using the Lempel-Ziv algorithm.\na) Modify your quantize function from the last assignment (or the solution posted\nonline if you prefer) to also produce an encoded output in bits, as opposed (or in\naddition) to the real-valued midpoints from before. The output in bits should\ncorrespond to the level that was decided upon. If the quantization was for two bits\n(which means four levels), each output should only be two bits long; assign '00' to\nthe first level, '01' to the second level, etc.\nThis can be done in a number of different ways in Matlab. The easiest way may be to\ncreate a string of bits using the dec2bin (decimal to binary) function and specifying\nthe number of bits to output (see function help for more details).\nb) For three-bit quantization (N=3), create a dictionary using the Lempel-Ziv algorithm\nfor the encoded bit-stream outputted from quantize. If you create a string of bits as\nthe output from the quantize function, then you may be interested in the strcmp\n(sting compare) function and using cells as opposed to arrays to store your dictionary\ncontents. See Matlab help for details on both.\nc) From the dictionary that you created in part b, create a set of codewords using the\nLempel-Ziv algorithm. Again, you may find it easier to use cells to store your\ncodewords, as opposed to an array.\nd) Discussion: How many entries are in the dictionary? How many bits is each\ncodeword? How many bits are needed to transmit the entire compressed waveform?\nWhat is the compression ratio between the compressed and uncompressed waveform?\nNote: This may take up to 15 minutes to run (which is why only N=3 is asked, N=8 can\ntake hours). You may want to test on smaller sequences first, such as the example given\nin section 6.3.2 of the text."
    },
    {
      "category": "Assignment",
      "title": "Problem Set No. 4",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/d2960ec063f32c57b0a22d2e29eb1a48_MIT16_36s09_assn04.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nDepartment of Aeronautics and Astronautics\n16.36: Comm. Sys. Engineering\nProblem Set No. 4\nProblem 1: Text problem 7.42\nHint: For the M=8 constellation you will need your trigonometric laws of sins and cosines. For\nthe probability of error just consider the power required to keep adjacent symbols at the same\ndistance under both constellations.\nProblem 2: Text problem 7.48 (except part 3)\nProblem 3:\nA source signal, represented by a binary sequence with information rate Rb = 9 kbps, is to be\ndigitally modulated and transmitted over a channel. The modulation method is M-ary PAM\n(Pulse Amplitude Modulation). The basic pulse is a rectangular function of time:\ng(t) =\n\nA\nt ∈[0,T ]\n0 otherwise\nThe carrier frequency allocated to this system is fc = 900MHz. Frequency planning regulations\nrequire that the two-sided null-to-null bandwidth of g(t) does not exceed 6 kHz.\nA) Determine the lowest modulation level M for which the bandwidth requirements are met.\nB) Propose a scheme for mapping the input bits into modulation waveforms. Make sure that\nwaveforms with adjacent amplitude levels differ by one bit only.\nC) Sketch the equivalent baseband signal if the input bit sequence is 011000111010.\n\nProblem 4: Matlab Exercise\nIn this exercise, you will construct an M-ary symmetric PAM bandpass modulator function.\n(This is not nearly as long as it looks)\nA) Your function should look like the following:\na. Inputs to your function will be a bit string to modulate, modulation level M, distance\nbetween the levels, carrier frequency, and sampling frequency. Output should be a vector\ncontaining the modulated waveform.\nb. The textbook (and notes) gives an equation for the different amplitude levels as Am =\n(2m-1-M). A modification to this equation to reflect the input distance between levels, d,\nwould be Am = (d/2)*(2m-1-M). You can verify that this will produce the desired\namplitude levels.\nc. The pulse shaping function, g(t), should be a rectangular function with amplitude A. You\ncan set A = 1 for this assignment.\nd. The symbol rate must be an integer multiple, n, of the carrier frequency. You can set n=1.\ne. As seen in the lecture notes, for a bandpass modulater, the transmitted waveform can be\nrepresented by Amg(t)cos(2πfct). You can recall from HW 1, that Matlab only works with\ndiscrete waveforms. Your carrier waveform needs to be constructed by sampling it at the\ninput sampling frequency.\nf. Take one symbol's worth of bits at a time to modulate, and construct an entire modulated\nwaveform.\nB) Use the following as inputs:\na. Carrier frequency of 1 Hz.\nb. Sampling frequency must be at least at the Nyquist rate. But to produce nicer plots,\nchoose the sampling frequency to be 100 Hz.\nc. Distance between the different signaling levels is 2.\nd. Two different M's with respective input bit strings\ni. M = 4, input: '00011011'\nii. M = 8, input: '000001010011100101110111'\n(You should notice that these are simply all of the symbols in order)\nC) Please produce as output a clearly labeled plot of the modulated waveform for M=4 and\nM=8. Make sure to comment all of your code."
    },
    {
      "category": "Assignment",
      "title": "Problem Set No. 5",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/7300b03a5823eae72e7cd02d47654dc0_MIT16_36s09_assn05.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nDepartment of Aeronautics and Astronautics\n16.36: Comm. Sys. Engineering\nProblem Set No. 5\nProblem 1: Text problem 7.5\nProblem 2: Text problem 7.14, parts 1, 2, and 3\nProblem 3: Text problem 7.16 (for simplicity let g(t) = Sinc(t))\nProblem 4: Text problem 7.18*\n*Determine and sketch the impulse response of the matched filter for all 3 cases. Determine the\nimpulse response of the output of the matched filter for case c only (you may do the others for\nfun, if you like...)\n\nProblem 5: Matlab Exercise\nIn this exercise, you will create a PAM matched-filter demodulator function to work with the\nPAM bandpass modulator that you created in the previous problem set.\nA) Your function should look like the following:\na. Inputs to your function should be the bandpass modulated waveform generated by\nyour modulator function, the carrier frequency, the sampling frequency, the distance\nbetween amplitude levels, and the number of modulation levels M. You may find the\nfollowing modifications to your modulator useful:\ni. Output the time vector for the modulated waveform corresponding to the\nsampling rate. This can be used as an input to your demodulator, allowing you\nto not recalculate it.\nii. Output the pulse shaping function g(t). This can then be used as your matched\nfilter, g(T-t).\nb. The notes and text give a schematic for demodulation.\ni. First multiply your input waveform by 2cos(2πfct). Remember that Matlab\nonly works with discrete waveforms and you will need to generate a cosine\nthat corresponds to the length in time of your modulated waveform, and\nsampled at the correct rate. This is why it is useful to have the time vector\ngenerated by the modulator as an input.\nii. Now pass the signal through the matched filter. This is commonly\nimplemented as a convolution between the input waveform and the matched\nfilter. In Matlab, use the function conv to perform the convolution. The output\nof your convolution must be scaled by Rs*fc/fs, where Rs is the symbol rate,\nwhich we previously set to 1. This scaling is necessary because Matlab is\nperforming a convolution on a vector representing discrete points in time.\nc. The output of the matched filter will be sampled at t=kT to decide on the kth\ntransmitted symbol. Time T corresponds to fs/(fc*Rs).\nd. Design a simple detector based on the distance between amplitude levels. Make the\ndecision region boundaries equidistant between amplitude levels.\ne. Decode the decision using the same encoding scheme you used for the modulator.\nCreate a bit string output.\nB) We will use the same inputs that we used for the modulator\na. Carrier frequency of 1 Hz.\nb. Sampling frequency of 100 Hz.\nc. Distance between the different signaling levels is 2.\nd. Two different M's with respective input bit strings\ni. M = 4, input: '00011011'\nii. M = 8, input: '000001010011100101110111'\nC) Please produce as output the plot of the output of your matched filter (convolution) for M=4\nand M=8. Also print your decision points and output bit string. Make sure to comment all of\nyour code."
    },
    {
      "category": "Assignment",
      "title": "Problem Set No. 6",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/d4d13102ee3274fdf9e316d4f3f82c9e_MIT16_36s09_assn06.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nDepartment of Aeronautics and Astronautics\n16.36: Comm. Sys. Engineering\nProblem Set No. 6\nProblem 1: Text problem 7.9\nProblem 2: Text problem 7.10\nSolve for a probability of error of Pb = 10-5. The Q function table is located in table 4.1 in the textbook.\nProblem 3: Text problem 7.13\nHint: see example 7.5.3 in the textbook for solving the optimal MAP detector.\nProblem 4: Text problem 7.60\n\nProblem 5: Matlab Exercise\nIn this exercise, you will modify your PAM demodulator to be an optimum MAP detector for antipodal\nsignaling, test your demodulator in the presence of noise, and compare the results to the theoretical error\nprobability. We will consider a binary source with p(0) = p, and p(1) = 1-p.\nA) Two functions have been uploaded to Stellar for your use in this exercise (you can change them as\nyou like, or make your own)\na. rand_bitstring: Creates a random bit string of size n with bit distribution p(0) = p and\np(1) = 1-p, with p ∈ [0,1].\nb. error_check: Takes two bit strings and returns the number of bit errors and the error rate.\nB) Modify your PAM demodulator function to use the optimum MAP detector decision point for an\nantipodal signal.\na. The optimal MAP detector for arbitrary bit distributions p and 1-p is solved in example 7.5.3\nin the textbook.\nb. You will have to add additional inputs to your function to tell it the variance of the noise, σ2,\nand the symbol probabilities, p.\nC) After you modulate your bit string, you will need to add noise to it\na. Use the function randn to generate Gaussian noise with zero-mean and variance σ2 = 1. To\nchange the variance, multiply the output of randn by the desired standard deviation, σ.\nb. Create a noise vector with the same number of samples as your signal, which you can add to\nyour modulated signal.\nc. After you add noise to your modulated signal, you can demodulate it using your matched\nfilter demodulator.\nD) You can calculate the theoretical error probability using the Matlab function qfunc. Since you\nknow the amplitude A, symbol length T, and noise with variance σ2, you can easily calculate the\ntheoretical value.\nE) You will conduct two separate tests\na. Test 1: for a given distance between constellation points d, add noise with σ ranging from 0\nto 5, increasing in 0.2 increments. Plot your observed error rate, as well as the plot of the\ntheoretical error rate from the Q function. Run this simulation for d = 2. Plot the simulation\nand the theoretical error probability on a single plot and label each line. Use even bit\ndistribution, p = 0.5. Notice how the MAP detector becomes a ML detector for p = 0.5.\nb. Test 2: Run the simulation for different values of p. Same as before, add noise with σ ranging\nfrom 0 to 5, increasing in 0.2 increments. In addition, plot the theoretical error probability for\nonly p = 0.5, which is the same as in Test 1, and corresponds to the ML detector. Run this\nsimulation for p = .05, .25, .5, .75, and .95. Put all on a single plot, as well as the ML\ntheoretical error probability, and label the results. You can now see the improvement in\nperformance from the ML detector.\nF) Use the following inputs for your tests\na. Carrier frequency, fc, of 1 Hz.\nb. Sampling frequency, fs, of 4 Hz.\nc. Symbol rate, Rs, of 1.\nd. Bit string size of n = 5000. This is important to give a large enough sample size.\ne. M will now be held constant at 2.\nG) Please produce as output the two plots for Test 1 and Test 2. Make sure to comment all of your code\nand clearly label your plots."
    },
    {
      "category": "Assignment",
      "title": "Problem Set No. 7",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/fa32b24176e0b000b63f61e82261cbcd_MIT16_36s09_assn07.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nDepartment of Aeronautics and Astronautics\n16.36: Comm. Sys. Engineering\nProblem Set No. 7\nProblem 1: Text problem 9.1\nProblem 2: Text problem 9.8\nProblem 3: Text problem 9.27\nProblem 4:\n0 1\n1 0\n\nG = 0\n\n0 1\n\nThe generator matrix for a (6,3) code is given above.\nA) find the minimum distance for the code\nB) Find the parity check matrix for the code\nC) What codeword would you use to encode 111?\nD) Suppose you receive 111111, how would you decode it?\n\nProblem 5: Matlab Exercise\nIn this exercise, you will create a linear block code encoder and decoder function, test it for antipodal\nsignaling with your PAM modulator and demodulator, and compare the error performance to not\nencoding.\nA) You will create two separate functions: encode and decode\na. Implement the (5,2) code that was presented in the textbook in examples 9.5.1, 9.5.2, 9.5.3,\nand 9.5.7.\nb. The decoder should implement hard decision decoding using syndrome decoding, as\npresented class and shown in example 9.5.7.\nc. For each of your functions, the input and output should be a bit string. This will allow you to\nmore easily integrate your new functions with preexisting ones.\nd. You may find the following Matlab functions useful (for more information, look at the\nMatlab help files)\ni. bin2dec: will take a binary string and convert it to decimal: '0'0,'10'2\nii. dec2bin: will take a decimal value and create a bitstring. This function has also can\ntake as an input the minimum number of bits to output. dec2bin(1,2)='01'\niii. mod: modulo operator (% in C or java). All the arithmetic that is being preformed for\ncoding is modulo-2: 1+1=0. An example use of the function is mod(4,2)=0 and\nmod(3,2)=1. You can also apply the function to an entire array.\niv. xor: bit-wise xor, also denoted by ⊕, is a modulo-2 addition or subtraction operator,\nwith no carry. xor(1,1)=0 and xor(1,0)=1.\nB) If you construct the input and outputs of your encoder and decoder properly, you will not need to\nmake any changes to any of your existing functions.\nC) Run the same test as Test 1 from the last homework, but this time encode and decode the data\na. Add noise with σ ranging from 0.4 to 1.0, increasing in 0.1 increments. Plot your observed\nerror rate, as well as the plot of the theoretical bit error rate (using the same Q function,\nqfunc, as the last homework) of unencoded data. Run this simulation for d = 2. Plot the\nsimulated encoded error rate and the theoretical single-bit error rate on a single plot and label\neach line.\nb. You should be able to reuse almost all of your code from the previous homework.\nD) Use the following inputs for your tests\na. Carrier frequency, fc, of 1 Hz.\nb. Sampling frequency, fs, of 4 Hz.\nc. Symbol rate, Rs, of 1.\nd. Bit string size of n = 5000, pre-encoded.\ne. Antipodal signaling: M = 2.\nf. Use even bit distribution, p=0.5, for rand_bitstring.\nE) Please produce as output the plotted error rates. Make sure to comment all of your code and clearly\nlabel plots."
    },
    {
      "category": "Exam",
      "title": "Quiz – 1",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/e295dd0576c04e35d2f1e08d589f7de4_MIT16_36s09_quiz01.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nName:\n16.36 Communication Systems Engineering\nQuiz -1\nMarch 5, 2009\n\nPart 1: Quick Questions (50 points; 5 points each)\n\nPlease provide brief explanations for your answers in order to receive full credit.\n\n1. Time-shifting a signal changes its frequency composition.\na. True\nb. False\n\n2. A signal x(t) with bandwidth W, is sampled at a sampling rate 2W. Can the following\nbe used to reconstruct the original signal from its samples?\n\nx(t) =\nx(nTS)\nn=-inf\ninf\n∑\nk( t\nTS\n-n) where, k(t) = Sinc(t)\nt ∈[-1,1]\notherwise\n⎧\n⎨\n⎩\n\nExplain your answer.\n\n3. When conditioning on some event Y, the entropy of a random variable X will\na. Increase\nb. Decrease\nc. Remain unchanged\n\nPlease circle all possible answers and explain your choices briefly.\n\nName:\n4. When designing a uniform quantizer for a Gaussian source, the mid-point of the\nquantization regions are the optimal quantization levels to minimize distortion.\na. True\nb. False\n\n5. The entropy of a uniform quantizer is always equal to the logarithm of the number of\nquantization levels.\na. True\nb. False\n\n6. Which of the following lengths of codewords are feasible for prefix-free codes:\na. {2,2,3,3,3,3,4}\nb. {1,2,4,4,4,5}\nc. {2,2,2,3,4,4}\n\nCircle all that apply and briefly explain your choices.\n\nName:\n7. For which of the following source alphabet probabilities can one construct a Huffman\ncode with average codeword length that is equal to the source entropy\na. {1/4, 1/4, 1/8, 1/8, 1/8, 1/8}\nb. {1/2, 1/8, 3/8}\nc. {1/4, 1/4, 1/4, 1/4}\n\nCircle all that apply and briefly explain your choices.\n\n8. Given a band limited signal, x(t), with Bandwidth W, that is modulated by a carrier of\nfrequency fc (i.e., u(t) = x(t)cos(2πfct)). At what frequency must the signal, u(t), be\nsampled for perfect reconstruction?\na. 2fc\nb. 2fc+2W\nc. 2fc+W\nd. 2W\n\n9. A Gaussian source with zero mean and variance 10, is to be quantized using a\nuniform quantizer with 8 quantization levels. (See attached table).\na. What is the resulting distortion?\nb. What is the spacing between quantization levels?\nc. What is the resulting entropy?\n\nName:\n\n10. A source is encoded using the Lempel-Ziv algorithm with four bit code words. The\nencoded sequence is given by:\n\n0001 0000 0101 0110\n\nUsing the above information reconstruct the dictionary and find the original bit\nsequence.\n\nQuestion 2: Modulation (30 points)\n\nSuppose you want to construct a 16-PAM modulator, using the basic pulse, g(t) given\nbelow.\n\nFrequency planning regulations require that the two-sided null-to-null bandwidth of g(t)\ndoes not exceed 8 kHz.\ng(t) = A\nt ∈[0,T]\notherwise\n⎧\n⎨\n⎩\n\na) What is the maximum information rate RB that can be supported with 16-ary\nPAM (M=16)?\n\nName:\n\nb) The baseband signal, g(t) is modulated by a sinusoidal carrier at frequency 2.4\nMHz. Sketch an approximate frequency representation of the modulated signal.\nClearly label magnitude and frequencies.\n\nc) Consider next a symmetric 16-QAM modulator.\ni. Sketch the signal constellation plot, and label the points with their\namplitude levels.\nii. For each signal point give the associated signal energy level\n\nName:\nQuestion 3: Quantization (20 points)\n\nSuppose that the individual samples form independent, identically distributed random\nvariables are distributed between -1 and 1 according to the pdf fx(x) given below:\n\nfx(x) = | x |\n-1 ≤x ≤1\notherwise\n⎧\n⎨\n⎩\n⎫\n⎬\n⎭\n\nSuppose that you quantize this source using a three level quantizer (three quantization\nregions). Also assume that the quantization regions are chosen to be: [-1,-1/3], [-1/3,1/3],\nand [1/3, 1].\n\na) What would you choose as the quantized values for each of the regions in order to\nminimize average distortion?\n\nb) What is the resulting binary entropy of the quantized source?"
    },
    {
      "category": "Exam",
      "title": "Quiz – 2",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/6e4aa4779de629f084e8a077a27cfc3b_MIT16_36s09_quiz02.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nName:\n16.36 Communication Systems Engineering\nQuiz - 2\nApril 23, 2009\n\nPart 1: Quick Questions (30 points; 5 points each)\n\nPlease provide brief explanations for your answers in order to receive full credit.\n\n1. In a binary PAM modulation system, the length of time of a pulse is reduced from\n1 second to 0.25 seconds. How much should the amplitude be increased to maintain\nthe same probability of error?\n\n2. In a satellite communication system, there is an opportunity to use a new parabolic\nantenna with twice the diameter of the old antenna. What is the expected increase of\nthe data rate? Assume free space loss.\n\nName:\n\n3. What is the minimum distance (dmin) of the (7,3) code defined by the following\ngenerator matrix?\n\nG =\n⎡\n⎣\n⎢\n⎢\n⎢\n⎤\n⎦\n⎥\n⎥\n⎥\n\n4. What is generator matrix corresponding to the following CRC feedback shift register\nimplementation?\n\nName:\n\n5. Suppose a cyclic code with generator string 11101 is used to generate a CRC.\n\na. (5 pts) The data sequence is 101111, what should the CRC be?\n\nb. (5 pts) The received sequence is 10111011, did any errors occur?\n\nName:\nQuestion 2: 20 points\n\nConsider the following set of four waveforms:\n\na) (10 pts) What is the dimensionality of the set of waveforms?\n\nName:\nb) (10 pts) Determine a set of basis functions for the set of waveforms.\n\nName:\nQuestion 3: 30 points\n\nA binary communication system employs antipodal signals. The system operates over an\nAWGN channel with power spectral density N0/2 W/Hz. The received signal is given by:\n\nr(t) = ±s(t) + n(t)\n\nwhere s(t) is the transmit signal and n(t) is the noise signal. The sender uses signal s(t) to\nrepresent a 1 and -s(t) to represent a 0. The symbol duration is T.\n\na) (5 pts) What is the impulse response h(t) of the matched filter for s(t)? (sketch your\nanswer)\n\nb) (10 pts) What is the output of the matched filter to the input s(t)? (sketch your\nanswer)\n\nName:\nThe receiver uses this matched filter and samples the output at time T. Call the\nsampled value r. Under AWGN, the conditional distributions of r are Gaussian:\n\nf (r| 0 sent) ~ N (μ0, N0/2)\nf (r| 1 sent) ~ N (μ1, N0/2)\n\nWith μ0 = +√ES and μ1 = -√ES.\n\nThe prior probabilities of sending a 0 or 1 are P0 and P1 respectively.\n\nc) (10 pts) What is the MAP decoding rule for the received value r, when P0 = P1 = 0.5?\n\nd) (5 pts) What is the MAP decoding rule for the received value r, when P0 = 0.4 and P1\n= 0.6?\n\nName:\nQuestion 4: 20 points\n\nConsider the discrete memoryless symmetric ternary channel below with channel error ε\nand source alphabet {0,1,2}.\n\na) (10 pts) Find the capacity of the channel when ε = 0\n\nb) (10 pts) Find the capacity of the channel when ε = 1⁄3"
    },
    {
      "category": "Exam",
      "title": "Quiz – 3",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/d0787dc0709a622417f1e018238b68c2_MIT16_36s09_quiz03.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nName:\n\n16.36 Communication Systems Engineering\nQuiz - 3, May 20, 2009\n\nProblem 1: Short Answer (45 pts)\nPlease provide brief explanations for your answers in order to receive full credit.\n\n1. (5 pts) Suppose that the string 0110 is used as a flag.\n\na) What would the bit stuffing rule be?\n\nb) How would the following string be stuffed?\n\n2. (6 pts) For each of the following protocols indicate the minimum modulo that can be used for\nnumbering packets.\n\na) Stop and Wait\n\nb) Go-Back-N, with N=7\n\nc) Selective Repeat (SRP), with W=7\n\nName:\n\n3. Buses arrive at a bus stop at a rate of 6 per hour.\n\na) (4 pts) What is the expected amount of time between successive busses?\n\nb) (4 pts) You have just arrived at the bus stop. What is the expected amount of time\nbetween the last bus to arrive before you and the next bus?\n\n4. (4 pts) A popular ice cream shop has an average arrival rate of 100 customers per hour. The\nshop can hold up to 50 people in line at any point in time. Give an upper bound on the\naverage waiting time for a customer.\n\n5. (6 pts) True or False: 2 points each, no explanation needed\n\na) For a graph, a minimum spanning tree (MST) is unique. ________\n\nb) A shortest path only exists in acyclic graphs. ________\n\nc) A spanning tree exists for every graph. ________\n\nName:\n\n6. (6 pts) After graduation, you go to work for NASA, where you are helping design a new\ngeosynchronous satellite communication system. The satellite communicates to the ground\nterminals with round-trip propagation delay of 0.5 seconds, packet lengths of 1000 bits, and a\ntransmission rate of 1 Mbps. The engineers there suggest using CSMA/CD for the MAC\nbetween the satellite and ground terminals. Would CSMA/CD be a good choice? If not, what\nwould you recommend to use?\n\n7. (5 pts) Briefly describe the hidden terminal problem.\n\n8. (5 pts) An Aloha protocol uses immediate retransmission upon a collision. What would be\nthe throughput of the protocol?\n\nName:\n\nProblem 2: Data Link Layer (15 points)\n\na) (6 pts) For the diagram below, suppose you are using the Go-Back-N protocol (with N=4)\nand indicate, in the space provided, the sender's sequence numbers (SN) and the\nreceiver's request numbers (RN). The first RN and SN are 0 and 0 as indicated in the\ndiagram. Note that packets arriving in the middle of a transmission are not ACK'd until\nthe next transmission.\n\nX\nX\nSN\nRN\nX\n\nb) (9 pts) A GEO satellite link has a transmission rate of 1Mbps, a (round-trip) propagation\ndelay of 500ms, and a data/ACK packet size of 10000 bits.\n\ni. Suppose you use Stop & Wait and the channel is error-free. What is the efficiency of\nthe system?\n\nii. Suppose you use Go-Back-N. What is the minimum window size would you use to\nachieve 100% efficiency for an error-free channel?\n\niii. Suppose you use ideal Selective Repeat (SRP) with packet error rate p = 10-1. What\nis the efficiency of the system?\n\nName:\n\nProblem 3: Routing (20 points)\n\na) (10 pts) Use the Bellman-Ford Algorithm to find the shortest path from node 1 to all other\nnodes. Show all of your steps in the table below!\n\nH\nD2 (path)\nD3 (path)\nD4 (path)\nD5 (path)\nD6 (path)\n\nName:\n\nb) (10 pts) For the graph below find a minimum weight spanning (MST) tree using the Prim-\nDijkstra algorithm (starting with node 1). Show all of your steps!\n\nName:\n\nProblem 4: Queuing (20 points)\n\nYou may use the following formula for average queuing delay in an M/G/1 system:\n\nDqueue =\nλ X2\n2(1-ρ)\n\na) (10 pts) Packets arrive to a link at a rate of 1 per second and are all exactly 1000 bits long.\nThe transmission rate is 2000 bps. What is the average total delay in the system\n(queue+transmitter)?\n\nb) (10 pts) Packets arrive to a link at a rate of 1 per second. Two-thirds (2⁄3) of the packets are\n1000 bits long and one-third (1⁄3) are 2000 bits long. The transmission rate is 2000 bps. What\nis the average number of packets in the system?"
    },
    {
      "category": "Resource",
      "title": "ARQ Protocols: Go Back N and SRP",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/9b06e175ee2b383dc35490581a45267a_MIT16_36s09_lec18.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n16.36: Communication Systems Engineering\nARQ Protocols: Go Back N and SRP\nEytan Modiano\n\nGo Back N ARQ\n(Sliding Window)\n- Stop and Wait is inefficient when propagation delay is larger than the\npacket transmission time\n- Can only send one packet per round-trip time\n- Go Back N allows the transmission of new packets before earlier ones\nare acknowledged\n- Go back N uses a window mechanism where the sender can send\npackets that are within a \"window\" (range) of packets\n- The window advances as acknowledgements for earlier packets are received\nACK-0 ACK-1 ACK-2 ACK-3 ACK-4 ACK-5 ACK-6 ACK-7 ACK-8\nPKT-0 PKT-1 PKT-2 PKT-3\nPKT-9\nPKT-8\nPKT-7\nPKT-6\nPKT-5\nPKT-4\nWINDOW\nWINDOW\nWINDOW\nWINDOW\n\nFeatures of Go Back N\n- Window size = N\n- Sender cannot send packet i+N until it has received the ACK for packet i\n- Receiver operates just like in Stop and Wait\n- Receive packets in order\n- Receiver cannot accept packet out of sequence\n- Send RN = i + 1 => ACK for all packets up to and including i\n- Use of piggybacking\n- When traffic is bi-directional RN's are piggybacked on packets going in the\nother direction\n- Each packet contains a SN field indicating that packet's sequence number and a\nRN field acknowledging packets in the other direction\n<--Frame Header --------->\nSN\nRN\nPacket\nCRC\n\nGo Back N ARQ\n- The transmitter has a \"window\" of N packets that can be sent without\nacknowledgements\n- This window ranges from the last value of RN obtained from the\nreceiver (denoted SNmin) to SNmin+N-1\n- When the transmitter reaches the end of its window, or times out, it\ngoes back and retransmits packet SNmin\nLet SNmin be the smallest number packet not yet ACKed\nLet SNmax be the number of the next packet to be accepted from the higher\nlayer (I.e., the next new packet to be transmitted)\n\nGo Back N\nSender Rules\n- SNmin = 0; SNmax = 0\n- Repeat\n- If SNmax < SNmin + N (entire window not yet sent)\n- Send packet SNmax ;\n- SNmax = SNmax + 1;\n- If packet arrives from receiver with RN > SNmin\n- SNmin = RN;\n- If SNmin < SNmax (there are still some unacknowledged packets) and sender\ncannot send any new packets\n- Choose some packet between SNmin and SNmax and re-send it\n-\nThe last rule says that when you cannot send any new packets you\nshould re-send an old (not yet ACKed) packet\n- There may be two reasons for not being able to send a new packet\n- Nothing new from higher layer\n- Window expired (SNmax = SNmin + N )\n- No set rule on which packet to re-send\n- Least recently sent\n\nReceiver Rules\n- RN = 0;\n- Repeat\n- When a good packet arrives, if SN = RN\n- Accept packet\n- Increment RN = RN +1\n- At regular intervals send an ACK packet with RN\n- Most DLCs send an ACK whenever they receive a packet from the other\ndirection\n- Delayed ACK for piggybacking\n- Receiver reject all packets with SN not equal RN\n- However, those packets may still contain useful RN numbers\n\nExample of Go Back 7 ARQ\nt\nSN\nRN\nWindow\n(0,6)\n(1,7)\n(5,11)\n(2,8) (3,9)\nNode A\nNode B\nPackets\ndelivered\n-\nNote that packet RN-1 must be accepted at B before a frame\ncontaining request RN can start transmission at B\n\nRETRANSMISSION BECAUSE OF ERRORS FOR GO\nBACK 4 ARQ\nt\nRN\nSN\nx\nWindow\nNode A\nNode B\n(0,3)\n(1,4)\n(2,5)\nPackets\ndelivered\n- Note that the timeout value here is taken to be the time to send a full\nwindow of packets\n- Note that entire window has to be retransmitted after an error\n\nRETRANSMISSION DUE TO FEEDBACK ERRORS\nFOR GO BACK 4 ARQ\nt\nSN\nRN\nx\nx\n(4,7)\n(5,8)\nNode A\nNode B\nPackets\ndelivered\nWindow\n(0,3)\n(2,5)\n- When an error occurs in the reverse direction the ACK may still arrive in\ntime. This is the case here where the packet from B to A with RN=2\narrives in time to prevent retransmission of packet 0\n- Packet 2 is retransmitted because RN = 4 did not arrive in time,\nhowever it did arrive in time to prevent retransmission of packet 3\n- Was retransmission of packet 4 and 5 really necessary?\n- Strictly no because the window allows transmission of packets 6 and 7 before\nfurther retransmissions. However, this is implementation dependent\n\nEFFECT OF LONG FRAMES\nt\nSN\nRN\nWindow\nNode A\nPackets\ndelivered\n(0,3)\n(1,4)\n(3,6)\n(4,7)\nNode B\n- Long frames in feedback direction slow down the ACKs\n- This causes a transmitter with short frames to wait or go back\n- Notice again that the retransmission of packets 3 and 4 was not\nstrictly required because the sender could have sent new packets\nwithin the window\n- Again, this is implementation dependent\n\nEfficiency of Go Back N\nA\nB\n-\nWe want to choose N large enough to allow continuous transmission\nwhile waiting for an ACK for the first packet of the window,\nN > S/ DTP\n-\nWithout errors the efficiency of Go Back N is,\nE = min{1, N*DTP/S}\npacket\nACK\nS\nDTP\nDP\nDTA\nDP\nS = DTP + 2DP + DTA\npacket\npacket\npacket\nN*DTP\n\nEfficiency of Go Back N with transmission errors\nApproximate analysis\nAssume: N =\n⎡\n⎢\n⎢\nS\nDTP\n⎤\n⎥\n⎥\nTO = N*DTP\n- When an error occurs the entire window of N packets must be\nretransmitted\nLet X = the number of packets sent per successful transmission\nE[X] = 1*(1-P) + (X+N)*P\n= 1 + N*P/(1-P)\nEfficiency = 1/E[X]\n\nGo Back N Requirements\n- Go Back N is guaranteed to work correctly, independent of the detailed\nchoice of which packets to repeat, if\n1) System is correctly initialized\n2) No failures in detecting errors\n3) Packets travel in FCFS order\n4) Positive probability of correct reception\n5) Transmitter occasionally resends Snmin (e.g., upon timeout)\n6) Receiver occasionally sends RN\n\nNotes on Go Back N\n- Requires no buffering of packets at the receiver\n- Sender must buffer up to N packets while waiting for their ACK\n- Sender must re-send entire window in the event of an error\n- Packets can be numbered modulo M where M > N\n- Because at most N packets can be sent simultaneously\n- Receiver can only accept packets in order\n- Receiver must deliver packets in order to higher layer\n- Cannot accept packet i+1 before packet i\n- This removes the need for buffering\n- This introduces the need to re-send the entire window upon error\n- The major problem with Go Back N is this need to re-send the entire\nwindow when an error occurs. This is due to the fact that the receiver\ncan only accept packets in order\n\nSelective Repeat Protocol (SRP)\n- Selective Repeat attempts to retransmit only those packets that are\nactually lost (due to errors)\n- Receiver must be able to accept packets out of order\n- Since receiver must release packets to higher layer in order, the receiver must\nbe able to buffer some packets\n- Retransmission requests\n- Implicit\n- The receiver acknowledges every good packet, packets that are not ACKed before a\ntime-out are assumed lost or in error\n- Notice that this approach must be used to be sure that every packet is eventually\nreceived\n- Explicit\n- An explicit NAK (selective reject) can request retransmission of just one packet\n- This approach can expedite the retransmission but is not strictly needed\n- One or both approaches are used in practice\n\nSRP Rules\n- Window protocol just like GO Back N\n- Window size W\n- Packets are numbered Mod M where M >= 2W\n- Sender can transmit new packets as long as their number is with W of\nall un-ACKed packets\n- Sender retransmit un-ACKed packets after a timeout\n- Or upon a NAK if NAK is employed\n- Receiver ACKs all correct packets\n- Receiver stores correct packets until they can be delivered in order to\nthe higher layer\n\nNeed for buffering\n- Sender must buffer all packets until they are ACKed\n- Up to W un-ACKed packet are possible\n- Receiver must buffer packets until they can be delivered in order\n- I.e., until all lower numbered packets have been received\n- Needed for orderly delivery of packets to the higher layer\n- Up to W packets may have to be buffered (in the event that the first packet\nof a window is lost)\n- Implication of buffer size = W\n- Number of un-ACKed packets at sender =< W\n- Buffer limit at sender\n- Number of un-ACKed packets at sender cannot differ by more than W\n- Buffer limit at the receiver (need to deliver packets in order)\n- Packets must be numbered modulo M >= 2W (using log2(M) bits)\n\nEFFICIENCY\n- For ideal SRP, only packets containing errors will be retransmitted\n- Ideal is not realistic because sometimes packets may have to be\nretransmitted because their window expired. However, if the window size is\nset to be much larger than the timeout value then this is unlikely\n- With ideal SRP, efficiency = 1 - P\n- P = probability of a packet error\n- Notice the difference with Go Back N where\nefficiency (Go Back N) = 1/(1 + N*P/(1-P))\n- When the window size is small performance is about the same,\nhowever with a large window SRP is much better\n- As transmission rates increase we need larger windows and hence the\nincreased use of SRP\n\nWhy are packets numbered Modulo 2W?\n-\nLets consider the range of packets that may follow packet i at the\nreceiver\ni - W +1\ni\ni - W +1\nx\ni\ni - W +1\nPacket i may be followed by the first packet of the window (i -W+1) if it\nrequires retransmission\ni\ni+1\ni+2\ni+W\ni\ni - W\nPacket i may be followed by the last packet of the window (i+W) if all\nOf the ACKs between i and i +W are lost\n-\nReceiver must differentiate between packets i -W+1 ... i +W\n- These 2W packets can be differentiated using Mod 2W numbering\nx x x x\n\nSTANDARD DLC's\n-\nHDLC, LAPB (X.25), and SDLC are almost the same\n- HDLC/ SDLC developed by IBM for IBM SNA networks\n- LAPB developed for X.25 networks\n- They all use bit oriented framing with flag = 01111110\n- They all use a 16-bit CRC for error detection\n- They all use Go Back N ARQ with N = 7 or 127 (optional)\nSDLC packet\nflag\naddress\ncontrol\ndata\nCRC\nflag\nMultipoint\nSN,RN\ncommunication\n- Older protocols (used for modems, e.g., xmodem) used stop and wait\nand simple checksums"
    },
    {
      "category": "Resource",
      "title": "ARQ Protocols: Stop & Wait",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/fdb1cbbdfcc90b5c0767cef353994c8e_MIT16_36s09_lec17.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n16.36: Communication Systems Engineering\nARQ Protocols: Stop & Wait\nEytan Modiano\nSlide 1\n\nAutomatic Repeat ReQuest (ARQ)\n- When the receiver detects errors in a packet, how does it let the\ntransmitter know to re-send the corresponding packet?\n- Systems which automatically request the retransmission of\nmissing packets or packets with errors are called ARQ systems.\n- Three common schemes\n- Stop & Wait\n- Go Back N\n- Selective Repeat\n- Byzantine Army Problem\n- Byzantine failure: the failure to correctly execute a step in an\nalgorithm\nEytan Modiano\nSlide 2\n\nPure Stop and Wait Protocol\nACK\nTime\n----->\nNAK\npacket 0 CRC\npacket 1 CRC\npacket 1 CRC\narrival times at receiver\nTransmitter departure times at A\nPacket 0\nPacket 1\nAccepted\nAccepted\n-\nProblem: Lost Packets\n-\nSender will wait forever for an acknowledgement\n-\nPacket may be lost due to framing errors\n-\nSolution: Use time-out (TO)\n-\nSender retransmits the packet after a timeout\nEytan Modiano\nSlide 3\n\nThe Use Of Timeouts For Lost Packets Requires\nSequence Numbers\n<---- timeout ----->\npacket 0 CRC\npacket 0 CRC\npacket 0\naccepted\npacket 0 or 1?\n- Problem: Unless packets are numbered the receiver cannot tell\nwhich packet it received\n- Solution: Use packet numbers (sequence numbers)\nEytan Modiano\nSlide 4\n\nRequest Numbers Are Required On ACKs To\nDistinguish Packet ACKed\nACK\nACK\npacket 0 timeout 0 packet 0 1\npacket 1\n?\nPacket 0\naccepted\n- REQUEST NUMBERS:\n- Instead of sending \"ack\" or \"nak\", the receiver sends the number of the\npacket currently awaited.\n- Sequence numbers and request numbers can be sent modulo 2.\nThis works correctly assuming that\n1) Frames travel in order (FCFS) on links\n2) The CRC never fails to detect errors\n3) The system is correctly initialized.\nEytan Modiano\nSlide 5\n\nThe stop and wait protocol\n- Original ARQ protocol\n- Sender transmits one packet at a time and waits for an ACK\n- Receiver ACK's packets\n- Sender retransmits packet after a timeout\nPKT-0\nX\nACK-0\nACK-1\nPKT-1\nPKT-2\nPKT-2\nACK-2\nTO\n- Packet numbering\n- Sender numbers packets with sequence numbers (SN)\n- Receiver uses request numbers (RN) to ACK packets\nRN = j is the same as an ACK for packet j-1\n- Note:\n- Transmitter idle while waiting for ACK\n- Efficiency limited by round trip delay time\n- Requires no storage of packets\nEytan Modiano\nSlide 6\n\nStop and Wait Protocol\nAlgorithm at sender (node A)\n(with initial condition SN=0)\n1)\nAccept packet from higher layer when available;\nassign number SN to it\n2)\nTransmit packet SN\n3)\nWait for an error free packet from B\ni. if received and it contains RN>SN in the\nrequest # field, set SN to RN and go to 1\nii. if not received within given time (TO), go to 2\nEytan Modiano\nSlide 7\n\nStop and Wait\nAlgorithm at receiver (node B)\n(with initial condition RN=0)\n1) Whenever an error-free frame is received from A with a sequence\n# equal to RN, release received packet to higher layer and\nincrement RN.\n2) At arbitrary times, but within bounded delay after receiving any\nerror free frame from A, transmit a frame to A containing RN in the\nrequest # field.\nEytan Modiano\nSlide 8\n\nCorrectness of Stop and Wait\n- SAFETY: show that no packet is ever released out of order or more\nthan once\n- This is immediately obvious from the algorithm. We start with packet\n'0' and receiver does not increment its RN until '0' is received; upon\nwhich it can only accept packet '1', etc.\n- LIVENESS: show that every packet is eventually released\n- The sender keeps sending a packet until it gets an ack, so eventually\nevery packet is correctly received\n- Packet numbering: packets are numbered modulo 2 (0 or 1)\n- Start with packet 0, then 1, then 0, then 1, etc...\n- This works because at any time, the received packet can only be either\nthe packet that the receiver is waiting for (I.e., SN = RN) or the previous\npacket which has already been received (I.e., SN = RN-1). Mod 2\nnumbering can be used to distinguish between these packets.\nEytan Modiano\nSlide 9\n\nEfficiency of stop and wait\nLet S = total time between the transmission of a packet and reception\nof its ACK\nDTP = transmission time of the packet\nDTA = ACK trans. Time\nE = DTP/(DTP + 2DP + DTA )\nDTP = packet trans. time\nEytan Modiano\nSlide 10\nEfficiency (no errors) = DTP/S\nB\nDP = prop delay\nA\npacket\nACK\nS\nDTP\nDP\nDTA\nDP\nS = DTP + 2DP + DTA\n\nStop and wait in the presence of errors\nLet P = the probability of an error in the transmission of a packet or in\nits acknowledgment\nS = DTP + 2DP + DTA\nTO = the timeout interval\nX = the amount of time that it takes to transmit a packet and receive its\nACK. This time accounts for retransmissions due to errors\nE[X] = S + TO*P/(1-P),\nEfficiency = DTP/E[X]\nWhere,\nTO = DTP in a full duplex system\nTO = S in a half duplex system\nEytan Modiano\nSlide 11"
    },
    {
      "category": "Resource",
      "title": "Packet multiple access: The Aloha Protocol",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/bd06e398d455db074059d50f6abc953e_MIT16_36s09_lec21_22.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nPacket multiple access:\nThe Aloha Protocol\nEytan Modiano\nMassachusetts Institute of Technology\nDepartment of Aeronautics and Astronautics\nEytan Modiano\nSlide 1\n\nEytan Modiano\nSlide 2\nPacket Multiple Access\nTERMINAL\nTERMINAL\nTERMINAL\nTERMINAL\nTERMINAL\nPMA\nSHARED\nUPLINK\nPHYS\nDLC\nNET\nTRANS\nAPPL\n-\nMedium Access Control (MAC)\n-\nRegulates access to channel\n-\nLogical Link Control (LLC)\nLLC\nMAC\n-\nAll other DLC functions\n\nExamples of Multiple Access Channels\n- Local area networks (LANs)\n- Satellite channels\n- Wireless radio\n- Characteristics of Multiple Access Channel\n- Shared Transmission Medium\nA receiver can hear multiple transmitters\nA transmitter can be heard by multiple receivers\n-\nThe major problem with multiple access is allocating the channel\nbetween the users\nNodes do not know when other nodes have data to send\nNeed to coordinate transmissions\nEytan Modiano\nSlide 3\n\nApproaches to Multiple Access\n- Fixed Assignment (TDMA, FDMA, CDMA)\n-\nEach node is allocated a fixed fraction of bandwidth\n-\nEquivalent to circuit switching\n-\nvery inefficient for low duty factor traffic\n- Packet multiple access\n-\nPolling\n-\nReservations and Scheduling\n-\nRandom Access\nEytan Modiano\nSlide 4\n\nAloha\nSingle receiver, many transmitters\nReceiver\nTransmitters\n...\n.\nE.g., Satellite system, wireless\nEytan Modiano\nSlide 5\n\nSlotted Aloha\n- Time is divided into \"slots\" of one packet duration\n- E.g., fixed size packets\n- When a node has a packet to send, it waits until the start of the\nnext slot to send it\n- Requires synchronization\n- If no other nodes attempt transmission during that slot, the\ntransmission is successful\n- Otherwise \"collision\"\n- Collided packet are retransmitted after a random delay\nS\nl\no\nt\nt\ned aloh\na di\nagram, di\nvide\nd into five time slots. Some are successful, some are idle, and one shows a collision.\nEytan Modiano\nSlide 6\nFigure by MIT OpenCourseWare.\n\nSlotted Aloha Assumptions\n- Poisson external arrivals\n- No capture\n- Packets involved in a collision are lost\n- Capture models are also possible\n- Immediate feedback\n- Idle (0) , Success (1), Collision (e)\n- If a new packet arrives during a slot, transmit in next slot\n- If a transmission has a collision, it becomes backlogged and\nretransmitted after a random delay\n- Let n be the number of backlogged nodes\nEytan Modiano\nSlide 7\n\nslotted aloha\n- Let g be the attempt rate (the expected number of packets\ntransmitted in a slot)\n-\nThe number of attempted packets per slot is approximately a Poisson\nrandom variable of mean g = λ + n*qr\nqr = probability that a backlogged packet is retransmitted in a slot\nn = number of backlogged packets\n-\nP (m attempts) = gme-g/m!\n-\nP (idle) = probability of no attempts in a slot = e-g\n-\np (success) = probability of one attempt in a slot = ge-g\n-\nP (collision) = P (two or more attempts) = 1 - P(idle) - P(success)\nEytan Modiano\nSlide 8\n\nThroughput of Slotted Aloha\n- The throughput is the fraction of slots that contain a successful\ntransmission = P(success) =\narrival rate (λ)\nd\ndg(n)\nge! g = e!g ! ge!g = 0\n\" g =1\n\" P(success) =ge! g = 1/e# 0.36\n- What value of g\nmaximizes throughput?\n-\ng < 1 => too many idle slots\n-\ng > 1 => too many collisions\n- If g can be kept close to 1, an external arrival rate of 1/e packets per\nEytan Modiano\nSlide 9\nslot can be sustained\nGra\nph o\nf\nthroughput vs\n. attempt rate for slotted aloha, with a maximum at g = 1.\nFigure by MIT OpenCourseWare.\n\nInstability of slotted aloha\n- if backlog increases beyond unstable point (bad luck) then it tends\nto increase without limit and the departure rate drops to 0\n-\nAloha is inherently unstable and needs algorithm to keep it stable\n- Drift in state n, D(n) is the expected change in backlog over one\ntime slot\n- D(n) = λ - P(success) = λ - g(n)e-g(n)\nEytan Modiano\nSlide 10\nSlotte\nd aloha graph\nshowing\nregio\nns of ne\ngativ\ne and positive\ndrift.\nFigure by MIT OpenCourseWare.\n\nTDM vs. slotted aloha\n0 0.2 0.4 0.6 0.8\nARRIVAL RATE\nDELAY\nALOHA\nTDM, m=8\nTDM, m=16\n- Aloha achieves lower delays when arrival rates are low\n- TDM results in very large delays with large number of users, while\nAloha is independent of the number of users\nEytan Modiano\nSlide 11\n\nPure (unslotted) Aloha\n- New arrivals are transmitted immediately (no slots)\n- No need for synchronization\n- No need for fixed length packets\n- A backlogged packet is retried after an exponentially distributed\nrandom delay with some mean 1/x\n- The total arrival process is a time varying Poisson process of rate\ng(n) = λ + nx (n = backlog, 1/x = ave. time between retransmissions)\n- Note that an attempt suffers a collision if the previous attempt is not\nyet finished (ti-ti-1<1) or the next attempt starts too soon (ti+1 -ti<1)\nt\nt\nt\nt 4\nt 5\nRetransmission\nNew Arrivals\n!\n!\nCollision\nEytan Modiano\nSlide 12\n\nThroughput of Unslotted Aloha\n- An attempt is successful if the inter-attempt intervals on both\nsides exceed 1 (for unit duration packets)\n- P(success) = e-g x e-g = e-2g\n- Throughput (success rate) = ge-2g\n- Max throughput at g = 1/2, Throughput = 1/2e ~ 0.18\n- Stabilization issues are similar to slotted aloha\n- Advantages of unslotted aloha are simplicity and possibility of\nunequal length packets\nEytan Modiano\nSlide 13\n\nPacket Multiple Access:\nCSMA/CD and the Ethernet\nEytan Modiano\nMassachusetts Institute of Technology\nDepartment of Aeronautics and Astronautics\nEytan Modiano\nSlide 14\n\nCSMA/CD and Ethernet\nTwo way cable\nWS\nWS\nWS\nWS\nWS\nWS\n- CSMA with Collision Detection (CD) capability\n-\nNodes able to detect collisions\n- Upon detection of a collision nodes stop transmission\nReduce the amount of time wasted on collisions\n- Protocol:\n-\nAll nodes listen to transmissions on the channel\n- When a node has a packet to send:\nChannel idle ⇒ Transmit\nChannel busy ⇒ wait a random delay (binary exponential back-off)\n- If a transmitting node detects a collision it stops transmission\nWaits a random delay and tries again\nEytan Modiano\nSlide 15\n\nTime to detect collisions\nWS\nWS\nτ = prop\nτ\ndelay\n-\nA collision can occur while the signal propagates between the two nodes\n- It would take an additional propagation delay for both users to detect the\ncollision and stop transmitting\n- If τ is the maximum propagation delay on the cable then if a collision\noccurs, it can take up to 2τ seconds for all nodes involved in the collision\nto detect and stop transmission\nEytan Modiano\nSlide 16\n\nApproximate model for CSMA/CD\n- Simplified approximation for added insight\n- Consider a slotted system with \"mini-slots\" of duration 2τ\n2τ <-\n->\n<----------- 1 ---------------->\npacket\nMini-slots\n- If a node starts transmission at the beginning of a mini-slot, by the end\nof the mini-slot either\n- No collision occurred and the rest of the transmission will be\nuninterrupted\n- A collision occurred, but by the end of the mini-slot the channel would be\nidle again\n- Hence a collision at most affects one mini-slot\nEytan Modiano\nSlide 17\n\nAnalysis of CSMA/CD\n- Assume N users and that each attempts transmission during a\nfree \"mini-slot\" with probability p\n- P includes new arrivals and retransmissions\nP(i users attempt) = N\ni\n!\n\"\n# #\n$\n%\n& & P\ni(1' P )\nN'i\nP(exactly 1 attempt) = P(success) = NP(1-P )\nN-1\nTo maximize P(success),\nd\ndp [NP(1- P )\nN-1] = N(1-P )\nN-1 'N(N'1)P(1' P )\nN'2 = 0\n\n( Popt = 1\nN\n( Average attempt rate of one per slot\n( Notice the similarity to slotted Aloha\nEytan Modiano\nSlide 18\n\nAnalysis of CSMA/CD, continued\nP(success)=NP(1- p)\nN-1 = (1! 1\nN)\nN!1\nPs = limit (N\" #) P(success) = 1\ne\nLet X = Average number of slots per succesful transmission\nP(X= i) = (1- Ps)\ni !1Ps\n\n$ E[X]= 1\nPs\n= e\n- Once a mini-slot has been successfully captured, transmission continues\nwithout interruption\n- New transmission attempts will begin at the next mini-slot after the end of\nthe current packet transmission\nEytan Modiano\nSlide 19\n\nAnalysis of CSMA/CD, continued\n- Let S = Average amount of time between successful packet\ntransmissions\nS = (e-1)2τ + DTp + τ\nAve time until start\nof next Mini-slot\nIdle/collision\nPacket transmission time\nMini-slots\n- Efficiency = DTp/S = DTp / (DTp + τ + 2τ(e-1))\n- Let β = τ/ DTp => Efficiency ≈ 1/(1+4.4β) = λ < 1/(1+4.4β)\nEytan Modiano\nSlide 20\n\nNotes on CSMA/CD\n- Can be viewed as a reservation system where the mini-slots are\nused for making reservations for data slots\n- In this case, Aloha is used for making reservations during the\nmini-slots\n- Once a users captures a mini-slot it continues to transmit without\ninterruptions\n- In practice, of course, there are no mini-slots\n-\nMinimal impact on performance but analysis is more complex\nEytan Modiano\nSlide 21\n\nCSMA/CD examples\n-\nExample (Ethernet)\n-\nTransmission rate = 10 Mbps\n-\nPacket length = 1000 bits, DTp = 10-4 sec\n-\nCable distance = 1 mile, τ = 5x10-6 sec\n-\n➨ β = 5x10-2 and E = 80%\n-\nExample (GEO Satellite) - propagation delay 1/4 second\n-\nβ = 2,500 and E ~ 0%\n-\nCSMA/CD only suitable for short propagation scenarios!\n-\nHow is Ethernet extended to 100 Mbps?\n-\nHow is Ethernet extended to 1 Gbps?\nEytan Modiano\nSlide 22\n\nMigration to switched LANs\n-\nTraditional Ethernet\n-\nNodes connected with coax\nLong \"runs\" of wire everywhere\n-\nCSMA/CD protocol\nWS\nWS\nWS\nWS\nWS\nWS\n-\n\"Hub\" Ethernet\n-\nNodes connected to hub\nHub acts as a broadcast repeater\nShorted cable \"runs\", Useful for 100 Mbps\n-\nCSMA/CD protocol\n-\nEasy to add/remove users\n-\nEasy to localize faults\n-\nCheap cabling (twisted pair, 10baseT)\n-\nSwitched Ethernet\n-\nNo CSMA/CD\nEasy to increase data rate (e.g., Gbit Ethernet)\n-\nNodes transmit when they want\n-\nSwitch queues the packets and transmits to destination\n-\nTypical switch capacity of 20-40 ports\n-\nEach node can now transmit at the full rate of\n10/100/Gbps\n-\nModularity: Switches can be connected to each other\nusing high rate ports\nWS\nWS\nWS\nWS\nWS\nWS\nWS\nWS\nWS\nWS\nWS\nWS\nPacket\nSwitch\nConnect\nTo other\nSwitchs\nEytan Modiano\nSlide 23\n\nLarge propagation delay\n(satellite networks)\n1 2 3 4 5\nA = mv\nReservation\nInterval\nData\nInterval\nReservation\nInterval\nFrame\nRes\nData\nRes\nData\nData\nRes\nRes\nArrival\nWait for Reser-\nvation Interval\nPropagation Delay\nWait for Assigned\nData Slot\nTransmit\n-\nSatellite reservation system\n-\nUse mini-slots to make reservation for longer data slots\n-\nMini-slot access can be inefficient (Aloha, TDMA, etc.)\n- To a crude approximation, delay is 3/2 times the propagation delay plus\nideal queueing delay.\nEytan Modiano\nSlide 24\n\nSatellite Reservations\n- Frame length must exceed round-trip delay\n-\nReservation slots during frame j are used to reserve data slots in frame j+1\n-\nVariable length: serve all requests from frame j in frame j+1\nDifficult to maintain synchronization\nDifficult to provide QoS (e.g., support voice traffic)\n-\nFixed length: Maintain a virtual queue of requests\n- Reservation mechanism\n-\nScheduler on board satellite\n-\nScheduler on ground\n-\nDistributed queue algorithm\nAll nodes keep track of reservation requests and use the same algorithm to make\nreservation\n- Control channel access\n-\nTDMA: Simple but difficult to add more users\n-\nAloha: Can support large number of users but collision resolution can be\ndifficult and add enormous delay\nEytan Modiano\nSlide 25\n\nPacket multiple access summary\n- Latency: Ratio of propagation delay to packet transmission time\n-\nGEO example: Dp = 0.5 sec, packet length = 1000 bits, R = 1Mbps\nLatency = 500 => very high\n-\nLEO example: Dp = 0.1 sec\nLatency = 100 => still very high\n-\nOver satellite channels data rate must be very low to be in a low latency\nenvironment\n- Low latency protocols\n-\nCSMA, Polling, Token Rings, etc.\n-\nThroughput ~ 1/(1+aα), α = latency, a = constant\n- High latency protocols\n-\nAloha is insensitive to latency, but generally low throughput\nVery little delays\n-\nReservation system can achieve high throughput\nDelays for making reservations\n-\nProtocols can be designed to be a hybrid of Aloha and reservations\nAloha at low loads, reservations at high loads\nEytan Modiano\nSlide 26\n\nPacket Multiple Access:\nWireless LANs\nEytan Modiano\nMassachusetts Institute of Technology\nDepartment of Aeronautics and Astronautics\nEytan Modiano\nSlide 27\n\nWireless Networking Technologies\nSHORT < RANGE > LONG\n\n802.16 (wimax)\n802.11b\n802.11a/g/n\nZigBee Bluetooth\nWiMedia\nWireless Metropolitan\nArea Network\nWireless Local\nArea Network\nWireless Personal\nArea Network\nLOW\n<\nDATA RATE >\nHIGH\n- Standards typically define the\nMedium Access Control (MAC)\nand the Physical layers\nEytan Modiano\nSlide 28\nBluetooth\nWiFi\nWiMax\n(802.11)\n(802.16)\nData rate\n2.1 Mbps\n54 Mbps\n70 Mbps\nLink length\n10 meters\nmeters\n10 km\napplication\nPeripheral\ndevices\nLAN\nAccess\nMost slides on wireless MAC borrowed with permission from Prof. Gil Zussman of Columbia University\n\nMedium Access Control (MAC)\n- Nodes are scattered in a geographic area\n- Need to somehow coordinate the access to channel\n-\nTransmission time, power, rate, etc.\n- Centralized\n-\nManaged by an Access Point/Base Station\n- Distributed\n-\nRandom access (Aloha, CSMA, Ethernet)\n-\nScheduled access\n- Requirements\n-\nThroughput, delay, fairness, energy efficiency\nEytan Modiano\nSlide 29\n\nIEEE 802.11 / WiFi\n- Set of standards for Wireless Local Area Networks (WLANs)\n- Define Medium Access Control (MAC)\n- Physical layer\n- Most common 802.11g\n- Maximum data rate: 54Mb/s\n- Frequency band: 2.4 Ghz\n- Other variations 802.11a,b,e,n\n- Different bands, physical layers, data rates, QoS, etc.\nEytan Modiano\nSlide 30\n\nAd Hoc and Infrastructure Modes\n- Ad Hoc mode\n- The stations communicate with one\nanother\n- Not connected to a larger network\n- Infrastructure mode\n- An Access Point connects\nStations to a wired network\n- Overlapping Access Points\nconnected to each other\n- Allows Stations to roam\nbetween Access Points\nEytan Modiano\nSlide 31 Top: diagram of ad hoc mode, with arrows between laptops. Bottom: diagram of infrastructure mode, with arrows between laptops and an access point.\nFigure by MIT OpenCourseWare.\n\nMedium Access Control - CSMA\\CA\nCarrier Sense Multiple Access \\ Collision Avoidance\n- Station wishing to transmit a Data packet senses the medium\n- If it is idle for a given period - Transmits\n- ACK packet is sent by the receiving station\nCSMA\n\n- Collision assumed if sending station doesn't get ACK\n-\nData is retransmitted after a random time\nData\nA\nB\nStation A\nStation B\nAck\nEytan Modiano\nSlide 32\n\nMedium Access Control - CSMA\\CA\nCarrier Sense Multiple Access \\ Collision Avoidance\nData\nA\nB\nStation A\nStation B\nAck\nC\nStation C\nDon't Transmit !\nCA\n- A station that heard the Data or the ACK, knows the time remaining until\nthe medium will become available\n-\nWill not try to transmit during that time\n- Carrier Sensing\n-\nPhysical\nEytan Modiano\n-\nVirtual: using RTS/CTS procedure and NAV values within\nSlide 33\n\nHidden Node Problem\n- Hidden Node - A node that a station does not hear but can\nCA\n\ninterfere with its transmissions\n- Solution: Busy tone multiple access (\nB\nA\n, 1975)\nTobagi\nC\n- Enhancement:\n- A → B Request to Send (RTS)\n- B → A Clear to Send (CTS)\n- A → B Data\n- B → A ACK\n- Neighboring nodes will keep quiet for the duration of the transfer\n- Network allocation vector (NAV) - specifies duration of transfer\nStation A\nStation B\nEytan Modiano\nSlide 34\nStation C\nRTS\nCTS\nDon't Transmit !\nData\nAck\n\n- A station that sensed the medium busy or did not receive an ACK\nContention Window\nwill try to retransmit\nStation A\nStation B\nStation C\nDon't Transmit !\nData\nAck\nContention Window (CW)\n- The back-off interval is uniformly distributed within the CW\n- The window is doubled every time there is a need to retransmit\n- Upper limit on CW\n- Count down back-off interval when channel idle\n- Stop counting when busy (resume when idle again)\n- Transmit when back-off interval reaches 0\nB=10\n9 8 7 6 5\nChannel busy\n4 3 2 1 0\nData\nACK\nEytan Modiano\nSlide 35\nChannel\nChannel\nidle\nidle\n\nBluetooth\n-\nVery short-range communications between computers and peripheral devices\n-\nE.g., replace connector cables such as usb\n-\nOperates in 2.4 GHz unlicensed band\n-\nUses spread-spectrum communications\nFrequency hopping between 79 frequency channels\nNew frequency every slot (625 μs)\n-\nPiconet: master and 7 slave devices\n-\nAll communication goes through the master\n-\nZigBee - a competing technology (will not discuss much)\n-\nNewer technology for low bandwidth, low power applications\n-\nVery simple and inexpensive\n-\nDesigned for sensor networks; and communications between very inexpensive devices (e.g.,\nappliances)\nEytan Modiano\nSlide 36\n\nEytan Modiano\nSlide 37\nBluetooth MAC\n- Frequency Hop / Time Division Duplex Scheme\n- Frequency band: 2.4 GHz ISM Band\n-\n1,600 slots per second (625 μs/slot)\n- Piconet - A Master and up to 7 Slaves\nsharing a common hopping pattern\n- Intra-Piconet Communication (TDD):\nMaster\nSlave 1\nSlave 2\nSlave n\n\nBluetooth MAC\nMaster\nSlave 1\nSlave 2\nSlave n\n- 1, 3, and 5-slot data frames\n- If the master has no data to transmit, it can\naddress a slave by sending a 1-slot POLL packet\n- If a slave has nothing to send, it must respond by\nsending a 1-slot NULL packet\nEytan Modiano\nSlide 38\n\nMulti-hop Topology\n- Several piconets may coexist in the same coverage area with\nminimal interference\n- A unit can be:\n- Piconet Coordinator / Device / Bridge\n- There are links and neighbors\nEytan Modiano\nSlide 39\n\nWiMAX (802.16)\n- Access technology - metro area\n-\nLast (few) miles to home or business\n- Data rates of up to 70 Mbps\n- Physical layer\n-\nMicrowave band: 10 to 66 GHz (line of sight)\n-\nOther bands also possible\n- Connection oriented to offer QoS guarantees\n- Medium access\n-\nFixed assignment (guaranteed rate)\n-\nReservations (polling)\n-\nContention mechanism for best effort services\nEytan Modiano\nSlide 40"
    },
    {
      "category": "Resource",
      "title": "Routing in Data Networks",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/a2da68b5fdfa1de645435947dbf5daef_MIT16_36s09_lec23_24.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nRouting in Data Networks\nEytan Modiano\nEytan Modiano\nSlide 1\n\nPacket Switched Networks\nPacket Network\nPS\nPS\nPS\nPS\nPS\nPS\nPS\nBuffer\nPacket\nSwitch\nMessages broken into\nPackets that are routed\nTo their destination\nEytan Modiano\nSlide 2\n\nRouting\n- Must choose routes for various origin destination pairs (O/D pairs)\nor for various sessions\n- Datagram routing: route chosen on a packet by packet basis\nUsing datagram routing is an easy way to split paths\n- Virtual circuit routing: route chosen a session by session basis\n- Static routing: route chosen in a prearranged way based on O/D pairs\nEytan Modiano\nSlide 3\n\nBroadcast Routing\n- Route a packet from a source to all nodes in the network\n- Possible solutions:\n- Flooding: Each node sends packet on all outgoing links\nDiscard packets received a second time\n- Spanning Tree Routing: Send packet along a tree that includes all of\nthe nodes in the network\nEytan Modiano\nSlide 4\n\nGraphs\n- A graph G = (N,A) is a finite nonempty set of nodes and a set of\nnode pairs A called arcs (or links or edges)\nN = {1,2,3}\nA = {(1,2)}\nN = {1,2,3,4}\nA = {(1,2),(2,3),(1,4),(2,4)}\nEytan Modiano\nSlide 5\n\nWalks and paths\n- A walk is a sequence of nodes (n1, n2, ...,nk) in which each adjacent node\npair is an arc\n- A path is a walk with no repeated nodes\nWalk (1,2,3,4,2)\nPath (1,2,3,4)\nEytan Modiano\nSlide 6\n\nCycles\n- A cycle is a walk (n1, n2,...,nk) with n1 = nk, k > 3, and with no\nrepeated nodes except n1 = nk\nCycle (1,2,4,3,1)\nEytan Modiano\nSlide 7\n\nConnected graph\n-\nA graph is connected if a path exists between each pair of nodes\nConnected\nUnconnected\n-\nAn unconnected graph can be separated into two or more connected\ncomponents\nEytan Modiano\nSlide 8\n\nAcyclic graphs and trees\n-\nAn acyclic graph is a graph with no cycles\n- A tree is an acyclic connected graph\nAcyclic,\nunconnected\nCyclic,\nconnected\nnot tree\nnot tree\n- The number of arcs in a tree is always one less than the number of nodes\n-\nProof: start with arbitrary node and each time you add an arc you add a node ⇒\nN nodes and N-1 links. If you add an arc without adding a node, the arc must go\nto a node already in the tree and hence form a cycle\nEytan Modiano\nSlide 9\n\nSub-graphs\n- G' = (N',A') is a sub-graph of G = (N,A) if\n-\n1) G' is a graph\n-\n2) N' is a subset of N\n-\n3) A' is a subset of A\n- One obtains a sub-graph by deleting nodes and arcs from a graph\n-\nNote: arcs adjacent to a deleted node must also be deleted\n-\nGraph G\nSubgraph G' of G\nEytan Modiano\nSlide 10\n\nSpanning trees\n- T = (N',A') is a spanning tree of G = (N,A) if\n-\nT is a sub-graph of G with N' = N and T is a tree\nGraph G\nSpanning tree of G\nEytan Modiano\nSlide 11\n\nSpanning trees\n- Spanning trees are useful for disseminating and collecting control\ninformation in networks; they are sometimes useful for routing\n- To disseminate data from Node n:\n- Node n broadcasts data on all adjacent tree arcs\n- Other nodes relay data on other adjacent tree arcs\n- To collect data at node n:\n- All leaves of tree (other than n) send data\n- Other nodes (other than n) wait to receive data on all but one adjacent\narc, and then send received plus local data on remaining arc\nEytan Modiano\nSlide 12\n\nGeneral construction of a spanning tree\n- Algorithm to construct a spanning tree for a connected graph G = (N,A):\n1) Select any node n in N; N' = {n}; A' = { }\n2) If N' = N, then stop\nT=(N',A') is a spanning tree\n3) Choose (i,j) ∈ A, i ∈ N', j ∈N'\nN' := N'∪{j}; A' := A'∪{(i,j)}; go to step 2\n-\nConnectedness of G assures that an arc can be chosen in step 3 as long as N' = N\n-\nIs spanning tree unique?\n-\nWhat makes for a good spanning tree?\nEytan Modiano\nSlide 13\n\nMinimum Weight Spanning Tree (MST)\n- Generic MST algorithm steps:\n- Given a collection of sub-trees of an MST (called fragments) add a\nminimum weight outgoing edge to some fragment\n- Prim-Dijkstra: Start with an arbitrary single node as a fragment\n- Add minimum weight outgoing edge\n- Kruskal: Start with each node as a fragment;\n- Add the minimum weight outgoing edge, minimized over all\nfragments\nEytan Modiano\nSlide 14\n\nPrim-Dijkstra Algorithm\nStep 1\nStep 3\nStep 2\nStep 4\nStep 5\nEytan Modiano\nSlide 15\n\nKruskal's Algorithm Example\nSuppose the arcs of weight 1 and 3 are a fragment\nFragment\nMST\nMin weight outgoing edge\nfrom fragment\n-\n- Consider any spanning tree using those arcs and the arc of weight 4,\nsay, which is an outgoing arc from the fragment\n- Suppose that spanning tree does not use the arc of weight 2\n- Removing the arc of weight 4 and adding the arc of weight 2 yields\nanother tree of smaller weight\n- Thus an outgoing arc of min weight from fragment must be in MST\nEytan Modiano\nSlide 16\n\nShortest Path routing\n- Each link has a cost that reflects\n-\nThe length of the link\n-\nDelay on the link\n-\nCongestion\n-\n$$ cost\n- Cost may change with time\n- The length of the route is the sum of the costs along the route\n- The shortest path is the path with minimum length\n- Shortest Path algorithms\n-\nBellman-Ford: centralized and distributed versions\n-\nDijkstra's algorithm\n-\nMany others\nEytan Modiano\nSlide 17\n\nDirected graphs (digraphs)\n- A directed graph (digraph) G = (N,A) is a finite nonempty set of nodes N and\na set of ordered node pairs A called directed arcs.\n-\nDirected walk: (4,2,1,4,3,2)\nN = {1,2,3,4}\nA = {(1,2), (2,1),(1,4),\n(4,2), (4,3),(3,2)}\n-\nDirected path: (4,2,1)\n-\nDirected cycle: (4,2,1,4)\n- Data networks are best represented with digraphs, although typically links\ntend to be bi-directional (cost may differ in each direction)\n-\nFor simplicity we will use bi-directional links of equal costs in our examples\nEytan Modiano\nSlide 18\n\nDijkstra's algorithm\n-\nFind the shortest path from a given source node to all other nodes\n-\nRequires non-negative arc weights\n- Algorithm works in stages:\n-\nStage k: the k closest nodes to the source have been found\n-\nStage k+1: Given k closest nodes to the source node, find k+1st\n- Key observation: the path to the k+1st closest nodes includes only nodes\nfrom among the k closest nodes\n- Let M be the set of nodes already incorporated by the algorithm\n-\nStart with Dn = dsn for all n (Dn = shortest path distance from node n to the\nsource node\n-\nRepeat until M=N\nFind node w∈M which has the next least cost distance to the source node\nAdd w to M\nUpdate distances: Dn = min [ Dn, Dw + dwn] (for all nodes n ∈M)\n-\nNotice that the update of Dn need only be done for nodes not already in M and\nthat the update only requires the computation of a new distance by going\nthrough the newly added node w\nEytan Modiano\nSlide 19\n\nDijkstra example\nEytan Modiano\nSlide 20\n\nDijkstra's algorithm implementation\n- Centralized version: Single node gets topology information and\ncomputes the routes\n- Routes can then be broadcast to the rest of the network\n- Distributed version: each node i broadcasts {dij all j} to all nodes\nof the network; all nodes can then calculate shortest paths to each\nother node\n-\nOpen Shortest Path First (OSPF) protocol used in the internet\nEytan Modiano\nSlide 21\n\nBellman Ford algorithm\n- Finds the shortest paths, from a given source node, say node 1, to all\nother nodes.\n- General idea:\n-\nFirst find the shortest single arc path,\n-\nThen the shortest path of at most two arcs, etc.\n-\nLet dij=inf if (i,j) is not an arc.\n- Let Di(h) be the shortest distance from 1 to i using at most h arcs.\n-\nDi(1) = d1i ; i= 1\nD1(1) = 0\n-\nDi(h+1) = min {j} [Dj(h) + dji] ;i= 1\nD1(h+1) = 0\n- If all weights are positive, algorithm terminates in N-1 steps.\nEytan Modiano\nSlide 22\n\nBellman Ford - example\nEytan Modiano\nSlide 23\n\nDistributed Bellman Ford\n- Link costs may change over time\n-\nChanges in traffic conditions\n-\nLink failures\n-\nMobility\n- Each node maintains its own routing table\n-\nNeed to update table regularly to reflect changes in network\n- Let Di be the shortest distance from node i to the destination\n-\nDi = min {j} [Dj + dij] : update equation\n- Each node (i) regularly updates the values of Di using the update equation\n-\nEach node maintains the values of dij to its neighbors, as well as values of Dj\nreceived from its neighbors\n-\nUses those to compute Di and send new value of Di to its neighbors\n-\nIf no changes occur in the network, algorithm will converge to shortest paths in\nno more than N steps\nEytan Modiano\nSlide 24\n\nSlow reaction to link failures\n- Start with D3=1 and D2=100\n- After one iteration node 2 receives D3=1 and\nD2 = min [1+1, 100] = 2\n- In practice, link lengths occasionally change\n- Suppose link between 3 and 1fails (I.e., d31=infinity)\n- Node 3 will update D3 = d32 + D2 = 3\n- In the next step node 2 will update: D2 = d23+D3 = 4\n- It will take nearly 100 iterations before node 2 converges on the correct route\nto node 1\n- Possible solutions:\n- Propagate route information as well\n- Wait before rerouting along a path with increasing cost\nNode next to failed link should announce D=infinity for some time to prevent loops\nEytan Modiano\nSlide 25\n\nRouting in the Internet\n- Autonomous systems (AS)\n- Internet is divided into AS's each under the control of a single\nauthority\n- Routing protocol can be classified in two categories\n- Interior protocols - operate within an AS\n- Exterior protocols - operate between AS's\n- Interior protocols\n- Typically use shortest path algorithms\nDistance vector - based on distributed Bellman-ford\nlink state protocols - Based on \"distributed\" Dijkstra's\nEytan Modiano\nSlide 26\n\nDistance vector protocols\n- Based on distributed Bellman-Ford\n-\nNodes exchange routing table information with their neighbors\n- Examples:\n- Routing information protocols (RIP)\nMetric used is hop-count (dij=1)\nRouting information exchanged every 30 seconds\n- Interior Gateway Routing Protocol (IGRP)\nCISCO proprietary\nMetric takes load into account\nDij ~ 1/(μ-λ) (estimate delay through link)\nUpdate every 90 seconds\nMulti-path routing capability\nEytan Modiano\nSlide 27\n\nLink State Protocols\n- Based on Dijkstra's Shortest path algorithm\n- Avoids loops\n- Routers monitor the state of their outgoing links\n- Routers broadcast the state of their links within the AS\n- Every node knows the status of all links and can calculate all routes\nusing dijkstra's algorithm\nNonetheless, nodes only send packet to the next node along the route with\nthe packets destination address. The next node will look-up the address in\nthe routing table\n- Example: Open Shortest Path First (OSPF) commonly used in the\ninternet\n- Link State protocols typically generate less \"control\" traffic than\nDistance-vector\nEytan Modiano\nSlide 28\n\nInter-Domain routing\n- Used to route packets across different AS's\n- Options:\n-\nStatic routing - manually configured routes\n- Distance-vector routing\nExterior Gateway Protocol (EGP)\nBorder Gateway Protocol (BGP)\n- Issues\n-\nWhat cost \"metric\" to use for Distance-Vector routing\nPolicy issues: Network provider A may not want B's packets routed through\nits network or two network providers may have an agreement\nCost issues: Network providers may charge each other for delivery of\npackets\nEytan Modiano\nSlide 29"
    },
    {
      "category": "Resource",
      "title": "The Data Link Layer: Framing",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/fbb78a025f4ae550c36cabb195da74e7_MIT16_36s09_lec16.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n16.36: Lecture 16 - A\nThe Data Link Layer: Framing\nEytan Modiano\nEytan Modiano\nSlide 1\n\nData Link Layer (DLC)\n- Responsible for reliable transmission of packets over a link\n-\nFraming: Determine the start and end of packets\n-\nError Detection: Determine when a packet contains errors\n-\nError recovery: Retransmission of packets containing errors\nDLC layer recovery\nMay be done at higher layer\nEytan Modiano\nSlide 2\n\nFraming\n_____________________________________\nWhere is the DATA??\n- Three approaches to find frame and idle fill boundaries:\n1) Character oriented framing\n2) Length counts\n- fixed length\n3) Bit oriented protocols (flags)\nEytan Modiano\nSlide 3\n\nCharacter Based Framing\nFrame\nSYN SYN STX Header Packet ETX CRC SYN SYN\nSYN is synchronous idle\nSTX is start text\nETX is end text\n- Standard character codes such as ASCII and EBCDIC contain\nspecial communication characters that cannot appear in data\n- Entire transmission is based on a character code\nEytan Modiano\nSlide 4\n\nIssues With Character Based Framing\n- Character code dependent\n-\nHow do you send binary data?\n- Frames must be integer number of characters\n- Errors in control characters are messy\nNOTE: Primary Framing method from 1960 to ~1975\nEytan Modiano\nSlide 5\n\nLength field approach (DECNET)\n- Use a header field to give the length of the frame (in bits or bytes)\n- Receiver can count until the end of the frame to find the start of the\nnext frame\n- Receiver looks at the respective length field in the next packet\nheader to find that packet's length\n- Length field must be log2 (Max_Size_Packet) + 1 bits long\n- This restricts the packet size to be used\n- Issues with length counts\n- Difficult to recover from errors\n- Resynchronization is needed after an error in the length count\nEytan Modiano\nSlide 6\n\nFixed Length Packets (e.g., ATM)\n- All packets are of the same size\n-\nIn ATM networks all packets are 53 Bytes\n- Requires synchronization upon initialization\n- Issues:\n- Message lengths are not multiples of packet size\nLast packet of a message must contain idle fill (efficiency)\n-\nSynchronization issues\n-\nFragmentation and re-assembly is complicated at high rates\nEytan Modiano\nSlide 7\n\nBit Oriented Framing (Flags)\n- A flag is some fixed string of bits to indicate the start and end of a\npacket\n- A single flag can be used to indicate both the start and the end of a\npacket\n- In principle, any string could be used, but appearance of flag must\nbe prevented somehow in data\n- Standard protocols use the 8-bit string 01111110 as a flag\n- Use 01111111..1110 (<16 bits) as abort under error conditions\n-\nConstant flags or 1's is considered an idle state\n- Thus 0111111 is the actual bit string that must not appear in data\n- INVENTED ~ 1970 by IBM for SDLC (synchronous data link protocol)\nEytan Modiano\nSlide 8\n\nBIT STUFFING (Transmitter)\n-\nUsed to remove flag from original data\n-\nA 0 is stuffed after each consecutive five 1's in the original frame\n1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0\nStuffed bits\nOriginal frame\n-\nWhy is it necessary to stuff a 0 in 0111110?\n-\nIf not, then\n-> 0111110111\n-> 0111110111\n-\nHow do you differentiate at the receiver?\nEytan Modiano\nSlide 9\n\nDESTUFFING (Receiver)\n- If 0 is preceded by 011111 in bit stream, remove it\n- If 0 is preceded by 0111111, it is the final bit of the flag.\nExample: Bits to be removed are underlined below\nflag\nEytan Modiano\nSlide 10\n\nOverhead\n- In general with a flag 01K0 the bit stuffing is require whenever 01k-1\nappears in the original data stream\n- For a packet of length L this will happen about L/2k times\nE{OH} = L/ 2k + (k+ 2) bits\n- For 8 bit flag OH ~ 8 + L/64\n-\nFor large packets efficiency ~ 1 - 1/64 = 98.5 (or 1.5% overhead)\n- Optimal flag length\n- If packets are long want longer flag (less stuffing)\n- If packets are short want short flag (reduce overhead due to flag)\nKopt ~ log2(L)\nEytan Modiano\nSlide 11\n\nFraming Errors\n- All framing techniques are sensitive to errors\n-\nAn error in a length count field causes the frame to be terminated at the wrong\npoint (and makes it tricky to find the beginning of the next frame)\n-\nAn error in DLE, STX, or ETX causes the same problems\n-\nAn error in a flag, or a flag created by an error causes a frame to disappear or\nan extra frame to appear\n- Flag approach is least sensitive to errors because a flag will eventually\nappear again to indicate the end of a next packet\n-\nOnly thing that happens is that an erroneous packet was created\n-\nThis erroneous packet can be removed through an error detection technique\nEytan Modiano\nSlide 12"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 1: Introduction",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/4ede5a7f1ca14fb80ea5d7f93dc22b4c_MIT16_36s09_lec01.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n16.36: Communication Systems Engineering\nLecture 1: Introduction\nFebruary 3, 2009\nEytan Modiano\nEytan Modiano\nSlide 1\n\nTimeline of modern communication\nAnalog\nComm\nSystems\nDigital\nComm\nSystems\nNetworked\nComm\nSystems\n(data packets)\n- 1876 - Bell Telephone\n- 1920 - Radio Broadcast\n- 1936 - TV Broadcast\n- 1960's - Digital communications\n- 1965 - First commercial satellite\n- 1970 - First Internet node\n- 1980 - Development of TCP/IP\n- 1993 - Invention of Web\n~ 2000 - Internet traffic surpasses voice!\nEytan Modiano\nSlide 3\n\nTypical Communication Classes\n- Old days (1980s): Teach analog and digital communications in\nseparate classes\n- Networking was sometimes taught as a graduate class, but most people\ndid not see much use to it!\n- Today: Most communication classes focus mainly on digital\n- Some classes may teach some analog for \"historical\" reasons\n- Networking classes are offered at both undergraduate and graduate levels\n- This class will introduce concepts of communications and networking\nat the undergraduate level\n- First attempt at combining concepts from both\nImportance of not thinking of the two systems as separate systems\n- Other offerings (advanced)\n- 16.37/6.263: Data Networks\n- 6.450: Digital Communications\nEytan Modiano\nSlide 4\n\nWhy communications in AA?\n- AA Information Initiative ~ 1997\n-\nCommunications\n-\nSoftware and computers\n-\nAutonomous systems\n- Computers are a vital part of an Aerospace system\n-\nControl of system, Human interface\n-\nInvolves computers, software, communications, etc.\n-\nE.g., complex communication networks within spacecraft or aircraft\n- Space communications is a critical industry\n-\nSatellite TV, Internet Access, NASA, DoD\n- Information technology is a critical engineering discipline\n-\nThese skills are as fundamental today as the knowledge of basic math or\nphysics\nEytan Modiano\nSlide 5\n\nCommunication Applications\n-\nBroadcast TV/Radio\n-\nRecent move toward digital broadcast (Satellite TV/Radio)\n-\n2009: all TV broadcast is going digital (HDTV) - why?\n-\nDigital telephony\n-\nWired and wireless\n-\nComputer communications/networks\n-\nResource sharing\nComputing: mainframe computer (old days)\nPrinters, peripherals\nInformation, DB access and update\n-\nInternet Services\nEmail, FTP, Telnet, Web access\n-\nToday, the vast majority of network traffic is for internet applications\n-\nInternet is also starting to carry traditional applications\nRadio, TV, phone\nEytan Modiano\nSlide 8\n\nTypes of Networks\n-\nWide Area Networks (WANS)\n-\nSpan large areas (countries, continents, world)\n-\nUse leased phone lines (expensive!)\n1980's: 10 Kbps, 2000's: 2.5 Gbps\nUser access rates: 56Kbps - 155 Mbps typical\n-\nShared communication links: switches and routers\nE.g, IBM SNA, X.25 networks, Internet\n-\nLocal Area Networks (LANS)\n-\nSpan office or building\n-\nSingle hop (shared channel) (cheap!)\n-\nUser rates: 10 Mbps - 1 Gbps\nE.g., Ethernet, Token rings, Apple-talk\nEytan Modiano\nSlide 9\n\nNetwork services\n- Synchronous (stream)\n-\nSession appears as a continuous stream of traffic (e.g, voice)\n-\nUsually requires fixed and limited delays\n- Asynchronous (bursty)\n-\nSession appears as a sequence of messages\n-\nTypically bursty\n-\nE.g., Interactive sessions, file transfers, email\n- Connection oriented services\n-\nLong sustained session\n-\nOrderly and timely delivery of packets\n-\nE.g., Telnet, FTP\n- Connectionless services\n-\nOne time transaction (e.g., email)\n- QoS\nEytan Modiano\nSlide 10\n\nSwitching Techniques\n- Circuit Switching\n-\nDedicated resources\n-\nTraditional telephone networks\n- Packet Switching\n-\nShared resources\n-\nModern data networks\nEytan Modiano\nSlide 11\n\nCircuit Switching\n- Each session is allocated a fixed fraction of the capacity on each\nlink along its path\n- Dedicated resources\n- Fixed path\n- If capacity is used, calls are blocked\nE.g., telephone network\n- Advantages of circuit switching\n- Fixed delays\n- Guaranteed continuous delivery\n- Disadvantages\n- Circuits are not used when session is idle\n- Inefficient for bursty traffic\n- Circuit switching usually done using a fixed rate stream (e.g., 64 Kbps)\nDifficult to support variable data rates\nEytan Modiano\nSlide 12\n\nPacket Switched Networks\nPacket Network\nPS\nPS\nPS\nPS\nPS\nPS\nPS\nBuffer\nPacket\nSwitch\nMessages broken into\nPackets that are routed\nTo their destination\nEytan Modiano\nSlide 13\n\n7 Layer OSI Reference Model\nEytan Modiano\nVirtual link for\nreliable packets\nApplication\nPresentation\nSession\nTransport\nNetwork\nData link\nControl\nApplication\nPresentation\nSession\nTransport\nNetwork\nData link\nControl\nNetwork\nNetwork\nDLC\nDLC\nDLC\nDLC\nPhysical link\nVirtual bit pipe\nVirtual link for end to end packets\nVirtual link for end to end messages\nVirtual session\nVirtual network service\nExternal\nSite\nsubnet\nnode\nsubnet\nnode\nExternal\nsite\nphysical\ninterface\nphys. int.\nphys. int.\nphys. int.\nphys. int.\nphysical\ninterface\nSlide 14\n\nLayers\n- Presentation layer\n-\nProvides character code conversion, data encryption, data compression, etc.\n- Session layer\n-\nObtains virtual end to end message service from transport layer\n-\nProvides directory assistance, access rights, billing functions, etc.\n- Standardization has not proceeded well here, since transport to application are\nall in the operating system and don't really need standard interfaces\n- Focus: Transport layer and lower\nEytan Modiano\nSlide 15\n\nTransport Layer\n- The transport layer is responsible for reliable end-to-end\ntransmission of messages across the network\n- The network layer provides a virtual end to end packet pipe to the\ntransport layer.\n- The transport layer provides a virtual end to end message service to\nthe higher layers.\n- The functions of the transport layer are:\n1) Break messages into packets and reassemble\npackets of size suitable to network layer\n2) Multiplex sessions with same source/destination nodes\n3) Resequence packets at destination\n4) recover from residual errors and failures\n5) Provide end-to-end flow control\nEytan Modiano\nSlide 16\n\nNetwork layer\n- The network layer is responsible for routing of packets across the\nnetwork\n- The network layer module accepts incoming packets from the\ntransport layer and transit packets from the DLC layer\n- It routes each packet to the proper outgoing DLC or (at the destination)\nto the transport layer\n- Typically, the network layer adds its own header to the packets\nreceived from the transport layer. This header provides the\ninformation needed for routing (e.g., destination address)\nEach node contains one network\nLayer module plus one\nLink layer module per link\nEytan Modiano\nSlide 17\nDLC layer\nlink 1\nDLC layer\nlink 2\nDLC layer\nlink 3\nNetwork\nlayer\nTransport\nlayer\n\nLink Layer\n- Responsible for error-free transmission of packets across a\nsingle link\n- Framing\nDetermine the start and end of packets\n- Error detection\nDetermine which packets contain transmission errors\n- Error correction\nRetransmission schemes (Automatic Repeat Request (ARQ))\nEytan Modiano\nSlide 18\n\nInternetworking with TCP/IP\nFTP\nclient\nFTP\nserver\nFTP Protocol\nTCP\nTCP Protocol\nTCP\nROUTER\nIP Protocol\nIP Protocol\nEthernet\nEthernet\nProtocol\ntoken ring\ndriver\ntoken ring\nProtocol\nEthernet\ndriver\nIP\nEthernet\ndriver\ntoken ring\ndriver\ntoken ring\nIP\nIP\nEytan Modiano\nSlide 19\n\nPhysical Layer\n- Responsible for transmission of bits over a link\n- Propagation delays\n- Time it takes the signal to travel from the source to the destination\nSignal travel approximately at the speed of light, C = 3x108 meters/second\n- E.g.,\nLEO satellite: d = 1000 km => 3.3 ms prop. delay\nGEO satellite: d = 40,000 km => 1/8 sec prop. delay\nEthernet cable: d = 1 km => 3 μs prop. delay\n- Transmission errors\n-\nSignals experience power loss due to attenuation\n-\nTransmission is impaired by noise\n-\nSimple channel model: Binary Symmetric Channel\n1-P\nP = bit error probability\nIndependent from bit to bit\n-\nIn reality channel errors are often bursty\n1-P\nP\nP\nEytan Modiano\nSlide 20\n\nBasic elements of the physical layer\nInput from\nHigher layer\nChannel\nencoder\nmodulator\nChannel\nOutput to\nhigher layer\nChannel\ndecoder\nDe-\nmodulator\n- In the traditional view of communication system the input was an\nanalog information source (typically voice)\n- In order to digitally transmit analog information one needs to\nconvert this analog waveform into a digital waveform\n- Sampling, Quantization, Source coding\n- In modern computer networks the information source is often\ndigital to begin with\n- Analog to digital conversion is not viewed as a part of the\ncommunication system, but as a higher layer function (application)\nEytan Modiano\nSlide 21\n\nTransmission of Information\n-\nInformation source\n-\nContinuous - e.g., voice, video\n-\nDiscrete - e.g., text, computer data\n-\nSignal\n-\nAnalog (continuous valued)\n-\nDigital (discrete valued)\n-\nWhy digital transmission?\n-\nCan remove unwanted \"noise\" to reproduce digital signal\n-\nCan eliminate redundancy\n-\nDigital transmission of continuous data\n-\nSample\n-\nQuantize\n-\nEncode\nEytan Modiano\nSlide 22\n\nElements of a digital communication system\n- Source coding\n- Used to compress the data\nLossy, lossless\n- Channel coding\n-\nUsed to overcome unwanted channel noise\n-\nIntroduce \"redundancy\" to protect against errors\n- Modulation\n-\nRepresent bits using continuous valued signals suited for\ntransmission\nImpose discrete valued signals on an analog waveform\nTypically use sine or cosine wave\nEytan Modiano\nSlide 23\n\nTransmission channels\n- Electro-magnetic transmission\n-\nGuided medium: twisted pair, coaxial cable\n-\nUnguided medium (air): radio transmission, satellite\n- Optical Transmission\n-\nMedia: optical fiber, free space (satellite)\n- Storage\n-\nMagnetic (tape, disk)\n-\nOptical (CD)\nEytan Modiano\nSlide 24\n\nFrequency spectrum\n- Transmission over the airwaves uses different frequency bands\n- Useful frequency bands are not limitless\n- Spectrum is a natural resource that must be used efficiently\n- Spectrum is allocated to operators by the Government\n-\nFederal Communications Commission (FCC)\nEytan Modiano\nSlide 25\n\nFrequency spectrum\nEytan Modiano\nSlide 26\nFrequency rang\ne f\nor wireless\nelectromagn\netic channels\n, highli\nghting the\nbands fo\nr micr\nowa\nve ra\ndio\n, sh\nortwa\nve r\nadio,\nand l\nongwav\ne radi\no.\nFigure by MIT OpenCourseWare."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 2: The Sampling Theorem",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/6c4e7183ae2d48e1b6b04a337b010529_MIT16_36s09_lec02.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nLecture 2: The Sampling Theorem\nEytan Modiano\nEytan Modiano\nSlide 1\n\nSampling\n- Given a continuous time waveform, can we represent it using\ndiscrete samples?\n- How often should we sample?\n- Can we reproduce the original waveform?\nλ\nλ\nλ λ λ λ\nλ λ\nλ\nλ\nEytan Modiano\nSlide 2\n\nThe Fourier Transform\n- Frequency representation of signals\n- Definition:\nX( f) =\nx(t)e! j2\"ft\n!#\n#$\ndt\nx(t) =\nX( f)ej 2\"ft\n!#\n#$\ndf\n- Notation:\nX(f) = F[x(t)]\nX(t) = F-1 [X(f)]\nx(t) X(f)\nEytan Modiano\nSlide 3\n\nUnit impulse δ(t)\n!(t) = 0,\"t # 0\n!(t)=1\n$%\n%&\n!(t)x(t) = x(0)\n\"#\n#$\n!(t \" % )x(%) = x(t)\n\"#\n#$\nF[!(t)] =\n!(t)e\" j 2#ftdt = e0 = 1\n\"$\n$%\n!(t) & 1\n!(t)\nF[!(t)]\nEytan Modiano\nSlide 4\n\nRectangle pulse\n!(t) =\n| t |<1/ 2\n1/ 2\n| t |= 1/ 2\notherwise\n\"\n#$\n%$\nF[!(t)] =\n!(t)e& j2' ftdt =\n&(\n()\ne& j2' ftdt\n&1/2\n1/2\n)\n= e& j' f & e j' f\n& j2' f\n= Sin(' f )\n' f\n= Sinc( f )\n!(t)\n1/2\n1/2\nEytan Modiano\nSlide 5\n\nProperties of the Fourier transform\n- Linearity\n-\nx1(t) <=> X1(f), x2(t) <=>X2(f) => αx1(t) + βx2(t) <=> αX1(f) + βX2(f)\n- Duality\n- X(f) <=> x(t) => x(f) <=> X(-t) and x(-f)<=> X(t)\n- Time-shifting: x(t-τ) <=> X(f)e-j2πfτ\n- Scaling: F[(x(at)] = 1/|a| X(f/a)\n- Convolution: x(t) <=> X(f), y(t) <=> Y(f) then,\n- F[x(t)*y(t)] = X(f)Y(f)\n- Convolution in time corresponds to multiplication in frequency and\nvice versa\nx(t) * y(t) =\nx(t ! \")y(\")d\"\n!#\n#$\nEytan Modiano\nSlide 6\n\nFourier transform properties (Modulation)\nx(t)e j2!fot \" X( f # fo)\nNow, cos(x) = e jx + e# jx\nx(t) cos(2!fot) = x(t)ej 2!f ot + x(t)e# j 2!fot\nHence, x(t) cos(2!fot) \" X( f # fo) + X( f + fo)\n- Example: x(t)= sinc(t), F[sinc(t)] = Π(f)\n- Y(t) = sinc(t)cos(2πfot) <=> (Π(f-fo)+Π(f+fo))/2\n1/2\n-fo\n+fo\nEytan Modiano\nSlide 7\n\nMore properties\n- Power content of signal\n- Autocorrelation\n- Sampling\n| x(t) |2\n!\"\n\"#\ndt =\n| X( f ) |2\n!\"\n\"#\ndf\nRx(!) =\nx(t)x*(t \" ! )dt\n\"#\n#$\nRx(!) %| X( f) |2\nx(to ) = x(t)!(t \" to )\nx(t)\n!(t \" nto ) = sampled version of x(t)\nn= \"#\n#\n$\nF[\n!(t \" nto )] = 1\nto\n\nn= \"#\n#\n$\n!( f \" n\nto\n)]\nn= \"#\n#\n$\nEytan Modiano\nSlide 8\n\nThe Sampling Theorem\n- Band-limited signal\n-\nBandwidth < W\nSampling Theorem: If we sample the signal at intervals Ts where\nTs ≤ 1/ 2W then signal can be completely reconstructed from its\nsamples using the formula\nX( f) = 0, for all f, | f |! W\nX( f)\n-w\nw\nx(t) =\n2W' Tsx(nTs )sinc[2W' (t ! nTs)]\nn =!\"\n\"\n#\nWhere,\nW $ W' $ 1\nTs\n! W\nWithTs =\n2W =>x(t)=\nx(nTs)sinc[( t\nTs\n! n)]\nn= !\"\n\"\n#\nx(t) =\nx( n\n2W)sinc[2W(t ! n\n2W)]\nn =!\"\n\"\n#\nEytan Modiano\nSlide 9\n\nProof\nx!(t) = x(t)\n!(t \" nTs)\nn= \"#\n#\n$\nX!( f) = X( f) * F[\n!(t \" nTs)\nn= \"#\n#\n$\n]\nF[\n! (t \" nTs)\nn= \"#\n#\n$\n] = 1\nTs\n! ( f \" n\nTs\n)\nn= \"#\n#\n$\nX!( f) = 1\nTs\nX( f \" n\nTs\n)\nn=\"#\n#\n$\n- The Fourier transform of the sampled signal is a replication of the\nFourier transform of the original separated by 1/Ts intervals\n2/Ts\n-2/Ts\n-1/Ts\n-w\nw\n1/Ts\nEytan Modiano\nSlide 10\n\nProof, continued\n- If 1/Ts > 2W then the replicas of X(f) will not overlap and can be\nrecovered\n- How can we reconstruct the original signal?\n-\nLow pass filter the sampled signal\n- Ideal low pass filter is rectangular\n-\nIts impulse response is a sinc function\nH( f ) = Ts!( f\n2W)\n- Now the recovered signal after low pass filtering\nX( f ) = X! ( f)Ts\"( f\n2W)\nx(t) = F\n#1[X! ( f )Ts\"( f\n2W)]\nx(t) =\nx(nTs)Sinc( t\nTs\nn =#$\n$\n%\n# n)\nEytan Modiano\nSlide 11\n\nNotes about Sampling Theorem\n- When sampling at rate 2W the reconstruction filter must be a\nrectangular pulse\n- Such a filter is not realizable\n- For perfect reconstruction must look at samples in the infinite future\nand past\n- In practice we can sample at a rate somewhat greater than 2W which\nmakes reconstruction filters that are easier to realize\n- Given any set of arbitrary sample points that are 1/2W apart, can\nconstruct a continuous time signal band-limited to W\n- Sampling using \"impulses\" is also not practical\n- Narrow pulses are difficult to implement\n- In practice, sampling is done using small rectangular pulses or\n\"zero-order-hold\"\nEytan Modiano\nSlide 12\n\nZero-Order Hold\n- A form of \"interpolation\"\n- The sampled signal holds its value until the next sample time\nsampled values\nheld values\n- In principle, zero-order hold can be realized with a cascade of an\nimpulse train sampling and an LTI system with rectangular\nimpulse response\nEytan Modiano\nSlide 13\nT\nh0(t)\nx0(t)\nx(t)\nx0(t)\nx! (t) = x(t)\n!(t \" nTs)\nn=\"#\n#\n$\np(t) =\n!(t \" nTs)\nn=\"#\n#\n$\n\nReconstruction from zero-order hold\nT\nh0(t)\nx0(t)\nx(t)\nx(t)\np(t) =\n!(t \" nTs)\nn=\"#\n#\n$\nhr(t)\nH(f)\nx! (t)\n- We know from the sampling theorem that in order to reconstruct\nx(t) from the impulse train samples on the left (xδ(t)) the filter on the\nright (H(f)) must be an ideal rectangular filter\nH( f ) = Ts!( f\n2W ) = Ts!(Ts f )\nH( f ) = Ts!( f\n2W ) = H0( f )Hr( f )\nH0( f ) = e\" j# fT (sin(# fT )\n# f\n)\n$\n%\n&&\n'\n&\n&\n( Hr( f ) =\nTs!( f\n2W )e j# fT# f\nsin(# fT )\nHr( f )\n-w\nw\nEytan Modiano\nSlide 14\n\nAliasing\n- Sampling theorem requires that the signal be sampled at a\nfrequency greater than twice its bandwidth\n- When sampling at a frequency less than 2W, the replicas of the\nfrequency spectrum overlap and cannot be \"separated\" using a\nlow pass filter\n- This is referred to as aliasing\n- Higher frequencies are \"reflected\" only lower frequencies\n- Signal cannot be recovered\n- The term aliasing refers to the fact that the higher frequency\nsignals become indistinguishable from the lower frequency ones\nEytan Modiano\nSlide 15"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 3: Measuring Information and Entropy",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/966f7edc174ad58aca88b816d1b8719a_MIT16_36s09_lec03.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n16.36: Communication Systems Engineering\nLecture 3:\nMeasuring Information and Entropy\nFebruary 10, 2009\nEytan Modiano\nEytan Modiano\nSlide 1\n\nInformation content of a random variable\n(how much information is in the data?)\n- Random variable X\n- Outcome of a random experiment\n- Discrete R.V. takes on values from a finite set of possible outcomes\nPMF: P(X = y) = Px(y)\n- How much information is contained in the event X = y?\n- Will the sun rise today?\nRevealing the outcome of this experiment provides no information\n- Will the Celtics win the NBA championship?\nIt's possible - but not certain\nRevealing the answer to this question certainly has value - I.e., contains information\n- Events whose outcome is certain contain less information than even\nwhose outcome is in doubt\nEytan Modiano\nSlide 2\n\nMeasure of Information\n-\nI(xi) = Amount of information revealed by an outcome X = xi\n-\nDesirable properties of I(x):\n1. If P(x) = 1 or P(x) = 0, then I(x) = 0\n2. If 0 < P(x) < 1, then I(x) > 0\n3. If P(x) < P(y), then I(x) > I(y)\n4. If x and y are independent events then I(x,y) = I(x)+I(y)\n-\nAbove is satisfied by: I(x) = Log2(1/P(x))\n-\nBase of Log is not critical\n-\nBase 2 ⇒ information measured in bits\nEytan Modiano\nSlide 3\n\nEntropy\n- A measure of the information content of a random variable\n- X ∈ {x1,...,xM}\n- H(X) = E[I(X)] = ∑P(xi) Log2(1/P(xi))\n- Example: Binary experiment\n-\nX = x1 with probability p\n-\nX = x2 with probability (1-p)\n-\nH(X) = pLog2(1/p) + (1-p)Log2(1/(1-p)) = Hb(p)\n-\nH(X) is maximized with p=1/2, Hb(1/2) = 1\nNot surprising that the result of a binary experiment can be conveyed using\none bit\nEytan Modiano\nSlide 4\n\nSimple bounds on entropy\n-\nTheorem: Given a random variable with M possible values\n-\n0 ≤ H(X) ≤ Log2(M)\nA) H(X) = 0 if and only if P(xi) = 1 for some i\nB) H(X) = Log2(M) if and only if P(xi) = 1/M for all i\n- Proof of A is obvious\nY=x-1\n- Proof of B requires\nthe Log Inequality:\n- if x > 0 then ln(x) ≤ x-1\n-\nEquality if x=1\nY= ln(x)\nEytan Modiano\nSlide 5\n\nProof, continued\nEytan Modiano\nSlide 6\nConsider the sum\nPiLog( 1\nMPi\ni=1\nM\n!\n) =\nln(2)\nPiLn( 1\nMPi\ni=1\nM\n!\n), by log inequality:\n\"\nln(2)\nPi (\ni=1\nM\n!\nMPi\n#1) =\nln(2)\n(\ni=1\nM\n!\nM\n# Pi) = 0, equality when Pi = 1\nM\nWriting this in another way:\nPiLog( 1\nMPi\ni=1\nM\n!\n) =\nPiLog( 1\nPi\ni=1\nM\n!\n) +\nPiLog( 1\nM\ni=1\nM\n!\n) \" 0,equality when Pi = 1\nM\nThat is,\nPiLog( 1\nPi\ni=1\nM\n!\n) \"\nPiLog(M\ni=1\nM\n!\n) = Log(M)\n\nJoint Entropy\nEytan Modiano\nSlide 7\nJoint entropy: H(X,Y) =\np(x, y) log(\np(x,y))\nx,y!\nConditional entropy: H(X | Y) = uncertainty in X given Y\nH(X |Y = y) =\np(x |Y = y)log(\np(x |Y = y)\nx!\n)\nH(X | Y) = E[H(X |Y = y)] =\np(Y = y)\ny!\nH(X |Y = y)\nH(X | Y) =\np( x, y)\nx,y!\nlog(\np(x |Y = y))\nIn General : X1,...,Xn random variables\nH(Xn | X1,...,Xn-1) =\np(\nx1,...,xn\n!\nx1,...,xn) log(\np(xn | x1,...,xn-1)\n\nRules for entropy\n1. Chain rule:\nH(X1, .., Xn) = H(X1) + H(X2|X1) + H(X3|X2,X1) + ...+ H(Xn|Xn-1...X1)\n2. H(X,Y) = H(X) + H(Y|X) = H(Y) + H(X|Y)\n3. If X1, .., Xn are independent then:\nH(X1, .., Xn) = H(X1) + H(X2) + ...+H(Xn)\nIf they are also identically distributed (i.i.d) then:\nH(X1, .., Xn) = nH(X1)\n4. H(X1, .., Xn) ≤ H(X1) + H(X2) + ...+ H(Xn) (with equality iff independent)\nProof: use chain rule and notice that H(X|Y) < H(X)\nentropy is not increased by additional information\nEytan Modiano\nSlide 8\n\nMutual Information\n- X, Y random variables\n- Definition: I(X;Y) = H(Y) - H(Y|X)\n- Notice that H(Y|X) = H(X,Y) - H(X) ⇒ I(X;Y) = H(X)+H(Y) - H(X,Y)\n- I(X;Y) = I(Y;X) = H(X) - H(X|Y)\n- Note: I(X,Y) ≥ 0 (equality iff independent)\n-\nBecause H(Y) ≥ H(Y|X)\nEytan Modiano\nSlide 9"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 4: Quantization",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/d91cdcc10683c573cc668c5b1ab3aab6_MIT16_36s09_lec04.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nLecture 4: Quantization\nEytan Modiano\nAero-Astro Dept.\nEytan Modiano\nSlide 1\n\nSampling\n- Sampling provides a discrete-time representation of a continuous\nwaveform\n-\nSample points are real-valued numbers\n- In order to transmit over a digital system we must first convert into\ndiscrete valued numbers\nQuantization\nlevels\nQ3\nQ2\nQ1\nλ\nλ\nλ λ λ λ\nλ λ\nλ\nλ\nSample points\nWhat are the quantization regions\nWhat are the quantization levels\nEytan Modiano\nSlide 2\n\nUniform Quantizer\nΔ\n2Δ\n3Δ\n-3Δ\n-2Δ\n-Δ\nY = x\nQ(x)\nQ(x)\n- All quantization regions are of equal size (Δ)\n-\nExcept first and last regions if samples are not finite valued\n- With N quantization regions, use log2(N) bits to represent each\nquantized value\nEytan Modiano\nSlide 3\n\nQuantization Error\ne(x) = Q(x) - x\nSquared error: D = E[e(x)2] = E[(Q(x)-x)2]\nSQNR: E[X2]/E[(Q(x)-x)2]\nEytan Modiano\nSlide 4\n\nExample\n- X is uniformly distributed between -A and A\n-\nf(x) = 1/2A, -A<=x<=A and 0 otherwise\n- Uniform quantizer with N levels => Δ = 2A/N\n-\nQ(x) = quantization level = midpoint of quantization region in which x lies\n-\nD = E[e(x)2] is the same for quantization regions\nD = E[e(x)2 | x !Ri ] =\nx2 f(x)dx\n\" # / 2\n# / 2\n$\n= 1\n#\nx2dx\n\"# / 2\n# / 2\n$\n= #2\nE[X] = 1\n2A\nx\n2dx\n\" A\nA$\n= A2\nSQNR = A2 /3\n#2 /12 =\nA2 /3\n(2A/ N)2 /12 = N\n2, (# = 2A/ N)\nEytan Modiano\nSlide 5\n\nQuantizer design\n- Uniform quantizer is good when input is uniformly distributed\n- When input is not uniformly distributed\n- Non-uniform quantization regions\nFiner regions around more likely values\n- Optimal quantization values not necessarily the region midpoints\n- Approaches\n- Use uniform quantizer anyway\nOptimal choice of Δ\n- Use non-uniform quantizer\nChoice of quantization regions and values\n- Transform signal into one that looks uniform and use uniform\nquantizer\nEytan Modiano\nSlide 6\n\nOptimal uniform quantizer\n- Given the number of regions, N\n- Find the optimal value of Δ\n- Find the optimal quantization values within each region\n- Optimization over N+2 variables\n- Simplification: Let quantization levels be the midpoint of the\nquantization regions (except first and last regions, when input not\nfinite valued)\n- Solve for Δ to minimize distortion\n- Solution depends on input pdf and can be done numerically for\ncommonly used pdfs (e.g., Gaussian pdf, table 6.2, p. 296 of text)\nEytan Modiano\nSlide 7\n\nUniform quantizer example\n- N=4, X~N(0,1)\nfx(x) =\n2!\" e\n# x 2 / 2\" 2, \"\n2 = 1\n- From table 6.2, Δ=0.9957, D=0.1188, H(Q)= 1.904\n-\nNotice that H(Q) = the entropy of the quantized source is < 2\n-\nTwo bits can be used to represent 4 quantization levels\n-\nSoon we will learn that you only need H(Q) bits\nΔ\n- Δ\nR1\nR2\nR3\nR4\nq1 = -3Δ/2\nq4 = 3Δ/2\nq2 =Δ/2\nq3 =Δ/2\nEytan Modiano\nSlide 8\n\nNon-uniform quantizer\n- Quantization regions need not be of same length\n- Quantization levels need not be at midpoints\n- Complex optimization over 2N variables\n- Approach:\n-\nGiven quantization regions, what should the quantization levels be?\n-\nWhat should the quantization regions be?\n- Solve for quantization levels first (given region (ai-1, ai))\n-\nMinimize distortion\nEytan Modiano\nSlide 9\n\nNon-uniform quantizer\n1ˆx\n2ˆx\nY = x\na1\na2\na3\na3\na4\na5\na6\n3ˆx\nNeed to determine optimum quantization regions and levels\nEytan Modiano\nSlide 10\n\nOptimal quantization levels\n- Minimize distortion, D\n- Optimal value affects distortion\nonly within its region\n-\n]\n|\n[\nˆ\n)\n|\n(\nˆ\n)\n(\n)\nˆ\n(\nˆ\n)\n(\n)\nˆ\n(\ni\ni\ni\na\na\ni\ni\nx\ni\na\na\nx\ni\ni\nR\na\na\nx\ni\nR\na\nx\na\nX\nE\nx\ndx\na\nx\na\nx\nxf\nx\ndx\nx\nf\nx\nx\nx\nd\ndD\ndx\nx\nf\nx\nx\nD\ni\ni\ni\ni\ni\ni\n!\n!\n=\n!\n!\n=\n=\n\"\n=\n\"\n=\n\"\n\"\n#\n#\n#\n\"\n\"\n\"\n- Quantization values should be the \"centroid\" of their regions\n- The conditional expected value of that region\n- Approach can be used to find optimal quantization values for the\nuniform quantizer as well\nEytan Modiano\nSlide 11\n\nOptimal quantization regions\n- Take derivative of D with respect to ai\n- Take derivative with respect to integral boundaries\ndD\ndai\n= fx(ai )[(ai ! ˆ x i )\n2 ! (ai ! ˆ x i +1)\n2] = 0\nai = ˆ x i + ˆ x i +1\n- Boundaries of the quantization regions are the midpoint of the\nquantization values\n- Optimality conditions:\n1. Quantization values are the \"centroid\" of their region\n2. Boundaries of the quantization regions are the midpoint of the\nquantization values\n3. Clearly 1 depends on 2 and visa-versa. The two can be solved\niteratively to obtain optimal quantizer\nEytan Modiano\nSlide 12\n\nFinding the optimal quantizer\n- Start with arbitrary regions (e.g., uniform Δ)\nA) Find optimal quantization values (\"centroids\")\nB) Use quantization values to get new regions (\"midpoints\")\n- Repeat A & B until convergence is achieved\n- Can be done numerically for known distributions\n- Table 6.3 (p. 299) gives optimal quantizer for Gaussian source\n- E.g., N=4,\n-\nD = 0.1175, H(x) = 1.911\n-\nRecall: uniform quantizer, D= 0.1188, H(x) = 1.904 (slight improvement)\n1.51\n0.4528\n-0.9816\n-0.4528\n0.9816\nEytan Modiano\nSlide 13\n- 1.51\n\nCompanders\n-\nNon-uniform quantizer can be difficult to design\n-\nRequires knowledge of source statistics\n-\nDifferent quantizers for different input types\n- Solution: Transfer input signal into one that looks uniform and then use\nuniform quantizer\n-\nSpeech signal: high probabilities for low amplitudes\n-\nCompress the large amplitudes before performing uniform quantization\n-\nμ-law compander\ng(x) = Log(1 + μ | x |)\nLog(1 + μ)\nsgn(x)\n-\nμ controls the level of compression\n-\nμ = 255 typically used for voice\nEytan Modiano\nSlide 14\n\nPulse code modulation\nQuantizer\nμ -law\nUniform Q\nSampler\nencoder\nvoice\n- Uniform PCM: x(t) ∈ [Xmin, Xmax]\n-\nN = 2V quantization levels, each level encoded using v bits\n-\nSQNR: same as uniform quantizer\nSQNR = E[X2] !3 ! 4v\nXMAX\n-\nNotice that increasing the number of bits by 1 decreases SQNR by a\nfactor of 4 (6 dB)\nEytan Modiano\nSlide 15\n\nSpeech coding\n- PCM with μ = 255\n- Uniform quantizer with 128 levels, N = 27 , 7 bits per sample\n- Speech typically limited to 4KHZ\n- Sample at 8KHZ => Ts = 1/8000 = 125 μs\n8000 samples per second at 7 bits per sample => 56 Kbps\n- Differential PCM\n- Speech samples are typically correlated\n- Instead of coding samples independently, code the difference\nbetween samples\n- Result: improved performance, lower bit rate speech\nEytan Modiano\nSlide 16"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 5: Source Coding",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/16-36-communication-systems-engineering-spring-2009/8d1958c0df197247e643e51d3eb5092e_MIT16_36s09_lec05.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n16.36 Communication Systems Engineering\nSpring 2009\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n16.36: Communication Systems Engineering\nLecture 5: Source Coding\nEytan Modiano\nEytan Modiano\nSlide 1\n\nSource coding\nSource\nEncode\nChannel\nAlphabet\nAlphabet\n{a1..aN}\n{c1..cN}\n- Source symbols\n-\nLetters of alphabet, ASCII symbols, English dictionary, etc...\n-\nQuantized voice\n- Channel symbols\n- In general can have an arbitrary number of channel symbols\nTypically {0,1} for a binary channel\n- Objectives of source coding\n-\nUnique decodability\n-\nCompression\nEncode the alphabet using the smallest average number of channel\nsymbols\nEytan Modiano\nSlide 2\n\nCompression\n- Lossless compression\n- Enables error free decoding\n- Unique decodability without ambiguity\n- Lossy compression\n- Code may not be uniquely decodable, but with very high probability\ncan be decoded correctly\nEytan Modiano\nSlide 3\n\nPrefix (free) codes\n- A prefix code is a code in which no codeword is a prefix of any\nother codeword\n- Prefix codes are uniquely decodable\n- Prefix codes are instantaneously decodable\n- The following important inequality applies to prefix codes and in\ngeneral to all uniquely decodable codes\nKraft Inequality\nLet n1...nk be the lengths of codewords in a prefix (or any\nUniquely decodable) code. Then,\n! ni\ni =1\nk\n\"\n#1\nEytan Modiano\nSlide 4\n\nProof of Kraft Inequality\n- Proof only for prefix codes\n- Can be extended for all uniquely decodable codes\n- Map codewords onto a binary tree\n- Codewords must be leaves on the tree\n- A codeword of length ni is a leaf at depth ni\n- Let nk ≥ nk-1 ... ≥ n1 ⇒ depth of tree = nk\n- In a binary tree of depth nk, up to 2nk leaves are possible (if all leaves\nare at depth nk)\n- Each leaf at depth ni < nk eliminates a fraction 1/2ni of the leaves at\ndepth nk ⇒ eliminates 2nk -ni of the leaves at depth nk\n- Hence,\nnk ! ni\ni =1\nk\n\"\n#2\nnk $\n!ni\ni =1\nk\n\"\n# 1\nEytan Modiano\nSlide 5\n\nKraft Inequality - converse\n- If a set of integers {n1..nk} satisfies the Kraft inequality the a prefix\ncode can be found with codeword lengths {n1..nk}\n- Hence the Kraft inequality is a necessary and sufficient condition for the\nexistence of a uniquely decodable code\n- Proof is by construction of a code\n-\nGiven {n1..nk}, starting with n1 assign node at level ni for codeword of\nlength ni. Kraft inequality guarantees that assignment can be made\nExample: n = {2,2,2,3,3}, (verify that Kraft inequality holds!)\nn1\nn2\nn3\nn5\nn4\nEytan Modiano\nSlide 6\n\nAverage codeword length\n- Kraft inequality does not tell us anything about the average length\nof a codeword. The following theorem gives a tight lower bound\nTheorem: Given a source with alphabet {a1..ak}, probabilities {p1..pk},\nand entropy H(X), the average length of a uniquely decodable\nbinary code satisfies:\nn ≥ H(X)\nProof:\nH(X) ! n =\npi log 1\npi\ni =1\ni = k\n\"\n!\npini\ni =1\ni = k\n\"\n=\npi log 2! ni\npi\ni =1\ni = k\n\"\nlog inequality =>log( X) # X !1 =>\nH(X) ! n #\npi\n2!ni\npi\n!1\n$\n%\n&\n&\n'\n(\n)\n) =\ni =1\ni= k\n\"\n! ni ! 1\ni =1\ni = k\n\"\n# 0\nEytan Modiano\nSlide 7\n\nAverage codeword length\n- Can we construct codes that come close to H(X)?\nTheorem: Given a source with alphabet {a1..ak}, probabilities {p1..pk},\nand entropy H(X), it is possible to construct a prefix (hence\nuniquely decodable) code of average length satisfying:\nn < H(X) + 1\nProof (Shannon-fano codes):\nLet ni = log( 1\npi\n)\n!\n\"\n\" \"\n#\n$\n$ $ %ni &log( 1\npi\n) % 2\n' ni ( pi\n%\n' ni (\ni =1\nk\n)\npi (1\ni =1\nk\n)\n%Kraftinequality satisfied!\n%Can find a prefix code with lengths,\nni = log( 1\npi\n)\n!\n\"\n\"\n\"\n#\n$\n$\n$ < log( 1\npi\n)+1\nni = log( 1\npi\n)\n!\n\"\n\"\n\"\n#\n$\n$\n$ < log( 1\npi\n)+1,\nNow,\nn =\npini\ni =1\nk\n%\n<\npi log( 1\npi\n)+1\n!\n&\n\"\n\"\n#\n'\n$\n$\ni =1\nk\n%\n= H(X) +1.\nHence,\nH(X)(n <H(X)+1\nEytan Modiano\nSlide 8\n\nGetting Closer to H(X)\n- Consider blocks of N source letters\n- There are KN possible N letter blocks (N-tuples)\n-\nLet Y be the \"new\" source alphabet of N letter blocks\n-\nIf each of the letters is independently generated,\nH(Y) = H(x1..xN) = N*H(X)\n- Encode Y using the same procedure as before to obtain,\nH(Y) !n y < H(Y) + 1\n\" N * H(X)!n y< N* H(X) + 1\n\" H(X) ! n < H(X) + 1/ N\nWhere the last inequality is obtained because each letter of Y corresponds to\nN letters of the original source\n- We can now take the block length (N) to be arbitrarily large and\nget arbitrarily close to H(X)\nEytan Modiano\nSlide 9\n\nHuffman codes\n- Huffman codes are special prefix codes that can be shown to be optimal\n(minimize average codeword length)\nH(X)\nHuffman\nShannon/\nH(X)+1\ncodes\nFano codes\nHuffman Algorithm:\n1) Arrange source letters in decreasing order of probability (p1 ≥ p2 .. ≥ pk)\n2) Assign '0' to the last digit of Xk and '1' to the last digit of Xk-1\n3) Combine pk and pk-1 to form a new set of probabilities\n{p1, p2 ,.., pk-2,(pk-1+ pk)}\n4) If left with just one letter then done, otherwise go to step 1 and repeat\nEytan Modiano\nSlide 10\n\nHuffman code example\nA = {a1,a2,a3, a4, a5} and p = {0.3, 0.25,0.25, 0.1, 0.1}\na1\n0.3\n0.3\n0.3\n0.55 1\n0.25\n0.25\n0.25\n+\na2\n1.0\n0.25\n0.25\n0.2\n0.45\n+\n+\n0.45\n+\na3\na4\n0.1\n0.1\na5\nn = 2 ! 0.8 + 3 ! 0.2 = 2.2 bits /symbol\nH(X) =\npi\n\"\nlog( 1\npi\n) = 2.1855\nShannon # Fanocodes $ ni = log( 1\npi\n)\n%\n&\n&\n&\n'\n(\n(\n(\nn1 = n2 = n3 = 2, n4 = n5 = 4\n$ n = 2.4 bits /symbol <H(X) +1\nLetter Codeword\na1\na2\na3\na4\na5\nEytan Modiano\nSlide 11\n\nLempel-Ziv Source coding\n- Source statistics are often not known\n- Most sources are not independent\n- Letters of alphabet are highly correlated\nE.g., E often follows I, H often follows G, etc.\n- One can code \"blocks\" of letters, but that would require a very\nlarge and complex code\n- Lempel-Ziv Algorithm\n- \"Universal code\" - works without knowledge of source statistics\n- Parse input file into unique phrases\n- Encode phrases using fixed length codewords\nVariable to fixed length encoding\nEytan Modiano\nSlide 12\n\nLempel-Ziv Algorithm\n- Parse input file into phrases that have not yet appeared\n- Input phrases into a dictionary\n- Number their location\n- Notice that each new phrase must be an older phrase followed by\na '0' or a '1'\n- Can encode the new phrase using the dictionary location of the\nprevious phrase followed by the '0' or '1'\nEytan Modiano\nSlide 13\n\nLempel-Ziv Example\nInput: 0010110111000101011110\nParsed phrases: 0, 01, 011, 0111, 00, 010, 1, 01111\nDictionary\nLoc\nbinary rep\nphrase\nCodeword\ncomment\nnull\n0000 0\nloc-0 + '0'\n0001 1\nloc-1 + '1'\n0010 1\nloc-2 + '1'\n0011 1\nloc-3 + '1'\n0001 0\nloc-1 +'0'\n0010 0\nloc-2 + '0'\n0000 1\nloc-0 + '1'\n0100 1\nloc-4 + '1'\nSent sequence: 00000 00011 00101 00111 00010 00100 00001 01001\nEytan Modiano\nSlide 14\n\nNotes about Lempel-Ziv\n- Decoder can uniquely decode the sent sequence\n- Algorithm clearly inefficient for short sequences (input data)\n- Code rate approaches the source entropy for large sequences\n- Dictionary size must be chosen in advance so that the length of\nthe codeword can be established\n- Lempel-Ziv is widely used for encoding binary/text files\n- Compress/uncompress under unix\n- Similar compression software for PCs and MACs\nEytan Modiano\nSlide 15"
    }
  ]
}