{
  "course_name": "Principles of Computer System Design: An Introduction",
  "course_description": "Principles of Computer System Design: An Introduction is published in two parts. Part I, containing chapters 1-6, is a traditional printed textbook published by Morgan Kaufman, an imprint of Elsevier. Part II, containing chapters 7-11, is available here as an open educational resource.\nThis textbook, an introduction to the principles and abstractions used in the design of computer systems, is an outgrowth of notes written for 6.033 Computer System Engineering over a period of 40-plus years. Individual chapters are also used in other EECS subjects. There is also a web site for the current 6.033 class with a lecture schedule that includes daily assignments, lecture notes, and lecture slides. The 6.033 class Web site also contains a thirteen-year archive of class assignments, design projects, and quizzes.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Computer Design and Engineering",
    "Systems Engineering",
    "Systems Design",
    "Engineering",
    "Computer Science",
    "Computer Design and Engineering",
    "Systems Engineering",
    "Systems Design"
  ],
  "syllabus_content": "",
  "files": [
    {
      "category": "Resource",
      "title": "atomicity_figures.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/42af24fac8bce4c9b8ca093a5d2f7775_atomicity_figures.pdf",
      "content": "Principles of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure TRANSFER (debit_account, credit_account, amount)\nGET (dbdata, debit_account)\ndbdata ← dbdata - amount\nPUT (dbdata, debit_account)\nGET (crdata, credit_account)\ncrdata← crdata + amount\nPUT (crdata, credit_account)\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nHuman user\ngenerating\nrequests\nCalendar\nProgram\nhardware\nJava\nInterpreter\nInterface\nCalendar manager\nlayer interface\nJava language\nlayer interface\nMachine language\nlayer interface\nTypical instruction\nacross this interface\nAdd new event on\nFebruary 27\nnextch = instring[j];\nadd R1,R2\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nAll-or-nothing atomicity\nA sequence of steps is an all-or-nothing action if, from the point of view of its\ninvoker, the sequence always either\ncompletes,\nor\naborts in such a way that it appears that the sequence had never been\nundertaken in the first place. That is, it backs out.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nBefore-or-after atomicity\nConcurrent actions have the before-or-after property if their effect from the point of\nview of their invokers is the same as if the actions occurred either completely before\nor completely after one another.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure TRANSFER (reference debit_account, reference credit_account, amount)\ndebit_account ← debit_account - amount\ncredit_account ← credit_account + amount\nTRANSFER (A, B, $10)\nTRANSFER (B, C, $25)\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nThread #2 (debit_account is B)\nThread #1 (credit_account is B)\n1-1\nREAD B\n2-1\nREAD B\n.\n.\n.\n.\n.\n.\n1-2\nWRITE B\n2-2\nWRITE B\ncorrect result:\ntime\ncase 1: Thread #1:\nThread #2:\nREAD B\nValue of B: 100\nWRITE B\nREAD B\nWRITE B\ncase 2: Thread #1:\nValue of B: 100\nThread #2: READ B\nWRITE B\nREAD B\nWRITE B\nwrong results:\nThread #1:\nThread #2:\nREAD B\nValue of B: 100\ncase 3:\nREAD B\nWRITE B\nWRITE B\ncase 4: Thread #1:\nThread #2:\nREAD B\nValue of B: 100\nREAD B\nWRITE B\nWRITE B\ncase 5: Thread #1:\nThread #2:\nValue of B: 100\nREAD B\nREAD B\nWRITE B\nWRITE B\ncase 6: Thread #1:\nThread #2:\nValue of B: 100\nREAD B\nREAD B\nWRITE B\nWRITE B\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nold system\nstate\nnew system\nstate\naction\naction #3\naction #1\nold system\nstate\nnew system\nstate\naction #2\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nold system\nstate\nfinal\nstate\nC\nfinal\nstate\nB\nfinal\nstate\nA\nAA\n#1\nAA #2\nAA#3\nAA#3\nAA\n#2\nAA #2\nAA#3\nAA#1\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure AUDIT()\nsum ← 0\nfor each W ← in bank.accounts\nsum ← sum + W.balance\nif (sum = 0) call for investigation\n// TRANSFER, in thread 1\ndebit_account ← debit_account - amount\n...\ncredit_account ← credit_account + amount\n// in thread 2\n...\nAUDIT()\n...\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nAtomicity\nAn action is atomic if there is no way for a higher layer to discover the internal\nstructure of its implementation.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure ALMOST_ALL_OR_NOTHING_PUT (data, all_or_nothing_sector)\nCAREFUL_PUT (data, all_or_nothing_sector.S1)\nCAREFUL_PUT (data, all_or_nothing_sector.S2)\n// Commit point.\nCAREFUL_PUT (data, all_or_nothing_sector.S3)\nprocedure ALL_OR_NOTHING_GET (reference data, all_or_nothing_sector)\nCAREFUL_GET (data1, all_or_nothing_sector.S1)\nCAREFUL_GET (data2, all_or_nothing_sector.S2)\nCAREFUL_GET (data3, all_or_nothing_sector.S3)\nif data1 = data2 then data ← data1\n// Return new value.\nelse data ← data3\n// Return old value.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure ALL_OR_NOTHING_PUT (data, all_or_nothing_sector)\nCHECK_AND_REPAIR (all_or_nothing_sector)\nALMOST_ALL_OR_NOTHING_PUT (data, all_or_nothing_sector)\nprocedure CHECK_AND_REPAIR (all_or_nothing_sector)// Ensure copies match.\nCAREFUL_GET (data1, all_or_nothing_sector.S1)\nCAREFUL_GET (data2, all_or_nothing_sector.S2)\nCAREFUL_GET (data3, all_or_nothing_sector.S3)\nif (data1 = data2) and (data2 = data3) return\n// State 1 or 7, no repair\nif (data1 = data2)\nCAREFUL_PUT (data1, all_or_nothing_sector.S3) return // State 5 or 6.\nif (data2 = data3)\nCAREFUL_PUT (data2, all_or_nothing_sector.S1) return // State 2 or 3.\nCAREFUL_PUT (data1, all_or_nothing_sector.S2)\n// State 4, go to state 5\nCAREFUL_PUT (data1, all_or_nothing_sector.S3)\n// State 5, go to state 7\ndata state:\nsector S1\nold\nbad\nnew\nnew\nnew\nnew\nnew\nsector S2\nold\nold\nold\nbad\nnew\nnew\nnew\nsector S3\nold\nold\nold\nold\nold\nbad\nnew\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\n___\n___\n___\n___\n___\n___\n___\n___\n___\nbegin all-or-nothing action\n___ }\narbitrary sequence of\n___\nlower-layer actions\nend all-or-nothing action\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\n___\n___\n___\n___\n___\n___\n}\nfirst step of all-or-nothing action\nPre-commit discipline: can back out,\nleaving no trace\nCommit point\n___\n___\n___\n___\n} Post-commit discipline: completion is inevitable\nlast step of all-or-nothing action\n___\n___\n___\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nThe golden rule of atomicity\nNever modify the only copy!\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nVariable A:\nHistory of earlier versions\nTentative\nnext version\nCurrent version\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nAll-or-nothing Journal Storage System\nCell Storage\nSystem\n- catalogs\n- versions\n- outcome\nrecords\nJournal\nREAD\nWRITE\nALLOCATE\nDEALLOCATE\nStorage\nManager\nNEW_ACTION\nREAD_CURRENT_VALUE\nWRITE_NEW_VALUE\nCOMMIT\nABORT\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nall-or-nothing\naction\ncommits\nnon-existent\ncommitted\ndiscarded\naborted\npending\nnew all-or-nothing\naction is\ncreated\nall-or-nothing\naction\noutcome record\naborts\nstate no longer\nof any interest\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure NEW_ACTION ()\nid ← NEW_OUTCOME_RECORD ()\nid.outcome_record.state ← PENDING\nreturn id\nprocedure COMMIT (reference id)\nid.outcome_record.state ← COMMITTED\nprocedure ABORT (reference id)\nid.outcome_record.state ← ABORTED\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nObject A\npending\n1794:\naborted\n1423:\n1101:\ncommitted\nall-or-nothing\naction id:\nvalue:\noutcome\nrecords\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure READ_CURRENT_VALUE (data_id, caller_id)\nstarting at end of data_id repeat until beginning\nv ← previous version of data_id\n// Get next older version\na ← v.action_id // Identify the action a that created it\ns ← a.outcome_record.state\n// Check action a's outcome record\nif s = COMMITTED then\nreturn v.value\nelse skip v\n// Continue backward search\nsignal (\"Tried to read an uninitialized variable!\")\nprocedure WRITE_NEW_VALUE (reference data_id, new_value, caller_id)\nif caller_id.outcome_record.state = PENDING\nappend new version v to data_id\nv.value ← new_value\nv.action_id ← caller_id\nelse signal (\"Tried to write outside of an all-or-nothing action!\")\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure TRANSFER (reference debit_account, reference credit_account, amount)\nmy_id ← NEW_ACTION ()\nxvalue ← READ_CURRENT_VALUE (debit_account, my_id)\nxvalue ← xvalue - amount\nWRITE_NEW_VALUE (debit_account, xvalue, my_id)\nyvalue ← READ_CURRENT_VALUE (credit_account, my_id)\nyvalue ← yvalue + amount\nWRITE_NEW_VALUE (credit_account, yvalue, my_id)\nif xvalue > 0 then\nCOMMIT (my_id)\nelse\nABORT (my_id)\nsignal(\"Negative transfers are not allowed.\")\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nJournal Storage\nLog\nWRITE_NEW_VALUE\ninstall\ncurrent\nend of log\nCell\nStorage\nlog\nREAD_CURRENT_VALUE\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nVolatile storage\nNon-volatile storage\nIn-memory database:\nOrdinary database:\nHigh-performance\ndatabase:\nlog\nlog\nApplication\nprogram\nApplication\nprogram\nApplication\nprogram\ncell\nstorage\ncell\nstorage\nlog\ncell\nstorage\ncache\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nWrite-ahead-log protocol\nLog the update before installing it.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure TRANSFER (debit_account, credit_account, amount)\nmy_id ← LOG (BEGIN_TRANSACTION)\ndbvalue.old ← GET (debit_account)\ndbvalue.new ← dbvalue.old - amount\ncrvalue.old ← GET (credit_account, my_id)\ncrvalue.new ← crvalue.old + amount\nLOG (CHANGE, my_id,\n\"PUT (debit_account, dbvalue.new)\",\n\"PUT (debit_account, dbvalue.old)\" )\nLOG ( CHANGE, my_id,\n\"PUT (credit_account, crvalue.new)\"\n\"PUT (credit_account, crvalue.old)\")\nPUT (debit_account, dbvalue.new)\nPUT (credit_account, crvalue.new)\nif dbvalue.new > 0 then\n//redo action\n//undo action\n//redo action\n//undo action\n// install\n// install\nLOG ( OUTCOME, COMMIT, my_id)\nelse\nLOG (OUTCOME, ABORT, my_id)\nsignal(\"Action not allowed. Would make debit account negative.\")\nLOG (END_TRANSACTION, my_id)\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\n...\nCHANGE\ntype:\ntype: OUTCOME\ntype:\nCHANGE\naction_id: 9979\naction_id: 9974\naction_id: 9979\nredo_action:\nstatus: COMMITTED\nredo_action:\nPUT(debit_account, $90)\nPUT(credit_account, $40)\nundo_action:\nundo_action:\nPUT(debit_account, $120)\nPUT(credit_account, $10)\nolder log records\nnewer log records\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure ABORT (action_id)\nstarting at end of log repeat until beginning\nlog_record ← previous record of log\nif log_record.id = action_id then\nif (log_record.type = OUTCOME)\nthen signal (\"Can't abort an already completed action.\")\nif (log_record.type = CHANGE)\nthen perform undo_action of log_record\nif (log_record.type = BEGIN)\nthen break repeat\nLOG (action_id, OUTCOME, ABORTED)\n// Block future undos.\nLOG (action_id, END)\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure RECOVER ()// Recovery procedure for a volatile, in-memory database.\nwinners ← NULL\nstarting at end of log repeat until beginning\nlog_record ← previous record of log\nif (log_record.type = OUTCOME)\nthen winners ← winners + log_record\n// Set addition.\nstarting at beginning of log repeat until end\nlog_record ← next record of log\nif (log_record.type= CHANGE)\nand (outcome_record ← find (log_record.action_id) in winners)\nand (outcome_record.status = COMMITTED) then\nperform log_record.redo_action\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure RECOVER ()// Recovery procedure for non-volatile cell memory\ncompleteds ← NULL\nlosers ← NULL\nstarting at end of log repeat until beginning\nlog_record ← previous record of log\nif (log_record.type = END)\nthen completeds ← completeds + log_record\n// Set addition.\nif (log_record.action_id is not in completeds) then\nlosers ← losers + log_record\n// Add if not already in set.\nif (log_record.type = CHANGE) then\nperform log_record.undo_action\nstarting at beginning of log repeat until end\nlog_record ← next record of log\nif (log_record.type = CHANGE)\nand (log_record.action_id.status = COMMITTED) then\nperform log_record.redo_action\nfor each log_record in losers do\nlog (log_record.action_id, END)\n// Show action completed.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure RECOVER ()\n// Recovery procedure for rollback recovery.\ncompleteds ← NULL\nlosers ← NULL\nstarting at end of log repeat until beginning\n// Perform undo scan.\nlog_record ← previous record of log\nif (log_record.type = OUTCOME)\nthen completeds ← completeds + log_record\n// Set addition.\nif (log_record.action_id is not in completeds) then\nlosers ← losers + log_record\n// New loser.\nif (log_record.type = CHANGE) then\nperform log_record.undo_action\nfor each log_record in losers do\nlog (log_record.action_id, OUTCOME, ABORT)\n// Block future undos.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure BEGIN_TRANSACTION ()\nid ← NEW_OUTCOME_RECORD (PENDING)\n// Create, initialize, assign id.\nprevious_id ← id - 1\nwait until previous_id.outcome_record.state = PENDING\nreturn id\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nObject\nvalue of object at end of transaction\nA\nB\nC\nD\noutcome\nrecord\nstate\nCommitted Committed Committed Aborted Committed Pending\ntransaction 1: initialize all accounts to 0\n2: transfer 10 from B to A\n3: transfer 4 from C to B\n4: transfer 2 from D to A (aborts)\n5: transfer 6 from B to C\n6: transfer 10 from A to B\n-12\n+2\n-2\n-6\n-4\n+12\n-2\n+10\n-10\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\n+12\n-12\n-2\n+2\n-6\n-4\n+10\n-10\n-2\nObject\nValue of object at end of transaction\nA\n+10\n+12\nB\n-6\n-2\nC\n-4\n+2\n+2\nD\n-2\n-2\n-2\nOUTCOME\nrecord\nCommitted Committed Committed Aborted Committed Pending\nPending\nstate\nUnchanged value\nChanged value\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure READ_CURRENT_VALUE (data_id, this_transaction_id)\nstarting at end of data_id repeat until beginning\nv ← previous version of data_id\nlast_modifier ← v.action_id\nif last_modifier ≥ this_transaction_id then skip v\n// Keep searching\nwait until (last_modifier.outcome_record.state = PENDING)\nif (last_modifier.outcome_record.state = COMMITTED)\nthen return v.state\nelse skip v\n// Resume search\nsignal (\"Tried to read an uninitialized variable\")\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure NEW_VERSION (reference data_id, this_transaction_id)\nif this_transaction_id.outcome_record.mark_state = MARKED then\nsignal (\"Tried to create new version after announcing mark point!\")\nappend new version v to data_id\nv.value ← NULL\nv.action_id ← transaction_id\nprocedure WRITE_VALUE (reference data_id, new_value, this_transaction_id)\nstarting at end of data_id repeat until beginning\nv ← previous version of data_id\nif v.action_id = this_transaction_id\nv.value ← new_value\nreturn\nsignal (\"Tried to write without creating new version!\"))\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure BEGIN_TRANSACTION ()\nid ← NEW_OUTCOME_RECORD (PENDING)\nprevious_id ← id - 1\nwait until (previous_id.outcome_record.mark_state = MARKED)\nor (previous_id.outcome_record.state = PENDING)\nreturn id\nprocedure NEW_OUTCOME_RECORD (starting_state)\nACQUIRE (outcome_record_lock)\n// Make this a before-or-after action.\nid ← TICKET (outcome_record_sequencer)\nallocate id.outcome_record\nid.outcome_record.state ← starting_state\nid.outcome_record.mark_state ← NULL\nRELEASE (outcome_record_lock)\nreturn id\nprocedure MARK_POINT_ANNOUNCE (reference this_transaction_id)\nthis_transaction_id.outcome_record.mark_state ← MARKED\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure TRANSFER (reference debit_account, reference credit_account,\namount)\nmy_id ← BEGIN_TRANSACTION ()\nNEW_VERSION (debit_account, my_id)\nNEW_VERSION (credit_account, my_id)\nMARK_POINT_ANNOUNCE (my_id);\nxvalue ← READ_CURRENT_VALUE (debit_account, my_id)\nxvalue ← xvalue - amount\nWRITE_VALUE (debit_account, xvalue, my_id)\nyvalue ← READ_CURRENT_VALUE (credit_account, my_id)\nyvalue ← yvalue + amount\nWRITE_VALUE (credit_account, yvalue, my_id)\nif xvalue > 0 then\nCOMMIT (my_id)\nelse\nABORT (my_id)\nsignal(\"Negative transfers are not allowed.\")\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nValue of object at end of transaction\nA\nB\nC\nD\n+10\n-6\n-12\n-2\nHWM=2\nHWM=6\nHWM=5\nHWM=2\nHWM=6\nHWM=7\n-10\nHWM=3\n-4\nHWM=3\nHWM=5\n-2\nHWM=4\nCommitted Committed\nCommitted\nOutcome state record\nConflict: Must abort!\n+12\n+2\nHWM=7\n-4\n+2\nAborted Committed\nPending Pending\nHWM=\nHigh-water mark\nConflict\nChanged value\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure READ_CURRENT_VALUE (reference data_id, value, caller_id)\nstarting at end of data_id repeat until beginning\nv ← previous version of data_id\nif v.action_id ≥ caller_id then skip v\nexamine v.action_id.outcome_record\nif PENDING then\nWAIT for v.action_id to COMMIT or ABORT\nif COMMITTED then\nv.high_water_mark ← max(v.high_water_mark, caller_id)\nreturn v.value\nelse skip v\n// Continue backward search\nsignal (\"Tried to read an uninitialized variable!\")\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\nprocedure NEW_VERSION (reference data_id, caller_id)\nif (caller_id < data_id.high_water_mark)\n// Conflict with later reader.\nor (caller_id < (LATEST_VERSION[data_id].action_id))\n// Blind write conflict.\nthen ABORT this transaction and terminate this thread\nadd new version v at end of data_id\nv.value ← 0\nv.action_id ← caller_id\nprocedure WRITE_VALUE (reference data_id, new_value, caller_id)\nlocate version v of data_id.history such that v.action_id = caller_id\n(if not found, signal (\"Tried to write without creating new version!\"))\nv.value ← new_value\n\ninstruction architectural physical\nregister\nregister\nn\nR5\nn + 1\nR4\nn + 2\nR5\nthree entries in the reorder buffer\nphysical register file\nwith 128 registers\nn\nR5 ← R4 × R2\n// Write a result in register five.\nn + 1 R4 ← R5 + R1\n// Use result in register five.\nn + 2 R5 ← READ (117492)\n// Write content of a memory cell in register five.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure PAY_INTEREST (reference account)\nif account.balance > 0 then\ninterest = account.balance * 0.05\nTRANSFER (bank, account, interest)\nelse\ninterest = account.balance * 0.15\nTRANSFER (account, bank, interest)\nprocedure MONTH_END_INTEREST:()\nfor A ← each customer_account do\nPAY_INTEREST (A)\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nMONTH_END_INTEREST\noutcome:\nsuperior:\nPENDING\nnone\noutcome:\nsuperior:\nPAY_INTEREST2 (2nd invocation)\nPENDING\nMONTH_END_INTEREST\nOK for TRANSFER2\nto read?\nPAY_INTEREST1 (1st invocation)\noutcome:\nsuperior:\nCOMMITTED\nMONTH_END_INTEREST\nTRANSFER2\noutcome:\nsuperior:\nPENDING\nPAY_INTEREST2\nTRANSFER1\noutcome:\nsuperior:\nCOMMITTED\nPAY_INTEREST1\ncreator: TRANSFER1\nnewest version of\naccount bank\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nFrom: Alice\nTo: Bob\nRe: my transaction 91\nif (Charles does Y and Dawn does Z) then do X, please.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nFrom:Alice\nTo: Bob\nRe: my transaction 271\nPlease do X as part of my transaction.\nFrom:Bob\nTo: Alice\nRe: your transaction 271\nMy part X is ready to commit.\nTwo-phase-commit message #1:\nFrom:Alice\nTo: Bob\nRe: my transaction 271\nPREPARE to commit X.\nTwo-phase-commit message #2:\nFrom:Bob\nTo:Alice\nRe: your transaction 271\nI am PREPARED to commit my part. Have you decided to commit yet?\nTwo-phase-commit message #3\nFrom:Alice\nTo:Bob\nRe: my transaction 271\nMy transaction committed. Thanks for your help.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nCoordinator\nWorker\nWorker\nWorker\nAlice\nBob\nCharles\nDawn\nPREPARE X\nPREPARE Y\nPREPARE Z\nBob is PREPARED\nCharles is PREPARED\nDawn is PREPARED\nCOMMIT\nCOMMIT\nCOMMIT\nTime\nlog BEGIN\nlog\nlog BEGIN\nlog PREPARED\nlog COMMITTED\nCOMMITTED\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nFrom:Julius Caesar\nTo:Titus Labienus\nDate:11 January\nI propose to cross the Rubicon and attack at dawn tomorrow. OK?\nFrom:Titus Labienus\nTo:Julius Caesar;\nDate:11 January\nAgreed, dawn on the 12th.\nor\nFrom:Titus Labienus\nTo: Julius Caesar\nDate:11 January\nNo. I am awaiting\nreinforcements from Gaul.\nFrom:Julius Caesar\nTo:Titus Labienus\nDate:11 January\nThe die is cast.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure ALL_OR_NOTHING_DURABLE_GET (reference data, atomic_sector)\nds ← CAREFUL_GET (data, atomic_sector.D0)\nif ds = BAD then\nds ← CAREFUL_GET (data, atomic_sector.D1)\nreturn ds\nprocedure ALL_OR_NOTHING_DURABLE_PUT (new_data, atomic_sector)\nSALVAGE(atomic_sector)\nds ← CAREFUL_PUT (new_data, atomic_sector.D0)\nds ← CAREFUL_PUT (new_data, atomic_sector.D1)\nreturn ds\nprocedure SALVAGE(atomic_sector)\n//Run this program every Td seconds.\nds0 ← CAREFUL_GET (data0, atomic_sector.D0)\nds1 ← CAREFUL_GET (data1, atomic_sector.D1)\nif ds0 = BAD then\nCAREFUL_PUT (data1, atomic_sector.D0)\nelse if ds1 = BAD then\nCAREFUL_PUT (data0, atomic_sector.D1)\nif data0 = data1 then\nCAREFUL_PUT (data0, atomic_sector.D1)\nD0:\ndata0\nD1 :\ndata1\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009"
    },
    {
      "category": "Resource",
      "title": "consistency_figures.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/39db27e4e4c819f2039491e13952f071_consistency_figures.pdf",
      "content": "Processor A\nCache\nProcessor B\nCache\nProcessor C\nCache\nbus\nSecondary\nMemory\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nThe durability mantra\nMultiple copies, widely separated and independently administered...\nMultiple copies, widely separated and independently administered...\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nupdate\nrequest #1\nSite 1\nnew state\nSite 2\nnew state\nSite 3\nupdate\nrequest #2\nnew state\nprior state\nState\nmachine\nprior state\nState\nmachine\nprior state\nState\nmachine\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure RECONCILE (reference left, reference right,\nreference last_reconcile_time)\nquiesce all activity on left and right // Shut down all file-using applications\nALL_OR_NOTHING_GET (last_reconcile_time, reconcile_time_sector)\nleft_list ← enumerate(left)\nright_list ← enumerate(right)\ncommon_list ← intersect(left_list, right_list)\nleft_only_list ← remove members of common_list from left_list\nright_only_list ← remove members of common_list from right_list\nconflict_list ← nil\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nfor each named_file in common_list do // Reconcile files found both sides\nleft_new ← (MODIFICATION_TIME (left.named_file) > last_reconcile_time)\nright_new ← (MODIFICATION_TIME (right.named_file) > last_reconcile_time)\nif left_new and right_new then\nadd named_file to conflict_list\nelse if left_new then\ncopy named_file from left to right\nelse if right_new then\ncopy named_file from right to left\nelse if MODIFICATION_TIME (left.named_file) =\n(MODIFICATION_TIME (right.named_file)\nthen TERMINATE (\"Something awful has happened.\")\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nfor each named_file in left_only_list do // Reconcile files found one side\nif MODIFICATION_TIME (left.named_file) > last_reconcile_time then\ncopy named_file from left to right\nelse\ndelete left.named_file\nfor each named_file in right_only_list do\nif MODIFICATION_TIME (right.named_file) > last_reconcile_time then\ncopy named_file from right to left\nelse\ndelete right.named_file\nfor each named_file in conflict_list do\n// Handle conflicts\nMANUALLY_RESOLVE (right.named_file, left.named_file)\nlast_reconcile_time ← NOW ()\nALL_OR_NOTHING_PUT (last_reconcile_time, reconcile_time_sector)\nAllow activity to resume on left and right\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nsubjective\ncomplexity of\ncoordination\nscheme\nhigh\nlow\nLimit of\ncorrectness\nfor this much\ncomplexity\nlimit of\ncorrectness despite\nunlimited complexity\ncorrect\ncoordination\nmiscoordination and\nwrong answers\nnone\nunconstrained\nAmount of concurrent activity permitted\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009"
    },
    {
      "category": "Resource",
      "title": "errata_part_i.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/61432bbe14fec6d1c1ab12cf9fc4c1ad_errata_part_i.pdf",
      "content": "CHAPTER\n\nErrata for Part I\nAs of March 23, 2017\nErrata added since March 25, 2014: page 283.\nErrata added since March 3, 2013: pp 118, 151, 152, 245, 341, and 353.\nErrata added since December 28, 2011: pp 105, 278, 279, 434, 456, 467, and Solutions 10.3.\nPage xv, Sidebar 1.2\nPage number should be 7, not 6.\nPage 29, caption of figure 1.3:\nThe first sentence of the caption should read \"How analog gain and non-linearity\nrestore levels and thus create a digital component\".\nPage 71, 3rd example under \"Explicit context reference\":\nMacintosh hd:projects:CSE 491\nshould be\nMacintosh HD:projects:CSE 496\nPage 76, 3rd line from bottom:\n\"programs are written\" should be \"procedures are written\".\nPage 86, 3rd paragraph, sixth line:\n\"exasperation at the\" should be \"exasperation about the\".\nPage 95, paragraph beginning \"The version 6...\"\n\"67,329\" should be \"67,328\".\nERRATA-1\nSaltzer & Kaashoek Ch. errata, p. 1\nMarch 23, 2017 10:50 am\n\nERRATA-2\nSaltzer & Kaashoek, Principles of Computer System Design\nPage 98, procedure PATH_TO_INODE_NUMBER should read as follows:\nprocedure PATH_TO_INODE_NUMBER (character string path, integer dir) returns integer\nif PLAIN_NAME (path) then return NAME_TO_INODE_NUMBER (path, dir)\nelse\ndir\n\n← LOOKUP (FIRST (path), dir)\npath ← REST (path)\nif path = \"\" then return dir\nelse return PATH_TO_INODE_NUMBER (path, dir)\nPage 99, top-most paragraph:\nAt the end of the sentence beginning \"The function FIRST...\" add the following words:\n...with the leading separators removed. (Multiple consecutive \"/\" are usually\ninterpreted as a single \"/\"; for example, \"projects////paper\" is the same name as\n\"projects/paper\".)\nIn the next sentence (which begins \"Thus, for example,...\") both instances of the\nprocedure name PATH_TO_NAME should be PATH_TO_INODE_NUMBER.\nThe declaration of procedure CHDIR should read:\nprocedure CHDIR (character string path)\nPage 101, first sentence of the first complete paragraph:\n\"the file system reserves\" should be \"the UNIX file system reserves\".\nPage 102, procedure GENERALPATH_TO_INODE_NUMBER:\nline 2 should read\nif path[0] = \"/\" then return PATH_TO_INODE_NUMBER (STRIP (path, '/'), 1)\nand insert the following paragraph after that procedure:\nIf the pathname starts with a separator, GENERALPATH_TO_INODE_NUMBER uses the\ninode number for the root directory (1), otherwise it uses the inode number of the\ncurrent working directory. In the first case, it strips off the leading separators,\nbecause it has processed the leading \"/\" that indicates the root directory.\nPage 105, pseudocode lines 5 and 6 should read: (errata line 6 added 3/2/2013)\nif i.type = SYMLINK then\ni <- PATHNAME_TO_INODE (COERCE_TO_STRING (i.blocknumbers))\nPage 109, pseudocode line 6 should read:\ninode.atime ← NOW ()\nSaltzer & Kaashoek Ch. errata, p. 2\nMarch 23, 2017 10:50 am\n\nErrata for Part I\nERRATA-3\nand pseudocode lines 8 and 9 should read:\nfor i from 0 to m - 1 do\nb ← INODE_NUMBER_TO_BLOCK (i, file_table[file_index].inode_number)\nPage 109, pseudocode line 10 should read:\nCOPY (b, buf + i, MINIMUM(m - i, BLOCKSIZE))\nAlso, in the paragraph following the pseudocode, the next-to-last sentence should\nbegin \"Lines 8 through 11...\" and the last sentence should begin \"Line 12 updates...\"\nPage 110, first line:\n\"maintain\" should be \"maintains\"\nPage 118, third complete paragraph, line 5: (errata added 3/25/2014)\n\"...numbered 2 in Figure 3.2\" should read \"...numbered 2 in Figure 3.4\"\nPage 151, Figure 4.2: (errata added 3/25/2014)\nLines 148-164 should read:\n148: SUB 8, SP\n// pop argument and return address off stack\n152: SUB 4, SP\n// move stack pointer to saved R2\n156: MOV SP, R2\n// restore content of R2\n160: SUB 4, SP\n// move stack pointer to saved R1\n164: MOV SP, R1\n// restore content of R1\nPage 152, step 4 (errata added 3/25/2014)\nIn the sketch of the stack, the number 144 should be 148\nPage 174, bullet labeled \"Atomicity\":\n\"Section 4.1.6\" should be \"Section 4.1.5\"\nPage 219, Caption of Figure 5.6:\n\"Section 5.25\" should be \"Section 5.2.5\"\nPage 245, Section 5.4.2, last line of first paragraph:(errata added 3/25/2014)\n\"might need 272 bytes\" should say \"might need 264 x 8 = 267 bytes\"\nSaltzer & Kaashoek Ch. errata, p. 3\nMarch 23, 2017 10:50 am\n\nERRATA-4\nSaltzer & Kaashoek, Principles of Computer System Design\nPage 278, Figure 5.29: (errata added 3/2/2013)\nLine 6 should read\nAWAIT (p.out, READ (p.in) - N) // wait till there is space in the buffer\nand line 10 should read\nAWAIT (p.in, READ (p.out))\n// wait till something in the buffer\nPage 278, eleventh line from the bottom: (errata added 3/2/2013)\nThe eventcount variable \"sent\" should be \" p.in\" (two instances)\nPage 279, Figure 5.30: (errata added 3/2/2013)\nLine 8 should read\nAWAIT (p.in, t - 1)\n// wait till previous slots are filled\nPage 282, sixth line from the bottom:\nThe second word, \"flip-flip\", should be \"flip-flop\"\nPage 283, last paragraph, second line:(errata added 3/23/2017)\n\"is unable make\" should be \"is unable to make\"\nPage 291, Caption of figure 5.34:\n\"guest operating with\" should be \"guest operating system with\"\nPage 293, Section 5.8.3, first paragraph, line 5:\n\"operating system by\" should be \"operating systems by\"\nPage293, Section 5.8.3, second paragraph, lines 4 and 5\ndelete \"and virtual machine\"\n\"translate\" should be \"translates\"\n\"virtual machine addresses\" should be \"machine virtual addresses\"\nPage 317, pseudocode line 2:\nThe comment on line 2 should say \"writing\", not \"reading\"\n2 out ← OPEN ('out' WRITE)\n// open \"out\" for writing\nPage 339, Table 6.5:\nColumn 4 contains an error that propagates to columns 5 and 6. The table should read:\nSaltzer & Kaashoek Ch. errata, p. 4\nMarch 23, 2017 10:50 am\n\nErrata for Part I\nERRATA-5\nTable 6.5. The LRU page-removal policy with a three-page primary device.\ntime\n\nreference\nstring\nprimary\n-\ndevice\n-\n-\nPages\ncontents\n-\n-\n-\nbrought\nin\nremove\n-\n-\n-\n-\n-\nbring in\n-\n-\n\nPage 341, second paragraph, line 6: (errata added 3/25/2014)\n\"at times 8, 9, 11, and 12\" should say \"at times 8, 9, and 12\"\nPage 353, Table at bottom of page, column 7 header: (errata added 3/25/2014)\n\"Wait Time\" should be \"Waiting Time\"\nPage 431, problem set 3, figure 1:\nLine 4 of FSD_READ and line 4 of FSD_CLOSE should both begin\nif host = \"\" then...\nPage 434, problem set 4, question 4.1:(errata added 3/2/2013)\nThe RELEASE that Alyssa added after line 7 should be indented to match the ACQUIRE that\nAlyssa added after line 2.\nPage 456, problem set 10, procedure at top of page: (errata added 3/2/2013)\nlines 33-36 should each be indented one step further.\nPage 461, problem set 11, procedure \"Web server using events\":\nThere should be another line at the end of the procedure that reads\ndoneCnt ← doneCnt + 1\n//D\nand in the procedure \"Network manager using events\"(at the bottom of the page) the\ntwo lines of that procedure should end with the comments \"//E\" and \"//F\", respectively.\nSaltzer & Kaashoek Ch. errata, p. 5\nMarch 23, 2017 10:50 am\n\nERRATA-6\nSaltzer & Kaashoek, Principles of Computer System Design\nPage 463, problem set 12:\nIn procedure INTERRUPT, the last line should read\nUP (port.n)\nIn procedure RECEIVE_MESSAGE, the second and third lines should read\nDOWN (port.n)\nm ← port_buffer[port.out modulo NMSG]\nPage 467, problem set 15: (errata added 3/2/2013)\nIn the paragraph beginning \"ISPRESENT looks up...\", \"it returns 1.\" should read \"it\nreturns -1.\"\nSolutions, problem 10.3: (errata added 3/2/2013)\nFor \"A\" read \"B\".\nSaltzer & Kaashoek Ch. errata, p. 6\nMarch 23, 2017 10:50 am"
    },
    {
      "category": "Resource",
      "title": "errata_part_ii.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/05dcf398c5255c3e0a9be902d3d6a396_errata_part_ii.pdf",
      "content": "CHAPTER\n\nErrata for Part II\nAs of February 25, 2016\nErrata added since June 14, 2014: pp 7-17\nErrata added since May 4, 2011: pp 9-18 and 9-44\nErrata added since April 3, 2013: p 11-122\nChapter 7, Page 7-17, Figure 7.8:\nThe caption should begin with the word \"Lost\".\nChapter 8, Page 8-22, Figure 8.4:\nThe bit string\"101\" in the figure should be in bold face.\n(Correct version is at the right)\nChapter 9, Page 9-18, AUDIT() procedure: (errata added 4/3/2013)\nThe third line should read\nfor each W in bank.accounts\nChapter 9, Page 9-35, Figure 9.15:\nThe last line of pseudocode (\"else signal\") should be numbered 15 and aligned with\nthe \"if\" on line 11.\nChapter 9, Page 9-44, Figure 9.19, line 5 should read: (errata added 4/3/2013)\ncrvalue.old ← GET (credit_account)\nChapter 9, Page 9-46, first complete paragraph, line 2:\nThe word \"backward\" should not be in italics.\nChapter 9, Page 9-67, Section 9.4.4, second paragraph, line 5:\nThe letter \"i\" in \"issues\" should not be underlined.\nChapter 9, Page 9-73, last paragraph, line 4:\n\"...transaction T2 just does a (blind) write to Y.\" should be\n\"...transaction T2 just does a (blind) write to X.\";\non line 5, \"...intersect at variable Y,\" should be \"...intersect at variable X,\"\nand the second line of pseudocode at the bottom of the page should read\nT2: WRITE X\nChapter 9, Page 9-74, line 3:\nERRATA-1\nSaltzer & Kaashoek Ch. errata, p. 1\nFebruary 25, 2016 12:02 pm\n\nERRATA-2\nSaltzer & Kaashoek, Principles of Computer System Design\nInsert the following sentence after the word \"locking.\":\n(Under two-phase locking, the earliest that T1 can release its lock on X is after it acquires\nthe lock on Y, so it unnecessarily delays the blind write of T2.)\"\nChapter 11, page 11-110, third and fourth paragraphs:\nThe second sentence of the third paragraph should begin:\n\"That reduction uses the theorem that P(p - 1)(q - 1) = P0 (modulo n), a result by Euler\nand...\"\nand the second sentence of the fourth paragraph should begin:\n\"If one chooses p = 47, q = 59, and e = 17, then d = 157...\"\nChapter 11, Section 11.9 (Page 11-112):\nDelete the period at the beginning of the section title, both here and in the table of\ncontents on page 11-3.\nChapter 11, Section 11.10.3 (Page 11-122):(errata added 6/14/2014)\nIn the fifth line of the paragraph beginning \"TLS uses...\", insert the word \"is\" between\n\"and\" and \"different\".\nIn the last line on the page, \"Amazon\" should be capitalized.\nSaltzer & Kaashoek Ch. errata, p. 2\nFebruary 25, 2016 12:02 pm"
    },
    {
      "category": "Resource",
      "title": "faults_figures.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/aafc5306d23570ffc787cbf624d15277_faults_figures.pdf",
      "content": "Be explicit\nGet all of the assumptions out on the table.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\ntime, t\nfailure rate,\nconditional\nh(t)\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\n4.5 s\n-1\n7s\n9.6\n10.0\n10.4\n10.8\n11.2\n11.6\n12.0\n12.4\n12.8 ns\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nerror\nundetectable\nerror\nundetected\nerror\nunmaskable\nerror\nunmasked\nerror\nuntolerated\nerror\ndetectable\nerror\ndetected\nerror\nmaskable\nerror\nmasked\nerror\ntolerated\nerror\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nbit\nP7\nP6\nP5\nP4\nP3 P2\nP1\nChoose P1 so XOR of every other bit (P7 ⊕ P5 ⊕ P3 ⊕P1) is 0\n⊕\n⊕\n⊕\n⊕\nChoose P2 so XOR of every other pair (P7 ⊕P6 ⊕P3 ⊕P2) is 0\n⊕\n⊕\n⊕\n⊕\nChoose P4 so XOR of every other four (P7 ⊕P6 ⊕P5 ⊕P 4) is 0\n⊕\n⊕\n⊕\n⊕\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nnew sector\ndata 1\ndata 2\ndata 3\ndata 4\nparity\nold sector\ndata 1\ndata 2\ndata 3\ndata 4\nparity\nparity ⊕ old ⊕ new\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nM1\nM2\nM3\nV1\nV2\nV3\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\n1.0000\n0.9997\n.999997\nthree engines\nReliability\n0.9993\n0.9990\n0.9987\n0.999\none engine\n0.9983\n.00025 .0005\n.001\n.00075\nMission time, in units of MTTF\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nReliability\n1.0\n0.8\n0.6\n0.4\n0.2\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0 1.2 1.4\nprevious\nfigure\nMission time, in units of MTTF\n0.25 single engine\n0.15 three engines\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\n5MR with\nNumber\nof\nreplicas\nstill\nworking\ncorrectly 1\n5MR with fail-fast\nreplicas fails\n5MR with\npurging fails\nfail-vote fails\ntime\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nprocedure CAREFUL_GET (data, sector_number)\nfor i from 1 to NTRIES do\nif FAIL_FAST_GET (data, sector_number) = OK then\nreturn OK\nreturn BAD\nprocedure CAREFUL_PUT (data, sector_number)\nfor i from 1 to NTRIES do\nif FAIL_FAST_PUT (data, sector_number) = OK then\nreturn OK\nreturn BAD\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009\n\nAvoid rarely used components\nDeterioration and corruption accumulate unnoticed--until the next use.\nPrinciples of Computer System Design (c) Saltzer & Kaashoek 2009"
    }
  ]
}