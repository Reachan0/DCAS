{
  "course_name": "Elements of Software Construction",
  "course_description": "This course provides an introduction to the fundamental principles and techniques of software development that have greatest impact on practice. Topics include capturing the essence of a problem by recognizing and inventing suitable abstractions; key paradigms, including state machines, functional programming, and object-oriented programming; use of design patterns to bridge gap between models and code; the role of interfaces and specification in achieving modularity and decoupling; reasoning about code using invariants; testing, test-case generation and coverage; and essentials of programming with objects, functions, and abstract types. The course includes exercises in modeling, design, implementation and reasoning.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1.5 hours / session\n\nRecitations: 1 session / week, 1 hour / session\n\nObjectives\n\nThe objectives of this course are that, by the end:\n\nYou will have the skills to develop a small to medium-scale software system from scratch: formulating and analyzing the problem to be solved; exploring and articulating candidate designs; implementing in Java; and using testing and reasoning to ensure quality.\n\nYou will have a solid grasp of, and ability to apply, key software engineering ideas, including invariants, decoupling, and data abstraction.\n\nYou will be fluent in three essential and widely used design notations (state machines, module dependency diagrams, and object models) and able to use them effectively in exploring and articulating problems and designs.\n\nYou will be familiar with a variety of standard design and implementation patterns (such as model-view-controller and client-server) and with some popular technologies (such as Eclipse, JUnit, Subversion, Swing, HTTP, network sockets).\n\nYou will have a stronger inherent ability to make engineering judgments and pick the right tool for the task at hand; improved skills in design, organization and analysis; an appreciation for the importance of simplicity and abstraction; and a greater awareness of risk and how to mitigate it.\n\nYou will have had some experience working collaboratively in a team.\n\nCourse Elements\n\nLectures\n\nThere are two 80-minute lectures each week. You're expected to attend all the lectures and to participate actively in class discussions. To encourage a collegiate atmosphere, we request that no laptops or phones be open during class. There is no course text.\n\nRecitations\n\nThe teaching assistants will be leading one-hour recitations on Thursdays. You will be asked to select a time, and to attend the recitation at that time each week.\n\nProblem Sets\n\nTo consolidate your understanding of the lecture ideas, you'll do three problem sets, one on each paradigm. Like projects, problem sets will involve both design and implementation work, but the problems will be smaller and less open-ended. Problem sets will be done individually.\n\nProjects\n\nYou'll complete three small software development projects, each of which goes all the way from specification and design to coding and testing. All projects will be done in teams of three students. You'll have the opportunity to choose whom to work with, and we'll do our best to honor your choices. Any pair of students, however, will only be allowed to work together on a single project. Collaboration is encouraged, although each team member is required to participate roughly equally in every activity (design, implementation, test, documentation), and we may ask for an accounting of what each team member did. Each project will have a deliverable after one week (usually involving exploring the problem and working on design issues), and a second, final deliverable after the second week. Code will be handed in electronically (by committing in the repository before the deadline). For each of the deliverables, your team will submit a single document (in hardcopy and in PDF in your repository) summarizing your design and answering any particular questions posed in the project handout.\n\nExplorations\n\nA series of three case studies will be presented in lecture, in order to illustrate the concepts being taught on substantial examples. Before each case study, you will implement a solution to the case study problem yourself, both to give you practice coding in Java, and to introduce you to the case study. Your solution will be judged on the correctness and clarity of the code; you will (obviously) not be expected to use design ideas that have not yet been taught. Explorations will be done individually.\n\nTeam Meetings\n\nYou and your team will meet with your TA during your project to discuss the work. Your TA will assign a grade based in part on this meeting. A single grade will be assigned to all students in the project.\n\nLab Assignments\n\nEach project will be preceded by a lab assignment to help you get up to speed with the project's technology. Lab assignments will be done individually. A TA will formally check off that you have completed the lab during the session itself. The lab is also a time to chat informally with your TA about your ongoing work and to look over your lab notebook. A team of LAs will be available in the lab to help you slay any technological monsters that impede your progress.\n\nQuizzes\n\nThere will be no quizzes or final exam.\n\nGrading Policy\n\nThe relative contributions of the various activities to your grade are: explorations 20%, problem sets 30%, projects 40%. The remaining 10% of your grade will be at the discretion of the teaching staff, and will be determined in part by your participation in recitations and your performance in lab assignments. Late work will incur a penalty of 10 percentage points per 24 hours late, up to a maximum of 72 hours. Assignments that are more than 3 days late will not be graded at all.\n\nIn unusual or extenuating circumstances, you may be able to complete a project late without penalty, but only if you receive advance permission from your TA. The further in advance you ask for an extension, the more likely it is to be granted. Obviously, exceptions are made for emergencies; we don't expect you to get advance permission if you get sick suddenly, but remember that a health problem can only be considered for an unapproved extension if you present a doctor's note.\n\nIn line with the Departmental Guidelines Relating to Academic Honesty, here are our expectations regarding collaboration and sharing. For the projects, you are encouraged to collaborate with your partners on all aspects of the work, and each of you is expected to contribute a roughly equal share to design and implementation. You may reuse designs, ideas and code from your own work earlier in the semester (even if it was done with a different partner). You may also use material from external sources, so long as: (1) the material is available to all students in the class; (2) you give proper attribution; and (3) the assignment itself allows it. In particular, if the assignment says \"implement X\", then you must create your own X, not reuse someone else's.\n\nProblem sets, explorations and lab assignments are intended to be primarily individual efforts. You are encouraged to discuss approaches with other students but your write-up must be your own. You should not make use of any written solutions or partial solutions produced by others. Material from external sources can also be used with proper attribution, but again only if the assignment allows it. You may not use materials produced as course work by students in the course, whether in this term or previous terms, nor may you provide work for other students to use.\n\nCopying work, or knowingly making work available for copying, in contravention of this policy is a serious offense that may incur reduced grades, failing the course and disciplinary action.",
  "files": [
    {
      "category": "Resource",
      "title": "Exploration 1: A Midi Piano",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/a938262c99aaa3026f83fdc6d56530f3_MIT6_005f08_explore01.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nExploration 1: A Midi Piano\n6.005 Elements of Software Construction | Fall 2008\nExploration 1: A Midi Piano\nThe purpose of this exploration is to give you practice coding in Java, and to introduce you to\nthe state machine case study that will be presented in lecture. Your solution will be judged by\n(1) correctness -- whether it meets the specification, and (2) clarity -- whether your code is\nwell-organized, carefully commented, and makes proficient use of Java. You are not required\nto use any of the ideas or patterns that have not yet been taught in lecture.\nSpecification\nYour task is to build a program that allows a standard computer keyboard to be used as a\n(rather crude) electronic piano with the following features:\n● The notes of the octave above middle C are played on the numeric keys, starting with 1\non the left and ending with the = key on the right, with a semitone between each (so\nthat each pair of adjacent keys corresponds to a pair of adjacent keys on a real piano,\nincluding the black ones).\n● Holding a key down sustains the note, and several notes can be played at once.\n● Different instruments can be chosen. Pressing the I key cycles through the available\nmidi instruments.\n● You can record and play back sequences of notes. Pressing the R key starts recording,\nand pressing it again stops recording. During recording, a red indicator is shown; this\nturns back to green when recording ends. Pressing P causes the last recorded sequence\nto be played back. Note that playback should preserve timing.\nHints\nYour keyboard driver will probably generate repeat presses when a key is held down. You'll\nneed to make sure these are filtered away so that the quality of the sound isn't damaged.\nWe recommend that you implement your program as a Java applet. We are providing you\nwith skeletal code that shows you how to bind methods to key presses, and how to access the\nJava midi API. You may of course use this code in your solution.\n\nExploration 1: A Midi Piano\nTo implement the color indicator, we recommend that you simply change the color of the\napplet's background, as shown in the sample code.\nA slight annoyance: you'll need to click on the applet's panel with your mouse to give it\nkeyboard focus before playing any notes.\nOptional Challenge\nIf you've successfully completed the exploration, you may want to try this optional challenge.\nAllow the P key to be pressed during recording, so that recordings can be layered, with new\nnotes played being added to notes that were previously recorded. (Warning: this is tricky!)\nAddendum\nSome Java installations do not have a default soundbank installed, causing the Midi code to\nthrow the exception\njava.lang.NullPointerException\nat com.sun.media.sound.AbstractPlayer.loadAllInstruments(Unknown Source)\nat midi.Midi.(Midi.java:43)\nat piano.PianoApplet.init(PianoApplet.java:24)\nat sun.applet.AppletPanel.run(Unknown Source)\nat java.lang.Thread.run(Unknown Source)\nThis can be corrected by following Sun's instructions here."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 1: The State Machine Paradigm",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/1af22e22e0bb89280bcafe05a5d9bdd1_MIT6_005f08_pset01.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nProblem Set 1: The State Machine Paradigm\n6.005 Elements of Software Construction | Fall 2008\nProblem Set 1: The State Machine Paradigm\nThe purpose of this problem set is to give you practice in the basic techniques of the state\nmachine paradigm. You'll construct state transition diagrams and grammars for a variety of\nsmall problems, and code them using standard patterns.\nState Machine Reasoning\nMilk and Tea Puzzle. Here's a well-known puzzle. You have a glass of tea and an equal-\nsized glass of milk. You pour some milk into the tea, mix it up throughly, and then transfer\nthe same amount of liquid back to the milk. This process is repeated some number of times.\nIs there now more milk in the tea or more tea in the milk?\nThe answer is that there is exactly the same amount. To prove this, (1) construct a state\nmachine to model the problem; (2) define an invariant; and (3) show that the invariant is\ntrue in the initial state and is preserved by the state machine's actions.\nHint: Treat each glass as consisting of a discrete number of particles, and define an action\nthat does to-and-fro transfers in a single step. Also, note that, as specified, the machine is\nalready non-deterministic, since it permits an arbitrary quantity of milk to be poured initially.\nCan you make it even more non-deterministic and still preserve the invariant?\nState Diagram Modeling\nThree-way Light. A 'three-way' lighting circuit consists of two switches and a single lamp;\ntoggling either switch toggles the state of the lamp. Draw a state machine representing the\nbehavior of this system, with events up_1 and down_1 for moving switch 1 up and down (and\nanalogously for switch 2). Show the state of the lamp by marking the states of the machine\nappropriately.\nCruise Control. Consider a cruise-control system with these events: on (turns the system\non); set (records the current speed and attempts to maintain it); brake (stops attempting to\nmaintain speed); resume (attempts to return to and maintain last recorded speed); and off\n\nProblem Set 1: The State Machine Paradigm\n(turns the system off and clears any memory of a recorded speed). Draw a state transition\ndiagram that shows which event sequences are accepted (assuming that on is accepted only\nwhen the system is off, resume only when the system is on, etc), and which of three modes\nthe system is in: OFF (not operating); ON (operating but not actively controlling speed); and\nACTIVE (actively controlling speed). A mode may correspond to one or more states. Then,\nusing this diagram as a basis, construct a second diagram that includes three additional\nevents that are produced as outputs: save (which saves the current speed to a register),\ncontrol (commanding the engine to maintain the speed in the register) and relinquish\n(relinquishing control of the engine to the driver).\nAlternating Bit Protocol. One way to compensate for a lossy communications channel is to\nhave the receiver acknowledge each received message and have the sender retransmit if no\nacknowledgment is obtained. But if an acknowledgment arrives late, and a resend has already\noccurred, messages and their acknowledgments get out of step. To avoid this, you can attach\na sequence number to each message so that the receiver can indicate which message is being\nacknowledged. The simplest version of this scheme is the Alternating Bit Protocol which uses\nsequence numbers of just one bit. Here's how it works. The sender marks outgoing messages\nwith a zero, then a one, then a zero, etc. The receiver acknowledges each message with the\nsame bit that the message was marked with. If either the sender or the receiver gets a\nmessage with the wrong bit, it resends its previous message. The sender also resends a\nmessage if it receives no acknowledgment at all after some unspecified elapsed time. Model\nthis protocol as two state transition diagrams, one for the sender and one for the receiver,\naccompanied by a list of events and their definitions. Draw a third diagram to model the\nbehavior of an unreliable channel between them that can hold up to two messages at a time,\nand can drop but never corrupt or reorder messages.\nGrammar Modeling\nMulti-Unit Calculator. It's often convenient to use different units in the same computation.\nFor example, to figure out how many lines of twelve-point type fit in a six-inch column, it\nwould be nice to have a calculator that accepted the expression \"6in/12pt\". Construct two\ngrammars for such a language: first, a lexical grammar that breaks the sequence of\ncharacters into numbers, unit specifiers, operators, and left/right parentheses, filtering out\nspaces and tabs (but not requiring them as delimiters); and second, a syntactic grammar that\ngroups expressions appropriately. Your grammar should allow nesting of expressions using\nparentheses (eg, \"1in + (2in + 3in)\"), and it should allow unit conversions (eg, \"30pt in\"\nto show 30 points in inches). Note: You need only handle inches and points, and you can\nassume that every expression denotes a length or a dimensionless scalar (and not, for\nexample, a product of lengths). There are 12 points in a pica, 6 picas in an inch, and thus 72\n\nProblem Set 1: The State Machine Paradigm\npoints in an inch.\nCruise Control. Model the cruise control system described above but using grammars\ninstead of state transition diagrams.\nImplementing with Patterns\nMulti-unit Calculator. Implement the multi-unit calculator described above, with a class\nwhose main method takes a single string as an argument and returns a string as a result. You\nshould split your program into two separate phases, one for 'lexing' (breaking the string into\nlexical tokens), one for 'parsing' (grouping the tokens syntactically). Your code for these\nphases should correspond directly to the two grammars you designed. Provide at least three\nJUnit test cases for your code. Hint: You can perform evaluation as part of the parsing phase\nor in a separate subsequent phase.\nAlternating Bit Protocol. Implement the alternating bit protocol as described above,\nincluding the unreliable communications channel. Each of the three components should be\nimplemented as (at least) one class with a method step which, when called, causes the\ncomponent to take a step -- such as sending, receiving or transmitting a message. Provide at\nleast three JUnit test cases for your code that include a case in which the protocol handles\ndropped messages.\nInfrastructure\nNo code is provided for this problem set. A directory called pset1 will be created for you in\nyour personal repository, containing a copy of this file. In addition to your code and test\ncases, you should commit your solutions to the exercises as a single PDF file."
    },
    {
      "category": "Resource",
      "title": "Exploration 2: Building a Sudoku Solver with SAT",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/edd5db4c32b6d028470076aa16cdb3cf_MIT6_005f08_explore02.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nExploration 2: Building a Sudoku Solver with SAT\n6.005 Elements of Software Construction | Fall 2008\nExploration 2: Building a Sudoku Solver with SAT\nThe purpose of this exploration is to give you practice coding in Java, and to introduce you to\nthe case study that will be presented in the lectures on programming with functions and\nimmutable datatypes. Your solution will be judged by (1) correctness -- whether it meets the\nspecification, and (2) clarity -- whether your code is well-organized, carefully commented,\nand makes proficient use of Java. You are not required to use any of the ideas or patterns\nthat have not yet been taught in lecture.\nSpecification\nYour task is to build a program that completes a Sudoku puzzle by (1) translating the puzzle\ninto the problem of satisfying a propositional logic formula, and (2) solving the problem using\na SAT solver. Your program should accept a Sudoku puzzle as input, and should display a\nsolution on the console. The format for the puzzle is just one line for each line of the puzzle,\nconsisting of a sequence of digits (for known squares) and periods (for squares to be filled).\nWe're providing you with two sample puzzles in this format, which are included in your\nrepository along with this assignment.\nBackground\nA Sudoku puzzle is a kind of Latin square. The aim is to complete a 9x9 grid with a digit\nbetween 1 and 9 in each square, so that -- as in a Latin square -- each digit occurs exactly\nonce in each row and in each column. In addition, the grid is divided into 9 blocks, each 3x3,\nand each digit must also occur exactly once in each block. Sudoku is normally solved by\nreasoning, determining one step at a time how to complete an additional square until the\nentire puzzle is finished. Solving Sudoku by SAT is not very appealing for human players but\nworks well on a computer.\nA propositional formula is a logical formula formed from propositional variables and the\nboolean operators and, or and not. The satisfiability problem is to find an assignment of truth\nvalues to the variables that makes the formula true.\nA SAT solver is a program that solves the satisfiability problem: given a formula, it either\n\nExploration 2: Building a Sudoku Solver with SAT\nreturns an assignment that makes it true, or says that no such assignment exists. SAT\nsolvers typically use a restricted form of propositional formula called CNF.\nA formula in conjunctive normal form (CNF) consists of a set of clauses, each of which is a set\nof literals. A literal is a propositional variable or its negation. Each clause is interpreted as the\ndisjunction of its literals, and the formula as a whole is interpreted as the conjunction of the\nclauses. So an empty clause represents false, and a problem containing an empty clause is\nunsatisfiable. But an empty problem (containing no clauses) represents true, and is trivially\nsatisfiable.\nDavis-Putnam-Logemann-Loveland (DPLL) is a simple and effective algorithm for a SAT\nsolver. The basic idea is just backtracking search: pick a variable, try setting it to true,\nobtaining a new problem, and recursively try to solve that problem; if you fail, try setting the\nvariable to false and recursively solving from there. DPLL adds a powerful but simple\noptimization called unit propagation: if a clause contains just one literal, then you can set the\nliteral's variable to the value that will make that literal true. (There's actually another\noptimization included in the original algorithm for 'pure literals', but it's not necessary and\ndoesn't seem to improve performance in practice.)\nWikipedia articles cover these topics nicely: Sudoku, CNF, DPLL, backtracking search, unit\npropagation.\nInfrastructure\nThe exploration2 project in your repository contains this assignment and the sample Sudoku\npuzzles. Your work should be submitted by committing to this project.\nHints\nHere are some hints to help you get the most out of this exploration and make progress\nquickly:\n● This exploration is quite challenging. You'll probably not succeed if you just start\nhacking and hope to make your way through it by brute force. Start early, and discuss\nyour ideas with your TA.\n● Build your program incrementally. Start with a version that does only backtracking and\nno unit propagation, and see if you can get it to work on a tiny problem. Try a very\nsmall SAT problem first that is small enough that you can trace the behavior of your\n\nExploration 2: Building a Sudoku Solver with SAT\nsolver with print statements if necessary. Try an unpopulated Sudoku puzzle before\nyou try one that is partially completed, and try smaller puzzles (2x2 and 4x4) before\nyou try the full-sized puzzle (9x9).\n● You can create a standard propositional formula and convert it to CNF, but you'll find it\neasier if you generate CNF directly from the Sudoku grid. It's not hard.\n● The simplest way to encode the puzzle in logic is to create one propositional variable\nfor the possibility that each symbol can be in each square. So for a 9x9 puzzle, there\nwill be 9x9x9 variables. This makes it clear that backtracking search alone will likely\nfail, since the number of leaves of the search tree is 2 to the power of the number of\nvariables.\n● Use immutable datatypes to represent literals, clauses and clause sets. Search is much\neasier to program if you don't have to worry about mutation and undoing previous\ndecisions.\n● To solve the full-sized Sudoku problem you will probably need to increase the amount\nof memory that the Java interpreter has allocated for heap space. Recall that every\ntime you run your project (as a Java program, with JUnit, etc.) Eclipse creates a run\nconfiguration that specifies what to run and how to run it. To increase the maximum\nheap space for a run configuration, open the Run dialog (Run → Run\nConfigurations...), select the relevant configuration, select the Arguments tab, and\nenter under VM arguments -Xmx512m (for example, which sets the maximum heap size\nto 512MB)."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 2: The Symbolic Paradigm",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/312b62acc6a7bb9958faec626138f189_MIT6_005f08_pset02.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nProblem Set 2: The Symbolic Paradigm\n6.005 Elements of Software Construction | Fall 2008\nProblem Set 2: The Symbolic Paradigm\nThe purpose of this problem set is to give you practice in the basic techniques of the symbolic\nparadigm. You will model datatype productions, write recursive functions over those\ndatatypes, practice with structural induction, and implement datatypes as classes.\nDatatype Reasoning\nLength of append [10%]. Given a datatype List and two functions over the datatype size\nand append defined as follows:\nList<E> = Empty + Cons(first:E, rest:List<E>)\nsize: List<E> → int\nsize(Empty) = 0\nsize(Cons(f,r)) = 1 + size(r)\nappend: List<E> x List<E> → List<E>\nappend(Empty, l) = l\nappend(Cons(e,l1), l2) = Cons(e, append(l1,l2))\nShow using structural induction that size(append(x,y)) = size(x) + size(y).\nDatatype Modeling\nSuppose you're developing a system for doing physics calculations (simple mechanics, as\nused in 8.01; e.g. Newton's laws of motion and Newton's law of gravitation.).\nPhysical units [10%]. One helpful feature in a physics-handling system is to check\nexpressions for unit correctness. For example, an expression that adds mass to velocity is\nnonsensical. Model the units of a physical quantity used in mechanics. Your datatype should\nbe able to handle dimensionless values (like pi and e), the basic SI units for mechanics\n(meters, grams, and seconds), and the units of physical variables like velocity, momentum,\n\nProblem Set 2: The Symbolic Paradigm\nforce, and energy.\nExpressions for physical computations [10%]. Design a datatype that models the\nmathematical expressions you need to represent problems in mechanics. The expressions\nshould be over the real numbers; should be able to represent numerical constants (like 0),\nnamed constants (like G or g), and variables (like F, m, a); should include the basic\narithmetic operators (addition, multiplication, exponentiation, etc.), differentiation and\nintegration in one variable, and equality (like F=ma). Constants and variables should have\nphysical units, using the datatype you defined in the previous problem. Briefly discuss the\ndesign decisions you made -- e.g., does your datatype permit nonsensical expressions?\nNote: These datatypes should be defined using abstract datatype productions (similar to the\nway we defined List and Tree in class), not in Java.\nDatatype Operations\nUnit checking [15%]. Define a boolean-valued function unitsCheck over your physical\nexpressions that is true if and only if the the units of the expression check correctly. Write\nyour function as a recursive definition, not in Java. Hints:\n● You may need to define additional helper functions to determine the units of an\nexpression or test for unit equality. Don't just assume the existence of these helper\nfunctions; provide definitions for them if you need them.\n● Checking for unit equality may be tricky, depending on how you defined your units\ndatatype. It may help to use a canonical form that puts a units expression in lowest\nterms and determines the exponents of each of the three physical quantities (mass,\nlength, time). For example, the units of acceleration (m/s2) would be canonically\nrepresented by length 1, time -2, mass 0. You can define the canonical form either as a\nnew datatype (i.e., a triple of integers) or as a set of functions over your units\ndatatype (e.g., mass:Units → int).\nArrays [15%]. This problem uses an immutable datatype to represent arrays, which are\ndata structures that map integers to objects. An array is represented by a binary tree, in\nwhich each node stores an element of the array:\nArray<E> = Empty + Node(elem:E, left:Array<E>, right:Array<E>)\nThe array is indexed starting from 1. Each tree node has an index given (in binary) by its\npath to the root, as follows. Start with 1 for the node itself, and append 0 or 1 for each step\nback to the root, depending on whether it was a left branch or a right branch. The diagram\n\nProblem Set 2: The Symbolic Paradigm\nbelow shows the nodes with index 1 through 12.\nThe element at index i is stored in the tree node with index i according to this scheme, so a\n[1] would be stored in the root. Note that indexes are not stored in the tree; an index is used\nto find a node by walking down from the root. Also, an array may not have gaps, so if it\ncontains n elements, then the elements must be indexed from 1 to n. The binary tree is not\nnecessarily complete, however, so some nodes in the tree may have only one nonempty child\n(like nodes 5, 6, and 7 in the picture above).\nGive recursive definitions for the following operations:\n● size(a) returns the number of elements in an array.\n● get(a,i) returns the element at index i in array a (or is undefined if i is out of range).\n● put(a,i,e) returns a new array which maps index i to element e and is otherwise\nidentical to a. (Undefined if i is negative or zero, or if it would create an array with a\ngap.)\nHint: you may need to write conditional expressions in your function definitions. Here's a\nsimple model:\nabs: int → int\nabs(x) = if x < 0 then -x else x\nImplementing Datatypes\nArrays [20%]. Implement the array datatype from the previous problem using Java classes,\nand implement get, put, and size as methods. Write a JUnit test suite that tests your\ndatatype. Note that your datatype should be immutable, and you will have to make design\ndecisions about what the methods should do when the result is undefined.\n\nProblem Set 2: The Symbolic Paradigm\nArbitrary-precision rational numbers [20%]. Implement an immutable abstract data\ntype for rational numbers. Represent a rational number using two java.math.BigInteger\nvalues, a numerator and a denominator, which should always be stored in lowest form (i.e.,\nnot 4/8, but 1/2). You'll find BigInteger's gcd operation useful; a.gcd(b) returns the greatest\ncommon divisor of a and b.\nImplement your data type as a Java class called Rat. It should have the following parts:\n● Representation, consisting of private fields\n● Rep invariant, implemented by a checkRep() method\n● Abstraction function, implemented by a toString() method\n● Constructor Rat(BigInteger num, BigInteger denom)\n● Operations provided by the following methods:\npublic boolean isZero()\npublic boolean isOne()\npublic Rat plus(Rat that)\npublic Rat minus(Rat that)\npublic Rat times(Rat that)\npublic Rat divide(Rat that)\n● Preconditions and postconditions on the constructor and operations\n● A JUnit test suite called RatTest that tests Rat\nInfrastructure\nNo code is provided for this problem set. A directory called pset2 will be created for you in\nyour personal repository, containing a copy of this file. In addition to your code and test\ncases, you should commit your solutions to the exercises as a single PDF file."
    },
    {
      "category": "Resource",
      "title": "Exploration 3: Photo Organizer",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/73ce4032ea79a56abd55f6ad121d91a3_MIT6_005f08_explore03.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nExploration 3: Photo Organizer\n6.005 Elements of Software Construction | Fall 2008\nExploration 3: Photo Organizer\nThe purpose of this exploration is to give you practice coding in Java, and to introduce you to\nthe case study that will be presented in the lectures on programming with mutable data and\nrelations. Your solution will be judged by (1) correctness -- whether it meets the specification,\nand (2) clarity -- whether your code is modular, well-organized, carefully commented, and\nmakes proficient use of Java. You are not required to use any of the ideas or patterns that\nhave not yet been taught in lecture.\nSpecification\nYour task is to build an organizer for digital photos, similar to the screenshot below.\nThe photo organizer should have the following features:\n● A set of photos is loaded by finding all the JPEG files in a subtree of the filesystem\nspecified by a command-line argument. (When run with no arguments, the organizer\n\nExploration 3: Photo Organizer\nshould just use the set of sample photos provided.)\n● The user can create and manage named albums of photos. An album is a subset of all\nthe loaded photos. A photo can appear in more than one album. There is an album, \"all\nphotos\", containing all the loaded photos.\n● Albums are hierarchical. An album may have subalbums, which are subsets of the\nparent album's photos. For example, the user might create a \"Cambridge\" album for all\nthe photos taken in Cambridge, and an \"MIT\" subalbum under it that contains all\nphotos from MIT. The \"all photos\" album is the root of the album hierarchy.\n● The photo organizer window has two parts: a tree on the left showing the album\nhierarchy, and an array of photo thumbnails on the right.\n● Clicking on an album name in the tree selects it. At most one album may be selected at\na time.\n● Double-clicking on an album name displays the thumbnails for the album's photos on\nthe right. (Note that the displayed album is not necessarily the same as the selected\nalbum, since another album can be single-clicked to select it without changing the\ndisplayed thumbnails.)\n● Clicking on a photo thumbnail selects or deselects it. Selected photos are highlighted in\nblue. Any number of photos may be selected.\n● Buttons on the window allow making a new album with a user-provided name, deleting\nthe selected album, and adding and removing the selected photos from the selected\nalbum.\n● Adding and removing a photo from an album should immediately affect the album. If\nyou remove a photo from an album, then that album should stop displaying that photo.\nSubsequent user operations may put the photo back in the album, however. Other\nalbums may also be affected by adding or removing a photo, as necessary to preserve\nthe album hierarchy property.\n● As an optional extension, display the size of each album in the tree (e.g. \"MIT (45)\" if\nthe MIT album has 45 photos in it).\nIf this specification is incomplete, you should use your own design judgement to fill in the\ndetails. In general, your program should not crash, throw uncaught exceptions, or allow the\nuser to put the interface into a state that violates this specification.\nInfrastructure\nThe exploration3 project in your repository contains this assignment, some skeleton code\nfor the photo organizer, and some sample photos. Your work should be submitted by\ncommitting to this project.\n\nExploration 3: Photo Organizer\nHints\nNote that albums are not the same as folders in the filesystem, so you don't have to make a\nfolder on disk when the user creates an album. The notion of an album is just internal to your\nphoto organizer. It's also acceptable if your photo organizer completely forgets the albums\nthe user created when it restarts. (As an optional extension, however, you might make the\nalbums persistent by saving and loading them from a file.)"
    },
    {
      "category": "Assignment",
      "title": "Problem Set 3: The Relational Paradigm",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/3e67655afdea6a2f6778ac94be3d15e7_MIT6_005f08_pset03.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nProblem Set 3: The Relational Paradigm\n6.005 Elements of Software Construction | Fall 2008\nProblem Set 3: The Relational Paradigm\nThe purpose of this problem set is to give you practice in the basic techniques of the\nrelational paradigm. You'll construct a variety of object models, and code one of them using\nstandard patterns. You'll also do a small exercise to check that you understand some of the\ncomplexities of of mutable datatypes.\nMutable Datatypes\nInvestigating Java's Set. The specification of java.util.Set says that a set should not\ncontain itself. Write a JUnit test for one of the standard Java library implementations of Set\nthat violates this rule and fails; explain what's happening carefully and succinctly; and explain\nhow the principles of the lecture on mutable types address this issue.\nObject Modeling\nFor each of the following problems, construct (1) a graphical object model, accompanied by\n(2) designations that give a crisp and precise one sentence meaning for each set and relation\nname, and (3) three object diagrams showing interesting cases of instances satisfying the\nmodel.\nSudoku. Model the state of a puzzle, allowing for both completed and incomplete grids, and\nmaking explicit the grouping into rows, columns and subgrids.\nSlide Animation. Model a slide containing textual and graphical elements, along with\nsettings for animation. Include grouping of elements, and appearance order and effects.\nDomain Name System (DNS). Model domain names and the architecture for resolving\nthem. Your model should include the structure of the domain names, their relationship to IP\naddresses, the network of domain name solvers, and caches (and little else!). For an\nexplanation of DNS, see the wikipedia article. Do not worry about the low level structure of\nDNS records; your model should show the structure of the system (and the state of the\nservers) at an abstract level.\n\nProblem Set 3: The Relational Paradigm\nSocial Network. Model a social network (as found, for example, in Facebook, MySpace and\nLinkedIn) that includes the following features: members, friendship, groups, profiles, posted\nobjects, tagged photos, recent activity feeds, pending invitations.\nElection Ballots. Model the voter input in a US federal election, consisting of a set of marked\nballots, containing sufficient information to determine the outcome of the presidential\nelection, senate and congressional races, and state ballot questions.\nAddress Book. Model an email address book that associates user-defined names with email\naddresses, and includes the ability to distinguish home and work addresses, forming groups\nof multiple addresses, and using indirection to allow groups to contain groups and user-\ndefined names.\nObject Model Implementation\nImplement an address book, based on the object model that you constructed. Your address\nbook should provide an API, as a class AddressBook, that provides key operations for\nentering and editing entries, displaying entries, and for resolving a user-defined name to the\nemail addresses it represents. Indicate precisely which object model implementation patterns\nyou used, and how they were applied to derive the implementation structure from the object\nmodel. Construct a suite of test cases based on partitioning that gives reasonable coverage of\nthe specification of the API, and make sure to include the three sample instances that you\ndevised for your object model.\nYour solution will be judged on the clarity of structure of your code, on how well you mapped\nthe model to the code, on the quality of design of your API, and on quality of the testing you\nperformed.\nInfrastructure\nNo code is provided for this problem set. A directory called ps3 will be created for you in your\npersonal repository, containing a copy of this file. In addition to your code and test cases, you\nshould commit your solutions to the exercises as a single PDF file."
    },
    {
      "category": "Resource",
      "title": "Basics of Mutable Types",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/5a6830a94eaa166e2db4b5e820498609_MIT6_005f08_lec16.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n6.005\nelements of\nsoftware\nconstruction\nbasics of mutable types\nDaniel Jackson\n\nheap semantics of Java\n\npop quiz\nwhat happens when this code is executed?\n\nString s = \"hello\";\n\ns.concat(\"world\");\n\nSystem.out.println (s);\n\ns = s.concat(\" world\");\n\nSystem.out.println (s);\nand how about this?\n\nStringBuffer sb = new StringBuffer (\"hello\");\n\nsb.append(\" world\");\n\nSystem.out.println (sb);\n\nStringBuffer sb2 = sb;\n\nsb2.append (\"!\");\n\nSystem.out.println (sb);\n(c) Daniel Jackson 2008\n\nsolutions\nwhat you needed to know to answer correctly\nimmutable and mutable types\n‣ String is immutable, StringBuffer is mutable\n‣ method call on immutable object can't affect it\nassignment semantics\n‣ the statement x = e makes x point to the object that e evaluates to\naliasing\n‣ the statement x = y makes x point to the same object as y\n‣ subsequent mutations of the object are seen equivalently through x and y\n‣ since immutable objects can't be mutated, sharing is not observable\n(c) Daniel Jackson 2008\n\nhow mutation happens\nthrough field setting\n‣ statement x.f = y makes f field of x point to object y\nthrough array update\n‣ statement a[i] = y makes element_i 'field' of a point to object y\nf\nx\ny\nf\n(c) Daniel Jackson 2008\n\nnull and primitives\nprimitive values\n‣ eg, integers, booleans, chars\n‣ are immutable (and aren't objects)\n‣ so whether shared is not observable\nnull\n‣ is a value of object type\n‣ but does not denote an object\n‣ cannot call method on null, or get/set field\n(c) Daniel Jackson 2008\n\nthe operator ==\nthe operator ==\n‣ returns true when its arguments denote the same object\n(or both evaluate to null)\nfor mutable objects\n‣ if x == y is false, objects x and y are observably different\n‣ mutation through x is not visible through y\nfor immutable objects\n‣ if x == y is false, objects x and y might not be observably different\n‣ in that case, can replace x by y and save space (called 'interning')\n‣ Java does this with Strings, with unpredictable results\n‣ lesson: don't use == on immutables (unless you're doing your own interning)\n(c) Daniel Jackson 2008\n\nheap reachability\nfrom example before\n‣ after these statements\n\nString s = \"hello\";\n\ns = s.concat(\" world\");\n‣ the two string literal objects are unreachable\nonce an object is unreachable\n‣ it cannot be reached again\n‣ so removing it will not be observable\nan assignment or field set can leave an object unreachable\n\"hello world\"\n\"hello\"\n\"world\"\ns\nAFTER\n\"hello\"\ns\n\"world\"\narg\nBEFORE\ngarbage collector (aka \"automatic memory management\")\n‣ marks unreachable objects, then deallocates them\n(c) Daniel Jackson 2008\n\nconceptual leaks\nstorage leak\n‣ use of memory grows, but active state isn't growing\nno storage leaks in garbage-collected language?\n‣ unfortunately, can still happen\nexercise: what's wrong with this code? (hint: think about rep invariant)\n\npublic class ArraySet {\n\nprivate Object [] elements;\n\nprivate int size;\n\n...\n\npublic void delete (Object o) {\n\nfor (int i = 0; i < size; i++) {\n\nif (elements[i].equals(o)) {\n\nelements[i] = elements[size-1];\n\nsize--;\n\n}\n\n}\n\n}\n\n(c) Daniel Jackson 2008\n\nmutable datatypes\n\nmutable vs. immutable\nString is an immutable datatype\n‣ computation creates new objects with producers\nclass String {\nString concat (String s);\n...}\nStringBuffer is a mutable datatype\n‣ computation gives new values to existing objects with mutators\nclass StringBuffer {\nvoid append (String s);\n...}\n(c) Daniel Jackson 2008\n\nclassic mutable types\ninterface in\nprincipal\njava.util\nimplementations\nkey mutators\nList\nArrayList,\nLinkedList\nadd, set\nSet\nHashSet,\nTreeSet\nadd, remove,\naddAll, removeAll\nMap\nHashMap,\nTreeMap\nput\n(c) Daniel Jackson 2008\n\nhow to pick a rep\nlists\n‣ use ArrayList unless you want insertions in the middle\nsets and maps\n‣ hashing implementations: constant time\n‣ tree implementations: logarithmic time\n‣ use hashing implementations unless you want determinism\n‣ we'll see later in this lecture how non-determinism arises\nconcurrency\n‣ none of these are thread-safe\n‣ if using with concurrent clients, must synchronize clients yourself\n‣ if you want concurrency in operations, use java.util.concurrent versions\n(c) Daniel Jackson 2008\n\nequality revisited\n\nthe object contract\nevery class implicitly extends Object\n‣ two fundamental methods:\nclass Object {\nboolean equals (Object o) {...}\nint hashCode () {...}\n...\n}\n\"Object contract\": a spec for equals and hashCode\n‣ equals is an equivalence (reflexive, symmetric, transitive)\n‣ equals is consistent: if x.equals(y) now, x.equals(y) later\n‣ hashCode respects equality:\nx.equals(y) implies x.hashCode() = y.hashCode()\n(c) Daniel Jackson 2008\n\nequivalence\ncan define your own equality notion\n‣ but is any spec reasonable?\nreasonable equality predicates\n‣ define objects to be equal when they represent the same abstract value\na simple theorem\n‣ if we define a ≈ b when f(a) = f(b) for some function f\n‣ then the predicate ≈ will be an equivalence\nan equivalence relation is one that is\n‣ reflexive: a ≈ a\n‣ symmetric: a ≈ b ⇒ b ≈ a\n‣ transitive: a ≈ b ∧ b ≈ c ⇒ a ≈ c\n(c) Daniel Jackson 2008\n\na running example\na duration class\n‣ represents durations measured in minutes\npublic class Duration {\nprivate final int hours;\nprivate final int mins;\npublic Duration(int h, int h) {hours = h; mins = m;}\npublic int getMins() {return hours*60 + mins;}\n}\n(c) Daniel Jackson 2008\n\nabstraction function\nDuration d1 = new Duration (1, 2);\nDuration d2 = new Duration (1, 3);\nDuration d3 = new Duration (0, 62);\n(1,2)\n(0,62)\n(1,3)\nconcrete\nabstract\n\nbug #1\nhere's our first broken equality method\n‣ violates transitivity: easy to see why\npublic class Duration {\nprivate final int hours;\nprivate final int mins;\nstatic final int CLOCK_SKEW = ...;\npublic boolean equals (Duration d) { // problematic, see next slide\nif (d == null) return false;\nreturn Math.abs(d.getMins()-this.getMins()) < CLOCK_SKEW;\n}\n}\n(c) Daniel Jackson 2008\n\nbug #2\nwhat happens if you fail to override equals\n‣ note that outcome depends on declaration, not runtime type (aagh!)\npublic class Duration {\nprivate final int hours;\nprivate final int mins;\npublic Duration(int h, int h) {hours = h; mins = m;}\npublic boolean equals (Duration d) {\nreturn d.getMins() == this.getMins();\n}\n}\nDuration d1 = new Duration(1,2);\nDuration d2 = new Duration(1,2);\nSystem.out.println(d1.equals(d2)); // prints true\nObject d1 = new Duration(1,2);\nObject d2 = new Duration(1,2);\nSystem.out.println(d1.equals(d2)); // prints false!\n(c) Daniel Jackson 2008\n\nexplaining bug #2\nwhat's going on?\n‣ we've failed to override Object.equals\n‣ method is chosen using compile-time type\n‣ method has been overloaded, not overridden\npublic class Object {\npublic boolean equals (Object o) {return o == this;}\n}\npublic class Duration extends Object {\npublic boolean equals (Object o) {return o == this;}\npublic boolean equals (Duration d) {\nreturn d.getMins() == this.getMins();\n}\n}\n(c) Daniel Jackson 2008\n\nfixing equals\nhere's a fix to the problem\n‣ compile-time declaration no longer affects equality\n@Override // compile error if doesn't override superclass method\npublic boolean equals(Object o) {\nif (! (o instanceof Duration))\nreturn false;\nDuration d = (Duration) o;\nreturn d.getMins() == this.getMins();\n}\n(c) Daniel Jackson 2008\n\nequality and subclassing\nnow considering extending the type\n‣ how should equality be determined?\n‣ can't rely on inherited equals method, because seconds ignored\npublic class ShortDuration extends Duration {\nprivate final int secs;\n...\nprivate ShortDuration (int h, int m, int s) {...};\npublic int getSecs () {return 3600*hours + 60*mins + secs;}\n...\n}\n(c) Daniel Jackson 2008\n\nbug #3\nan attempt at writing equals for subclass\n@Override\npublic boolean equals(Object o) {\nif (! (o instanceof ShortDuration))\nreturn false;\nShortDuration d = (ShortDuration) o;\nreturn d.getSecs () == this.getSecs();\n}\nwill this work?\n‣ no, now it's not symmetric!\nDuration d1 = new ShortDuration(1,2,3);\nDuration d2 = new Duration(1,2);\nSystem.out.println(d1.equals(d2)); // false\nSystem.out.println(d2.equals(d1)); // true\n(c) Daniel Jackson 2008\n\nbug #4\nyet another attempt\n‣ this time not transitive\n@Override public boolean equals(Object o) {\nif (! (o instanceof Duration)) return false;\nif (! (o instanceof ShortDuration)) return super.equals (o);\nShortDuration d = (ShortDuration) o;\nreturn d.getSecs () == this.getSecs();\n}\nDuration d1 = new ShortDuration(1,2,3);\nDuration d2 = new Duration(1,2);\nDuration d3 = new ShortDuration(1,2,4);\nSystem.out.println(d1.equals(d2)); // true\nSystem.out.println(d2.equals(d3)); // true\nSystem.out.println(d1.equals(d3)); // false!\n(c) Daniel Jackson 2008\n\nsolving the subclassing snag\nno really satisfactory solution\nsuperclass equality rejects subclass objects\n‣ can write this\nif (!o.getClass().equals(getClass())) return false;\n‣ but this is inflexible: can't extend just to add functionality, eg\nbetter solution\n‣ avoid inheritance, and use composition instead\n‣ see Bloch, Effective Java, Item 14\n(c) Daniel Jackson 2008\n\nhash maps\n\nhash map structure\nrepresentation\n‣ array of bucket lists\nclass HashMap <K,V> {\nEntry<K,V>[] table;\nclass Entry<K, V> { K key; V val; Entry<K,V> next; ... }\n(c) Daniel Jackson 2008\nEntry\nk1: K\nv1: V\nEntry\nnext\nkey\nval\nk2: K\nv2: V\nkey\nval\nHashMap\ntable\n\nhash map operations\noperations\n‣ put(k,v): to associate value v with key k\ncompute index i = hash(k)\nhash(k) = k.hashCode & table.length-1 (eg)\nif find entry in table[i] with key equal to k, replace val by v\notherwise add new entry for (k, v)\n‣ get(k): to get value associated with key k\nexamine all entries in table[i] as for insertion\nif find one with key equal to k, return val\nelse return null\nresizing\n‣ if map gets too big, create new array of twice the size and rehash\n(c) Daniel Jackson 2008\n\nhashing principle\nwhy does hashing work?\ne: table[i].*next means e\nranges over set of all entries reachable\nfrom table[i] in zero or more\napplications of next\n‣ rep invariant: entries are in buckets indexed by hash\nall i: table.indexes, e: table[i].*next | hash(e.key) == i\n‣ from object contract: equal keys have equal hashes\nall k, k': Key | k.equals(k') ⇒ hash(k) == hash(k')\n‣ consequence: need only look at one index\nall k: Key, i: table.indexes | i != hash(k) ⇒ all e: table[i].*next | !e.key.equals(k)\n‣ also additional rep invariant: only one entry per key\n‣ consequence: can stop at first match\nfinally, keep buckets to small constant number of entries\n‣ then put and get will be constant time\n(c) Daniel Jackson 2008\n\nmutating keys\nwhat happens if you mutate a hash map's key?\nif equals and hashCode depend only on key's identity\n‣ nothing bad happens\nif equals and hashCode depend on key's fields\n‣ then value of hashCode can change\n‣ rep invariant of hash map is violated\n‣ lookup may fail to find key, even if one exists\nproblem is example of 'abstract aliasing'\n‣ hash map and key are aliased\n(c) Daniel Jackson 2008\n\nexample\nwhat does this print?\npublic class BrokenHash {\n\nstatic class Counter {\n\nint i;\n\nvoid incr () {i++;}\n\n@Override public boolean equals (Object o) {\n\nif (!(o instanceof Counter)) return false;\n\nCounter c = (Counter) o;\nreturn c.i == i;\n\n}\n@Override public int hashCode () {return i;}\n\n}\n\npublic static void main (String[] args) {\n\nSet m = new HashSet <Counter> ();\n\nCounter c = new Counter();\nm.add(c);\n\nSystem.out.println (\"m contains c: \" + (m.contains(c) ? \"yes\" : \"no\"));\nc.incr();\n\n}\nSystem.out.println (\"m contains c: \" + (m.contains(c) ? \"yes\" : \"no\"));\n}\n(c) Daniel Jackson 2008\n\nso what to do?\noption #1 (Liskov)\n‣ equals on mutable types compares references\n‣ no problem with keys, but two sets with same elements are not equal\noption #2 (Java Collections)\n‣ equals on mutable types compares current values\n‣ forbid modification of objects held as keys\n‣ more convenient for comparing collections, but dangerous\nis Java consistent?\n‣ Object contract in Java says\nIt is consistent: for any reference values x and y, multiple invocations of x.equals(y) consistently return true\nor consistently return false, provided no information used in equals comparisons on the object is modified\n(c) Daniel Jackson 2008\n\nnon-determinism\nto iterate over elements of a hash set\n‣ use HashSet.iterator()\n‣ elements yielded in unspecified order\nwhat determines order?\n‣ code iterates over table indices\n‣ so order related to hashing function\n‣ depends on hash code, thus (for mutables) on object addresses\nso this means\n‣ different program runs likely to give different order\n‣ this can be a real nuisance: consider regression testing, for example\n‣ solution: use a TreeSet instead\n(c) Daniel Jackson 2008\n\nsummary\n\nprinciples\nobject heap is a graph\n‣ to understand mutation & aliasing, can't think in terms of values\nequality is user-defined but constrained\n‣ must be consistent and an equivalence\nabstract aliasing complicates\n‣ may even break rep invariant (eg, mutating hash key)\n(c) Daniel Jackson 2008"
    },
    {
      "category": "Resource",
      "title": "Classes",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/fd5cc0db961ce24413c9704851f7c522_MIT6_005f08_lec02.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n(name, retur\nwhich\nClasses\nRob Miller\nFall 2008\n(c) Robert Miller 2008\nReview: How To Write a Method\n/*\n* Returns the contents of the web page identified\n1. Write the method signature\nn type, arguments\n*/\npublic static String fetch(String urlString) {\n* by urlString,\nmust be a valid URL.\n* e.g. fetch(\"http://www.mit.edu\")\n* returns the MIT home page as a string of HTML.\n...\n}\n2. Write a specification (a comment\nthat defines what it returns, any side‐\neffects, and assumptions about the\narguments.\n3. Write the method body so that it conforms to your\nspecification. (Revise the signature or specification if\nyou discover you can't implement it!)\n(c) Robert Miller 2007\nToday's Topics\nobject-oriented programming in Java\n3⁄4exceptions\n3⁄4classes\n3⁄4subclassing\nsubclassing\n(c) Robert Miller 2007\nGetting Data from the Web\nimport java.net.URL;\n/*\nimports the class URL from\nthe java.net package\n* Returns the contents of the web page identified\n* by urlString. e.g. fetch(\"http://www.mit.edu\")\n* returns the MIT home page as a string of HTML.\n*/\npublic static String fetch(String urlString) {\nURL url = new URL(urlString);\n...\n}\nconstructs a new URL object\n(c) Robert Miller 2007\n1. Write the method signature\n(name, return type, arguments\n2. Write a specification (a comment\nthat defines what it returns, any side‐\neffects, and assumptions about the\narguments.\n3. Write the method body so that it conforms to your\nspecification. (Revise the signature or specification if\nyou discover you can't implement it!)\nimports the class URL from\nthe java.net package\nconstructs a new URL object\n\nClasses in Other Packages\nJava classes are arranged in packages\n3⁄4java.lang.String\n3⁄4java.lang.Math\n3⁄4java net URL\njava.net.URL\nImport statements at top of Java file bring in the classes\nyou need\n3⁄4import java.net.URL;\n3⁄4import java.net.*;\n3⁄4java.lang.* package is imported automatically, so we don't have to do this\nwith String or Math,, for exampple\n(c) Robert Miller 2007\nTwo Ways To Deal With Exceptions\npublic static String fetch(String urlString) {\ntry {\nURL url = new URL(urlString);\n...\n} catch (MalformedURLException e) {\ncatch the exception and deal\nwith it\n} catch (MalformedURLException e) {\nSystem.out.println(\"Badly formed URL: \" + urlString);\ne.printStackTrace(); //\nSystem.exit(0);\n}\n}\nExiting the whole program is generally not useful. Catching the exception\nmakes sense when there's something fetch() can do to fix the problem.\npublic static String fetch(String urlString)\nthrows MalformedURLException {\nthrows MalformedURLException {\nURL url = new URL(urlString);\n...\n}\nThis is probably the right thing to do in this\ncase, because it's the caller's fault for passing a\nnonsensical URL. fetch() can't fix it.\ndeclare the exception in the\nmethod signature, so that\nit's passed on to the caller of\nfetch() to deal with it\n(c) Robert Miller 2007\nExceptions\nExceptions are abnormal return conditions from a\nmethod\n3⁄4Instead of returning a value normally, the method throws an exception\n3⁄4Exceptions usually indicate error conditions but not necessarily\nExceptions usually indicate error conditions, but not necessarily\n3⁄4Exceptions are objects. Usually just have a message, but can carry other\ndata as well\nThrowing an exception\n3⁄4throw statement throws an exception object\nthrow new MalformedURLException(\"bad URL:\" + urlString);\n3⁄4throw is like return - the method immediatelysto pps,, but instead of\nreturning a value, it propagates the exception\n(c) Robert Miller 2007\nGetting Data from the Web\npublic static String fetch(String urlString)\nthrows MalformedURLException, IOException {\nURL url = new URL(urlString);\n// open a stream from the web server\n// open a stream from the web server\nInputStream input = url.openStream();\nInputStreamReader reader = new InputStreamReader(input);\n// create a stream that appends data together into a String\nStringWriter writer = new StringWriter();\n// copy from the web server stream to the string stream\n// (defined in a few slides)\n// (defined in a few slides)\ncopyStream(reader, writer);\n// return the string we created\nreturn writer.toString();\n}\n(c) Robert Miller 2007\nExiting the whole program is generally not useful. Catching the exception\nmakes sense when there's something fetch() can do to fix the problem.\nThis is probably the right thing to do in this\ncase, because it's the caller's fault for passing a\nnonsensical URL. fetch() can't fix it.\ndeclare the exception in the\nmethod signature, so that\nit's passed on to the caller of\nfetch() to deal with it\n\nBytes vs. Chars\nByte is an 8-bit value\n3⁄4Older programming systems used 7-bit (ASCII) or 8-bit character sets,\nwhich could represent at most 256 different characters\n3⁄4The multilingualWeb demands a lot more!\n3⁄4The multilingualWeb demands a lot more!\n3⁄4But network connections and files are still generally represented as a\nsequence of 8-bit byte values\n3⁄4java.io.InputStream and java.io.OutputStream are streams of bytes\nChar is a 16-bit value\n3⁄4Java characters are Unicode characters\n3⁄4Unicode is an extension of ASCII), which has thousands of characters\n(including Latin alphabets, Greek, Cyrillic, Chinese/Japanese/Korean\ncharacters, symbols, accents, etc.)\n3⁄4java.lang.String is a sequence of Unicode characters, and java.io.Reader and\njava.io.Writer are streams of Unicode characters\n3⁄4If it's human-readable text, use Unicode; if it's binary data (like an image)\nuse bytes\n(c) Robert Miller 2007\nTry/Finally\npublic static void copyStream(Reader from, Writer to)\nthrows IOException {\ntry {\nchar[] buffer = new char[10000];\n// any size buffer would work, but bigger\n// performs better\nwhile (true) {\nint n = from.read(buffer);\nif (n == -1) break; // at the end of the stream\nto.write(buffer, 0, n);\nwriter.close();\n}\n}\n}\n} finally\nreader.close();\nfinally clause is run no matter how\ncontrol leaves the try block - whether\nby falling out normally or by throwing\nan exception\n{\n(c) Robert Miller 2007\nReading and Writing Streams\n/*\n* Copies all data from the \"from\" stream to\n* the \"to\" stream, then closes both streams.\n* Throws IOException if any error occurs.\n*/\npublic static void copyStream(Reader from, Writer to)\nthrows IOException {\nchar[] buffer = new char[10000];\n// any size buffer would work, but bigger\n// performs better\nwhile (true) {\nint n = from.read(buffer);\nif (n == -1) break; // \"from\" stream is done\nto.write(buffer, 0, n);\n}\nreader.close();\nwriter.close();\n(c) Robert Miller 2007\n}\nIt's important to close the streams to\nmark the end of the stream and free\nup resources. But will the streams\nalways be closed in this code?\nOverloading a Method\npublic static String fetch(String urlString)\nthrows MalformedURLException, IOException {\nURL(urlString);\nURL url = new\nreturn fetch(url);\nOverloaded methods have the\nreturn fetch(url);\n}\npublic static String fetch(URL url)\nthrows IOException {\n// open a connection to the web server\nInputStream input = url.openStream();\nInputStreamReader reader = new InputStreamReader(input);\nOverloaded methods have the\nsame name but different number\nor types of arguments\n...\n}\nJava automatically chooses which overloaded method to call based on the\ntypes of the arguments you give it\nfetch(\"http://www.mit.edu\");\nfetch(new URL(\"http://www.mit.edu\"));\n(c) Robert Miller 2007\nJava automatically chooses which overloaded method to call based on the\ntypes of the arguments you give it\nfinally clause is run no matter how\ncontrol leaves the try block - whether\nby falling out normally or by throwing\nan exception\n\nate U\nu\nfetch(this\nA Class Representing Web Pages\npublic class Page {\nprivate URL url;\nprivate String content;\npublic Page(String urlString) throws MalformedURL... {\nfields are variables stored in\nthe object\npublic Page(String urlString) throws MalformedURL... {\nthis.url = new URL(urlString);\nthis.content = Web.\nconstructors create new objects\n.url);\n}\npublic URL getURL() {\npublic String getContent() {\nreturn this.content;\n}\n}\nreturn this.url;\n}\npublic String getContent\nmethods are functions that\nact on an object\n() {\nthis refers to the object itself in a method or constructor\n(c) Robert Miller 2007\nFinal\nAnother way to control changes to a field\n3⁄4Fields and variables marked final may not be reassigned after initialization\n3⁄4So Page could be kept immutable even if it's public\npublic final URL url;\npublic final URL url;\n3⁄4It's good practice to use final for any variable that shouldn't be reassigned\n(even local variables)\npublic static String fetch(final String urlString) throws ... {\nfinal URL url = new URL(urlString);\nfinal InputStream input = url.openStream();\nfinal InputStreamReader reader = new InputStreamReader(input);\nfinal StringWriter writer = new StringWriter();\n...\n}\n(c) Robert Miller 2007\nAccess Control\n3⁄4public can be used anywhere in the program\npublic URL getURL()\n3⁄4private can be used only in this class\nprivate URL url\np\nAccess control provides greater safety\n3⁄4We want Page to be immutable (never changes once created). What if its\nfields were public?\npublic URL url;\n3⁄4Then it would be possible to change the field anywhere in the program,\nand Page would no longer be immutable\nPage p = new Page(\"http://www.mit.edu\")\np.url = new URL(\"http://www.google.com\");\n3⁄4With private, it's much easier to guarantee that the url is never changed\n(c) Robert Miller 2007\nCaching Pages\nWeb browsers store downloaded pages in a cache\n3⁄4So that they don't have download the page each time it's used\n3⁄4Let's add a cache to the Page class\n/* Returns the cached Page object for url,\n/* Stores page in the cache. */\nprivate static void putPageInCache(Page page) { ... }\nor null if no such Page in the cache. */\nprivate static Page getPageFromCache(URL url) { ... }\nReturning an invalid value (like null) is one\nway to signal an error condition. How else\ncould we have designed this method to\nsignal an error to its caller?\n(c) Robert Miller 2007\nconstructors create new objects\nfields are variables stored in\nthe object\nmethods are functions that\nact on an object\nthis refers to the object itself in a method or constructor\nReturning an invalid value (like null) is one\nway to signal an error condition. How else\ncould we have designed this method to\nsignal an error to its caller?\n\nStatic Fields and Methods\n3⁄4Fields and methods declared static are associated with the class itself,\nrather than an individual object\n- A static field has only one value for the whole program (rather than\none value per object)\n- All objects of the class share that single copy of the static field\n- A static method has no this object\n- Static methods and fields are referenced using the class name (e.g.\nWeb.fetch()) rather than an object variable\n- Some classes are purely containers for static code (e.g. Hailstone,Web,\njava.lang.Math), and no objects of the class are ever constructed\n3⁄4Fields and methods not declared static are called instance fields or\n3⁄4Fields and methods not declared static are called instance fields or\nmethods\n3⁄4static final is commonly used for constants, e.g.:\npublic static final PI = 3.14159;\n(c) Robert Miller 2007\nUsing the Cache\npublic Page(URL url) throws IOException {\nthis.url = url;\nPage p = getPageFromCache(url);\nif (p != null) {\nthis.content = p.content;\n} else {\nthis.content = Web.fetch(url);\nputPageInCache(this);\n}\n}\nImplementing the Cache\nprivate static final Page[] cache = new Page[100];\nprivate static int cachePointer = 0;\n// index of next page to replace in the cache\nprivate static Page getPageFromCache(URL url) {\nfor (Page p : cache) {\nif (p != null && p.getURL().equals(url)) return p;\n}\nreturn null;\nwhy might p be null?\nwhat happens if we don't check?\n// page not found\n}\nprivate static void putPageInCache(Page page) {\ncache[cachePointer] = page;\n++cachePointer;\nif (cachePointer >= cache.length) cachePointer = 0;\n}\n(c) Robert Miller 2007\nSummary\nExceptions\n3⁄4Exceptions are abnormal returns from a method\n3⁄4Exceptions can be caught or declared\nClasses\nClasses\n3⁄4Members (fields, constructors, methods)\n3⁄4Access control (public, protected, private)\n3⁄4Static members\n3⁄4Overloading\n(c) Robert Miller 2007\n(c) Robert Miller 2007\nwhy might p be null?\nwhat happens if we don't check?"
    },
    {
      "category": "Resource",
      "title": "Coding the Photo Organizer",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/536852e935745fdafa966f405cea7916_MIT6_005f08_lec19.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n6.005\nelements of\nsoftware\nconstruction\ncoding the photo organizer\nDaniel Jackson\n\ntopics for today\nhow to implement an object model\n‣ key idea: transform to allocate state\n‣ basic patterns\n‣ navigation direction\n‣ derived components\n‣ maintaining invariants\n(c) Daniel Jackson 2008\n\nstarting point: object model\nAlbum\nUserDefined\nsubs\nPhoto\ninserted,\nphotos\nRoot\nSelected\nImage\n!\nName\nname\n!\n!\nFile\n!\n?\nfile\nimage\n?\nadditional constraints\n‣ all albums reachable from root (implies acyclic)\nAlbum in Root.*subs\n‣ implicit photos are inserted photos plus photos in subalbums\nall a: Album | a.photos = a.inserted + a.subs.photos\nchanges\n‣ globally unique names; added File; renamed Collection to Album\n(c) Daniel Jackson 2008\n\nimplementing the OM\n\nbasic strategy\nobject model can be implemented in many ways\n‣ key issue: where state resides\neg, where does relation from A to B go?\n‣ inside A object, or inside B object\n‣ or inside a new singleton C object, as Map<A,B>\n‣ or nowhere: compute on-the-fly\nconsiderations\n‣ ease & efficiency of navigation\n‣ multiplicity (might call for collections)\n‣ minimizing memory usage\n‣ exploiting immutability\n‣ minimizing dependences\n(c) Daniel Jackson 2008\n\nimplementing sets\ntop-level sets become classes\n‣ set as class: class Album {...}, class Photo {...}\n‣ set as built-in class: Name as String\nsubset patterns\n‣ subset as boolean field: class Photo {boolean selected;}\n‣ subset as singleton set: class Catalog {Set<Photo> selected;}\nclass Catalog {Album root;}\nstatic subset patterns\n‣ classification of object does not change over time\n‣ subset as subclass: class Root extends Album {...}\n(c) Daniel Jackson 2008\n\nexample: Selected\nPhoto\nSelected\nSet\nCatalog\nelts\n!\nPhoto\nselected\nOR\nPhoto\nBoolean\nisSelected\n!\n(c) Daniel Jackson 2008\n\nexample: Root\nAlbum\nRoot\nOR\nAlbum\nCatalog\n!\nroot\nAlbum\nRoot\n(c) Daniel Jackson 2008\n\nimplementing relations\nbasic patterns (function)\n‣ relation as field: class Album {Name name;}\n‣ relation as map: class Catalog {Map<Album, Name> name;}\nbasic patterns (one-to-many)\n‣ relation as field: class Album {Set<Album> subs;}\n‣ relation as map: class Catalog {Map<Album, Set<Album>> subs;}\nhow to choose?\n‣ efficiency: relation as field uses marginally less time and space\n‣ immutability: relation as map is preferable if Album otherwise immutable\n‣ encapsulation: choose so that OM invariant can be a rep invariant\n(c) Daniel Jackson 2008\n\nexample: name\nOR\nAlbum\n!\nName\nname\n?\nAlbum\n!\nString\nname\n?\nAlbum\nString\nCatalog\nMap\nEntry\nnamemap\n!\nentries\nkey\nval\n!\n!\n?\n?\n(c) Daniel Jackson 2008\n\nexample: subs\nAlbum\nUserDefined\n!\nsubs\nOR\nAlbum\nSet\nsubs\n!\n?\nelts\nAlbum\nSet\nCatalog\nMap\nEntry\nsubMap\n!\nentries\nkey\nval\n!\n!\n?\n?\nelts\nAlbum\nCatalog\nMap\nEntry\nparentMap\n!\nentries\nkey\nval\n!\n!\n?\n?\nOR\n(c) Daniel Jackson 2008\n\nrelation direction\nnavigation direction\n‣ direction of relation in object model is semantic\n‣ navigation direction depends on operations\n‣ for relation R: can implement R, transpose of R, or both\nimplementation must support navigation\n‣ consider inserted: Album -> Photo and operation add (a, p)\n‣ relation as field: class Album {Set<Album> insertedPhotos;}\nor class Photo {Set<Collection> insertedInto;}\n‣ relation as map: class Catalog {Map<Album, Set<Photo>> insertedPhotos;}\nor class Catalog {Map<Photo, Set<Album>> insertedInto;}\n‣ for basic add operation, implementing as Album -> Photo is fine\n‣ but if add operation removes photo from other collections,\nwill want both directions\n(c) Daniel Jackson 2008\n\nderived components\nderived component\n‣ a set or relation that can be derived from others\n‣ OM invariant has the form x = ...\nin this case\n‣ can choose not to implement at all!\n‣ instead, construct value when needed\nexamples\n‣ UserDefined = Album - Root\nso to determine if a in UserDefined, can just check a == Root\n‣ all a: Album | a.photos = a.inserted + a.subs.photos\nso can compute photos set for given a by traversing subcollections\n(c) Daniel Jackson 2008\n\nmaintaining OM invariants\nOM invariants\n‣ called \"integrity constraints\" for databases\n‣ become rep invariants or invariants across classes\nto maintain\n‣ reject inputs that might break invariant (eg, duplicate name for collection)\n‣ or compensate for bad input (eg, modify name to make it unique)\nto check\n‣ insert repCheck methods and assertions for cross-class invariants\n(c) Daniel Jackson 2008\n\ndecisions made\nin implementing the photo organizer, we chose\n‣ subset as boolean field for Selected (in Thumbnail class)\n‣ relation as field for name (in Album class), since the relation is immutable\n‣ relation as map for subs and inserted (in Catalog class)\n‣ to implement subs in the direction of child to parent\n(so getChildren method has to iterate-and-check to find children)\n‣ to compute UserDefined and photos on the fly\n(c) Daniel Jackson 2008\n\nthumbnails\narchitecture of GUI may influence decisions\n‣ regard selection and images as part of view, not model\n‣ and want to avoid back-dependences of model on view\nPhoto\nSelected\nImage\n!\nFile\n!\n?\nfile\nimage\nPhoto\nFile\n!\nfile\nList\nPreviewPane\nthumbnails\nThumbnail\nelts\nImage\n!\nimage\nBoolean\nisSelected\n!\nphoto\n!\n?\n?\n!\n?\n(c) Daniel Jackson 2008\n\nfinal code: catalog, album, etc\npublic class Catalog {\n\nprivate static final String ROOTNAME = \"all photos\";\n\n// root album, cannot be deleted\n\nprivate final Album root;\n\n// map from child album to parent\n\nprivate final Map<Album, Album> parent;\n\n// map from albums to photos that were explicitly inserted into them\n\nprivate final Map<Album, Set<Photo>> inserted;\n}\npublic final class Album {\n\nprivate String name;\n}\npublic class Photo {\n\nprivate final File file;\n}\n(c) Daniel Jackson 2008\n\nfinal code: selected, etc\npublic class PreviewPane extends JScrollPane {\n\nprivate JPanel content;\n\nprivate List<Thumbnail> thumbnails;\n}\npublic class Thumbnail extends JComponent {\n\npublic static final int THUMBNAIL_SIZE = 150;\n\nprivate Photo photo;\n\n// the loaded, displayable thumbnail image\n\nprivate BufferedImage bufferedImage;\n\nprivate int width;\n\nprivate int height;\n\nprivate boolean isSelected;\n\n(c) Daniel Jackson 2008\n\ncatalog rep invariant\n\nprivate void checkRep() {\n\n/*\n\n* 1) All fields are non-null\n\n* 2) The root has no parent; all other albums have one parent\n\n* all a: albums | parent.get(a) == null iff a == root\n\n* 3) Each album has a unique name\n\n* all a1, a2: albums | a1.equals(a2) or !a1.getName().equals(a2.getName())\n\n* 4) Map of inserted photos has all albums as keys\n\n* inserted.keySet() = parent.keySet() + root\n\n*\nwhere albums is the set of Album objects that are keys or values in the parent map\n\n*/\n\n// checking rep (1)\n\nassert root != null: \"root cannot be null!\";\n\nassert parent != null: \"parent cannot be null!\";\n\nassert inserted != null: \"inserted cannot be null!\";\n\n// checking rep (2,4)\n\nassert parent.get(root) == null: \"Root cannot have a parent!\";\n\nSet<Album> a1 = new HashSet<Album>(inserted.keySet());\n\nSet<Album> a2 = new HashSet<Album>(parent.keySet());\n\na2.add(root);\n\nassert a1.equals(a2) : \"Inconsistent album sets!\";\n\n// checking rep (3)\n\nSet<Album> x = new HashSet<Album>(inserted.keySet());\n\nfor (Album a: x) {\n\nfor (Album d: x) {\n\nassert (a == d || !a.getName().equals(d.getName())):\n\n\"Albums exist with duplicate names\";\n\n}\n\n}\n(c) Daniel Jackson 2008\n\n}\n\nsummary: principles\nkeep abstract model abstract\n‣ relations are conceptual; no containment notion\nimplementation is OM transformation\n‣ from abstract to code object model\n‣ key decision: where state should reside\nconsider all criteria\n‣ use built-in collections when possible\n‣ consider navigation, encapsulation, immutability\n(c) Daniel Jackson 2008"
    },
    {
      "category": "Resource",
      "title": "Conclusion",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/1bb173ac0fc980981d33851b7de8af6b_MIT6_005f08_lec23.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n-\nConclusion\nDaniel Jackson & Rob Miller\nFall 2008\nWhat You've Learned in 6.005\nthink first, then code\n3⁄4abstracting a real-world problem into a model\n- State machine paradigm: state machine, grammar\n- Symbolic paradigm: datatypes and operations\nSymbolic paradigm: datatypes and operations\n- Relational paradigm: object model\n3⁄4applying design patterns to translate models into code\nhow to create good software\n3⁄4easy to understand\n3⁄4safe from bugs\n3⁄4ready for change\nready for change\nsoftware engineering literacy\n3⁄4Java\n3⁄4MIDI, URL, HTTP, maps, lists, sets, streams, SAT, threads, queues, sockets,\nclient/server, GUI, SQL\n3⁄4Subversion, Eclipse, JUnit, code coverage, dependence diagrams\nToday\nconclusion\n3⁄4take-away messages\n3⁄4what to do next\nproject 3 awards\n6.005 quiz game\nHKN evaluations\nHKN evaluations\nWhat to Do Next\nSpring\n3⁄46.813/6.831 User Interface Design & Implementation\n3⁄46.035 Computer Language Engineering\nIAP\n3⁄46.370 IAP Programming Competition\n3⁄46.470 IAP Web Programming Competition\nFall\n3⁄46 197 P\nf\nE\ni\ni\n3⁄46.197 Performance Engineering"
    },
    {
      "category": "Resource",
      "title": "Concurrency",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/af4002ad05326362dc3788fce9a33e2d_MIT6_005f08_lec20.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n11/16/2008\nConcurrency\nRob Miller\nFall 2008\n(c) Robert Miller 2008\nConcurrency\nMultiple computations running at the same time\n3⁄4Concurrency is everywhere, whether we like it or not\nMemory\n3⁄4Concurrency is useful, too\nNetwork\nMultiple processors in a computer\n(or multiple cores in a single chip)\nMultiple computers in a network\ny\n,\n- Splitting up a computation into concurrent pieces is often faster\n- Many apps must handle multiple simultaneous users (e.g. web sites)\n- Even single-user applications are better with concurrency (e.g. Eclipse\ncompiling your Java code in the background while you're editing it)\n(c) Robert Miller 2008\nModels for Concurrent Programming\nShared Memory\n3⁄4Analogy: two processors in a computer, sharing the same physical memory\nConcurrent modules A and B\nMessage Passing\n3⁄4Analogy: two computers in a network communicating by network\nA\nB\nShared memory\ninteract by reading & writing shared\nstate in memory\n3⁄4Analogy: two computers in a network, communicating by network\nconnections\nA\nB\nA and B interact by sending\nmessages to each other through\na communication channel\n(c) Robert Miller 2008\nShared Memory Example\nFour customers using cash machines simultaneously\n3⁄4Shared memory model - each cash machine reads and writes the account\nbalance directly\nA\nB\nC\nD\nCash\nmachines\ndeposit $100\nto account 1\nwithdraw $100\nfrom account 2\ndeposit $100\nto account 1\nget balance\nof account 1\nShared memory\nBank\n$50\n$200\n$50\naccount 1\naccount 2\naccount 3\n(c) Robert Miller 2008\n\n11/16/2008\nRace Condition\nSuppose A and C run at the same time\nget balance\n$50\nadd deposit\n+ $100\nwrite back total\n$150\nget balance\n$50\nadd deposit\n+ $100\nwrite back total\n$150\nA\nC\n3⁄4Neither answer is right!\nThis is an example of a race condition\n3⁄4A race condition means that the correctness of the program depends on\nthe relative timing of events in concurrent computations\n- \"A is in a race with C\"\n3⁄4 Some interleavings of events may be OK, e.g.:\nbut other interleavings produce wrong answers\nget balance\n$50\nadd deposit\n+ $100\nwrite back total\n$150\nA\nbut other interleavings produce wrong answers\nCorrectness of a concurrent\nprogram should not depend on\naccidents of timing\n3⁄4Race conditions are nasty bugs -- may be rarely observed, hard to\nreproduce, hard to debug, but may have very serious effects\nget balance\n$150\nadd deposit\n+ $100\nwrite back total\n$250\nC\n(c) Robert Miller 2008\nSynchronization\nA and C need to synchronize with each other\n3⁄4Locks are a common synchronization mechanism\n3⁄4Holding a lock means \"I'm changing this; don't touch it right now\"\n3⁄4Suppose C acquires the lock first; then A must wait to read and write the\n3⁄4Suppose C acquires the lock first; then A must wait to read and write the\nbalance until C finishes and releases the lock\n3⁄4Ensures that A and C are synchronized, but B can run independently on a\ndifferent account (with a different lock)\nA\nB\nC\nD\nCash\nmachines\nShared memory\nBank\n$50\n$200\n$50\naccount 1\naccount 2\naccount 3\nC\nB\n(free)\nwaiting for lock\nwaiting for lock\nlock holder\n(c) Robert Miller 2008\nDeadlocks\nSuppose A and B are making simultaneous transfers\n3⁄4A transfer between accounts needs to lock both accounts, so that money\ncan't disappear from the system\n3⁄4A and B each acquire the lock on the \"from\" account\n3⁄4A and B each acquire the lock on the from account\n3⁄4Now each must wait for the other to give up the lock on the \"to\" account\n3⁄4Stalemate! A and B are frozen,\nand the accounts are locked up.\n\"Deadly embrace\"\n3⁄4Deadlock occurs when concurrent\nmodules are stuck waiting for each\nA\nB\ntransfer $100\nfrom account 1\nto account 2\ntransfer $200\nfrom account 2\nto account 1\nother to do something\n3⁄4A deadlock may involve more than\ntwo modules (e.g., a cycle of\ntransfers among N accounts)\n3⁄4You can have deadlock without\nusing locks - example later\nShared\nmemory\naccount 1\naccount 2\nA\nB\n(c) Robert Miller 2008\nLock Granularity\nPreventing the deadlock\n3⁄4One solution is to change the locking granularity - e.g. use one lock on\nthe entire bank, instead of a lock on each account\nChoosing lock granularity is hard\n$50\n$200\n$50\n$50\n$200\n$50\none lock per account\none lock for the whole bank\ng\ng\ny\n3⁄4If locking is too coarse, then you lose concurrency (e.g. only one cash\nmachine can run at a time)\n3⁄4If locking is too fine, then you get race conditions and/or deadlocks\n3⁄4Easy to get this wrong\n(c) Robert Miller 2008\n\n11/16/2008\nMessage Passing Example\nModules interact by sending messages to each other\n3⁄4Incoming requests are placed in a queue to be handled one at a time\n3⁄4Sender doesn't stop working while waiting for an answer to its request; it\nhandles more requests from its own queue\nhandles more requests from its own queue\n3⁄4Reply eventually comes back as another message\nA\nB\nC\nD\ndeposit $100\nto account 1\nwithdraw $100\nfrom account 2\ndeposit $100\nto account 1\nget balance\nof account 1\nget bal\nAccount 1\nbal: $50\nAccount 2\nbal: $200\nAccount 3\nbal: $50\ndep $100\ndep $100\nwdrw $100\ng\nqueue for\nAccount 1\nAccounts are\nnow modules,\nnot just memory locations\n(c) Robert Miller 2008\nMessage Passing Has the Same Risks\nMessage passing doesn't eliminate race conditions\n3⁄4Suppose the account state machine supports get-balance and withdraw\noperations (with corresponding messages)\n3⁄4Can Alice and Bob always stay out of the OVERDRAWN state?\n3⁄4Can Alice and Bob always stay out of the OVERDRAWN state?\nAlice\nBob\nget-balance\nif balance > $75,\nwithdraw $75\nget-balance\nif balance > $50,\nwithdraw $50\nAccount\nb l $100\nOK\nOVERDRAWN\nwithdraw\nwithdraw\nget-\nbalance\n3⁄4Lesson: need to carefully choose the atomic (indivisible) operations of the\nstate machine - withdraw-if-sufficient-funds would be better\nMessage-passing can have deadlocks too\n3⁄4Particularly when using finite queues that can fill up\nbal: $100\nbalance\n(c) Robert Miller 2008\nConcurrency Is Hard to Test\nPoor coverage\n3⁄4Recall our notions of coverage\n- all states, all transitions, or all paths through a state machine\n3⁄4Given two concurrent state machines (with N states and M states) the\n3⁄4Given two concurrent state machines (with N states and M states), the\ncombined system has N x M states (and many more transitions and paths)\n3⁄4As concurrency increases, the state space explodes, and achieving sufficient\ncoverage becomes infeasible\nPoor reproducibility\n3⁄4Transitions are nondeterministic, depending on relative timing of events\nthat are strongly influenced by the environment\n- Delays can be caused by other running programs, other network traffic,\noperating system scheduling decisions, variations in processor clock\nspeed, etc.\n3⁄4Test driver can't possibly control all these factors\n3⁄4So even if state coverage were feasible, the test driver can't reliably\nreproduce particular paths through the combined state machine\n(c) Robert Miller 2008\nUse Message Passing in 6.005\nWe'll focus on message passing, not shared memory\n3⁄4Locking strategy for shared-memory paradigm is hard to get right\n3⁄4Message-passing paradigm often aligns directly with the real-world\nworkflow of a problem\nworkflow of a problem\n3⁄4But message passing is less suited to some problems, e.g. a big shared data\nstructure\n(c) Robert Miller 2008\n\n11/16/2008\nThreads\n3⁄4A thread is a locus of control (i.e. program counter + stack, representing\na position in a running program)\n- Simulates a fresh processor running the same program in a different\nplace\n3⁄4A process always has at least one thread (the main thread)\n3⁄4Threads can share any memory in the process, as long as they can get a\nreference to it\n3⁄4Threads must set up message passing explicitly (e.g. by creating queues)\nProcess\nT1\nT2\nShared\nmemory\n(c) Robert Miller 2007\nTime Slicing\nHow can I have many concurrent threads with only one\nor two processors in my computer?\n3⁄4When there are more threads than processors, concurrency is simulated\nby time slicing (processor switches between threads)\nby time slicing (processor switches between threads)\n3⁄4Time slicing happens unpredictably and nondeterministically\nT1\nT2\nT3\nT1\nT2\nT3\nT1\nT2\na thread may\nbe paused and\nresumed at\nany time\n(c) Robert Miller 2007\nThreads in Java\nA thread is represented by java.lang.Thread object\n3⁄4To define a thread, either override Thread or implement Runnable\nT1 extends Thread R1 implements Runnable\nThread lifecycle\nThread lifecycle\n3⁄4Starting arguments can be given to the constructor\nnew T1(arg1, ...) new Thread(new R1(arg1, ...))\n3⁄4Thread is spawned by calling its start() method\n3⁄4New thread starts its life by calling its own run() method\n3⁄4Thread dies when run() returns or throws an uncaught exception\n(c) Robert Miller 2007\nMessage Passing with Threads\nUse a synchronized queue for message-passing between\nthreads\n3⁄4interface java.util.concurrent.BlockingQueue is such a queue\nt\nT1\nT2\nput\ntake\nSOME\nFULL\nT3\nput\nput\nput\ntake\ntake\nput\ntake\nEMPTY\nno take transition in EMPTY state, so a\nthread that tries to take from an empty\n3⁄4ArrayBlockingQueue is a fixed-size queue that uses an array representation\n3⁄4LinkedBlockingQueue is a growable queue (no FULL state) using a linked-\nlist representation\n(c) Robert Miller 2007\nthread that tries to take from an empty\nqueue must block (wait) until it can\n\n11/16/2008\nCase Study: Photo Organizer\nWhat happens when the UI displays a large album?\n(c) Robert Miller 2008\nMouse and keyboard events are accumulated in an\nevent queue\n3⁄4Event loop reads an input event from the queue and dispatches it to\nlisteners on the view hierarchy\nConcurrency in GUIs\nlisteners on the view hierarchy\n3⁄4In Java, the event loop runs on a special event-handling thread, started\nautomatically when a user interface object is created\nSwing event-handling thread\nMouse\nKeyboard\nevent queue\nEvent loop\nview hierarchy\nKeyboard\nevent queue\nmain thread\nMain\n(c) Robert Miller 2007\nJava Swing Is Not Threadsafe\nThe view hierarchy is a big meatball of shared state\n3⁄4And there's no lock protecting it at all\n3⁄4It's OK to access user interface objects from the event-handling thread\n(i.e., in response to input events)\n(i.e., in response to input events)\n3⁄4But the Swing specification forbids touching - reading or writing - any\nComponent objects from a different thread\n- See \"Threads and Swing\",\nhttp://java.sun.com/products/jfc/tsc/articles/threads/threads1.html\n- The truth is that Swing's implementation does have one big lock\n(Component.getTreeLock()) but only some Swing methods use it (e.g.\nlayout)\nlayout)\n(c) Robert Miller 2007\nMessage Passing Via the Event Queue\nThe event queue is also a message-passing queue\n3⁄4To access or update Swing objects from a different thread, you can put a\nmessage (represented as a Runnable object) on the event queue\nSwingUtilities.invokeLater(new Runnable() {\nSwingUtilities.invokeLater(new Runnable() {\npublic void run() { content.add(thumbnail); ...} });\n3⁄4The event loop handles one of these pseudo-events by calling run()\nSwing thread\nMouse\nKeyboard\nevent queue\nEvent loop\nKeyboard\nmain thread\nmain()\ndisplay thread\nDisplayThread\n(c) Robert Miller 2007\n\n11/16/2008\nThread Safety\nBlockingQueue is itself a shared state machine\n3⁄4But it's OK to use from multiple threads because it has an internal lock\nthat prevents race conditions within the state machine itself\n- So state transitions are guaranteed to be atomic\nSo state transitions are guaranteed to be atomic\n- This is done by the Java synchronized keyword\nSwing thread\nBlockingQueue\nBlockingQueue interface\nEMPTY\nSOME\nFULL\nput\nput\nput\ntake\nput\n3⁄4BlockingQueue is therefore thread-safe (able to be called by multiple\nthreads safely without threat to its invariants)\n3⁄4HashSet is not thread-safe; neither is the Swing view hierarchy\nDisplayThread\ntake\ntake\ntake\ntake\n(c) Robert Miller 2007\nOther Thread-Safe Classes\nLists, Sets, and Maps can be made thread-safe by a\nwrapper function\n3⁄4t = Collections.synchronizedSet(s) returns a thread-safe version of set s,\nwith a lock that prevents more than one thread from entering it at a time,\nwith a lock that prevents more than one thread from entering it at a time,\nforcing the others to block until the lock is free\n3⁄4So we could imagine synchronizing all our sets:\nthumbnails = Collections.synchronizedSet(new HashSet<Thumbnail> ());\nThis doesn't fix all race conditions!\n3⁄4Doesn't help preserve invariants involving more than one data structure\nthumbnails.add(t);\nthese operations need to be atomic together to avoid\ncontent.add(t);\n(c) Robert Miller 2007\nthese operations need to be atomic together, to avoid\nbreaking the rep invariant of PreviewPane\n(that all thumbnails are children of content)\nMore Thread-Safe Classes\nObjects that never change state are usually* thread-safe\nINIT\na, b, c, ...\nall possible actions\n3⁄4 Immutable objects never change state\n- e.g., java.lang.String is immutable, so threads can share strings as much\nas they like without fear of race conditions, and without any need for\nlocks or queues\np\non the object\n* Caveat: some apparently immutable objects may have hidden state: e.g.\nmemoizing (caching) method return values.\n(c) Robert Miller 2007\nSummary\nConcurrency\n3⁄4Multiple computations running simultaneously\nShared-memory & message-passing paradigms\n3⁄4Sh\nd\nd\nh\ni\ni\nh\ni\nlik l\nk\n3⁄4Shared memory needs a synchronization mechanism, like locks\n3⁄4Message passing synchronizes on communication channels, like queues\nPitfalls\n3⁄4Race when correctness of result depends on relative timing of events\n3⁄4Deadlock when concurrent modules get stuck waiting for each other\nDesign advice\n3⁄4Share only immutable objects between threads\n3⁄4Use blocking queues and SwingUtilities.invokeLater()\n(c) Robert Miller 2008"
    },
    {
      "category": "Resource",
      "title": "Debugging",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/bc46bea8117369edefd494fcb834e3a3_MIT6_005f08_lec12.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n10/15/2008\nDebugging\nRob Miller\nFall 2008\n(c) Robert Miller 2008\nToday's Topics\nhow to avoid debugging\n3⁄4assertions\n3⁄4code reviews\nhow to do it when you have to\n3⁄4reducing test cases\n3⁄4hypothesis-driven debugging\n3⁄4binary search\nvery hard bugs\nvery hard bugs\n3⁄4Heisenbugs\n(c) Robert Miller 2008\nDefensive Programming\nfirst defense against bugs is to make them impossible\n3⁄4Java makes buffer overflow bugs impossible\nsecond defense against bugs is to not make them\n3⁄4\nhi\ni h fi\ni\n3⁄4correctness: get things right first time\nthird defense is to make bugs easy to find\n3⁄4local visibility of errors: if things fail, we'd rather they fail loudly and\nimmediately - e.g. with assertions\nfourth defense is extensive testing\n3⁄4uncover as many bugs as possible\nl\ni d b\ni\nlast resort is debugging\n3⁄4needed when effect of bug is distant from cause\n(c) Robert Miller 2008\nFirst Defense: Impossible By Design\nin the language\n3⁄4automatic array bounds checking make buffer overflow bugs impossible\n3⁄4static typing eliminates many runtime type errors\nin the protocols/libraries/modules\nin the protocols/libraries/modules\n3⁄4TCP/IP guarantees that data is not reordered\n3⁄4BigInteger guarantees that there will be no overflow\nin self-imposed conventions\n3⁄4immutable objects can be passed around and shared without fear\n3⁄4caution: you have to keep the discipline\nt th l\nt\nh l\nh\nibl\nith\ni\nt\nd\n- get the language to help you as much as possible , e.g. with private and\nfinal\n(c) Robert Miller 2008\n\n10/15/2008\nSecond Defense: Correctness\nget things right the first time\n3⁄4don't code before you think! Think before you code.\n- do your thinking in design; use a pattern to map that design to code\nespecially true when debugging is going to be hard\nespecially true when debugging is going to be hard\n3⁄4concurrency\nsimplicity is key\n3⁄4modularity\n- divide program into chunks that are easy to understand\n- use abstract data types with well-defined interfaces\nid\n- avoid rep exposure\n3⁄4specification\n- write specs for all modules, so that an explicit, well-defined contract\nexists between each module and its client\n(c) Robert Miller 2008\nThird Defense: Immediate Visibility\nif we can't prevent bugs, we can try to localize them to\na small part of the program\n3⁄4fail fast: the earlier a problem is observed, the easier it is to fix\n3⁄4assertions: catch bugs early before failure has a chance to contaminate (and\n3⁄4assertions: catch bugs early, before failure has a chance to contaminate (and\nbe obscured by) further computation\n- in Java: assert boolean-expression\n- note that you must enable assertions with -ea\n3⁄4unit testing: when you test a module in isolation, you can be confident that\nany bug you find is in that unit (or in the test driver)\n3⁄4regression testing: run tests as often as possible when changing code.\n- if a test fails, the bug is probably in the code you just changed\nwhen localized to a single method or small module,\nbugs can be found simply by studying the program text\n(c) Robert Miller 2008\nExample: Assertions\n/*\n* Returns n!, the number of permutations of n objects.\n* n must be nonnegative.\n*/\npublic static int fact(int n) {\nwhere would\npublic static int fact(int n) {\nif (n == 0) return 1;\nelse return n * fact(n-1);\n}\n/*\n* Returns (n choose k), the number of distinct subsets\n* of size k in a set of size n.\n* Requires 0 <= k <= n\nwhere would\nassertions be\nusefully added\nto this code?\n* Requires 0 <= k <= n.\n*/\npublic static int combinations(int n, int k) {\nreturn fact(n) / (fact(k) * fact(n-k));\n}\n(c) Robert Miller 2008\nCode Review\nother eyes looking at the code can find bugs\ncode review\n3⁄4\nf l\ni\nd\nf\nd b\nh\n(\ni i\nl\nh\n)\n3⁄4careful, systematic study of source code by others (not original author)\n3⁄4analogous to proofreading an English paper\n3⁄4look for bugs, poor style, design problems, etc.\n3⁄4formal inspection: several people read code separately, then meet to\ndiscuss it\n3⁄4lightweight methods: over-the-shoulder walkthrough, or by email\n3⁄4many dev groups require a code review before commit\ny\ng\np\nq\ncode review complements other techniques\n3⁄4code reviews can find many bugs cheaply\n3⁄4also test the understandability and maintainability of the code\n3⁄4three proven techniques for reducing bugs: reasoning, code reviews,\ntesting\n(c) Robert Miller 2008\n\n10/15/2008\nLet's Review Some Code\npublic class PigLatin {\nstatic String[] words;\npublic static String toPigLatin(String s) {\nwords = s.split(\" \");\nString result = \"\";\nfor (int i = 0; i <= words.length; ++i) {\npiggify(i);\nresult += words[i];\n}\nreturn result;\n}\npublic static void piggify(int i) {\nif (words[i].startsWith(\"a\") || words[i].startsWith(\"e\") || ...) {\nwords[i] += \"yay\";\n} else {\nwords[i] = words[i].substring(1);\nwords[i] += words[i].charAt(0) + \"ay\";\n}\n}\n}\n(c) Robert Miller 2008\nHow to Debug\n1) reproduce the bug with a small test case\n3⁄4find a small, repeatable test case that produces the failure (may take effort,\nbut helps clarify the bug, and also gives you something for regression)\n3⁄4don't move on to next step until you have a repeatable test\n3⁄4don t move on to next step until you have a repeatable test\n2) find the cause\n3⁄4narrow down location and proximate cause\n3⁄4study the data / hypothesize / experiment / repeat\n3⁄4may change code to get more information\n3⁄4don't move on to next step until you understand the cause\n3) fix the bug\n3) fix the bug\n3⁄4is it a simple typo, or is it a design flaw? does it occur elsewhere?\n4) add test case to regression tests\n3⁄4then run regression tests to ensure that the bug appears to be fixed, and\nno new bugs have been introduced by the fix\n(c) Robert Miller 2008\nReducing to a Simple Test Case\nfind simplest input that will provoke bug\n3⁄4usually not the input that originally revealed existence of the bug\n3⁄4start with data that revealed bug\n3⁄4keep paring it down (binary search can help)\n3⁄4keep paring it down (binary search can help)\n3⁄4often leads directly to an understanding of the cause\nsame idea is useful at many levels of a system\n3⁄4method arguments\n3⁄4input files\n3⁄4keystrokes and mouse clicks in a GUI\n(c) Robert Miller 2008\nExample\n/**\n* Returns true if and only if s contains t as a substring,\n* e.g. contains(\"hello world\", \"world\") == true.\n*/\npublic static boolean contains(String s, String t) { ... }\npublic static boolean contains(String s, String t) { ... }\n3⁄4a user discovers that\ncontains(\"Life is wonderful! I am so very very happy all the time\",\n\"very happy\")\nincorrectly returns false\nwrong approach:\ng pp\n3⁄4try to trace the execution of contains() for this test case\nright approach:\n3⁄4first try to reduce the size of the test case\n3⁄4even better: bracket the bug with a test case that fails and similar test cases\nthat succeed\n(c) Robert Miller 2008\n\n10/15/2008\nCode for contains()\n/**\n* Returns true if and only if s contains t as a substring,\n* e.g. contains(\"hello world\", \"world\") == true.\n*/\npublic static boolean contains(String s, String t) {\npublic static boolean contains(String s, String t) {\nsearch:\nfor (int i = 0; i < s.length(); ++i) {\nfor (int j = 0; j < t.length(); ++j, ++i) {\nif (s.charAt(i) != t.charAt(j)) continue search;\n}\nreturn true;\n}\nreturn false;\nreturn false;\n}\n(c) Robert Miller 2008\nFinding the Cause\nexploit modularity\n3⁄4start with everything, take away pieces until bug goes\n3⁄4start with nothing, add pieces back in until bug appears\ntake advantage of modular reasoning\ntake advantage of modular reasoning\n3⁄4trace through program, viewing intermediate results\n3⁄4insert assertions targeted at the bug\n3⁄4design all data structures to be printable (i.e., implement toString())\n3⁄4println is a surprisingly useful and universal tool\n- in large systems, use a logging infrastructure instead of println\nuse binary search to speed things up\nuse binary search to speed things up\n3⁄4bug happens somewhere between first and last statement\n3⁄4so do binary search on the ordered set of statements\n(c) Robert Miller 2008\nExample: Finding a Sudoku Bug\nsuppose a Sudoku solver produces the wrong answer\nSudoku\nsolver\n3....\n......\n7....\n......\nsolver\n......\n......\nparse\ninput\nmake SAT\nformula\nSAT\nsolver\ninterpret\nassignment\nprint\noutput\n(c) Robert Miller 2008\nNote that this isn't a state machine diagram or a module dependence diagram; it\nshows data flow, which is often useful for thinking about bugs.\nRegression Testing\nwhenever you find and fix a bug\n3⁄4store the input that elicited the bug\n3⁄4store the correct output\n3⁄4add it to your test suite\n3⁄4add it to your test suite\nwhy regression tests help\n3⁄4helps to populate test suite with good test cases\n- remember that a test is good if it elicits a bug - and every regression\ntest did in one version of your code\n3⁄4protects against reversions that reintroduce bug\n3⁄4the bug may be an easy error to make (since it happened once already)\ng\ny\ny\n(\npp\ny)\ntest-first debugging\n3⁄4when a bug arises, immediately write a test case for it that elicits it\n3⁄4once you find and fix the bug, the test case will pass, and you'll be done\n(c) Robert Miller 2008\n\n10/15/2008\nThe Ugliest Bugs\nwe've had it easy so far\n3⁄4sequential, deterministic programs have repeatable bugs\nbut the real world is not that nice...\n3⁄4 i i\nd\nd\ni\n3⁄4timing dependencies\n3⁄4unpredictable network delays\n3⁄4varying processor loads\n3⁄4concurrency\nheisenbugs\n3⁄4nondeterministic, hard to reproduce\n3⁄4\ndi\nh\nt\nt\nl\nk t it\nith\ni tl\nd b\n!\n3⁄4may even disappear when you try to look at it with println or debugger!\none approach\n3⁄4build a lightweight event log (circular buffer)\n3⁄4log events during execution of program as it runs at speed\n3⁄4when you detect the error, stop program and examine logs\n(c) Robert Miller 2008\nExample of a heisenbug\npublic class Bank {\nint balance;\npublic Bank(int balance) {\nthis.balance = balance;\nthis.balance\nbalance;\n}\npublic void deposit(int amount) {\nbalance += amount;\n}\npublic void withdraw(int amount) {\nbalance\n= amount;\nbalance -= amount;\n}\npublic int getBalance() {\nreturn balance;\n}\n}\n(c) Robert Miller 2008\nExample of a heisenbug\n// our bank account starts with $100\nfinal Bank account = new Bank(100);\n// start a bunch of threads\nList<Thread> threads = new ArrayList<Thread>();\nfor (int i = 0; i < 10; ++i) {\nfor (int i 0; i < 10; ++i) {\nThread t = new Thread(new Runnable() {\npublic void run() {\n// each thread does a bunch of bank transactions\nfor (int i = 0; i < 10000; ++i) {\naccount.deposit(1); // put a dollar in\naccount.withdraw(1); // take it back out\n}}});\nt start(); // don't forget to start the thread!\nt.start(); // don't forget to start the thread!\nthreads.add(t); }\n// wait for all the threads to finish\nfor (Thread t: threads) t.join();\n// display the final account balance\nSystem.out.println(account.getBalance());\n(c) Robert Miller 2008\nSummary\navoid debugging\n3⁄4it's not fun and not productive\n3⁄4many of the techniques of this class are designed to save you from bugs\napproach it systematically\napproach it systematically\n3⁄4simplify test cases\n3⁄4find cause before trying to fix\n(c) Robert Miller 2008"
    },
    {
      "category": "Resource",
      "title": "Decoupling and Interfaces",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/259aaebfa525dbb0878464c24a9735f3_MIT6_005f08_lec08.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nDecoupling and Interfaces\nRob Miller\nFall 2008\n(c) Robert Miller 2008\nQuote Generation Problem\nproblem\n3⁄4obtain stock quotes for some ticker symbols\n3⁄4produce both RTF and HTML output\n3⁄4put the ask price in bold if the change since open is ≥± 1%\n3⁄4put the ask price in bold if the change since open is ≥ ± 1%\nToday's Topics\nprinciples and concepts of system design\n3⁄4modularity\n3⁄4decoupling\n3⁄4information hiding\ninformation hiding\na new notation\n3⁄4module dependency diagram\ncase study: designing a stock quoter\n3⁄4using interfaces to decouple modules\n(c) Robert Miller 2007\nDesign Tasks\ntasks, for each ticker symbol:\n3⁄4download quote information from web site\n3⁄4parse to extract stock quotes\n3⁄4write to file in RTF or HTML format\nwrite to file in RTF or HTML format\nparsing\n3⁄4minimize parsing by choosing a site with a simple format\n3⁄4Yahoo offers stock quotes in comma-separated-values (CSV) format\nexample\n3⁄4http://quote.yahoo.com/d/quotes.csv?s=aapl&f=noa\n3⁄4returns the string \"APPLE INC\",130.75,125.20\neturns the string \"APPLE INC\" 130 75 125 20\n(c) Robert Miller 2007\n(c) Robert Miller 2007\n\nDownloading & Parsing\npublic class Quoter {\nprivate URL url;\nprivate String open, ask;\nprivate int change;\nwhy are the fields of\nQuoter private?\npublic Quoter (String symbol) throws MalformedURLException {\nurl = new URL(\"http://quote.yahoo.com/d/quotes.csv?s=\"\n+symbol+\"&f=noa\");\n}\npublic String getOpen () {return open;}\npublic String getAsk () {return ask;}\npublic int getChange () {return change;}\npublic void obtainQuote () throws IOException {\nBufferedReader in = new BufferedReader(new\nBufferedReader is also\na state machine.\nDraw it. What design\npattern does it use?\nInputStreamReader(url.open..));\nSt i\ni\ndLi\n()\nQuoter is a state machine.\nDraw it. What design\npattern does it use?\nString csv = in.readLine();\nin.close();\nString[] fields = csv.split(\",\");\nopen = fields[1];\nask = fields[2];\nchange = (int)(100 *(Float.valueOf(ask)-Float.valueOf(open))\n/ Float.valueOf(open));\n}\n(c) Robert Miller 2007\n}\nDesign Option #1\njust build two formatters that use Quoter\npublic class HTMLFormatter {\nprivate final Set<String> symbols = new HashSet<String> ();\n...\npublic void\nvoid generateOutput ()\nu\nthrows IOException {\nIOExcepti n {\npublic\ngenerateO tput () throws\no\nPrintStream out = new PrintStream(new FileOutputStream (...));\nout.println(\"<html>\");\nfor (String symbol: symbols) {\nQuoter q = new Quoter (symbol);\nq.obtainQuote();\nout.println(symbol + \": \"\n+ \"<i>opened at</i> \" + q.getOpen ()\n+ \"<i> and is currently trading at </i>\");\nboolean bigChange = Math abs (q getChange()) >= 1;\nboolean bigChange\nMath.abs (q.getChange()) > 1;\nif (bigChange) out.println(\"<b>\");\nout.println(q.getAsk ());\nif (bigChange) out.println(\"</b>\");\nout.println(\"<br>\");\n}\nout.close();\n}\n}\n(c) Robert Miller 2007\nHow would the RTF\nversion differ? What's\nundesirable about this\nchoice?\nModularity and Decoupling\nmodularity is essential for managing complexity\n3⁄4system is divided into parts (modules) that can be handled separately and\nrecombined in other combinations\ncoupling\ncoupling\n3⁄4degree of dependence between parts of the system\n3⁄4an important measurement of modularity\ndecoupling achieved so far\n3⁄4the website (Yahoo) and its format (CSV) have been decoupled from the\nrest of the system\nrest of the system\nnext step\n3⁄4design the part of the system that generates the report\n3⁄4report can be either HTML or RTF\n(c) Robert Miller 2007\nDesign Option #2\nbuild one formatter that takes a flag (RTF or HTML)\n3⁄4tests flag to determine flow of control\npublic class Formatter {\np\npublic enum Format { HTML, RTF };\nprivate final Format format;\n..\npublic void generateOutput () throws IOException {\nPrintStream out = new PrintStream(new FileOutputStream (...));\nout.println(format == HTML ? \"<html>\" : \"{\\\\rtf1\\\\mac\");\nfor (String symbol: symbols) {\n...\nboolean bigChange = Math.abs (q.getChange()) >= 1;\nIs this a wise\nway to test the\nformat flag?\ng\ng\n(q g\ng ())\n;\nif (bigChange) out.println(format == HTML ? \"<b>\" : \"\\\\f\\\\b\");\nout.println(q.getAsk ());\nif (bigChange) out.println(format == HTML ? \"</b>\" : \"\\\\f\\\\b0\");\nout.println(\"<br>\");\n}\n...\n}\n}\n(c) Robert Miller 2007\nWhat's undesirable about this choice?\nwhy are the fields of\nQuoter private?\nBufferedReader is also\na state machine.\nDraw it. What design\npattern does it use?\nHow would the RTF\nversion differ? What's\nundesirable about this\nchoice?\nWhat's undesirable about this choice?\n\nA Better Solution\nA Principle\nfactor out responsibilities for report generation\nlocalize each design decision in exactly one place\n3⁄4generator: knows how to put in bold, italics, etc.\n3⁄4more crudely:\"don't repeat yourself\"\n3⁄4formatter: knows what to put in bold, italics, etc.\ndesigning the generator\nwhy?\nwhy?\n3⁄4ready for change: if decision needs to change, there's only one place\n3⁄4make it a state machine!\n3⁄4two versions, one RTF and one HTML\n3⁄4but same interface\n3⁄4ease of understanding: don't have to think about the details of that decision\nwhen working on the rest of the system\n3⁄4safety from bugs: fewer places to change means less chance of omission\nvariations on the same idea\nvariations on the same idea\n3⁄4Information hiding: localizing design decision and protecting the rest of the\nsystem from it\n3⁄4Encapsulation: wrapping code up into a module that hides information\n(c) Robert Miller 2007\n3⁄4Separation of concerns: responsibility for a feature is given to one module,\nnot spread across system\n(c) Robert Miller 2007\nA Generator\npublic class RTFGenerator implements Generator {\nprivate boolean italic;\nprivate boolean bold;\nprivate final String filename;\nprivate PrintStream stream;\nprivate PrintStream stream;\npublic RTFGenerator (String filename) {\nthis.filename = filename; }\npublic void open() throws FileNotFoundException {\nFileOutputStream fos = new FileOutputStream (filename);\nstream = new PrintStream(fos);\nstream.println (\"{\\\\rtf1\\\\mac\"); }\npublic void close() {\npublic void close() {\nstream.println (\"}\"); stream.close(); }\npublic void newLine () {\nstream.println (\"\\\\\"); }\npublic void toggleBold() {\nstream.println (bold ? \"\\\\f\\\\b0\" : \"\\\\f\\\\b\");\nbold = !bold; }\n...\n(c) Robert Miller 2007\n}\nGenerator Machine\nkey design idea\n3⁄4develop generic interface for text formatting\nOPEN\nBOLD\nITALIC\nPLAIN\nROMAN\nCLOSED\ntoggleBold\ntoggleBold\ntoggleItalic\ntoggleItalic\nwrite,\nnewline\nclose\n(c) Robert Miller 2007\nBOLD\nITALIC\nCLOSED\n\nThe Big Question\nhow to make formatter independent of generator?\n3⁄4we want them decoupled\n3⁄4so we can plug in different generators\n3⁄4without changing the formatter's code\n3⁄4without changing the formatter s code\nsolution\n3⁄4formatter doesn't refer to a particular generator class\n3⁄4it refers to an interface instead\n(c) Robert Miller 2007\nInterfaces, in Pictures\nwhat we want\n3⁄4two ways to configure formatter\nhow does formatter refer to\ngenerators?\n3⁄4with an interface\n(c) Robert Miller 2007\nGenerator Interface\n/**\n* Interface for generator with basic text formatting.\n* Typically a stream is passed to the constructor.\n*/\npublic interface Generator {{\npublic interface Generator\npublic void open () throws Exception;\npublic void close ();\npublic void newLine ();\npublic void toggleBold ();\npublic void toggleItalic ();\npublic void write (String s);\n}\npublic class RTFGenerator implements Generator {\npublic void open() throws FileNotFoundException { ... }\n...}\npublic class HTMLGenerator implements Generator {\npublic void open() throws FileNotFoundException { ... }\n...}\n(c) Robert Miller 2007\nUsing the Generator Interface\npublic class QuoteFormatter {\nprivate final Set<String> symbols = new HashSet<String> ();\nprivate final Generator generator;\npublic QuoteFormatter(Generator generator) {\nthis.generator = generator ;\n}\npublic void addSymbol (String symbol) {\nsymbols.add (symbol);\n}\npublic void generateOutput () throws Exception {\ngenerator.open ();\nfor (String symbol: symbols) {\nQuoter q = new Quoter (symbol);\nq.obtainQuote();\ngenerator.write (symbol + \": \");\ngenerator.toggleItalic ();\ngenerator.write (\"opened at \");\ngenerator.toggleItalic ();\n...\ngenerator.close();\n}\n(c) Robert Miller 2007\n}\nan object implementing\nGenerator is plugged into\np gg\nthe formatter\nno mention of HTMLGenerator\nor RTFGenerator anywhere!\n\nerator\nPutting Everything Together\npublic class QuoteApp {\npublic static void main(String[] args) throws Exception {\nGenerator rtfg = new RTFGenerator (\"myQuotes.rtf\");\nQuoteFormatter formatter = new QuoteFormatter(rtfg);\nformatter.addSymbol (\"AAPL\");\nformatter.addSymbol (\"INTC\");\nformatter.addSymbol (\"JAVA\");\nformatter.addSymbol (\"MSFT\");\nformatter.generateOutput ();\nplugin is selected here\nGenerator htmlg = new HTMLGenerator (\"myQuotes.html\");\nformatter = new QuoteFormatter(htmlg);\nformatter.addSymbol (\"AAPL\");\nformatter.addSymbol (\"INTC\");\nformatter.addSymbol (\"JAVA\");\nformatter.addSymbol (\"MSFT\");\nformatter.generateOutput ();\n}\n}\n(c) Robert Miller 2007\nExercise\nwhich modules would you need to modify to...\n3⁄4handle new RTF syntax for italics?\n3⁄4put the ask price in bold if the stock went down since open?\n3⁄4use Google Finance instead ofYahoo?\n3⁄4use Google Finance instead of Yahoo?\n3⁄4add year-to-date change to the report?\nWhat We've Achieved\ndependency diagram\n3⁄4arc means \"depends on\"\ninvokes QuoteFormatter with\ntickers & selects output format\nGen\nobtains and outputs quotes\nQuoter\nHTMLGenerator\nRTFGenerator\nobtains quotes\nformats text in HTML\nformats text in RTF\nQuoteApp\nQuoteFormatter\n(c) Robert Miller 2007\nAn Interface is a Specification\na general strategy\n3⁄4client should only know about the specification of the service it uses\n3⁄4so decouple the client from the service by interposing the specification\nin Java:\nin Java:\n3⁄4the specification is declared by an interface\n3⁄4the service is plugged in by passing an object implementing that interface\nspecification is a contract\n3⁄4we'll see more about this idea in later lectures\n(c) Robert Miller 2007\n(c) Robert Miller 2007\nplugin is selected here\nobtains and outputs quotes\ninvokes QuoteFormatter with\ntickers & selects output format\nQuoteApp\nQuoteFormatter\nGenerator\nQuoter\nHTMLGenerator\nRTFGenerator\nobtains quotes\nformats text in HTML\nformats text in RTF\n\nOther Uses of Interfaces\ndecoupling from choice of representation\n3⁄4very common and important\nList<NoteEvent> recording = new ArrayList<NoteEvent>();\nrecording add( );\nrecording.add(...);\nList<NoteEvent> recording = new LinkedList<NoteEvent> ();\nrecording.add(...);\n\"marker\" interfaces\n3⁄4declare no methods\n3⁄4declare no methods\n3⁄4used to expose specification properties (e.g. java.util.RandomAccess)\n3⁄4or as a hack to add functionality (e.g. java.io.Serializable)\n(c) Robert Miller 2007\nSummary\nsystem design principles\n3⁄4modularity\n3⁄4decoupling using interfaces\ndependency diagrams\ndependency diagrams\n3⁄4show essence of code design\n3⁄4missing dependences are the interesting ones!\n(c) Robert Miller 2007"
    },
    {
      "category": "Resource",
      "title": "Designing State Machines",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/91fcd7e2093b0e1d30ffc0dfd035a2bb_MIT6_005f08_lec04.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n6.005\nelements of\nsoftware\nconstruction\ndesigning state machines\nDaniel Jackson\nUntil now, we've been doing a crash course in Java. This is the first lecture of the course proper,\nstarting with state machines -- our first software paradigm.\n\na lesson from failure\n\nfriendly fire in afghanistan\nAfghanistan, December 2001\n‣ US soldier uses plugger* to mark Taliban\nposition for air-strike\n‣ notices battery-low warning, so replaces\nbattery and calls in coordinates\n‣\nPhotograph of PLGR removed due to copyright restrictions.\nresulting strike kills user and two comrades\nand wounds 20 others\nwhat happened?\n‣ replacing battery reset to current position\n*PLGR: precision lightweight global-positioning satellite\nreceiver\nVernon Loeb. Friendly Fire Deaths Traced to Dead Battery; Taliban\nTargeted, but U.S. Forces Killed. Washington Post. March 24, 2002\n(c) Daniel Jackson 2008\nA tragic story reported in the Washington Post.\n\nwhat can we learn from this?\naccidents are complex\n‣ rarely one cause, so be wary of simple explanations\n‣ often human factors + technology\nlessons from this case\n‣ design for robustness against all likely failure modes\n‣ defaults are dangerous: user should be warned\n‣ describe and analyze all usage scenarios\n(c) Daniel Jackson 2008\nThere are lots of problems here that could be analyzed. For example, there's clearly a user interface\nproblem that the device didn't clearly indicate when it was showing calculated coordinates versus\nthe coordinates of the user. Like many accidents, this one involved human factors issues in which\nthe designers didn't think through all the ways that user might interact with the machine. But\nwhatever the problem was, it's clear that we need some way to talk about the possible scenarios in\nsimple but precise way.\n\nstate machines\nwhat they are\n‣ a simple notation for describing behaviors\n‣ succinct and abstract -- but not vague!\n‣ basis for analysis and for implementation\nNOCOORD\nYOURCOORD\nMYCOORD\nlocate\nadjust\nreset\nNOCOORD\nYOURCOORD\nMYCOORD\nlocate\nadjust\nreset\n(c) Daniel Jackson 2008\nState machines give us this simple and precise way of talking about scenarios. Don't confuse\nabstract with vague! They're abstract in the sense that they allow you to express only the important\nbits, but that isn't the same as being vague. A state machine doesn't tell you everything there is to\nknow about a system, but what it does tell you -- namely what orders events can happen in -- it\ntells you very precisely.\n\nour path\ngeneral strategy\n‣ design behavior --> design mechanism\n‣ three paradigms covering different aspects of software design\nfirst paradigm: state machines\n‣ today -- state machines for designing behavior\n‣ wednesday -- design patterns for implementing state machines\n‣ friday -- analyzing state machines with invariants\n(c) Daniel Jackson 2008\nThis strategy is one we'll follow throughout the course: first learning how to think about designing\nthe behavior of a system, and only then thinking about designing the mechanism -- the system's\ninternal structure. This is a very important 'separation of concerns'. It lets you focus on the\nbehavior without getting mixed up with mechanism issues. And there's an important sequencing\nhere too: how can you figure out what mechanism you need to implement a behavior if you don't\nknow what the behavior is? For small systems, many programmers just do the behavioral design\ncompletely in their heads, but that can lead you into real trouble -- and many late nights of\nrestructuring and debugging. For large systems, teams usually develop requirements and\nspecification documents. What we're trying to teach you is the essential notions you need in those\ndocuments. The models we're teaching you in this course are much more succinct than informal\ndocumentation, can be analyzed automatically by tools (although that's beyond this course) and can\nbe translated fairly directly into code, as we'll see. So constructing these behavioral designs makes\nit easier to write the code, because they help bridge the gap -- the code doesn't come out of thin\nair.\n\ndesigning a midi piano\n\na midi-piano\nfunctionality required\n‣ play notes on computer keyboard\n‣ sustain by holding key down\n‣ cycling through instruments\n‣ record and playback\ncontext\n‣ piano depends on keyboard, midi API\n‣ this is a dependence diagram -- more later\nneed to start by understanding\nkeyboard input\njavax.sound.midi\nmy midi piano\n‣ keyboard input: press and release\n‣ MIDI interface: commands\n(c) Daniel Jackson 2008\nWe'll see more of these kinds of diagrams later. They're called _dependency diagrams_. Note that\nthe edges aren't labelled: that's a clue that they're not state machines! Sometimes people try and\nmake these various notations look different from one another (eg, by making the boxes slightly\ndifferent shapes), but our experience is that it's more trouble than it's worth: easier just to use\nplain old boxes and arrows and label your diagrams so you know what they are.\nNote, btw, that there's a big decision that's already been made here: what the context actually is.\nWe could have chosen to use a different API for making the musical sounds, and we could have\nimplemented our own keyboard driver. Just defining where your system sits with respect to the\noutside world and your assumptions about it is a big step.\n\nmodeling the context\n\na single key\nthe state machine\n‣ two states, UP and DOWN\n‣ UP is the initial state\n‣ two input event classes, with these designations\nUP\nDOWN\nrel\npr\npr\n:\npr: the keyboard driver reports a key press\nrel: the keyboard driver reports a release\nmeaning: a set of traces\n‣ a trace is a sequence of events\n‣ traces of this machine are\n<>\n<pr>\n<pr, rel>\n<pr, pr, rel>\n...\n(c) Daniel Jackson 2008\nThe designations are more important than you might think. The biggest mistake novices make with\nstate machine modeling is that the event classes aren't right. Formulating a designation -- trying to\nsay exactly what comprises the occurrence of an event -- is a big help in checking whether your\nnotion of the event class is reasonable, and in conveying it to others. Here the crucial idea is that\npr, for example, doesn't mean that the user actually pressed the key, which is an important\ndistinction.\nInterestingly, not all keyboard drivers generate key repeats in this form. In Gnome, for example (as\na student told me after class), the driver actually repeats release-press pairs -- in the notation we'll\nsee next week, the repeat is (rel pr)* rather than pr*. That's bad news, because it's not at all clear\nhow the generated repeats can be distinguished from the real key presses.\nNote that the trace set is infinite if the machine has a loop in it, although each trace is itself finite -\nthe history of events up to some point in time. This notion of traces was invented by Tony Hoare in\na machine formalism called Communicating Sequential Processes. You may be a bit confused if\nyou've seen the notion of languages and state machines in a computer science theory setting.\nThere, the language usually consists of the set of all complete sequences, which are defined\nbecause there are some special states that are marked as final. Here we only have initial states.\n\n(c) Daniel Jackson 2008\nthe whole keyboard\nrepresent as parallel combination of state machines\n‣ each key's machine can take steps independently\n(general rule: shared events must be synchronized, but no sharing here)\n‣ traces include <>, <pr1>, <pr1, rel1>, <pr1, rel1, pr2>, <pr1, pr2, pr1>\nUP\nDOWN\nrel1\npr1\npr1\n...\nUP\nDOWN\nrel2\npr2\npr2\nThe parallelism here is just conceptual. To implement this kind of parallelism, you could actually\nhave threads running concurrently, but usually you just have separate state components, one for\neach of the submachines, and the whole machine runs sequentially with one of the submachines\ntaking a step at a time. When the 'alphabets' of events of the component submachines overlap, the\nshared events have to happen as one. In this case, there aren't any shared events, but we'll see\nexamples of this below.\n\n(c) Daniel Jackson 2008\napproximate models\nover-approximation\n‣ this model is actually an over-approximation\n‣ it allows more traces than can happen (eg <pr1, pr2, pr1>) -- try it and see\n‣ but this is OK: problem is handling fewer inputs than can occur\nUP\nDOWN\nrel1\npr1\npr1\n...\nUP\nDOWN\nrel2\npr2\npr2\nThis is an overapproximation because it includes traces that can't happen in practice. In a real\nkeyboard driver, the keys are not independent. In many, for example, the key repeat on one key is\nterminated when another key is pressed, so the trace <pr1, pr2, pr1> can't occur, since the\npressing of key 2 prevents repeats of key 1.\nOverapproximation is good because it allows us to use a simpler model. It doesn't matter if we\nhandle more input scenarios than actually happen.\n[Note, not explained in lecture: There's actually a form of overapproximation for output too, called\nnondeterminism, in which you show multiple possible outputs happening with the implication that\neither they are all equally acceptable, or that some other part of the specification which is not\ncurrently being considered will say which should happen. This is useful because, again, it makes the\nmodel simpler. But there's a more subtle reason it helps: if I can show that my system has the right\neffect whichever output behavior it chooses, then I've shown that any of the implementations you\nchoose will be OK. Sometimes we just want to make sure that everything will be OK without\nspecifying exactly what the behavior will be. An example of this is giving a caching algorithm\nwithout saying exactly what the rules are for choosing which line to evict. Sometimes we actually\ncan't control the behavior. In a distributed system, for example, it's often impossible to get events\nat different hosts to execute in some given ordering, so it's better to allow whatever ordering can\nhappen, and make sure the system will work whichever it is.]\n\n(c) Daniel Jackson 2008\nmodelling the midi API\nsimple interface\n‣ just turn each note on and off; need explicit initialization\nOFF\nON\nOFF\nON\nendC#\nbeginC#\nendC\nbeginC\nSTART\ninit\nC#\nC\n...\nThere's nothing much going on here: just a simple state machine protocol, just like the kind many\nAPIs present. File i/o, for example, has the same kind of protocol: you can't read or write when the\nfile is closed, etc.\n\nfirst design draft\n\n(c) Daniel Jackson 2008\nfirst design draft\ndesign strategy\n‣ base structure on input and embed output events\n‣ absorb superfluous presses\nUP\nDOWN\nrelk/endnote(k)\nprk/beginnote(k)\nprk\n...\nk\nSTART\ninit\nThis shows the result of starting with the basic keyboard and adding output events. I've written this\nas a generic machine, with the understanding that there is one of these for each key. I've assumed\nsome function, note, that takes a key and returns a musical note associated with it. So begin_note\n(k) means the begin event for the note associated with key k. Note that there's no output generated\nfor the repeated press events.\nIn lecture, I referred to the filtering of the superfluous presses as 'debouncing', but that's an abuse\nof terminology. Debouncing means eliminating the spurious press and release events associated\nwith the electrical contact of the key's switch not closing cleanly.\n\nstate machine semantics\n\nthe i/o shorthand\ninput/output shorthand\n‣ i/o label is just a shorthand\nsubtle consequence\n‣ o need not follow i immediately\n‣ another event can intervene\nA\nB\ni/o\nA\ni\nB\no\nshort\nfor:\n(c) Daniel Jackson 2008\nThere are different ways that a state machine formalism can handle inputs and outputs. This is\nperhaps the simplest way. We just say that after the input occurs, the output can happen -- and no\nother inputs until it's happened. Note that we don't actually distinguish inputs from outputs in any\nformal way, although of course when you designate the events you'll say which are which. And we\ndon't have any notion of outputs following inputs immediately: if this was a component submachine\nin a parallel combination, another machine could take a step between the i and the o, so that the o\ndoesn't immediately follow the i. In most situations this is exactly what we want anyway.\n\na state machine is ...\n‣ a set of states\nState = { UP, DOWN, PRESSED, RELEASED }\n‣ a set of initial states\nInit = { UP }\n‣ a set of events\nEvent = { pr, rel, begin, end }\n‣ a transition relation\nUP\nDOWN\nrel\nbegin\npr\nPRESSED\nRELEASED\npr\nend\ntrans ⊆ State × Event × State =\n{ (UP, pr, PRESSED), (PRESSED, begin, DOWN), (DOWN, pr, DOWN),\n(DOWN, rel, RELEASED), (RELEASED, end, UP) }\n‣ trace set (derived from trans and Init)\ntraces = { <>, <pr>, <pr, begin>, <pr, begin, pr>, <pr, begin, rel>, ...}\nHere's the mathematical definition of a state machine that we're using. The diagram can be\ntranslated easily into this structure: each box becomes a member of the set of states, each label\nname becomes an event class, each edge becomes a tuple in the transition relation. In terms of\nwhat the machine actually means though we only care about the traces: the states are just an\nartifact to help us define the order in which the events can occur.\nIn general, there can be more than one initial state. This allows you to describe overapproximations\n-- it's another form of non-determinism, which I mentioned before -- allowing an execution to\nstart in any of the initial states. But generally for the machines we'll look at there's just one initial\nstate.\n\nrecording\n\nexercise\ndraw a state machine where\n‣ pressing R key toggles between recording on and off\n‣ and switches indicator light to red (on) and green (off)\n‣ ignore actual recording for now\n!REC\nREC\nprP\nsetRed\nACTIVATED\nDEACTIVATED\nprP\nsetGreen\nINIT\nsetGreen\n!REC\nREC\nprP/setGreen\nprP/setRed\nINIT\nsetGreen\n(c) Daniel Jackson 2008\nIn doing this exercise, some of you didn't have explicit events for setting the indicator light green\nand red, and just labeled the states. That's not so good, because as we noted before, the states\ndon't really mean anything: it's only the traces that are observable.\n\nadding recording\ndesign strategy\n‣ add a parallel machine that maintains additional state\nnew events and states\n‣ events\nprR: keyboard driver reports press of R key\npr(k): keyboard driver reports press of any\nkey except for R\n‣ states\n!REC: recording off\n!REC\nREC\nprR\nprR\npr(k), rel(k)\npr(k), rel(k)\nREC: recording on\ndesign question\n‣ do we need to worry about key repeats?\n(c) Daniel Jackson 2008\nYou might think that this machine says nothing -- and you'd be almost right. All it does is parse a\nsequence of keyboard events, deciding whether we're in the recording mode or not after a given\nsequence. As we noted before, only traces matter and not states. But we'll actually use these states\nto determine outputs, after elaborating them a bit.\nThere's no need to worry about key repeats in this case, as we don't expect the user to hold the R\nkey down. If we were worried about them, we could filter them out the way we filtered them out for\nother keys.\n\ntextual notation\nstate = (control-state, data-state)\n‣ diagram only shows control state\n‣ to show data state, use textual notation\nstate\n// declare state and init\nList<Event> recording = <>;\n// state component and initial value\nboolean REC = false;\n// this component is a mode\nop pr-R\n// declare operation\nwhen true\n// precondition: when op can fire\ndo\n// postcondition: effect of operation\nif (! REC) recording = <>;\nREC = !REC\nop pr (k)\n// any press except an R\nwhen true\ndo\n// append key to recording\nif (REC)\nrecording = recording ^ <prk>\n// .. and similar op for rel(k)\n(c) Daniel Jackson 2008\nHere's the elaboration. We want to say what actually gets recorded, and we can't do that in a\ndiagram. This is a textual state machine. It has exactly the same semantics as a diagram, but the\nstates and transitions are now implicit. The set of states is declared by giving state components,\nand each state is then a combination of values of the components. The transitions are declared by\ngiving operations, each of which defines a set of transitions. For example, the operation pr(k)\ndefines the set of all key press events, where k is the key being pressed. Note that there's a subtle\ndifference in how I use the terms pr(k) and pr_k. The term pr(k) is a generic press event matching\nany key k; the term pr_k is a press event for a particular key k. The operation is like a method: you\nsupply the argument k.\nThe ! is boolean negation, so REC = !REC just flips the boolean value of REC. This would be bad Java\nstyle, btw, to name a variable in all caps. I'm doing it here so that it matches the name of the state\nin the diagram. When the state machine has one particular state component that takes one of a\nsmall set of values, such as REC, it is often called a \"mode\". You can think of all the states of the\nmachine being partitioned into the modes: within the mode REC, there are different states\ncorresponding to the different values of the state component recording.\nThe statement \"recording = recording ^ <pr_k>\" means that the event of key k being pressed is\nappended onto the sequence called recording. The ^ is concatenation of sequences, and <e> is the\nsingleton sequence containing just e. This is standard mathematical notation which unfortunately\nyou can't use in Java.\nNote that each operation has two parts, a precondition that says when the operation can occur, and\na postcondition describing the way the state is updated. It's important to understand that although\nthis seems much more complicated than the state machine diagram, the mathematical structure\nunderneath is the same. So the operation pr-R, for example implicitly defines transitions like\n(!REC, <e>), pr-R, (REC, <>)\n(REC, <e>), pr-R, (!REC, <e>)\nwhere each state has two components. There are just many more of these than for the diagram,\nbecause there's a transition tuple (REC, s) for example for every recording sequence s.\n\ncheck your understanding\nwhat difference would this make?\n‣ instead of test in postcondition\nop pr (k)\nwhen true\ndo\nif (REC)\nrecording = recording ^ <prk>\n‣ use precondition\nop pr (k)\nwhen REC\ndo\nrecording = recording ^ <prk>\n(c) Daniel Jackson 2008\nIn our example, we didn't actually use the precondition, because every operation was allowed in\nevery state. Here's an example of using it, although it's not what we want in this case. Suppose we\nput the test from the postcondition into the precondition. What this now says is not that we only\nupdate the recording sequence when in mode REC but that the pr-R event can only occur in mode\nREC, which is a very different thing!\n\nanalyzing recording\nconsider traces\n‣ how about this trace?\n<pr(1), prR, rel(1), prR>\n‣ very strange behavior: recording starts with key release!\ntwo simple options\n‣ filter out initial key releases\n‣ or just allow it (which is what we'll do)\nor perhaps\n‣ regard as evidence of larger issue\n‣ maybe recording should be of musical\nstructure and not of user events?\n!REC\nREC\nprR\nprR\npr(k), rel(k)\npr(k), rel(k)\n(c) Daniel Jackson 2008\nBack to our simple machine. Note that something funny can happen: you can begin a recording with\na key being released! There are many ways we could deal with this. We could filter out pr-R events\nwhen any other key is depressed. We could do something more complicated and somehow handle\nthe unmatched release events, either by generating press events to match or by dropping them.\nWhat I actually did in my implementation, which you'll see in the next lecture, is just to ignore this\nissue because I wanted to keep things simple.\nBut actually this little detail is a symptom of a much bigger problem. What's really going on is that\nwe shouldn't be recording press and release events at all. We should be recording musical entities,\nsuch as notes of a particular duration and pitch. This little problem here is just the tip of the\niceberg. If we go ahead and record only press and release events, we won't be able to associate\ndifferent instruments with different notes: recording with one instrument and then playing back and\nmixing with notes played on another instrument. This is a typical occurrence in a software\ndevelopment: a small glitch reveals that actually the entire abstraction is suspect. It's one reason\nthat thinking carefully about the behavior before you start building is important, because it's much\neasier to make big changes at this point than when we already have a pile of code written.\n\nplayback\n\nplayback\nlet's add a playback mode\n‣ use P key for playing back\nprP: keyboard driver reports P key pressed\n‣ add an event to signal end of playback\ndone: output event to signal end of playback\nfirst design option\n‣ playback only enabled\nwhen recording is off\n‣ no key presses during playback\nPLAY\nREC\nprR\nprR\nPLAYBK\nprP\ndone\npr(k), rel(k)\npr(k), rel(k)\n(c) Daniel Jackson 2008\nThis is the most simple notion of playback - it occurs in a mode in which no recording or manual\nplaying is allowed. I'm ignoring for now the question of what exactly is played back; we'll come to\nthat soon.\n\nrecord during playback\ncan you record during playback?\n‣ very useful, but much trickier\nwhat does playback involve?\n‣ generated playback events merged\nwith user keyboard events?\nPLAYBK\nRECPLAYBK\nPLAY\nREC\nprP\ndone\nprR\nprR\nprR\nprR\nprP\ndone\nH\npr(k),\nrel(k)\n(c) Daniel Jackson 2008\nThis is the more sophisticated and useful notion of playback, with recording and playback\ninterleaved in any way we please. I'm using a statechart shorthand. The arc coming from the outer\nbox labeled \"pr(k), rel(k)\" says that you can have a transition on a press or release of any key from\nany of the states inside the box, and the destination of the transition is whatever state you were in\nbefore. (H) means history and a transition to that special marker means a transition to the last state\nthat the machine was in inside the larger superstate box.\nThis still doesn't resolve the question of what is actually played back. Onto that next...\n\n(c) Daniel Jackson 2008\nan asychronous solution\nidea\n‣ playback generates press and release events\n‣ merge these events on a queue with incoming keyboard events\n‣ midi piano sees just one stream of events\nkeyboard input\njavax.sound.midi\nmy midi piano\nevent\nqueue\nplayback\nevents\nHere's perhaps the simplest way to handle playback. When the playback key is pressed, all the\nevents in the recording are added to an input queue, along with whatever events are being\ngenerated by the keyboard driver. They can be interleaved in an arbitrary way so long as none of\nthe events are delayed too long. As noted above, a better abstraction would be to record and\nplayback musical notes; in that case, we'd have to split the piano module into two parts, and put\nthe queue between the two. This isn't really any more complicated conceptually, but it does require\ninventing a whole new set of events, and I wanted to avoid that complication. There is, btw, a tricky\nissue to do with how the events are timed, which I've ignored. A simple solution is to timestamp\neach press or release with the delay since the last press or release, and have a process that delays\nputting the next playback event into the queue by that amount.\n\n(c) Daniel Jackson 2008\nthe playback machine\nanother over-approximation\n‣ which enq events are generated will depend on what was recorded\n‣ (that is, reads recording state component)\nDONE\nPLAYBK\n!REC\nREC\ndone\nprP\nprR\nprR\npr(k), rel(k)\npr(k), rel(k)\nenq (prk),\nenq (relk)\nThis diagram describes the enqueuing of the events; it shows that during playback any sequence of\npress and release events can be enqueued. We're abstracting away the details of which events get\nenqueued, but it's pretty straightforward: it's just the events in the recording sequence that we\nspecified textually.\n\n(c) Daniel Jackson 2008\nmore on recording state\nwhat would happen if\n‣ playback is pressed during record\n‣ generated events get played\n‣ and added to recording\n‣ so they get played back again...\noops!\n‣ keep two recordings\ncurrent: holds events being recorded\nlast: holds events being played back\n‣ show how these are updated in textual syntax\n\nrevised recording with playback\nstate\nList<Event> last, current = <>;\nboolean REC = false;\nop prR\ndo\nif (REC) last = current else current = <>\nREC = ! REC\nop pr (k)\n// .. and similar op for rel(k)\ndo\nif (REC) current = current ^ <prk>\nop prP\ndo // enq events in last\n(c) Daniel Jackson 2008\nHere's the textual description showing how the two lists are handled. I omitted the preconditions,\nwhich means that they are by default true. This description doesn't actually handle how the events\nare enqueued.\n\n(c) Daniel Jackson 2008\nfinal state machine\nstate\nList<Event> last, current = <>;\nboolean REC = false;\nop prR\ndo if (REC) last = current else current = <>; REC = ! REC\nop pr (k)\ndo if (REC) current = current ^ <prk>\nop rel (k)\ndo if (REC) current = current ^ <relk>\nop prP\ndo // enq events in last\nDONE\nPLAYBK\n!REC\nREC\ndone\nprP\nprR\nprR\npr(k), rel(k)\npr(k), rel(k)\nenq (prk),\nenq (relk)\nUP\nDOWN\nrelk/endnote(k)\nprk/beginnote(k)\nprk\nk\nThis is a summary of what we've arrived at in our state machine behavior design, and it will be the\nstarting point for our design of the mechanism. You can think of the textual part as describing\nanother component state machine that is in parallel with all the others. The first two diagrammatic\ncomponent machines just summarize this machine from the perspectives of the recording and\nplayback keys.\n\nsummary\n\n(c) Daniel Jackson 2008\nprinciples\ndescription before invention\n‣ before you invent something, understand what's there\n‣ especially important for your design's environment\n‣ eg, keyboard driver and midi API\nbehavior before mechanism, or 'what before how'\n‣ design the behavior of a system first\n‣ easier to design the mechanism when you know what the behavior is\n‣ and easier to analyze the behavior when you can ignore mechanism\n‣ eg, state machines before Java classes\nget the details right\n‣ details matter for quality, and can hide major structural flaws\n‣ eg, details of playback during record determine gross structure\n\naddendum\n\n(c) Daniel Jackson 2008\nmodeling advice\ngrounding in reality\n‣ select events first and thoughtfully\n‣ give explicit designations saying what they mean\n‣ must be atomic and recognizable\nbad smells\n‣ events not designated, event classes not really disjoint\n‣ no initial state marked\n‣ states or transitions without labels\na state machine is not a control flow graph\n‣ no behavior inside states\n‣ no 'decision edges'"
    },
    {
      "category": "Resource",
      "title": "Designing Stream Processors",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/85d673071386f87f9e4c89b10f4e3fea_MIT6_005f08_lec07.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\n6.005\nelements of\nsoftware\nconstruction\ndesigning stream processors\nDaniel Jackson\nThis lecture is the last in the series on state machines. It takes a dierent view -- how to implement\na state machine that processes a stream of events, using the control structure of code. In contrast\nto the machine implementations based on the state and transition structure, this approach uses the\nimplicit state in the program counter, defined by the nested structure of loops, conditions, etc.\nThe two important lessons in the lecture are (a) the idea of grammars and regular expressions and\nhow to use them to model trace sets, and (b) the JSP method for synthesizing code from grammars.\n\ndesigning a quizzer\n\ndesigning a quizzer\nwant a console program that\nreads a file of questions\ndisplays them one by one\naccepts user responses\nprompts again if out of bounds\nreports a total and message\n(c) Daniel Jackson 2008\nWhat is the capital of France?\n(a) Paris\n(b) London\n(c) Brussels\ne\nMust give answer between a and c. Try again.\nb\nWhich of these bodies of water is the largest?\n(a) Pacific Ocean\n(b) North Sea\n(c) Walden Pond\na\nWhich of these is not a continent?\n(a) Asia\n(b) Africa\n(c) North America\n(d) Finland\nd\nWhich city is at approximately the same latitude as Boston?\n(a) Rio de Janeiro\n(b) Rome\n(c) Amsterdam\nc\nWhat is a geocache?\n(a) A form of payment that geologists use\n(b) A place that things are hidden in a treasure-hunting game\n(c) A memory used to accelerate the performance of GPS devices\nb\nYou scored 3 points.\nYou're obviously a real globe trotter.\nA simple program but not a trivial one -- will illustrate many of the issues involved in reading\nstreams. There will be two streams to consider: the stream of inputs from the user when actually\nrunning the quiz, and the stream of records read from the file template for the quiz. The first one is\nsimpler, so we start with that.\n\na state machine design\nwhat's right with this?\nit captures the correct traces\nwhat's wrong with this?\nit doesn't show any structure\ndisplayQuestion\nDISP\nERR\nWAIT\ngoodAnswer\nhard to see that you can loop on a question\nbadAnswer\ndisplayErrMsg\n(c) Daniel Jackson 2008\nHow do we model the behavior of the quizzer with a state machine? We can do it, but it fails to\nshow the structure inherent in the problem. There's no indication here that the repeated handling\nof bad answers is done once per question -- that the bad answer handling is nested inside the\nquestion handling.\n\nanother attempt\nusing Statecharts notation\ncan show repeat attempts inside the state corresponding to one question\nbut this can get clumsy\nDISP\nWAIT\ndisplayQuestion\ngoodAnswer\nbadAnswer\ndisplayErrMsg\nERR\n(c) Daniel Jackson 2008\nWe can use the syntactic extensions of Statecharts to introduce some structure, and now we can see\nthat the bad answer handling is a sort of subroutine. But this is not a good approach in general.\nFirst, there isn't a convention for how to do this systematically -- to prevent arbitrary exits out of\nthe 'subroutine' for example -- and it can easily become a mess. Second, it doesn't scale very well.\nThird, the structure is still somewhat obscured. We need to observer that there's a cyclic path to see\nthat there's an iteration going on here.\n\nwhat's going on?\nconsider a trace such as\n<\ndisplayQuestion,\nbadAnswer,\ndisplayErrMsg,\nbadAnswer,\ndisplayQuestion\nDISP\nERR\nWAIT\ngoodAnswer\ndisplayErrMsg,\ngoodAnswer,\ndisplayQuestion,\ngoodAnswer,\nbadAnswer\ndisplayErrMsg\ndisplayQuestion,\nbadAnswer,\ndisplayErrMsg,\ngoodAnswer\n>\n(c) Daniel Jackson 2008\nTake a step back and look at just the trace; this is where we find the structure. The states are just\nan artifact.\n\nhierarchical structure\nwe can structure it like this:\n<\ndisplayQuestion,\nSession\nbadAnswer,\nQuestion\ndisplayErrMsg,\nBadAnswers\nbadAnswer,\ndisplayErrMsg,\ngoodAnswer,\ndisplayQuestion,\ngoodAnswer,\ndisplayQuestion,\nbadAnswer,\ndisplayErrMsg,\ngoodAnswer\n>\n(c) Daniel Jackson 2008\nWe can group the trace into subtraces, hierarchically. So we have a subtrace for each question, and\nthat's divided into a subtrace for displaying the question, one for handling bad answers, and one\nfor accepting the good answer.\n\nas a grammar\ngrammar\ndefines set of traces\nSession ::= Question*\nQuestion ::= displayQuestion BadAnswers goodAnswer\nBadAnswers ::= (badAnswer displayErrMsg)*\neasily converted to code\nvery roughly:\nvoid Session() {while (...) Question();}\nvoid Question() {displayQuestion(); BadAnswers(); goodAnswer}\nvoid BadAnswers() {while (...) {badAnswer; displayErrMsg}\n(c) Daniel Jackson 2008\nThis hierarchical structure can be expressed directly as a grammar. This is not only a more direct\nand clear representation of the structure than the state machine diagram, but it can be transcribed\nstraightforwardly into structured code. We'll see how to do this in today's lecture.\nA state machine diagram can be transcribed easily into code too, but in general it will be code with\narbitrary gotos lacking structure, so that approach is generally only useful for autogenerated code,\nwhen the developer never has to look at the code but can do all development work at the diagram\nlevel.\n\nregular grammars\nThis section of the lecture is a brief introduction to the idea of regular grammars and regular\nexpressions, from a software engineering perspective. Some comments at the end of the lecture\nabout the theoretical connection between grammars and state machines.\n\ngrammars\nsentences\na grammar defines a set of sentences\na sentence is a sequence of symbols or terminals\nproductions, terminals and non-terminals\na grammar is a set of productions\neach production defines a non-terminal\na non-terminal is a variable that stands for a set of sentences\n(c) Daniel Jackson 2008\nGrammars can be used for more than describing sequences of events, so we talk in general about\nsentences rather than traces.\n\nexample\ngrammar\nURL ::= Protocol :// Address\nAddress ::= Domain . TLD\nProtocol ::= http | ftp\nDomain ::= mit | apple | pbs\nTLD ::= com | edu | org\nterminals are\n://, ., http, ftp, mit, apple, pbs, com, edu, org\nnon-terminals and their meanings\nTLD = { com, edu, org }\nDomain = { mit, apple, pbs }\nProtocol = { http, ftp }\nAddress = { mit.com, mit.edu, mit.org, apple.com, apple.edu, apple.org,\npbs.com, pbs.edu, pbs.org}\nURL = {\n\noperators\nproduction has form\nnon-terminal ::= expression in terminals and non-terminals\nexpression operators\nsequence: an A is a B followed by a C\nA ::= B C\niteration: an A is zero or more B's\nA ::= B*\nchoice: an A is a B or a C\nA ::= B | C\noption: an A is a B or is empty\nA ::= B ?\n(c) Daniel Jackson 2008\nThese are the regular expression operators. The symbol + is often used for an iteration of one or\nmore; B+ is short for BB*.\n\nexamples\na two-way switch\nSWITCH ::= (up down)*\na Java identifier\nIdentifier ::= Letter (Letter | Digit)*\nLetter ::= a | b | ... | Z\nDigit ::= 0 | 1 | ... | 9\nfile handling protocol\nFILE ::= open (read | write)* close?\ntrailing whitespace\nTRAIL ::= (space | tab)* newline\n(c) Daniel Jackson 2008\nSWITCH is an example of a grammar describing a trace set. IDENTIFIER and TRAIL illustrate the use\nof grammars for things that aren't about events. The FILE example illustrates a typical feature of\nAPIs: that the methods must be invoked in some order -- in this case, that you can't read or write\nuntil the file has been opened. Closing the file is optional (for correctness, but if you open a lot of\nfiles and don't close them, you'll waste resources and damage performance).\n\nJSP form\n\"JSP form\"\nno 'mixed productions'\neach is sequence, iteration, choice or option\nhas nice diagrammatic form\ngood basis for code synthesis\nexample\nSWITCH ::= TOGGLE*\n// SWITCH is an iteration\nTOGGLE ::= up down\n// TOGGLE is a sequence\nSWITCH\nTOGGLE*\nup\ndown\n(c) Daniel Jackson 2008\nThe regular expression operators are technically all you need to describe a regular language: you\njust write a single expression for the language. That is, one production is enough. So why would you\nintroduce more non-terminals and productions? We had an interesting discussion about this in\nclass. The main reason is the same reason we use procedures in code: if the single expression would\ncontain multiple occurrences of the same subexpression, we can introduce a non-terminal to factor\nthat out, and thereby make it possible to change that subexpression in just one place. Someone else\npointed out that sometimes a non-terminal represents a choice amongst a very large set of\nterminals, and in that case, it's easier just to leave the production for that non-terminal out and\ndefine it informally. In programming language grammars, for example, you'll find non-terminals for\nalphanumeric characters, and it's easier to define what that means in English than to actually list\nthem all: ALPHANUMERIC ::= a | b | ...\nSo, in general, when using grammars for modeling, you have to make good judgments about where\nto introduce non-terminals in just the same way that you decide when to introduce procedures in a\nprogram. But when grammars are being used in a more constructive way to generate code directly,\nit's appropriate to use a more prescriptive rule. The rule that JSP, the method I'm explaining today,\nuses, is that every production must be either a sequence, an iteration, a choice or an option. This\nleads to an easily understandable diagrammatic form in which each box in the diagram has a single\ntype -- it's either one of these non-terminal types, or a terminal.\nTools that generate parsers from grammars also impose rules about the exact forms that\nproductions must take.\n\ndiagram syntax for grammars\nnotation also called\n\"structure diagram\"\n\"entity life history\"\nA\nB\nC\nA\nB*\nA\nB0\nC0\nA\nB0\nA ::= B C\nA ::= B*\nA ::= B | C\nA ::= B ?\n(c) Daniel Jackson 2008\nHere's the repertoire of operators shown in diagrammatic JSP notation. Note that the same\nsuperscript 0 symbol is used for choice and option. In the choice, choosing the empty sequence is\nnot one of the possibilities though. A common variant of iteration uses + in place of * to mean \"one\nor more\" rather than \"zero or more\".\n\nhow to write code to\nread a stream\nNow we'll see how to synthesize code directly from the grammar, first on the simpler example, with\na bit of hand-waving and using pseudocode statements, then more carefully for the second\nexample.\n\nbasic recipe\nbasic idea\nstructure code around grammar of input events\nsteps\ndraw input grammar in JSP form\nconstruct list of statements\nfor reading inputs, updating state, generating outputs\nassign operations to grammar components\nwrite conditions\nread code off grammar\nsequence becomes statements in sequence\niteration becomes while loop\nchoice becomes if-then-else\n(c) Daniel Jackson 2008\nThis is the basic JSP recipe. The full method handles a much more general case, in which there are\nmultiple streams being read and written, and you need to reconcile their structures. In many cases\nthough -- like this one -- the output stream has a very simple relationship to the input stream and\nwrites can just be embedded in the structure of the input stream.\n\nexample: quizzer\nSESSION\nQUESTION*\nBADANSWERS\nBADANSWER*\ndiagrammatic grammar\ndisplay\ngood\nQuestion\nAnswer\ntextual grammar\nSession ::= Question*\nQuestion ::= displayQuestion BadAnswers goodAnswer\nBadAnswers ::= BadAnswer*\nBadAnswer ::= badAnswer displayErrMsg\nbad\ndisplay\nAnswer\nErrMsg\n(c) Daniel Jackson 2008\nHere's the grammar for the input stream of the quizzer, shown in JSP diagram form, and as a\ntextual grammar (for comparison -- you don't need that for the JSP method).\n\nassigning operations\nSESSION\nQUESTION*\nBADANSWERS\ngood\nAnswer\ndisplay\nQuestion\nBADANSWER*\n1 read line\n2 initialize score\n3 incr score\n4 display error msg\n5 display question\n6 display score\nbad\ndisplay\nAnswer\nErrMsg\n(c) Daniel Jackson 2008\nHere's a list of basic operations: reading a line of input, initializing and incrementing the score, and\nthe various display statements. To assign them to the diagram, you just ask the question \"once per\nwhat?\". For example, incrementing the score is done once per good answer, so we assign that\noperation, (3), to the goodAnswer component.\n\nassigning reads\nonly tricky part is where to put the reads\noften need lookahead to evaluate conditions\nusually one lookahead is enough\nin this case\nread after display\nread again after bad answer\n1 read line\n2 initialize score\n3 incr score\n6 display score\n4 display error msg\n5 display question\nSESSION\nQUESTION*\nBADANSWERS\ngood\nAnswer\ndisplay\nQuestion\nBADANSWER*\nbad\nAnswer\ndisplay\nErrMsg\n(c) Daniel Jackson 2008\nReads are tricky, because you can't just assign them logically. You need to figure out how you're\ngoing to be able to evaluate the conditions (on loops and choices). In this case, for example, you\nneed to determine whether there's another bad answer - and obviously you can't determine that\nuntil you've already read the answer to see if it's bad. Also you have to be careful when there are\noutputs also to order the inputs appropriately with respect to the outputs -- in this case, we have\nto do the reading for new input (1) after the displaying of an error message (4).\n\nSESSION\nQUESTION*\nBADANSWERS\ngood\nAnswer\ndisplay\nQuestion\nBADANSWER*\nbad\ndisplay\nconditions\ntwo conditions needed\nfor termination of QUESTION*\nwhile more questions in quiz\nfor termination of BADANSWER*\nnow just transcribe into code\nfollow the structure:\nwhile (more questions) {\n// displayQuestion\nwhile (answer is bad)\n// badAnswer\n// displayErrMsg\nAnswer\nErrMsg\n}\n// goodAnswer\n}\n(c) Daniel Jackson 2008\nHaving assigned the operations, you write down the conditions for loops and choices -- in this\ncase, just loops. Now we can just transcribe directly to code, with the structure following the\nstructure of the diagram. Check that you understand how the code on the left is related to the\ndiagram on the right, and see the next slide for the code fleshed out in full.\n\n}\n\n}\n\ncode\nprivate static void runQuiz(Quiz quiz) throws IOException {\n\nfor (Question question: quiz.getQuestions()) {\n\nSystem.out.println (question);\n\n// display question\n\nreadLine();\n\n// read line\n\nint maxIndex = 'a' + question.getNumOptions() - 1;\n\nwhile (!isEOF() && badResponse(maxIndex)) {\n\nSystem.out.println\n\n// display error message\n\n(\"Answer must be between a and \" + (char)maxIndex);\n\nreadLine();\n\n// read line\n\n}\n\nchar choice = response.charAt(0);\n\n// increment\n\nscore += question.getScore(choice);\n\n// ... score\n}\nSystem.out.println (quiz.interpretScore(score));\n// display score\n\nprivate static boolean badResponse (int maxIndex) {\n\nreturn response.length() != 1\n\n||\n\nresponse.charAt(0) < 'a'\n\n|| response.charAt(0) > maxIndex;\n(c) Daniel Jackson 2008\n\ndesigning a file format:\na more detailed example\nNow we consider the other stream processing problem: reading in the quiz template. This is more\ncomplicated in terms of the structure (but simpler in one respect -- there's are no output events to\nconsider, so we don't need to worry about reading too early).\n\ndesigning operations\nwhere do the operations come from?\nfrom datatypes we invent\nmore on this later in the course\nconsiderations\nwhat objects do we need to construct?\nQuiz: the quiz object derived from the file\nQuestion: one of these for each question\nOption: one for each option of each question\nScorer: for interpreting the total score\nwhat observations do we need to make about them?\n(c) Daniel Jackson 2008\nThe operation list that I showed earlier came out of thin air a bit. Here I'll explain more\nprescriptively how you construct it. A good place to start is to think about what abstract datatypes\nyou need, and what their operations should. We'll be covering this in detail in the second third of\nthe course.\nThe way to start thinking about the datatypes is to ask first what kind of objects we need to\nconstruct (questions, options, etc), and then what kinds of observations we'll need to make of them.\n\norigins of operations\nfor construction of objects\nQuiz from Questions\n--> Quiz.new\nQuestion from text and Options\n--> Question.new\nOption from text and value\n--> Option.new\nScorer from range and message\n--> Scorer.new, Scorer.fromRange\nfor observation of objects\nfrom Quiz, get Questions\n--> Quiz.getQuestions\nfrom Question, get text, num options\n--> Question.toString, getNumOptions\nfrom Question, get score for choice\n--> Question.getScore(index)\nfrom Quiz, get interpretation of score\n--> Quiz.interpretScore\nfor internal observations\nfrom Option, get text and value\n--> Option.getValue, toString\nfrom Scorer, get interpretation of score --> Scorer.interpretScore\n(c) Daniel Jackson 2008\nHere's how I thought about what methods I'd need: first the constructors, then the observers. The\nobservers for Option and Scorer are internal in the sense that they're observations made with a Quiz\nor Question. For example, the program will call Quiz.interpretScore to interpret a score, and that\nwill then call the method of the same name in Scorer. This design idiom is called \"Facade\" and limits\ndependences, by having access to types like Option and Scorer go through Quiz and Question. Take\na look at slide 22 and you'll see that the code that executes the quiz only sees these two types, and\nis therefore decoupled from the other types.\n\ndatatypes designed\npublic class Quiz implements Iterable<Question> {\n\npublic Quiz (Scorer scorer, List<Question> questions)\n\npublic String interpretScore (int score)\n\npublic List<Question> questions()\n}\npublic class Question {\n\npublic Question (String text, List<Option> options)\n\npublic int getNumOptions ()\n\npublic int getScore (char index)\n\npublic String toString ()\n}\npublic class Option {\n\npublic Option (String optionText, int value)\n\npublic int getValue()\n\npublic String toString ()\n}\npublic class Scorer {\n\npublic String interpretScore (int score)\n\npublic Scorer rangeElse (final int lo, final int hi, final String msg) {\n}\n(c) Daniel Jackson 2008\nHere are the methods shown in Java. The Scorer.rangeElse method is the only one that's slightly\ntricky. I designed it like this because I knew I would want to construct a scorer incrementally, one\nrule at a time (where a rule consists of a range of values and a message to be displayed). So I chose\nto define a method that takes a scorer (the receiver argument), and range from lo to hi, and a\nmessage, and displays that message if the score is in that range, and otherwise uses the receiver\nscorer.\n\ndesigning a grammar\nconsiderations\nshould it be human readable?\nshould it be human writeable?\neasy to parse (one lookahead)\neasy to detect errors (redundant)\nissues arising in this case\nhow to delineate new option?\nnew question? scoring rules?\nallow linebreaks in options?\npredicate syntax? <, >?\nmissing scoring rules?\n(c) Daniel Jackson 2008\nWhat is the capital of France?\n[1]Paris\n[0]London\n[0]Brussels\nWhich of these bodies of water is the largest?\n[1]Pacific Ocean\nNorth Sea\nWalden Pond\nWhich of these is not a continent?\nAsia\nAfrica\nNorth America\n[1]Finland\nWhich city is at approximately the same latitude as Boston?\nRio de Janeiro\n[1]Rome\nAmsterdam\nWhat is a geocache?\nA form of payment that geologists use\n[1]A place that things are hidden in a treasure-hunting game\nA memory used to accelerate the performance of GPS devices\n0-1:Don't worry. Most people don't know anything either.\n2-3:You're obviously a real globe trotter.\n4-5:You know so much, you could be President!\nSometimes the grammar is given, but often you get to design it yourself. There are lots of\nconsiderations. Here the biggest question was whether to treat linebreaks as syntactically\nsignificant. By answering yes, I made the design of the program easier, and I made it easier to write\nthe quiz template (because you don't need to indicate which lines are question stems and which are\noptions -- the options always follow line by line after the stem). This seemed reasonable to me\nbecause (a) most editors do soft line wrapping, so if you had a long question, you could edit in on\nmultiple \"lines\" anyway, and (b) the displaying code can wrap the line if it's too long.\n\ndecisions\nchoices I made and their rationale\nuse linebreaks for end of question stem, option, scoring rule\nmakes parsing easier, and gives cleaner look (fewer blank lines or special marks)\nprevents multiline messages, but displayer can break into lines\nallows option value to be omitted, since linebreak delineates option\nrequire all scoring predicates to be simple range, eg 0-3\neasier to parse, extra flexibility not very useful\ndelineate option values [0] and scoring ranges 0-3: with special chars\nmakes parsing easier, allows easy checking that these are numeric\nallow any number of blank lines between questions\nno harm to give a bit more flexibility\nallow scoring rules to be omitted\njust use a default message if no applicable rule\n(c) Daniel Jackson 2008\nMore discussion of various possibilities in the design of the grammar and what I decided to do.\n\nthe grammar\nQUIZ\nSTEM\nQUESTIONS\nSCORING\nplan to parse individual lines by\nrandom access, so use diagram\nonly for structure down to lines\nQUESTION*\nRULE*\nexpress line structure textually:\nOption ::= Value? Text\nOPTIONS\nBLANKS\nValue ::= [ digit+ ]\nText ::= char*\nRule ::= Range Message\nOPTION+\nBLANK+\nRange ::= digit+ - digit+ :\nMessage ::= char*\n(c) Daniel Jackson 2008\nHere's the JSP grammar for my design. I only took it down to lines, since I knew that for parsing a\nRULE or an OPTION I would use random access operations rather than using the JSP method\ncharacter by character. For example, in RULE, I planned to call a method to find out where the\nhyphen and colon are, and then to use the String.substring method to pull out the hi and low\nbounds. I've written the structure of the parts not covered in the diagram in the textual grammar on\nthe right just for completeness. If you expect people to satisfy some formatting rules, you have to\ngive them precisely as a grammar.\n\nwhere we are heading\ngrammar gives code structure immediately\nwhile (more questions) {\n// process STEM\nwhile (more options)\n// process OPTION\nwhile (more blank lines)\n// process BLANK\n}\nwhile (more rules)\n// process RULE\nissue is how to fill it out\nSTEM\nwhat operations, and in what order?\nwhat are the loop conditions?\nQUIZ\nQUESTIONS\nQUESTION*\nOPTIONS\nBLANKS\nOPTION+\nSCORING\nRULE*\nBLANK+\n(c) Daniel Jackson 2008\nThis shows the relationship between the control structure of the code that we're going to end up\nwith and the structure of the stream, shown in the JSP diagram. To flesh out the code, we'll need to\nfigure out what the operations are, and assign them to the appropriate components in the structure,\nand to determine the conditions for the loops.\n\nlisting operations operations\nprimary state variables\nlist of questions so far\nList<Question> questions\nlist of options so far\nList<Option> options\nscorer so far\nScorer scorer\nnext line to be processed\nString nextLine\nhow to enumerate ops\none variable at a time\ninitializations, updates, finalizations\n(c) Daniel Jackson 2008\nthen operations these depend on\n\nnextLine = reader.readLine()\nquestions = new List<Question>()\nquestions.add(q)\nscorer = new Scorer()\nscorer = scorer.rangeElse(lo, hi, msg)\nquiz = new Quiz(questions, scorer)\noptions = new List<Option>()\noptions.add(o)\nq = new Question(stem, options)\no = new Option (opt, val)\nlo = ...nextLine...\nhi = ...nextLine...\nmsg = ...nextLine...\nstem = ...nextLine...\nopt = ...nextLine...\nval = ...nextLine...\nHere's how to go about listing the operations. First, list the basic variables you know you'll need. In\nthis case, I know I'm going construct a quiz object from a list of questions, so I'l need to grow this\nlist as I read the questions. Similarly, I'll need a list of options for each question. And as I\nmentioned before, I'm going to grow the scorer incrementally too, rule by rule. Finally, there's the\nline that's read from the stream.\nNow for each of these variables, consider how it's initialized, how it's updated, and whether there's\nany final operation to be done on it. Take questions, for example: we need to initialize it to the\nempty list (2), and add a question to it (3). Some of these operations suggest new state variables\nand operations that will be needed. For example, when I add a question with (3), I need to form the\nquestion. So that suggests that I use the constructor (9), which then suggests I need to construct\nthe stem (14) and the options (7). And so it goes on until it bottoms out. This might seem\ncomplicated, but it's pretty easy once you get the hang of it. The statements from 11 onwards all\ninvolve doing some parsing of nextLine using the substring and indexOf methods, the details of\nwhich I've omitted from the list. See the code for the details.\n\nassigning operations\nfor each operation, ask\nQUIZ\nhow many times should it be executed?\nonce per what?\nQUESTIONS\nSCORING\nbefore which other ops?\nthen\nQUESTION*\nRULE*\nchoose grammar element\nplace operation in position\nexample\nSTEM\nOPTIONS\nBLANKS\n3 and 9 are once per QUESTION, at end\n9 must go before 3\nOPTION+\nBLANK+\n3 questions.add(q)\n9 q = new Question(stem, options)\n(c) Daniel Jackson 2008\nNow we assign the operations, using the \"once per what rule\", and considering any required\ndataflow order. So for example the adding of a question (9) and the creation of a new question (3)\nobviously happen once per question, at the end of that component, and the question has to be\ncreated before added, so (9) precedes (3).\n\nassigning operations, ctd\nother examples\n2 questions = new List<Question>()\n// once per QUIZ, at start\n3 questions.add(q)\n// once per QUESTION, at end\n4 scorer = new Scorer()\n// once per QUIZ, at start\n5 scorer = scorer.rangeElse(lo, hi, msg)\n// once per RULE\n6 quiz = new Quiz(questions, scorer)\n// once per QUIZ, at end\n7 options = new List<Option>()\n// once per QUESTION, at start\n8 options.add(o)\n// once per OPTION\n9 q = new Question(options)\n// once per QUESTION, at end\n10 o = new Option (opt, val)\n// once per OPTION\n(c) Daniel Jackson 2008\nHere's what happens when I apply the \"once per what\" rule to each of the operations.\n\nassignments, all but read\nQUIZ\nQUESTIONS\nQUESTION*\nOPTIONS\nBLANKS\nSTEM\nOPTION+\nSCORING\nRULE*\nBLANK+\n(c) Daniel Jackson 2008\nNow I assign them...\n\nassigning the read operation\nsingle readahead rule\nread once at the start\nread once after each record is consumed\nSTEM\nOPTION+\nBLANK+\n(c) Daniel Jackson 2008\nThe read operation is a bit trickier. Logically, you would just associated a read with each component\nthat corresponds to a line: STEM, OPTION, BLANK and RULE. But this doesn't take account of the fact\nthat the program will need to evaluate the looping conditions: we'll need to know if we have another\nquestion, for example. So in general the reads need to be done ahead of the conditions. This is\ncalled \"readahead\" or \"lookahead\". Usually looking ahead one record suces. In fact, in this case, I\ndesigned the grammar to ensure that. So we just pull the reads back one step: we read right at the\nbeginning, and then _after_ each record is consumed. See how I've placed the read ops -- the (1)'s\n-- in the diagram.\nQUESTIONS\nQUESTION*\nOPTIONS\nBLANKS\nQUIZ\nSCORING\nRULE*\n\ncompleted assignments\nQUIZ\nQUESTIONS\nQUESTION*\nOPTIONS\nBLANKS\nSTEM\nOPTION+\nSCORING\nRULE*\nBLANK+\n(c) Daniel Jackson 2008\nHere's the final structure with all the operations, read included, assigned.\n\n}\n\n}\nconditions\nfor each iteration or choice\nwrite a condition\nexamples\nQUESTION*: !isEOF() && nextLine.charAt(0) != '['\nOPTION*: !isBlankLine()\nBLANK*: isBlankLine()\nRULE*: !isEOF()\nusing auxiliary predicates, eg:\n\nprivate boolean isBlankLine () {\n\nreturn nextLine != null && nextLine.trim().length()==0;\n\nprivate boolean isEOF () {\n\nreturn nextLine==null;\n(c) Daniel Jackson 2008\nNow we write the conditions. Often it's convenient to introduce procedures to give cleaner structure\nto the conditions: here I've introduced ones for determining whether the next line is blank or\nrepresents end of file. note that the QUESTION* condition has to include the EOF check, because\nthere may be no RULEs.\n\nputting it all together\nnow just read code off the diagram!\ncan introduce methods for boxes\nQUESTION*\nOPTIONS\nBLANKS\nSTEM\nOPTION+\nBLANK+\nexample: QUESTION\n7 options = new List<Option>()\n14 stem = ...nextLine...\n1 nextLine = reader.readLine()\nwhile (!isBlankLine())\nreadOption();\nwhile (isBlankLine())\n1 nextLine = reader.readLine();\n3 questions.add(q)\n9 q = new Question(stem, options)\n(c) Daniel Jackson 2008\nThe final step is the easy one. We just populate the skeletal structure (see slide 30) from the\ndiagram.\n\ngrammars, machines, regexps\nA few general points and observations about the relationship between grammars and machines, and\nsome comments about other uses of regular expressions.\n\nexpressions vs. grammars\ncan always write a regular grammar in one production\nthen the RHS is called a regular expression\nconsists of terminals and operators\nSWITCH ::= (up down)*\ncan also write a grammar with only sequence and choice\nbut allow special symbol for empty string\nand allow recursion on the left (or right) but not both\nSWITCH ::= | (up down SWITCH)\n(in general multiple productions)\n(c) Daniel Jackson 2008\nYou can actually write a regular grammar without any of these regular expression operators, so\nlong as ou have concatenation, and can show multiple options for a non-terminal -- here with the\nbar operator, but often done just by giving multiple productions for a single non-terminal. You\nneed recursion to replace iteration, and you also need a special symbol for the empty string. If you\ncan refer to a non-terminal recursively in any position on the RHS of a production, you don't have a\nregular grammar -- it becomes \"context free\". In a regular grammar, the recursive uses have to be\non the extreme left or extreme right (and you can't mix both in a single grammar).\n\ngrammars and machines\nregular grammars vs state machines\na state machine's trace set is prefix closed: if t^e is a trace, so is t\nregular grammars can express trace sets that are not prefix closed\ntraces of (up down)* include <up, down> but not <up>\nso grammars are more expressive\nbut can add \"final\" states to state diagrams\nthen define (full) traces as those that go from initial to final states\nnow grammars and machines are equally expressive\nthey both define regular languages\nin practice\nuse state machines for non-terminating systems\nuse grammars for terminating and non-terminating systems\n(c) Daniel Jackson 2008\nRegular grammars are equivalent in expressive power to state machines, with one caveat. Our\ngrammars allow us to describe the notion of a full trace. For example, the grammar for SWITCH ::=\n(up down)* defines the traces <>, <up, down>, <up, down, up, down>, but it does not include\n\"incomplete\" traces like <up, down, up>. Recall that our definition of the state machine notation\nwas that every sequence of transitions that the machine allows is a trace, so the language of\nsentences it defines is \"prefix closed\", meaning that if t^e (t with e appended) is a trace, then so is\njust t. To make up for this dierence, we can introduce \"final\" or \"acceptor\" states in the state\nmachine, and say that an event sequence is only a trace if it starts at the initial state and ends at a\nfinal state. This is the definition of state machine usually used in theoretical CS, but it's not used in\nsoftware engineering practice, because state machines are used to describe reactive processes that\ndon't terminate, so the notion of a \"complete trace\" isn't needed.\n\ngrammars\nlanguage definitions\nusually include grammars\nnot usually regular, but context free\na context free grammar\njust like a regular grammar in basic form\nbut non-terminals can be used recursively anywhere\nextended Backus-Naur form (EBNF)\nthe name for the (meta!) language of grammars in the form we've seen\n(c) Daniel Jackson 2008\nThe grammars you'll see in programming language definitions generally have full recursion -- an\nexpression can contain arbitrary subexpressions, eg -- so they're context free and not regular, and\ncould not be defined with state machines. A nice feature of the grammar/JSP approach is that it\nextends nicely to the context free case so long as the programming language you're transcribing\ninto supports recursion (which Java does, of course).\nThis grammar notation, with productions and regular expression operators, is called EBNF.\n\nregular expression matching\nwidely used in programming tools\nin Java, can use REs for parsing strings\nsee String.split, java.util.Regex\nbuilt-in to scripting languages such as Perl, Python, Ruby\navailable for find/replace in many editors\nremove trailing whitespace\nfind pattern:\n[\\t ]*\\r\n[\\t ]* means an iteration of tab or space\nreplace pattern: \\r\nreplace by just newline character\nconvert Pascal comment to C comment\nfind pattern:\n{([^}]*)} [^}]* means an iteration of any char that is not }\nreplace pattern: /* \\1 */\n\\1 binds to all chars that matched inside ()\n(c) Daniel Jackson 2008\nRegular expressions are widely used for search and replace. The examples on this slide are from\nBBEdit, my favorite Mac text editor. Typically, regular expression packages have all kinds of features\nthat actually take them well beyond regular languages.\n\nsummary\n\nprinciples\nfor a structured stream\nuse a grammar, not a state machine\nderive code structure from stream structure\nexpress stream structure as regular grammar\ndefine operations, and assign to grammar elements\nread code off annotated structure\nif in doubt, read ahead\nnovices usually read too late; leads to ugly ifs and gotos\ndesign grammars for single lookahead if possible\n(c) Daniel Jackson 2008\nHere are the principles from today. You should use the JSP strategy whenever you're processing a\nstream. It's simple and reliable, and you'll find that if you don't use it you can get into a real mess.\nSee the article \"Getting it Wrong\" by Michael Jackson in the Cameron book (see next slide for cites).\n\nreferences\nfor more information on regular grammars\nhttp://en.wikipedia.org/wiki/Regular_grammar\nhttp://en.wikipedia.org/wiki/Regular_language\nhttp://en.wikipedia.org/wiki/Regular_expression\non the JSP technique\nthe original paper: http://mcs.open.ac.uk/mj665/ECI1976.pdf\n'getting it wrong': http://mcs.open.ac.uk/mj665/GetWrong.pdf\nsome online materials\nhttp://en.wikipedia.org/wiki/Jackson_Structured_Programming\nhttp://www.jacksonworkbench.co.uk/stevefergspages/jackson_methods\n(c) Daniel Jackson 2008\nBoth of the JSP papers are short and easy to read. The Getting it Wrong paper is a nice illustration of\nthe mess programmers often get into when they design a stream processing program without\nunderstanding how to structure the code around the structure of the stream."
    },
    {
      "category": "Resource",
      "title": "Event-Based Programming",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-005-elements-of-software-construction-fall-2008/bafbe510b91313d9cca4fc590f3add45_MIT6_005f08_lec17.pdf",
      "content": "MIT OpenCourseWare\nhttp://ocw.mit.edu\n6.005 Elements of Software Construction\nFall 2008\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms.\n\nJButton\nJButton\nJButton\nThumbnail\nThumbnail\nThumbnail\nThumbnail\nToday's lecture\nComposite pattern\n3⁄4Example: view hierarchy in GUIs\nEvent-based programming\n3⁄4E\nle:\ndlingiin graphihicall useriinterf\nExampl iinput handli\nfaces\nModel-view-controller pattern\n3⁄4Found throughout user interfaces\nEvent-Based Programming\nRob Miller\nFall 2008\n(c) Robert Miller 2008\n(c) Robert Miller 2008\nGraphical User Interfaces\nView Hierarchy\nGUIs are composed from small reusable pieces\nA GUI is structured as a hierarchy of views\n3⁄4A view is an object that displays itself on a rectangular region of the screen\nJFrame\nJSplitPane\nJPanel\nJScrollPane\nwindow (JFrame)\nbutton (JButton)\ntree widget\n(JTree)\n(c) Robert Miller 2008\nsplitter bar\n(JSplitPane)\nscrolling pane\n(JSplitPane)\nS\nll\n(c) Robert Miller 2008\nJPanel\nJScrollPane\nJPanel\nThumbnail\nJButton\nJTree\nJP\nl\n\nThumbnail\nThumbnail\nJButton\nJButton\nJButton\nThumbnail\nThumbnail\nThumbnail\nThumbnail l\ndeleteAlbum:\nMouseListener\nnot to be confused with\nobserver methods in a\ndatatype\nComposite Pattern\nView hierarchy is an example of the Composite pattern\n3⁄4Primitive views don't contain other views\n- button, tree widget, textbox, thumbnail, etc.\n3⁄4Composite views are used for grouping or modifying other views\n3⁄4Composite views are used for grouping or modifying other views\n- JSplitPane displays two views side-by-side with an adjustable splitter\n- JScrollPane displays only part of a view, with adjustable scrollbars\nKey idea\n3⁄4primitives and composites implement a common interface (JComponent)\n3⁄4containers can hold any JComponent, so both primitives and other\ncontainers\nHow the View Hierarchy Is Used\nOutput\n3⁄4GUIs change their output by mutating the view hierarchy\n- e.g., to show a new set of photos, the current Thumbnails are removed\nfrom the tree and a new set ofThumbnails is added in their place\nfrom the tree and a new set of Thumbnails is added in their place\n3⁄4A redraw algorithm automatically redraws the affected views using the\ninterpreter pattern (paint() method)\nInput\n3⁄4GUIs receive keyboard and mouse input by attaching listeners to views\n(more on this in a bit)\nLayout\nJScrollPane\nJTree\n3⁄4An automatic layout algorithm automatically calculates positions and sizes\nof views using the interpreter pattern (doLayout() method)\n- Specialized composites (JSplitPane, JScrollPane) do layout themselves\n- Generic composites (JPanel, JFrame) delegate layout decisions to a\nlayout manager (e.g. FlowLayout,GridLayout, BorderLayout, ...)\n(c) Robert Miller 2008\nJScrollPane\nJPanel\nThumbnail\n(c) Robert Miller 2008\nHandling Mouse Input\nCentralized approach?\nwhile (true) {\nread mouse click\nif (clicked on New Album) doNewAlbum();\nif (clicked on New Album) doNewAlbum();\nelse if (clicked on Delete Album) doDeleteAlbum();\nelse if (clicked on Add Photos) doAddPhotos();\n...\nelse if (clicked on an album in the tree) doSelectAlbum();\nelse if (clicked on +/- button in the tree) doToggleTreeExpansion();\n....\nelse if (clicked on a thumbnail) doToggleThumbnailSelection();\n...\nNot modular!\n3⁄4Mixes up responsibilities for button panel, album tree, and thumbnails all in\none place\n(c) Robert Miller 2008\nInput Handling on the View Hierarchy\nInput handlers are associated with views\n3⁄4Also called listeners, event handlers, subscribers, and observers\nJFrame\nJSplitPane\nJPanel\nJScrollPane\nJPanel\nJPanel\nJScrollPane\nselectThumbnail:\nMouseListener\n(c) Robert Miller 2008\nJTree\nJButton\nThumbnai\nnewAlbum:\nMouseListener\nselectAlbum:\nMouseListener\nnot to be confused with\nobserver methods in a\ndatatype\n\n-\nEvent-Based Programming\nControl flow through a graphical user interface\n3⁄4A top-level event loop reads input from mouse and keyboard\n3⁄4For each input event, it finds the right view in the hierarchy (by looking at\nthe x,y position of the mouse) and sends the event to that views listeners\nthe x,y position of the mouse) and sends the event to that view's listeners\n3⁄4Listener does its thing (e.g. modifying the view hierarchy) and returns\nimmediately to the event loop\n(c) Robert Miller 2008\nPublish-Subscribe Pattern\nGUI input handling is an example of the Publish-\nSubscribe pattern\n3⁄4aka Listener, Event, Observer\nAn event source generates a stream of discrete events\nAn event source generates a stream of discrete events\n3⁄4In this example, the mouse is the event source\n3⁄4Events are state transitions in the source\n3⁄4Events often include additional info about the transition (e.g. x,y position of\nmouse), bundled into an event object or passed as parameters\nListeners register interest in events from the source\n3⁄4Can often register only for specific events - e g\ne.g., only want mouse events\n3⁄4Can often register only for specific events\nonly want mouse events\noccurring inside a view's bounds\n3⁄4Listeners can unsubscribe when they no longer want events\nWhen an event occurs, event source distributes it to all\ninterested listeners\n(c) Robert Miller 2008\nA Closer Look at Listeners\nJComponent\nListener\ninterface MouseListener {\nvoid mousePressed(MouseEvent e);\nid\nR l\nd(M\nE\n)\nvoid mouseReleased(MouseEvent e);\nvoid mouseMoved(MouseEvent e);\n...\n}\nclass JComponent {\n...\npublic void addMouseListener(MouseListener l) ...\npublic void removeMouseListener(MouseListener l) ...\nprivate void fireMousePress(int x, int y) {\nMouseEvent event = new MouseEvent(..., x, y, ...);\nfor (MouseListener l : listeners) {\nl.mousePressed(e);\n}\n}\n}\nComponent is very weakly coupled to its listeners\n3⁄4Component doesn't depend on the identity of the listening class, only that\nit implements the MouseListener interface\n3⁄4Component doesn't depend on the number of listeners, and listeners can\ncome and go\n(c) Robert Miller 2008\nOther Examples of Publish-Subscribe\nHigher-level GUI input events\n3⁄4JButton sends an action event when it is pressed (whether by the mouse\nor by the keyboard)\n3⁄4JTree sends a selection event when the selected element changes (whether\n3⁄4JTree sends a selection event when the selected element changes (whether\nby mouse or by keyboard)\n3⁄4JTextbox sends change events when the text inside it changes for any\nreason\nInternet messaging\n3⁄4Email mailing lists\n3⁄4IM chatrooms\n(c) Robert Miller 2008\n\nthe system\ndata\nn\no\nati\nci\nppl\na\nes\nstor\nModel\n3⁄4\nSeparating Frontend from Backend\nWe've seen how to separate input and output in GUIs\n3⁄4Output is represented by the view hierarchy\n3⁄4Input is handled by listeners attached to views\nMissing piece is the backend of\nthe system\n3⁄4Backend (aka model) represents the actual data that the user interface is\nshowing and editing\n3⁄4Why do we want to separate this from the user interface?\nModel-View-Controller Pattern\nModel-View-Controller (MVC) separates responsibilities\n3⁄4View displays output\n3⁄4Controller handles input\n3⁄4Model stores application data\n(c) Robert Miller 2008\nA More Detailed Look\nMVC with a Mutable Model\nListener interface decouples the view from the\nController mutates the model; model updates the view\ncontroller (somewhat) (e etRtF\n\nt\n\ni\nl\nDecoupling the Model from the View\nMore interfaces decouple the view and the model\nSummary of MVC\nView handles output\nController handles input\n- calls observers on the model to display it\n- listens for input events on the view hierarchy\n- listens for model changes and updates display\n- calls mutators on model or view\nAnother MVC Example:Textbox\nAdvantages of Model-View-Controller\nSeparation of responsibilities\n3⁄4Each module is responsible for just one feature\n- Model: data\n- View: output\n- C\nt\nl i\n\nContro er: nput\nDecoupling\n3⁄4View and model are decoupled from each other, so they can be changed\nindependently\n3⁄4Model can be reused with other views\n- e.g. JTree view that displays the full filesystem tree, and a JLabel view\nthat just displays the number of files\n3⁄4Multiple views can simultaneously share the same model\n3⁄4Views can be reused with other models, as long as the model implements\nan interface\n- e.g. JTree class (the view) and TreeModel interface\n(c) Robert Miller 2008\n\n11/7/2008\nRisks of Event-Based Programming\nSpaghetti of event handlers\n3⁄4Control flow through an event-based program is not simple\n3⁄4You can't follow the control just by studying the source code, because\ncontrol flow depends on listener relationships established at runtime\ncontrol flow depends on listener relationships established at runtime\n3⁄4Careful discipline about who listens to what (like the model-view-\ncontroller pattern) is essential for limiting the complexity of control flow\nObscured control flow leads to some unexpected\npitfalls...\n(c) Robert Miller 2008\nBasic Interaction of Event Passing\nSequence diagram is good for depicting control flow\n3⁄4Time flows downward\n3⁄4Each vertical time line shows one object's lifetime\n3⁄4Horizontal arrows show calls and returns trading control between objects\n3⁄4Horizontal arrows show calls and returns, trading control between objects\n3⁄4Dark rectangles show when a method is active (i.e., has been called but\nhasn't returned yet)\nclient\nsource\nlistener\ninterface Source {\naddListener\naddListener()\nremoveListener()\nobserver()\nmutator()\nmutator\nmutator()\n}\nchangeEvent\ninterface Listener {\nchangeEvent()\n}\n(c) Robert Miller 2008\nPitfall #1: Listener Calls Observers\nThe listener often calls methods on the source\n3⁄4e.g., when a textbox gets a change event from its model, it needs to call\ngetText() to get the new text and display it\n3⁄4So observer method calls may occur while the mutator is still in progress\n3⁄4So observer method calls may occur while the mutator is still in progress\nobserver\nclient\nsource\nlistener\nmutator\nchangeEvent\nWhy is this a potential problem?\n(c) Robert Miller 2008\nPitfall #1: Specific Example\nclass Filesystem {\nprivate Map<File, List<File>> cache;\npublic List<File> getContents(File folder) {\ncheck for folder in cache, otherwise read it from disk and update cache }\ncheck for folder in cache, otherwise read it from disk and update cache }\npublic void deleteContents(File folder) {\nfor (File f: getContents(folder)) {\nf.delete();\nfireChangeEvent(f, REMOVED); // notify listeners that f was deleted }\ncache.remove(folder); // cache is no longer valid for this folder}\n}\nSolution\n3⁄4source must establish rep invariant before giving up control to any listeners\n3⁄4often done simply by waiting to send events until end of mutator\n(c) Robert Miller 2008\n\n11/7/2008\nPitfall #2: Listener Calls Mutators\nThe listener might call mutator on the source\n3⁄4e.g., when two sources are listening to each other in order to keep their\nstate synchronized\n3⁄4So calls to mutators may occur while mutator is still in progress\n3⁄4So calls to mutators may occur while mutator is still in progress\nmutator\nclient\nsource1\nlistener\nmutator\nchangeEvent\nsource 2\nlistener\nchangeEvent\nmutator\nWhy is this a potential problem?\n(c) Robert Miller 2008\nPitfall #2: Specific Example\nChangeListener\nchange event\nsetText()\nJTextbox\nJSlider\nChangeListener\nChangeListener\nchange event\nsetValue()\nSolution\n3⁄4only send events when mutator actually causes a state change\n(c) Robert Miller 2008\nPitfall #3: Listener Removes Itself\nThe listener might call removeListener() on the source\n3⁄4This happens when the listener is done its work, e.g. a listener that\nexecutes a stock trade as soon as a certain price is reached\n3⁄4So calls to removeListener() may occur while mutator is still in progress\n3⁄4So calls to removeListener() may occur while mutator is still in progress\nremoveListener\nclient\nsource\nlistener\nset\nchangeEvent\nWhy is this a potential problem?\n(c) Robert Miller 2008\nPitfall #3: Specific Example\nclass Source {\nprivate Listener[] listeners;\nprivate int size;\npublic void removeListener(Listener l) {\nWhat happens if\nlisteners[i] removes\nitself here?\npublic void removeListener(Listener l) {\nfor (int i = 0; i < size; ++i) {\nif (listeners[i] == l) { listeners[i] = listeners[size-1]; --size; } }\nprivate void fireChangeEvent(...) {\nfor (int i = 0; i < size; ++i) listeners[i].changed(...); }\n}\n3⁄4Java collections (Set, List, etc) have the same problem:\nitself here?\nIt's not safe to mutate a collection while you're iterating over it\nSolution\n3⁄4fire events by iterating over a copy of the listeners data structure\n3⁄4or use javax.swing.EventListenerList which copies only when necessary\n(c) Robert Miller 2008\n\nSummary\nView hierarchy\n3⁄4Organizes the screen into a tree of nested rectangles\n3⁄4Used for dispatching input as well as displaying output\n3⁄4Uses the Composite pattern: compound views (windows, panels) can be\n3⁄4Uses the Composite pattern: compound views (windows panels) can be\ntreated just like primitive views (buttons, labels)\nPublish-subscribe pattern\n3⁄4An event source sends a stream of events to registered listeners\n3⁄4Decouples the source from the identity of the listeners\n3⁄4Beware of pitfalls\nMVC pattern\nMVC pattern\n3⁄4Separation of responsibilities: model=data, view=output, controller=input\n3⁄4Decouples view from model\n(c) Robert Miller 2008"
    }
  ]
}