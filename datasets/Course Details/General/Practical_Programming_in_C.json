{
  "course_name": "Practical Programming in C",
  "course_description": "This course provides a thorough introduction to the C programming language, the workhorse of the UNIX operating system and lingua franca of embedded processors and micro-controllers. The first two weeks will cover basic syntax and grammar, and expose students to practical programming techniques. The remaining lectures will focus on more advanced concepts, such as dynamic memory allocation, concurrency and synchronization, UNIX signals and process control, library development and usage. Daily programming assignments and weekly laboratory exercises are required. Knowledge of C is highly marketable for summer internships, UROPs, and full-time positions in software and embedded systems development.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering"
  ],
  "syllabus_content": "This course makes use of Athena, MIT's UNIX-based computing environment. OCW does not provide access to this environment.\n\nCourse Meeting Times\n\nLectures: 5 sessions / week for 3 weeks, 1.5 hours / session\n\nLabs: 1 session / week for 3 weeks, 3 hours / session\n\nPrerequisites\n\nThis course assumes a basic understanding of the principles of programming. Prior knowledge of C is neither expected nor desired. The primary prerequisite of this course is 6.00\nIntroduction to Computer Science and Programming\n, 1.00\nIntroduction to Computers and Engineering Problem Solving\n, 6.01\nIntroduction to Electrical Engineering and Computer Science I\n, or another introductory programming course at MIT. If you are unsure of the adequacy of your programming background, please speak to a member of the course staff as soon as possible. As the duration of this course is only three weeks, the material will be covered at a relatively fast pace, and catching up will be difficult.\n\nTexts\n\nThere is no required text for the course. However, the following text is highly recommended:\n\nKernighan, Brian, and Dennis Ritchie.\nThe C Programming Language\n. 2nd ed. Upper Saddle River, NJ: Prentice Hall, 1988. ISBN: 9780131103627.\n\nThis text provides a concise and thorough coverage of the C programming language, including exercises. Suggested readings from this book may enhance your understanding of the material covered in lectures.\n\nLectures and Lab Sessions\n\nWhile attendance will not be formally taken at the lectures, attending every lecture is crucial to learning the material necessary to complete the assignments and projects. Handouts generally will not be provided in printed form. However, slides will be posted before lectures, and you are welcome to print them yourselves. Some students may seek to take another course that overlaps with the lecture time and either come late to lecture or leave early. This should be avoided, as it disrupts the lectures and distracts the rest of the class.\nPlease avoid interrupting the class by arriving late or leaving early\n.\n\nDue to space constraints, the laboratory sessions are only open to those students taking the class for credit. The weekly laboratory sessions are mandatory to attend (for those receiving credit). As explained later, the projects will have both in-lab and out-of-class components, and it is expected that you will complete the in-lab portions during the three hours on Wednesday night. During the lab sessions, you will work in pairs to complete programming exercises that are connected to the overall programming project for that week. Lab assistants will be in lab at the time to assist you and verify that you have completed the in-lab exercises. While students are welcome to bring their laptops to the lab, the staff encourages students to use the Athena Linux computing environment present on the machines in the lab. Using a single standardized development environment will make debugging easier and ensure consistent results across machines.\n\nHomework\n\nHomework will be assigned daily through the first two weeks (7 assignments) and generally must be handed in at the beginning of the next lecture. Like any programming language, C is most easily mastered by using it to write programs. Therefore, the assignments will include small programming exercises. Homework will be graded coarsely (on a scale of 0-2), where 0 = minimal understanding demonstrated or inadequate effort shown in completing the problems, 1 = basic understanding of the concepts, but too many missed details, and 2 = thorough understanding of the concepts. Solutions to the homework will be provided after the assignment is due, so no late homework will be accepted or graded. If you have questions or desire additional feedback about a homework problem, please go to any of the staff's office hours for assistance. Because of the course grading scale, there will be no re-grades on homework.\n\nProjects\n\nIn addition to the small programming exercises in homework assignments, this course will include three more extensive programming assignments in the form of projects. The first two projects will consist of an in-lab component composed of more structured programming problems dealing with specific concepts and an out-of-class component that will tie these concepts together to form a larger program. The in-lab component will be completed in pairs, and will require a lab assistant's signature verifying satisfactory completion of the in-lab exercises to receive credit. The out-of-class component should be completed alone, and the final program will be due at the beginning of the following week.\n\nThe third (final) project will be more open-ended, to give you a chance to express your creativity, and expose you to a more realistic programming experience. In teams of two, you will propose and implement a program that involves using one or more publicly available libraries to accomplish some non-trivial task. Suggestions of possible libraries and related programs are provided in the project handout. A written proposal must be submitted and approved by the instructors by the end of the second week of class. The final implementation and writeup of the project is due on the last day of class. The proposal and implementation should be completed as a team, but each student is expected to produce a final writeup and will be graded individually.\n\nThese projects are intended to provide you with the opportunity to develop a level of sophistication in programming in C. Therefore, in addition to correctness, points will be awarded for elegance, coding style, and a demonstrated understanding of the practical issues. Although some competitions reward obfuscation, practical programming requires a balance of clarity and conciseness. Therefore, all code should be well-documented, with comments, and the structure of the code should be straightforward.\n\nCourse Grade\n\nACTIVITIES\n\nPERCENTAGES\n\nHomework\n\n20%\n\nProject 1\n\n15%\n\nProject 2\n\n15%\n\nProject 3\n\n50%\n\nThis course is graded on a Pass/D/Fail grading scale. Grades will be assigned based on the staff's best assessment of your understanding of the C programming language, roughly based on the grading scale above (Pass ≈ ≥ 70%). Failure to complete and turn in homework assignments or the projects on time impedes the staff's ability to assess your level of understanding and may result in a failing grade.\n\nCollaboration and Cheating Policy\n\nYou are welcome to discuss assignments and laboratory projects with other students, provided that all work turned in must be your own. If you do discuss your work with other students on assignments, please list your collaborators at the top of your assignment, underneath your name. This does not excuse you from submitting your own work! For the in-lab parts of laboratory projects completed in teams, both team members should contribute equally and will be graded individually. The write-ups and out-of-class portions of labs must be completed independently.\n\nIn summary, when you are turning in an assignment with your name on it, what you turn in must be your work, and yours alone. Cheating will not be tolerated.",
  "files": [
    {
      "category": "Assignment",
      "title": "Problem Set 1",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/cd5418a0535359a7ac9aba2a1ab9fb71_MIT6_087IAP10_assn01.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 1\nWriting, compiling, and debugging programs. Preprocessor macros. C file structure. Variables.\nFunctions and program statements. Returning from functions.\nOut: Monday, January 11, 2010.\nDue: Tuesday, January 12, 2010.\nProblem 1.1\n(a) What do curly braces denote in C? Why does it make sense to use curly braces to surround\nthe body of a function?\n(b) Describe the difference between the literal values 7, \"7\", and '7'.\n(c) Consider the statement\ndouble ans = 10.0+2.0/3.0-2.0∗2.0;\nRewrite this statement, inserting parentheses to ensure that ans = 11.0 upon evaluation of\nthis statement.\nProblem 1.2\nConsider the statement\ndouble ans = 18.0/squared(2+1);\nFor each of the four versions of the function macro squared() below, write the corresponding value\nof ans.\n1. #define squared(x) x*x\n2. #define squared(x) (x*x)\n3. #define squared(x) (x)*(x)\n4. #define squared(x) ((x)*(x))\nProblem 1.3\nWrite the \"Hello, 6.087 students\" program described in lecture in your favorite text editor and\ncompile and execute it. Turn in a printout or screen shot showing\n- the command used to compile your program\n- the command used to execute your program (using gdb)\n- the output of your program\n\nProblem 1.4\nThe following lines of code, when arranged in the proper sequence, output the simple message \"All\nyour base are belong to us.\"\n1. return 0;\n2. const char msg[] = MSG1;\n3. }\n4. #define MSG1 \"All your base are belong to us!\"\n5. int main(void) {\n6. #include <stdio.h>\n7. puts(msg);\nWrite out the proper arrangement (line numbers are sufficient) of this code.\nProblem 1.5\nFor each of the following statements, explain why it is not correct, and fix it.\n(a) #include <stdio.h>;\n(b) int function(void arg1)\n{\nreturn arg1-1;\n}\n(c) #define MESSAGE = \"Happy new year!\"\nputs(MESSAGE);\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 1 — Solutions",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/656e0e2be308dc417a8ff800c4e69d6b_MIT6_087IAP10_assn01_sol.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 1 - Solutions\nWriting, compiling, and debugging programs. Preprocessor macros. C file structure. Variables.\nFunctions and program statements. Returning from functions.\nOut: Monday, January 11, 2010.\nDue: Tuesday, January 12, 2010.\nProblem 1.1\n(a) What do curly braces denote in C? Why does it make sense to use curly braces to surround\nthe body of a function?\nAnswer: The curly braces denote a block of code, in which variables can be declared. Variables\ndeclared within the block are valid only until the end of the block, marked by the matching\nright curly brace '}'. The body of a function is one such type of block, and thus, curly braces\nare used to describe the extent of that block.\n(b) Describe the difference between the literal values 7, \"7\", and '7'.\nAnswer: The first literal describes an integer of value 7. The second describes a null-\nterminated string consisting of the character '7'. The third describes the character '7',\nwhose value is its ASCII character code (55).\n(c) Consider the statement\ndouble ans = 10.0+2.0/3.0-2.0∗2.0;\nRewrite this statement, inserting parentheses to ensure that ans = 11.0 upon evaluation of\nthis statement.\nAnswer: double ans = 10.0+2.0/((3.0-2.0)∗2.0);\nProblem 1.2\nConsider the statement\ndouble ans = 18.0/squared(2+1);\nFor each of the four versions of the function macro squared() below, write the corresponding value\nof ans.\n1. #define squared(x) x*x\nAnswer: 18.0/2 + 1 ∗ 2 + 1 = 9 + 2 + 1 = 12.\n2. #define squared(x) (x*x)\nAnswer: 18.0/(2 + 1 ∗ 2 + 1) = 18/5 = 3.6.\n\n3. #define squared(x) (x)*(x)\nAnswer: 18.0/(2 + 1) ∗ (2 + 1) = 6 ∗ 3 = 18.\n4. #define squared(x) ((x)*(x))\nAnswer: 18.0/((2 + 1) ∗ (2 + 1)) = 18/9 = 2.\nProblem 1.3\nWrite the \"Hello, 6.087 students\" program described in lecture (slides 22 and 27) in your favorite\ntext editor and compile and execute it. Turn in a printout or screen shot showing\n- the command used to compile your program\n- the command used to execute your program (using gdb)\n- the output of your program\nAnswer:\ndweller@dwellerpc:~$ gcc -g -O0 -Wall hello.c -o hello.o\ndweller@dwellerpc:~$ gdb hello.o\nGNU gdb (GDB) 7.0-ubuntu\nCopyright (C) 2009 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>...\nReading symbols from /home/dweller/hello.o...done.\n(gdb) run\nStarting program: /home/dweller/hello.o\nhello, 6.087 students\nProgram exited normally.\n(gdb) quit\ndweller@dwellerpc:~$\n\nProblem 1.4\nThe following lines of code, when arranged in the proper sequence, output the simple message \"All\nyour base are belong to us.\"\n1. return 0;\n2. const char msg[] = MSG1;\n3. }\n4. #define MSG1 \"All your base are belong to us!\"\n5. int main(void) {\n6. #include <stdio.h>\n7. puts(msg);\nWrite out the proper arrangement (line numbers are sufficient) of this code.\nAnswer: 6, 4, 5, 2, 7, 1, 3. Note that line 4 also can go any place before line 2, and line 2 can also\ngo before the function starts in line 5. Also, line 6 can go anywhere before the function starts.\nProblem 1.5\nFor each of the following statements, explain why it is not correct, and fix it.\n(a) #include <stdio.h>;\nAnswer: Preprocessor macros like #include should not be terminated with semicolons. The\ncorrect code is:\n#include <stdio.h>\n(b) int function(void arg1)\n{\nreturn arg1-1;\n}\nAnswer: The void type signifies an empty variable, which cannot be used in any way. The\ncorrect code is:\nint function ( int arg1 )\n{\nreturn arg1 -1;\n}\n(c) #define MESSAGE = \"Happy new year!\"\nputs(MESSAGE);\nAnswer: The form of the #define statement does not include an assignment operator:\n#define MESSAGE \"Happy new year!\"\nputs (MESSAGE) ;\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 2",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/1d420c465b4225ebe6a8ceb42815c64c_MIT6_087IAP10_assn02.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 2\nTypes, operators, expressions\nOut: Tuesday, January 12, 2010.\nDue: Wednesday, January 13, 2010.\nProblem 2.1\nDetermine the size,minimum and maximum value following data types. Please specify if your\nmachine is 32 bit or 64 bits in the answer.\nchar\n-\n- unsigned char\nshort\n-\nint\n-\n- unsigned int\n- unsigned long\nfloat\n-\nHint: Use sizeof() operator,limits.h and float.h header files\nProblem 2.2\nWrite logical expressions that tests whether a given character variable c is\nlower case letter\n-\n- upper case letter\n- digit\n- white space (includes space,tab,new line)\nProblem 2.3\nConsider int val=0xCAFE; Write expressions using bitwise operators that do the following:\n- test if atleast three of last four bits (LSB) are on\n- reverse the byte order (i.e., produce val=0xFECA)\n- rotate fourbits (i.e., produce val=0xECAF)\n\nProblem 2.4\nUsing precedence rules, evaluate the following expressions and determine the value of the vari\nables(without running the code). Also rewrite them using parenthesis to make the order explicit.\nAssume (x=0xFF33,MASK=0xFF00).Expression: c=x & MASK ==0;\n-\nAssume (x=10,y=2,z=2;).Expression: z=y=x++ + ++y∗2;\n-\nAssume (x=10,y=4,z=1;).Expression: y>>= x&0x2 && z\n-\nProblem 2.5\nDetermine if the following statements have any errors. If so, highlight them and explain why.\n- int 2nd value=10;\nAssume (x=0,y=0,alliszero=1). alliszero =(x=1) && (y=0);\n-\nAssume (x=10,y=3,z=0;). y=++x+y;z=z-->x;\n-\n- Assume that we want to test if last four bits of x are on. (int MASK=0xF;ison=x&MASK==MASK)\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 2 — Solutions",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/63515d4218cf01ba460623cbe9dc3b5c_MIT6_087IAP10_assn02_sol.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 2 - Solutions\nTypes, operators, expressions\nOut: Tuesday, January 12, 2010.\nDue: Wednesday, January 13, 2010.\nProblem 2.1\nDetermine the size,minimum and maximum value following data types. Please specify if your\nmachine is 32 bit or 64 bits in the answer.\nchar\n-\n- unsigned char\nshort\n-\nint\n-\n- unsigned int\n- unsigned long\nfloat\n-\nHint: Use sizeof() operator,limits.h and float.h header files\nAnswer: On my 32-bit machine (/usr/include/limits.h,/usr/include/float.h), the sizes and limits\nare as follows. Results may differ if you used a 64 bit machine.\nData type\nsize (bytes)\nmin\nmax\nchar\nSCHAR MIN (-128)\nSCHAR MAX (127)\nunsigned char\nUCHAR MAX(255)\nshort\nSHRT MIN (-32768)\nSHRT MAX (32767)\nint\nINT MIN (-2147483648)\nINT MAX (2147483647)\nunsigned int\nUINT MAX(4294967295)\nunsigned long\nULONG MAX(4294967295)\nfloat\nFLT MIN(1.175494e-38)\nFLT MAX(3.402823e+38)\nProblem 2.2\nWrite logical expressions that tests whether a given character variable c is\n- lower case letter (Answer: c>='a'&& c<='z')\n- upper case letter (Answer: c>='A'&& c<='Z')\n- digit (Answer: c>='0'&& c<='9')\n\n- white space (includes space,tab,new line) (Answer: c=='\\n'|| c=='\\t'|| c=='')\nProblem 2.3\nConsider int val=0xCAFE; Write expressions using bitwise operators that do the following:\n(a) test if atleast three of last four bits (LSB) are on\n(b) reverse the byte order (i.e., produce val=0xFECA)\n(c) rotate fourbits (i.e., produce val=0xECAF)\nAnswer:\n(a) We have to test if last three or four bits are on. The possible values are 0x7,0xB,0xD,0xE,0xF.\nTo test this, first we extract the last four bits. ( int bits=val&0xF; /∗last four bits∗/). Next we\ntest if it is one of the possible patterns. ( bits==0x7 || bits==0xB || (bits>=0xD)).\n(b)\nval = ((0xFF & val) << 8) | (val>>8)\n(b)\nval = (val >> 4) | ((val&0xF)<<12)\nProblem 2.4\nUsing precedence rules, evaluate the following expressions and determine the value of the vari\nables(without running the code). Also rewrite them using parenthesis to make the order explicit.\n(a) Assume (x=0xFF33,MASK=0xFF00).Expression: c=x & MASK ==0;\n(b) Assume (x=10,y=2,z=2;).Expression: z=y=x++ + ++y∗2;\n(c) Assume (x=10,y=4,z=1;).Expression: y>>= x&0x2 && z\nAnswer:\n(a) The operator precedence is '=='>'&'>'='. Thus, the expression is equivalent to c= (x & (MASK==0)).\nTherefore x=0xFF33,c=0.\n(b) The operator precedence is '++'>'*'>'+'. Thus, the expression is equivalent to z =(x++) + ((++y)∗2).\nTherefore x=11,y=3,z=10+3∗2=16.\n(b) The operator precedence is '&'>'&&'>'>>='. Thus, the expression is equivalent to y>>= (x & 0x2) && z.\nTherefore x=10,y=2,z=1.\nProblem 2.5\nDetermine if the following statements have any errors. If so, highlight them and explain why.\n(a) int 2nd value=10;\n(b) Assume (x=0,y=0,alliszero=1). alliszero =(x=1) && (y=0);\n(c) Assume (x=10,y=3,z=0;). y=++x+y;z=z-->x;\n(d) Assume that we want to test if last four bits of x are on. (int MASK=0xF;ison=x&MASK==MASK)\n\nAnswer:\n(a) Variable names cannot start with a number.\n(b) '=' operator should be replaced with '=='. The correct version is alliszero =(x==1) && (y==0);.\n(c) There is nothing wrong with the statement. While --> may look suspicious, the expression\nsymplifies to y= (++x)+y; z=(z--)>x.\n(c) There is nothing syntatically wrong with the statement. However, what we want is ison=(x&MASK)==MASK.\nBased on operator precedence, the current expression simplifies to ison=x&(MASK==MASK)\nThese exercises should have convinced you to use () always.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 3",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/e69d005d49d18bbe6498104ebef9923c_MIT6_087IAP10_assn03.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 3\nControl flow. Functions. Variable scope. Static and global variables. I/O: printf and scanf. File\nI/O. Character arrays. Error handling. Labels and goto.\nOut: Wednesday, January 13, 2010.\nDue: Friday, January 15, 2010.\nProblem 3.1\nCode profiling and registers. In this problem, we will use some basic code profiling to examine\nthe effects of explicitly declaring variables as registers. Consider the fibonacci sequence generating\nfunction fibonacci in prob1.c, which is reproduced at the end of this problem set (and can be\ndownloaded from Stellar). The main() function handles the code profiling, calling fibonacci()\nmany times and measuring the average processor time.\n(a) First, to get a baseline (without any explicitly declared registers), compile and run prob1.c.\nCode profiling is one of the rare cases where using a debugger like gdb is discouraged, because\nthe debugger's overhead can impact the execution time. Also, we want to turn off compiler\noptimization. Please use the following commands to compile and run the program:\ndweller@dwellerpc:~$ gcc -O0 -Wall prob1.c -o prob1.o\ndweller@dwellerpc:~$ ./prob1.o\nAvg. execution time: 0.000109 msec\nexample output\n←\ndweller@dwellerpc:~$\nHow long does a single iteration take to execute (on average)?\n(b) Now, modify the fibonacci() function by making the variables a, b, and c register variables.\nRecompile and run the code. How long does a single iteration take now, on average? Turn\nin a printout of your modified code (the fibonacci() function itself would suffice).\n(c) Modify the fibonacci() function one more time by making the variable n also a register\nvariable. Recompile and run the code once more. How long does a single iteration take with\nall four variables as register variables?\n(d) Comment on your observed results. What can you conclude about using registers in your\ncode?\nProblem 3.2\nWe are writing a simple searchable dictionary using modular programming. First, the program\nreads a file containing words and their definitions into an easily searchable data structure. Then,\nthe user can type a word, and the program will search the dictionary, and assuming the word is\nfound, outputs the definition. The program proceeds until the user chooses to quit.\nWe split the code into several files: main.c, dict.c, and dict.h. The contents of these files are\ndescribed briefly below.\n\nmain.c:\ndict.c:\ndict.h:\n#include <stdio.h>\n#include \"dict.h\"\n/* data structure\n#include <stdlib.h>\nfor the dictionary */\n#include \"dict.h\"\n/* data structure\nchar * the dictionary[1000];\nfor the dictionary */\nint main() {\nchar * the dictionary[1000];\n/* declarations */\n...\nvoid load dictionary();\n}\nvoid load dictionary() {\n...\nchar * lookup(char []);\n}\nchar * lookup(char []) {\n...\n}\nAnswer the following questions based on the above program structure.\n(a) In implementing this program, you want to access the global variable the dictionary from\nmain.c, as well as from dict.c. However, due to the header file's inclusion in both source\ndocuments, the variable gets declared in both places, creating an ambiguity. How would you\nresolve this ambiguity?\n(b) Now, suppose you want to restrict the dictionary data structure to be accessible only from\nfunctions in dict.c. You remove the declaration from dict.h. Is it still possible to directly\naccess or modify the variable from main.c, even without the declaration in dict.h? If so,\nhow would you ensure the data structure variable remains private?\n(c) Congratulations! You're done and ready to compile your code. Write the command line\nthat you should use to compile this code (using gcc). Let's call the desired output program\ndictionary.o.\nProblem 3.3\nBoth the for loop and the do-while loop can be transformed into a simple while loop. For each\nof the following examples, write equivalent code using a while loop instead.\n(a) int f a c t o r i a l ( int n) {\nint i , ret = 1;\nfor ( i = 2; i <= n ; i++)\nret ∗= i ;\nreturn ret ;\n}\n(b) #include <s t d l i b . h>\ndouble rand double () {\n/∗ generate random number in [ 0 , 1 ) ∗/\ndouble ret = ( double ) rand ( ) ;\nreturn ret /(RAND MAX+1);\n}\nint sample geometric rv ( double p) {\n\ndouble q ;\nint n = 0;\ndo {\nq = rand double ( ) ;\nn++;\n} while (q >= p ) ;\nreturn n ;\n}\nNote: You only need to modify the sample geometric rv() function.\n\nProblem 3.4\n'wc' is a unix utility that display the count of characters, words and lines present in a file. If no\nfile is specified it reads from the standard input. If more than one file name is specified it displays\nthe counts for each file along with the filename. In this problem, we will be implementing wc.\nOne of the ways to build a complex program is to develop it iteratively, solving one problem\nat a time and testing it throroughly. For this problem, start with the following shell and then\niteratively add the missing components.\n#include <s t d i o . h>\n#include <s t d l i b . h>\nint main ( int argc , char∗ argv [ ] )\n{\nFILE∗ fp=NULL;\nint\nn f i l e s =--argc ; /∗ ignore the name of the program i t s e l f ∗/\nint\nargidx =1;\n/∗ ignore the name of the program i t s e l f ∗/\nchar∗ c u r r f i l e=\"\" ;\nchar\nc ;\n/∗ count of words , l i n e s , characters ∗/\nunsigned long nw=0, nl =0,nc =0;\ni f ( n f i l e s ==0)\n{\nfp=stdin ; /∗ standard input ∗/\nn f i l e s ++;\n}\nelse /∗ set to f i r s t ∗/\n{\nc u r r f i l e=argv [ argidx ++];\nfp=fopen ( c u r r f i l e , \"r\" ) ;\n}\nwhile ( n f i l e s >0) /∗ f i l e s l e f t >0∗/\n{\ni f ( fp==NULL)\n{\nf p r i n t f ( stderr , \"Unable to open input\\n\" ) ;\ne x i t ( -1);\n}\nnc=nw=nl =0;\nwhile (( c=getc ( fp ))! =EOF)\n{\n/∗TODO: FILL HERE\nprocess the f i l e using getc ( fp )\n∗/\n}\np r i n t f ( \"%ld %s\\n\" , nc , c u r r f i l e ) ;\n/∗ next f i l e\ni f e x i s t s ∗/\nn f i l e s --;\ni f ( n f i l e s >0)\n{\nc u r r f i l e=argv [ argidx ++];\nfp\n=fopen ( c u r r f i l e , \"r\" ) ;\n}\n}\nreturn 0;\n}\nHint: In order to count words, count the transitions from non-white space to white space characters.\n\n----------------------------\n----------------------------\nProblem 3.5\nIn this problem, we will be reading in formatted data and generating a report. One of the\ncommon formats for interchange of formatted data is 'tab delimited' where each line corresponds\nto a single record. The individual fields of the record are separated by tabs. For this problem,\ndownload the file stateoutflow0708.txt from Stellar. This contains the emigration of people\nfrom individual states. The first row of the file contains the column headings. There are eight self\nexplanatory fields. Your task is to read the file using fscanf and generate a report outlining the\nmigration of people from Massachusetts to all the other states. Use the field \"Aggr AGI\" to report\nthe numbers. Also, at the end, display a total and verify it is consistent with the one shown below.\nAn example report should look like the following:\nSTATE\nTOTAL\n\"FLORIDA\"\n\"NEW HAMPSHIRE\"\n..........\nTotal\nMake sure that the fields are aligned.\n\nCode listing for Problem 3.1: prob1.c\n#include <s t d l i b . h>\n#include <s t d i o . h>\n#include <time . h>\n#define NMAX 25\nstatic unsigned int r e s u l t s b u f f e r [NMAX] ;\nvoid f i b o n a c c i ()\n{\n/∗ here are the v a r i a b l e s to set as r e g i s t e r s ∗/\nunsigned int a = 0;\nunsigned int b = 1;\nunsigned int c ;\nint n ;\n/∗ do not e d it below t h i s l i n e ∗/\nr e s u l t s b u f f e r [ 0 ] = a ;\nr e s u l t s b u f f e r [ 1 ] = b ;\nfor (n = 2; n < NMAX; n++) {\nc = a + b ;\nr e s u l t s b u f f e r [ n ] = c ; /∗ s t o r e code in r e s u l t s b u f f e r ∗/\na = b ;\nb = c ;\n}\n}\nint main ( void ) {\nint n , n t e s t s = 10000000;\nc l o c k t tstart , tend ;\ndouble favg ;\n/∗ do p r o f i l i n g ∗/\nt s t a r t = clock ( ) ;\nfor (n = 0; n < n t e s t s ; n++)\nf i b o n a c c i ( ) ;\ntend = clock ( ) ;\n/∗ end p r o f i l i n g ∗/\n/∗ compute average execution time ∗/\nfavg = (( double )( tend - t s t a r t ))/CLOCKS PER SEC/ n t e s t s ;\n/∗ print avg execution time in m i l l i s e c o n d s ∗/\np r i n t f ( \"Avg. execution time: %g msec\\n\" , favg ∗ 1000);\nreturn 0;\n}\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 3 — Solutions",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/82fd6812c56caf3dadb60a13d08cfd2b_MIT6_087IAP10_assn03_sol.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 3 - Solutions\nControl flow. Functions. Variable scope. Static and global variables. I/O: printf and scanf. File\nI/O. Character arrays. Error handling. Labels and goto.\nOut: Wednesday, January 13, 2010.\nDue: Friday, January 15, 2010.\nProblem 3.1\nCode profiling and registers. In this problem, we will use some basic code profiling to examine\nthe effects of explicitly declaring variables as registers. Consider the fibonacci sequence generating\nfunction fibonacci in prob1.c, which is reproduced at the end of this problem set (and can be\ndownloaded from Stellar). The main() function handles the code profiling, calling fibonacci()\nmany times and measuring the average processor time.\n(a) First, to get a baseline (without any explicitly declared registers), compile and run prob1.c.\nCode profiling is one of the rare cases where using a debugger like gdb is discouraged, because\nthe debugger's overhead can impact the execution time. Also, we want to turn off compiler\noptimization. Please use the following commands to compile and run the program:\ndweller@dwellerpc:~$ gcc -O0 -Wall prob1.c -o prob1.o\ndweller@dwellerpc:~$ ./prob1.o\nAvg. execution time: 0.000109 msec\nexample output\n←\ndweller@dwellerpc:~$\nHow long does a single iteration take to execute (on average)?\nAnswer: On my 64-bit machine (results may differ slightly for 32-bit machines), the original\nfibonacci() function took 0.000109 msec on average.\n(b) Now, modify the fibonacci() function by making the variables a, b, and c register variables.\nRecompile and run the code. How long does a single iteration take now, on average? Turn\nin a printout of your modified code (the fibonacci() function itself would suffice).\nAnswer: Here's the modified fibonacci() function for part (b):\nvoid f i b o n a c c i ()\n{\n/∗ here are the v a r i a b l e s to set as r e g i s t e r s ∗/\nregister unsigned int a = 0;\nregister unsigned int b = 1;\nregister unsigned int c ;\nint n ;\n/∗ do not e d it below t h i s l i n e ∗/\nr e s u l t s b u f f e r [ 0 ] = a ;\nr e s u l t s b u f f e r [ 1 ] = b ;\nfor (n = 2; n < NMAX; n++) {\nc = a + b ;\n\nr e s u l t s b u f f e r [ n ] = c ; /∗ s t o r e code in r e s u l t s b u f f e r ∗/\na = b ;\nb = c ;\n}\n}\nOn my 64-bit machine (results may differ slightly for 32-bit machines), the modified function\ntook 0.000111 msec on average.\n(c) Modify the fibonacci() function one more time by making the variable n also a register\nvariable. Recompile and run the code once more. How long does a single iteration take with\nall four variables as register variables?\nAnswer: Here's the modified fibonacci() function for part (c):\nvoid f i b o n a c c i ()\n{\n/∗ here are the v a r i a b l e s to set as r e g i s t e r s ∗/\nregister unsigned int a = 0;\nregister unsigned int b = 1;\nregister unsigned int c ;\nregister int n ;\n/∗ do not e d it below t h i s l i n e ∗/\nr e s u l t s b u f f e r [ 0 ] = a ;\nr e s u l t s b u f f e r [ 1 ] = b ;\nfor (n = 2; n < NMAX; n++) {\nc = a + b ;\nr e s u l t s b u f f e r [ n ] = c ; /∗ s t o r e code in r e s u l t s b u f f e r ∗/\na = b ;\nb = c ;\n}\n}\nOn my 64-bit machine (results may differ slightly for 32-bit machines), the further modified\nfibonacci() function took 3.4e-05 msec on average.\n(d) Comment on your observed results. What can you conclude about using registers in your\ncode?\nAnswer: The observed results suggest that storing some variables in a register vs. in memory\nmay or may not impact performance. In particular, storing a, b, and c in registers do not\nappear to improve the performance at all, while storing n in a register improves performance\nby a factor of 3.\nProblem 3.2\nWe are writing a simple searchable dictionary using modular programming. First, the program\nreads a file containing words and their definitions into an easily searchable data structure. Then,\nthe user can type a word, and the program will search the dictionary, and assuming the word is\nfound, outputs the definition. The program proceeds until the user chooses to quit.\nWe split the code into several files: main.c, dict.c, and dict.h. The contents of these files are\ndescribed briefly below.\n\nmain.c:\ndict.c:\ndict.h:\n#include <stdio.h>\n#include \"dict.h\"\n/* data structure\n#include <stdlib.h>\nfor the dictionary */\n#include \"dict.h\"\n/* data structure\nchar * the dictionary[1000];\nfor the dictionary */\nint main() {\nchar * the dictionary[1000];\n/* declarations */\n...\nvoid load dictionary();\n}\nvoid load dictionary() {\n...\nchar * lookup(char []);\n}\nchar * lookup(char []) {\n...\n}\nAnswer the following questions based on the above program structure.\n(a) In implementing this program, you want to access the global variable the dictionary from\nmain.c, as well as from dict.c. However, due to the header file's inclusion in both source\ndocuments, the variable gets declared in both places, creating an ambiguity. How would you\nresolve this ambiguity?\nAnswer: Adding the extern keyword immediately before the declaration in dict.h resolves\nthe ambiguity, causing both files to reference the variable declared in dict.c.\n(b) Now, suppose you want to restrict the dictionary data structure to be accessible only from\nfunctions in dict.c. You remove the declaration from dict.h. Is it still possible to directly\naccess or modify the variable from main.c, even without the declaration in dict.h? If so,\nhow would you ensure the data structure variable remains private?\nAnswer: Simply removing the declaration from dict.h does not make the variable private\nto dict.c. One could simply add an extern declaration to main.c or any other source file\nand still be able to access or modify the dictionary directly. In order to prevent direct access,\nthe dictionary should be declared with the static keyword in dict.c.\n(c) Congratulations! You're done and ready to compile your code. Write the command line\nthat you should use to compile this code (using gcc). Let's call the desired output program\ndictionary.o.\nAnswer: gcc -g -O0 -Wall main.c dict.c -o dictionary.o.\nNote that the order of\nmain.c and dict.c is not important, as long as they are both specified.\nProblem 3.3\nBoth the for loop and the do-while loop can be transformed into a simple while loop. For each\nof the following examples, write equivalent code using a while loop instead.\n(a) int f a c t o r i a l ( int n) {\nint i , ret = 1;\nfor ( i = 2; i <= n ; i++)\nret ∗= i ;\nreturn ret ;\n}\n\nAnswer:\nint f a c t o r i a l ( int n) {\nint i = 1 , ret = 1;\nwhile (++i <= n)\nret ∗= i ;\nreturn ret ;\n}\n(b) #include <s t d l i b . h>\ndouble rand double () {\n/∗ generate random number in [ 0 , 1 ) ∗/\ndouble ret = ( double ) rand ( ) ;\nreturn ret /(RAND MAX+1);\n}\nint sample geometric rv ( double p) {\ndouble q ;\nint n = 0;\ndo {\nq = rand double ( ) ;\nn++;\nwhile (q >= p ) ;\n}\nreturn n ;\n}\nNote: You only need to modify the sample geometric rv() function.\nAnswer:\nint sample geometric rv ( double p) {\ndouble q ;\nint n = 0 , condition = 1;\nwhile ( condition ) {\nq = rand double ( ) ;\nn++;\ncondition = q >= p ;\n}\nreturn n ;\n}\n\nProblem 3.4\n'wc' is a unix utility that display the count of characters, words and lines present in a file. If no\nfile is specified it reads from the standard input. If more than one file name is specified it displays\nthe counts for each file along with the filename. In this problem, we will be implementing wc.\nOne of the ways to build a complex program is to develop it iteratively, solving one problem\nat a time and testing it throroughly. For this problem, start with the following shell and then\niteratively add the missing components.\n#include <s t d i o . h>\n#include <s t d l i b . h>\nint main ( int argc , char∗ argv [ ] )\n{\nFILE∗ fp=NULL;\nint\nn f i l e s =--argc ; /∗ ignore the name of the program i t s e l f ∗/\nint\nargidx =1;\n/∗ ignore the name of the program i t s e l f ∗/\nchar∗ c u r r f i l e=\"\" ;\nchar\nc ;\n/∗ count of words , l i n e s , characters ∗/\nunsigned long nw=0, nl =0,nc =0;\ni f ( n f i l e s ==0)\n{\nfp=stdin ; /∗ standard input ∗/\nn f i l e s ++;\n}\nelse /∗ set to f i r s t ∗/\n{\nc u r r f i l e=argv [ argidx ++];\nfp=fopen ( c u r r f i l e , \"r\" ) ;\n}\nwhile ( n f i l e s >0) /∗ f i l e s l e f t >0∗/\n{\ni f ( fp==NULL)\n{\nf p r i n t f ( stderr , \"Unable to open input\\n\" ) ;\ne x i t ( -1);\n}\nnc=nw=nl =0;\nwhile (( c=getc ( fp ))! =EOF)\n{\n/∗TODO: FILL HERE\nprocess the f i l e using getc ( fp )\n∗/\n}\np r i n t f ( \"%ld %s\\n\" , nc , c u r r f i l e ) ;\n/∗ next f i l e\ni f e x i s t s ∗/\nn f i l e s --;\ni f ( n f i l e s >0)\n{\nc u r r f i l e=argv [ argidx ++];\nfp\n=fopen ( c u r r f i l e , \"r\" ) ;\n}\n}\nreturn 0;\n}\nHint: In order to count words, count the transitions from non-white space to white space characters.\n\nAnswer: Here's the code with the shell filled in\n/∗\n6.087 IAP Spring 2010\nProblem set 2\n∗/\n#include <s t d i o . h>\n#include <s t d l i b . h>\nint main ( int argc , char∗ argv [ ] )\n{\nFILE∗ fp=NULL;\nint\nn f i l e s =--argc ; /∗ ignore the name of the program i t s e l f ∗/\nint\nargidx =1;\n/∗ ignore the name of the program i t s e l f ∗/\nchar∗ c u r r f i l e=\"\" ;\nchar\nc ;\n/∗ f o l l o w i n g used to count words ∗/\nenum\ns t a t e {INSIDE ,OUTSIDE} ;\nenum\ns t a t e c u r r s t a t e=INSIDE ;\n/∗ count of words , l i n e s , characters ∗/\nunsigned long nw=0, nl =0,nc =0;\ni f ( n f i l e s ==0)\n{\nfp=stdin ; /∗ standard input ∗/\nn f i l e s ++;\n}\nelse /∗ set to f i r s t ∗/\n{\nc u r r f i l e=argv [ argidx ++];\nfp=fopen ( c u r r f i l e , \"r\" ) ;\n}\nwhile ( n f i l e s >0) /∗ f i l e s l e f t >0∗/\n{\ni f ( fp==NULL)\n{\nf p r i n t f ( stderr , \"Unable to open input\\n\" ) ;\ne x i t ( -1);\n}\n/∗TODO: FILL HERE\nprocess the f i l e using getc ( fp )\n∗/\nnc=nw=nl =0;\nwhile (( c=getc ( fp ))! =EOF)\n{\nnc++;\ni f ( c=='\\n' )\n{\nn l++;\n}\ni f ( i s s p a c e ( c ))\n{\ni f ( c u r r s t a t e==INSIDE)\nnw++;\nc u r r s t a t e=OUTSIDE;\n}\nelse\n{\n\nc u r r s t a t e=INSIDE ;\n}\n}\n/∗ update t o t a l s ∗/\np r i n t f ( \"%ld %ld %ld %s\\n\" , nl ,nw, nc , c u r r f i l e ) ;\n/∗ next f i l e\ni f e x i s t s ∗/\nn f i l e s --;\ni f ( n f i l e s >0)\n{\nc u r r f i l e=argv [ argidx ++];\nfp\n=fopen ( c u r r f i l e , \"r\" ) ;\n}\n}\n}\n\n----------------------------\n----------------------------\nProblem 3.5\nIn this problem, we will be reading in formatted data and generating a report. One of the\ncommon formats for interchange of formatted data is 'tab delimited' where each line corresponds\nto a single record. The individual fields of the record are separated by tabs. For this problem,\ndownload the file stateoutflow0708.txt from Stellar. This contains the emigration of people\nfrom individual states. The first row of the file contains the column headings. There are eight self\nexplanatory fields. Your task is to read the file using fscanf and generate a report outlining the\nmigration of people from Massachusetts to all the other states. Use the field \"Aggr AGI\" to report\nthe numbers. Also, at the end, display a total and verify it is consistent with the one shown below.\nAn example report should look like the following:\nSTATE\nTOTAL\n\"FLORIDA\"\n\"NEW HAMPSHIRE\"\n..........\nTotal\nMake sure that the fields are aligned.\nAnswer: Here's the code with the shell filled in\n#include <s t d i o . h>\n#include <s t d l i b . h>\n#include <s t r i n g . h>\n#define STRSIZE 100\n#define NFIELDS 9\nint main ( )\n{\nchar i n p u t f i l e [] = \"stateoutflow0708.txt \" ;\n/∗ define a l l the f i e l d s ∗/\nchar s t a t e c o d e o r g [ STRSIZE ] ;\nchar country code org [ STRSIZE ] ;\nchar s t a t e c o d e d e s t [ STRSIZE ] ;\nchar country code dest [ STRSIZE ] ;\nchar state abbrv [ STRSIZE ] ;\nchar state name [ STRSIZE ] ;\nchar l i n e [ STRSIZE∗NFIELDS ] ;\nint\nreturn num =0;\nint\nexmpt num=0;\nint\naggr agi =0;\nlong\nt o t a l =0;\n/∗ f i l e r e l a t e d ∗/\nint f i e l d s r e a d =0;\nFILE∗ fp=fopen ( i n p u t f i l e , \"r\" ) ;\ni f ( fp==NULL)\n{\nf p r i n t f ( stderr , \"Cannot open file\\n\" ) ;\ne x i t ( -1);\n}\n/∗ skip f i r s t l i n e ∗/\nf g e t s ( line , STRSIZE∗NFIELDS, fp ) ;\n/∗ print the header ∗/\n\np r i n t f ( \"%-30s,%6s\\n\" , \"STATE \" , \"TOTAL \" ) ;\np r i n t f ( \" ---------------------------------------\\n\" ) ;\nwhile ( f g e t s ( line , STRSIZE∗NFIELDS, fp ))\n{\n/∗ parse the f i e l d s ∗/\nf i e l d s r e a d=sscanf ( line , \"%s %s %s %s %s %s %d %d %d\" ,\nstate code org ,\ncountry code org ,\nstate code dest ,\ncountry code dest ,\nstate abbrv ,\nstate name ,\n&return num ,\n&exmpt num ,\n&aggr agi ) ;\ni f ( strcmp ( state code org , \"\\\"25\\\" \")==0)\n{\np r i n t f ( \"%-30s ,%6d\\n\" , state name , aggr agi ) ;\nt o t a l\n+= aggr agi ;\n}\n}\n/∗ print the header ∗/\np r i n t f ( \" ----------------------------------------\\n\" ) ;\np r i n t f ( \"%-30s,%6 lu\\n\" , \"TOTAL \" , t o t a l ) ;\nf c l o s e ( fp ) ;\nreturn 0;\n}\n\nCode listing for Problem 3.1: prob1.c\n#include <s t d l i b . h>\n#include <s t d i o . h>\n#include <time . h>\n#define NMAX 25\nstatic unsigned int r e s u l t s b u f f e r [NMAX] ;\nvoid f i b o n a c c i ()\n{\n/∗ here are the v a r i a b l e s to set as r e g i s t e r s ∗/\nunsigned int a = 0;\nunsigned int b = 1;\nunsigned int c ;\nint n ;\n/∗ do not e d it below t h i s l i n e ∗/\nr e s u l t s b u f f e r [ 0 ] = a ;\nr e s u l t s b u f f e r [ 1 ] = b ;\nfor (n = 2; n < NMAX; n++) {\nc = a + b ;\nr e s u l t s b u f f e r [ n ] = c ; /∗ s t o r e code in r e s u l t s b u f f e r ∗/\na = b ;\nb = c ;\n}\n}\nint main ( void ) {\nint n , n t e s t s = 10000000;\nc l o c k t tstart , tend ;\ndouble favg ;\n/∗ do p r o f i l i n g ∗/\nt s t a r t = clock ( ) ;\nfor (n = 0; n < n t e s t s ; n++)\nf i b o n a c c i ( ) ;\ntend = clock ( ) ;\n/∗ end p r o f i l i n g ∗/\n/∗ compute average execution time ∗/\nfavg = (( double )( tend - t s t a r t ))/CLOCKS PER SEC/ n t e s t s ;\n/∗ print avg execution time in m i l l i s e c o n d s ∗/\np r i n t f ( \"Avg. execution time: %g msec\\n\" , favg ∗ 1000);\nreturn 0;\n}\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 4",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/2ae6d57a3ce6e5c8685b459fbe9dbffb_MIT6_087IAP10_assn04.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 4\nPointers. Arrays. Strings. Searching and sorting algorithms.\nOut: Friday, January 15, 2010.\nDue: Tuesday, January 19, 2010.\nProblem 4.1\nConsider the insertion sort algorithm described in Lecture 5 In this problem, you will re-implement\nthe algorithm using pointers and pointer arithmetic.\n(a) The function shift element() takes as input the index of an array element that has been\ndetermined to be out of order. The function shifts the element towards the front of the array,\nrepeatedly swapping the preceding element until the out-of-order element is in the proper\nlocation. The implementation using array indexing is provided below for your reference:\n/∗ move previous elements down u n t i l\ni n s e r t i o n point reached ∗/\nvoid s h i f t e l e m e n t ( unsigned int i ) {\nint ivalue ;\n/∗ guard against going outside array ∗/\nfor ( ival ue = arr [ i ] ; i && arr [ i -1] > iva lue ; i --)\narr [ i ] = arr [ i - 1];\nmove element down\n/∗\n∗/\narr [ i ] = i valu e ; /∗ i n s e r t element ∗/\n}\nRe-implement this function using pointers and pointer arithmetic instead of array indexing.\n/∗ int ∗ pElement - pointer to the element\nin arr ( type int [ ] ) that i s out-of-place ∗/\nvoid s h i f t e l e m e n t ( int ∗ pElement ) {\n/∗ i n s e r t code here ∗/\n}\n(b) The function insertion sort() contains the main loop of the algorithm. It iterates through\nelements of the array, from the beginning, until it reaches an element that is out-of-order. It\ncalls shift element() to shift the offending element to its proper location earlier in the array\nand resumes iterating until the end is reached. The code from lecture is provided below:\n/∗ i t e r a t e u n t i l out-of-order element found ;\ns h i f t the element , and continue i t e r a t i n g ∗/\nvoid i n s e r t i o n s o r t ( void ) {\nunsigned int i , len = array length ( arr ) ;\nfor ( i = 1; i < len ; i++)\ni f ( arr [ i ] < arr [ i -1])\ns h i f t e l e m e n t ( i ) ;\n}\nRe-implement this function using pointers and pointer arithmetic instead of array indexing.\nUse the shift element() function you implemented in part (a).\n\nProblem 4.2\nIn this problem, we will use our knowledge of strings to duplicate the functionality of the C standard\nlibrary's strtok() function, which extracts \"tokens\" from a string. The string is split using a set of\ndelimiters, such as whitespace and punctuation. Each piece of the string, without its surrounding\ndelimiters, is a token. The process of extracting a token can be split into two parts: finding the\nbeginning of the token (the first character that is not a delimiter), and finding the end of the token\n(the next character that is a delimiter). The first call of strtok() looks like this:\nchar ∗ strtok(char ∗ str, const char ∗ delims);\nThe string str is the string to be tokenized, delims is a string containing all the single characters\nto use as delimiters (e.g. \" \\t\\r\\n\"), and the return value is the first token in str. Additional\ntokens can be obtained by calling strtok() with NULL passed for the str argument:\nchar ∗ strtok(NULL, const char ∗ delims);\nBecause strtok() uses a static variable to store the pointer to the beginning of the next token,\ncalls to strtok() for different strings cannot be interleaved. The code for strtok() is provided\nbelow:\nchar ∗ strtok ( char ∗ text , const char ∗ delims ) {\n/∗ i n i t i a l i z e ∗/\ni f ( ! text )\ntext = pnexttoken ;\n/∗ find s t a r t of token in text ∗/\ntext += strspn ( text , delims ) ;\ni f (∗ text == '\\0 ' )\nreturn NULL;\n/∗ find end of token in text ∗/\npnexttoken = text + strcspn ( text , delims ) ;\n/∗ i n s e r t null -terminator at end ∗/\ni f (∗ pnexttoken != '\\0 ' )\n∗ pnexttoken++ = '\\0 ' ;\nreturn text ;\n}\n(a) In the context of our string tokenizer, the function strspn() computes the index of the\nfirst non-delimiter character in our string. Using pointers or array indexing (your choice),\nimplement the strspn() function. In order to locate a character in another string, you may\nuse the function strpos(), which is declared below:\nint strpos ( const char\nstr , const char ch ) ;\n∗\nThis function returns the index of the first occurrence of the character ch in the string str,\nor -1 if ch is not found. The declaration of strspn() is provided below:\nunsigned int strspn ( const char ∗ str , const char ∗ delims ) {\n/∗ i n s e r t code here ∗/\n}\nHere, delims is a string containing the set of delimiters, and the return value is the index of the\nfirst non-delimiter character in the string str. For instance, strspn(\" . This\", \" .\") == 3.\nIf the string contains only delimiters, strspn() should return the index of the null-terminator\n('\\0'). Assume '\\0' is not a delimiter.\n\n(b) The function strcspn() computes the index of the first delimiter character in our string.\nHere's the declaration of strcspn():\nunsigned int strcspn ( const char ∗ str , const char ∗ delims ) {\n/∗ i n s e r t code here ∗/\n}\nIf the string contains no delimiters, return the index of the null-terminator ('\\0'). Implement\nthis function using either pointers or array indexing.\nProblem 4.3\nIn this problem, you will be implementing the shell sort. This sort is built upon the insertion sort,\nbut attains a speed increase by comparing far-away elements against each other before comparing\ncloser-together elements. The distance between elements is called the \"gap\". In the shell sort, the\narray is sorted by sorting gap sub-arrays, and then repeating with a smaller gap size.\nAs written here, the algorithm sorts in O(n2) time. However, by adjusting the sequence of\ngap sizes used, it is possible to improve the performance to O(n3/2), O(n4/3), or even O(n(log n)2)\ntime. You can read about a method for performing the shell sort in O(n(log n)2) time on Robert\nSedgewick's page at Princeton:\nhttp://www.cs.princeton.edu/~rs/shell/paperF.pdf\nNote that you can find complete C code for the shell sort at the beginning of the paper, so please\nwait until you have finished this exercise to read it.\n(a) First, we will modify the shift element() function from the insertion sort code for the shell\nsort. The new function, started for you below, should start at index i and shift by intervals\nof size gap. Write the new function, using array indexing or pointers. Assume that i ≥ gap.\nvoid shift element by gap ( unsigned int i , unsigned int gap ) {\n/∗ i n s e r t code here ∗/\n}\n(b) Now, we need to write the main shell sort routine. Using the template below, fill in the missing\ncode so that the insertion sort in the inner loop compares every element to the element gap\nspaces before it.\nvoid s h e l l s o r t ( void ) {\nunsigned int gap , i ,\nlen = array length ( arr ) ;\n/∗ sort , comparing against f a r t h e r away\nelements f i r s t , then c l o s e r elements ∗/\nfor ( gap = len /2; gap > 0; gap /= 2) {\n/∗ do i n s e rt i o n -l i k e sort , but comparing\nand s h i f t i n g elements in multiples of gap ∗/\nfor\ni n s e r t code here\n( /∗\n∗/ ) {\ni f ( /∗ i n s e r t code here ∗/ ) {\n/∗ out of order , do s h i f t ∗/\nshift element by gap ( i , gap ) ;\n}\n}\n}\n}\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 4 — Solutions",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/b2ed1416e28321842283a8a99025d9f3_MIT6_087IAP10_assn04_sol.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 4 - Solutions\nPointers. Arrays. Strings. Searching and sorting algorithms.\nOut: Friday, January 15, 2010.\nDue: Tuesday, January 19, 2010.\nProblem 4.1\nConsider the insertion sort algorithm described in Lecture 5 (slides 21-23). In this problem, you\nwill re-implement the algorithm using pointers and pointer arithmetic.\n(a) The function shift element() takes as input the index of an array element that has been\ndetermined to be out of order. The function shifts the element towards the front of the array,\nrepeatedly swapping the preceding element until the out-of-order element is in the proper\nlocation. The implementation using array indexing is provided below for your reference:\n/∗ move previous elements down u n t i l\ni n s e r t i o n point reached ∗/\nvoid s h i f t e l e m e n t ( unsigned int i ) {\nint ivalue ;\n/∗ guard against going outside array ∗/\nfor ( ivalue = arr [ i ] ; i && arr [ i -1] > iva lue ; i --)\narr [ i ] = arr [ i - 1];\nmove element down\n/∗\n∗/\narr [ i ] = ivalue ; /∗ i n s e r t element ∗/\n}\nRe-implement this function using pointers and pointer arithmetic instead of array indexing.\n/∗ int ∗ pElement - pointer to the element\nin arr ( type int [ ] ) that i s out-of-place ∗/\nvoid s h i f t e l e m e n t ( int ∗ pElement ) {\n/∗ i n s e r t code here ∗/\n}\nAnswer: Here's one possible implementation:\n/∗ int ∗ pElement - pointer to the element\nin arr ( type int [ ] ) that i s out-of-place ∗/\nvoid s h i f t e l e m e n t ( int ∗ pElement ) {\nint ivalue = ∗ pElement ;\nfor ( ivalue = ∗ pElement ; pElement > arr && ∗( pElement -1) > ivalue ; pElement--)\n∗ pElement = ∗( pElement -1);\n∗ pElement = ivalue ;\n}\n(b) The function insertion sort() contains the main loop of the algorithm. It iterates through\nelements of the array, from the beginning, until it reaches an element that is out-of-order. It\ncalls shift element() to shift the offending element to its proper location earlier in the array\nand resumes iterating until the end is reached. The code from lecture is provided below:\n\n/∗ i t e r a t e u n t i l out-of-order element found ;\ns h i f t the element , and continue i t e r a t i n g ∗/\nvoid i n s e r t i o n s o r t ( void ) {\nunsigned int i , len = array length ( arr ) ;\nfor ( i = 1; i < len ; i++)\ni f ( arr [ i ] < arr [ i -1])\ns h i f t e l e m e n t ( i ) ;\n}\nRe-implement this function using pointers and pointer arithmetic instead of array indexing.\nUse the shift element() function you implemented in part (a).\nAnswer: Here's one possible implementation:\n/∗ i t e r a t e u n t i l out-of-order element found ;\ns h i f t the element , and continue i t e r a t i n g ∗/\nvoid i n s e r t i o n s o r t ( void ) {\nint\npElement , ∗pEnd = arr + array length ( arr ) ;\n∗\nfor ( pElement = arr +1; pElement < pEnd ; pElement++)\ni f (∗ pElement < ∗( pElement -1))\ns h i f t e l e m e n t ( pElement ) ;\n}\nProblem 4.2\nIn this problem, we will use our knowledge of strings to duplicate the functionality of the C standard\nlibrary's strtok() function, which extracts \"tokens\" from a string. The string is split using a set of\ndelimiters, such as whitespace and punctuation. Each piece of the string, without its surrounding\ndelimiters, is a token. The process of extracting a token can be split into two parts: finding the\nbeginning of the token (the first character that is not a delimiter), and finding the end of the token\n(the next character that is a delimiter). The first call of strtok() looks like this:\nchar ∗ strtok(char ∗ str, const char ∗ delims);\nThe string str is the string to be tokenized, delims is a string containing all the single characters\nto use as delimiters (e.g. \" \\t\\r\\n\"), and the return value is the first token in str. Additional\ntokens can be obtained by calling strtok() with NULL passed for the str argument:\nchar ∗ strtok(NULL, const char ∗ delims);\nBecause strtok() uses a static variable to store the pointer to the beginning of the next token,\ncalls to strtok() for different strings cannot be interleaved. The code for strtok() is provided\nbelow:\nchar ∗ strtok ( char ∗ text , const char ∗ delims ) {\n/∗ i n i t i a l i z e ∗/\ni f ( ! text )\ntext = pnexttoken ;\n/∗ find s t a r t of token in text ∗/\ntext += strspn ( text , delims ) ;\ni f (∗ text == '\\0 ' )\nreturn NULL;\n/∗ find end of token in text ∗/\npnexttoken = text + strcspn ( text , delims ) ;\n/∗ i n s e r t null -terminator at end ∗/\ni f (∗ pnexttoken != '\\0 ' )\n∗ pnexttoken++ = '\\0 ' ;\nreturn text ;\n}\n\n(a) In the context of our string tokenizer, the function strspn() computes the index of the\nfirst non-delimiter character in our string. Using pointers or array indexing (your choice),\nimplement the strspn() function. In order to locate a character in another string, you may\nuse the function strpos(), which is declared below:\nint strpos ( const char\nstr , const char ch ) ;\n∗\nThis function returns the index of the first occurrence of the character ch in the string str,\nor -1 if ch is not found. The declaration of strspn() is provided below:\nunsigned int strspn ( const char ∗ str , const char ∗ delims ) {\n/∗ i n s e r t code here ∗/\n}\nHere, delims is a string containing the set of delimiters, and the return value is the index of the\nfirst non-delimiter character in the string str. For instance, strspn(\" . This\", \" .\") == 3.\nIf the string contains only delimiters, strspn() should return the index of the null-terminator\n('\\0'). Assume '\\0' is not a delimiter.\nAnswer: Here's a simple implementation of strspn():\nunsigned int strspn ( const char ∗ str , const char ∗ delims ) {\nunsigned int i ;\nfor ( i = 0; s t r [ i ] != '\\0 ' && strpos ( delims , s t r [ i ] ) > -1; i ++);\nreturn i ;\n}\n(b) The function strcspn() computes the index of the first delimiter character in our string.\nHere's the declaration of strcspn():\nunsigned int strcspn ( const char ∗ str , const char ∗ delims ) {\n/∗ i n s e r t code here ∗/\n}\nIf the string contains no delimiters, return the index of the null-terminator ('\\0'). Implement\nthis function using either pointers or array indexing.\nAnswer: Here's a simple implementation of strcspn():\nunsigned int strcspn ( const char ∗ str , const char ∗ delims ) {\nunsigned int i ;\nfor ( i = 0; s t r [ i ] != '\\0 ' && strpos ( delims , s t r [ i ] ) == -1; i ++);\nreturn i ;\n}\nProblem 4.3\nIn this problem, you will be implementing the shell sort. This sort is built upon the insertion sort,\nbut attains a speed increase by comparing far-away elements against each other before comparing\ncloser-together elements. The distance between elements is called the \"gap\". In the shell sort, the\narray is sorted by sorting gap sub-arrays, and then repeating with a smaller gap size.\nAs written here, the algorithm sorts in O(n2) time. However, by adjusting the sequence of\ngap sizes used, it is possible to improve the performance to O(n3/2), O(n4/3), or even O(n(log n)2)\ntime. You can read about a method for performing the shell sort in O(n(log n)2) time on Robert\nSedgewick's page at Princeton:\n\nhttp://www.cs.princeton.edu/~rs/shell/paperF.pdf\nNote that you can find complete C code for the shell sort at the beginning of the paper, so please\nwait until you have finished this exercise to read it.\n(a) First, we will modify the shift element() function from the insertion sort code for the shell\nsort. The new function, started for you below, should start at index i and shift by intervals\nof size gap. Write the new function, using array indexing or pointers. Assume that i ≥ gap.\nvoid shift element by gap ( unsigned int i , unsigned int gap ) {\n/∗ i n s e r t code here ∗/\n}\nAnswer: One possible version of this function is:\nvoid shift element by gap ( unsigned int i ,\nunsigned int gap ) {\nint ivalue ;\nunsigned int j ;\nfor ( j = i , ivalue = arr [ i ] ; j >= gap\n&& arr [ j-gap ] > ivalue ; j -= gap )\narr [ j ] = arr [ j-gap ] ;\nmove\n/∗\n∗/\narr [ j ] = ivalue ; /∗ i n s e r t element ∗/\n}\n(b) Now, we need to write the main shell sort routine. Using the template below, fill in the missing\ncode so that the insertion sort in the inner loop compares every element to the element gap\nspaces before it.\nvoid s h e l l\nunsigned\ns o r t ( void ) {\nint gap , i ,\nl e n = a r r a y l e n g t h ( a r r ) ;\n/∗ s o r t , comparing a g a i n s t f a r t h e r away\ne le m e n ts f i r s t , then c l o s e r elem e n t s ∗/\nfor ( gap = l e n / 2 ; gap > 0 ; gap /= 2) {\n/∗ do i n s e r t i o n -l i k e s o r t , but comparing\nand s h i f t i n g elem e n t s i n m u l t i p l e s o f gap ∗/\nfor ( /∗ i n s e r t code h e r e ∗/ ) {\ni f ( /∗ i n s e r t code he r e ∗/ ) {\n/∗ out o f order , do s h i f t ∗/\ns h i f t e l e m e n t b y g a p ( i , gap ) ;\n}\n}\n}\n}\nAnswer: One possible solution is shown below:\nvoid s h e l l\nunsigned\ns o r t ( void ) {\nint gap , i , l e n = a r r a y l e n g t h ( a r r ) ;\n/∗ compare a g a i n s t f a r t h e r away elem e n t s f i r s t , then c l o s e r e l e me nt s ∗/\nfor ( gap = l e n / 2 ; gap > 0 ; gap /= 2)\n/∗ comparing and s h i f t i n g ele m e n ts\n{\ni n m u l t i p l e s o f gap ∗/\nfor ( i = gap ; i < l e n ; i ++)\ni f ( a r r [ i -gap ] > a r r [ i ] )\ns h i f t e l e m e n t b y g a p ( i , gap ) ; /∗ out o f order , do s h i f t ∗/\n}\n}\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Assignment",
      "title": "Problem Set 5",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/887507ff7915f9ae2dce38f47b59e689_MIT6_087IAP10_assn05.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nProblem Set 5\nLinked lists, trees\nOut: January 19, 2010.\nDue: January 20, 2010.\nProblem 5.1\nIn this problem, we continue our study of linked lists. Let the nodes in the list have the following\nstructure\nstruct node\n{\nint data ;\nstruct node ∗ next ;\n} ;\nUse the template in Lec06 to add elements to the list.\n(a) Write the function void display(struct node∗ head) that displays all the elements of the list.\n(b) Write the function struct node∗ addback(struct node∗ head,int data) that adds an element to the\nend of the list. The function should return the new head node to the list.\n(c) Write the function struct node∗ find(struct node∗ head,int data) that returns a pointer to the\nelement in the list having the given data. The function should return NULL if the item does\nnot exist.\n(d) Write the function struct node∗ delnode(struct node∗ head,struct node∗ pelement) that deletes the\nelement pointed to by pelement (obtained using find). The function should return the up\ndated head node. Make sure you consider the case when pelement points to the head node.\n(e) Write the function void freelist (struct node∗ head) that deletes all the element of the list. Make\nsure you do not use any pointer after it is freed.\n(f) Write test code to illustrate the working of each of the above functions.\nAll the code and sample outputs should be submitted.\n\nProblem 5.2\nIn this problem, we continue our study of binary trees. Let the nodes in the tree have the\nfollowing structure\nstruct tnode\n{\nint data ;\nstruct tnode ∗ l e f t ;\nstruct tnode ∗ r i g h t ;\n} ;\nUse the template in Lec06 to add elements to the list.\n(a) Write the function struct tnode∗ talloc(int data) that allocates a new node with the given data.\n(b) Complete the function addnode() by filling in the missing section. Insert elements 3, 1, 0, 2, 8, 6, 5, 9\nin the same order.\n(c) Write function void preorder(struct tnode∗ root) to display the elements using pre-order traver\nsal.\n(d) Write function void inorder(struct tnode∗ root) to display the elements using in-order traversal.\nNote that the elements are sorted.\n(e) Write function int deltree (struct tnode∗ root) to delete all the elements of the tree. The function\nmust return the number of nodes deleted. Make sure not to use any pointer after it has been\nfreed. (Hint: use post-order traversal).\n(f) Write test code to illustrate the working of each of the above functions.\nAll the code and sample outputs should be submitted.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Final Project",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/9796fe2dda5404aa9d14a49081b842d8_MIT6_087IAP10_project.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nFinal Project\nAs part of your final project, you will build a C application leveraging one or more open-source\nlibraries. In addition to producing your own code, a critical skill of software development is the\nability to utilize existing code. This involves reading documentation, compiling and linking library\ncode with your own.\nYou are free to utilize any open-source library for your project. However, we recommend some\nlibraries for which you may expect some level technical support from us.\nOpenCV\nOpenCV is a open-source computer vision library, originally developed by Intel and now widely\ndeveloped by a large community of contributors. The library consists of routines for acquiring\nimages from webcams, image processing operations, image analysis routines and pattern classifiers.\nExample applications that can be developed using OpenCV library include face-detection and\nrecognition, object Identification etc. You can find more details at http://sourceforge.net/\nprojects/opencvlibrary/\nImageMagick\nImageMagick is a software suite and also a library that allows you to to create, edit, and compose\nimages. It can read, convert and write images in over 100 fromats that includes PNG, PDF, BMP,\nJPG etc. You can use imagemagick library to embedd text in images, do common operations\nsuch as enhancing color, scaling images etc. You can find more details about the library at http:\n//sourceforge.net/projects/opencvlibrary/\nCUDA\nCUDA (C unified device architecture) is a library developed by NVIDIA to leverage the general\npurpose processing power of GPUs. CUDA allows you to use C-language to develop compute-\nintensive applications on the GPU. Note: While you can develop and debug code in emulation\nmode on any computer, you have to have a CUDA enabled NVIDIA graphics in order to leverage\nthe processing power offered by these devices. You can find more details at http://www.nvidia.\ncom/object/cuda_home.html\nFFTW\nFFTW stands for fastest Fourier transform in the west! True to its name, FFTW is one of the\nfastest publicly available libraries for perform discrete Fourier transform in multiple dimensions. If\nyou would like to build applications for signal processing, image processing, radar processing then\nyou will find this library very valuable.\n\nSQLite\nSQLite is a library that implements a SQL database engine. It makes working with databases\nas easy as reading and writing files. It implements a large section of the SQL specification. You\ncan embedd it in your applications without any configuaration. You can find more details at\nhttp://sqlite.org\nlibCURL\nlibCURL is a client side URL transfer library that supports over a dozen transfer protocols such as\nhttp, ftp, ftps, scp etc. Using this library you can build applications that uploads and downloads\ncontent over a network. libcurl is free, thread-safe, IPv6 compatibleand fast. You can get more\ndetails about libCURL at http://curl.haxx.se/\nDeliverables\nAs part of the project submission you are required to submit a one-page proposal. Due to limited\ntime frame, plan your project carefully. The proposal a week before the project is designed to force\nyou to consider the scope and design of the project carefully. At the end of the project, you are\nrequired to submit a more substantial write up describing the nature of your project, your design\nchoices, documentation to download and run your code. Also make sure you attribute any publicly\navailable code that you used to its proper sources. Finally, you are also required to submit code\nas part of your submission. Code that cannot be run by the lab-assistants based on the provided\ndocumentation will not be evaluated.\nImportant Dates\nProject proposal\n1/22\nProject Report\n1/29\nCode\n1/29\nEvaluation\nIn addition to writing code, documentation is critical if the code is intended for use by others than\nits authors. The projects will be evaluated on the correctness of code, ingenuity. It will also be\nevaluated on the extent of its documentation. Due to limited time, project material submitted\nafter the deadlines will not be evaluated.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Lab 1: Game of Life",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/86f222c2f2558ba9559771ed913513f5_MIT6_087IAP10_lab01.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nLab 1: Game of Life\nIn-Lab: Wednesday, January 13, 2010\nDue: Tuesday, January 19, 2010\nOverview\nThe Game of Life, invented by John Conway in 1970, is an example of a zero-player \"game\" known\nas a cellular automaton. The game consists of a two-dimensional world extending infinitely in all\ndirections, divided into \"cells.\" Each cell is either \"dead\" or \"alive\" at a given \"generation.\" The\ngame consists of a set of rules that describe how the cells evolve from generation to generation.\nThese rules calculate the state of a cell in the next generation as a function of the states of its\nneighboring cells in the current generation. In a 2-D world, a cell's neighbors are those 8 cells\nvertically, horizontally, or diagonally adjacent to that cell. Conway's set of rules are summarized\nas:\n1. A live cell with fewer than two live neighbors dies.\n2. A live cell with more than three live neighbors also dies.\n3. A live cell with exactly two or three live neighbors lives.\n4. A dead cell with exactly three live neighbors becomes alive.\nIn this lab, we will be implementing Conway's Game of Life, with the minor restriction that\nour 2-D world is finite. The neighbors of a cell on the edge of the world that would be beyond\nthe edge are assumed dead. You can read more about Conway's Game of Life on Wikipedia at\nhttp://en.wikipedia.org/wiki/Conway's_Game_of_Life.\nExample (the so-called \"glider\"):\n| | | | | | |\n| | | |*| | |\n| |*| |*| | |\n| | |*|*| | |\n| | | | | | |\n-→\n| | | | | | |\n| | |*| | | |\n| | | |*|*| |\n| | |*|*| | |\n| | | | | | |\nLegend: * = alive, = dead\nPart A: Implementing Evolution (In-Lab)\nIn this part, we will focus on implementing the rules needed to evolve the world from one generation\nto the next. To assist you, we provide several functions you should use to access and modify the\ncurrent and next state of the world. These functions are described in the header file lifegame.h\nand implemented in the file lifegame.c. Also, we have provided a skeleton describing what you\nneed to do for this part in lab1a.c.\n\nBefore getting started, you should copy all these files from the locker (/mit/6.087/Lab1/) into\nyour working directory. When compiling, you need to compile lab1a.c and lifegame.c together\nto generate a single executable file (let's call it lab1a.o) with all the code in it (otherwise, you'll\nget \"undefined reference\" errors). Here's an example command line for compiling this code:\nathena% gcc -g -O0 -Wall lab1a.c lifegame.c -o lab1a.o\nathena%\nStart by examining the contents of lifegame.h and lab1a.c. You need to fill in a few lines in\nmain() and complete the functions next generation(), get next state(x,y), and\nnum neighbors(x,y). There is no need to modify the files lifegame.h or lifegame.c in this part.\n(a) How will you initialize the world for the Game of Life? Write the appropriate code in the\nmain() function.\n(b) How will you output the final state of the world once all the evolutions are done? Write the\nappropriate function call in main().\n(c) The main() function calls next generation() for each generation to handle the evolution\nprocess. Your code should set each cell's state in the next generation according to the rules\nspecified in the Overview of this handout. Once the states of all the cells have been set\nfor the next generation, calling finalize evolution() will set the current world state to\nthe next generation and reset the next generation state. Your code should make use of the\nget next state(x,y) function to compute the next state of each cell.\n(d) Write the code for get next state(x,y), so the function returns the next state (ALIVE or\nDEAD) of the cell at the specified coordinates using the number of live neighbors (returned\nby the num neighbors(x,y) function) and the Game of Life rules.\n(e) Fill in the function num neighbors(x,y), so it returns the number of live neighbors (cells\nvertically, horizontally, or diagonally adjacent) for the specified cell. Since our world is finite,\nadjacent cells which are beyond the edge of the world are presumed DEAD.\nNow that you're done, compile and run the program. Feel free to change the definition of NUM GENERATIONS,\nbut when you're ready to be checked off, make sure NUM GENERATIONS = 50 and show your program's\noutput to the Lab Assistant.\nCheck off:\nPart B: The World in a File\nIn the first part of this lab, the initial state of the world was hard-coded into lifegame.c and the\nfinal state of the world was output to the console. In this part, we will modify the code so that the\ninitial state of the world can be read from a file, and the final state is output to a file.\nFirst, let's examine lifegame.c. Notice the functions you need to implement:\ninitialize world from file(filename) and save world to file(filename).\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\n(a) The first of these, initialize world from file(filename), reads the file specified by filename\nand initializes the world from the pattern specified in the file. Basically, the file is a matrix of\ncharacters, '*' to specify a live cell, and ' ' (space) to specify a dead cell. The ith character\nof the jth line (zero-indexed) represents the initial state of the cell located at (i,j). If the line\ndoesn't contain enough characters or the file doesn't contain enough lines, the unspecified\ncells are presumed dead. Fill in the function to read the file and initialize the world. Don't\nforget to reset all the next generation states to DEAD. Use appropriate error handling.\n(b) The other function, save world to file(filename), saves the final state of the world to the\nfile filename in the same format as used in the initialization function: the ith character of\nthe jth line (zero-indexed) represents the state of the cell located at (i,j) in the world.\n(c) Fill in the contents of lab1b.c using the code from Part A (lab1a.c) and modifying to\ncall these functions. The name of the file to load will be specified in the first command line\nargument passed to the executable. If no file is specified, you should default to initializing the\nworld to the hard-coded default \"glider\" pattern. Save the final output to the file \"world.txt.\"\nTo help you test your code, we've provided a couple test files: glider.txt (should match your\noutput from Part A) and sship.txt (output in sshipout.txt).\nTo finish, write a brief (1 page max.) lab report describing your experience completing this lab,\nwhat challenges you faced and how you addressed them, and what you learned from this lab. Turn\nin a zip file containing all your code (lab1a.c, lab1b.c, lifegame.h, and lifegame.c), and your\nlab report, using the online submission system on Stellar.\nCongratulations, you're done!\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Lab 2: Data compression",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/39a5b0af4d8fbeb58ccdc0247c8d6528_MIT6_087IAP10_lab02.pdf",
      "content": "Massachusetts Institute of Technology\nDepartment of Electrical Engineering and Computer Science\n6.087: Practical Programming in C\nIAP 2010\nLab 2: Data compression\nIn-Lab: Wednesday, January 20, 2010\nDue: Monday, January 25, 2010\nOverview\nAssume that the data consists of stream of symbols from a finite alphabet. Compression algorithms\nencode this data such that it can be transmitted/stored with minimum size. Huffman coding is a\nlossless data compression algorithm developed by David A. Huffman while he was a PhD student\nat MIT. It forms the basis of the 'zip' file format. It has several interesting properties:\n- It is a variable length code. Frequent symbols are encoded using shorter codes.\n- It is a prefix code. No code occurs as a prefix of another code. This property is also called as\ninstant decoding. The code can be decoded using current and past inputs only.\n- It is the best possible prefix code (on an average)-it produces the shortest prefix code for a\ngiven symbol frequency.\nGenerating code\nAssume that we know the frequency of occurence of each symbol. We also assume that the symbols\nare sorted according to the frequency of their occurence (lowest first). The procedure to generate\nthe code involves constructing a tree that proceeds as follows\n- Intially all symbols are leaf nodes.\n- The pair of symbols with the smallest frequency are joined to form a composite symbol whose\nfrequency of occurence is sum of their individual frequencies. This forms the parent node in\nthe binary tree with the original pair as its children. This new node is now treated as a new\nsymbol.\n- The symbols are re-arranged according to the new frequency and the procedure is repeated\nuntil there is a single root node corresponding to the composition of all the original symbols.\n. After N-1 (N being the number of symbols) iterations the tree building is complete. Now, each\nbranch is labelled with '1' (if right) or '0' (if left). The code for each symbol is the string of 1s and\n0s formed when traversing the tree from the root to the leaf node containing the symbol.\n\nConsider the following example: Let {('a',0.01),('b',0.04),('c',0.05),('d',0.11),('e',0.19),('f',0.20),('g',0.4)}\nbe the exhaustive set of symbols and their corresponding frequency of occurence. We can represent\nthe code formation through the following table and the corresponding tree.\niteration\ntree\n{('a',0.01),('b',0.04),('c',0.05),('d',0.11),('e',0.19),('f',0.20),('g',0.4)}\n{('ab',0.05),('c',0.05),('d',0.11),('e',0.19),('f',0.20),('g',0.4)}\n{('abc',0.1),('d',0.11),('e',0.19),('f',0.20),('g',0.4)}\n{('e',0.19),('f',0.20),('abcd',0.21),('g',0.4)}\n{('abcd',0.21),('ef',0.39),('g',0.4)}\n{('g',0.4),('abcdef',0.6)}\n{('abcdefg',1.00)}\nTable 1: The table illustrates the formation of the tree from bottom-up\n'abcdefg',1.0\n'g',0.4\n'abcdef',0.6\n'abcd',0.21\n'abc',0.1\n'ab',0.05\n'a',0.01\n'b',0.04\n'c',0.05\n'd',0.11\n'ef',0.39\n'e',0.19\n'f',0.20\nFigure 1: Huffman code tree corresponding to the given symbol frequencies\n\nPart A: Implementing a Huffman decoder (In lab)\nInstructions\n(a) Please copy the sample code (decode.c) from the locker. ('/mit/6.087/Lab2/decode.c')\n(b) Please go through the code to understand the overall structure and how it implements the\nalgorithm.\nThings to do:\n(a) The symbol tree has to be recreated given the mapping between symbols and its binary\nstring (see code.txt). The function build tree() implements this functionality. Please fill in\nmissing code.\n(b) Given the encoded string and symbol tree, write the missing code to generate the decoded\noutput. Hint: for each string, traverse the tree and output a symbol only when you encounter\na leaf node.\n(c) Finally fill in the missing code(if any) to free all resources and memory before exiting the\ncode.\nOutput The program outputs a file 'decoded.txt' containing the decoded output. The output\nshould be \"abbacafebad\".\n\nPart B: Implementing a Huffman encoder (Project)\nIn this part, we will implement a Huffman encoder. For simplicity, we assume that the the symbols\ncan be one of 'a','b','c','d','e','f','g'. We also assume that the symbols frequencies are known.\nInstructions\n(a) Please copy the sample code (encode.c) from the locker. ('/mit/6.087/Lab2/encode.c')\n(b) Please go through the code to understand the overall structure and how it implements the\nalgorithm. In particular pay attention to the use of a priority queue and how the code tree\nis built from bottom-up.\nThings to do:\n(a) During each iteration, we need to keep track of the symbol (or composite) with the lowest\nfrequency and second lowest frequency of occurrence. This can be done easily using a priority\nqueue (a linked list where elements are always inserted in the correct position).\nThe file\n'encode.c' contains template code (pq insert())that implements the priority queue. You are\nrequired to fill in the missing sections. Make sure you take care of the following conditions:(i)\nqueue is empty (ii) new element goes before the beginning and (iii) new element goes at the\nend or in the middle of the queue.\n(b) Symbols are removed from the priority queue using 'pq pop()' function. In a priority queue,\nelements are always removed from the beginning. The file 'encode.c' contains template code\nto implement this. Please fill in the missing parts. Make sure you update the pointers for the\nelement to be removed.\n(c) Once the code tree is built in memory, we need to generate the code strings for each symbol.\nFill in the missing code in 'generate code()'.\n(d) Finally fill in the missing code to free all resources and memory before exiting the code.\nOutput The program outputs two files 'encoded.txt' containing the encoded output and also\n'code.txt' that displays the huffman code. Your output should match the reference values shown\nbelow:\nsymbol\ncode\na\nb\nc\nd\ne\nf\ng\nTable 2: Reference huffman code\n\nPart C: Compressing a large file (Project)\nThus far, we have assumed the symbols and their frequencies are given. In this part, you will be\ngenerating the symbol frequencies from a text file.\nInstructions\n(a) Please copy the text file (book.txt) from the locker. ('/mit/6.087/Lab2/book.txt')\nThings to do:\n(a) Update encode.c to read from this file to generate the frequency of occurence.\n(b) Generate an updated 'code.txt' and 'encoded.txt'\n(c) Update decode.c (if required).\n(d) Measure the compression ratio. Assume each character('1'/'0') in encoded stream (encodec.txt)\ntakes one bit. Assume each character in book.txt takes 8 bits.\nOutput The decoded file decoded.txt and book.txt has to be identical.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 1",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/b7f13dd2771c6e8557e0877457d07543_MIT6_087IAP10_lec01.pdf",
      "content": "6.087 Lecture 1 - January 11, 2010\nIntroduction to C\nWriting C Programs\nOur First C Program\n\nWhat is C?\n- Dennis Ritchie - AT&T Bell\nLaboratories - 1972\n- 16-bit DEC PDP-11\ncomputer (right)\n- Widely used today\n- extends to newer system\narchitectures\n- efficiency/performance\n- low-level access\n\nFeatures of C\nC features:\n- Few keywords\n- Structures, unions - compound data types\n- Pointers - memory, arrays\n- External standard library - I/O, other facilities\n- Compiles to native code\n- Macro preprocessor\n\nVersions of C\nEvolved over the years:\n1972 - C invented\n-\n- 1978 - The C Programming Language published; first\nspecification of language\n- 1989 - C89 standard (known as ANSI C or Standard C)\n- 1990 - ANSI C adopted by ISO, known as C90\n1999 - C99 standard\n-\n- mostly backward-compatible\n- not completely implemented in many compilers\n2007 - work on new C standard C1X announced\n-\nIn this course: ANSI/ISO C (C89/C90)\n\nWhat is C used for?\nSystems programming:\n- OSes, like Linux\n- microcontrollers: automobiles and airplanes\n- embedded processors: phones, portable electronics, etc.\n- DSP processors: digital audio and TV systems\n. . .\n-\n\nC vs. related languages\n- More recent derivatives: C++, Objective C, C#\n- Influenced: Java, Perl, Python (quite different)\nC lacks:\n-\n- exceptions\n- range-checking\n- garbage collection\n- object-oriented programming\n- polymorphism\n. . .\n-\nLow-level language\nfaster code (usually)\n-\n⇒\n\nWarning: low-level language!\nInherently unsafe:\n- No range checking\n- Limited type safety at compile time\n- No type checking at runtime\nHandle with care.\n- Always run in a debugger like gdb (more later. . . )\nNever run as root\n-\nNever test code on the Athena servers\n-\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\n6.087 Lecture 1 - January 11, 2010\nIntroduction to C\nWriting C Programs\nOur First C Program\n\nEditing C code\n.c extension\n-\n- Editable directly\nMore later. . .\n-\n\nCompiling a program\n- gcc (included with most Linux distributions): compiler\n.o extension\n-\n- omitted for common programs like gcc\n\nMore about gcc\n- Run gcc:\nathena% gcc -Wall infilename.c -o\noutfilename.o\n- -Wall enables most compiler warnings\n- More complicated forms exist\n- multiple source files\n- auxiliary directories\n- optimization, linking\n- Embed debugging info and disable optimization:\nathena% gcc -g -O0 -Wall infilename.c -o\noutfilename.o\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nDebugging\nFigure: gdb: command-line debugger\n\nUsing gdb\nSome useful commands:\n- break linenumber - create breakpoint at specified line\n- break file:linenumber - create breakpoint at line in\nfile\n- run - run program\nc - continue execution\n-\nnext - execute next line\n-\n- step - execute next line or step into function\n- quit - quit gdb\n- print expression - print current value of the specified\nexpression\n- help command - in-program help\n\nMemory debugging\nFigure: valgrind: diagnose memory-related problems\n\nThe IDE - all-in-one solution\n- Popular IDEs: Eclipse (CDT), Microsoft Visual C++\n(Express Edition), KDevelop, Xcode, . . .\n- Integrated editor with compiler, debugger\n- Very convenient for larger programs\nCourtesy of The Eclipse Foundation. Used with permission.\n\nUsing Eclipse\n- Need Eclipse CDT for C programs (see\nhttp://www.eclipse.org/cdt/)\n- Use New > C Project\n- choose \"Hello World ANSI C Project\" for simple project\n- \"Linux GCC toolchain\" sets up gcc and gdb (must be\ninstalled separately)\n- Recommended for final project\n\n6.087 Lecture 1 - January 11, 2010\nIntroduction to C\nWriting C Programs\nOur First C Program\n\nHello, 6.087 students\n- In style of \"Hello, world!\"\n.c file structure\n-\n- Syntax: comments, macros, basic declarations\n- The main() function and function structure\n- Expressions, order-of-operations\n- Basic console I/O (puts(), etc.)\n\nStructure of a .c file\n/* Begin with comments about file contents */\nInsert #include statements and preprocessor\ndefinitions\nFunction prototypes and variable declarations\nDefine main() function\n{\nFunction body\n}\nDefine other function\n{\nFunction body\n}\n.\n.\n.\n\nComments\n- Comments: /∗ this is a simple comment ∗/\n- Can span multiple lines\n/ ∗ This comment\nspans\nm u l t i p l e l i n e s ∗ /\n- Completely ignored by compiler\n- Can appear almost anywhere\n/ ∗ hello . c -- our f i r s t C program\nCreated by Daniel Weller , 01/11/2010 ∗ /\n\nThe #include macro\n- Header files: constants, functions, other declarations\n#include <stdio.h> - read the contents of the header file\n-\nstdio.h\n- stdio.h: standard I/O functions for console, files\n/ ∗ hello . c -- our f i r s t C program\nCreated by Daniel Weller , 01/11/2010 ∗ /\n#include < stdio . h> / ∗ basic I /O f a c i l i t i e s ∗ /\n\nMore about header files\n- stdio.h - part of the C Standard Library\n- other important header files: ctype.h, math.h,\nstdlib.h, string.h, time.h\n- For the ugly details: visit http:\n//www.unix.org/single_unix_specification/\n(registration required)\n- Included files must be on include path\n- -Idirectory with gcc: specify additional include\ndirectories\n- standard include directories assumed by default\n- #include \"stdio.h\" - searches ./ for stdio.h first\n\nDeclaring variables\nMust declare variables before use\n-\nVariable declaration:\n-\nint n;\nfloat phi;\n- int - integer data type\n- float - floating-point data type\n- Many other types (more next lecture. . . )\n\nInitializing variables\n- Uninitialized, variable assumes a default value\n- Variables initialized via assignment operator:\nn = 3;\nCan also initialize at declaration:\n-\nfloat phi = 1.6180339887;\n- Can declare/initialize multiple variables at once:\nint a, b, c = 0, d = 4;\n\nArithmetic expressions\nSuppose x and y are variables\n- x+y, x-y, x*y, x/y, x%y: binary arithmetic\n- A simple statement:\ny = x+3∗x/(y-4);\n- Numeric literals like 3 or 4 valid in expressions\n- Semicolon ends statement (not newline)\n- x += y, x -= y, x *= y, x /= y, x %= y: arithmetic\nand assignment\n\nOrder of operations\n- Order of operations:\nOperator\nEvaluation direction\n+,- (sign)\nright-to-left\n*,/,%\nleft-to-right\n+,-\nleft-to-right\n=,+=,-=,*=,/=,%=\nright-to-left\n- Use parentheses to override order of evaluation\n\nOrder of operations\nAssume x = 2.0 and y = 6.0. Evaluate the statement\nfloat z = x+3∗x/(y-4);\n1. Evaluate expression in parentheses\nfloat z = x+3∗x/(y-4);\nfloat z = x+3∗x/2.0;\n→\n\nOrder of operations\nAssume x = 2.0 and y = 6.0. Evaluate the statement\nfloat z = x+3∗x/(y-4);\n1. Evaluate expression in parentheses\nfloat z = x+3∗x/(y-4);\nfloat z = x+3∗x/2.0;\n→\n2. Evaluate multiplies and divides, from left-to-right\nfloat z = x+3∗x/2.0;\nfloat z = x+6.0/2.0;\nfloat z = x+3.0;\n→\n→\n\nOrder of operations\nAssume x = 2.0 and y = 6.0. Evaluate the statement\nfloat z = x+3∗x/(y-4);\n1. Evaluate expression in parentheses\nfloat z = x+3∗x/(y-4);\nfloat z = x+3∗x/2.0;\n→\n2. Evaluate multiplies and divides, from left-to-right\nfloat z = x+3∗x/2.0;\nfloat z = x+6.0/2.0;\nfloat z = x+3.0;\n→\n→\n3. Evaluate addition\nfloat z = x+3.0;\nfloat z = 5.0;\n→\n\nOrder of operations\nAssume x = 2.0 and y = 6.0. Evaluate the statement\nfloat z = x+3∗x/(y-4);\n1. Evaluate expression in parentheses\nfloat z = x+3∗x/(y-4);\nfloat z = x+3∗x/2.0;\n→\n2. Evaluate multiplies and divides, from left-to-right\nfloat z = x+3∗x/2.0;\nfloat z = x+6.0/2.0;\nfloat z = x+3.0;\n→\n→\n3. Evaluate addition\nfloat z = x+3.0;\nfloat z = 5.0;\n→\n4. Perform initialization with assignment\nNow, z = 5.0.\n\nOrder of operations\nAssume x = 2.0 and y = 6.0. Evaluate the statement\nfloat z = x+3∗x/(y-4);\n1. Evaluate expression in parentheses\nfloat z = x+3∗x/(y-4);\nfloat z = x+3∗x/2.0;\n→\n2. Evaluate multiplies and divides, from left-to-right\nfloat z = x+3∗x/2.0;\nfloat z = x+6.0/2.0;\nfloat z = x+3.0;\n→\n→\n3. Evaluate addition\nfloat z = x+3.0;\nfloat z = 5.0;\n→\n4. Perform initialization with assignment\nNow, z = 5.0.\nHow do I insert parentheses to get z = 4.0?\n\nOrder of operations\nAssume x = 2.0 and y = 6.0. Evaluate the statement\nfloat z = x+3∗x/(y-4);\n1. Evaluate expression in parentheses\nfloat z = x+3∗x/(y-4);\nfloat z = x+3∗x/2.0;\n→\n2. Evaluate multiplies and divides, from left-to-right\nfloat z = x+3∗x/2.0;\nfloat z = x+6.0/2.0;\nfloat z = x+3.0;\n→\n→\n3. Evaluate addition\nfloat z = x+3.0;\nfloat z = 5.0;\n→\n4. Perform initialization with assignment\nNow, z = 5.0.\nHow do I insert parentheses to get z = 4.0?\nfloat z = (x+3∗x)/(y-4);\n\nFunction prototypes\nFunctions also must be declared before use\n-\n- Declaration called function prototype\n- Function prototypes:\nint factorial ( int );\nor\nint factorial (int n);\n- Prototypes for many common functions in header files for\nC Standard Library\n\nFunction prototypes\nGeneral form:\n-\nreturn_type function_name(arg1,arg2,...);\n- Arguments: local variables, values passed from caller\n- Return value: single value returned to caller when function\nexits\n- void - signifies no return value/arguments\nint rand(void);\n\nThe main() function\n- main(): entry point for C program\n- Simplest version: no inputs, outputs 0 when successful,\nand nonzero to signal some error\nint main(void);\n- Two-argument form of main(): access command-line\narguments\nint main(int argc, char ∗∗argv);\n- More on the char **argv notation later this week. . .\n\nFunction definitions\nFunction declaration\n{\ndeclare variables;\nprogram statements;\n}\n- Must match prototype (if there is one)\nvariable names don't have to match\n-\nno semicolon at end\n-\n- Curly braces define a block - region of code\n- Variables declared in a block exist only in that block\n- Variable declarations before any other statements\n\nOur main() function\n/ ∗ The main ( ) function ∗ /\nint main ( void )\n/ ∗ entry point ∗ /\n{\n/ ∗ write message to console ∗ /\nputs ( \"hello, 6.087 students\" ) ;\nreturn 0; / ∗ e x i t (0 => success ) ∗ /\n}\n- puts(): output text to console window (stdout) and end\nthe line\n- String literal: written surrounded by double quotes\n- return 0;\nexits the function, returning value 0 to caller\n\nAlternative main() function\n- Alternatively, store the string in a variable first:\nint main ( void )\n/ ∗ entry point ∗ /\n{\nconst char msg [ ] = \"hello, 6.087 students\" ;\n/ ∗ write message to console ∗ /\nputs (msg ) ;\n- const keyword: qualifies variable as constant\n- char: data type representing a single character; written in\nquotes: 'a', '3', 'n'\n- const char msg[]: a constant array of characters\n\nMore about strings\n- Strings stored as character array\n- Null-terminated (last character in array is '\\0' null)\n- Not written explicitly in string literals\n- Special characters specified using \\ (escape character):\n- \\\\ - backslash, \\' - apostrophe, \\\" - quotation mark\n- \\b, \\t, \\r, \\n - backspace, tab, carriage return, linefeed\n- \\ooo, \\xhh - octal and hexadecimal ASCII character\ncodes, e.g. \\x41 - 'A', \\060 - '0'\n\nConsole I/O\n- stdout, stdin: console output and input streams\n- puts(string): print string to stdout\n- putchar(char): print character to stdout\n- char = getchar(): return character from stdin\n- string = gets(string): read line from stdin into\nstring\n- Many others - later this week\n\nPreprocessor macros\n- Preprocessor macros begin with # character\n#include <stdio.h>\n- #define msg \"hello, 6.087 students\"\ndefines msg as \"hello, 6.087 students\" throughout\nsource file\n- many constants specified this way\n\nDefining expression macros\n- #define can take arguments and be treated like a function\n#define add3(x,y,z) ((x)+(y)+(z))\n- parentheses ensure order of operations\n- compiler performs inline replacement; not suitable for\nrecursion\n\nConditional preprocessor macros\n- #if, #ifdef, #ifndef, #else, #elif , #endif\nconditional preprocessor macros, can control which lines\nare compiled\n- evaluated before code itself is compiled, so conditions must\nbe preprocessor defines or literals\n- the gcc option -Dname=value sets a preprocessor define\nthat can be used\n- Used in header files to ensure declarations happen only\nonce\n\nConditional preprocessor macros\n- #pragma\npreprocessor directive\n- #error, #warning\ntrigger a custom compiler error/warning\n- #undef msg\nremove the definition of msg at compile time\n\nCompiling our code\nAfter we save our code, we run gcc:\nathena% gcc -g -O0 -Wall hello.c -o\nhello.o\nAssuming that we have made no errors, our compiling is\ncomplete.\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nRunning our code\nOr, in gdb,\nathena% gdb hello.o\n.\n.\n.\nReading symbols from hello.o...done.\n(gdb) run\nStarting program:\nhello.o\nhello, 6.087 students\nProgram exited normally.\n(gdb) quit\nathena%\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nSummary\nTopics covered:\n- How to edit, compile, and debug C programs\n- C programming fundamentals:\ncomments\n-\n- preprocessor macros, including #include\n- the main() function\n- declaring and initializing variables, scope\n- using puts() - calling a function and passing an argument\n- returning from a function\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nIAP 2010\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 2",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/ab99b303a22349b7830a31eca6310fee_MIT6_087IAP10_lec02.pdf",
      "content": "6.087 Lecture 2 - January 12, 2010\nReview\nVariables and data types\nOperators\nEpilogue\n\nReview: C Programming language\n- C is a fast, small,general-purpose,platform independent\nprogramming language.\n- C is used for systems programming (e.g., compilers and\ninterpreters, operating systems, database systems,\nmicrocontrollers etc.)\n- C is static (compiled), typed, structured and imperative.\n- \"C is quirky, flawed, and an enormous success.\"-Ritchie\n\nReview: Basics\n- Variable declarations: int i ; float f ;\n- Intialization: char c='A'; int x=y=10;\n- Operators: +,-,∗,/,%\n- Expressions: int x,y,z; x=y∗2+z∗3;\n- Function: int factorial (int n); /∗function takes int , returns int ∗/\n\n6.087 Lecture 2 - January 12, 2010\nReview\nVariables and data types\nOperators\nEpilogue\n\nDefinitions\nDatatypes:\n- The datatype of an object in memory determines the set\nof values it can have and what operations that can be\nperformed on it.\n- C is a weakly typed language. It allows implicit conversions\nas well as forced (potentially dangerous) casting.\nOperators:\n- Operators specify how an object can be manipulated\n(e.g.,, numeric vs. string operations).\n- operators can be unary(e.g., -,++),binary (e.g.,\n+,-,*,/),ternary (?:)\n\nDefinitions (contd.)\nExpressions:\n- An expression in a programming language is a\ncombination of values, variables, operators, and functions\nVariables:\n- A variable is as named link/reference to a value stored in\nthe system's memory or an expression that can be\nevaluated.\nConsider: int x=0,y=0; y=x+2;.\n- x, y are variables\n- y = x + 2 is an expression\n- + is an operator.\n\nVariable names\nNaming rules:\n- Variable names can contain letters,digits and _\nVariable names should start with letters.\n-\n- Keywords (e.g., for,while etc.) cannot be used as variable\nnames\n- Variable names are case sensitive. int x; int X declares\ntwo different variables.\nPop quiz (correct/incorrect):\n- int money$owed; (incorrect: cannot contain $)\n- int total_count (correct)\n- int score2 (correct)\n- int 2ndscore (incorrect: must start with a letter)\n- int long (incorrect: cannot use keyword)\n\nData types and sizes\nC has a small family of datatypes.\n- Numeric (int,float,double)\n- Character (char)\n- User defined (struct,union)\n\nNumeric data types\nDepending on the precision and range required, you can use\none of the following datatypes.\nsigned\nunsigned\nshort\nshort int x;short y;\nunsigned short x;unsigned short int y;\ndefault\nint x;\nunsigned int x;\nlong\nlong x;\nunsigned long x;\nfloat\nfloat x;\nN/A\ndouble\ndouble x;\nN/A\nchar\nchar x; signed char x;\nunsigned char x;\n- The unsigned version has roughly double the range of its\nsigned counterparts.\n- Signed and unsigned characters differ only when used in\narithmetic expressions.\n- Titbit: Flickr changed from unsigned long (232 - 1) to string\ntwo years ago.\n\nBig endian vs. little endian\nThe individual sizes are machine/compiler dependent.\nHowever, the following is guaranteed:\nsizeof(char)<sizeof(short)<=sizeof(int)<=sizeof(long) and\nsizeof(char)<sizeof(short)<=sizeof(float)<=sizeof(double)\n\"NUXI\" problem: For numeric data types that span multiple\nbytes, the order of arrangement of the individual bytes is\nimportant. Depending on the device architecture, we have \"big\nendian\" and \"little endian\" formats.\n\nBig endian vs. little endian (cont.)\n- Big endian: the most significant bits (MSBs) occupy the\nlower address. This representation is used in the powerpc\nprocessor. Networks generally use big-endian order, and\nthus it is called network order.\n- Little endian : the least signficant bits (LSBs) occupy the\nlower address. This representation is used on all x86\ncompatible processors.\nFigure: (from http://en.wikipedia.org/wiki/Little_endian)\n\nConstants\nConstants are literal/fixed values assigned to variables or used\ndirectly in expressions.\nDatatype\nexample\nmeaning\nint i=3;\ninteger\nlong l=3;\nlong integer\ninteger\nunsigned long ul= 3UL;\nunsigned long\nint i=0xA;\nhexadecimal\nint i=012;\noctal number\nfloat pi=3.14159\nfloat\nfloating point\nfloat pi=3.141F\nfloat\ndouble pi=3.1415926535897932384L\ndouble\n\nConstants (contd.)\nDatatype\nexample\nmeaning\ncharacter\n'A'\n'\\x41'\n'\\0101'\ncharacter\nspecified in hex\nspecified in octal\nstring\n\"hello world\"\n\"hello\"\"world\"\nstring literal\nsame as \"hello world\"\nenumeration\nenum BOOL {NO,YES}\nenum COLOR {R=1,G,B,Y=10}\nNO=0,YES=1\nG=2,B=3\n\nDeclarations\nThe general format for a declaration is\ntype variable-name [=value]\n.\nExamples:\n- char x; /∗ uninitialized ∗/\n- char x='A'; /∗ intialized to 'A'∗/\n- char x='A',y='B'; /∗multiple variables initialized ∗/\n- char x=y='Z';/∗multiple initializations ∗/\n\nPop quiz II\n- int x=017;int y=12; /∗is x>y?∗/\n- short int s=0xFFFF12; /∗correct?∗/\n- char c=-1;unsigned char uc=-1; /∗correct?∗/\n- puts(\"hel\"+\"lo\");puts(\"hel\"\"lo\");/∗which is correct?∗/\n- enum sz{S=0,L=3,XL}; /∗what is the value of XL?∗/\n- enum sz{S=0,L=-3,XL}; /∗what is the value of XL?∗/\n\n6.087 Lecture 2 - January 12, 2010\nReview\nVariables and data types\nOperators\nEpilogue\n\nArithmetic operators\noperator\nmeaning\nexamples\n+\naddition\nx=3+2; /∗constants∗/\ny+z; /∗variables∗/\nx+y+2; /∗both∗/\n-\nsubtraction\n3-2; /∗constants∗/\nint x=y-z; /∗variables∗/\ny-2-z; /∗both∗/\n*\nmultiplication\nint x=3∗2; /∗constants∗/\nint x=y∗z; /∗variables∗/\nx∗y∗2; /∗both∗/\n\nArithmetic operators (contd.)\noperator\nmeaning\nexamples\n/\ndivision\nfloat x=3/2; /∗produces x=1 (int /) ∗/\nfloat x=3.0/2 /∗produces x=1.5 (float /) ∗/\nint x=3.0/2; /∗produces x=1 (int conversion)∗/\n%\nmodulus\n(remainder)\nint x=3%2; /∗produces x=1∗/\nint y=7;int x=y%4; /∗produces 3∗/\nint y=7;int x=y%10; /∗produces 7∗/\n\nRelational Operators\nRelational operators compare two operands to produce a\n'boolean' result. In C any non-zero value (1 by convention) is\nconsidered to be 'true' and 0 is considered to be false.\noperator\nmeaning\nexamples\n>\ngreater than\n3>2; /∗evaluates to 1 ∗/\n2.99>3 /∗evaluates to 0 ∗/\n>=\ngreater than or\nequal to\n3>=3; /∗evaluates to 1 ∗/\n2.99>=3 /∗evaluates to 0 ∗/\n<\nlesser than\n3<3; /∗evaluates to 0 ∗/\n'A'<'B'/∗evaluates to 1∗/\n<=\nlesser than or equal\nto\n3<=3; /∗evaluates to 1 ∗/\n3.99<3 /∗evaluates to 0 ∗/\n\nRelational Operators\nTesting equality is one of the most commonly used relational\noperator\n==\noperator.\n!=\nGotchas:\nmeaning\nequal to\nnot equal to\nexamples\n3==3; /∗evaluates to 1 ∗/\n'A'=='a'/∗evaluates to 0 ∗/\n3!=3; /∗evaluates to 0 ∗/\n2.99!=3 /∗evaluates to 1 ∗/\nNote that the \"==\" equality operator is different from the\n-\n\"=\", assignment operator.\nNote that the \"==\" operator on float variables is tricky\n-\nbecause of finite precision.\n\nLogical operators\noperator\nmeaning\nexamples\n&&\nAND\n((9/3)==3) && (2∗3==6); /∗evaluates to 1 ∗/\n('A'=='a') && (3==3) /∗evaluates to 0 ∗/\n||\nOR\n2==3 || 'A'=='A'; /∗evaluates to 1 ∗/\n2.99>=3 || 0 /∗evaluates to 0 ∗/\n!\nNOT\n!(3==3); /∗evaluates to 0 ∗/\n!(2.99>=3) /∗evaluates to 1 ∗/\nShort circuit: The evaluation of an expression is discontinued if\nthe value of a conditional expression can be determined early.\nBe careful of any side effects in the code.\nExamples:\n- (3==3) || ((c=getchar())=='y'). The second expression is not\nevaluated.\n- (0) && ((x=x+1)>0) . The second expression is not evaluated.\n\nIncrement and decrement operators\nIncrement and decrement are common arithmetic operation. C\nprovides two short cuts for the same.\nPostfix\nx++ is a short cut for x=x+1\n-\n- x-- is a short cut for x=x-1\n- y=x++ is a short cut for y=x;x=x+1. x is evaluated before it is\nincremented.\n- y=x-- is a short cut for y=x;x=x-1. x is evaluated before it is\ndecremented.\n\nIncrement and decrement operators\nPrefix:\n++x is a short cut for x=x+1\n-\n- --x is a short cut for x=x-1\n- y=++x is a short cut for x=x+1;y=x;. x is evaluate after it is\nincremented.\n- y=--x is a short cut for x=x-1;y=x;. x is evaluate after it is\ndecremented.\n\nBitwise Operators\noperator\nmeaning\nexamples\n&\nAND\n0x77 & 0x3; /∗evaluates to 0x3 ∗/\n0x77 & 0x0; /∗evaluates to 0 ∗/\n|\nOR\n0x700 | 0x33; /∗evaluates to 0x733 ∗/\n0x070 | 0 /∗evaluates to 0x070 ∗/\nˆ\nXOR\n0x770 ^ 0x773; /∗evaluates to 0x3 ∗/\n0x33 ^ 0x33; /∗evaluates to 0 ∗/\n«\nleft shift\n0x01<<4; /∗evaluates to 0x10 ∗/\n1<<2; /∗evaluates to 4 ∗/\n»\nright shift\n0x010>>4; /∗evaluates to 0x01 ∗/\n4>>1 /∗evaluates to 2 ∗/\nNotes:\n- AND is true only if both operands are true.\n- OR is true if any operand is true.\n- XOR is true if only one of the operand is true.\n\nAssignment Operators\nAnother common expression type found while programming in\nC is of the type var = var (op) expr\nx=x+1\n-\n- x=x∗10\n- x=x/2\nC provides compact assignment operators that can be used\ninstead.\n- x+=1 /∗is the same as x=x+1∗/\n- x-=1 /∗is the same as x=x-1∗/\n- x∗=10 /∗is the same as x=x∗10 ∗/\n- x/=2 /∗ is the same as x=x/2\n- x%=2 /∗is the same as x=x%2\n\nConditional Expression\nA common pattern in C (and in most programming) languages\nis the following:\ni f ( cond )\nx=<expra >;\nelse\nx=<exprb >;\nC provides syntactic sugar to express the same using the\nternary operator '?:'\nsign=x>0?1:-1;\nisodd=x%2==1?1:0;\ni f ( x>0)\ni f ( x%2==1)\nsign =1\nisodd=1\nelse\nelse\nsign=-1\nisodd=0\nNotice how the ternary operator makes the code shorter and\neasier to understand (syntactic sugar).\n\n6.087 Lecture 2 - January 12, 2010\nReview\nVariables and data types\nOperators\nEpilogue\n\nType Conversions\nWhen variables are promoted to higher precision, data is\npreserved. This is automatically done by the compiler for mixed\ndata type expressions.\nint i ;\nfloat f ;\nf = i +3.14159; / ∗ i i s promoted to f l o a t , f =( f l o a t ) i +3.14159 ∗ /\nAnother conversion done automatically by the compiler is 'char'\n'int'. This allows comparisons as well as manupilations of\n→\ncharacter variables.\nisupper =(c>='A' && c<='Z' )?1:0; / ∗ c and l i t e r a l constants\nare converted to i n t ∗ /\ni f ( ! isupper )\nc=c-'a'+'A' ;\n/ ∗ subtraction i s possible\nbecause of integer conversion ∗ /\nAs a rule (with exceptions), the compiler promotes each term in\nan binary expression to the highest precision operand.\n\nPrecedence and Order of Evaluation\n- ++,-,(cast),sizeof have the highest priority\n- *,/,% have higher priority than +,\n- ==,!= have higher priority than &&,||\n- assignment operators have very low priority\nUse () generously to avoid ambiguities or side effects\nassociated with precendence of operators.\n- y=x∗3+2 /∗same as y=(x∗3)+2∗/\n- x!=0 && y==0 /∗same as (x!=0) && (y==0)∗/\n- d= c>='0'&& c<='9'/∗same as d=(c>='0') && (c<='9')∗/\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nIAP 2010\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 3",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/6ef53f22595564c47c0c377ef8bd5398_MIT6_087IAP10_lec03.pdf",
      "content": "6.087 Lecture 3 - January 13, 2010\nReview\nBlocks and Compound Statements\nControl Flow\nConditional Statements\nLoops\nFunctions\nModular Programming\nVariable Scope\nStatic Variables\nRegister Variables\n\nReview: Definitions\n- Variable - name/reference to a stored value (usually in\nmemory)\n- Data type - determines the size of a variable in memory,\nwhat values it can take on, what operations are allowed\n- Operator - an operation performed using 1-3 variables\n- Expression - combination of literal values/variables and\noperators/functions\n\nReview: Data types\n- Various sizes (char, short, long, float, double)\n- Numeric types - signed/unsigned\n- Implementation - little or big endian\n- Careful mixing and converting (casting) types\n\nReview: Operators\n- Unary, binary, ternary (1-3 arguments)\n- Arithmetic operators, relational operators, binary (bitwise\nand logical) operators, assignment operators, etc.\n- Conditional expressions\n- Order of evaluation (precedence, direction)\n\n6.087 Lecture 3 - January 13, 2010\nReview\nBlocks and Compound Statements\nControl Flow\nConditional Statements\nLoops\nFunctions\nModular Programming\nVariable Scope\nStatic Variables\nRegister Variables\n\nBlocks and compound statements\n- A simple statement ends in a semicolon:\nz = foo(x+y);\n- Consider the multiple statements:\ntemp = x+y ;\nz = foo ( temp ) ;\n- Curly braces - combine into compound statement/block\n\nBlocks\n- Block can substitute for simple statement\n- Compiled as a single unit\nVariables can be declared inside\n-\n{\nint temp = x+y ;\nz = foo ( temp ) ;\n}\n- Block can be empty {}\nNo semicolon at end\n-\n\nNested blocks\nBlocks nested inside each other\n-\n{\nint temp = x+y ;\nz = foo ( temp ) ;\n{\nfloat temp2 = x∗y ;\nz += bar ( temp2 ) ;\n}\n}\n\n6.087 Lecture 3 - January 13, 2010\nReview\nBlocks and Compound Statements\nControl Flow\nConditional Statements\nLoops\nFunctions\nModular Programming\nVariable Scope\nStatic Variables\nRegister Variables\n\nControl conditions\n- Unlike C++ or Java, no boolean type (in C89/C90)\n- in C99, bool type available (use stdbool.h)\n- Condition is an expression (or series of expressions)\ne.g. n < 3 or x < y || z < y\nExpression is non-zero\ncondition true\n-\n⇒\n- Expression must be numeric (or a pointer)\nconst char s t r [ ] = \"some text\" ;\ni f ( s t r ) / ∗ s t r i n g i s not n u l l ∗ /\nreturn 0;\n\nConditional statements\nThe if statement\n-\nThe switch statement\n-\n\nThe if statement\ni f ( x % 2)\ny += x / 2 ;\nEvaluate condition\n-\nif (x % 2 == 0)\n- If true, evaluate inner statement\ny += x/2;\n- Otherwise, do nothing\n\nThe else keyword\ni f ( x % 2 == 0)\ny += x / 2 ;\nelse\ny += ( x +1)/2;\n- Optional\nExecute statement if condition is false\n-\ny += (x+1)/2;\n- Either inner statement may be block\n\nThe else if keyword\ni f ( x % 2 == 0)\ny += x / 2 ;\nelse i f ( x % 4 == 1)\ny += 2∗ (( x + 3 ) / 4 ) ;\nelse\ny += ( x +1)/2;\n- Additional alternative control paths\n- Conditions evaluated in order until one is met; inner\nstatement then executed\n- If multiple conditions true, only first executed\n- Equivalent to nested if statements\n\nNesting if statements\ni f ( x % 4 == 0)\ni f ( x % 2 == 0)\ny = 2;\nelse\ny = 1;\nTo which if statement does the else keyword belong?\n\nNesting if statements\nTo associate else with outer if statement: use braces\ni f ( x % 4 == 0) {\ni f ( x % 2 == 0)\ny = 2;\n} else\ny = 1;\n\nThe switch statement\nAlternative conditional statement\n-\n- Integer (or character) variable as input\nConsiders cases for value of variable\n-\nswitch ( ch ) {\ncase 'Y' :\n/ ∗ ch == 'Y ' ∗ /\n/ ∗ do something ∗ /\nbreak ;\ncase 'N' :\n/ ∗ ch == 'N ' ∗ /\n/ ∗ do something else ∗ /\nbreak ;\ndefault :\n/ ∗ otherwise ∗ /\n/ ∗ do a t h i r d thing ∗ /\nbreak ;\n}\n\nMultiple cases\n- Compares variable to each case in order\n- When match found, starts executing inner code until\nbreak; reached\n- Execution \"falls through\" if break; not included\nswitch ( ch ) {\nswitch ( ch ) {\ncase 'Y' :\ncase 'Y' :\n/ ∗ do something i f\ncase 'y' :\nch == 'Y ' ∗ /\n/ ∗ do something i f\ncase 'N' :\nch == 'Y ' or\n/ ∗ do something i f\nch == ' y ' ∗ /\nch == 'Y ' or\nbreak ;\nch == 'N ' ∗ /\n}\nbreak ;\n}\n\nThe switch statement\nContents of switch statement a block\n-\n- Case labels: different entry points into block\n- Similar to labels used with goto keyword (next lecture. . . )\n\nLoop statements\n- The while loop\n- The for loop\n- The do-while loop\n- The break and continue keywords\n\nThe while loop\nwhile ( / ∗ condition ∗ / )\n/ ∗ loop body ∗ /\n- Simplest loop structure - evaluate body as long as\ncondition is true\n- Condition evaluated first, so body may never be executed\n\nThe for loop\nint f a c t o r i a l ( int n ) {\nint i , j = 1;\nfor ( i = 1; i\n<= n ; i ++)\nj ∗= i ;\nreturn j ;\n}\n- The \"counting\" loop\n- Inside parentheses, three expressions, separated by\nsemicolons:\nInitialization: i = 1\n-\nCondition: i <= n\n-\nIncrement: i++\n-\n- Expressions can be empty (condition assumed to be \"true\")\n\nThe for loop\nEquivalent to while loop:\nint f a c t o r i a l ( int n ) {\nint j = 1;\nint i = 1; / ∗ i n i t i a l i z a t i o n ∗ /\nwhile ( i <= n / ∗ condition ∗ / ) {\nj ∗= i ;\ni ++; / ∗ increment ∗ /\n}\nreturn j ;\n}\n\nThe for loop\n- Compound expressions separated by commas\nint f a c t o r i a l ( int n ) {\nint i , j ;\nfor ( i = 1 , j = 1; i\n<= n ; j ∗= i , i ++)\n;\nreturn j ;\n}\n- Comma: operator with lowest precedence, evaluated\nleft-to-right; not same as between function arguments\n\nThe do-while loop\nchar c ;\ndo {\n/ ∗ loop body ∗ /\nputs ( \"Keep going? (y/n) \" ) ;\nc = getchar ( ) ;\n/ ∗ other processing ∗ /\n} while ( c == 'y' && / ∗ other conditions ∗ / ) ;\n- Differs from while loop - condition evaluated after each\niteration\n- Body executed at least once\nNote semicolon at end\n-\n\nThe break keyword\n- Sometimes want to terminate a loop early\n- break; exits innermost loop or switch statement to exit\nearly\n- Consider the modification of the do-while example:\nchar c ;\ndo {\n/ ∗ loop body ∗ /\nputs ( \"Keep going? (y/n) \" ) ;\nc = getchar ( ) ;\ni f ( c != 'y' )\nbreak ;\n/ ∗ other processing ∗ /\n} while ( / ∗ other conditions ∗ / ) ;\n\nThe continue keyword\n- Use to skip an iteration\n- continue; skips rest of innermost loop body, jumping to loop\ncondition\n- Example:\n#define min (a , b ) ( ( a ) < ( b ) ? ( a ) : ( b ) )\nint gcd ( int a , int b ) {\nint i , r e t = 1 , minval = min (a , b ) ;\nfor ( i = 2; i <= minval ; i ++) {\ni f ( a % i ) / ∗ i not d i v i s o r of a ∗ /\ncontinue ;\ni f ( b % i == 0) / ∗ i i s d i v i s o r of both a and b ∗ /\nr e t = i ;\n}\nreturn r e t ;\n}\n\n6.087 Lecture 3 - January 13, 2010\nReview\nBlocks and Compound Statements\nControl Flow\nConditional Statements\nLoops\nFunctions\nModular Programming\nVariable Scope\nStatic Variables\nRegister Variables\n\nFunctions\n- Already seen some functions, including main():\nint main ( void )\n{\n/ ∗ do s t u f f ∗ /\nreturn 0; / ∗ success ∗ /\n}\n- Basic syntax of functions explained in Lecture 1\n- How to write a program using functions?\n\nDivide and conquer\n- Conceptualize how a program can be broken into smaller\nparts\n- Let's design a program to solve linear Diophantine\nequation (ax + by = c,x, y: integers):\nget a, b, c from command line\ncompute g = gcd(a,b)\nif (c is not a multiple of the gcd)\nno solutions exist; exit\nrun Extended Euclidean algorithm on a, b\nrescale x and y output by (c/g)\nprint solution\n- Extended Euclidean algorithm: finds integers x, y s.t.\nax + by = gcd(a, b).\n\nComputing the gcd\n- Compute the gcd using the Euclidean algorithm:\nint gcd ( int a , int b ) {\nwhile ( b ) { / ∗ i f a < b , performs swap ∗ /\nint temp = b ;\nb = a % b ;\na = temp ;\n}\nreturn a ;\n}\n- Algorithm relies on gcd(a, b) = gcd(b, a mod b), for natural\nnumbers a > b.\n[Knuth, D. E. The Art of Computer Programming, Volume 1: Fundamental\nAlgorithms. 3rd ed. Addison-Wesley, 1997.]\n(c) Addison Wesley. All rights reserved. This content is excluded from our Creative Commons license.\nFor more information, see http://ocw.mit.edu/fairuse.\n\nExtended Euclidean algorithm\nPseudocode for Extended Euclidean algorithm:\nInitialize state variables (x,y)\nif (a < b)\nswap(a,b)\nwhile (b > 0) {\ncompute quotient, remainder\nupdate state variables (x,y)\n}\nreturn gcd and state variables (x,y)\n[Menezes, A. J., et al. Handbook of Applied Cryptography. CRC Press, 1996.]\n(c) CRC Press. All rights reserved. This content is excluded from our Creative Commons license.\nFor more information, see http://ocw.mit.edu/fairuse.\n\nReturning multiple values\n- Extended Euclidean algorithm returns gcd, and two other\nstate variables, x and y\n- Functions only return (up to) one value\n- Solution: use global variables\n- Declare variables for other outputs outside the function\n- variables declared outside of a function block are globals\n- persist throughout life of program\n- can be accessed/modified in any function\n\nDivide and conquer\n- Break down problem into simpler sub-problems\nConsider iteration and recursion\n-\n- How can we implement gcd(a,b) recursively?\nMinimize transfer of state between functions\n-\n- Writing pseudocode first can help\n\n6.087 Lecture 3 - January 13, 2010\nReview\nBlocks and Compound Statements\nControl Flow\nConditional Statements\nLoops\nFunctions\nModular Programming\nVariable Scope\nStatic Variables\nRegister Variables\n\nProgramming modules in C\n- C programs do not need to be monolithic\n- Module: interface and implementation\ninterface: header files\n-\n- implementation: auxilliary source/object files\n- Same concept carries over to external libraries (next\nweek. . . )\n\nThe Euclid module\n- Euclid's algorithms useful in many contexts\n- Would like to include functionality in many programs\n- Solution: make a module for Euclid's algorithms\n- Need to write header file (.h) and source file (.c)\n\nThe source: euclid.c\nImplement gcd() in euclid.c:\n/ ∗ The gcd ( ) function ∗ /\nint gcd ( int a , int b ) {\nwhile ( b ) { / ∗ i f a < b , performs swap ∗ /\nint temp = b ;\nb = a % b ;\na = temp ;\n}\nreturn a ;\n}\nExtended Euclidean algorithm implemented as\next_euclid(), also in euclid.c\n\nThe extern keyword\n- Need to inform other source files about functions/global\nvariables in euclid.c\n- For functions: put function prototypes in a header file\n- For variables: re-declare the global variable using the\nextern keyword in header file\n- extern informs compiler that variable defined somewhere\nelse\n- Enables access/modifying of global variable from other\nsource files\n\nThe header: euclid.h\nHeader contains prototypes for gcd() and ext_euclid():\n/ ∗ ensure included only once ∗ /\n#ifndef __EUCLID_H__\n#define __EUCLID_H__\n/ ∗ global variables ( declared in euclid . c ) ∗ /\nextern int x , y ;\n/ ∗ compute gcd ∗ /\nint gcd ( int a , int b ) ;\n/ ∗ compute g = gcd (a , b ) and solve ax+by=g ∗ /\nint ext _euclid ( int a , int b ) ;\n#endif\n\nUsing the Euclid module\n- Want to be able to call gcd() or ext_euclid() from the\nmain file diophant.c\nNeed to include the header file euclid.h:\n-\n#include \"euclid.h\" (file in \".\", not search path)\n- Then, can call as any other function:\n/ ∗ compute g = gcd (a , b ) ∗ /\ng = gcd (a , b ) ;\n/ ∗ compute x and y using Extended Euclidean alg . ∗ /\ng = ext _euclid (a , b ) ;\n- Results in global variables x and y\n/ ∗ rescale so ax+by = c ∗ /\ngrow = c / g ;\nx ∗= grow ;\ny ∗= grow ;\n\nCompiling with the Euclid module\n- Just compiling diophant.c is insufficient\n- The functions gcd() and ext_euclid() are defined in\neuclid.c; this source file needs to be compiled, too\n- When compiling the source files, the outputs need to be\nlinked together into a single output\n- One call to gcc can accomplish all this:\nathena% gcc -g -O0 -Wall diophant.c\neuclid.c -o diophant.o\n- diophant.o can be run as usual\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\n6.087 Lecture 3 - January 13, 2010\nReview\nBlocks and Compound Statements\nControl Flow\nConditional Statements\nLoops\nFunctions\nModular Programming\nVariable Scope\nStatic Variables\nRegister Variables\n\nVariable scope\n- scope - the region in which a variable is valid\n- Many cases, corresponds to block with variable's\ndeclaration\n- Variables declared outside of a function have global scope\n- Function definitions also have scope\n\nAn example\nWhat is the scope of each variable in this example?\nint nmax = 20;\n/ ∗ The main ( ) function ∗ /\nint main ( int argc , char\nargv ) / ∗ entry point ∗ /\n∗∗\n{\nint a = 0 , b = 1 , c , n ;\np r i n t f ( \"%3d: %d\\n\" ,1 ,a ) ;\np r i n t f ( \"%3d: %d\\n\" ,2 ,b ) ;\nfor ( n = 3; n <= nmax ; n++) {\nc = a + b ; a = b ; b = c ;\np r i n t f ( \"%3d: %d\\n\" ,n , c ) ;\n}\nreturn 0; / ∗ success ∗ /\n}\n\nScope and nested declarations\nHow many lines are printed now?\nint nmax = 20;\n/ ∗ The main ( ) function ∗ /\nint main ( int argc , char\nargv ) / ∗ entry point ∗ /\n∗∗\n{\nint a = 0 , b = 1 , c , n , nmax = 25;\np r i n t f ( \"%3d: %d\\n\" ,1 ,a ) ;\np r i n t f ( \"%3d: %d\\n\" ,2 ,b ) ;\nfor ( n = 3; n <= nmax ; n++) {\nc = a + b ; a = b ; b = c ;\np r i n t f ( \"%3d: %d\\n\" ,n , c ) ;\n}\nreturn 0; / ∗ success ∗ /\n}\n\nStatic variables\n- static keyword has two meanings, depending on where\nthe static variable is declared\n- Outside a function, static variables/functions only visible\nwithin that file, not globally (cannot be extern'ed)\n- Inside a function, static variables:\nare still local to that function\n-\n- are initialized only during program initialization\n- do not get reinitialized with each function call\nstatic int somePersistentVar = 0;\n\nRegister variables\n- During execution, data processed in registers\n- Explicitly store commonly used data in registers - minimize\nload/store overhead\n- Can explicitly declare certain variables as registers using\nregister keyword\n- must be a simple type (implementation-dependent)\n- only local variables and function arguments eligible\n- excess/unallowed register declarations ignored, compiled\nas regular variables\n- Registers do not reside in addressed memory; pointer of a\nregister variable illegal\n\nExample\nVariable scope example, revisited, with register variables:\n/ ∗ The main ( ) function ∗ /\nint main ( register int argc , register char\nargv )\n∗∗\n{\nregister int a = 0 , b = 1 , c , n , nmax = 20;\np r i n t f ( \"%3d: %d\\n\" ,1 ,a ) ;\np r i n t f ( \"%3d: %d\\n\" ,2 ,b ) ;\nfor ( n = 3; n <= nmax ; n++) {\nc = a + b ; a = b ; b = c ;\np r i n t f ( \"%3d: %d\\n\" ,n , c ) ;\n}\nreturn 0; / ∗ success ∗ /\n}\n\nSummary\nTopics covered:\n- Controlling program flow using conditional statements and\nloops\n- Dividing a complex program into many simpler\nsub-programs using functions and modular programming\ntechniques\n- Variable scope rules and extern, static, and\nregister variables\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 4",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/262cf4e05f039e45c926109c8aa95024_MIT6_087IAP10_lec04.pdf",
      "content": "6.087 Lecture 4 - January 14, 2010\nReview\nControl flow\nI/O\nStandard I/O\nString I/O\nFile I/O\n\nBlocks\n- Blocks combine multiple statements into a single unit.\n- Can be used when a single statement is expected.\n- Creates a local scope (variables declared inside are local\nto the block).\nBlocks can be nested.\n-\n{\nint x=0;\n{\nint y=0; / ∗ both x and y v i s i b l e ∗ /\n}\n/ ∗ only x v i s i b l e ∗ /\n}\n\nConditional blocks\nif ... else..else if is used for conditional branching of execution\ni f ( cond )\n{\n/ ∗ code executed i f cond i s true ∗ /\n}\nelse\n{\n/ ∗ code executed i f cond i s false ∗ /\n}\n\nConditional blocks\nswitch..case is used to test multiple conditions (more efficient\nthan if else ladders).\nswitch ( opt )\n{\ncase 'A' :\n/ ∗ execute i f opt == 'A ' ∗ /\nbreak ;\ncase 'B' :\ncase 'C' :\n/ ∗ execute i f opt == 'B ' | | opt == 'C ' ∗ /\ndefault :\n}\n\nIterative blocks\n- while loop tests condition before execution of the block.\n- do..while loop tests condition after execution of the block.\n- for loop provides initialization, testing and iteration together.\n\n6.087 Lecture 4 - January 14, 2010\nReview\nControl flow\nI/O\nStandard I/O\nString I/O\nFile I/O\n\ngoto\n- goto allows you to jump unconditionally to arbitrary part of\nyour code (within the same function).\n- the location is identified using a label.\na label is a named location in the code. It has the same\n-\nform as a variable followed by a ':'\ns t a r t :\n{\ni f ( cond )\ngoto outside ;\n/ ∗ some code ∗ /\ngoto s t a r t ;\n}\noutside :\n/ ∗ outside block ∗ /\n\nSpaghetti code\nDijkstra. Go To Statement Considered Harmful.\nCommunications of the ACM 11(3),1968\n- Excess use of goto creates sphagetti code.\n- Using goto makes code harder to read and debug.\n- Any code that uses goto can be written without using one.\n\nerror handling\nLanguage like C++ and Java provide exception mechanism to\nrecover from errors. In C, goto provides a convenient way to exit\nfrom nested blocks.\ncont _flag =1;\nfor ( . . )\nfor ( . . )\n{\n{\nfor ( i n i t ; c o n t _ f l a g ; i t e r )\nfor ( . . )\n{\n{\ni f ( error_cond )\ni f ( error_cond )\n{\ngoto e r r o r ;\nc o n t _ f l a g =0;\n/ ∗ skips 2 blocks ∗ /\nbreak ;\n}\n}\n}\n/ ∗ i n n er loop ∗ /\ne r r o r :\n}\ni f ( ! c o n t _ f l a g ) break ;\n/ ∗ outer loop ∗ /\n}\n\n6.087 Lecture 4 - January 14, 2010\nReview\nControl flow\nI/O\nStandard I/O\nString I/O\nFile I/O\n\nPreliminaries\n- Input and output facilities are provided by the standard\nlibrary <stdio.h> and not by the language itself.\n- A text stream consists of a series of lines ending with '\\n'.\nThe standard library takes care of conversion from\n'\\r\\n'-'\\n'\n- A binary stream consists of a series of raw bytes.\n- The streams provided by standard library are buffered.\n\nStandard input and output\nint putchar(int)\n- putchar(c) puts the character c on the standard output.\n- it returns the character printed or EOF on error.\nint getchar()\n- returns the next character from standard input.\nit returns EOF on error.\n-\n\nStandard input and output\nWhat does the following code do?\nint main ( )\n{\nchar c ;\nwhile ( ( c=getchar ( ) ) ! = EOF)\n{\ni f ( c>='A' && c<='Z' )\nc=c-'A'+'a' ;\nputchar ( c ) ;\n}\nreturn 0;\n}\nTo use a file instead of standard input, use '<' operator (*nix).\n- Normal invocation: ./a.out\n- Input redirection: a.out < file.txt. Treats file.txt as source of\nstandard input.This is an OS feature, not a language\nfeature.\n\nStandard output:formatted\nint printf (char format[],arg1,arg2 ,...)\n- printf() can be used for formatted output.\n- It takes in a variable number of arguments.\n- It returns the number of characters printed.\n- The format can contain literal strings as well as format\nspecifiers (starts with %).\nExamples:\np r i n t f ( \"hello world\\n\" ) ;\np r i n t f ( \"%d\\n\" ,10); / ∗ format : %d ( integer ) , argument :10 ∗ /\np r i n t f ( \"Prices:%d and %d\\n\" ,10 ,20);\n\nprintf format specification\nThe format specification has the following components\n%[flags][width ][. precision ][ length]<type>\ntype:\ntype\nmeaning\nexample\nd,i\ninteger\nprintf (\"%d\",10); /∗prints 10∗/\nx,X\ninteger (hex)\nprintf (\"%x\",10); /∗ print 0xa∗/\nu\nunsigned integer\nprintf (\"%u\",10); /∗prints 10∗/\nc\ncharacter\nprintf (\"%c\",'A'); /∗prints A∗/\ns\nstring\nprintf (\"%s\",\"hello\"); /∗prints hello∗/\nf\nfloat\nprintf (\"%f\",2.3); /∗ prints 2.3∗/\nd\ndouble\nprintf (\"%d\",2.3); /∗ prints 2.3∗/\ne,E\nfloat(exp)\n1e3,1.2E3,1E-3\n%\nliteral %\nprintf (\"%d %%\",10); /∗prints 10%∗/\n\nprintf format specification (cont.)\n%[flags][width ][. precision ][ modifier]<type>\nwidth:\nformat\noutput\nprintf (\"%d\",10)\n\"10\"\nprintf (\"%4d\",10)\nbb10 (b:space)\nprintf (\"%s\",\"hello\")\nhello\nprintf (\"%7s\",\"hello\")\nbbhello\n\nprintf format specification (cont.)\n%[flags][width ][. precision ][ modifier]<type>\nflag:\nformat\noutput\nprintf (\"%d,%+d,%+d\",10,-10)\n10,+10,-10\nprintf (\"%04d\",10)\nprintf (\"%7s\",\"hello\")\nbbhello\nprintf (\"%-7s\",\"hello\")\nhellobb\n\nprintf format specification (cont.)\n%[flags][width ][. precision ][ modifier]<type>\nprecision:\nformat\noutput\nprintf (\"%.2f,%.0f,1.141,1.141)\n1.14,1\nprintf (\"%.2e,%.0e,1.141,100.00)\n1.14e+00,1e+02\nprintf (\"%.4s\",\"hello\")\nhell\nprintf (\"%.1s\",\"hello\")\nh\n\nprintf format specification (cont.)\n%[flags][width ][. precision ][ modifier]<type>\nmodifier:\nmodifier\nmeaning\nh\ninterpreted as short. Use with i,d,o,u,x\nl\ninterpreted as long. Use with i,d,o,u,x\nL\ninterpreted as double. Use with e,f,g\n\nDigression: character arrays\nSince we will be reading and writing strings, here is a brief\ndigression\n- strings are represented as an array of characters\n- C does not restrict the length of the string. The end of the\nstring is specified using 0.\nFor instance, \"hello\" is represented using the array\n{'h','e','l','l','\\0'}.\nDeclaration examples:\n- char str []=\"hello\"; /∗compiler takes care of size∗/\n- char str[10]=\"hello\"; /∗make sure the array is large enough∗/\n- char str []={ 'h','e','l','l',0};\nNote: use \\\" if you want the string to contain \".\n\nDigression: character arrays\nComparing strings: the header file <string.h> provides the\nfunction int strcmp(char s[],char t []) that compares two strings in\ndictionary order (lower case letters come after capital case).\nthe function returns a value <0 if s comes before t\n-\nthe function return a value 0 if s is the same as t\n-\nthe function return a value >0 if s comes after t\n-\n- strcmp is case sensitive\nExamples\n- strcmp(\"A\",\"a\") /∗<0∗/\n- strcmp(\"IRONMAN\",\"BATMAN\") /∗>0∗/\n- strcmp(\"aA\",\"aA\") /∗==0∗/\n- strcmp(\"aA\",\"a\") /∗>0∗/\n\nFormatted input\nint scanf(char∗ format ,...) is the input analog of printf.\n- scanf reads characters from standard input, interpreting\nthem according to format specification\n- Similar to printf , scanf also takes variable number of\narguments.\n- The format specification is the same as that for printf\n- When multiple items are to be read, each item is assumed\nto be separated by white space.\nIt returns the number of items read or EOF.\n-\n- Important: scanf ignores white spaces.\n- Important: Arguments have to be address of variables\n(pointers).\n\nFormatted input\nint scanf(char∗ format ,...) is the input analog of printf.\nExamples:\nprintf (\"%d\",x)\nscanf(\"%d\",&x)\nprintf (\"%10d\",x)\nscanf(\"%d\",&x)\nprintf (\"%f\",f)\nscanf(\"%f\",&f)\nprintf (\"%s\",str)\nscanf(\"%s\",str) /∗note no & required∗/\nprintf (\"%s\",str)\nscanf(\"%20s\",str) /∗note no & required∗/\nprintf (\"%s %s\",fname,lname)\nscanf(\"%20s %20s\",fname,lname)\n\nString input/output\nInstead of writing to the standard output, the formatted data can\nbe written to or read from character arrays.\nint sprintf (char string [], char format[],arg1,arg2)\n- The format specification is the same as printf.\n- The output is written to string (does not check size).\n- Returns the number of character written or negative value\non error.\nint sscanf(char str [], char format[],arg1,arg2)\n- The format specification is the same as scanf;\n- The input is read from str variable.\n- Returns the number of items read or negative value on\nerror.\n\nFile I/O\nSo far, we have read from the standard input and written to the\nstandard output. C allows us to read data from text/binary files\nusing fopen().\nFILE∗ fopen(char name[],char mode[])\n- mode can be \"r\" (read only),\"w\" (write only),\"a\" (append)\namong other options. \"b\" can be appended for binary files.\n- fopen returns a pointer to the file stream if it exists or\nNULL otherwise.\n- We don't need to know the details of the FILE data type.\n- Important: The standard input and output are also FILE*\ndatatypes (stdin,stdout).\n- Important: stderr corresponds to standard error\noutput(different from stdout).\n\nFile I/O(cont.)\nint fclose(FILE∗ fp)\n- closes the stream (releases OS resources).\n- fclose() is automatically called on all open files when\nprogram terminates.\n\nFile input\nint getc(FILE∗ fp)\n- reads a single character from the stream.\n- returns the character read or EOF on error/end of file.\nNote: getchar simply uses the standard input to read a\ncharacter. We can implement it as follows:\n#define getchar() getc(stdin)\nchar[] fgets(char line [], int maxlen,FILE∗ fp)\n- reads a single line (upto maxlen characters) from the input\nstream (including linebreak).\n- returns a pointer to the character array that stores the line\n(read-only)\nreturn NULL if end of stream.\n-\n\nFile output\nint putc(int c,FILE∗ fp)\n- writes a single character c to the output stream.\nreturns the character written or EOF on error.\n-\nNote: putchar simply uses the standard output to write a\ncharacter. We can implement it as follows:\n#define putchar(c) putc(c,stdout)\nint fputs(char line [], FILE∗ fp)\n- writes a single line to the output stream.\n- returns zero on success, EOF otherwise.\nint fscanf(FILE∗ fp,char format[],arg1,arg2)\n- similar to scanf,sscanf\n- reads items from input stream fp.\n\nCommand line input\n- In addition to taking input from standard input and files, you\ncan also pass input while invoking the program.\n- Command line parameters are very common in *nix\nenvironment.\n- So far, we have used int main() as to invoke the main\nfunction. However, main function can take arguments that\nare populated when the program is invoked.\n\nCommand line input (cont.)\nint main(int argc,char∗ argv[])\n- argc: count of arguments.\n- argv[]: an array of pointers to each of the arguments\n- note: the arguments include the name of the program as\nwell.\nExamples:\n- ./cat a.txt b.txt (argc=3,argv[0]=\"cat\" argv[1]=\"a.txt\"\nargv[2]=\"b.txt\"\n- ./cat (argc=1,argv[0]=\"cat\")\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 5",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/d5a4c815a3f931d7efca0f4fb1a7604f_MIT6_087IAP10_lec05.pdf",
      "content": "6.087 Lecture 5 - January 15, 2010\nReview\nPointers and Memory Addresses\nPhysical and Virtual Memory\nAddressing and Indirection\nFunctions with Multiple Outputs\nArrays and Pointer Arithmetic\nStrings\nString Utility Functions\nSearching and Sorting Algorithms\nLinear Search\nA Simple Sort\nFaster Sorting\nBinary Search\n\nReview: Unconditional jumps\n- goto keyword: jump somewhere else in the same function\n- Position identified using labels\n- Example (for loop) using goto:\n{\nint i = 0 , n = 20; / ∗ i n i t i a l i z a t i o n ∗ /\ngoto loop_cond ;\nloop_body :\n/ ∗ body of loop here ∗ /\ni ++;\nloop_cond :\ni f ( i < n ) / ∗ loop condition ∗ /\ngoto loop_body ;\n}\n- Excessive use of goto results in \"spaghetti\" code\n\nReview: I/O Functions\n- I/O provided by stdio.h, not language itself\n- Character I/O: putchar(), getchar(), getc(),\nputc(), etc.\n- String I/O: puts(), gets(), fgets(), fputs(), etc.\n- Formatted I/O: fprintf(), fscanf(), etc.\n- Open and close files: fopen(), fclose()\n- File read/write position: feof(), fseek(), ftell(), etc.\n. . .\n-\n\nReview: printf() and scanf()\n- Formatted output:\nint printf (char format[], arg1, arg2, ...)\n- Takes variable number of arguments\n- Format specification:\n%[flags][width][.precision][length]<type>\n- types: d, i (int), u, o, x, X (unsigned int), e, E, f, F, g, G\n(double), c (char), s (string)\n- flags, width, precision, length - modify meaning and number\nof characters printed\n- Formatted input: scanf() - similar form, takes pointers to\narguments (except strings), ignores whitespace in input\n\nReview: Strings and character arrays\n- Strings represented in C as an array of characters (char [])\n- String must be null-terminated ('\\0' at end)\nDeclaration:\n-\nchar str [] = \"I am a string.\"; or\nchar str[20] = \"I am a string.\";\n- strcpy() - function for copying one string to another\n- More about strings and string functions today. . .\n\n6.087 Lecture 5 - January 15, 2010\nReview\nPointers and Memory Addresses\nPhysical and Virtual Memory\nAddressing and Indirection\nFunctions with Multiple Outputs\nArrays and Pointer Arithmetic\nStrings\nString Utility Functions\nSearching and Sorting Algorithms\nLinear Search\nA Simple Sort\nFaster Sorting\nBinary Search\n\nPointers and addresses\n- Pointer: memory address of a variable\n- Address can be used to access/modify a variable from\nanywhere\n- Extremely useful, especially for data structures\n- Well known for obfuscating code\n\nPhysical and virtual memory\n- Physical memory: physical resources where data can be\nstored and accessed by your computer\ncache\n-\nRAM\n-\nhard disk\n-\n- removable storage\n- Virtual memory: abstraction by OS, addressable space\naccessible by your code\n\nPhysical memory considerations\n- Different sizes and access speeds\n- Memory management - major function of OS\n- Optimization - to ensure your code makes the best use of\nphysical memory available\n- OS moves around data in physical memory during\nexecution\n- Embedded processors - may be very limited\n\nVirtual memory\n- How much physical memory do I have?\nAnswer: 2 MB (cache) + 2 GB (RAM) + 100 GB (hard\ndrive) + . . .\n- How much virtual memory do I have?\nAnswer: <4 GB (32-bit OS), typically 2 GB for Windows,\n3-4 GB for linux\n- Virtual memory maps to different parts of physical memory\n- Usable parts of virtual memory: stack and heap\n- stack: where declared variables go\n- heap: where dynamic memory goes\n\nAddressing variables\n- Every variable residing in memory has an address!\nWhat doesn't have an address?\n-\n- register variables\n- constants/literals/preprocessor defines\n- expressions (unless result is a variable)\n- How to find an address of a variable? The & operator\nint n = 4;\ndouble pi = 3.14159;\nint ∗pn = &n ; / ∗ address of integer n ∗ /\ndouble ∗ ppi = &pi ; / ∗ address of double pi ∗ /\n- Address of a variable of type t has type t *\n\nDereferencing pointers\n- I have a pointer - now what?\n- Accessing/modifying addressed variable:\ndereferencing/indirection operator *\n/ ∗ p r i n t s \" pi = 3.14159\\n \" ∗ /\np r i n t f ( \"pi = %g\\n\" ,∗ ppi ) ;\n/ ∗ pi now equals 7.14159 ∗ /\n∗ ppi = ∗ ppi + ∗pn ;\n- Dereferenced pointer like any other variable\n- null pointer, i.e. 0 (NULL): pointer that does not reference\nanything\n\nCasting pointers\n- Can explicitly cast any pointer type to any other pointer\ntype\nppi = (double ∗)pn; /∗ pn originally of type ( int ∗) ∗/\n- Implicit cast to/from void * also possible (more next\nweek. . . )\n- Dereferenced pointer has new type, regardless of real type\nof data\n- Possible to cause segmentation faults, other\ndifficult-to-identify errors\n- What happens if we dereference ppi now?\n\nFunctions with multiple outputs\n- Consider the Extended Euclidean algorithm\next_euclid(a,b) function from Wednesday's lecture\n- Returns gcd(a, b), x and y s.t. ax + by = gcd(a, b)\n- Used global variables for x and y\n- Can use pointers to pass back multiple outputs:\nint ext_euclid(int a, int b, int ∗x, int ∗y);\n- Calling ext_euclid(), pass pointers to variables to\nreceive x and y:\nint x , y , g ;\n/ ∗ assume a , b declared previously ∗ /\ng = ext _euclid (a , b,&x ,&y ) ;\n- Warning about x and y being used before initialized\n\nAccessing caller's variables\n- Want to write function to swap two integers\n- Need to modify variables in caller to swap them\n- Pointers to variables as arguments\nvoid swap( int ∗x , int ∗y ) {\nint temp = ∗x ;\n∗x = ∗y ;\n∗y = temp ;\n}\n- Calling swap() function:\nint a = 5 , b = 7;\nswap(&a , &b ) ;\n/ ∗ now, a = 7 , b = 5 ∗ /\n\nVariables passing out of scope\n- What is wrong with this code?\n#include < stdio . h>\nchar\nget_message ( ) {\n∗\nchar msg [ ] = \"Aren't pointers fun?\" ;\nreturn msg;\n}\nint main ( void )\n{\nchar\ns t r i n g = get_message ( ) ;\n∗\nputs ( s t r i n g ) ;\nreturn 0;\n}\n\nVariables passing out of scope\n- What is wrong with this code?\n#include < stdio . h>\nchar\nget_message ( ) {\n∗\nchar msg [ ] = \"Aren't pointers fun?\" ;\nreturn msg;\n}\nint main ( void )\n{\nchar\ns t r i n g = get_message ( ) ;\n∗\nputs ( s t r i n g ) ;\nreturn 0;\n}\n- Pointer invalid after variable passes out of scope\n\n6.087 Lecture 5 - January 15, 2010\nReview\nPointers and Memory Addresses\nPhysical and Virtual Memory\nAddressing and Indirection\nFunctions with Multiple Outputs\nArrays and Pointer Arithmetic\nStrings\nString Utility Functions\nSearching and Sorting Algorithms\nLinear Search\nA Simple Sort\nFaster Sorting\nBinary Search\n\nArrays and pointers\n- Primitive arrays implemented in C using pointer to block of\ncontiguous memory\n- Consider array of 8 ints:\nint arr [8];\n- Accessing arr using array entry operator:\nint a = arr [0];\n- arr is like a pointer to element 0 of the array:\nint ∗pa = arr;\nint ∗pa = &arr[0];\n⇔\n- Not modifiable/reassignable like a pointer\n\nThe sizeof() operator\n- For primitive types/variables, size of type in bytes:\nint s = sizeof(char); /∗ == 1 ∗/\ndouble f; /∗ sizeof(f) == 8 ∗/ (64-bit OS)\n- For primitive arrays, size of array in bytes:\nint arr [8]; /∗ sizeof(arr) == 32 ∗/ (64-bit OS)\nlong arr [5]; /∗ sizeof(arr) == 40 ∗/ (64-bit OS)\n- Array length:\n/ ∗ needs to be on one l i n e when implemented ∗ /\n#define array _length ( arr ) ( sizeof ( arr )\n== 0 ?\n0 : sizeof ( arr ) / sizeof ( ( arr ) [ 0 ] ) )\n- More about sizeof() next week. . .\n\nPointer arithmetic\n- Suppose int ∗pa = arr;\n- Pointer not an int, but can add or subtract an int from a\npointer:\npa + i points to arr[i]\n- Address value increments by i times size of data type\nSuppose arr[0] has address 100. Then arr[3] has\naddress 112.\n- Suppose char ∗ pc = (char ∗)pa; What value of i satisfies\n(int ∗)(pc+i) == pa + 3?\n\nPointer arithmetic\n- Suppose int ∗pa = arr;\n- Pointer not an int, but can add or subtract an int from a\npointer:\npa + i points to arr[i]\n- Address value increments by i times size of data type\nSuppose arr[0] has address 100. Then arr[3] has\naddress 112.\n- Suppose char ∗ pc = (char ∗)pa; What value of i satisfies\n(int ∗)(pc+i) == pa + 3?\ni = 12\n-\n\n6.087 Lecture 5 - January 15, 2010\nReview\nPointers and Memory Addresses\nPhysical and Virtual Memory\nAddressing and Indirection\nFunctions with Multiple Outputs\nArrays and Pointer Arithmetic\nStrings\nString Utility Functions\nSearching and Sorting Algorithms\nLinear Search\nA Simple Sort\nFaster Sorting\nBinary Search\n\nStrings as arrays\n- Strings stored as null-terminated character arrays (last\ncharacter == '\\0')\n- Suppose char str [] = \"This is a string.\"; and\nchar ∗ pc = str ;\n- Manipulate string as you would an array\n∗(pc+10) = 'S';\nputs(str ); /∗ prints \"This is a String .\" ∗/\n\nString utility functions\n- String functions in standard header string.h\n- Copy functions: strcpy(), strncpy()\nchar ∗ strcpy( strto ,strfrom ); - copy strfrom to strto\nchar ∗ strncpy(strto ,strfrom,n); - copy n chars from strfrom\nto strto\n- Comparison functions: strcmp(), strncmp()\nint strcmp(str1,str2 ); - compare str1, str2; return 0 if\nequal, positive if str1>str2, negative if str1<str2\nint strncmp(str1,str2,n); - compare first n chars of str1 and\nstr2\n- String length: strlen()\nint strlen ( str ); - get length of str\n\nMore string utility functions\n- Concatenation functions: strcat(), strncat()\nchar ∗ strcat ( strto ,strfrom ); - add strfrom to end of strto\nchar ∗ strncat( strto ,strfrom,n); - add n chars from strfrom to\nend of strto\n- Search functions: strchr(), strrchr()\nchar ∗ strchr( str ,c); - find char c in str, return pointer to\nfirst occurrence, or NULL if not found\nchar ∗ strrchr ( str ,c); - find char c in str, return pointer to\nlast occurrence, or NULL if not found\n- Many other utility functions exist. . .\n\n6.087 Lecture 5 - January 15, 2010\nReview\nPointers and Memory Addresses\nPhysical and Virtual Memory\nAddressing and Indirection\nFunctions with Multiple Outputs\nArrays and Pointer Arithmetic\nStrings\nString Utility Functions\nSearching and Sorting Algorithms\nLinear Search\nA Simple Sort\nFaster Sorting\nBinary Search\n\nSearching and sorting\n- Basic algorithms\n- Can make good use of pointers\n- Just a few examples; not a course in algorithms\n- Big-O notation\n\nSearching an array\n- Suppose we have an array of int's\nint arr [100]; /∗ array to search ∗/\n- Let's write a simple search function:\nint\nlinear _search ( int val ) {\n∗\nint\nparr ,\nparrend = arr + array _length ( arr ) ;\n∗\n∗\nfor ( parr = arr ; parr < parrend ; parr ++) {\ni f (∗ parr == val )\nreturn parr ;\n}\nreturn NULL;\n}\n\nA simple sort\n- A simple insertion sort: O(n2)\n- iterate through array until an out-of-order element found\ninsert out-of-order element into correct location\n-\n- repeat until end of array reached\n- Split into two functions for ease-of-use\nint arr [ 1 0 0 ] ; / ∗ array to sort ∗ /\nvoid shift _element ( unsigned i n t i ) {\n/ ∗ do i n s e r t i o n of out-of-order element ∗ /\n}\nvoid i n s e r t i o n _ s o r t ( ) {\n/ ∗ main i n s e r t i o n sort loop ∗ /\n/ ∗ c a l l shift _element ( ) f o r\neach out-of-order element ∗ /\n}\n\nShifting out-of-order elements\n- Code for shifting the element\n/ ∗ move previous elements down u n t i l\ni n s e r t i o n point reached ∗ /\nvoid shift _element ( unsigned i n t i ) {\nint ivalue ;\n/ ∗ guard against going outside array ∗ /\nfor ( ivalue = arr [ i ] ; i && arr [ i -1] > ivalue ; i --)\narr [ i ] = arr [ i -1]; / ∗ move element down ∗ /\narr [ i ] = ivalue ; / ∗ i n s e r t element ∗ /\n}\n\nInsertion sort\n- Main insertion sort loop\n/ ∗ i t e r a t e u n t i l out-of-order element found ;\ns h i f t the element , and continue i t e r a t i n g ∗ /\nvoid i n s e r t i o n _ s o r t ( void )\n{\nunsigned i n t i , len = array _length ( arr ) ;\nfor ( i = 1; i < len ; i ++)\ni f ( arr [ i ] < arr [ i -1])\nshift _element ( i ) ;\n}\n- Can you rewrite using pointer arithmetic instead of\nindexing?\n\nQuicksort\n- Many faster sorts available (shellsort, mergesort,\nquicksort, . . . )\n- Quicksort: O(n log n) average; O(n2) worst case\n- choose a pivot element\n- move all elements less than pivot to one side, all elements\ngreater than pivot to other\n- sort sides individually (recursive algorithm)\n- Implemented in C standard library as qsort() in\nstdlib.h\n\nQuicksort implementation\n- Select the pivot; separate the sides:\nvoid quick_sort ( unsigned i n t l e f t ,\nunsigned i n t r i g h t ) {\nunsigned i n t i , mid ;\nint pivot ;\ni f ( l e f t >= r i g h t )\nreturn ;\n/ ∗ nothing to sort ∗ /\n/ ∗ pivot i s midpoint ; move to l e f t side ∗ /\nswap( arr + l e f t , arr + ( l e f t + r i g h t ) / 2 ) ;\npivot = arr [ mid = l e f t ] ;\n/ ∗ separate i n t o side < pivot ( l e f t +1 to mid )\nand side >= pivot ( mid+1 to r i g h t ) ∗ /\nfor ( i = l e f t +1; i <= r i g h t ; i ++)\ni f ( arr [ i ] < pivot )\nswap( arr + ++mid , arr + i ) ;\n[Kernighan and Ritchie. The C Programming Language. 2nd ed. Prentice\nHall, 1988.]\n(c) Prentice Hall. All rights reserved. This content is excluded from our Creative Commons license.\nFor more information, see http://ocw.mit.edu/fairuse.\n\nQuicksort implementation\n- Restore the pivot; sort the sides separately:\n/ ∗ restore pivot p o s i t i o n ∗ /\nswap( arr + l e f t , arr +mid ) ;\n/ ∗ sort two sides ∗ /\ni f ( mid > l e f t )\nquick _sort ( l e f t , mid -1);\ni f ( mid < r i g h t )\nquick _sort ( mid+1 , r i g h t ) ;\n}\n- Starting the recursion:\nquick_sort(0, array_length(arr) - 1);\n[Kernighan and Ritchie. The C Programming Language. 2nd ed. Prentice\nHall, 1988.]\n(c) Prentice Hall. All rights reserved. This content is excluded from our Creative Commons license.\nFor more information, see http://ocw.mit.edu/fairuse.\n\nDiscussion of quicksort\n- Not stable (equal-valued elements can get switched) in\npresent form\n- Can sort in-place - especially desirable for low-memory\nenvironments\n- Choice of pivot influences performance; can use random\npivot\n- Divide and conquer algorithm; easily parallelizeable\n- Recursive; in worst case, can cause stack overflow on\nlarge array\n\nSearching a sorted array\n- Searching an arbitrary list requires visiting half the\nelements on average\n- Suppose list is sorted; can make use of sorting\ninformation:\n- if desired value greater than value and current index, only\nneed to search after index\n- each comparison can split list into two pieces\n- solution: compare against middle of current piece; then\nnew piece guaranteed to be half the size\n- divide and conquer!\n- More searching next week. . .\n\nBinary search\n- Binary search: O(log n) average, worst case:\nint\nbinary_search ( int val ) {\n∗\nunsigned i n t L = 0 , R = array _length ( arr ) , M;\nwhile ( L < R) {\nM = ( L+R- 1)/2;\ni f ( val == arr [M] )\nreturn arr +M; / ∗ found ∗ /\nelse i f ( val < arr [M] )\nR = M; / ∗ in f i r s t h a l f ∗ /\nelse\nL = M+1; / ∗ in second h a l f ∗ /\n}\nreturn NULL; / ∗ not found ∗ /\n}\n\nBinary search\n- Worst case: logarithmic time\n- Requires random access to array memory\n- on sequential data, like hard drive, can be slow\n- seeking back and forth in sequential memory is wasteful\n- better off doing linear search in some cases\n- Implemented in C standard library as bsearch() in\nstdlib.h\n\nSummary\nTopics covered:\n- Pointers: addresses to memory\n- physical and virtual memory\n- arrays and strings\n- pointer arithmetic\n- Algorithms\n- searching: linear, binary\n- sorting: insertion, quick\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 6",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/1aa34decd30f336826cd087d2f52035b_MIT6_087IAP10_lec06.pdf",
      "content": "6.087 Lecture 6 - January 19, 2010\nReview\nUser defined datatype\nStructures\nUnions\nBitfields\nData structure\nMemory allocation\nLinked lists\nBinary trees\n\nReview: pointers\n- Pointers: memory address of variables\n- '&' (address of) operator.\n- Declaring: int x=10; int ∗ px= &x;\n- Dereferencing: ∗px=20;\nPointer arithmetic:\n-\n- sizeof()\n- incrementing/decrementing\n- absolute value after operation depends on pointer datatype.\n\nReview: string.h\n- String copy: strcpy(),strncpy()\n- Comparison: strcmp(),strncmp()\n- Length: strlen()\n- Concatenation: strcat()\n- Search: strchr(),strstr()\n\nSearching and sorting\nSearching\n- Linear search: O(n)\n- Binary search: O(logn). The array has to be sorted first.\nSorting\n- Insertion sort: O(n2)\n- Quick sort: O(n log n)\n\n6.087 Lecture 6 - January 19, 2010\nReview\nUser defined datatype\nStructures\nUnions\nBitfields\nData structure\nMemory allocation\nLinked lists\nBinary trees\n\nStructure\nDefinition: A structure is a collection of related variables (of\npossibly different types) grouped together under a single name.\nThis is a an example of composition-building complex\nstructures out of simple ones.\nExamples:\nstruct employee\nstruct p o i n t\n{\n{\nchar fname [ 1 0 0 ] ;\ni n t x ;\nchar lname [ 1 0 0 ] ;\ni n t y ;\ni n t\nage ;\n} ;\n} ;\n/ ∗ n o t i c e the ; at the end ∗ /\n/ ∗ members of d i f f e r e n t\ntype ∗ /\n\nStructure\n- struct defines a new datatype.\n- The name of the structure is optional.\nstruct {...} x,y,z;\nThe variables declared within a structure are called its\n-\nmembers\n- Variables can be declared like any other built in data-type.\nstruct point ptA;\n- Initialization is done by specifying values of every member.\nstruct point ptA={10,20};\n- Assignment operator copies every member of the structure\n(be careful with pointers).\n\nStructure (cont.)\nMore examples:\nstruct t r i a n g l e\nstruct chain_element\n{\n{\nstruct point ptA ;\nint data ;\nstruct point ptB ;\nstruct chain_element ∗ next\nstruct point ptC ;\n} ;\n} ;\n/ ∗ members can be\n/ ∗ members can be structures ∗ / s e l f r e f e r e n t i a l ∗ /\n\nStructure (cont.)\n- Individual members can be accessed using '.' operator.\nstruct point pt={10,20}; int x=pt.x; int y=pt.y;\n- If structure is nested, multiple '.' are required\nstruct rectangle\n{\nstruct point t l ; / ∗ top l e f t ∗ /\nstruct point br ; / ∗ bot r i g h t ∗ /\n} ;\nstruct rectangle rect ;\nint t l x = rect . t l . x ; / ∗ nested ∗ /\nint t l y = rect . t l . y ;\n\nStructure pointers\n- Structures are copied element wise.\n- For large structures it is more efficient to pass pointers.\nvoid foo(struct point ∗ pp); struct point pt; foo(&pt)\n- Members can be accesses from structure pointers using\n'->' operator.\nstruct point p={10 ,20};\nstruct point ∗ pp=&p ;\npp->x = 10; / ∗ changes p . x ∗ /\nint y= pp->y ; / ∗ same as y=p . y ∗ /\nOther ways to access structure members?\nstruct point p={10 ,20};\nstruct point ∗ pp=&p ;\n(∗ pp ) . x = 10; / ∗ changes p . x ∗ /\nint y= (∗ pp ) . y ; / ∗ same as y=p . y ∗ /\nwhy is the () required?\n\nArrays of structures\n- Declaring arrays of int: int x[10];\n- Declaring arrays of structure: struct point p[10];\n- Initializing arrays of int: int x [4]={0,20,10,2};\n- Initializing arrays of structure:\nstruct point p[3]={0,1,10,20,30,12};\nstruct point p [3]={{0,1},{10,20},{30,12}};\n\nSize of structures\n- The size of a structure is greater than or equal to the sum\nof the sizes of its members.\n- Alignment\nstruct {\nchar c ;\n/ ∗ padding ∗ /\nint i ;\n- Why is this an important issue? libraries, precompiled files,\nSIMD instructions.\n- Members can be explicitly aligned using compiler\nextensions.\n__attribute__((aligned(x ))) /∗gcc∗/\n__declspec((aligned(x))) /∗MSVC∗/\n\nUnion\nA union is a variable that may hold objects of different\ntypes/sizes in the same memory location. Example:\nunion data\n{\nint idata ;\nfloat fdata ;\nchar∗ sdata ;\n} d1 , d2 , d3 ;\nd1 . idata =10;\nd1 . fdata =3.14F ;\nd1 . sdata=\"hello world\" ;\n\nUnions (cont.)\n- The size of the union variable is equal to the size of its\nlargest element.\n- Important: The compiler does not test if the data is being\nread in the correct format.\nunion data d; d.idata=10; float f=d.fdata; /∗ will give junk∗/\n- A common solution is to maintain a separate variable.\nenum dtype { INT ,FLOAT,CHAR} ;\nstruct v ar iant\n{\nunion data d ;\nenum dtype t ;\n} ;\n\nBit fields\nDefinition: A bit-field is a set of adjacent bits within a single\n'word'. Example:\nstruct f l a g {\nunsigned i n t i s _ co lo r : 1 ;\nunsigned i n t has_sound : 1 ;\nunsigned i n t is _ntsc : 1 ;\n} ;\n- the number after the colons specifies the width in bits.\n- each variables should be declared as unsigned int\nBit fields vs. masks\nCLR=0x1,SND=0x2,NTSC=0x4;\nstruct flag f ;\nx|= CLR; x|=SND; x|=NTSC\nf .has_sound=1;f.is_color=1;\nx&= ~CLR; x&=~SND;\nf .has_sound=0;f.is_color=0;\nif (x & CLR || x& NTSC)\nif (f . is_color || f .has_sound)\n\n6.087 Lecture 6 - January 19, 2010\nReview\nUser defined datatype\nStructures\nUnions\nBitfields\nData structure\nMemory allocation\nLinked lists\nBinary trees\n\nDigression: dynamic memory allocation\nvoid∗ malloc(size_t n)\n- malloc() allocates blocks of memory\n- returns a pointer to unitialized block of memory on\nsuccess\nreturns NULL on failure.\n-\n- the returned value should be cast to appropriate type using\n(). int∗ ip=(int∗)malloc(sizeof(int)∗100)\nvoid∗ calloc(size_t n,size_t size)\n- allocates an array of n elements each of which is 'size'\nbytes.\n- initializes memory to 0\nvoid free(void∗)\n- Frees memory allocated my malloc()\n- Common error: accessing memory after calling free\n\nLinked list\nDefinition: A dynamic data structure that consists of a\nsequence of records where each element contains a link to the\nnext record in the sequence.\n- Linked lists can be singly linked, doubly linked or circular.\nFor now, we will focus on singly linked list.\n- Every node has a payload and a link to the next node in\nthe list.\n- The start (head) of the list is maintained in a separate\nvariable.\n- End of the list is indicated by NULL (sentinel).\n\nLinked list\nstruct node\n{\nint data ; / ∗ payload ∗ /\nstruct node∗ next ;\n} ;\nstruct node∗ head ; / ∗ beginning ∗ /\nLinked list vs. arrays\nlinked-list\narray\nsize\ndynamic\nfixed\nindexing\nO(n)\nO(1)\ninserting\nO(1)\nO(n)\ndeleting\nO(1)\nO(n)\n\nLinked list\nCreating new element:\nstruct node∗ nalloc ( int data )\n{\nstruct node∗ p=( struct node ∗ ) malloc ( sizeof ( node ) ) ;\ni f ( p!=NULL)\n{\np->data=data ;\np->next=NULL;\n}\nreturn p ;\n}\n\nLinked list\nAdding elements to front:\nstruct node∗ addfront ( struct node∗ head , int data )\n{\nstruct node∗ p= nalloc ( data ) ;\ni f ( p==NULL) return head ;\np->next=head ;\nreturn p ;\n\nLinked list\nIterating:\nfor ( p=head ; p!=NULL; p=p->next )\n/ ∗ do something ∗ /\nfor ( p=head ; p->next !=NULL; p=p->next )\n/ ∗ do something ∗ /\n\nBinary trees\n- A binary tree is a dynamic data structure where each node\nhas at most two children. A binary search tree is a binary\ntree with ordering among its children.\n- Usually, all elements in the left subtree are assumed to be\n\"less\" than the root element and all elements in the right\nsubtree are assumed to be \"greater\" than the root element.\n\nBinary tree (cont.)\nstruct tnode\n{\nint data ; / ∗ payload ∗ /\nstruct tnode ∗ l e f t ;\nstruct tnode ∗ r i g h t ;\n} ;\nThe operation on trees can be framed as recursive operations.\nTraversal (printing,\nsearching):\n- pre-order: root, left\nsubtree, right subtree\n- Inorder: left subtree, root,\nright subtree\n- post-order: right subtree,\nright subtree, root\n\nBinary tree (cont.)\nAdd node:\nstruct tnode ∗ addnode ( struct tnode ∗ root , int data )\n{\nstruct tnode ∗ p=NULL;\n/ ∗ termination condition ∗ /\ni f ( root ==NULL)\n{\n/ ∗ al lo c a t e node ∗ /\n/ ∗ return new root ∗ /\n}\n/ ∗ recursive c a l l ∗ /\nelse i f ( data < root ->data )\nroot -> l e f t =addnode ( root ->l e f t , data )\nelse\nroot ->r i g h t =addnode ( root ->r i g h t , data )\n}\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 7",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/afdb632076595f216692b04cafae216c_MIT6_087IAP10_lec07.pdf",
      "content": "6.087 Lecture 7 - January 20, 2010\nReview\nMore about Pointers\nPointers to Pointers\nPointer Arrays\nMultidimensional Arrays\nData Structures\nStacks\nQueues\nApplication: Calculator\n\nReview: Compound data types\n- struct - structure containing one or multiple fields, each with\nits own type (or compound type)\n- size is combined size of all the fields, padded for byte\nalignment\n- anonymous or named\n- union - structure containing one of several fields, each with\nits own type (or compound type)\n- size is size of largest field\n- anonymous or named\nBit fields - structure fields with width in bits\n-\n- aligned and ordered in architecture-dependent manner\ncan result in inefficient code\n-\n\nReview: Compound data types\n- Consider this compound data structure:\nstruct foo {\nshort s ;\nunion {\nint i ;\nchar c ;\n} u ;\nunsigned int flag _s : 1;\nunsigned int flag_u : 2;\nunsigned int bar ;\n} ;\n- Assuming a 32-bit x86 processor, evaluate\nsizeof(struct foo)\n\nReview: Compound data types\n- Consider this compound data structure:\nstruct foo {\nshort s ;\n← 2 bytes\nunion {\n← 4 bytes,\nint i ;\n4 byte-aligned\nchar c ;\n} u ;\nunsigned int flag _s : 1;\nbit fields\nunsigned int flag_u : 2;\n←\nunsigned int bar ;\n4 bytes,\n←\n} ;\n4 byte-aligned\n- Assuming a 32-bit x86 processor, evaluate\nsizeof(struct foo)\n\nReview: Compound data types\n- How can we rearrange the fields to minimize the size of\nstruct foo?\n\nReview: Compound data types\n- How can we rearrange the fields to minimize the size of\nstruct foo?\n- Answer: order from largest to smallest:\nstruct foo {\nunion {\nint i ;\nchar c ;\n} u ;\nunsigned i n t bar ;\nshort s ;\nunsigned i n t flag _s : 1;\nunsigned i n t flag _u : 2;\n} ;\nsizeof(struct foo) = 12\n\nReview: Linked lists and trees\n- Linked list and tree dynamically grow as data is\nadded/removed\n- Node in list or tree usually implemented as a struct\n- Use malloc(), free(), etc. to allocate/free memory\ndynamically\n- Unlike arrays, do not provide fast random access by index\n(need to iterate)\n\n6.087 Lecture 7 - January 20, 2010\nReview\nMore about Pointers\nPointers to Pointers\nPointer Arrays\nMultidimensional Arrays\nData Structures\nStacks\nQueues\nApplication: Calculator\n\nPointer review\n- Pointer represents address to variable in memory\n- Examples:\nint ∗pn; - pointer to int\nstruct div_t ∗ pdiv; - pointer to structure div_t\n- Addressing and indirection:\ndouble pi = 3.14159;\ndouble ∗ ppi = &pi ;\np r i n t f ( \"pi = %g\\n\" , ∗ ppi ) ;\n- Today: pointers to pointers, arrays of pointers,\nmultidimensional arrays\n\nPointers to pointers\n- Address stored by pointer also data in memory\n- Can address location of address in memory - pointer to\nthat pointer\nint n = 3;\nint ∗pn = &n ; / ∗ pointer to n ∗ /\nint ∗∗ppn = &pn ; / ∗ pointer to address of n ∗ /\n- Many uses in C: pointer arrays, string arrays\n\nPointer pointers example\nWhat does this function do?\n-\nvoid swap( int ∗∗a , int ∗∗b ) {\nint ∗temp = ∗a ;\n∗a = ∗b ;\n∗b = temp ;\n}\n\nPointer pointers example\nWhat does this function do?\n-\nvoid swap( int ∗∗a , int ∗∗b ) {\nint ∗temp = ∗a ;\n∗a = ∗b ;\n∗b = temp ;\n}\n- How does it compare to the familiar version of swap?\nvoid swap( int ∗a , int ∗b ) {\nint temp = ∗a ;\n∗a = ∗b ;\n∗b = temp ;\n}\n\nPointer arrays\n- Pointer array - array of pointers\nint ∗arr [20]; - an array of pointers to int's\nchar ∗arr[10]; - an array of pointers to char's\n- Pointers in array can point to arrays themselves\nchar ∗strs [10]; - an array of char arrays (or strings)\n\nPointer array example\n- Have an array int arr [100]; that contains some numbers\n- Want to have a sorted version of the array, but not modify\narr\n- Can declare a pointer array int ∗ sorted_array[100]; containing\npointers to elements of arr and sort the pointers instead\nof the numbers themselves\n- Good approach for sorting arrays whose elements are very\nlarge (like strings)\n\nPointer array example\nInsertion sort:\n/ ∗ move previous elements down u n t i l\ni n s e r t i o n point reached ∗ /\nvoid shift _element ( unsigned int i ) {\nint ∗ pvalue ;\n/ ∗ guard against going outside array ∗ /\nfor ( pvalue = sorted_array [ i ] ; i &&\n∗ sorted_array [ i -1] > ∗ pvalue ; i --) {\n/ ∗ move pointer down ∗ /\nsorted_array [ i ] = sorted_array [ i -1];\n}\nsorted_array [ i ] = pvalue ; / ∗ i n s e r t pointer ∗ /\n}\n\nPointer array example\nInsertion sort (continued):\n/ ∗ i t e r a t e u n t i l out-of-order element found ;\ns h i f t the element , and continue i t e r a t i n g ∗ /\nvoid i n s e r t i o n _ s o r t ( void )\n{\nunsigned i n t i , len = array_length ( arr ) ;\nfor ( i = 1; i < len ; i ++)\ni f (∗ sorted_array [ i ] < ∗ sorted_array [ i -1])\nshift _element ( i ) ;\n}\n\nString arrays\n- An array of strings, each stored as a pointer to an array of\nchars\n- Each string may be of different length\nchar str1 [ ] = \"hello\" ;\n/ ∗ length = 6 ∗ /\nchar str2 [ ] = \"goodbye\" ;\n/ ∗ length = 8 ∗ /\nchar str3 [ ] = \"ciao\" ;\n/ ∗ length = 5 ∗ /\nchar\nstrArray [ ] = { str1 , str2 , str3 } ;\n∗\n- Note that strArray contains only pointers, not the characters\nthemselves!\n\nMultidimensional arrays\n- C also permits multidimensional arrays specified using [ ]\nbrackets notation:\nint world [20][30]; is a 20x30 2-D array of int's\n- Higher dimensions possible:\nchar bigcharmatrix [15][7][35][4]; - what are the dimensions of\nthis?\n- Multidimensional arrays are rectangular; pointer arrays can\nbe arbitrary shaped\n\n6.087 Lecture 7 - January 20, 2010\nReview\nMore about Pointers\nPointers to Pointers\nPointer Arrays\nMultidimensional Arrays\nData Structures\nStacks\nQueues\nApplication: Calculator\n\nMore data structures\nLast time: linked lists\n-\n- Today: stack, queue\n- Can be implemented using linked list or array storage\n\nThe stack\n- Special type of list - last element in (push) is first out (pop)\nRead and write from same end of list\n-\n- The stack (where local variables are stored) is\nimplemented as a *gasp* stack\n\nStack as array\n- Store as array buffer (static allocation or dynamic\nallocation):\nint stack_buffer[100];\n- Elements added and removed from end of array; need to\ntrack end:\nint itop = 0; /∗ end at zero => initialized for empty stack ∗/\n\nStack as array\n- Add element using void push(int);\nvoid push ( int elem ) {\nstack _buffer [ i t o p ++] = elem ;\n}\n- Remove element using int pop(void);\nint pop ( void )\n{\ni f ( i t o p > 0)\nreturn stack _buffer[-- i t o p ] ;\nelse\nreturn 0; / ∗ or other special value ∗ /\n}\n- Some implementations provide int top(void); to read last\n(top) element without removing it\n\nStack as linked list\n- Store as linked list (dynamic allocation):\nstruct s_listnode {\nint element ;\nstruct s_listnode\npnext ;\n∗\n} ;\nstruct s_listnode ∗ stack_buffer = NULL; - start empty\n- \"Top\" is now at front of linked list (no need to track)\n\nStack as linked list\n- Add element using void push(int);\nvoid push ( int elem ) {\nstruct s_listnode ∗new_node = / ∗ a llo c a t e new node ∗ /\n( struct s_listnode ∗ ) malloc ( sizeof ( struct s_listnode ) )\nnew_node->pnext = stack _buffer ;\nnew_node->element = elem ;\nstack _buffer = new_node ;\n}\n- Adding an element pushes back the rest of the stack\n\nStack as linked list\n- Remove element using int pop(void);\nint pop ( void )\n{\ni f ( stack _buffer ) {\nstruct s_listnode ∗pelem = stack _buffer ;\nint elem = stack_buffer ->element ;\nstack _buffer = pelem->pnext ;\nfree ( pelem ) ; / ∗ remove node from memory ∗ /\nreturn elem ;\n} else\nreturn 0; / ∗ or other special value ∗ /\n}\n- Some implementations provide int top(void); to read last\n(top) element without removing it\n\nThe queue\n- Opposite of stack - first in (enqueue), first out (dequeue)\n- Read and write from opposite ends of list\n- Important for UIs (event/message queues), networking (Tx,\nRx packet queues)\n- Imposes an ordering on elements\n\nQueue as array\n- Again, store as array buffer (static or dynamic allocation);\nfloat queue_buffer[100];\n- Elements added to end (rear), removed from beginning\n(front)\n- Need to keep track of front and rear:\nint ifront = 0, irear = 0;\n- Alternatively, we can track the front and number of\nelements:\nint ifront = 0, icount = 0;\n- We'll use the second way (reason apparent later)\n\nQueue as array\n- Add element using void enqueue(float);\nvoid enqueue ( float elem ) {\ni f ( icount < 100) {\nqueue_buffer [ i f r o n t +icount ] = elem ;\nicount ++;\n}\n}\n- Remove element using float dequeue(void);\nfloat dequeue ( void )\n{\ni f ( icount > 0) {\nicount --;\nreturn queue_buffer [ i f r o n t ++];\n} else\nreturn 0 . ; / ∗ or other special value ∗ /\n}\n\nQueue as array\nThis would make for a very poor queue! Observe a queue\n-\nof capacity 4:\na\nc\nb\nfront\nrear\nEnqueue 'd' to the rear of the queue:\n-\na\nc\nb\nd\nfront\nrear\nThe queue is now full.\n\nQueue as array\nDequeue 'a':\n-\nc\nb\nd\nfront\nrear\nEnqueue 'e' to the rear: where should it go?\n-\nSolution: use a circular (or \"ring\") buffer\n-\n'e' would go in the beginning of the array\n-\n\nQueue as array\n- Need to modify void enqueue(float); and float dequeue(void);\n- New void enqueue(float);:\nvoid enqueue ( float elem ) {\ni f ( icount < 100) {\nqueue_buffer [ ( i f r o n t +icount ) % 100] = elem ;\nicount ++;\n}\n}\n\nQueue as array\n- New float dequeue(void);:\nfloat dequeue ( void )\n{\ni f ( icount > 0) {\nfloat elem = queue_buffer [ i f r o n t ] ;\nicount --;\ni f r o n t ++;\ni f ( i f r o n t == 100)\ni f r o n t = 0;\nreturn elem ;\n} else\nreturn 0 . ; / ∗ or other special value ∗ /\n}\n- Why would using \"front\" and \"rear\" counters instead make\nthis harder?\n\nQueue as linked list\n- Store as linked list (dynamic allocation):\nstruct s_listnode {\nfloat element ;\nstruct s_listnode\npnext ;\n∗\n} ;\nstruct s_listnode ∗queue_buffer = NULL; - start empty\n- Let front be at beginning - no need to track front\nRear is at end - we should track it:\n-\nstruct s_listnode ∗prear = NULL;\n\nQueue as linked list\n- Add element using void enqueue(float);\nvoid enqueue ( float elem ) {\nstruct s_listnode ∗new_node = / ∗ al lo ca t e new node ∗ /\n( struct s_listnode ∗ ) malloc ( sizeof ( struct s_listnode ) )\nnew_node->element = elem ;\nnew_node->pnext = NULL; / ∗ at rear ∗ /\ni f ( prear )\nprear ->pnext = new_node ;\nelse / ∗ empty ∗ /\nqueue_buffer = new_node ;\nprear = new_node ;\n}\n- Adding an element doesn't affect the front if the queue is\nnot empty\n\nQueue as linked list\n- Remove element using float dequeue(void);\nfloat dequeue ( void )\n{\ni f ( queue_buffer ) {\nstruct s_listnode ∗pelem = queue_buffer ;\nfloat elem = queue_buffer ->element ;\nqueue_buffer = pelem->pnext ;\ni f ( pelem == prear ) / ∗ at end ∗ /\nprear = NULL;\nfree ( pelem ) ; / ∗ remove node from memory ∗ /\nreturn elem ;\n} else\nreturn 0 . ; / ∗ or other special value ∗ /\n}\n- Removing element doesn't affect rear unless resulting\nqueue is empty\n\nA simple calculator\n- Stacks and queues allow us to design a simple expression\nevaluator\n- Prefix, infix, postfix notation: operator before, between, and\nafter operands, respectively\nInfix\nA + B\nA * B - C\n( A + B ) * ( C - D)\nPrefix\n+ A B\n- * A B C\n* + A B - C D\nPostfix\nA B +\nA B * C\nA B + C D - *\n- Infix more natural to write, postfix easier to evaluate\n\nInfix to postfix\n- \"Shunting yard algorithm\" - Dijkstra (1961): input and\noutput in queues, separate stack for holding operators\n- Simplest version (operands and binary operators only):\n1. dequeue token from input\n2. if operand (number), add to output queue\n3. if operator, then pop operators off stack and add to output\nqueue as long as\n- top operator on stack has higher precedence, or\n- top operator on stack has same precedence and is\nleft-associative\nand push new operator onto stack\n4. return to step 1 as long as tokens remain in input\n5. pop remaining operators from stack and add to output\nqueue\n\nInfix to postfix example\n- Infix expression: A + B * C - D\nToken\nA\n+\nB\n*\nC\n-\nD\n(end)\nOutput queue\nA\nA\nA B\nA B\nA B C\nA B C * +\nA B C * + D\nA B C * + D -\nOperator stack\n+\n+\n+ *\n+ *\n-\n-\n- Postfix expression: A B C * + D\n- What if expression includes parentheses?\n\nExample with parentheses\n- Infix expression: ( A + B ) * ( C - D )\nToken\n(\nA\n+\nB\n)\n*\n(\nC\n-\nD\n)\n(end)\nOutput queue\nA\nA\nA B\nA B +\nA B +\nA B +\nA B + C\nA B + C\nA B + C D\nA B + C D\nA B + C D - *\nOperator stack\n(\n(\n( +\n( +\n*\n* (\n* (\n* (\n* (\n*\n- Postfix expression: A B + C D - *\n\nEvaluating postfix\n- Postfix evaluation very easy with a stack:\n1. dequeue a token from the postfix queue\n2. if token is an operand, push onto stack\n3. if token is an operator, pop operands off stack (2 for binary\noperator); push result onto stack\n4. repeat until queue is empty\n5. item remaining in stack is final result\n\nPostfix evaluation example\n- Postfix expression: 3 4 + 5 1 - *\nToken\n3 4\n+\n7 5\n7 5 1\n-\n*\n(end)\nanswer = 28\nStack\n7 4\n- Extends to expressions with functions, unary operators\n- Performs evaluation in one pass, unlike with prefix notation\n\nSummary\nTopics covered:\n- Pointers to pointers\n- pointer and string arrays\n- multidimensional arrays\nData structures\n-\n- stack and queue\n- implemented as arrays and linked lists\n- writing a calculator\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 8",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/02aef29b821a0258e53ba95a648207f9_MIT6_087IAP10_lec08.pdf",
      "content": "6.087 Lecture 8 - January 21, 2010\nReview\nPointers\nVoid pointers\nFunction pointers\nHash table\n\nReview:Pointers\n- pointers: int x; int∗ p=&x;\n- pointers to pointer: int x; int∗ p=&x;int∗∗ pp=&p;\n- Array of pointers: char∗ names[]={\"abba\",\"u2\"};\n- Multidimensional arrays: int x [20][20];\n\nReview: Stacks\nLIFO: last in first out data structure.\n-\nitems are inserted and removed from the same end.\n-\n- operations: push(),pop(),top()\n- can be implemented using arrays, linked list\n\nReview: Queues\nFIFO: first in first out\n-\nitems are inserted at the rear and removed from the front.\n-\n- operations: queue(),dequeue()\n- can be implemented using arrays, linked list\n\nReview: Expressions\n- Infix: (A+B)*(C-D)\n- prefix: *+AB-CD\n- postfix: AB+CD-*\n\n6.087 Lecture 8 - January 21, 2010\nReview\nPointers\nVoid pointers\nFunction pointers\nHash table\n\nVoid pointers\nC does not allow us to declare and use void variables.\n-\n- void can be used only as return type or parameter of a\nfunction.\n- C allows void pointers\n- Question: What are some scenarios where you want to\npass void pointers?\n- void pointers can be used to point to any data type\n- int x; void∗ p=&x; /∗points to int ∗/\n- float f ;void∗ p=&f; /∗points to float ∗/\n- void pointers cannot be dereferenced. The pointers should\nalways be cast before dereferencing.\nvoid∗ p; printf (\"%d\",∗p); /∗ invalid ∗/\nvoid∗ p; int ∗px=(int∗)p; printf (\"%d\",∗px); /∗valid ∗/\n\nFunction pointers\n- In some programming languages, functions are first class\nvariables (can be passed to functions, returned from\nfunctions etc.).\n- In C, function itself is not a variable. But it is possible to\ndeclare pointer to functions.\n- Question: What are some scenarios where you want to\npass pointers to functions?\n- Declaration examples:\n- int (∗fp )( int ) /∗notice the () ∗/\n- int (∗fp )(void∗,void∗)\n- Function pointers can be assigned, pass to and from\nfunctions, placed in arrays etc.\n\nCallbacks\nDefinition: Callback is a piece of executable code passed to\nfunctions. In C, callbacks are implemented by passing function\npointers.\nExample:\nvoid qsort(void∗ arr, int num,int size,int (∗fp )(void∗ pa,void∗pb))\n- qsort() function from the standard library can be sort an\narray of any datatype.\n- Question: How does it do that? callbacks.\n- qsort() calls a function whenever a comparison needs to\nbe done.\n- The function takes two arguments and returns (<0,0,>0)\ndepending on the relative order of the two items.\n\nCallback (cont.)\nint arr [] ={10 ,9 ,8 ,1 ,2 ,3 ,5};\n/ ∗ callback ∗ /\nint asc ( void∗ pa , void∗ pb )\n{\nreturn (∗ ( int ∗ ) pa -∗ ( int ∗ ) pb ) ;\n}\n/ ∗ callback ∗ /\nint desc ( void∗ pa , void∗ pb )\n{\nreturn (∗ ( int ∗ ) pb -∗ ( int ∗ ) pa ) ;\n}\n/ ∗ sort in ascending order ∗ /\nqsort ( arr , sizeof ( arr ) / sizeof ( int ) , sizeof ( int ) , asc ) ;\n/ ∗ sort in descending order ∗ /\nqsort ( arr , sizeof ( arr ) / sizeof ( int ) , sizeof ( int ) , desc ) ;\n\nCallback (cont.)\nConsider a linked list with nodes defined as follows:\nstruct node {\nint data ;\nstruct node∗ next ;\n} ;\nAlso consider the function 'apply' defined as follows:\nvoid apply ( struct node∗ phead ,\nvoid (∗ fp ) ( void ∗ , void∗ ) ,\nvoid∗ arg ) / ∗ only fp has to be named ∗ /\n{\nstruct node∗ p=phead ;\nwhile ( p !=NULL)\n{\nfp (p , arg ) ; / ∗ can also use (∗ fp ) ( p , arg ) ∗ /\np=p->next ;\n}\n}\n\nCallback (cont.)\nIterating:\nstruct node∗ phead ;\n/ ∗ populate somewhere ∗ /\nvoid p r i n t ( void∗ p , void∗ arg )\n{\nstruct node∗ np =( struct node ∗ )p ;\np r i n t f ( \"%d \" ,np->data ) ;\n}\napply ( phead , p r in t ,NULL ) ;\n\nCallback (cont.)\nCounting nodes:\nvoid dot ot al ( void∗ p , void∗ arg )\n{\nstruct node∗ np=( struct node ∗ )p ;\nint ∗ p t o t a l\n=( int ∗ ) arg ;\n∗ p t o t a l += np->data ;\n}\nint t o t a l =0;\napply ( phead , dototal ,& t o t a l ) ;\n\nArray of function pointers\nExample:Consider the case where different functions are called\nbased on a value.\nenum TYPE{SQUARE,RECT, CIRCILE ,POLYGON} ;\nstruct shape {\nfloat params [MAX] ;\nenum TYPE type ;\n} ;\nvoid draw ( struct shape∗ ps )\n{\nswitch ( ps->type )\n{\ncase SQUARE:\ndraw_square ( ps ) ; break ;\ncase RECT:\ndraw_rect ( ps ) ; break ;\n. . .\n}\n}\n\nArray of function pointers\nThe same can be done using an array of function pointers\ninstead.\nvoid (∗ fp [ 4 ] ) ( struct shape∗ ps)=\n{&draw_square ,& draw_rec ,& draw_circle ,& draw_poly } ;\ntypedef void (∗ fp ) ( struct shape∗ ps ) drawfn ;\ndrawfn fp [4] =\n{&draw_square ,& draw_rec ,& draw_circle ,& draw_poly } ;\nvoid draw ( struct shape∗ ps )\n{\n(∗ fp [ ps->type ] ) ( ps ) ; / ∗ c a l l the correct function ∗ /\n}\n\n6.087 Lecture 8 - January 21, 2010\nReview\nPointers\nVoid pointers\nFunction pointers\nHash table\n\nHash table\nHash tables (hashmaps) combine linked list and arrays to\nprovide an efficient data structure for storing dynamic data.\nHash tables are commonly implemented as an array of linked\nlists (hash tables with chaining).\nkeys\nJohn Smith\nLisa Smith\nSam Doe\nSandra Dee\nTed Baker\nbuckets\n:\n:\n:\n:\nentries\nLisa Smith\n521-8976\nJohn Smith\n521-1234\nSandra Dee\n521-9655\nTed Baker\n418-4165\nSam Doe\n521-5030\nFigure: Example of a hash table with chaining (source: wikipedia)\n\nHash table\n- Each data item is associated with a key that determines its\nlocation.\n- Hash functions are used to generate an evenly distributed\nhash value.\nA hash collision is said to occur when two items have the\n-\nsame hash value.\n- Items with the same hash keys are chained\n- Retrieving an item is O(1) operation.\n\nHash tables\nHash functions:\n- A hash function maps its input into a finite range: hash\nvalue, hash code.\n- The hash value should ideally have uniform distribution.\nwhy?\n- Other uses of hash functions: cryptography, caches\n(computers/internet), bloom filters etc.\n- Hash function types:\n- Division type\n- Multiplication type\n- Other ways to avoid collision: linear probing, double\nhashing.\n\nHash table: example\n#define MAX_BUCKETS 1000\n#define MULTIPLIER 31\nstruct wordrec\n{\nchar∗ word ;\nunsigned long count ;\nstruct wordrec∗ next ;\n} ;\n/ ∗ hash bucket ∗ /\nstruct wordrec ∗ table [MAX_LEN ] ;\n\nHash table: example\nunsigned long hashstring ( const char∗ s t r )\n{\nunsigned long hash =0;\nwhile (∗ s t r )\n{\nhash= hash∗MULTIPLIER+∗ s t r ;\ns t r ++;\n}\nreturn hash%MAX_BUCKETS;\n}\n\nHash table: example\nstruct wordrec ∗\nlookup ( const char∗ str , int create )\n{\nstruct wordrec∗ curr =NULL;\nunsigned long hash= hashstring ( s t r ) ;\nstruct wordrec∗ wp= table [ hash ] ;\nfor ( curr =wp; curr !=NULL ; curr =curr ->next )\n/ ∗ search ∗ / ;\nnotfound :\ni f ( create )\n/ ∗ add to f r o n t ∗ /\nreturn curr ;\n}\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 9",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/4b9152a12a01274abfaf5a3c2686564b_MIT6_087IAP10_lec09.pdf",
      "content": "6.087 Lecture 9 - January 22, 2010\nReview\nUsing External Libraries\nSymbols and Linkage\nStatic vs. Dynamic Linkage\nLinking External Libraries\nSymbol Resolution Issues\nCreating Libraries\nData Structures\nB-trees\nPriority Queues\n\nReview: Void pointers\n- Void pointer - points to any data type:\nint x; void ∗ px = &x; /∗ implicit cast to (void ∗) ∗/\nfloat f ; void ∗ pf = &f;\n- Cannot be dereferenced directly; void pointers must be\ncast prior to dereferencing:\np r i n t f ( \"%d %f\\n\" , ∗ ( int ∗ ) px , ∗ ( float ∗ ) pf ) ;\n\nReview: Function pointers\n- Functions not variables, but also reside in memory (i.e.\nhave an address) - we can take a pointer to a function\n- Function pointer declaration:\nint (∗cmp)(void ∗, void ∗);\n- Can be treated like any other pointer\n- No need to use & operator (but you can)\n- Similarly, no need to use * operator (but you can)\n\nReview: Function pointers\nint strcmp_wrapper ( void\npa , void\npb ) {\n∗\n∗\nreturn strcmp ( ( const char ∗ )pa , ( const char ∗)pb ) ;\n}\n- Can assign to a function pointer:\nint (∗fp )(void ∗, void ∗) = strcmp_wrapper; or\nint (∗fp )(void ∗, void ∗) = &strcmp_wrapper;\n- Can call from function pointer: (str1 and str2 are\nstrings)\nint ret = fp(str1 , str2 ); or\nint ret = (∗fp )( str1 , str2 );\n\nReview: Hash tables\n- Hash table (or hash map): array of linked lists for storing\nand accessing data efficiently\n- Each element associated with a key (can be an integer,\nstring, or other type)\n- Hash function computes hash value from key (and table\nsize); hash value represents index into array\n- Multiple elements can have same hash value - results in\ncollision; elements are chained in linked list\n\n6.087 Lecture 9 - January 22, 2010\nReview\nUsing External Libraries\nSymbols and Linkage\nStatic vs. Dynamic Linkage\nLinking External Libraries\nSymbol Resolution Issues\nCreating Libraries\nData Structures\nB-trees\nPriority Queues\n\nSymbols and libraries\n- External libraries provide a wealth of functionality -\nexample: C standard library\n- Programs access libraries' functions and variables via\nidentifiers known as symbols\n- Header file declarations/prototypes mapped to symbols at\ncompile time\n- Symbols linked to definitions in external libraries during\nlinking\n- Our own program produces symbols, too\n\nFunctions and variables as symbols\n- Consider the simple hello world program written below:\n#include < stdio . h>\nconst char msg [ ] = \"Hello, world.\" ;\nint main ( void )\n{\nputs (msg ) ;\nreturn 0;\n}\n- What variables and functions are declared globally?\n\nFunctions and variables as symbols\n- Consider the simple hello world program written below:\n#include < stdio . h>\nconst char msg [ ] = \"Hello, world.\" ;\nint main ( void )\n{\nputs (msg ) ;\nreturn 0;\n}\n- What variables and functions are declared globally?\nmsg, main(), puts(), others in stdio.h\n\nFunctions and variables as symbols\n- Let's compile, but not link, the file hello.c to create hello.o:\nathena% gcc -Wall -c hello.c -o hello.o\n- -c: compile, but do not link hello.c; result will compile the\ncode into machine instructions but not make the program\nexecutable\n- addresses for lines of code and static and global variables\nnot yet assigned\n- need to perform link step on hello.o (using gcc or ld) to\nassign memory to each symbol\n- linking resolves symbols defined elsewhere (like the C\nstandard library) and makes the code executable\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nFunctions and variables as symbols\n- Let's look at the symbols in the compiled file hello.o:\nathena% nm hello.o\n- Output:\n0000000000000000 T main\n0000000000000000 R msg\nU puts\n- 'T' - (text) code; 'R' - read-only memory; 'U' - undefined\nsymbol\n- Addresses all zero before linking; symbols not allocated\nmemory yet\n- Undefined symbols are defined externally, resolved during\nlinking\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it..\n\nFunctions and variables as symbols\n- Why aren't symbols listed for other declarations in\nstdio.h?\n- Compiler doesn't bother creating symbols for unused\nfunction prototypes (saves space)\n- What happens when we link?\nathena% gcc -Wall hello.o -o hello\n- Memory allocated for defined symbols\n- Undefined symbols located in external libraries (like libc\nfor C standard library)\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nFunctions and variables as symbols\n- Let's look at the symbols now:\nathena% nm hello\n- Output:\n(other default symbols)\n. . .\n0000000000400524 T main\n000000000040062c R msg\nU puts@@GLIBC_2.2.5\n- Addresses for static (allocated at compile time) symbols\n- Symbol puts located in shared library GLIBC_2.2.5 (GNU\nC standard library)\n- Shared symbol puts not assigned memory until run time\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nStatic and dynamic linkage\n- Functions, global variables must be allocated memory\nbefore use\n- Can allocate at compile time (static) or at run time (shared)\n- Advantages/disadvantages to both\n- Symbols in same file, other .o files, or static libraries\n(archives, .a files) - static linkage\n- Symbols in shared libraries (.so files) - dynamic linkage\n- gcc links against shared libraries by default, can force\nstatic linkage using -static flag\n\nStatic linkage\n- What happens if we statically link against the library?\nathena% gcc -Wall -static hello.o -o hello\n- Our executable now contains the symbol puts:\n. . .\n00000000004014c0 W puts\n. . .\n0000000000400304 T main\n. . .\n000000000046cd04 R msg\n. . .\n- 'W': linked to another defined symbol\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nStatic linkage\n- At link time, statically linked symbols added to executable\n- Results in much larger executable file (static - 688K,\ndynamic - 10K)\n- Resulting executable does not depend on locating external\nlibrary files at run time\n- To use newer version of library, have to recompile\n\nDynamic linkage\n- Dynamic linkage occurs at run-time\n- During compile, linker just looks for symbol in external\nshared libraries\n- Shared library symbols loaded as part of program startup\n(before main())\n- Requires external library to define symbol exactly as\nexpected from header file declaration\n- changing function in shared library can break your program\n- version information used to minimize this problem\n- reason why common libraries like libc rarely modify or\nremove functions, even broken ones like gets()\n\nLinking external libraries\n- Programs linked against C standard library by default\n- To link against library libnamespec.so or\nlibnamespec.a, use compiler flag -lnamespec to link\nagainst library\n- Library must be in library path (standard library directories\n+ directories specified using -L directory compiler flag\n- Use -static for force static linkage\n- This is enough for static linkage; library code will be added\nto resulting executable\n\nLoading shared libraries\n- Shared library located during compile-time linkage, but\nneeds to be located again during run-time loading\n- Shared libraries located at run-time using linker library\nld.so\n- Whenever shared libraries on system change, need to run\nldconfig to update links seen by ld.so\n- During loading, symbols in dynamic library are allocated\nmemory and loaded from shared library file\n\nLoading shared libraries on demand\n- In Linux, can load symbols from shared libraries on\ndemand using functions in dlfcn.h\n- Open a shared library for loading:\nvoid ∗ dlopen(const char ∗file, int mode);\nvalues for mode: combination of RTLD_LAZY (lazy loading\nof library), RTLD_NOW (load now), RTLD_GLOBAL (make\nsymbols in library available to other libraries yet to be\nloaded), RTLD_LOCAL (symbols loaded are accessible\nonly to your code)\n\nLoading shared libraries on demand\n- Get the address of a symbol loaded from the library:\nvoid ∗ dlsym(void ∗ handle, const char ∗ symbol_name);\nhandle from call to dlopen; returned address is pointer to\nvariable or function identified by symbol_name\n- Need to close shared library file handle after done with\nsymbols in library:\nint dlclose(void ∗ handle);\n- These functions are not part of C standard library; need to\nlink against library libdl: -ldl compiler flag\n\nSymbol resolution issues\n- Symbols can be defined in multiple places\n- Suppose we define our own puts() function\n- But, puts() defined in C standard library\n- When we call puts(), which one gets used?\n\nSymbol resolution issues\n- Symbols can be defined in multiple places\n- Suppose we define our own puts() function\n- But, puts() defined in C standard library\n- When we call puts(), which one gets used?\n- Our puts() gets used since ours is static, and puts() in\nC standard library not resolved until run-time\n- If statically linked against C standard library, linker finds\ntwo puts() definitions and aborts (multiple definitions not\nallowed)\n\nSymbol resolution issues\n- How about if we define puts() in a shared library and\nattempt to use it within our programs?\n- Symbols resolved in order they are loaded\n- Suppose our library containing puts() is libhello.so,\nlocated in a standard library directory (like /usr/lib),\nand we compile our hello.c code against this library:\nathena% gcc -g -Wall hello.c -lhello -o\nhello.o\n- Libraries specified using -l flag are loaded in order\nspecified, and before C standard library\n- Which puts() gets used here?\nathena% gcc -g -Wall hello.c -lc -lhello -o\nhello.o\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\n6.087 Lecture 9 - January 22, 2010\nReview\nUsing External Libraries\nSymbols and Linkage\nStatic vs. Dynamic Linkage\nLinking External Libraries\nSymbol Resolution Issues\nCreating Libraries\nData Structures\nB-trees\nPriority Queues\n\nCreating libraries\n- Libraries contain C code like any other program\n- Static or shared libraries compiled from (un-linked) object\nfiles created using gcc\n- Compiling a static library:\n- compile, but do not link source files:\nathena% gcc -g -Wall -c infile.c -o\noutfile.o\n- collect compiled (unlinked) files into an archive:\nathena% ar -rcs libname.a outfile1.o\noutfile2.o ...\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\nCreating shared libraries\n- Compile and do not link files using gcc:\nathena% gcc -g -Wall -fPIC -c infile.c -o\noutfile.o\n- -fPIC option: create position-independent code, since\ncode will be repositioned during loading\n- Link files using ld to create a shared object (.so) file:\nathena% ld -shared -soname libname.so -o\nlibname.so.version -lc outfile1.o\noutfile2.o ...\n- If necessary, add directory to LD_LIBRARY_PATH\nenvironment variable, so ld.so can find file when loading\nat run-time\n- Configure ld.so for new (or changed) library:\nathena% ldconfig -v\nAthena is MIT's UNIX-based computing environment. OCW does not provide access to it.\n\n6.087 Lecture 9 - January 22, 2010\nReview\nUsing External Libraries\nSymbols and Linkage\nStatic vs. Dynamic Linkage\nLinking External Libraries\nSymbol Resolution Issues\nCreating Libraries\nData Structures\nB-trees\nPriority Queues\n\nData structures\n- Many data structures designed to support certain\nalgorithms\n- B-tree - generalized binary search tree, used for databases\nand file systems\n- Priority queue - ordering data by \"priority,\" used for sorting,\nevent simulation, and many other algorithms\n\nB-tree structure\n- Binary search tree with variable number of children (at\nleast t, up to 2t)\nTree is balanced - all leaves at same level\n-\n- Node contains list of \"keys\" - divide range of elements in\nchildren\n[Cormen, Leiserson, Rivest, and Stein. Introduction to Algorithms, 2nd ed.\nMIT Press, 2001.]\nCourtesy of MIT Press. Used with permission.\n\nInitializing a B-tree\n- Initially, B-tree contains root node with no children (leaf\nnode), no keys\n- Note: root node exempt from minimum children\nrequirement\n\nInserting elements\n- Insertion complicated due to maximum number of keys\n- At high level:\n1. traverse tree down to leaf node\n2. if leaf already full, split into two leaves:\n(a) move median key element into parent (splitting parent\nalready full)\n(b) split remaining keys into two leaves (one with lower, one with\nhigher elements)\n3. add element to sorted list of keys\n- Can accomplish in one pass, splitting full parent nodes\nduring traversal in step 1\n\nInserting elements\nB-tree with t = 3 (nodes may have 2-5 keys):\n[Cormen, Leiserson, Rivest, and Stein. Introduction to Algorithms, 2nd ed.\nMIT Press, 2001.]\nCourtesy of MIT Press. Used with permission.\n\nInserting elements\nMore insertion examples:\n[Cormen, Leiserson, Rivest, and Stein. Introduction to Algorithms, 2nd ed.\nMIT Press, 2001.]\nCourtesy of MIT Press. Used with permission.\n\nSearching a B-tree\n- Search like searching a binary search tree:\n1. start at root.\n2. if node empty, element not in tree\n3. search list of keys for element (using linear or binary\nsearch)\n4. if element in list, return element\n5. otherwise, element between keys, and repeat search on\nchild node for that range\n- Tree is balanced - search takes O(log n) time\n\nDeletion\n- Deletion complicated by minimum children restriction\n- When traversing tree to find element, need to ensure child\nnodes to be traversed have enough keys\n- if adjacent child node has at least t keys, move separating\nkey from parent to child and closest key in adjacent child to\nparent\n- if no adjacent child nodes have extra keys, merge child\nnode with adjacent child\n- When removing a key from a node with children, need to\nrearrange keys again\n- if child before or after removed key has enough keys, move\nclosest key from child to parent\n- if neither child has enough keys, merge both children\n- if child not a leaf, have to repeat this process\n\nDeletion examples\n[Cormen, Leiserson, Rivest, and Stein. Introduction to Algorithms, 2nd ed.\nMIT Press, 2001.]\nCourtesy of MIT Press. Used with permission.\n\nDeletion examples\n[Cormen, Leiserson, Rivest, and Stein. Introduction to Algorithms, 2nd ed.\nMIT Press, 2001.]\nCourtesy of MIT Press. Used with permission.\n\nDeletion examples\n[Cormen, Leiserson, Rivest, and Stein. Introduction to Algorithms, 2nd ed.\nMIT Press, 2001.]\nCourtesy of MIT Press. Used with permission.\n\nPriority queue\n- Abstract data structure ordering elements by priority\n- Elements enqueued with priority, dequeued in order of\nhighest priority\n- Common implementations: heap or binary search tree\n- Operations: insertion, peek/extract max-priority element,\nincrease element priority\n\nHeaps\n- Heap - tree with heap-ordering property: priority(child) ≤\npriority(parent)\n- More sophisticated heaps exist - e.g. binomial heap,\nFibonacci heap\n- We'll focus on simple binary heaps\n- Usually implemented as an array with top element at\nbeginning\n- Can sort data using a heap - O(n log n) worst case\nin-place sort!\n\nExtracting data\nHeap-ordering property\nmaximum priority element at\n-\n⇒\ntop of heap\n- Can peek by looking at top element\n- Can remove top element, move last element to top, and\nswap top element down with its children until it satisfies\nheap-ordering property:\n1. start at top\n2. find largest of element and left and right child; if element is\nlargest, we are done\n3. otherwise, swap element with largest child and repeat with\nelement in new position\n\nInserting data/increasing priority\n- Insert element at end of heap, set to lowest priority -inf\n- Increase priority of element to real priority:\n1. start at element\n2. if new priority less than parent's, we are done\n3. otherwise, swap element with parent and repeat\n\nExample of inserting data\n[Cormen, Leiserson, Rivest, and Stein. Introduction to Algorithms, 2nd ed.\nMIT Press, 2001.]\nCourtesy of MIT Press. Used with permission.\n\nSummary\nTopics covered:\n- Using external libraries\n- symbols and linkage\n- static vs. dynamic linkage\n- linking to your code\n- symbol clashing\n- Creating libraries\nData structures\n-\nB-tree\n-\n- priority queue\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 10",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/2d7ce9e81c1ce03c8c93a12c9d21d0dd_MIT6_087IAP10_lec10.pdf",
      "content": "Outline\nReview\nStandard Library\n<stdio.h>\n<ctype.h>\n<stdlib.h>\n<assert.h>\n<stdarg.h>\n<time.h>\n\n6.087 Lecture 10 - January 25, 2010\nReview\nStandard Library\n<stdio.h>\n<ctype.h>\n<stdlib.h>\n<assert.h>\n<stdarg.h>\n<time.h>\n\nReview: Libraries\n- linking: binds symbols to addresses.\n- static linkage: occurs at compile time (static libraries).\n- dynamic linkage: occurs at run time (shared libraries).\nshared libraries:\n-\nld.so - locates shared libraries\n-\n- ldconfig - updates links seen by ld.so\n- dlopen(),dlsym(),dlclose() - load shared libraries\non demand.\n- compiling static libraries: gcc,ar\n- compiling shared libraries: gcc,ldconfig\n\nReview: BTree\n- generalized search tree-multiple children.\n- except for root, each node can have between t and 2t\nchildren.\n- tree is always balanced.\n- Used in file systems, databases etc.\n\nReview: Priority Queue\n- abstract data structure: many implementations\n- common implementations: heaps,bst,linked list\n- elements are queued and dequeued in order of priority.\n- operations:\npeek(),insert(),extract-max()/extract-min()\n\n6.087 Lecture 10 - January 25, 2010\nReview\nStandard Library\n<stdio.h>\n<ctype.h>\n<stdlib.h>\n<assert.h>\n<stdarg.h>\n<time.h>\n\n<stdio.h>: Opening, closing files\nFILE∗ fopen(const char∗ filename,const char∗ mode)\nmode can be \"r\"(read),\"w\"(write),\"a\"(append).\n-\n\"b\" can be appended for binary input/output (unnecessary\n-\nin *nx)\nreturns NULL on error.\n-\nFILE∗ freopen(const char∗ filename,const char∗ mode,FILE∗ stream)\n- redirects the stream to the file.\n- returns NULL on error.\n- Where can this be used? (redirecting stdin,stdout,stderr)\nint fflush (FILE∗ stream)\nflushes any unwritten data.\n-\nif stream is NULL flushes all outputs streams.\n-\nreturns EOF on error.\n-\n\n<stdio.h>: File operations\nint remove(const char∗ filename)\nremoves the file from the file system.\n-\nretrn non-zero on error.\n-\nint rename(const char∗ oldname,const char∗ newname)\nrenames file\n-\nreturns non-zero on error (reasons?: permission,\n-\nexistence)\n\n<stdio.h>:Temporary files\nFILE∗ tmpfile(void)\ncreates a temporary file with mode \"wb+\".\n-\nthe file is removed automatically when program\n-\nterminates.\nchar∗ tmpnam(char s[L_tmpnam])\ncreates a string that is not the name of an existing file.\n-\nreturn reference to internal static array if s is NULL.\n-\nPopulate s otherwise.\ngenerates a new name every call.\n-\n\n<stdio.h>: Raw I/O\nsize_t fread(void∗ ptr,size_t size,size_t nobj,FILE∗ stream)\nreads at most nobj items of size size from stream into\n-\nptr.\nreturns the number of items read.\n-\nfeof and ferror must be used to test end of file.\n-\nsize_t fwrite (const void∗ ptr,size_t size,size_t nobj,FILE∗ stream)\nwrite at most nobj items of size size from ptr onto\n-\nstream.\nreturns number of objects written.\n-\n\n<stdio.h>: File position\nint fseek(FILE∗ stream, long offset,int origin )\nsets file position in the stream. Subsequent read/write\n-\nbegins at this location\norigin can be SEEK_SET, SEEK_CUR, SEEK_END.\n-\nreturns non-zero on error.\n-\nlong ftell (FILE∗ stream)\nreturns the current position within the file. (limitation? long\n-\ndata type).\nreturns -1L on error.\n-\nint rewind(FILE∗ stream)\nsets the file pointer at the beginning.\n-\nequivalent to fseek(stream,0L,SEEK_SET);\n-\n\n<stdio.h>: File errors\nvoid clearerr(FILE∗ stream)\nclears EOF and other error indicators on stream.\n-\nint feof(FILE∗ stream)\n- return non-zero (TRUE) if end of file indicator is set for\nstream.\n- only way to test end of file for functions such as\nfwrite(),fread()\nint ferror (FILE∗ stream)\nreturns non-zero (TRUE) if any error indicator is set for\n-\nstream.\n\n<ctype.h>: Testing characters\nisalnum(c)\nisalpha(c) || isdigit (c)\niscntrl (c)\ncontrol characters\nisdigit (c)\n0-9\nislower(c)\n'a'-'z'\nisprint (c)\nprintable character (includes space)\nispunct(c)\npunctuation\nisspace(c)\nspace, tab or new line\nisupper(c)\n'A'-'Z'\n\n<string.h>: Memory functions\nvoid∗ memcpy(void∗ dst,const void∗ src,size_t n)\ncopies n bytes from src to location dst\n-\nreturns a pointer to dst.\n-\nsrc and dst cannot overlap.\n-\nvoid∗ memmove(void∗ dst,const void∗ src,size_t n)\nbehaves same as memcpy() function.\n-\nsrc and dst can overlap.\n-\nint memcmp(const void∗ cs,const void∗ ct,int n)\ncompares first n bytes between cs and ct.\n-\nvoid∗ memset(void∗ dst,int c,int n)\nfills the first n bytes of dst with the value c.\n-\nreturns a pointer to dst\n-\n\n<stdlib.h>:Utility\ndouble atof(const char∗ s)\nint atoi (const char∗ s)\nlong atol(const char∗ s)\nconverts character to float,integer and long respectively.\n-\nint rand()\nreturns a pseduo-random numbers between 0 and\n-\nRAND_MAX\nvoid srand(unsigned int seed)\nsets the seed for the pseudo-random generator!\n-\n\n<stdlib.h>: Exiting\nvoid abort(void)\n- causes the program to terminate abnormally.\nvoid exit (int status)\n- causes normal program termination. The value status is\nreturned to the operating system.\n- 0 EXIT_SUCCESS indicates successful termination. Any\nother value indicates failure (EXIT_FAILURE)\n\n<stdlib.h>:Exiting\nvoid atexit (void (∗fcn)(void))\n- registers a function fcn to be called when the program\nterminates normally;\n- returns non zero when registration cannot be made.\n- After exit() is called, the functions are called in reverse\norder of registration.\nint system(const char∗ cmd)\n- executes the command in string cmd.\n- if cmd is not null, the program executes the command and\nreturns exit status returned by the command.\n\n<stdlib.h>:Searchign and sorting\nvoid bsearch ( const void key , const\n∗\n∗\nvoid∗ base ,\nsize _t n , size _t size ,\nint (∗cmp ) ( const void∗ keyval , const void∗ datum ) ) ;\n- searches base[0] through base[n-1] for *key.\n- function cmp() is used to perform comparison.\n- returns a pointer to the matching item if it exists and NULL\notherwise.\nvoid qsort ( void∗ base , size _t n ,\nsize _t sz ,\nint (∗cmp ) ( const void ∗ , const void ∗ ) ) !\n- sorts base[0] through base[n-1] in\nascending/descending order.\n- function cmp() is used to perform comparison.\n\n<assert.h>:Diagnostics\nvoid assert(int expression)\nused to check for invariants/code consistency during\n-\ndebugging.\ndoes nothing when expression is true.\n-\nprints an error message indicating, expression, filename\n-\nand line number.\nAlternative ways to print filename and line number during\nexecution is to use: __FILE__,__LINE__ macros.\n\n<stdarg.h>:Variable argument lists\nVariable argument lists:\nfunctions can variable number of arguments.\n-\nthe data type of the argument can be different for each\n-\nargument.\natleast one mandatory argument is required.\n-\nDeclaration:\n-\nint printf (char∗ fmt ,...); /∗fmt is last named argument∗/\nva_list ap\nap defines an iterator that will point to the variable\n-\nargument.\nbefore using, it has to be initialized using va_start.\n-\n\n<stdarg.h>:Variable argument list\nva_start( va_list ap, lastarg)\nap lastarg refers to the name of the last named argument.\n-\nva_start is a macro.\n-\nva_arg(va_list ap, type)\neach call of va_arg points ap to the next argument.\n-\ntype has to be inferred from the fixed argument (e.g. printf)\n-\nor determined based on previous argument(s).\nva_end(va_list ap)\nmust be called before the function is exited.\n-\n\n<stdarg.h>:Variable argument list(cont.)\nint sum( int num , . . . )\n{\nv a _ l i s t ap ; int t o t a l =0;\nva _start ( ap ,num ) ;\nwhile (num>0)\n{\nt o t a l +=va_arg ( ap , int ) ;\nnum--;\n}\nva_end ( ap ) ;\nreturn t o t a l ;\n}\nint suma=sum(4 ,1 ,2 ,3 ,4); / ∗ called with f i v e args ∗ /\nint sumb=sum(2 ,1 ,2); / ∗ called with three args ∗ /\n\n<time.h>\ntime_t,clock_t, struct tm data types associated with time.\nstruct tm:\nint tm_sec\nseconds\nint tm_min\nminutes\nint tm_hour\nhour since midnight (0,23)\nint tm_mday\nday of the month (1,31)\nint tm_mon\nmonth\nint tm_year\nyears since 1900\nint tm_wday\nday since sunday (0,6)\nint tm_yday\nday since Jan 1 (0,365)\nint tm_isdst\nDST flag\n\n<time.h>\nclock_t clock()\nreturns processor time used since beginning of program.\n-\ndivide by CLOCKS_PER_SEC to get time in seconds.\n-\ntime_t time(time_t ∗ tp)\nreturns current time (seconds since Jan 1 1970).\n-\nif tp is not NULL, also populates tp.\n-\ndouble difftime(time_t t1,time_t t2)\nreturns difference in seconds.\n-\ntime_t mktime(struct tm∗ tp)\nconverts the structure to a time_t object.\n-\nreturns -1 if conversion is not possible.\n-\n\n<time.h>\nchar∗ asctime(const struct tm∗ tp)\nreturns string representation of the form \"Sun Jan 3\n-\n15:14:13 1988\".\nreturns static reference (can be overwritten by other calls).\n-\nstruct tm∗ localtime(const time_t ∗ tp)\nconverts calendar time to local time\".\n-\nchar∗ ctime(const time_t ∗ tp)\nconverts calendar time to string representation of local\n-\ntime\".\nequivalent to sctime(locltime(tp))!\n-\n\n<time.h>\nsize_t strftime (char∗ s,size_t smax,const char∗ fmt,const struct tm∗ tp)\nreturns time in the desired format.\n-\n- does not write more than smax characters into the string s.\n%a\nabbreviated weekday name\n%A\nfull weekday name\n%b\nabbreviated month name\n%B\nfull month name\n%d\nday of the month\n%H\nhour (0-23)\n%I\nhour (0-12)\n%m\nmonth\n%M\nminute\n%p\nAM/PM\n%S\nsecond\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.087 Practical Programming in C\nJanuary (IAP) 2010\n\nFor information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms."
    }
  ]
}