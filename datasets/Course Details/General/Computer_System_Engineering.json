{
  "course_name": "Computer System Engineering",
  "course_description": "This class covers topics on the engineering of computer software and hardware systems. Topics include techniques for controlling complexity; strong modularity using client-server design, operating systems; performance, networks; naming; security and privacy; fault-tolerant systems, atomicity and coordination of concurrent activities, and recovery; impact of computer systems on society.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Computer Design and Engineering",
    "Computer Networks",
    "Operating Systems",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Computer Design and Engineering",
    "Computer Networks",
    "Operating Systems",
    "Software Design and Engineering"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1 hour / session\n\nRecitations: 2 sessions / week, 1 hour / session\n\nTutorials: 1 session / week, 1 hour / session\n\nPrerequisites\n\n6.004 Computation Structures\nand\n6.005 Software Construction\nor\n6.009 Fundamentals of Programming\n\nLearning Objectives\n\nAfter completing this class, the students will be able to design their own distributed systems to solve real-world problems. The ability to design one's own distributed system includes an ability to argue for one's design choices.\n\nThis primary objective is supported by a few others:\n\nThe students will be able to evaluate and critique existing systems, as well as their own system designs. As part of that, students will learn to recognize design choices made in existing systems.\n\nThe students will be able to apply the technical material taught in lecture to new system components. This implies an ability to recognize and describe:\n\nHow common design patterns in computer system--such as abstraction and modularity--are used to limit complexity.\n\nHow operating systems use virtualization and abstraction to enforce modularity.\n\nHow the Internet is designed to deal with scale, a diversity of applications, and competing economic interests.\n\nHow reliable, usable distributed systems are able to be built on top of an unreliable network.\n\nCommon pitfalls in the security of computer systems, and how to combat them.\n\nBecause this is a\nCommunication Intensive in the Major\n(CI-M) class, students will also learn to communicate in forms that are common in the field of computer systems. This includes written design reports, oral presentations, and peer review.\n\nThe communication instruction also supports the primary learning objective of designing systems. In the real world, we design systems in teams, and communication of many forms (written, oral, etc.) is part of that process.\n\nRequired Text\n\nSaltzer, Jerome H. and M. Frans Kaashoek.\nPrinciples of Computer System Design: An Introduction, Part I\n. Morgan Kaufmann, 2009. ISBN: 9780123749574. [Preview with\nGoogle Books\n]\n\nThe text supplements the lectures and recitations; it should be your first resource when you are confused by a lecture topic, or want more information.\n\nPart II of the textbook\nis available on MIT OpenCourseWare.\n\nCourse Structure\n\nThe course has three components: lectures, recitations, and tutorials. We expect you to attend all three, as they each serve a different purpose.\n\n1. Lectures\n\nLectures are held on Mondays and Wednesdays for one hour. The lectures are designed to teach students the technical details necessary to design their own systems and to put those details in larger contexts: both the contexts of a specific area of systems as well as systems in general.\n\nThis type of material appears in lectures because that's what lectures are good at: giving a higher-level context for the details of the class.\n\n2. Recitations\n\nRecitations are held on Tuesdays and Thursdays for one hour. For the first recitation, attend whichever one you want. After that, you will be assigned a permanent section.\n\nRecitations are designed to give students a chance to practice their system-analysis and oral communication skills. Each recitation revolves around a particular paper in systems. Through reading these papers, students get a better sense of how communication in the field is done. Recitations are discussion-based; students get practice analyzing, critiquing, and communicating about systems.\n\n3. Writing Tutorials\n\nWriting tutorials are held on Fridays for one hour. We will assign your time slot during the first week of classes.\n\nMost of these tutorials will teach the communication theory and practices of this course and assist you in preparing for the assignments. You'll become fluent in a variety of communication genres, develop strategies and skills needed to present technical concepts to different audiences, learn how to use writing to develop and deepen your technical understanding--and get specific, directed instruction on writing and presenting your assignments. A handful of the tutorials will be dedicated to discussing the design project.\n\nLate Policy\n\nYou must hand in assignments when they are due, and you must attend quizzes at the scheduled times. If you feel you have a compelling reason for not handing in an assignment on time, or for not attending a quiz, please talk to Dr. LaCurts in advance.\n\nThe only exception to this late policy is design project materials. For those, the late policy will be explicitly posted on each assignment.\n\nIf you miss an assignment deadline, you should still hand in the assignment; we'll give you feedback even though we won't give you credit for your final grade. Furthermore, doing assignments is the best way to prepare for exams and design project. Unless otherwise specified, assignments are due at 5:00pm on their assigned due-date.\n\nGrade Components\n\nEach assignment supports the objectives of the class in various ways.\n\nTechnical Material (35% of Grade)\n\nQuizzes: One quiz is held during the term. A second quiz will be scheduled during finals week. Each quiz will focus on half of the class material, but keep in mind that later topics build heavily upon the earlier topics. The quizzes will test material from lectures, recitations, and the assigned reading and let us test whether students have mastered the technical material.\n\nHands-ons: During most weeks, you will be expected to complete a hands-on experiment that requires a computer. These reinforce some of the abstract concepts from the lectures or papers that week and let you find out how things really work. (Note: Hands-on experiments are not available to OCW users.)\n\nCommunication + System Design and Analysis (40% of Grade)\n\nThe staff has worked with the MIT Writing, Rhetoric, and Professional Communication (WRAP) program for more than 10 years to design the writing and speaking assignments. We have chosen assignments that are similar to the kinds of writing you will do in the engineering workplace: Preliminary reports, final reports, and presentations. Communication assignments are designed to help you conceptualize and develop the design project.\n\nDesign Project: The primary assignment in 6.033 is the design project (DP). This project is where the students get to design their own system, which is the primary objective of this course.\n\nThe DP requires you to develop a detailed system design to solve a real-world problem. This project will extend over most of the semester, and will be done in teams of three students, all of whom attend the same writing tutorial (with exceptions only for extenuating circumstances). Real-world systems are not built individually; it's always a team effort. Part of the DP is to learn to work productively and effectively in this setting. We will give you tools for doing so in the writing tutorials.\n\nThe DP consists of multiple deliverables: a preliminary report, oral presentation, final report, and peer review. The\nDesign Project\npage gives more detail about the DP deliverables.\n\nSystem Critiques: One of the goals of this class is for students to be able to analyze and critique technical systems. We will assign multiple system critiques during the semester.\n\nThese critiques will be graded by your Teaching Assistants (TAs) and/or Communication Instructors and assigned a letter grade (we will specify more details about grading in each of the assignments). The expectations for each individual critique will be detailed in the tutorials. As your skills at analyzing and reading technical papers improve throughout the semester, we will expect your critiques to reflect that.\n\nParticipation (25% of Grade)\n\nRecitation Participation: Our recitations are discussion-based, and we expect you to be engaged and participate. Participating in a recitation means:\n\nComing prepared to recitation (doing the reading, turning in the pre-reading question etc.)\n\nPaying attention when the instructor is speaking (you can't participation in a discussion if you don't know what it's about)\n\nParticipating (verbally) in pair-/group-work\n\nVolunteering to answer questions when the instructor asks them. (Note that you may not get called on each time. That's okay; our class sizes prevent that. Statistically, if you're raising your hand frequently, you'll get called on with some frequency.)\n\nResponding to other student's comments with an opinion of their own.\n\nAsking good questions in recitation (where \"good\" just means it's clear that you prepared for the recitation).\n\nWe will assign the participation grade in two parts: one for the first half of the semester, one for the second half of the semester. We will also give you preliminary grades for each of these (one about a quarter into the semester, one about three quarters into the semester), so that you know where you stand and have time to improve. This document explains in more detail how your participation grade is determined.\n\nCommunication Participation: A portion of your participation grade will also be based on your participation in writing tutorials and on your understanding of communication concepts and skills, as demonstrated by your work on the design project and evaluated by your communication instructor.\n\nNote that over a third of your grade comes from written assignments; we expect you to take writing seriously in this class.\n\nGrading\n\nThe class consists of three components: technical material, communication/system design and analysis, and participation. Each of these components comprises roughly one third of your grade, according to the following breakdown:\n\nACTIVITIES\n\nPERCENTAGES\n\nTechnical Material\n\n30% for Quizzes (two @ 15% each)\n5% for Hands-Ons\n\n35%\n\nCommunication + System Design and Analysis\n\n10% for Design Project (DP) Preliminary Report and Presentation\n\n20% for DP report\n\n4% for DP Peer Review\n\n6% for Critiques (Critique #1 =2%, Critique #2 = 4%)\n\n40%\n\nParticipation\n20% for Recitation Participation\n\n5% for Communication Participation\n\n25%\n\nYou must complete all design project assignments in order to pass 6.033. If you do not, you will automatically receive an F.\n\nCollaboration Policy\n\nYou may not collaborate on quizzes. On hands-ons, it's okay to discuss ideas with your classmates, but you should not be collaborating on the actual answers. Take the UNIX hands-on for example: it's okay to talk to your classmates about what pipes are, it's not okay to work together to come up with a command that gives a long listing of the smallest given files in the /etc directory whose name contains the string \".conf\", sorted by increasing file size (i.e., the solution to one of the first questions).\n\nOn all writing assignments you are welcome to discuss ideas with others, but your writing should be your own and you should acknowledge all contributions of ideas by others, whether from classmates or from papers you have read.",
  "files": [
    {
      "category": "Resource",
      "title": "Computer System Engineering, Networking Guide",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/b95bf0e79ebef3831b68ec8e4654f152_MIT6_033S18networking_guide.pdf",
      "content": "MIT 6.033 2017\nTen-minute Networking Extravaganza\nThis is not meant to be a comprehensive guide to networking. It contains the very\nbasics that you need to know to understand how a network works; some terms have\nbeen intentionally defined imprecisely, and many details have been left out. We'll fill in a\nlot of those details, and make a lot of definitions more precise, as the course goes on.\nA computer network facilitates communication between two or more computers. You can\nimagine having, say, ten computers, all connected to one another with Ethernet cables. That's\none example of a computer network. We would say that each of those machines had a direct\nconnection to one another, or a point-to-point link. These point-to-point links don't have to be\nEthernet cables; they could be 802.11 wireless links, satellite links, cellular links, etc. There are\nmany different physical technologies that one can build a network out of.\nIt isn't feasible to have every computer in the world directly connected to every other computer.\nInstead, most networks involve switches. Switches are devices that sit in the middle of the\nnetwork, and help move data from one machine to another.\nTypically we'll refer to machines such as your computer as \"endpoints\", to differentiate them\nfrom switches. Usually, endpoints initiate the sending of data, and data is sent to them;\nswitches help move data through the network. As you can see, data from multiple different\nendpoints might pass through a single switch.\nThere are multiple ways to handle this -- multiple ways to send more than one stream of data\nthrough a switch (to multiplex the network). The most common way is to use packet\nswitching. In a packet-switched network, each piece of data -- a packet -- contains some\nmeta-information attached to it, called a header. This header contains things such as the\nsource address: the address of the machine where the packet is headed. As the packet passes\nthrough different switches, they can look at the packet header and figure out where the packet\nneeds to go.\nA contrasting idea is circuit switching, where the relevant state is kept on switches\ninstead of attached to teach packet.\nTo actually get data from one place to another, a network first needs to make sure every\nendpoint has a unique address. Depending on the size of the network, the addressing scheme\n\nmay have to be clever in certain ways; for small networks, it's fine to just image that a\ncentralized service gives every endpoint a unique address.\nIn addition to addresses, a network needs a routing protocol. That is a protocol that helps it\nfind routes through the network. Once a switch has run a routing protocol, when it gets a packet\ndestined for Machine A, it knows which switch to send the packet to next.\nWith addressing and routing, we now have a network that works, at least to an extent: endpoints\ncan send data to one another. Importantly, addressing and routing protocols don't need to worry\nabout what physical technology is running \"underneath\": a routing protocol can work over an\nEthernet network, a wireless network, etc. This is thanks to layering: the physical layer need\nnot be concerned with what the network layer is doing, and vice versa.\nEach switch is only capable of handling so many packets at once. Switches contain queues,\nwhich store packets that they've received but cannot send yet (because their outgoing link is\nbusy sending other packets). If a packet arrives when the queue is full, that packet will be\ndropped; it disappears from the network. Full queues are one reason that a network might\nexperience loss. Other reasons are if a switch crashes or if a link fails (e.g., an Ethernet cable\ngets cut).\nFor some applications, this type of loss is okay; others might desire reliable transport, where\nmore effort is made to deliver data reliably. Reliable transport protocols provide reliable --\nbut not perfect -- transport. These protocols, and many others, are part of the transport layer,\nwhich sits above the network layer. That implies that transport layer protocols don't care what\nrouting protocol the network is using, e.g.\nThis discussion also reveals yet another layer: the application layer. Ultimately, applications\n-- like Skype, Spotify, or other applications that you might run -- generate the network traffic.\nAs revealed, different applications desire different things.\nBesides reliability, there are other ways to think about how the network performs:\n- How much data can it transport over some unit of time? There are many ways to think about\nthis: what is the physical speed that the underlying links are capable of? How much data is\nthe network actually sending (say, per second), which is based at least partly on how much\ntraffic the endpoints are generating? Etc. There are lots of terms you'll see used to describe\nthese concepts: the speed of a network, its bandwidth, its throughput, etc.\n- How long does it take a packet to get from one end of the network to the other? This quantity\nis referred to as latency. The latency of a network is affected by its physical properties, as\nwell as how much other data is in the network.\nThere are a number of other things we can ask of our networks:\n- Does it provide multicast: the ability to send a piece of data to multiple endpoints at once,\ninstead of just one? The implication there is that the underlying network replicates the data\nwhere appropriate; the sender sends a single copy, while somehow specifying the endpoints\nthat should receive it. If a network provides the ability to multicast to all endpoints at once\n(sometimes, all in-range endpoints), we say that network provides broadcast.\n\n- Does it allow for prioritization, where different types of data are treated differently? For\ninstance, perhaps a switch prioritizes HTTP packets, sending those before all others.\n- Does the network support any other policies? Usually, those policies are set by a human,\nnot automated by the network. Prioritizing certain types of data is one example of a policy.\nIn this discussion, we've presented a four-layer model: physical, network, transport, and\napplication. One of the most widely-used models actually uses seven layers: a \"link layer\" sits\nbetween the physical and network layers, and the \"session\" and \"presentation\" layers sit\nbetween the transport and application layers. There's no need to worry about the details of\nthose layers at the moment.\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.033 Computer System Engineering\nSpring 2018\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms"
    },
    {
      "category": "Resource",
      "title": "Computer System Engineering, Quick Guide",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/82ef662a803f2c310c03cc06053da27b_guide.pdf",
      "content": "This is a very, very brief guide to a few common types of memory corruption attacks. Almost all details have\nbeen ommitted, but it should give you the basic ideas.\nBuffer Overruns\nMost memory corruption attacks start with some type of buffer overrun. A buffer overrun is when a program\nallocates some amount memory to a buffer--say 100 bytes--and then writes beyond the end of that allocated\nmemory.\nBuffer overruns can be done on the stack...\nvoid f1a(void * arg, size_t len) {\nchar buff[100];\nmemcpy(buff, arg, len); /* buffer overrun if len > 100 */\n/* ... */\nreturn;\n}\n...or on the heap.\nvoid f1b(void * arg, size_t len) {\nchar * ptr = malloc(100);\nif (ptr == NULL) return;\nmemcpy(ptr, arg, len); /* buffer overrun if len > 100 */\n/* ... */\nreturn;\n}\n(Both of these examples were taken from the paper \"Beyond Stack Smashing: Recent Advances in Exploiting Buffer\nOverruns\" by Pincus and Baker.)\nThe examples above are written in C. C provides no built-in mechanisms to prevent writing past the end of a buffer\n(unlike languages such as Java, where you'd expect to see some sort of ArrayIndexOutOfBounds exception).\nStack Smashing\nOne of the original techniques to exploit buffer overruns was stack smashing. To understand stack smashing, you\nfirst have to understand how a stack works.\nWhen a piece of code calls a function f, the compiler pushes a few things onto the stack before it makes the jump to f.\nIn particular, it pushes the current address onto the stack. When the function f is ready to return, the compiler uses that\naddress as the return address, so that the code returns to the calling function.\nTo smash the stack, an attacker cleverly overwrites a buffer so that it overwrites the return address. The new return\naddress points to some code that the attacker has written. This means that, when f returns, it will jump to the\nmalicious code rather than the calling function.\n(The original stack smashing \"paper\" is not required reading for 6.033, but it is pretty enjoyable.)\nReturn-to-libc\nBasic stack-smashing attacks--where the return address is overwritten to point to code that the attacker wrote--can\nbe thwarted by making the stack non-executable (the attacker's code will exist on the stack, so if the stack is marked\nas non-executable, that code can't run). This technique is sometimes known as W⊕X.\nHowever, in that case, attackers can overwrite return addresses to point to some existing subroutine--often a shared\nlibrary--that is executable. Those shared libraries typically contain subroutines for making system calls. If an attacker\noverwrites the return address, as well as some other carefully selected locations on the stack, they can pass parameters\nto these system calls and execute arbitrary code. These types of attacks are known as return-to-libc attacks (libc being\na very common shared library).\nReturn-oriented Programming\nReturn-oriented programming (ROP) builds on the idea from return-to-libc attacks. Instead of returning to a\nparticular subroutine in a shared library, ROP allows attackers to return to some small chunk of code from shared\nlibraries (rather than a full subroutine). These chunks of code--\"gadgets\"--can be chained together to allow for\narbitrary code execution.\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.033 Computer System Engineering\nSpring 2018\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "6.033 DNS Critique Worksheet 2017",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/40c59cdf5cc3002f4f5752bcd63188fe_MIT6_033S18_Crit1Worksheet.pdf",
      "content": "6.033 systems critique: preparation worksheet\n\nPaper\n\nDNS\nSummary of\nsystem: What is it?\nWhat does it do?\n\nDoes DNS respond\nto a previous\nsystem? What\nproblem is solved\nby DNS?\n\nWhat are the\nmodules of the\nsystem? How do\nthey interact?\n\nDesign goals (use\nevidence from text)\n\nRelevant\n(y/n)\nIf no, why not? If yes,\nis goal met?\nEvidence from text\nSimplicity\n\nScalability\n\n6.033 systems critique: preparation worksheet\n\nFault-tolerance/\nhandling failures\n\nSecurity\n\nAdditional design goals, if\nany (use extra paper if >2)\nIs this goal met? Explain\nEvidence from text\n\nOther analysis\n(limitations, context,\nnotable success)\n\nCriteria most important to\nthis system and why\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.033 Computer System Engineering\nSpring 2018\nFor Information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "6.033 DNS Critique Worksheet 2017",
      "type": "DOCX",
      "source_url": "https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/1795776fcbb70fb120df9c6a06d6c717_MIT6_033S18_Crit1Worksheet.docx",
      "content": "MIT OpenCourseWare\nhttps://ocw.mit.edu\n\n6.033 Computer System Engineering\nSpring 2018\n\nFor Information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "6.033S18 MapReduce Critique Worksheet 2017",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/35980840d44ecd95ad8eec4fda5f3030_MIT6_033S18_Crit2Worksheet.pdf",
      "content": "6.\n\n033 systems critique: preparation worksheet\n\nPaper\n\nMapReduce\nSummary of\nsystem: What is it?\nWhat does it do?\n\nDoes MapReduce\nrespond to a\nprevious system?\nWhat problem is\nsolved by\nMapReduce?\n\nWhat are the\nmodules of the\nsystem? How do\nthey interact?\n\nDesign goals (use\nevidence from text)\n\nRelevant\n(y/n)\nIf no, why not? If yes,\nis goal met?\nEvidence from text\nSimplicity\n\nScalability\n\n6.\n\n033 systems critique: preparation worksheet\nFault-tolerance/\nhandling failures\n\nSecurity\n\nAdditional design goals, if\nany (use extra paper if >2)\nIs this goal met? Explain\nEvidence from text\n\nOther analysis\n(limitations, context,\nnotable success)\n\nCriteria most important to\nthis system and why\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.033 Computer System Engineering\nSpring 2018\nFor Information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "6.033S18 Rubric for Critique 2017",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/2c8eaac631f2d2324fa77fe0ffa313dd_MIT6_033S18_Crit2Rubric.pdf",
      "content": "Advanced\nCompetent\nDeveloping\nIntroduction\nIntroduces system in terms of\npurpose and response to previous\nsystem. Supports with evidence.\nStates the purpose of the\nsystem.\nPurpose of system is unclear.\nSummary\nClearly articulates modules and\ninteractions between modules\nwithin the system.\nMay state modules or\ninteractions, but relationship is\nunclear. May only list modules.\nSystem modules are unclear or\nunstated.\nPriorities\nMakes evaluative claims about\nsystem priorities in relationship\nto/context of key use case(s).\nOnly one property is analyzed\nin relationship to system, or\npaper claims are presented as\nfact. Properties are not clearly\nconnected to use cases.\nLacks an introduction to key system\nproperties.\nBody\nProvides an explanation for how\nsystem design choices\ndemonstrate which properties are\nhighly prioritized. Supports with\nevidence from text.\nLists properties but does not\nconnect to design choices or\nlacks substantial evidence.\nDoes not support description of\nproperties with evidence from the\ntext. Omits properties from\nworksheet.\nAnalysis\nAssesses how well purpose and\nproperties (design principles/\ngoals) are achieved, evaluates\ntradeoffs between properties.\nLinks techniques to properties\nthey improve or degrade. Defines\nproperties in context of use cases\nor design goals, if necessary.\nStates whether a property is\nimportant to system and\njustifies that with evidence\nfrom text. Does not relate this\nto use cases consistently. May\nnot evaluate tradeoffs or may\nomit link between properties\nand techniques.\nLacks textual evidence in supporting\nanalysis. Does not explore all\nproperties requested.\nScope\nAssessment of properties is\njustified both by the primary use\ncase and by speculative use cases\nthat explain limits of properties in\nsystem.\nProperties are explored\nexclusively within a single use\ncase.\nProperties are not connected to a use\ncase.\n\nConclusion\nSummarizes assessment of system\nin context of use case(s) and\ndraws conclusions.\nSummarizes how properties are\nprioritized to achieve design\ngoals\nLacks a full summary of property\nprioritization.\nClarity\nUses strong subjects and active\nverbs, and precise language\nincluding system terminology:\nproperties, behaviors, and use\ncases. Applies known-new\nstructure appropriately.\nUses strong subjects and active\nverbs. Syntax does not interfere\nwith understanding of content.\nSyntax is confusing. Sentences lack\nclear connection to the content.\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.033 Computer System Engineering\nSpring 2018\nFor Information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_033S18_Crit2Worksheet.docx",
      "type": "DOCX",
      "source_url": "https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/4c7f271a57d11aabe20056c36c3143fc_MIT6_033S18_Crit2Worksheet.docx",
      "content": "MIT OpenCourseWare\nhttps://ocw.mit.edu\n\n6.033 Computer System Engineering\nSpring 2018\n\nFor Information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    }
  ]
}