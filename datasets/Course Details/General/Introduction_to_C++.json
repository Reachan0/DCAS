{
  "course_name": "Introduction to C++",
  "course_description": "This is a fast-paced introductory course to the C++ programming language. It is intended for those with little programming background, though prior programming experience will make it easier, and those with previous experience will still learn C++-specific constructs and concepts.\nThis course is offered during the Independent Activities Period (IAP), which is a special 4-week term at MIT that runs from the first week of January until the end of the month.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 3 sessions / week for 4 weeks, 1 hour / session\n\nLabs: 1 session / week for 4 weeks, 3 hours / session\n\nCourse Objectives\n\nThis is a fast-paced introductory course to the C++ programming language. It is intended for those with little programming background, though prior programming experience will make it easier, and those with previous experience will still learn C++-specific constructs and concepts.\n\nBy the end of this course, you should be able to:\n\nUnderstand and use the basic programming constructs of C/C++\n\nManipulate various C/C++ datatypes, such as arrays, strings, and pointers\n\nIsolate and fix common errors in C++ programs\n\nUse memory appropriately, including proper allocation/deallocation procedures\n\nApply object-oriented approaches to software problems in C++\n\nWrite small-scale C++ programs using the above skills\n\nCourse Mechanics\n\nYou are responsible for all material presented in lectures. There will also generally be some extra notes in the problem sets building on the material that you should read before attempting the problem set. We strongly recommend that you attend labs, as you will almost certainly need help on the problem sets (C++ can be tricky!), but you are not required to stay for the entire lab.\n\nThere is no textbook for this course. You may find some of the following online materials helpful:\n\nC++ Language Tutorial\n\nWikiversity: Introduction to C++\n\nLearn about C++ Programming\n\nAssessment\n\nThere will be four problem sets (the last of which will be smaller) and a final project. You are encouraged to collaborate, but any code and write-ups you hand in must be your own.\n\nThis is a P/D/F course. Each problem set will be graded out of 100. We will award a pass based on whether problem set grades are generally on par with the class average and whether the final project demonstrates an understanding of the material. There will be no exams.\n\nCoding Environment\n\nGenerally, software developers do their development work in some sort of \"integrated development environment\" (IDE), which will have many built-in tools for editing, compiling, running, and debugging programs. We recommend that you use the IDE known as Code::Blocks, which is\nfreely available\n.\n\nYou will also need to download the GNU C++ compiler (GCC). For Windows machines, you should use the MinGW version of it; you can install the version of Code::Blocks that comes bundled with MinGW, or follow the instructions\nhere\n. If you're on a Mac, the easiest thing to do is install Xcode, which comes bundled with GCC. Xcode\ncan be downloaded here\n(registration with Apple is required). If you're using Linux, you probably don't need our help on this one, and your operating system probably came with GCC anyway.\n\nThere are many IDEs available besides Code::Blocks, and you may use any of them if you so desire. Another\nfreely available\none is Eclipse, which is very powerful and works on all operating systems, though many have had technical problems in the past with installing/using it for C++. (We recommend that you download the edition of Eclipse for C/C++ developers, but if you already have a different version of Eclipse, you can install the C/C++ add-ons through\nEclipse's add-on manager\n.) On a Mac, you can simply use the Xcode IDE; on Windows you can use Microsoft Visual Studio on Windows (registration with Microsoft DreamSpark required). While all of these will serve the purpose well, we cannot guarantee that we will be able to help you with any problems that arise in the course of using them.",
  "files": [
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_assn01.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/213177bc033f42d335e27bf253448912_MIT6_096IAP11_assn01.pdf",
      "content": "6.096 Lab 1\nDue: 7 January 12:30:00\nSeptember 20, 2011\nAdditional Material\n1.1\nConstants\nA constant is an expressions with a fixed value. Kinds of constants:\n- Literals: used to express particular values within the source code; can be integers (ex:\n1, -0, -17), floating points (ex: 3.1415926535897, 1., 6.096, 3), characters (ex: 'a', ' ',\n'\\n'), strings (ex: \"6.096\", \"a\"), booleans (ex: true, false)\n- Defined constants (#define): user-defined named constants that do not require memory-\nconsuming variables. When the preprocessor sees the #define, it will replace every\nsubsequent occurrance of the identifier in the source code.\n1 # include < iostream >\n3 using namespace std ;\n5 # define PI 3.14159\n6 # define NEWLINE '\\n '\n8 int main ()\n9 {\ndouble r = 5.0;\ndouble circle ;\ncircle = 2 * PI * r; // circle = 2 * 3.14159 * r;\ncout << circle << NEWLINE ; // cout << circle << '\\n ';\nreturn 0;\n17 }\n- Declared constants (const): user defined constants with const prefix with a specific\ntype that are declared the same way as variables. The value of a const variable cannot\nbe modified.\n\n1 const int pathwidth = 100;\n2 // pathwidth = 2; this will cause a compiler error!\n3 const char tabulator = '\\t ';\n4 cout << \"tabulator =\" << tabulator << '\\n ';\n1.2\nL-values, R-values\nlvalue is short for \"left hand side value\" (of an assignment).\nExamples of non-lvalue expressions:\n- 3+3 // you can't assign 3+3 to something\n- \"str\" // the literal \"str\" can't take on another value\n- const int i = 3 // can't change the value of const variable\nExamples of lvalue expressions:\n- int var // var is an lvalue because we can assign it with some value\nfloat x\n-\nrvalue is short for \"right hand side value\" because rvalues can appear on the right hand\nside of an assignment. Anything with a well-defined value can be an rvalue, including an\nassigment: (x = 5) can be used as an rvalue whose value is 5, e.g. y = (x=5);.\n1.3\nIncrement, Decrement operators (++, --)\na++ and ++a are shorthand for a = a + 1 with a big warning sign:\n- ++a will increment a and then return the value (so it will return one greater than the\noriginal value)\na++ will return the current value and then increment\n-\n- --a will decrement a and then return the value (so it will return one less than the\noriginal value)\na-- will return the current value and then decrement\n-\n// this code outputs 0 to 9\nfor (int i = 0; i < 10;)\n{\ncout << i++ << \"\\n\";\n}\n\n7 // this code outputs 1 to 10\n8 for (int i = 0; i < 10;)\n9 {\ncout << ++i << \"\\n\";\n11 }\n1.4\nAssignment operators\nAssignment ops include +=, -=, *=, /=, %=, etc.; a += 5 is equivalent to a = a + 5, etc.\n1.5\nType Conversions\nUsed for changing between data types. Also called \"casts.\" Type conversions are implicit\nwhen changing from smaller data type to a bigger data type or data type of same size (e.g.\nfloat to double or int to float). Type conversions usually must be explicitly stated when\nchanging from bigger datatype to smaller datatype or when there could be a loss of accuracy\n(e.g. int to short or float to int), but implicitly converting from a double to an int will\nnot generate a compiler error (the compiler will give a warning, though).\n1 int x = ( int ) 5.0; // float should be explicitly \" cast \" to int\n2 short s = 3;\n3 long l = s; // does not need explicit cast , but\n// long l = ( long )s is also valid\n5 float y = s + 3.4; // compiler implicitly converts s\n// to float for addition\n1.6\nOperator precedence\nLike arithmetic, C++ operators have a set order by which they are evaluated. The table of\noperators and their precedence is listed in the following table:\n\n() [] -> . ::\nGrouping, scope, array/member access\n! * & sizeof (type cast) ++ - (most) unary operations, sizeof and typecasts\n* / %\nMultiplication, division, modulo\n+ -\nAddition and subtraction\n<< >>\nBitwise left and right shift\n< <= > >=\nComparisons: less than, etc.\n== !=\nComparisons: equal and not equal\n&\nBitwise AND\nË†\nBitwise exclusive OR\n|\nBitwise inclusive (normal) OR\n&&\nLogical AND\n||\nLogical OR\n?:\nConditional expression (ternary operator)\n= += -= *= /= %=, etc.\nAssignment operators\n,\nComma operator\n1.7\nTernary operator (?:)\nAn operator that takes three arguments and defines a conditional statement.\n1 if (a > b)\nresult = x;\n3 else\nresult = y;\nis equivalent to\n1 result = a > b ? x : y;\n1.8\nswitch statement\nA type of selection control statement. Its purpose is to allow the value of a variable or\nexpression to control the flow of program execution via multiple possible branches. Omitting\nbreak keywords to causes the program execution to \"fall through\" from one block to the\nnext, a trick used extensively. In the example below, if n = 2, the fifth case statement (line\n10) will match the value of n, so the next line outputs \"n is an even number.\" Execution\nthen continues through the next three case statements and to the next line, which outputs\n\"n is a prime number.\" This is a classic example of omitting the break line to allow for fall\nthrough. The break line after a case block causes the switch statement to conclude. The\ndefault block (line 21) is executed if no other cases match, in this case producing an error\nmessage if n has multiple digits or is negative. The default block is optional in a switch\nstatement.\n1 switch (n) {\n\ncase 0:\ncout << \" You typed zero .\\ n\";\nbreak ;\ncase 1:\ncase 4:\ncase 9:\ncout << \"n is a perfect square .\\ n\";\nbreak ;\ncase 2:\ncout << \"n is an even number .\\ n\";\ncase 3:\ncase 5:\ncase 7:\ncout << \"n is a prime number .\\ n\";\nbreak ;\ncase 6:\ncase 8:\ncout << \"n is an even number .\\ n\";\nbreak ;\ndefault :\ncout << \" Only single -digit positive numbers are allowed .\\ n\";\nbreak ;\n24 }\n1.9\nbreak\nUsed for breaking out of a loop or switch statement.\n1 // outputs first 10 positive integers\n2 int i = 1;\n3 while (true )\n4 {\nif (i > 10)\nbreak ;\ncout << i << \"\\n\";\n++i;\n9 }\n1.10\ncontinue\nUsed for skipping the rest of a loop body and continuing to the next iteration.\n1 // print out even numbers in\n2 for ( int i = 0; i <= 10; ++ i)\n3 {\nrange 1 to 10\n\nif (i % 2 != 0)\ncontinue ; // skips all odd numbers\ncout << i << \"\\n\";\n7 }\n1.11\nReferences\n- Wikipedia: http://en.wikipedia.org/\n- Cplusplus: http://www.cplusplus.com/\n\n\"Hello, World!\"\nThis section is about writing the canonical \"Hello, World!\" program and its derivatives.\nNow is a good time to get used to your development environment. Submit each program in\na separate source file named hsectioni.hsubsectioni.cpp.\n2.1\nHello World I\nWrite a program that outputs \"Hello, World!\" by printing a const char * with value\n\"Hello, World!\".\n2.2\nHello World II\nWrite a program that outputs \"Hello, World!\" n times (where n is a nonnegative integer\nthat the user will input) with:\n- a for loop.\n- a while loop.\n- a do...while loop.\n\nMore Programs\nNow that you have had some practice working in your development environment, here are\nsome more challenging tasks. Again, submit your work (source code and answers to ques\ntions) in an appropriately named text file.\n3.1\nScope\nFor these questions, you are encouraged to use a computer.\n1. Below is a sample program. Use it to answer the following question: What happens if\nwe declare the same name twice within a block, giving it two different meanings?\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint arg1;\narg1 = -1;\nint x, y, z;\nchar myDouble = '5 ';\nchar arg1 = 'A ';\ncout << arg1 << \"\\n\";\nreturn 0;\n14 }\nHints: Did your program compile? If so, what does it print? If not, what error message\ndo you get?\n2. Below is a sample program. Use it to answer the following question: What happens if\nwe declare an identifier in a block, and then redeclare that same identifier in a block\nnested within that block?\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint arg1;\narg1 = -1;\n{\nchar arg1 = 'A ';\ncout << arg1 << \"\\n\";\n\n}\nreturn 0;\n14 }\nHints: Did your program compile? If it does, what does the program output? If not,\nwhat error message does it produce?\n3. Below is a sample program. Use it to answer the following question: Suppose an\nidentifier has two different declarations, one in an outer block and one in a nested\ninner block. If the name is accessed within the inner block, which declaration is used?\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint arg1;\narg1 = -1;\n{\nchar arg1 = 'A ';\ncout << arg1 << \"\\n\";\n}\nreturn 0;\n14 }\n4. Below is a sample program. Use it to answer the following question: Suppose an\nidentifier has two different declarations, one in an outer block and one in a nested\ninner block. If the name is accessed within the outer block, but after the inner block,\nwhich declaration is used?\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint arg1 ;\narg1 = -1;\n{\nchar arg1 = 'A ';\n}\ncout << arg1 << \"\\n\";\nreturn 0;\n14 }\n\n5. Below is a sample program that will not compile. Why not? By moving which line\ncan we get the code to compile?\n1 using namespace std;\n3 int main ()\n4 {\ncout << \"Hello , World !\\n\";\nreturn 0;\n7 }\n9 #include <iostream >\n3.2\nBasic Statistics\nGiven a list of N integers, find its mean (as a double), maximum value, minimum value,\nand range. Your program will first ask for N, the number of integers in the list, which the\nuser will input. Then the user will input N more numbers.\nHere is a sample input sequence:\n3 <-- N\nThree numbers are given: 2, 1, 3. The output should be as follows:\nMean: 2\nMax: 3\nMin: 1\nRange: 2\n3.3\nPrime Numbers\nWrite a program to read a number N from the user and then find the first N primes. A\nprime number is a number that only has two divisors, one and itself.\n3.4\nMultiples of numbers\n3.4.1\nTernary operator\nWrite a program that loops indefinitely. In each iteration of the loop, read in an integer N\n(declared as an int) that is inputted by a user, output N\n5 if N is nonnegative and divisible by\n5, and -1 otherwise. Use the ternary operator (?:) to accomplish this. (Hint: the modulus\noperator may be useful.)\n\n3.4.2\ncontinue\nModify the code from 3.4.1 so that if the condition fails, nothing is printed. Use an if and\na continue command (instead of the ternary operator) to accomplish this.\n3.4.3\nbreak\nModify the code from 3.4.2 to let the user break out of the loop by entering -1 or any negative\nnumber. Before the program exits, output the string \"Goodbye!\".\n3.5\nWhat does this program do?\nDo these problems without the use of a computer!\n1. What does this snippet do? Try doing out a few examples with small numbers on\npaper if you're stuck. (Hint:\nThink about numbers in binary notation - in base 2.\nHow would you express a number as a sum of powers of 2? You may also find it useful\nto note that multiplying by 2n is equivalent to multiplying by 2 n times. You should\nalso keep in mind the distributive property of multiplication: a(x + y) = ax + ay.)\n1 // bob and dole are integers\n2 int accumulator = 0;\n3 while (true )\n4 {\nif (dole == 0) break ;\naccumulator += (( dole % 2 == 1) ? bob : 0);\ndole /= 2;\nbob *= 2;\n9 }\n10 cout << accumulator << \"\\n\";\n2. What does this program do? What would the operating system assume about the\nprogram's execution?\n1 #define O 1 // That 's an oh , not a zero\n2 int main ()\n3 {\nreturn O;\n5 }\n3. What does this program do?\n1 // N is a nonnegative integer\n2 double acc = 0;\n3 for (int i = 1; i <= N; ++i)\n4 {\n\ndouble term = (1.0/i);\nacc += term * term;\nfor (int j = 1; j < i; ++j)\n{\nacc *= -1;\n}\n11 }\n12 cout << acc << \"\\n\";\n\nFactorials Gone Wrong\nThis section focuses on debugging programs. We will start off with a simple factorial program\nand do a step by step troubleshooting routine.\n4.1\nWriting the factorial program\nHere is the code for a factorial program. Copy it into your IDE and verify that it compiles.\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nshort number;\ncout << \"Enter a number: \";\ncin >> number;\ncout << \"The factorial of \" << number << \" is \";\nint accumulator = 1;\nfor (; number > 0; accumulator *= number --);\ncout << accumulator << \".\\n\";\nreturn 0;\n17 }\nWhat do you get when you enter the following values: 0, 1, 2, 9, 10?\n4.2\nBreaking the program\nRun the program and enter -1. What happens? How can you change the code such that it\nwon't exhibit this behavior?\n4.3\nBreaking the program II\nTry entering some larger numbers. What is the minimum number for which your modified\nprogram from 4.2 stops working properly? (You shouldn't have to go past about 25. You\nmay find Google's built-in calculator useful in checking factorials.) Can you explain what\nhas happened?\n4.4\nRewriting Factorial\nModify the given code such that negative inputs do not break the program and the smallest\nnumber that broke the program before now works. Do not hardcode answers.\n\n4.5\nRewriting Factorial II\nSince we know that only a small number of inputs produce valid outputs, we can alterna\ntively hardcode the factorials of these inputs. Rewrite the program from the previous part\n(\"Rewriting Factorial\") using a switch statement to demonstrate for inputs up to 10 how\nyou would do this. (Of course, the code for inputs above 10 would basically be the same,\nbut you do not need to go through the work of finding all those large factorials.)\n4.6\nFurther testing\nAre there any other inputs we have to consider? Why or why not?\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_assn02.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/797ebff419fa2cc3a10af2c5f19be961_MIT6_096IAP11_assn02.pdf",
      "content": "6.096 Problem Set 2\nDue: 14 January 12:30:00\nFor this problem set, you should be able to put all your code for each section into a single\nsource/text file (though you may have to comment out earlier parts of your solution to test\nlater parts). Clearly mark each subsection with comments, and submit a .zip file containing\nall your source/text files.\nAdditional Material\n1.1\nFunctions\n1.1.1\nDefault Arguments\nSay you have a function with 1 argument, but that argument is usually the same.\nFor\ninstance, say we want a function that prints a message n times, but most of the time it will\nonly need to print it once:\n1 void printNTimes( char *msg , int n) {\nfor ( int i = 0; i < n; ++i) {\ncout << msg;\n}\n5 }\nRather than writing printNTimes(\"Some message\", 1); every time, C++ allows de\nfault arguments to be defined for a function:\n1 void printNTimes ( char *msg , int n = 1) {\nfor ( int i = 0; i < n; ++ i) {\ncout << msg ;\n}\n5 }\nDeclaring the function argument as int n = 1 allows us to call the function with printNTimes(\"Some\nmessage\");. The compiler automatically inserts 1 as the second argument.\nYou may have multiple default arguments for a function:\n1 void printNTimes( char *msg = \"\\n\", int n = 1) {\nfor ( int i = 0; i < n; ++i) {\ncout << msg;\n\n}\n5 }\nNow, to print one newline, we can simply write printNTimes();. However, C++ does\nnot allow skipping arguments, so we could not print k newlines by writing printNTimes(k);.\nTo do that, we'd need to say printNTimes(\"\\n\", k);.\n1.1.2\nConstant Arguments\nIt's often useful to specify that arguments to a function should be treated as constants. As\nwith regular variables, we can declare function arguments to be const:\n1 void print( const int n) {\ncout << n;\n3 }\nThis is particularly useful when we are passing values by reference to a function, but\ndon't want to allow the function to make any changes to the original value:\n1 void print( const long &x) { // Pass -by -reference avoids overhead\n// of copying large number\ncout << x;\n4 }\n6 int main () {\nlong x = 234923592;\nprint(x); // We are guaranteed that x\n// will not be changed by this\nreturn 0;\n11 }\nIn general, if you know a value shouldn't be changing (particularly a function argument),\nyou should declare it const. That way, the compiler can catch you if you messed up and\ntried to change it somewhere.\n1.1.3\nRandom Number Generation Functions\nThe C++ standard libraries include the rand() function for generating random numbers\nbetween 0 and RAND MAX (an integer constant defined by the compiler).\nThese numbers\nare not truly random; they are a random-seeming but deterministic sequence based on a\nparticular \"seed\" number. To make sure we don't keep getting the same random-number\nsequence, we generally use the current time as the seed number. Here is an example of how\nthis is done:\n1 #include <iostream >\n2 #include <cstdlib > // C standard library\n// defines rand (), srand (), RAND_MAX\n\n4 #include <ctime >\n// C time functions - defines time ()\n5 int main () {\nsrand( time (0) ); // Set the seed;\n// time (0) returns current time as a number\nint randNum = rand ();\nstd :: cout << \"A random number: \" << randNum << endl;\nreturn 0;\n11 }\n1.2\nPointers\n1.2.1\nPointers to Pointers\nWe can have pointers to any type, including pointers to pointers. This is commonly used\nin C (and less commonly in C++) to allow functions to set the values of pointers in their\ncalling functions. For example:\n1 void setString( char ** strPtr) {\nint x;\ncin >> x;\nif (x < 0)\n*strPtr = \"Negative!\";\nelse\n*strPtr = \"Nonnegative!\";\n8 }\n10 int main () {\nchar *str;\nsetString (&str);\ncout << str; // String has been set by setString\nreturn 0;\n15 }\n1.2.2\nReturning Pointers\nWhen you declare a local variable within a function, that variable goes out of scope when\nthe function exits: the memory allocated to it is reclaimed by the operating system, and\nanything that was stored in that memory may be cleared. It therefore usually generates a\nruntime error to return a pointer to a local variable:\n1 int\n4 }\n* getRandNumPtr ()\nint x = rand () ;\nreturn &x;\n{\n\n6 int main () {\nint *randNumPtr = getRandNumPtr ();\ncout << *randNumPtr; // ERROR\nreturn 0;\n10 }\nLine 8 will likely crash the program or print a strange value, since it is trying to access\nmemory that is no longer in use - x from getRandNumPtr has been deallocated.\n1.3\nArrays and Pointers\n1.3.1\nArrays of Pointers\nArrays can contain any type of value, including pointers. One common application of this\nis arrays of strings, i.e., arrays of char *'s. For instance:\n1 const char *suitNames [] = {\"Clubs \", \"Diamonds \", \"Spades \", \"Clubs \"};\n2 cout << \"Enter a suit number (1 -4): \";\n3 unsigned int suitNum;\n4 cin >> suitNum;\n5 if (suitNum <= 3)\ncout << suitNames[suitNum - 1];\n1.3.2\nPointers to Array Elements\nIt is important to note that arrays in C++ are pointers to continuous regions in memory.\nTherefore the following code is valid:\nconst int ARRAY_LEN = 100;\nint arr [ ARRAY_LEN ];\nint *p = arr ;\nint *q = & arr [0];\nNow p and q point to exactly the same location as arr (ie. arr[0]), and p, q and arr\ncan be used interchangeably. You can also make a pointer to some element in the middle of\nan array (similarly to q):\n1 int *z = &arr [10];\n1.4\nGlobal Scope\nWe discussed in lecture how variables can be declared at global scope or file scope - if a\nvariable is declared outside of any function, it can be used anywhere in the file. For anything\nbesides global constants such as error codes or fixed array sizes, this is usually a bad idea; if\nyou need to access the same variable from multiple functions, most often you should simply\n\npass the variable around as an argument between the functions. Avoid global variables when\nyou can.\nA Simple Function\nWhat would the following program print out? (Answer without using a computer.)\n1 void f( const int a = 5)\n2 {\nstd :: cout << a *2 << \"\\n\";\n4 }\n6 int a = 123;\n7 int main ()\n8 {\nf (1) ;\nf(a);\nint b = 3;\nf(b);\nint a = 4;\nf(a);\nf () ;\n16 }\nFix the Function\nIdentify the errors in the following programs, and explain how you would correct them to\nmake them do what they were apparently meant to do.\n3.1\n1 #include <iostream >\n3 int main () {\nprintNum (35);\nreturn 0;\n6 }\n8 void printNum( int number) { std :: cout << number; }\n(Give two ways to fix this code.)\n\n3.2\n1 #include <iostream >\n3 void printNum () { std :: cout << number; };\n5 int main () {\nint number = 35;\nprintNum(number);\nreturn 0;\n9 }\n(Give two ways to fix this code. Indicate which is preferable and why.)\n3.3\n1 # include <iostream >\n3 void doubleNumber ( int num ) { num = num * 2;}\n5 int main () {\nint num = 35;\ndoubleNumber ( num );\nstd :: cout << num ; // Should print 70\nreturn 0;\n10 }\n(Changing the return type of doubleNumber is not a valid solution.)\n3.4\n1 #include <iostream >\n2 #include <cstdlib > // contains some math functions\n4 int difference( const int x, const int y) {\nint diff = abs(x - y); // abs(n) returns absolute value of n\n6 }\n8 int main () {\nstd :: cout << difference (24, 1238);\nreturn 0;\n11 }\n\n3.5\n1 # include <iostream >\n3 int sum ( const int x , const int y) {\nreturn x + y;\n5 }\n7 int main () {\nstd :: cout << sum (1 , 2, 3) ; // Should print 6\nreturn 0;\n10 }\n3.6\n1 #include <iostream >\n2 const int ARRAY_LEN = 10;\n4 int main () {\nint arr[ARRAY_LEN] = {10}; // Note implicit initialization of\n// other elements\nint *xPtr = arr , yPtr = arr + ARRAY_LEN - 1;\nstd :: cout << *xPtr << ' ' << *yPtr; // Should output 10 0\nreturn 0;\n10 }\nSums\nMake sure to use const arguments where appropriate throughout this problem (and all the\nothers).\n4.1\nWrite a single sum function that returns the sum of two integers. Also write the equivalent\nfunction for taking the sum of two doubles.\nExplain why, given your functions from part 1, sum(1, 10.0) is a syntax error. (Hint: Think\nabout promotion and demotion - the conversion of arguments between types in a function\ncall. Remember that the compiler converts between numerical types for you if necessary.) [1\npoint]\n4.2\n\n4.3\nWrite 2 more functions such that you can find the sum of anywhere between 2 and 4 integers\nby writing sum(num1, num2, ...).\n4.4\nNow write just one function that, using default arguments, allows you to take the sum of\nanywhere between 2 and 4 integers. What would happen if you put both this definition and\nyour 3-argument function from part 3 into the same file, and called sum(3, 5, 7)? Why?\n4.5\nWrite a single sum function capable of handling an arbitrary number of integers. It should\ntake two arguments, include a loop, and return an integer. (Hint: What data types can you\nuse to represent an arbitrarily large set of integers in two arguments?)\n4.6\nNow rewrite your function from 4.5 to use recursion instead of a loop. The function signature\nshould not change. Thinking about pointer arithmetic may help you.\nCalculating Ï€\nThis problem is a bit tricky, but it's a good exercise in writing a program that actually does\nsomething neat. It will also familiarize you with using random numbers.\nUsing a \"Monte Carlo\" method - that is, a randomized simulation - we can compute a\ngood approximation of Ï€. Consider a circle of radius 1, centered on the origin and circum\nscribed by a square, like so:\nImagine that this is a dartboard and that you are tossing darts at it randomly. With\nenough darts, the ratio of darts in the circle to total darts thrown should be the ratio between\ntotal darts\nthe area of the circle (call it a) and the area of the square (4):\n=\n. We can use\ndarts in circle\na\nthis ratio to calculate a, from which we can then find Ï€ =\na\n2 .\nr\nWe can simplify the math by only considering the first quadrant, calculating the ratio of\nthe top right square's area to the area of the single quadrant. Thus, we will actually find a\n4 ,\na\nand then compute Ï€ = 4 Ã— r\n2 .\nWe'll build a function step by step to do all this.\n}1\n\n5.1\nDefine variables to store the x and y coordinates of a particular dart throw. Initialize them\nto random doubles in the range [0, 1] (simulating one dart throw). (Hint: remember that\nrand() returns a value in the range [0, RAND MAX]; we just want to convert that value to\nsome value in [0, 1].)\n5.2\nPlace your x and y declarations in a loop to simulate multiple dart throws. Assume you have\na variable n indicating how many throws to simulate. Maintain a count (declared outside\nthe loop) of how many darts have ended up inside the circle. (You can check whether a dart\nis within a given radius with the Euclidean distance formula, d2 = x 2 + y 2; you may find the\nsqrt function from the <cmath> header useful.)\n5.3\nNow use your loop to build a Ï€-calculating function. The function should take one argument\nspecifying the number of dart throws to run (n from part 2). It should return the decimal\nvalue of pi, using the technique outlined above. Be sure to name your function appropriately.\nDon't forget to initialize the random number generator with a seed. You should get pretty\ngood results for around 5,000,000 dart throws.\nArray Operations\n6.1\nWrite a function printArray to print the contents of an integer array with the string \", \"\nbetween elements (but not after the last element). Your function should return nothing.\n6.2\nWrite a reverse function that takes an integer array and its length as arguments. Your\nfunction should reverse the contents of the array, leaving the reversed values in the original\narray, and return nothing.\n6.3\nAssume the existence of two constants WIDTH and LENGTH. Write a function with the following\nsignature:\nvoid transpose( const int input [][ LENGTH], int output [][ WIDTH ]);\n\nYour function should transpose the WIDTH Ã— LENGTH matrix in input, placing the LENGTH Ã—\nWIDTH transposed matrix into output. (See http://en.wikipedia.org/wiki/Transpose#Examples\nfor examples of what it means to transpose a matrix.)\n6.4\nWhat would happen if, instead of having output be an \"out argument,\" we simply declared\na new array within transpose and returned that array?\n6.5\nRewrite your function from part 2 to use pointer-offset notation instead of array-subscript\nnotation.\nPointers and Strings\n7.1\nWrite a function that returns the length of a string (char *), excluding the final NULL\ncharacter. It should not use any standard-library functions. You may use arithmetic and\ndereference operators, but not the indexing operator ([]).\n7.2\nWrite a function that swaps two integer values using call-by-reference.\n7.3\nRewrite your function from part 2 to use pointers instead of references.\n7.4\nWrite a function similar to the one in part 3, but instead of swapping two values, it swaps\ntwo pointers to point to each other's values. Your function should work correctly for the\nfollowing example invocation:\n1 int x = 5, y = 6;\n2 int * ptr1 = &x , * ptr2 = &y;\n3 swap (& ptr1 , & ptr2 );\n4 cout << * ptr1 << ' ' << * ptr2 ; // Prints \"6 5\"\n\n7.5\nAssume that the following variable declaration has already been made:\n1 char *oddOrEven = \"Never odd or even \";\nWrite a single statement to accomplish each of the following tasks (assuming for each one\nthat the previous ones have already been run). Make sure you understand what happens in\neach of them.\n1. Create a pointer to a char value named nthCharPtr pointing to the 6th character of\noddOrEven (remember that the first item has index 0). Use the indexing operator.\n2. Using pointer arithmetic, update nthCharPtr to point to the 4th character in oddOrEven.\n3. Print the value currently pointed to by nthCharPtr.\n4. Create a new pointer to a pointer (a char **) named pointerPtr that points to\nnthCharPtr.\n5. Print the value stored in pointerPtr.\n6. Using pointerPtr, print the value pointed to by nthCharPtr.\n7. Update nthCharPtr to point to the next character in oddOrEven (i.e. one character\npast the location it currently points to).\n8. Using pointer arithmetic, print out how far away from the character currently pointed\nto by nthCharPtr is from the start of the string.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_assn03.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/c335118f84da60229ca2a206db2d3a6f_MIT6_096IAP11_assn03.pdf",
      "content": "6.096 Problem Set 3\nAdditional Material\n1.1\nArrays of class objects\nAn array of class objects is similar to an array of some other data type. To create an array\nof Points, we write\nPoint parray [4];\nTo access the object at position i of the array, we write\nparray[i]\nand to call a method on that object method, we write\nparray[i]. methodName(arg1 , arg2 , ...);\nTo initialize an array of objects whose values are known at compile time, we can write\nPoint parray [4] = {Point (0 ,1), Point (1 ,2), Point (3 ,5), Point (8 ,13)};\nWe can also allocate an array of objects dynamically using the new operator (this implicitly\ncalls the default constructor of each new Point):\nPoint* parray = new Point [4];\n1.2\nStatic members and variables\nStatic data members of a class are also known as \"class variables,\" because there is only one\nunique value for all the objects of that class. Their content is not different from one object\nof this class to another.\nFor example, it may be used for a variable within a class that can contain a counter with\nthe number of objects of the class that are currently allocated, as in the following example:\n1 #include <iostream >\n3 using namespace std ;\n5 class CDummy\n6 {\n\n7 public :\nstatic int n;\nCDummy () { ++n; }\n~CDummy () { --n; }\n11 };\n13 int CDummy ::n = 0;\n15 int main ()\n16 {\nCDummy a;\nCDummy b[5];\nCDummy* c = new CDummy;\ncout << a.n << \"\\n\"; // prints out 7\ndelete c;\ncout << CDummy ::n << \"\\n\"; // prints out 6\nreturn 0;\n24 }\nIn fact, static members have the same properties as global variables, but they can only be\nreferenced via the class: either in class methods, via a class instance (someObject.staticVariable,\nor via the className::variable construct.\nBecause these variables are global, if we were to initialize them in a header file we could\nend up with that initialization being compiled multiple times (once per time we include the\nheader). To avoid this, we only include a static member's \"prototype\" (its declaration) in\nthe class declaration, but not its definition (its initialization). This is why line 13 above is\nnecessary, and why if we were to provide a header file for CDummy, we would still need to put\nline 13 in a separate .cpp file. If you get linker errors saying a static int is undefined,\ncheck to see whether you've included a line like line 13 in a .cpp file.\nClasses can also have static member functions - that is, member functions which are\nassociated with the class but do not operate on a particular class instance. Such member\nfunctions may not access non-static data members. For instance, we might replace CDummy\nabove with the following class definition:\n1 class CDummy\n2 {\n3 private :\nstatic int n;\n5 public :\nCDummy () { ++n; }\n~CDummy () { --n; }\nstatic int getN () {return n;}\n9 };\ngetN could then be called as c->getN() or CDummy::getN().\n\n1.3\nconst member functions\nIt is clear what const-ness means for a simple value like an int, but it is not clear what\nfunctions should be available on a const object, since functions may allow modifications in\nsubtle ways that ought to be forbidden on const objects. To specify to the compiler that\na given member function is safe to call on const objects, you can declare the function with\nthe const keyword. This specifies that the function is a \"read-only\" function that does not\nmodify the object on which it is called.\nTo declare a const member function, place the const keyword after the closing paren\nthesis of the argument list. The const keyword is required in both the prototype and the\ndefinition. A const member function cannot modify any data members or call any member\nfunctions that aren't also declared const. Generally, const member functions should return\nconst values, since they often return references/pointers to internal data, and we wouldn't\nwant to allow someone to get a modifiable reference to the data of a const object.\n1 const string &Person :: getName () const {\nreturn name ;\n// Doesn 't modify anything ; trying to modify a\n// data member from here would be a syntax error\n4 }\nIf an object of class Person would be declared as const Person jesse;, no non-const\nmember functions could be called on it. In other words, the set of const member functions\nof a class defines the set of operations that can be performed on const objects of that class.\n1.4\nString objects\nManipulating strings as char * or char[] types tends to be unwieldy. In particular, it is\ndifficult to perform modifications on strings that change their length; this requires reallo\ncating the entire array. It is also very difficult to deal with strings whose maximum length\nis not known ahead of time. Many C++ classes have been created to solve such problems.\nThe C++ standard library includes one such class, appropriately called string, defined in\nheader file string under namespace std.\nThe string class allows us to do all sorts of nifty operations:\n1 #include <string >\n2 ...\n3 string s = \"Hello \";\n4 s += \" world!\";\n5 if (s == \"Hello world!\") {\ncout << \"Success!\" << endl;\n7 }\n8 cout << s.substr (6, 6) << endl; // Prints \"world !\"\n9 cout << s.find(\"world \"); // (prints \"6\")\n10 cout << s.find( 'l ', 5); // (prints \"9\")\nA line-by-line description of the string features this code demonstrates:\n\n3. We can set strings to normal char *'s.\n4. We can use the + operator to append things to a string. Don't worry about how this\nworks for now; we'll see in Lecture 9 how to allow your classes to do things like this.)\n5. We can use the == operator to test whether two strings are the same. (If we tried to\ndo this with char *'s, we'd just be checking whether they point to the same string\nin memory, not whether the pointed-to strings have the same contents. To check for\nstring equality with char *'s, you need to use the function strcmp.)\n8. We can get a new string object that is a substring of the old one.\n9. We can find the index a given string within the string object.\n10. We can find a character as well, and we can specify a starting location for the search.\nTake a few minutes to play around with the string class. Look at the documentation\nat http://www.cplusplus.com/reference/string/string/. In particular, be sure to understand\nthe behavior of the substr function.\n1.5\nType Conversions and Constructors\nAny time you call a function, the compiler will do its best to match the arguments you\nprovide with some function definition. As a last-ditch strategy, it will even try constructing\nobjects for you.\nSay you have a function f that takes a Coordinate object, and that the Coordinate\nconstructor is defined to take one double. If you call f(3.4), the compiler will notice that\nthere is no f that takes a double; however, it will also see that it can match the f that\nit found by converting your argument to a Coordinate object. Thus, it will automatically\nturn your statement into f(Coordinate(3.4)).\nThis applies to constructors, as well. Say you have a Point class, whose constructor\ntakes two Coordinates. If you write Point p(2.3, 0.5);, the compiler will automatically\nturn your statement into Point p(Coordinate(2.3), Coordinate(2.5);.\n1.6\nSources\n- http://www.cplusplus.com/\n\n2.1\nCatch that bug\nIn this section, the following snippets will have bugs. Identify them and indicate how to\ncorrect them. Do these without the use of a computer!\n1 ...\n2 class Point\n3 {\n4 private :\nint x , y;\n7 public :\nPoint ( int u , int v) : x(u) , y(v) {}\nint getX () { return x; }\nint getY () { return y; }\nvoid doubleVal ()\n{\nx *= 2;\ny *= 2;\n}\n16 };\n18 int main ()\n19 {\nconst Point myPoint (5 , 3)\nmyPoint . doubleVal () ;\ncout << myPoint . getX () << \" \" << myPoint . getY () << \"\\n\";\nreturn 0;\n24 }\n2.2\n1 ...\n2 class Point\n3 {\n4 private :\nint x , y;\n7 public :\nPoint ( int u , int v) : x(u) , y(v) {}\nint getX () { return x; }\nint getY () { return y; }\n\nvoid setX ( int newX ) const { x = newX ; }\n12 };\n14 int main ()\n15 {\nPoint p (5 , 3) ;\np. setX (9001) ;\ncout << p. getX () << ' ' << p. getY () ;\nreturn 0;\n20 }\n2.3\n1 ...\n2 class Point\n3 {\n4 private :\nint x, y;\n7 public :\nPoint( int u, int v) : x(u), y(v) {}\nint getX () { return x; }\nint getY () { return y; }\n11 };\n13 int main ()\n14 {\nPoint p(5, 3);\ncout << p.x << \" \" << p.y << \"\\n\";\nreturn 0;\n18 }\n2.4\n1 ...\n2 class Point\n3 {\n4 private :\nint x , y;\n7 public :\nPoint ( int u , int v) : x(u) , y(v) {}\nint getX () { return x; }\n\nvoid setX( int newX);\n11 };\n13 void setX( int newX){ x = newX; }\n15 int main ()\n16 {\nPoint p(5, 3);\np.setX (0);\ncout << p.getX () << \" \" << \"\\n\";\nreturn 0;\n21 }\n2.5\n1 ...\n2 int size;\n3 cin >> size;\n4 int *nums = new int [size ];\n5 for (int i = 0; i < size; ++i)\n6 {\ncin >> nums[i];\n8 }\n9 ... // Calculations with nums omitted\n10 delete nums;\n11 ...\n2.6\n1 class Point\n2 {\n3 private :\nint x , y;\n6 public :\nPoint ( int u , int v) : x(u) , y(v) {}\nint getX () { return x; }\nint getY () { return y; }\n10 };\n12 int main ()\n13 {\nPoint *p = new Point (5 , 3) ;\n\ncout << p -> getX () << ' ' << p -> getY () ;\nreturn 0;\n17 }\n(Hint: this bug is a logic error, not a syntax error.)\nPoint\nFor the next several problems, you should put your class definitions and function proto\ntypes in a header file called geometry.h, and your function definitions in a file called\ngeometry.cpp. If your functions are one-liners, you may choose to include them in the\nheader file.\nIn this section you will implement a class representing a point, appropriately named\nPoint.\n3.1\nFoundation\nCreate the class with two private ints. Name them x and y.\n3.2\nConstructors\nImplement a single constructor that, if called with 0 arguments, initializes a point to the\norigin - (0, 0) - but if called with two arguments x and y, creates a point located at (x, y).\n(Hint: You will need to use default arguments.\n3.3\nMember Functions\nSupport the following operations using the given function signatures:\nGet the x coordinate\n-\nint Point::getX() const\n- Get the y coordinate\nint Point::getY() const\nSet the x coordinate\n-\nvoid Point::setX(const int new x)\n- Set the y coordinate\nvoid Point::setY(const int new y)\n\nPointArray\nIn this section you will implement a class representing an array of Points. It will allow\ndynamically resizing the array, and it will track its own length so that if you were to pass it\nto a function, you would not need to pass its length separately.\n4.1\nFoundation\nCreate the class with two private members, a pointer to the start of an array of Points and\nan int that stores the size (length) of the array.\n4.2\nConstructors\nImplement the default constructor (a constructor with no arguments) with the following\nsignature. It should create an array with size 0.\nImplement a constructor that takes a Point array called points and an int called size\nas its arguments. It should initialize a PointArray with the specified size, copying the values\nfrom points. You will need to dynamically allocate the PointArray's internal array to the\nspecified size.\nPointArray::PointArray(const Point points[], const int size)\nFinally, implement a constructor that creates a copy of a given PointArray (a copy\nconstructor).\nPointArray::PointArray(const PointArray& pv)\n(Hint: Make sure that the two PointArrays do not end up using the same memory for\ntheir internal arrays. Also make sure that the contents of the original array are copied, as\nwell.)\n4.3\nDestructors\nDefine a destructor that deletes the internal array of the PointArray.\nPointArray::~PointArray()\n4.4\nDealing with an ever-changing array\nSince we will allow modifications to our array, you'll find that the internal array grows\nand shrinks quite often. A simple (though very inefficient) way to deal with this without\nrepetitively writing similar code is to write a member function PointArray::resize(int\nn) that allocates a new array of size n, copies the first min(previous array size, n) existing\nelements into it, and deallocates the old array. If doing so has increased the size, it's fine\n\nfor resize to leave the new spaces uninitialized; whatever member function calls it will be\nresponsible for filling those spaces in. Then every time the array size changes at all (including\nclear), you can call this function.\nIn some cases, after you call this function, you will have to subsequently shift some of\nthe contents of the array right or left in order to make room for a new value or get rid of an\nold one. This is of course inefficient; for the purposes of this exercise, however, we won't be\nworrying about efficiency. If you wanted to do this the \"right\" way, you'd remember both\nhow long your array is and how much of it is filled, and only reallocate when you reach your\ncurrent limit or when how much is filled dips below some threshhold.\nAdd the PointArray::resize(int n) function as specified above to your PointArray\nclass. Give it an appropriate access modifier, keeping in mind that this is meant for use only\nby internal functions; the public interface is specified below.\n4.5\nMember Functions\nImplement public functions to perform the following operations:\n- Add a Point to the end of the array\nvoid PointArray::push back(const Point &p)\n- Insert a Point at some arbitrary position (subscript) of the array, shifting the elements\npast position to the right\nvoid PointArray::insert(const int position, const Point &p)\n- Remove the Point at some arbitrary position (subscript) of the array, shifting the\nremaining elements to the left\nvoid PointArray::remove(const int pos)\n- Get the size of the array\nconst int PointArray::getSize() const\n- Remove everything from the array and sets its size to 0\nvoid PointArray::clear()\n- Get a pointer to the element at some arbitrary position in the array, where positions\nstart at 0 as with arrays\nPoint *PointArray::get(const int position)\nconst Point *PointArray::get(const int position) const\nIf get is called with an index larger than the array size, there is no Point you can return\na pointer to, so your function should return a null pointer. Be sure your member functions\nall behave correctly in the case where you have a 0-length array (i.e., when your PointArray\ncontains no points, such as after the default constructor is called).\n\n4.5.1\nWhy do we need const and non-const versions of get? (Think about what would happen if\nwe only had one or the other, in particular what would happen if we had a const PointArray\nobject.)\nPolygon\nIn this section you will implement a class for a convex polygon called Polygon. A convex\npolygon is a simple polygon whose interior is a convex set; that is, if for every pair of points\nwithin the object, every point on the straight line segment that joins them is also within the\nobject.\nPolygon will be an abstract class - that is, it will be a placeholder in the class hierarchy,\nbut only its subclasses may be instantiated. Polygon will be an immutable type - that is,\nonce you create the Polygon, you will not be able to change it.\nThroughout this problem, remember to use the const modifier where appropriate.\n5.1\nFoundation\nCreate the class with two protected members: a PointArray and a static int to keep\ntrack of the number of Polygon instances currently in existence.\n5.2\nConstructors/Destructors\nImplement a constructor that creates a Polygon from two arguments: an array of Points and\nthe length of that array. Use member initializer syntax to initialize the internal PointArray\nobject of the Polygon, passing the Polygon constructor arguments to the PointArray con\nstructor. You should need just one line of code in the actual constructor body.\nImplement a constructor that creates a polygon using the points in an existing PointArray\nthat is passed as an argument. (For the purposes of this problem, you may assume that the\norder of the points in the PointArray traces out a convex polygon.) You should make sure\nyour constructor avoids the unnecessary work of copying the entire existing PointArray each\ntime it is called.\nWill the default \"memberwise\" copy constructor work here? Explain what happens to\nthe PointArray field if we try to copy a Polygon and don't define our own copy constructor.\nMake sure that your constructors and destructors are set up so that they correctly update\nthe static int that tracks the number of Polygon instances.\n5.3\nMember Functions\nImplement the following public functions according to the descriptions:\n\n- area: Calculates the area of the Polygon as a double. Make this function pure virtual,\nso that the subclasses must define it in order to be instantiated. (This makes the class\nabstract.)\n- getNumPolygons: Returns the number of Polygons currently in existence, and can be\ncalled even without referencing a Polygon instance. (Hint: Use the static int.)\n- getNumSides: Returns the number of sides of the Polygon.\n- getPoints: Returns an unmodifiable pointer to the PointArray of the Polygon.\n5.4\nRectangle\nWrite a subclass of Polygon called Rectangle that models a rectangle. Your code should\n- Allow constructing a Rectangle from two Points (the lower left coordinate and the\nupper right coordinate)\n- Allow construct a Rectangle from four ints\n- Override the Polygon::area's behavior such that the rectangle's area is calculated by\nmultiplying its length by its width, but still return the area as a double.\nBoth of your constructors should use member initializer syntax to call the base-class\nconstructor, and should have nothing else in their bodies. C++ unfortunately does not\nallow us to define arrays on the fly to pass to base-class constructors. To allow using member\ninitializer syntax, we can implement a little trick where we have a global array that we update\neach time we want to make a new array of Points for constructing a Polygon. You may\ninclude the following code snippet in your geometry.cpp file:\n1 Point constructorPoints [4];\n3 Point * updateConstructorPoints ( const Point &p1 , const Point &p2 ,\nconst Point &p3 , const Point &p4 = Point (0 ,0)) {\nconstructorPoints [0] = p1;\nconstructorPoints [1] = p2;\nconstructorPoints [2] = p3;\nconstructorPoints [3] = p4;\nreturn constructorPoints ;\n9 }\nYou can then pass the return value of updateConstructorPoints(...) (you'll need to\nfill in the arguments) as the Point array argument of the Polygon constructor. (Remember,\nthe name of an array of Ts is just a T pointer.)\n\np\n5.5\nTriangle\nWrite a subclass of Polygon called Triangle that models a triangle. Your code should\n- Construct a Triangle from three Points\n- Override the area function such that it calculates the area using Heron's formula:\nK =\ns(s - a)(s - b)(s - c)\nwhere a, b, and c are the side lengths of the triangle and s = a+\nb+c .\nUse the same trick as above for calling the appropriate base-class constructor. You should\nnot need to include any code in the actual function body.\n5.6\nQuestions\n1. In the Point class, what would happen if the constructors were private?\n2. Describe what happens to the fields of a Polygon object when the object is destroyed.\n3. Why did we need to make the fields of Polygon protected?\nFor the next question, assume you are writing a function that takes as an argument a Polygon\n* called polyPtr.\n4. Imagine that we had overridden getNumSides in each of Rectangle and Triangle.\nWhich version of the function would be called if we wrote polyPtr->getNumSides()?\nWhy?\n5.7\nPutting it All Together\nWrite a small function with signature void printAttributes(Polygon *) that prints the\narea of the polygon and prints the (x, y) coordinates of all of its points.\nFinally, write a small program (a main function) that does the following:\n- Prompts the user for the lower-left and upper-right positions of a Rectangle and\ncreates a Rectangle object accordingly\n- Prompts the user for the point positions of a Triangle and creates a Triangle object\naccordingly\n- Calls printAttributes on the Rectangle and Triangle, printing an appropriate mes\nsage first.\n\nStrings\nIn this section you will write a program that turns a given English word into Pig Latin. Pig\nLatin is a language game of alterations played in English. To form the Pig Latin version of\nan English word, the onset of the first consonant is transposed to the end of the word an an\nay is affixed. Here are the rules:\n1. In words that begin with consonant sounds, the initial consonant (if the word starts\nwith 'q', then treat 'qu' as the initial consonant) is moved to the end of the word, and\nan \"ay\" is added. For example:\n- beast : east-bay\n- dough : ough-day\n- happy : appy-hay\n- question : estion-quay\n2. In words that begin with vowel sounds, the syllable \"way\" is simply added to the end\nof the word.\nWrite a function pigLatinify that takes a string object as an argument. (You may\nassume that this string contains a single lowercase word.) It should return a new string\ncontaining the Pig Latin version of the original. (Yes, it is inefficient to copy a whole string\nin the return statement, but we won't worry about that. Also, your compiler is probably\nclever enough to do some optimizations.) You may find it useful to define a constant of type\nstring or char* called VOWELS.\nRemember that string objects allow the use of operators such as += and +.\n(Your answers for this problem should go in a separate file from geometry.h and geometry.cpp.)\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_assn04.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/5706356f2987c55d0495cf622598cf02_MIT6_096IAP11_assn04.pdf",
      "content": "6.096 Problem Set 4\nAdditional Material\n1.1\nTemplates and Header Files\nThe compiler does not compile a templated function until it encounters a use of it - until\nthat function is used with a particular type parameter, at which point it is compiled for\nthat type parameter. Because of this, if you define a templated class in a header file and\nimplement its (templated) functions in a .cpp file, the code in the .cpp file will never get\ncompiled unless you use the templated functions within that .cpp file. To solve this problem,\ntemplated classes and functions are generally just implemented in the header file, with no\n.cpp file.\n1.2\nTemplates and friend Functions\nThere are some syntax oddities when using friend functions with templated classes. In order\nto declare the function as a friend of the class, you need a function prototype (or the full\nfunction definition) to appear before the class definition. This is a problem, because you'll\noften need to have the class already defined in order for the function prototype to make\nsense. To get around this issue, when writing friend functions with templated classes, you\nshould include declarations in the following order:\n1. A templated forward declaration of the class. (A forward declaration is a statement\nlike class SomeClass;, with no class body, that just alerts the compiler that the class\ndefinition is coming.)\n2. A templated function prototype for the friend function (or the entire function defini\ntion).\n3. The full templated class definition, including the friend statement. When you write\nthe name of the function in the friend statement, you need to include an extra <> after\nit to indicate that it is a templated function (e.g., friend MyClass operator+<>(const\nMyClass &c1, const MyClass &c2;).\n4. The operator function definition, if you didn't include it above.\n\nMulti-Type min\n2.1\nUsing templates, implement a min function which returns the minimum of two elements of\nany comparable type (i.e., it takes two arguments of some type T, and works as long as values\nof type T can be compared with the < operator).\n(To test this function, you may need to omit your usual using namespace std; line,\nsince there is already an std::min function.)\n2.2\nImplement the min functionality from part 1 using only preprocessor macros. (Hint: You\nwill probably need the ternary operator - the ?: syntax.)\nCasting\nAssume you implemented Problem 5 from Problem Set 3 correctly. This would mean you\nwould have a working Polygon class, and inheriting from that a Triangle class and a\nRectangle class. Now imagine you have a pointer declared as Rectangle *rect; that has\nbeen properly initialized.\n3.1\nWrite a line of code showing how you would cast rect to a Triangle * without checking\nfor type correctness (i.e., without checking whether it actually points to a Triangle). Do\nnot use C-style casts.\n3.2\nNow write a line of code that does the same thing, but checks for type correctness and throws\nan exception or returns a null pointer if rect does not actually point to a Triangle.\nTemplated Stack\nA stack data structure stores a set of items, and allows accessing them via the following\noperations:\nPush - add a new item to the stack\n-\n- Pop - remove the most recently added item that is still in the stack (i.e. that has not\nyet been popped)\n\n- Top - Retrieve\nFor more explanation, see http://en.wikipedia.org/wiki/Stack (data structure).\n4.1\nUsing templates, implement a Stack class that can be used to store items of any type. You\ndo not need to implement any constructors or destructors; the default constructor should be\nsufficient, and you will not need to use new. Your class should support the following 3 public\nfunctions (assuming T is the parameterized type which the Stack is storing):\n- bool Stack::empty() - returns whether the stack is empty\n- void Stack::push(const T &item) - adds item to the stack\n- T &Stack::top() - returns a reference to the most-recently-added item\n- void Stack::pop() - removes the most-recently-added item from the stack\nUse an STL vector, deque, or list to implement your Stack. You may not use the\nSTL stack class. Make the member functions const where appropriate, and add const/non\nconst versions of each function for which it is appropriate. In the case where the Stack is\nempty, pop should do nothing, and top should behave exactly as normal (this will of course\ncause an error).\nWhen working with templated classes, you cannot separate the function implementations\ninto a separate .cpp file; put all your code in the class definition.\n(Hint: You can represent pushing by adding to the end of your vector, and popping by\nremoving the last element of the vector. This ensures that the popped item is always the\nmost recently inserted one that has not yet been popped.)\n4.2\nfriend Functions and Operator Overloading (Optional)\nMake a friend function that implements a + operator for Stacks. The behavior of the +\noperator should be such that when you write a + b, you get a new stack containing a's items\nfollowed by b's items (assuming a and b are both Stacks), in their original order. Thus, in\nthe following example, the contents of c would be the same as if 1, 2, 3, and 4 had been\npushed onto it in that order. (c.top() would therefore return the value 4.)\n1 Stack <int > a , b;\n2 a. push (1) ;\n3 a. push (2) ;\n4 b. push (3) ;\n5 b. push (4) ;\n6 Stack <int > c = a + b;\nPut your code for this section in the same file as for the previous one.\n\nGraph Representation (Optional)\nA graph is a mathematical data structure consisting of nodes and edges connecting them.\nTo help you visualize it, you can think of a graph as a map of \"cities\" (nodes) and \"roads\"\n(edges) connecting them. In an directed graph, the direction of the edge matters - that is,\nan edge from A to B is not also an edge from B to A. You can read more at Wikipedia:\nhttp://en.wikipedia.org/wiki/Graph (mathematics).\nOne way to represent a graph is by assigning each node a unique ID number. Then, for\neach node ID n, you can store a list of node ID's to which n has an outgoing edge. This list\nis called an adjacency list.\nWrite a Graph class that uses STL containers (vectors, maps, etc.) to represent a directed\ngraph. Each node should be represented by a unique integer (an int). Provide the following\nmember functions:\n- Graph::Graph(const vector &starts, const vector &ends)\nConstructs a Graph with the given set of edges, where starts and ends represent the\nordered list of edges' start and endpoints. For instance, consider the following graph:\nThe vectors used to initialize a Graph object representing this graph would be:\nstart: 1\nend: 2\n- int Graph::numOutgoing(const int nodeID) const\nReturns the number of outgoing edges from nodeID - that is, edges with nodeID as\nthe start point\n- const vector<int> &Graph::adjacent(const int nodeID) const\nReturns a reference to the list of nodes to which nodeID has outgoing edges\n(Hint: Use the following data type to associate adjacency lists with node ID's: map<int,\nvector<int> >. This will also allow for easy lookup of the adjacency list for a given node\nID. Note that the [] operator for maps inserts the item if it isn't already there.)\nThe constructor should throw an invalid argument exception of the two vectors are\nnot the same length. (This standard exception class is defined in header file stdexcept.) The\nother member functions should do likewise if the nodeID provided does not actually exist in\nthe graph. (Hint: Use the map::find, documented at http://www.cplusplus.com/reference/stl/map/find/.)\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_project.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/70714554292d0889f63b7d21be39d579_MIT6_096IAP11_project.pdf",
      "content": "6.096 Final Project\nProject Description\nWe would like you to demonstrate everything you have learned during this course in your\nfinal project. It should be a fully-fledged C++ program, written entirely from the scratch by\nyou, satisfying the requirements specified below. We are not forcing you to work on anything\nspecific - you can come up with any idea that you want for the final project. Possible ideas\ninclude:\n1. Games (can be multi- or single-player; no AI needed):\n- Card games (e.g. Blackjack, Poker)\nReversi\n-\nGomoku\n-\nConnect Four\n-\n- Maxit (very simple - two players just move around a grid from space to space,\nalternating turns, and each space has a number which gets added to your score;\nGoogle for more)\n2. An in-memory database (no need to save data to files) in which the user can enter/\nmodify/view records. For instance, you might make:\n- A database of MIT students, classes they take, etc., allowing adding, removing\nstudents, etc.\n- A database of sport results, fixtures, statistics, players, etc.\nRequirements\n1. Your project should be large enough to take about 10-15 hours of coding.\n2. Your project proposal needs to be approved by the staff first.\n3. Your project must make use of all of the following:\n- Classes (preferably using advanced class features such as inheritance wisely)\n\nFunctions\n-\n- STL (Standard Template Library)\n4. You may not use any other external libraries (e.g. for graphical interfaces). Generally\na good rule of thumb is that if something was not covered in this course, you should\nprobably not use it (if in doubt, email us!). Stick to a text interface.\n5. It is very important that you write easily readable, well-designed code.\n6. Include a README file, with some basic documentation and instructions on how to\nuse your program. Also include in this README what problems you had with your\nproject, what the challenges were, and what would you have done differently if you\ncould do it again.\nDeadlines\n- 23 January (Sunday) - The project proposal:\nSend us a short project proposal, sketching briefly what your project will do and\nhow it is going to satisfy the requirements. Please limit yourself to at most half\na page (the proposal won't count toward your final grade)\n- 30 January (Sunday) - The final project: Send us your project, satisfying the\nrequirements. Pack everything into a single .zip file (i.e. your code and the\nREADME file). You will get bonus points for the use of more advanced C++\nfeaures.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_sol01.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/4700c091d8a9c50cf8b2c39bd8d42717_MIT6_096IAP11_sol01.pdf",
      "content": "Lab 1 Solutions\n6.096 Staff\n\"Hello, World\" (10 points)\n2.1\nHello World I (1 point)\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nconst char * str = \"Hello , World!\";\ncout << str << \"\\n\";\nreturn 0;\n10 }\n2.2\nHello World II (9 points)\n1. for loop: (3 points)\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint N;\ncin >> N;\nfor (; N-- > 0;)\n{\ncout << \"Hello , World !\\n\";\n}\nreturn 0;\n14 }\n\n2. while loop: (3 points)\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint N;\ncin >> N;\nwhile (N -- > 0)\n{\ncout << \"Hello , World !\\n\"\n}\nreturn 0;\n14 }\n3. do...while loop: (3 points)\n#include <iostream >\nusing namespace std;\nint main ()\n{\nint N;\ncin >> N;\ndo\n{\ncout << \" Hello , World !\\ n\";\n}\nwhile (--N > 0) ;\nreturn 0;\n}\n\nMore Programs (50 points)\n3.1\nScope (10 points; 2 points each)\n1. We cannot declare the same name within a block because it will generate a compiler\nerror.\n2. The program compiles.\n3. The declaration in the inner block is used.\n4. The declaration in the outer block is used.\n5. The code will not compile because the function cout has not yet been defined. If we\nmove #include <iostream> to the top, then the code will compile.\n3.2\nBasic Statistics (10 points)\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint N;\ncout << \"Enter N: \";\ncin >> N;\nint acc = 0;\n// handle the first number separately\ncin >> acc;\nint minVal = acc;\nint maxVal = acc;\n// then process the rest of the input\nfor (int i = 1; i < N; ++i)\n{\nint a;\ncin >> a;\nacc += a;\nif (a < minVal)\n{\nminVal = a;\n}\nif (a > maxVal)\n{\n\nmaxVal = a;\n}\n}\ncout << \"Mean: \" << (double )acc/N << \"\\n\";\ncout << \"Max: \" << maxVal << \"\\n\";\ncout << \"Min: \" << minVal << \"\\n\";\ncout << \"Range: \" << (maxVal - minVal) << \"\\n\";\nreturn 0;\n39 }\n3.3\nPrime Numbers (10 points)\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nint N;\ncin >> N;\nfor (int i = 2; N > 0; ++i)\n{\nbool isPrime = true ;\nfor (int j = 2; j < i; ++j)\n{\nif (i % j == 0)\n{\nisPrime = false ;\nbreak ;\n}\n}\nif (isPrime)\n{\n--N;\ncout << i << \"\\n\";\n}\n}\nreturn 0;\n27 }\n\n3.4\nMultiples of numbers (10 points)\n3.4.1\nTernary operator (3 points)\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nwhile (1)\n{\nint N;\ncin >> N;\ncout << ((N % 5 == 0 && N >= 0) ? N/5 : -1) << \"\\n\";\n}\nreturn 0;\n14 }\n3.4.2\ncontinue (3 points)\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nwhile (1)\n{\nint N;\ncin >> N;\nif (N % 5 > 0)\n{\ncout << \" -1\\n\";\ncontinue ;\n}\ncout << N/5 << \"\\n\";\n}\nreturn 0;\n19 }\n3.4.3\nbreak (3 points)\n\n1 #include <iostream >\n3 using namespace std;\n5 int main ()\n6 {\nwhile (1)\n{\nint N;\ncin >> N;\nif (N % 5 > 0)\n{\ncout << \" -1\\n\";\ncontinue ;\n}\nif (N == -1)\n{\nbreak ;\n}\ncout << N /5 << \"\\n\";\n}\ncout << \" Goodbye !\\ n\";\nreturn 0;\n24 }\n1 extra point if all three parts are correct.\n3.5\nWhat does this program do? (10 points)\n1. Russian peasant multiplication of bob and dole. (5 points)\n2. It returns 1 and exits. The operating system would assume that something went wrong.\n(2 points)\n3. Evaluates the series\nCase N â‰¡ 0, 1 mod 4:\n12 + 22 - 32 - 42 + 52 + . . . N 2\nCase N â‰¡ 2, 3 mod 4:\n-12 - 22 + 32 + 42 - 52 - . . . N 2\nThe sign of the\n(3 points)\nN2 term is positive if N â‰¡ 0, 1 mod 4 and negative if N â‰¡ 2, 3 mod 4.\n\nFactorials Gone Wrong (40 points)\n4.1\nWriting the factorial program (5 points)\n0: 1; 1: 1; 2: 2; 9: 362880; 10: 3628800\n4.2\nBreaking the program (5 points)\nIf -1 is entered, the program will output 1, which is incorrect because the factorial function\n(or Gamma function) is not defined for negative numbers.\n4.3\nBreaking the program II (5 points)\nThe number at which the program fails depends on the system architecture; 64-bit systems\noften fail at 17. We accepted any answer around that value.\n4.4\nRewriting Factorial (10 points)\n1 #include <iostream >\n3 using namespace std;\n5 long long accumulator = 1;\n7 int main ()\n8 {\nint number;\ncout << \"Enter a number: \";\ncin >> number;\nif (number < 0)\n{\ncout << \"No negative numbers allowed !\\n\";\nreturn 1;\n}\nif (number > 20)\n{\ncout << \"Program will not produce correct result !\\n\";\n}\nfor (; number > 0; accumulator *= number --);\ncout << \"The factorial of \" << number << \" is \" << accumulator\n<< \".\\n\";\nreturn 0;\n24 }\n\n4.5\nRewriting Factorial II (10 points)\n#include <iostream >\nusing namespace std;\nint main ()\n{\nint number ;\ncout << \" Enter a number : \";\ncin >> number ;\nswitch ( number )\n{\ncase 0:\ncase 1:\ncout << \" 1\\ n\";\nbreak ;\ncase 2:\ncout << \" 2\\ n\";\nbreak ;\ncase 3:\ncout << \" 6\\ n\";\nbreak ;\ncase 4:\ncout << \" 24\\ n\";\nbreak ;\ncase 5:\ncout << \" 120\\ n\";\nbreak ;\ncase 6:\ncout << \" 720\\ n\";\nbreak ;\ncase 7:\n\"\n\"\ncout <<\n5040\\n ;\nbreak ;\ncase 8:\ncout << \"40320\\n\";\nbreak ;\ncase 9:\ncout << \"362880\\n\";\nbreak ;\ncase 10:\ncout << \"3628800\\n\";\nbreak ;\ndefault :\n\ncout << \" Input not supported !\\ n\";\nbreak ;\n}\nreturn 0;\n48 }\n4.6\nFurther Testing (5 points)\nThere are no other inputs we have to consider. Since we are dealing with the short data type\nfor storing our input number, we can separate our analysis into two cases: negative integers\nand nonnegative integers. We have modified our program to deal with negative numbers in\n4.2 and have modified our program to deal with large positive numbers in 4.4. Therefore we\ndo not have to consider any other input cases.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_sol02.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/274f7094b7018ebb378f8b285734a472_MIT6_096IAP11_sol02.pdf",
      "content": "6.096 Lab 2\nDue: 14 January 12:30:00\nJanuary 17, 2011\nA Simple Function [5 points]\nThe program prints: 2 246 6 8 10\nFix the Function [1 point/fix, so 2 points for first 2]\n3.1\nEither declare a function prototype for printNum before main, or move the definition of\nprintNum to before main.\n3.2\nEither add an int argument called number to printNum (preferable because it avoids use of\nglobal variables), or move the int number declaration to a global variable.\n3.3\nMake num a pass-by-reference parameter (i.e. add a & before its name).\n3.4\nAdd a return statement to difference returning diff (or just scrap diff altogether and\nmake the function return abs(x-y);).\n3.5\nAdd a third argument to sum.\n3.6\nAdd a * to make line 7 say int *xPtr = arr, *yPtr = ....\n\nSums\nIn this problem and all others, half a point should be deducted for not using a const argument\nwhere it would have been appropriate.\n4.1\n[4 points]\n1 int sum( const int x, const int y) {\nreturn x + y;\n3 }\n5 double sum( const double x, const double y) {\nreturn x + y;\n7 }\n4.2\n[1 point]\nMixing and matching an int with a double makes it ambiguous which one you want to call.\nThe compiler could either cast 1 to a double and call the double version of sum, or it could\ncast 10.0 to an int and call the int version.\n4.3\n[2+2 points]\n1 int sum( const int x, const int y, const int z) {\nreturn x + y + z;\n3 }\n5 int sum( const int a, const int b, const int c, const int d) {\nreturn a + b + c + d;\n7 }\n4.4\n[5 + 1 points]\n1 int sum ( const int a , const int b , const int c = 0, const int d = 0)\n{\nreturn a + b + c + d;\n3 }\nIf the given definitions were included together, the compiler would give a compile error,\nsince it cannot disambiguate between a call to the 3-argument function and a call to the\n4-argument one with a default parameter.\n\n4.5\n[5 points]\n1 int sum ( const int numbers [] , const int numbersLen ) {\nint sum = 0;\nfor ( int i = 0; i < numbersLen ; ++ i) {\nsum += numbers [i ];\n}\nreturn sum ;\n7 }\n4.6\n[8 points]\n1 int sum( const int numbers [], const int numbersLen) {\nreturn numbersLen == 0 ? 0 : numbers [0] + sum(numbers + 1,\nnumbersLen - 1);\n3 }\nCalculating Ï€\n5.1\n[3 points]\n1 double x = rand () / (double )RAND_MAX , y = rand () / (double )RAND_MAX;\n5.2\n[6 points]\n1 int dartsInCircle = 0;\n2 for (int i = 0; i < n; ++i) {\ndouble x = rand () / (double )RAND_MAX , y = rand () / (double )\nRAND_MAX;\nif ( sqrt(x*x + y*y) < 1 ) {\n++ dartsInCircle ;\n}\n7 }\n5.3\n[6 points]\ndouble computePi ( const int\nsrand ( time (0) );\nint dartsInCircle = 0;\nn) {\n\nfor ( int i = 0; i < n; ++ i) {\ndouble x = rand () / ( double ) RAND_MAX , y = rand () / ( double )\nRAND_MAX ;\nif ( sqrt (x*x + y*y) < 1 ) {\n++ dartsInCircle ;\n}\n}\n// r ^2 is 1, and a /4 = dartsInCircle /n , yielding this for pi :\nreturn dartsInCircle / static_cast < double >( n) * 4;\n14 }\nArray Operations\n6.1\n[4 points]\n1 void printArray ( const int arr [] , const int len ) {\nfor ( int i = 0; i < len ; ++ i) {\ncout << arr [i ];\nif (i < len -1) {\ncout << \" , \";\n}\n}\n8 }\n6.2\n[4 points]\n1 void reverse( int numbers [], const int numbersLen) {\nfor (int i = 0; i < numbersLen / 2; ++i) {\nint tmp = numbers[i];\nint indexFromEnd = numbersLen - i - 1;\nnumbers[i] = numbers[indexFromEnd ];\nnumbers[indexFromEnd] = tmp;\n}\n8 }\n6.3\n[6 points]\n1 void transpose( const int input [][ LENGTH], int output [][ WIDTH ]) {\nfor (int i = 0; i < WIDTH; ++i) {\nfor (int j = 0; j < LENGTH; ++j) {\n\noutput[j][i] = input[i][j];\n}\n}\n7 }\n6.4\n[2 points]\nA pointer to the first element in the array would be returned, but the array would have gone\nout of scope, making the pointer invalid.\n6.5\n[3 points]\n1 void reverse( int numbers [], const int numbersLen) {\nfor (int i = 0; i < numbersLen / 2; ++i) {\nint tmp = *( numbers + i);\nint indexFromEnd = numbersLen - i - 1;\n*( numbers + i) = *( numbers + indexFromEnd);\n*( numbers + indexFromEnd) = tmp;\n}\n8 }\nPointers and Strings\n7.1\n[5 points]\n1 int stringLength ( const char *str) {\nint length = 0;\nwhile (*( str + length) != '\\0 ') {\n++ length;\n}\nreturn length;\n7 }\n7.2\n[3 points]\n1 void swap ( int &x , int &y) {\nint tmp = x;\nx = y;\ny = tmp ;\n5 }\n\n7.3\n[4 points]\n1 void swap( int *x, int *y) {\nint tmp = *x;\n*x = *y;\n*y = tmp;\n5 }\n7.4\n[5 points]\n1 void swap( int **x, int **y) {\nint *tmp = *x;\n*x = *y;\n*y = tmp;\n5 }\n7.5\n[8 points]\n1. char *nthCharPtr = &oddOrEven[5];\n2. nthCharPtr -= 2; or nthCharPtr = oddOrEven + 3;\n3. cout << *nthCharPtr;\n4. char **pointerPtr = &nthCharPtr;\n5. cout << pointerPtr;\n6. cout << **pointerPtr;\n7. nthCharPtr++; to point to the next character in oddOrEven (i.e. one character past\nthe location it currently points to)\n8. cout << nthCharPtr - oddOrEven;\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_sol03.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/67df390ea1740f5a6c1c87552f70829e_MIT6_096IAP11_sol03.pdf",
      "content": "Lab 3 Solutions\nCatch that bug\n2.1\nLine 20 is missing a semicolon. doubleVal() cannot be applied to myPoint because myPoint\nis const.\n2.2\nLine 11 contains an error because the function is declared const, i.e. as not modifying any\ninstance variables, but it assigns x to another value.\n2.3\nx and y are private members and cannot be accessed outside of the class.\n2.4\nsetX is missing the scope; the function should be declared as void Point::setX(int newX)\n{ x = newX; }\n2.5\nDeleting a dynamically allocated array requires delete[], not delete.\n2.6\np is allocated using new, but is never deallocated with delete. Every piece of memory\nallocated with new must be deallocated somewhere with a corresponding delete.\n\nPoint\n3.1\ngeometry.h\n1 class Point {\nint x , y;\n4 public :\nPoint ( int xx =0 , int yy =0) {x = xx ; y = yy ;}\nint getX () const { return x ;}\nint getY () const { return y ;}\nvoid setX ( const int xx ) {x = xx ;}\nvoid setY ( const int yy ) {y = yy ;}\n10 };\nNote: the getX and getY functions should really have been declared as const, but we\nneglected to ask you to do this, so it's fine if you did not.\nPointArray\n4.1\ngeometry.h\nclass PointArray {\nint size;\nPoint *points;\nvoid resize( int size);\npublic :\nPointArray ();\nPointArray( const Point pts[], const int size);\nPointArray( const PointArray &pv);\n~PointArray ();\nvoid clear ();\nint getSize () const { return size ;}\nvoid push_back( const Point &p);\nvoid insert( const int pos , const Point &p);\nvoid remove( const int pos);\nPoint *get( const int pos);\nconst Point *get( const int pos) const ;\n};\n\n4.2\ngeometry.cpp\n1 #include \"geometry.h\"\n3 PointArray :: PointArray () {\nsize = 0;\npoints = new Point [0]; // Allows deleting later\n6 }\n8 PointArray :: PointArray( const Point ptsToCopy [], const int toCopySize\n) {\nsize = toCopySize;\npoints = new Point[toCopySize ];\nfor (int i = 0; i < toCopySize; ++i) {\npoints[i] = ptsToCopy[i];\n}\n14 }\n16 PointArray :: PointArray( const PointArray &other) {\n// Any code in the PointArray class has access to\n// private variables like size and points\nsize = other.size;\npoints = new Point[size ];\nfor (int i = 0; i < size; i++) {\npoints[i] = other.points[i];\n}\n24 }\n26 PointArray ::~ PointArray () {\ndelete [] points;\n28 }\n30 void PointArray :: resize( int newSize) {\nPoint *pts = new Point[newSize ];\nint minSize = (newSize > size ? size : newSize);\nfor (int i = 0; i < minSize; i++)\npts[i] = points[i];\ndelete [] points;\nsize = newSize;\npoints = pts;\n38 }\n40 void PointArray :: clear () {\nresize (0);\n42 }\n\n44 void PointArray :: push_back( const Point &p) {\nresize(size + 1);\npoints[size - 1] = p;\n// Could also just use insert(size , p);\n48 }\n50 void PointArray :: insert( const int pos , const Point &p) {\nresize(size + 1);\nfor (int i = size - 1; i > pos; i--) {\npoints[i] = points[i -1];\n}\npoints[pos] = p;\n58 }\n60 void PointArray :: remove( const int pos) {\nif (pos >= 0 && pos < size) { // pos < size implies size > 0\n// Shift everything over to the left\nfor (int i = pos; i < size - 2; i++) {\npoints[i] = points[i + 1];\n}\nresize(size - 1);\n}\n68 }\n70 Point *PointArray ::get( const int pos) {\nreturn pos >= 0 && pos < size ? points + pos : NULL;\n72 }\n74 const Point *PointArray ::get( const int pos) const {\nreturn pos >= 0 && pos < size ? points + pos : NULL;\n76 }\n4.2.1\n1. We need the const versions so that we can return read-only pointers for const PointArray\nobjects. (If the PointArray object is read-only, we don't want to allow someone to\nmodify a Point it contains just by using these functions.) However, many times we\nwill have a non-const PointArray object, for which we may want to allow modifying\nthe contained Point objects. If we had only const accessor functions, then even in\nsuch a case we would be returning a const pointer. To allow returning a non-const\npointer in situations where we might want one, we need non-const versions of these\n\nfunctions, as well.\nPolygon and friends\n5.1\nPolygon\n5.1.1\ngeometry.h\n1 class Polygon {\n2 protected :\nstatic int numPolygons ;\nPointArray points ;\n6 public :\nPolygon ( const PointArray & pa );\nPolygon ( const Point points [] , const int numPoints );\nvirtual double area () const = 0;\nstatic int getNumPolygons () { return numPolygons ;}\nint getNumSides () const { return points . getSize () ;}\nconst PointArray * getPoints () const { return & points ;}\n~ Polygon () {--numPolygons ;}\n14 };\n5.1.2\ngeometry.cpp\n1 int Polygon ::n = 0;\n3 Polygon :: Polygon( const PointArray &pa) : points(pa) {\n++ numPolygons;\n5 }\n7 Polygon :: Polygon( const Point pointArr [], const int numPoints) :\npoints(pointArr , numPoints) {\n++ numPolygons;\n9 }\n5.2\nRectangle\n5.2.1\ngeometry.h\n1 class Rectangle : public Polygon {\n2 public :\nRectangle( const Point &a, const Point &b);\n\nRectangle ( const int a , const int b , const int c , const int d);\nvirtual double area () const ;\n6 };\n5.2.2\ngeometry.cpp\n2 Point constructorPoints [4];\n4 Point * updateConstructorPoints ( const Point &p1 , const Point &p2 ,\nconst Point &p3 , const Point &p4 = Point (0 ,0)) {\nconstructorPoints [0] = p1;\nconstructorPoints [1] = p2;\nconstructorPoints [2] = p3;\nconstructorPoints [3] = p4;\nreturn constructorPoints ;\n10 }\n12 Rectangle :: Rectangle( const Point &ll , const Point &ur)\n: Polygon( updateConstructorPoints (ll , Point(ll.getX (), ur.getY ()\n),\nur , Point(ur.getX (), ll.getY ()\n)), 4) {}\n16 Rectangle :: Rectangle( const int llx , const int lly , const int urx ,\nconst int ury)\n: Polygon( updateConstructorPoints (Point(llx , lly), Point(llx ,\nury),\nPoint(urx , ury), Point(urx ,\nlly)), 4) {}\n20 double Rectangle :: area () const {\nint length = points.get (1) ->getY () - points.get (0) ->getY ();\nint width\n= points.get (2) ->getX () - points.get (1) ->getX ();\nreturn std::abs(( double )length * width);\n24 }\n(You'll need to add #include <cmath> at the top of your file to use the abs function.)\n5.3\nTriangle\n5.3.1\ngeometry.h\n1 class Triangle : public Polygon {\n\n2 public :\nTriangle( const Point &a, const Point &b, const Point &c);\nvirtual double area () const ;\n5 };\n5.4\ngeometry.cpp\n1 Triangle :: Triangle( const Point &a, const Point &b, const Point &c)\n: Polygon( updateConstructorPoints (a, b, c), 3) {}\n4 double Triangle :: area () const {\nint dx01 = points.get (0) ->getX () - points.get (1) ->getX (),\ndx12 = points.get (1) ->getX () - points.get (2) ->getX (),\ndx20 = points.get (2) ->getX () - points.get (0) ->getX ();\nint dy01 = points.get (0) ->getY () - points.get (1) ->getY (),\ndy12 = points.get (1) ->getY () - points.get (2) ->getY (),\ndy20 = points.get (2) ->getY () - points.get (0) ->getY ();\ndouble a = std:: sqrt(dx01*dx01 + dy01*dy01),\nb = std:: sqrt(dx12*dx12 + dy12*dy12),\nc = std:: sqrt(dx20*dx20 + dy20*dy20);\ndouble s = (a + b + c) / 2;\nreturn std:: sqrt( s * (s -a) * (s -b) * (s -c) );\n19 }\n5.5\nmain.cpp\n1 #include <iostream >\n2 using namespace std;\n4 #include \"geometry.h\"\n6 void printAttributes (Polygon *p) {\ncout << \"p's area is \" << p->area () << \".\\n\";\ncout << \"p's points are:\\n\";\nconst PointArray *pa = p->getPoints ();\nfor (int i = 0; i < pa ->getSize (); ++i) {\ncout << \"(\" << pa ->get(i) ->getX () << \", \" << pa ->get(i) ->\ngetY () << \")\\n\";\n}\n\n14 }\n16 int main( int argc , char *argv []) {\ncout << \"Enter lower left and upper right coords of rectangle as\nfour space separated integers: \";\nint llx , lly , urx , ury;\ncin >> llx >> lly >> urx >> ury;\nPoint ll(llx , lly), ur(urx , ury);\nRectangle r(ll , ur);\nprintAttributes (&r);\ncout << \"Enter three coords of triangle as six space separated\nintegers: \";\nint x1 , y1 , x2 , y2 , x3 , y3;\ncin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\nPoint a(x1 , y1), b(x2 , y2), c(x3 , y3);\nTriangle t(a, b, c);\nprintAttributes (&t);\nreturn 0;\n32 }\n5.6\nQuestions\n1. If the constructors were private, then we would not be able to create any Point objects.\n2. When a Polygon is destroyed, the counter for number of Polygons created is decre\nmented, and the PointArray's destructor is implicitly called.\n3. We had to make the fields of Polygon protected so that they could be accessed from\nRectangle and Triangle, but not by arbitrary outside code.\n4. The getNumSides from Polygon would be called, because the function is not virtual.\nStrings\n1 const string vowels = \" aeiou \";\n3 string pigLatinify ( const string s) {\nif (s. size () == 0) {\n// oops , empty string\nreturn s;\n}\n\nif (s.find(\"qu \") == 0) { // Starts with \"qu \"\nreturn s.substr (2, s.size () -2) + \"-\" + s.substr (0, 2) + \"ay \"\n;\n} else if ( vowels . find (s [0]) != string :: npos ) {\n// Starts with\na vowel\nreturn s + \" way \";\n} else {\nreturn s. substr (1 , s. size () -1) + \" -\" + s [0] + \" ay \";\n}\n16 }\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "MIT6_096IAP11_sol04.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/1263e1027b75471a7a3493b3abdfda59_MIT6_096IAP11_sol04.pdf",
      "content": "Lab 4 Solutions\nMulti-Type min\n2.1\n1 template <typename T>\n2 T min( const T t1 , const T t2) {\nreturn t1 < t2 ? t1 : t2;\n4 }\n2.2\n1 #define min(x, y) (x < y ? x : y)\nCasting\n3.1\nstatic_cast <Triangle *>(p)\nor\nreinterpret_cast <Triangle *>(p)\n3.2\ndynamic_cast <Triangle *>(p)\nTemplated Stack\n4.1\n\n1 template <class T> class Stack;\n3 template <class T>\n4 Stack <T> operator +( const Stack <T> &s1 , const Stack <T> &s2);\n{\nStack <T > result = s1 ;\nfor ( unsigned i = 0; i < s1 . items . size () ; ++ i) {\nresult . items . push_back ( s2 . items [i ]) ;\n}\nreturn result ;\n14 }\n16 template <class T>\n17 class Stack {\nfriend Stack <T> operator +<>( const Stack <T> &s1 , const Stack <T> &\ns2);\nvector <T> items;\n21 public :\nbool empty () const {return items.empty ();}\nvoid push( const T &item) {items.push_back(item);}\nT pop() {\nT last = items.back ();\nitems.pop_back ();\nreturn last;\n}\n29 };\n31 template <class T>\n32 Stack <T> operator +( const Stack <T> &s1 , const Stack <T> &s2)\n33 {\nStack <T> result = s1;\nfor (unsigned i = 0; i < s1.items.size (); ++i) {\nresult.items.push_back(s2.items[i]);\n}\nreturn result;\n41 }\n\nGraph Representation\n1 class Graph {\n2 protected :\nmap < int , vector <int > > outgoing;\npublic :\nGraph( const vector < int > &startPoints , const vector < int > &\nendPoints);\nint numOutgoing( const int nodeID) const ;\nconst vector <int > &adjacent( const int nodeID) const ;\n9 };\n11 // In a .cpp file ...\n13 #include <stdexcept >\nGraph :: Graph( const vector < int > &startPoints , const vector < int > &\nendPoints) {\nif (startPoints.size () != endPoints.size ()) {\nthrow invalid_argument (\"Start/end point lists differ in\nlength \");\n}\nfor ( unsigned i = 0; i < startPoints . size () ; i ++ ) {\nint start = startPoints [i], end = endPoints [i ];\noutgoing [ start ]. push_back ( end );\noutgoing [ end ]; // Just to indicate this node exists\n}\n}\n27 int Graph :: numOutgoing ( const int nodeID ) const {\nreturn adjacent ( nodeID ). size () ;\n29 }\n31 const vector <int > &Graph :: adjacent( const int nodeID) const {\nmap < int , vector <int > >:: const_iterator i = outgoing.find(nodeID)\n;\nif (i == outgoing.end()) {\nthrow invalid_argument (\"Invalid node ID \");\n}\nreturn i->second;\n37 }\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 1 Notes: Introduction",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/bc9f9f475ee617661c64a6e3d1a0c501_MIT6_096IAP11_lec01.pdf",
      "content": "6.096\nIntroduction to C++\nJanuary 4, 2011\nMassachusetts Institute of Technology\nLecture 1 Notes: Introduction\nCompiled Languages and C++\n1.1\nWhy Use a Language Like C++?\nAt its core, a computer is just a processor with some memory, capable of running tiny\ninstructions like \"store 5 in memory location 23459.\" Why would we express a program as\na text file in a programming language, instead of writing processor instructions?\nThe advantages:\n1. Conciseness: programming languages allow us to express common sequences of com\nmands more concisely. C++ provides some especially powerful shorthands.\n2. Maintainability: modifying code is easier when it entails just a few text edits, instead\nof rearranging hundreds of processor instructions. C++ is object oriented (more on\nthat in Lectures 7-8), which further improves maintainability.\n3. Portability: different processors make different instructions available. Programs writ\nten as text can be translated into instructions for many different processors; one of\nC++'s strengths is that it can be used to write programs for nearly any processor.\nC++ is a high-level language: when you write a program in it, the shorthands are sufficiently\nexpressive that you don't need to worry about the details of processor instructions. C++ does\ngive access to some lower-level functionality than other languages (e.g. memory addresses).\n1.2\nThe Compilation Process\nA program goes from text files (or source files) to processor instructions as follows:\nSource File\nObject File\nCompiler\nSource File\nObject File\nCompiler\nExecutable\nLinker\nLibraries\nProgram in Memory\nOS\nObject files are intermediate files that represent an incomplete copy of the program: each\nsource file only expresses a piece of the program, so when it is compiled into an object file,\nthe object file has some markers indicating which missing pieces it depends on. The linker\n\ntakes those object files and the compiled libraries of predefined code that they rely on, fills\nin all the gaps, and spits out the final program, which can then be run by the operating\nsystem (OS).\nThe compiler and linker are just regular programs. The step in the compilation process in\nwhich the compiler reads the file is called parsing.\nIn C++, all these steps are performed ahead of time, before you start running a program.\nIn some languages, they are done during the execution process, which takes time. This is\none of the reasons C++ code runs far faster than code in many more recent languages.\nC++ actually adds an extra step to the compilation process: the code is run through a\npreprocessor, which applies some modifications to the source code, before being fed to the\ncompiler. Thus, the modified diagram is:\nSource File\nProcessed Code\nPreprocessor\nObject File\nCompiler\nSource File\nProcessed Code\nPreprocessor\nObject File\nCompiler\nExecutable\nLinker\nLibraries\nProgram in Memory\nOS\n1.3\nGeneral Notes on C++\nC++ is immensely popular, particularly for applications that require speed and/or access\nto some low-level features. It was created in 1979 by Bjarne Stroustrup, at first as a set\nof extensions to the C programming language. C++ extends C; our first few lectures will\nbasically be on the C parts of the language.\nThough you can write graphical programs in C++, it is much hairier and less portable than\ntext-based (console) programs. We will be sticking to console programs in this course.\nEverything in C++ is case sensitive: someName is not the same as SomeName.\nHello World\nIn the tradition of programmers everywhere, we'll use a \"Hello, world!\" program as an entry\npoint into the basic features of C++.\n2.1\nThe code\n// A Hello World program\n#include <iostream >\n\nint main () {\nstd:: cout << \"Hello , world !\\n\";\nreturn 0;\n}\n2.2\nTokens\nTokens are the minimals chunk of program that have meaning to the compiler - the smallest\nmeaningful symbols in the language. Our code displays all 6 kinds of tokens, though the\nusual use of operators is not present here:\nToken type\nDescription/Purpose\nExamples\nKeywords\nWords with special meaning to\nthe compiler\nint, double, for, auto\nIdentifiers\nNames of things that are not\nbuilt into the language\ncout, std, x, myFunction\nLiterals\nBasic constant values whose\nvalue is specified directly in\nthe source code\n\"Hello, world!\", 24.3,\n0, 'c'\nOperators\nMathematical or logical oper\nations\n+, -, &&, %, <<\nPunctuation/Separators\nPunctuation\ndefining\nthe\nstructure of a program\n{ } ( ) , ;\nWhitespace\nSpaces of various sorts;\nig\nnored by the compiler\nSpaces, tabs, newlines, com\nments\n2.3\nLine-By-Line Explanation\n1. // indicates that everything following it until the end of the line is a comment: it is\nignored by the compiler. Another way to write a comment is to put it between /* and\n*/ (e.g. x = 1 + /*sneaky comment here*/ 1;). A comment of this form may span\nmultiple lines. Comments exist to explain non-obvious things going on in the code.\nUse them: document your code well!\n2. Lines beginning with # are preprocessor commands, which usually change what code\nis actually being compiled. #include tells the preprocessor to dump in the contents of\nanother file, here the iostream file, which defines the procedures for input/output.\n\n4. int main() {...} defines the code that should execute when the program starts up.\nThe curly braces represent grouping of multiple commands into a block. More about\nthis syntax in the next few lectures.\n5.\n- cout << : This is the syntax for outputting some piece of text to the screen.\nWe'll discuss how it works in Lecture 9.\n- Namespaces: In C++, identifiers can be defined within a context - sort of a\ndirectory of names - called a namespace. When we want to access an identifier\ndefined in a namespace, we tell the compiler to look for it in that namespace using\nthe scope resolution operator (::). Here, we're telling the compiler to look for\ncout in the std namespace, in which many standard C++ identifiers are defined.\nA cleaner alternative is to add the following line below line 2:\nusing namespace std;\nThis line tells the compiler that it should look in the std namespace for any\nidentifier we haven't defined. If we do this, we can omit the std:: prefix when\nwriting cout. This is the recommended practice.\n- Strings: A sequence of characters such as Hello, world is known as a string. A\nstring that is specified explicitly in a program is a string literal.\n- Escape sequences: The \\n indicates a newline character. It is an example of an\nescape sequence - a symbol used to represent a special character in a text literal.\nHere are all the C++ escape sequences which you can include in strings:\nEscape Sequence\nRepresented Character\n\\a\nSystem bell (beep sound)\n\\b\nBackspace\n\\f\nFormfeed (page break)\n\\n\nNewline (line break)\n\\r\n\"Carriage return\" (returns cursor to start of line)\n\\t\nTab\n\\\\\nBackslash\n\\'\nSingle quote character\n\\\"\nDouble quote character\n\\some integer x\nThe character represented by x\n7. return 0 indicates that the program should tell the operating system it has completed\nsuccessfully. This syntax will be explained in the context of functions; for now, just\ninclude it as the last line in the main block.\n\nNote that every statement ends with a semicolon (except preprocessor commands and blocks\nusing {}). Forgetting these semicolons is a common mistake among new C++ programmers.\nBasic Language Features\nSo far our program doesn't do very much. Let's tweak it in various ways to demonstrate\nsome more interesting constructs.\n3.1\nValues and Statements\nFirst, a few definitions:\n- A statement is a unit of code that does something - a basic building block of a program.\n- An expression is a statement that has a value - for instance, a number, a string, the\nsum of two numbers, etc. 4 + 2, x - 1, and \"Hello, world!\\n\" are all expressions.\nNot every statement is an expression.\nIt makes no sense to talk about the value of an\n#include statement, for instance.\n3.2\nOperators\nWe can perform arithmetic calculations with operators. Operators act on expressions to form\na new expression. For example, we could replace \"Hello, world!\\n\" with (4 + 2) / 3,\nwhich would cause the program to print the number 2. In this case, the + operator acts on\nthe expressions 4 and 2 (its operands).\nOperator types:\n- Mathematical: +, -, *, /, and parentheses have their usual mathematical meanings,\nincluding using - for negation. % (the modulus operator) takes the remainder of two\nnumbers: 6 % 5 evaluates to 1.\n- Logical: used for \"and,\" \"or,\" and so on. More on those in the next lecture.\n- Bitwise: used to manipulate the binary representations of numbers. We will not focus\non these.\n3.3\nData Types\nEvery expression has a type - a formal description of what kind of data its value is. For\ninstance, 0 is an integer, 3.142 is a floating-point (decimal) number, and \"Hello, world!\\n\"\n\nis a string value (a sequence of characters). Data of different types take a different amounts\nof memory to store. Here are the built-in datatypes we will use most often:\nType Names\nDescription\nSize\nRange\nchar\nSingle text character or small\ninteger. Indicated with single\nquotes ('a', '3').\n1 byte\nsigned: -128 to 127\nunsigned: 0 to 255\nint\nLarger integer.\n4 bytes\nsigned:\n-2147483648\nto\nunsigned: 0 to 4294967295\nbool\nBoolean (true/false).\nIndi\ncated with the keywords true\nand false.\n1 byte\nJust true (1) or false (0).\ndouble\n\"Doubly\"\nprecise\nfloating\npoint number.\n8 bytes\n+/- 1.7e +/- 308 ( 15 digits)\nNotes on this table:\n- A signed integer is one that can represent a negative number; an unsigned integer will\nnever be interpreted as negative, so it can represent a wider range of positive numbers.\nMost compilers assume signed if unspecified.\n- There are actually 3 integer types: short, int, and long, in non-decreasing order of\nsize (int is usually a synonym for one of the other two). You generally don't need to\nworry about which kind to use unless you're worried about memory usage or you're\nusing really huge numbers. The same goes for the 3 floating point types, float, double,\nand long double, which are in non-decreasing order of precision (there is usually some\nimprecision in representing real numbers on a computer).\n- The sizes/ranges for each type are not fully standardized; those shown above are the\nones used on most 32-bit computers.\nAn operation can only be performed on compatible types. You can add 34 and 3, but you\ncan't take the remainder of an integer and a floating-point number.\nAn operator also normally produces a value of the same type as its operands; thus, 1 / 4\nevaluates to 0 because with two integer operands, / truncates the result to an integer. To\nget 0.25, you'd need to write something like 1 / 4.0.\nA text string, for reasons we will learn in Lecture 5, has the type char *.\n\nVariables\nWe might want to give a value a name so we can refer to it later. We do this using variables.\nA variable is a named location in memory.\nFor example, say we wanted to use the value 4 + 2 multiple times. We might call it x and\nuse it as follows:\n# include <iostream >\nusing namespace std ;\nint main () {\nint x;\nx = 4 + 2;\ncout << x / 3 << ' ' << x * 2;\nreturn 0;\n}\n(Note how we can print a sequence of values by \"chaining\" the << symbol.)\nThe name of a variable is an identifier token. Identifiers may contain numbers, letters, and\nunderscores (_), and may not start with a number.\nLine 5 is the declaration of the variable x. We must tell the compiler what type x will be\nso that it knows how much memory to reserve for it and what kinds of operations may be\nperformed on it.\nLine 6 is the initialization of x, where we specify an initial value for it. This introduces a\nnew operator: =, the assignment operator. We can also change the value of x later on in the\ncode using this operator.\nWe could replace lines 5 and 6 with a single statement that does both declaration and\ninitialization:\nint x = 4 + 2;\nThis form of declaration/initialization is cleaner, so it is to be preferred.\nInput\nNow that we know how to give names to values, we can have the user of the program input\nvalues. This is demonstrated in line 6 below:\n\n# include <iostream >\nusing namespace std ;\nint main () {\nint x;\ncin >> x;\ncout << x / 3 << ' ' << x * 2;\nreturn 0;\n}\nJust as cout << is the syntax for outputting values, cin >> (line 6) is the syntax for inputting\nvalues.\nMemory trick: if you have trouble remembering which way the angle brackets go for cout\nand cin, think of them as arrows pointing in the direction of data flow. cin represents the\nterminal, with data flowing from it to your variables; cout likewise represents the terminal,\nand your data flows to it.\nDebugging\nThere are two kinds of errors you'll run into when writing C++ programs: compilation\nerrors and runtime errors. Compilation errors are problems raised by the compiler, generally\nresulting from violations of the syntax rules or misuse of types. These are often caused by\ntypos and the like.\nRuntime errors are problems that you only spot when you run the\nprogram: you did specify a legal program, but it doesn't do what you wanted it to. These\nare usually more tricky to catch, since the compiler won't tell you about them.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec02.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/ccef8a1ec946adb5179925311e276a7b_MIT6_096IAP11_lec02.pdf",
      "content": "6.096 Introduction to C++\nJanuary 5, 2011\nMassachusetts Institute of Technology\nJohn Marrero\nLecture 2 Notes: Flow of Control\nMotivation\nNormally, a program executes statements from first to last. The first statement is executed,\nthen the second, then the third, and so on, until the program reaches its end and terminates.\nA computer program likely wouldn't be very useful if it ran the same sequence of statements\nevery time it was run. It would be nice to be able to change which statements ran and when,\ndepending on the circumstances. For example, if a program checks a file for the number of\ntimes a certain word appears, it should be able to give the correct count no matter what file\nand word are given to it. Or, a computer game should move the player's character around\nwhen the player wants. We need to be able to alter the order in which a program's statements\nare executed, the control flow.\nControl Structures\nControl structures are portions of program code that contain statements within them and,\ndepending on the circumstances, execute these statements in a certain way. There are\ntypically two kinds: conditionals and loops.\n2.1\nConditionals\nIn order for a program to change its behavior depending on the input, there must a way to test\nthat input. Conditionals allow the program to check the values of variables and to execute (or\nnot execute) certain statements. C++ has if and switch-case conditional structures.\n2.1.1 Operators\nConditionals use two kinds of special operators: relational and logical. These are used to\ndetermine whether some condition is true or false.\nThe relational operators are used to test a relation between two expressions:\nOperator\nMeaning\n>\nGreater than\n>=\nGreater than or equal to\n<\nLess than\n<=\nLess than or equal to\n==\nEqual to\n!=\nNot equal to\nThey work the same as the arithmetic operators (e.g., a > b) but return a Boolean value of\neither true or false, indicating whether the relation tested for holds. (An expression that\nreturns this kind of value is called a Boolean expression.) For example, if the variables x and y\nhave been set to 6 and 2, respectively, then x > y returns true. Similarly, x < 5 returns\nfalse.\nThe logical operators are often used to combine relational expressions into more complicated\nBoolean expressions:\n\nOperator\nMeaning\n&&\nand\n||\nor\n!\nnot\nThe operators return true or false, according to the rules of logic:\na\nb\na && b\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\na\nb\na || b\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\nfalse\ntrue\ntrue\nfalse\nfalse\nfalse\nThe ! operator is a unary operator, taking only one argument and negating its value:\na\n!a\ntrue\nfalse\nfalse\ntrue\nExamples using logical operators (assume x = 6 and y = 2):\n!(x > 2) â†’ false\n(x > y) && (y > 0) â†’ true\n(x < y) && (y > 0) â†’ false\n(x < y) || (y > 0) â†’ true\nOf course, Boolean variables can be used directly in these expressions, since they hold true\nand false values. In fact, any kind of value can be used in a Boolean expression due to a\nquirk C++ has: false is represented by a value of 0 and anything that is not 0 is true. So,\n\"Hello, world!\" is true, 2 is true, and any int variable holding a non-zero value is true. This\nmeans !x returns false and x && y returns true!\n2.1.2 if, if-else and else if\nThe if conditional has the form:\nif(condition)\n{\nstatement1\nstatement2\n...\n}\n\nThe condition is some expression whose value is being tested. If the condition resolves to a\nvalue of true, then the statements are executed before the program continues on. Otherwise,\nthe statements are ignored. If there is only one statement, the curly braces may be omitted,\ngiving the form:\nif(condition)\nstatement\nThe if-else form is used to decide between two sequences of statements referred to as blocks:\nif(condition)\n{\nstatementA1\nstatementA2\n...\n}\nelse\n{\nstatementB1\nstatementB2\n...\n}\nIf the condition is met, the block corresponding to the if is executed. Otherwise, the block\ncorresponding to the else is executed. Because the condition is either satisfied or not, one of\nthe blocks in an if-else must execute. If there is only one statement for any of the blocks, the\ncurly braces for that block may be omitted:\nif(condition)\nstatementA1\nelse\nstatementB1\nThe else if is used to decide between two or more blocks based on multiple conditions:\nif(condition1)\n{\nstatementA1\nstatementA2\n...\n}\nelse if(condition2)\n{\nstatementB1\nstatementB2\n...\n}\nIf condition1 is met, the block corresponding to the if is executed. If not, then only if\ncondition2 is met is the block corresponding to the else if executed. There may be more\nthan one else if, each with its own condition. Once a block whose condition was met is\nexecuted, any else ifs after it are ignored. Therefore, in an if-else-if structure, either one or\nno block is executed.\nAn else may be added to the end of an if-else-if. If none of the previous conditions are met,\nthe else block is executed. In this structure, one of the blocks must execute, as in a normal if-\nelse.\nHere is an example using these control structures:\n\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nint x = 6;\nint y = 2;\nif(x > y)\ncout << \"x is greater than y\\n\";\nelse if(y > x)\ncout << \"y is greater than x\\n\";\nelse\ncout << \"x and y are equal\\n\";\nreturn 0;\n16 }\nThe output of this program is x is greater than y. If we replace lines 5 and 6 with\nint x = 2;\nint y = 6;\nthen the output is y is greater than x. If we replace the lines with\nint x = 2;\nint y = 2;\nthen the output is x and y are equal.\n2.1.3 switch-case\nThe switch-case is another conditional structure that may or may not execute certain\nstatements. However, the switch-case has peculiar syntax and behavior:\nswitch(expression)\n{\ncase constant1:\nstatementA1\nstatementA2\n...\nbreak;\ncase constant2:\nstatementB1\nstatementB2\n...\nbreak;\n...\ndefault:\nstatementZ1\nstatementZ2\n...\n}\nThe switch evaluates expression and, if expression is equal to constant1, then the\nstatements beneath case constant 1: are executed until a break is encountered. If\nexpression is not equal to constant1, then it is compared to constant2. If these are equal,\nthen the statements beneath case constant 2: are executed until a break is encountered. If\nnot, then the same process repeats for each of the constants, in turn. If none of the constants\nmatch, then the statements beneath default: are executed.\nDue to the peculiar behavior of switch-cases, curly braces are not necessary for cases where\n\nthere is more than one statement (but they are necessary to enclose the entire switch-case).\nswitch-cases generally have if-else equivalents but can often be a cleaner way of\nexpressing the same behavior.\nHere is an example using switch-case:\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nint x = 6;\nswitch(x) {\ncase 1:\ncout << \"x is 1\\n\";\nbreak;\ncase 2:\ncase 3:\ncout << \"x is 2 or 3\";\nbreak;\ndefault:\n}\ncout << \"x is not 1, 2, or 3\";\n20 }\nreturn 0;\nThis program will print x is not 1, 2, or 3. If we replace line 5 with int x = 2; then the\nprogram will print x is 2 or 3.\n2.2\nLoops\nConditionals execute certain statements if certain conditions are met; loops execute certain\nstatements while certain conditions are met. C++ has three kinds of loops: while, do-while,\nand for.\n2.2.1 while and do-while\nThe while loop has a form similar to the if conditional:\nwhile(condition)\n{\nstatement1\nstatement2\n...\n}\nAs long as condition holds, the block of statements will be repeatedly executed. If there is only\none statement, the curly braces may be omitted. Here is an example:\n#include <iostream>\nusing namespace std;\nint main() {\nint x = 0;\nwhile(x < 10)\nx = x + 1;\n\ncout << \"x is \" << x << \"\\n\";\n13 }\nreturn 0;\nThis program will print x is 10.\nThe do-while loop is a variation that guarantees the block of statements will be executed at\nleast once:\ndo\n{\nstatement1\nstatement2\n...\n}\nwhile(condition);\nThe block of statements is executed and then, if the condition holds, the program returns to\nthe top of the block. Curly braces are always required. Also note the semicolon after the while\ncondition.\n2.2.2 for\nThe for loop works like the while loop but with some change in syntax:\nfor(initialization; condition; incrementation)\n{\nstatement1\nstatement2\n...\n}\nThe for loop is designed to allow a counter variable that is initialized at the beginning of the\nloop and incremented (or decremented) on each iteration of the loop. Curly braces may be\nomitted if there is only one statement. Here is an example:\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nfor(int x = 0; x < 10; x = x + 1)\ncout << x << \"\\n\";\nreturn 0;\n10 }\nThis program will print out the values 0 through 9, each on its own line.\nIf the counter variable is already defined, there is no need to define a new one in the\ninitialization portion of the for loop. Therefore, it is valid to have the following:\n\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nint x = 0;\nfor(; x < 10; x = x + 1)\ncout << x << \"\\n\";\nreturn 0;\n11 }\nNote that the first semicolon inside the for loop's parentheses is still required.\nA for loop can be expressed as a while loop and vice-versa. Recalling that a for loop has the\nform\nfor(initialization; condition; incrementation)\n{\nstatement1\nstatement2\n...\n}\nwe can write an equivalent while loop as\ninitialization\nwhile(condition)\n{\nstatement1\nstatement2\n...\nincrementation\n}\nUsing our example above,\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nfor(int x = 0; x < 10; x = x + 1)\ncout << x << \"\\n\";\nreturn 0;\n10 }\nis converted to\n#include <iostream>\nusing namespace std;\nint main() {\nint x = 0;\nwhile(x < 10) {\ncout << x << \"\\n\";\nx = x + 1;\n}\nreturn 0;\n13 }\n\nThe incrementation step can technically be anywhere inside the statement block, but it is good\npractice to place it as the last step, particularly if the previous statements use the current\nvalue of the counter variable.\n2.3\nNested Control Structures\nIt is possible to place ifs inside of ifs and loops inside of loops by simply placing these\nstructures inside the statement blocks. This allows for more complicated program behavior.\nHere is an example using nesting if conditionals:\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nint x = 6;\nint y = 0;\nif(x > y) {\ncout << \"x is greater than y\\n\";\nif(x == 6)\ncout << \"x is equal to 6\\n\";\nelse\ncout << \"x is not equalt to 6\\n\";\n} else\ncout << \"x is not greater than y\\n\";\nreturn 0;\n18 }\nThis program will print x is greater than y on one line and then x is equal to 6 on the\nnext line.\nHere is an example using nested loops:\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nfor(int x = 0; x < 4; x = x + 1) {\nfor(int y = 0; y < 4; y = y + 1)\ncout << y;\ncout << \"\\n\";\n}\nreturn 0;\n12 }\nThis program will print four lines of 0123.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec03.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/1b954ce3fc96fd1168f8cd123c5748e4_MIT6_096IAP11_lec03.pdf",
      "content": "6.096 Lecture 3:\nFunctions\nHow to reuse code\n\nGeza Kovacs\n\n#include <iostream>\nusing namespace std;\n\nint main() {\nint threeExpFour = 1;\nfor (int i = 0; i < 4; i = i + 1) {\nthreeExpFour = threeExpFour * 3;\n}\ncout << \"3^4 is \" << threeExpFour << endl;\nreturn 0;\n}\n\n#include <iostream>\nusing namespace std;\n\nint main() {\nint threeExpFour = 1;\nfor (int i = 0; i < 4; i = i + 1) {\nthreeExpFour = threeExpFour * 3;\n}\ncout << \"3^4 is \" << threeExpFour << endl;\nint sixExpFive = 1;\nfor (int i = 0; i < 5; i = i + 1) {\nsixExpFive = sixExpFive * 6;\n}\ncout << \"6^5 is \" << sixExpFive << endl;\nreturn 0;\n}\n\nCopy-paste\ncoding\n\n#include <iostream>\nusing namespace std;\n\nint main() {\nint threeExpFour = 1;\nfor (int i = 0; i < 4; i = i + 1) {\nthreeExpFour = threeExpFour * 3;\n}\ncout << \"3^4 is \" << threeExpFour << endl;\nint sixExpFive = 1;\nfor (int i = 0; i < 5; i = i + 1) {\nsixExpFive = sixExpFive * 6;\n}\ncout << \"6^5 is \" << sixExpFive << endl;\nint twelveExpTen = 1;\nfor (int i = 0; i < 10; i = i + 1) {\ntwelveExpTen = twelveExpTen * 12;\n}\ncout << \"12^10 is \" << twelveExpTen << endl;\nreturn 0;\n}\n\nCopy-paste\ncoding\n(bad)\n\n#include <iostream>\nusing namespace std;\n\n// some code which raises an arbitrary integer\n// to an arbitrary power\n\nint main() {\nint threeExpFour = raiseToPower(3, 4);\ncout << \"3^4 is \" << threeExpFour << endl;\nreturn 0;\n}\nWith a\nfunction\n\nWith a\nfunction\n#include <iostream>\nusing namespace std;\n\n// some code which raises an arbitrary integer\n// to an arbitrary power\n\nint main() {\nint threeExpFour = raiseToPower(3, 4);\ncout << \"3^4 is \" << threeExpFour << endl;\nint sixExpFive = raiseToPower(6, 5);\ncout << \"6^5 is \" << sixExpFive << endl;\nreturn 0;\n}\n\nWith a\nfunction\n#include <iostream>\nusing namespace std;\n\n// some code which raises an arbitrary integer\n// to an arbitrary power\n\nint main() {\nint threeExpFour = raiseToPower(3, 4);\ncout << \"3^4 is \" << threeExpFour << endl;\nint sixExpFive = raiseToPower(6, 5);\ncout << \"6^5 is \" << sixExpFive << endl;\nint twelveExpTen = raiseToPower(12, 10);\ncout << \"12^10 is \" << twelveExpTen << endl;\nreturn 0;\n}\n\nWhy define your own functions?\n- Readability: sqrt(5) is clearer than copy-pasting\nin an algorithm to compute the square root\n- Maintainability: To change the algorithm, just\nchange the function (vs changing it\neverywhere you ever used it)\n- Code reuse: Lets other people use algorithms\nyou've implemented\n\nFunction Declaration Syntax\nint raiseToPower(int base, int exponent)\n{\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\nFunction name\n\nFunction Declaration Syntax\nint raiseToPower(int base, int exponent)\n{\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\nReturn type\n\nFunction Declaration Syntax\nint raiseToPower(int base, int exponent)\n{\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\nArgument 1\n- Argument order matters:\n- raiseToPower(2,3) is 2^3=8\n- raiseToPower(3,2) is 3^2=9\n\nFunction Declaration Syntax\nint raiseToPower(int base, int exponent)\n{\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\nArgument 2\n- Argument order matters:\n- raiseToPower(2,3) is 2^3=8\n- raiseToPower(3,2) is 3^2=9\n\nFunction Declaration Syntax\nint raiseToPower(int base, int exponent)\n{\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\nsignature\n\nFunction Declaration Syntax\nint raiseToPower(int base, int exponent)\n{\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\nbody\n\nFunction Declaration Syntax\nint raiseToPower(int base, int exponent)\n{\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\nReturn statement\n\n#include <iostream>\nusing namespace std;\n\nint raiseToPower(int base, int exponent) {\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\n\nint main() {\nint threeExpFour = raiseToPower(3, 4);\ncout << \"3^4 is \" << threeExpFour << endl;\nreturn 0;\n}\nFunction invocation\nFunction\ndeclaration\n\nReturning a value\n- Up to one value may be returned; it must be the same type as\nthe return type.\nint foo()\n{\nreturn \"hello\"; // error\n}\nchar* foo()\n{\nreturn \"hello\"; // ok\n}\n\nReturning a value\n- Up to one value may be returned; it must be the same type as\nthe return type.\n- If no values are returned, give the function a void return type\nvoid printNumber(int num) {\ncout << \"number is \" << num << endl;\n}\n\nint main() {\nprintNumber(4); // number is 4\nreturn 0;\n}\n\nReturning a value\n- Up to one value may be returned; it must be the same type as\nthe return type.\n- If no values are returned, give the function a void return type\n- Note that you cannot declare a variable of type void\nint main() {\nvoid x; // ERROR\nreturn 0;\n}\n\nReturning a value\n- Return statements don't necessarily need to be at the end.\n- Function returns as soon as a return statement is executed.\nvoid printNumberIfEven(int num) {\nif (num % 2 == 1) {\ncout << \"odd number\" << endl;\nreturn;\n}\ncout << \"even number; number is \" << num << endl;\n}\n\nint main() {\nint x = 4;\nprintNumberIfEven(x);\n// even number; number is 3\nint y = 5;\nprintNumberIfEven(y);\n// odd number\n}\n\nArgument Type Matters\n- printOnNewLine(3) works\n- printOnNewLine(\"hello\") will not compile\nvoid printOnNewLine(int x)\n{\ncout << x << endl;\n}\n\nArgument Type Matters\n- printOnNewLine(3) will not compile\n- printOnNewLine(\"hello\") works\nvoid printOnNewLine(char *x)\n{\ncout << x << endl;\n}\n\nArgument Type Matters\n- printOnNewLine(3) works\n- printOnNewLine(\"hello\") also works\nvoid printOnNewLine(int x)\n{\ncout << x << endl;\n}\n\nvoid printOnNewLine(char *x)\n{\ncout << x << endl;\n}\n\nFunction Overloading\n- Many functions with the same name, but\ndifferent arguments\n- The function called is the one whose\narguments match the invocation\n\nvoid printOnNewLine(int x)\n{\ncout << \"Integer: \" << x << endl;\n}\n\nvoid printOnNewLine(char *x)\n{\ncout << \"String: \" << x << endl;\n}\n\nFunction Overloading\n- printOnNewLine(3) prints \"Integer: 3\"\n- printOnNewLine(\"hello\") prints \"String: hello\"\nvoid printOnNewLine(int x)\n{\ncout << \"Integer: \" << x << endl;\n}\n\nvoid printOnNewLine(char *x)\n{\ncout << \"String: \" << x << endl;\n}\n\nFunction Overloading\n- printOnNewLine(3) prints \"1 Integer: 3\"\n- printOnNewLine(2, 3) prints \"2 Integers: 2 and 3\"\nvoid printOnNewLine(int x)\n{\ncout << \"1 Integer: \" << x << endl;\n}\n\nvoid printOnNewLine(int x, int y)\n{\ncout << \"2 Integers: \" << x << \" and \" << y << endl;\n}\n\n- Function declarations need to occur before invocations\nint foo()\n{\nreturn bar()*2; // ERROR - bar hasn't been declared yet\n}\n\nint bar()\n{\nreturn 3;\n}\n\n- Function declarations need to occur before invocations\n- Solution 1: reorder function declarations\n\nint bar()\n{\nreturn 3;\n}\n\nint foo()\n{\nreturn bar()*2; // ok\n}\n\n- Function declarations need to occur before invocations\n- Solution 1: reorder function declarations\n- Solution 2: use a function prototype; informs the compiler\nyou'll implement it later\n\nint bar();\n\nint foo()\n{\nreturn bar()*2; // ok\n}\n\nint bar()\n{\nreturn 3;\n}\nfunction prototype\n\n- Function prototypes should match the signature of the\nmethod, though argument names don't matter\nint square(int);\n\nint cube(int x)\n{\nreturn x*square(x);\n}\n\nint square(int x)\n{\nreturn x*x;\n}\nfunction prototype\n\n- Function prototypes should match the signature of the\nmethod, though argument names don't matter\nint square(int x);\n\nint cube(int x)\n{\nreturn x*square(x);\n}\n\nint square(int x)\n{\nreturn x*x;\n}\nfunction prototype\n\n- Function prototypes should match the signature of the\nmethod, though argument names don't matter\nint square(int z);\n\nint cube(int x)\n{\nreturn x*square(x);\n}\n\nint square(int x)\n{\nreturn x*x;\n}\nfunction prototype\n\n- Function prototypes are generally put into separate\nheader files\n- Separates specification of the function from its\nimplementation\n// myLib.h - header\n// contains prototypes\n\nint square(int);\nint cube (int);\n\n// myLib.cpp - implementation\n#include \"myLib.h\"\n\nint cube(int x)\n{\nreturn x*square(x);\n}\n\nint square(int x)\n{\nreturn x*x;\n}\n\nRecursion\n- Functions can call themselves.\n- fib(n) = fib(n-1) + fib(n-2) can be easily\nexpressed via a recursive implementation\nint fibonacci(int n) {\nif (n == 0 || n == 1) {\nreturn 1;\n} else {\nreturn fibonacci(n-2) + fibonacci(n-1);\n}\n}\n\nRecursion\n- Functions can call themselves.\n- fib(n) = fib(n-1) + fib(n-2) can be easily\nexpressed via a recursive implementation\nbase case\nint fibonacci(int n) {\nif (n == 0 || n == 1) {\nreturn 1;\n} else {\nreturn fibonacci(n-2) + fibonacci(n-1);\n}\n}\n\nRecursion\n- Functions can call themselves.\n- fib(n) = fib(n-1) + fib(n-2) can be easily\nexpressed via a recursive implementation\nrecursive step\nint fibonacci(int n) {\nif (n == 0 || n == 1) {\nreturn 1;\n} else {\nreturn fibonacci(n-2) + fibonacci(n-1);\n}\n}\n\nGlobal Variables\n- How many times is function foo() called? Use\na global variable to determine this.\n- Can be accessed from any function\nint numCalls = 0;\n\nvoid foo() {\n++numCalls;\n}\n\nint main() {\nfoo(); foo(); foo();\ncout << numCalls << endl; // 3\n}\n\nGlobal variable\n\nScope\n-\nScope: where a\nvariable was declared,\ndetermines where it\ncan be accessed from\nint numCalls = 0;\n\nint raiseToPower(int base, int exponent) {\nnumCalls = numCalls + 1;\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\n\nint max(int num1, int num2) {\nnumCalls = numCalls + 1;\nint result;\nif (num1 > num2) {\nresult = num1;\n}\nelse {\nresult = num2;\n}\nreturn result;\n}\n\nScope\n-\nScope: where a\nvariable was declared,\ndetermines where it\ncan be accessed from\n-\nnumCalls has global\nscope - can be\naccessed from any\nfunction\nint numCalls = 0;\n\nint raiseToPower(int base, int exponent) {\nnumCalls = numCalls + 1;\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\n\nint max(int num1, int num2) {\nnumCalls = numCalls + 1;\nint result;\nif (num1 > num2) {\nresult = num1;\n}\nelse {\nresult = num2;\n}\nreturn result;\n}\n\nScope\n-\nScope: where a\nvariable was declared,\ndetermines where it\ncan be accessed from\n-\nnumCalls has global\nscope - can be\naccessed from any\nfunction\n-\nresult has function\nscope - each function\ncan have its own\nseparate variable\nnamed result\nint numCalls = 0;\n\nint raiseToPower(int base, int exponent) {\nnumCalls = numCalls + 1;\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\nreturn result;\n}\n\nint max(int num1, int num2) {\nnumCalls = numCalls + 1;\nint result;\nif (num1 > num2) {\nresult = num1;\n}\nelse {\nresult = num2;\n}\nreturn result;\n}\n\nint numCalls = 0;\nint raiseToPower(int base, int exponent) {\nnumCalls = numCalls + 1;\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\n// A\nreturn result;\n}\nint max(int num1, int num2) {\nnumCalls = numCalls + 1;\nint result;\nif (num1 > num2) {\nresult = num1;\n}\nelse {\nresult = num2;\n}\n// B\nreturn result;\n}\n\nGlobal scope\nraiseToPower function scope\nmax function scope\nint\nbase\nint\nexponent\nint\nresult\nint\nnum1\nint\nnum2\nint\nresult\nint\nnumCalls\n\nint numCalls = 0;\nint raiseToPower(int base, int exponent) {\nnumCalls = numCalls + 1;\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\n// A\nreturn result;\n}\nint max(int num1, int num2) {\nnumCalls = numCalls + 1;\nint result;\nif (num1 > num2) {\nresult = num1;\n}\nelse {\nresult = num2;\n}\n// B\nreturn result;\n}\n\nGlobal scope\nraiseToPower function scope\nmax function scope\nint\nbase\nint\nexponent\nint\nresult\nint\nnum1\nint\nnum2\nint\nresult\nint\nnumCalls\nA\n- At A, variables marked in\ngreen are in scope\n\nint numCalls = 0;\nint raiseToPower(int base, int exponent) {\nnumCalls = numCalls + 1;\nint result = 1;\nfor (int i = 0; i < exponent; i = i + 1) {\nresult = result * base;\n}\n// A\nreturn result;\n}\nint max(int num1, int num2) {\nnumCalls = numCalls + 1;\nint result;\nif (num1 > num2) {\nresult = num1;\n}\nelse {\nresult = num2;\n}\n// B\nreturn result;\n}\n\n- At B, variables marked in\nblue are in scope\nGlobal scope\nraiseToPower function scope\nmax function scope\nint\nbase\nint\nexponent\nint\nresult\nint\nnum1\nint\nnum2\nint\nresult\nint\nnumCalls\nB\n\ndouble squareRoot(double num) {\ndouble low = 1.0;\ndouble high = num;\nfor (int i = 0; i < 30; i = i + 1) {\ndouble estimate = (high + low) / 2;\nif (estimate*estimate > num) {\ndouble newHigh = estimate;\nhigh = newHigh;\n} else {\ndouble newLow = estimate;\nlow = newLow;\n}\n}\nreturn (high + low) / 2;\n}\n- Loops and if/else\nstatements also have\ntheir own scopes\n- Loop counters are in the\nsame scope as the body of\nthe for loop\nsquareRoot function scope\nfor loop scope\nIf statement scope\nelse statement scope\ndouble\nlow\ndouble\nhigh\ndouble\nnum\ndouble\nestimate\nint i\ndouble\nnewHigh\ndouble\nnewLow\n\ndouble squareRoot(double num) {\ndouble low = 1.0;\ndouble high = num;\nfor (int i = 0; i < 30; i = i + 1) {\ndouble estimate = (high + low) / 2;\nif (estimate*estimate > num) {\ndouble newHigh = estimate;\nhigh = newHigh;\n} else {\ndouble newLow = estimate;\nlow = newLow;\n}\n}\n// A\nreturn estimate; // ERROR\n}\n- Cannot access variables\nthat are out of scope\n\nsquareRoot function scope\nfor loop scope\nIf statement scope\nelse statement scope\ndouble\nlow\ndouble\nhigh\ndouble\nnum\ndouble\nestimate\nint i\ndouble\nnewHigh\ndouble\nnewLow\nA\n\ndouble squareRoot(double num) {\ndouble low = 1.0;\ndouble high = num;\nfor (int i = 0; i < 30; i = i + 1) {\ndouble estimate = (high + low) / 2;\nif (estimate*estimate > num) {\ndouble newHigh = estimate;\nhigh = newHigh;\n} else {\ndouble newLow = estimate;\nlow = newLow;\n}\nif (i == 29)\nreturn estimate; // B\n}\nreturn -1; // A\n}\n- Cannot access variables\nthat are out of scope\n- Solution 1: move the\ncode\nsquareRoot function scope\nfor loop scope\nIf statement scope\nelse statement scope\ndouble\nlow\ndouble\nhigh\ndouble\nnum\ndouble\nestimate\nint i\ndouble\nnewHigh\ndouble\nnewLow\nA\nB\n\ndouble squareRoot(double num) {\ndouble low = 1.0;\ndouble high = num;\ndouble estimate;\nfor (int i = 0; i < 30; i = i + 1) {\nestimate = (high + low) / 2;\nif (estimate*estimate > num) {\ndouble newHigh = estimate;\nhigh = newHigh;\n} else {\ndouble newLow = estimate;\nlow = newLow;\n}\n}\nreturn estimate; // A\n}\n- Cannot access variables\nthat are out of scope\n- Solution 2: declare the\nvariable in a higher scope\nsquareRoot function scope\nfor loop scope\nIf statement scope\nelse statement scope\ndouble\nlow\ndouble\nhigh\ndouble\nnum\ndouble\nestimate\nint i\ndouble\nnewHigh\ndouble\nnewLow\nA\n\nPass by value vs by reference\n- So far we've been passing everything by value -\nmakes a copy of the variable; changes to the variable\nwithin the function don't occur outside the function\n// pass-by-value\nvoid increment(int a) {\na = a + 1;\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3;\nincrement(q); // does nothing\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 3\n\nPass by value vs by reference\n// pass-by-value\nvoid increment(int a) {\na = a + 1;\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3; // HERE\nincrement(q); // does nothing\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 3\nmain function scope\nq=3\n\nPass by value vs by reference\n// pass-by-value\nvoid increment(int a) { // HERE\na = a + 1;\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3;\nincrement(q); // does nothing\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 3\nmain function scope\nq=3\nincrement function scope\na=3\n\nPass by value vs by reference\n// pass-by-value\nvoid increment(int a) {\na = a + 1; // HERE\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3;\nincrement(q); // does nothing\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 3\nmain function scope\nq=3\nincrement function scope\na=4\n\nPass by value vs by reference\n- If you want to modify the original variable as\nopposed to making a copy, pass the variable by\nreference (int &a instead of int a)\n// pass-by-value\nvoid increment(int &a) {\na = a + 1;\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3;\nincrement(q); // works\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 4\n\nPass by value vs by reference\n// pass-by-value\nvoid increment(int &a) {\na = a + 1;\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3; // HERE\nincrement(q); // works\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 4\nmain function scope\nq=3\n\nPass by value vs by reference\n// pass-by-value\nvoid increment(int &a) { // HERE\na = a + 1;\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3;\nincrement(q); // works\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 4\nmain function scope\nincrement function scope\nq=3\na\n\nPass by value vs by reference\n// pass-by-value\nvoid increment(int &a) {\na = a + 1; // HERE\ncout << \"a in increment \" << a << endl;\n}\n\nint main() {\nint q = 3;\nincrement(q); // works\ncout << \"q in main \" << q << endl;\n}\nOutput\n\na in increment 4\nq in main 4\nmain function scope\nincrement function scope\nq=4\na\n\nImplementing Swap\nvoid swap(int &a, int &b) {\nint t = a;\na = b;\nb = t;\n}\n\nint main() {\nint q = 3;\nint r = 5;\nswap(q, r);\ncout << \"q \" << q << endl; // q 5\ncout << \"r \" << r << endl; // r 3\n}\n\nImplementing Swap\nvoid swap(int &a, int &b) {\nint t = a;\na = b;\nb = t;\n}\n\nint main() {\nint q = 3;\nint r = 5; // HERE\nswap(q, r);\ncout << \"q \" << q << endl; // q 5\ncout << \"r \" << r << endl; // r 3\n}\nmain function scope\nq=3\nr=5\n\nImplementing Swap\nvoid swap(int &a, int &b) { // HERE\nint t = a;\na = b;\nb = t;\n}\n\nint main() {\nint q = 3;\nint r = 5;\nswap(q, r);\ncout << \"q \" << q << endl; // q 5\ncout << \"r \" << r << endl; // r 3\n}\nmain function scope\nswap function scope\nq=3\nr=5\na\nb\n\nImplementing Swap\nvoid swap(int &a, int &b) {\nint t = a; // HERE\na = b;\nb = t;\n}\n\nint main() {\nint q = 3;\nint r = 5;\nswap(q, r);\ncout << \"q \" << q << endl; // q 5\ncout << \"r \" << r << endl; // r 3\n}\nmain function scope\nswap function scope\nq=3\nr=5\na\nb\nt=3\n\nImplementing Swap\nvoid swap(int &a, int &b) {\nint t = a;\na = b; // HERE\nb = t;\n}\n\nint main() {\nint q = 3;\nint r = 5;\nswap(q, r);\ncout << \"q \" << q << endl; // q 5\ncout << \"r \" << r << endl; // r 3\n}\nmain function scope\nswap function scope\nq=5\nr=5\na\nb\nt=3\n\nImplementing Swap\nvoid swap(int &a, int &b) {\nint t = a;\na = b;\nb = t; // HERE\n}\n\nint main() {\nint q = 3;\nint r = 5;\nswap(q, r);\ncout << \"q \" << q << endl; // q 5\ncout << \"r \" << r << endl; // r 3\n}\nmain function scope\nswap function scope\nq=5\nr=3\na\nb\nt=3\n\nReturning multiple values\n- The return statement only allows you to\nreturn 1 value. Passing output variables by\nreference overcomes this limitation.\nint divide(int numerator, int denominator, int &remainder) {\nremainder = numerator % denominator;\nreturn numerator / denominator;\n}\n\nint main() {\nint num = 14;\nint den = 4;\nint rem;\nint result = divide(num, den, rem);\ncout << result << \"*\" << den << \"+\" << rem << \"=\" << num << endl;\n// 3*4+2=12\n}\n\nLibraries\n- Libraries are generally distributed as the\nheader file containing the prototypes, and a\nbinary .dll/.so file containing the (compiled)\nimplementation\n- Don't need to share your .cpp code\n// myLib.h - header\n// contains prototypes\ndouble squareRoot(double num);\nmyLib.dll\n\nmyLib.dll\n// libraryUser.cpp - some other guy's code\n#include \"myLib.h\"\n\ndouble fourthRoot(double num) {\nreturn squareRoot(squareRoot(num));\n}\n- Library user only needs to know the function prototypes (in\nthe header file), not the implementation source code (in the\n.cpp file)\n- The Linker (part of the compiler) takes care of locating the\nimplementation of functions in the .dll file at compile time\n// myLib.h - header\n// contains prototypes\ndouble squareRoot(double num);\n\nFinal Notes\n- You don't actually need to implement\nraiseToPower and squareRoot yourself; cmath\n(part of the standard library) contains\nfunctions pow and sqrt\n#include <cmath>\n\ndouble fourthRoot(double num) {\nreturn sqrt(sqrt(num));\n}\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec04.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/33183276121549190ef4f8017b06b1b6_MIT6_096IAP11_lec04.pdf",
      "content": "6.096 Introduction to C++\nJanuary 10, 2011\nMassachusetts Institute of Technology\nJohn Marrero\nLecture 4 Notes: Arrays and Strings\nArrays\nSo far we have used variables to store values in memory for later reuse. We now explore a\nmeans to store multiple values together as one unit, the array.\nAn array is a fixed number of elements of the same type stored sequentially in memory.\nTherefore, an integer array holds some number of integers, a character array holds some\nnumber of characters, and so on. The size of the array is referred to as its dimension. To\ndeclare an array in C++, we write the following:\ntype arrayName[dimension];\nTo declare an integer array named arr of four elements, we write int arr[4];\nThe elements of an array can be accessed by using an index into the array. Arrays in C++ are\nzero-indexed, so the first element has an index of 0. So, to access the third element in arr, we\nwrite arr[2]; The value returned can then be used just like any other integer.\nLike normal variables, the elements of an array must be initialized before they can be used;\notherwise we will almost certainly get unexpected results in our program. There are several\nways to initialize the array. One way is to declare the array and then initialize some or all of\nthe elements:\nint arr[4];\narr[0] = 6;\narr[1] = 0;\narr[2] = 9;\narr[3] = 6;\nAnother way is to initialize some or all of the values at the time of declaration:\nint arr[4] = { 6, 0, 9, 6 };\nSometimes it is more convenient to leave out the size of the array and let the compiler\ndetermine the array's size for us, based on how many elements we give it:\nint arr[] = { 6, 0, 9, 6, 2, 0, 1, 1 };\nHere, the compiler will create an integer array of dimension 8.\nThe array can also be initialized with values that are not known beforehand:\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nint arr[4];\ncout << \"Please enter 4 integers:\" << endl;\nfor(int i = 0; i < 4; i++)\ncin >> arr[i];\n\ncout << \"Values in array are now:\";\nfor(int i = 0; i < 4; i++)\ncout << \" \" << arr[i];\ncout << endl;\n20 }\nreturn 0;\nNote that when accessing an array the index given must be a positive integer from 0 to n-1,\nwhere n is the dimension of the array. The index itself may be directly provided, derived from a\nvariable, or computed from an expression:\narr[5];\narr[i];\narr[i+3];\nArrays can also be passed as arguments to functions. When declaring the function, simply\nspecify the array as a parameter, without a dimension. The array can then be used as normal\nwithin the function. For example:\n0 #include <iostream>\n1 using namespace std;\n3 int sum(const int array[], const int length) {\nlong sum = 0;\nfor(int i = 0; i < length; sum += array[i++]);\nreturn sum;\n7 }\n9 int main() {\nint arr[] = {1, 2, 3, 4, 5, 6, 7};\ncout << \"Sum: \" << sum(arr, 7) << endl;\nreturn 0;\n13 }\nThe function sum takes a constant integer array and a constant integer length as its arguments\nand adds up length elements in the array. It then returns the sum, and the program prints out\nSum: 28.\nIt is important to note that arrays are passed by reference and so any changes made to the\narray within the function will be observed in the calling scope.\nC++ also supports the creation of multidimensional arrays, through the addition of more than\none set of brackets. Thus, a two-dimensional array may be created by the following:\ntype arrayName[dimension1][dimension2];\nThe array will have dimension1 x dimension2 elements of the same type and can be thought of\nas an array of arrays. The first index indicates which of dimension1 subarrays to access, and\nthen the second index accesses one of dimension2 elements within that subarray. Initialization\nand access thus work similarly to the one-dimensional case:\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nint twoDimArray[2][4];\ntwoDimArray[0][0] = 6;\ntwoDimArray[0][1] = 0;\ntwoDimArray[0][2] = 9;\n\ntwoDimArray[0][3] = 6;\ntwoDimArray[1][0] = 2;\ntwoDimArray[1][1] = 0;\ntwoDimArray[1][2] = 1;\ntwoDimArray[1][3] = 1;\nfor(int i = 0; i < 2; i++)\nfor(int j = 0; j < 4; j++)\ncout << twoDimArray[i][j];\ncout << endl;\nreturn 0;\n21 }\nThe array can also be initialized at declaration in the following ways:\nint twoDimArray[2][4] = { 6, 0, 9, 6, 2, 0, 1, 1 };\nint twoDimArray[2][4] = { { 6, 0, 9, 6 } , { 2, 0, 1, 1 } };\nNote that dimensions must always be provided when initializing multidimensional arrays, as it\nis otherwise impossible for the compiler to determine what the intended element partitioning\nis. For the same reason, when multidimensional arrays are specified as arguments to\nfunctions, all dimensions but the first must be provided (the first dimension is optional), as in\nthe following:\nint aFunction(int arr[][4]) { ... }\nMultidimensional arrays are merely an abstraction for programmers, as all of the elements in\nthe array are sequential in memory. Declaring int arr[2][4]; is the same thing as declaring\nint arr[8];.\nStrings\nString literals such as \"Hello, world!\" are actually represented by C++ as a sequence of\ncharacters in memory. In other words, a string is simply a character array and can be\nmanipulated as such.\nConsider the following program:\n1 #include <iostream>\n2 using namespace std;\n4 int main() {\nchar helloworld[] = {\n'H', 'e', 'l', 'l', 'o', ',', ' ',\n'w', 'o', 'r', 'l', 'd', '!', '\\0' };\ncout << helloworld << endl;\nreturn 0;\n11 }\nThis program prints Hello, world! Note that the character array helloworld ends with a\nspecial character known as the null character. This character is used to indicate the end of the\nstring.\nCharacter arrays can also be initialized using string literals. In this case, no null character is\nneeded, as the compiler will automatically insert one:\nchar helloworld[] = \"Hello, world!\";\n\nThe individual characters in a string can be manipulated either directly by the programmer or\nby using special functions provided by the C/C++ libraries. These can be included in a program\nthrough the use of the #include directive. Of particular note are the following:\n-\ncctype (ctype.h): character handling\n-\ncstdio (stdio.h): input/output operations\n-\ncstdlib (stdlib.h): general utilities\n-\ncstring (string.h): string manipulation\nHere is an example to illustrate the cctype library:\n1 #include <iostream>\n2 #include <cctype>\n3 using namespace std;\n5 int main() {\nchar messyString[] = \"t6H0I9s6.iS.999a9.STRING\";\nchar current = messyString[0];\nfor(int i = 0; current != '\\0'; current = messyString[++i]) {\nif(isalpha(current))\ncout << (char)(isupper(current) ? tolower(current) : current);\nelse if(ispunct(current))\ncout << ' ';\n}\ncout << endl;\nreturn 0;\n18 }\nThis example uses the isalpha, isupper, ispunct, and tolower functions from the cctype\nlibrary. The is- functions check whether a given character is an alphabetic character, an\nuppercase letter, or a punctuation character, respectively. These functions return a Boolean\nvalue of either true or false. The tolower function converts a given character to lowercase.\nThe for loop beginning at line 9 takes each successive character from messyString until it\nreaches the null character. On each iteration, if the current character is alphabetic and\nuppercase, it is converted to lowercase and then displayed. If it is already lowercase it is\nsimply displayed. If the character is a punctuation mark, a space is displayed. All other\ncharacters are ignored. The resulting output is this is a string. For now, ignore the (char)\non line 11; we will cover that in a later lecture.\nHere is an example to illustrate the cstring library:\n1 #include <iostream>\n2 #include <cstring>\n3 using namespace std;\n5 int main() {\nchar fragment1[] = \"I'm a s\";\nchar fragment2[] = \"tring!\";\nchar fragment3[20];\nchar finalString[20] = \"\";\nstrcpy(fragment3, fragment1);\nstrcat(finalString, fragment3);\nstrcat(finalString, fragment2);\ncout << finalString;\nreturn 0;\n17 }\n\nThis example creates and initializes two strings, fragment1 and fragment2. fragment3 is\ndeclared but not initialized. finalString is partially initialized (with just the null character).\nfragment1 is copied into fragment3 using strcpy, in effect initializing fragment3 to I'm a s.\nstrcat is then used to concatenate fragment3 onto finalString (the function overwrites the\nexisting null character), thereby giving finalString the same contents as fragment3. Then\nstrcat is used again to concatenate fragment2 onto finalString. finalString is displayed,\ngiving I'm a string!.\nYou are encouraged to read the documentation on these and any other libraries of interest to\nlearn what they can do and how to use a particular function properly. (One source is\nhttp://www.cplusplus.com/reference/.)\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec05.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/0240aeefb6d5fb9c0a20587ed98fa7ca_MIT6_096IAP11_lec05.pdf",
      "content": "6.096\nIntroduction to C++\nJanuary 12, 2011\nMassachusetts Institute of Technology\nLecture 5 Notes: Pointers\nBackground\n1.1\nVariables and Memory\nWhen you declare a variable, the computer associates the variable name with a particular\nlocation in memory and stores a value there.\nWhen you refer to the variable by name in your code, the computer must take two steps:\n1. Look up the address that the variable name corresponds to\n2. Go to that location in memory and retrieve or set the value it contains\nC++ allows us to perform either one of these steps independently on a variable with the &\nand * operators:\n1. &x evaluates to the address of x in memory.\n2. *( &x ) takes the address of x and dereferences it - it retrieves the value at that\nlocation in memory. *( &x ) thus evaluates to the same thing as x.\n1.2\nMotivating Pointers\nMemory addresses, or pointers, allow us to manipulate data much more flexibly; manipulat\ning the memory addresses of data can be more efficient than manipulating the data itself.\nJust a taste of what we'll be able to do with pointers:\n- More flexible pass-by-reference\n- Manipulate complex data structures efficiently, even if their data is scattered in differ\nent memory locations\n- Use polymorphism - calling functions on data without knowing exactly what kind of\ndata it is (more on this in Lectures 7-8)\n\nPointers and their Behavior\n2.1\nThe Nature of Pointers\nPointers are just variables storing integers - but those integers happen to be memory ad\ndresses, usually addresses of other variables.\nA pointer that stores the address of some\nvariable x is said to point to x. We can access the value of x by dereferencing the pointer.\nAs with arrays, it is often helpful to visualize pointers by using a row of adjacent cells to\nrepresent memory locations, as below. Each cell represents 1 block of memory. The dot-\narrow notation indicates that ptr \"points to\" x - that is, the value stored in ptr is 12314,\nx's memory address.\nptr\nx\n... 12309\n12314 ...\n2.2\nPointer Syntax/Usage\n2.2.1\nDeclaring Pointers\nTo declare a pointer variable named ptr that points to an integer variable named x:\nint *ptr = &x;\nint *ptr declares the pointer to an integer value, which we are initializing to the address\nof x.\nWe can have pointers to values of any type. The general scheme for declaring pointers is:\ndata_type *pointer_name; // Add \"= initial_value \" if applicable\npointer name is then a variable of type data type * - a \"pointer to a data type value.\"\n2.2.2\nUsing Pointer Values\nOnce a pointer is declared, we can dereference it with the * operator to access its value:\ncout << *ptr; // Prints the value pointed to by ptr ,\n// which in the above example would be x's value\nWe can use deferenced pointers as l-values:\n*ptr = 5; // Sets the value of x\n\nWithout the * operator, the identifier x refers to the pointer itself, not the value it points\nto:\ncout << ptr; // Outputs the memory address of x in base 16\nJust like any other data type, we can pass pointers as arguments to functions. The same\nway we'd say void func(int x) {...}, we can say void func(int *x){...}. Here is an\nexample of using pointers to square a number in a similar fashion to pass-by-reference:\nvoid squareByPtr ( int * numPtr ) {\n* numPtr = * numPtr * * numPtr ;\n}\nint main () {\nint x = 5;\nsquareByPtr (& x);\ncout << x; // Prints 25\n}\nNote the varied uses of the * operator on line 2.\n2.2.3\nconst Pointers\nThere are two places the const keyword can be placed within a pointer variable declaration.\nThis is because there are two different variables whose values you might want to forbid\nchanging: the pointer itself and the value it points to.\nconst int *ptr;\ndeclares a changeable pointer to a constant integer. The integer value cannot be changed\nthrough this pointer, but the pointer may be changed to point to a different constant integer.\nint * const ptr;\ndeclares a constant pointer to changeable integer data. The integer value can be changed\nthrough this pointer, but the pointer may not be changed to point to a different constant\ninteger.\nconst int * const ptr;\nforbids changing either the address ptr contains or the value it points to.\n\n2.3\nNull, Uninitialized, and Deallocated Pointers\nSome pointers do not point to valid data; dereferencing such a pointer is a runtime error.\nAny pointer set to 0 is called a null pointer, and since there is no memory location 0, it is an\ninvalid pointer. One should generally check whether a pointer is null before dereferencing it.\nPointers are often set to 0 to signal that they are not currently valid.\nDereferencing pointers to data that has been erased from memory also usually causes runtime\nerrors. Example:\nint * myFunc () {\nint phantom = 4;\nreturn & phantom ;\n}\nphantom is deallocated when myFunc exits, so the pointer the function returns is invalid.\nAs with any other variable, the value of a pointer is undefined until it is initialized, so it\nmay be invalid.\nReferences\nWhen we write void f(int &x) {...} and call f(y), the reference variable x becomes\nanother name - an alias - for the value of y in memory. We can declare a reference variable\nlocally, as well:\nint y;\nint &x = y; // Makes x a reference to , or alias of , y\nAfter these declarations, changing x will change y and vice versa, because they are two names\nfor the same thing.\nReferences are just pointers that are dereferenced every time they are used. Just like point\ners, you can pass them around, return them, set other references to them, etc. The only\ndifferences between using pointers and using references are:\n- References are sort of pre-dereferenced - you do not dereference them explicitly.\n- You cannot change the location to which a reference points, whereas you can change\nthe location to which a pointer points. Because of this, references must always be\ninitialized when they are declared.\n- When writing the value that you want to make a reference to, you do not put an &\nbefore it to take its address, whereas you do need to do this for pointers.\n\n3.1\nThe Many Faces of * and &\nThe usage of the * and & operators with pointers/references can be confusing. The * operator\nis used in two different ways:\n1. When declaring a pointer, * is placed before the variable name to indicate that the\nvariable being declared is a pointer - say, a pointer to an int or char, not an int or\nchar value.\n2. When using a pointer that has been set to point to some value, * is placed before the\npointer name to dereference it - to access or set the value it points to.\nA similar distinction exists for &, which can be used either\n1. to indicate a reference data type (as in int &x;), or\n2. to take the address of a variable (as in int *ptr = &x;).\nPointers and Arrays\nThe name of an array is actually a pointer to the first element in the array.\nWriting\nmyArray[3] tells the compiler to return the element that is 3 away from the starting el\nement of myArray.\nThis explains why arrays are always passed by reference: passing an array is really passing\na pointer.\nThis also explains why array indices start at 0: the first element of an array is the element\nthat is 0 away from the start of the array.\n4.1\nPointer Arithmetic\nPointer arithmetic is a way of using subtraction and addition of pointers to move around\nbetween locations in memory, typically between array elements. Adding an integer n to a\npointer produces a new pointer pointing to n positions further down in memory.\n4.1.1\nPointer Step Size\nTake the following code snippet:\nlong arr [] = {6 ,\nlong * ptr = arr ;\nptr ++;\n0, 9, 6};\n\nlong *ptr2 = arr + 3;\nWhen we add 1 to ptr in line 3, we don't just want to move to the next byte in memory,\nsince each array element takes up multiple bytes; we want to move to the next element in\nthe array. The C++ compiler automatically takes care of this, using the appropriate step\nsize for adding to and subtracting from pointers. Thus, line 3 moves ptr to point to the\nsecond element of the array.\nSimilarly, we can add/subtract two pointers: ptr2 - ptr gives the number of array elements\nbetween ptr2 and ptr (2). All addition and subtraction operations on pointers use the\nappropriate step size.\n4.1.2\nArray Access Notations\nBecause of the interchangeability of pointers and array names, array-subscript notation (the\nform myArray[3]) can be used with pointers as well as arrays. When used with pointers, it\nis referred to as pointer-subscript notation.\nAn alternative is pointer-offset notation, in which you explicitly add your offset to the pointer\nand dereference the resulting address. For instance, an alternate and functionally identical\nway to express myArray[3] is *(myArray + 3).\n4.2\nchar * Strings\nYou should now be able to see why the type of a string value is char *: a string is actually\nan array of characters. When you set a char * to a string, you are really setting a pointer\nto point to the first character in the array that holds the string.\nYou cannot modify string literals; to do so is either a syntax error or a runtime error,\ndepending on how you try to do it. (String literals are loaded into read-only program memory\nat program startup.)\nYou can, however, modify the contents of an array of characters.\nConsider the following example:\nchar courseName1 [] = {'6 ', '. ', '0 ', '9 ', '6 ', '\\0 ' };\nchar *courseName2 = \"6.096 \";\nAttempting to modify one of the elements courseName1 is permitted, but attempting to\nmodify one of the characters in courseName2 will generate a runtime error, causing the\nprogram to crash.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec06.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/a251375959c9498dec0d1204bc20bbd3_MIT6_096IAP11_lec06.pdf",
      "content": "6.096 Lecture 6:\nUser-defined Datatypes\nclasses and structs\n\nGeza Kovacs\n\nRepresenting a (Geometric) Vector\n- In the context of geometry, a\nvector consists of 2 points: a\nstart and a finish\n- Each point itself has an x and y\ncoordinate\nStart =\n(0.4, 0.8)\nEnd =\n(0.9, 1.5)\n\nRepresenting a (Geometric) Vector\n- Our representation so far? Use\n4 doubles (startx, starty, endx,\nendy)\n- We need to pass all 4 doubles\nto functions\nStart =\n(0.4, 0.8)\nEnd =\n(0.9, 1.5)\n\nint main() {\ndouble xStart = 1.2;\ndouble xEnd = 2.0;\ndouble yStart = 0.4;\ndouble yEnd = 1.6;\n}\nStart =\n(1.2, 0.4)\nEnd =\n(2.0, 1.6)\n\nvoid printVector(double x0, double x1, double y0, double y1) {\ncout << \"(\" << x0 << \",\" << y0 << \") -> (\"\n<< x1 << \",\" << y1 << \")\" << endl;\n}\n\nint main() {\ndouble xStart = 1.2;\ndouble xEnd = 2.0;\ndouble yStart = 0.4;\ndouble yEnd = 1.6;\nprintVector(xStart, xEnd, yStart, yEnd);\n// (1.2,2.0) -> (0.4,1.6)\n}\n\nvoid offsetVector(double &x0, double &x1, double &y0, double &y1,\ndouble offsetX, double offsetY) {\nx0 += offsetX;\nx1 += offsetX;\ny0 += offsetY;\ny1 += offsetY;\n}\n\nvoid printVector(double x0, double x1, double y0, double y1) {\ncout << \"(\" << x0 << \",\" << y0 << \") -> (\"\n<< x1 << \",\" << y1 << \")\" << endl;\n}\n\nint main() {\ndouble xStart = 1.2;\ndouble xEnd = 2.0;\ndouble yStart = 0.4;\ndouble yEnd = 1.6;\noffsetVector(xStart, xEnd, yStart, yEnd, 1.0, 1.5);\nprintVector(xStart, xEnd, yStart, yEnd);\n// (2.2,1.9) -> (3.8,4.3)\n}\nMany variables being passed to\nfunctions\n\nclass\n- A user-defined datatype which groups\ntogether related pieces of information\nVector\nxStart\nxEnd\nyStart\nyEnd\n\nclass definition syntax\nname\nclass Vector {\npublic:\ndouble xStart;\ndouble xEnd;\ndouble yStart;\ndouble yEnd;\n};\n- This indicates that the new datatype we're\ndefining is called Vector\n\nclass definition syntax\nclass Vector {\npublic:\ndouble xStart;\ndouble xEnd;\ndouble yStart;\ndouble yEnd;\n};\nfields\n- Fields indicate what related pieces of\ninformation our datatype consists of\n- Another word for field is members\n\nFields can have different types\nclass MITStudent {\npublic:\nchar *name;\nint studentID;\n};\nMITStudent\nname\nstudentID\n\nInstances\n- An instance is an occurrence of a class.\nDifferent instances can have their own set of\nvalues in their fields.\n- If you wanted to represent 2 different\nstudents (who can have different names and\nIDs), you would use 2 instances of MITStudent\nstudent1\nname\n= ?\nstudentID\n= ?\nstudent2\nname\n= ?\nstudentID\n= ?\n\nDeclaring an Instance\n- Defines 2 instances of MITStudent: one called\nstudent1, the other called student2\nclass MITStudent {\npublic:\nchar *name;\nint studentID;\n};\n\nint main() {\nMITStudent student1;\nMITStudent student2;\n}\nstudent1\nstudent2\nname\n= ?\nstudentID\n= ?\nname\n= ?\nstudentID\n= ?\n\nAccessing Fields\n- To access fields of instances, use\nvariable.fieldName\nclass MITStudent {\npublic:\nchar *name;\nint studentID;\n};\n\nint main() {\nMITStudent student1;\nMITStudent student2;\nstudent1.name = \"Geza\";\n}\nstudent1\nstudent2\nname\n= \"Geza\"\nstudentID\n= ?\nname\n= ?\nstudentID\n= ?\n\nstudent1\nstudent2\nname\n= \"Geza\"\nstudentID\n= 123456789\nname\n= ?\nstudentID\n= ?\nAccessing Fields\n- To access fields of instances, use\nvariable.fieldName\nclass MITStudent {\npublic:\nchar *name;\nint studentID;\n};\n\nint main() {\nMITStudent student1;\nMITStudent student2;\nstudent1.name = \"Geza\";\nstudent1.studentID = 123456789;\n}\n\nstudent1\nstudent2\nname\n= \"Geza\"\nstudentID\n= 123456789\nname\n= ?\nstudentID\n= ?\nAccessing Fields\n- To access fields of instances, use\nvariable.fieldName\nclass MITStudent {\npublic:\nchar *name;\nint studentID;\n};\n\nint main() {\nMITStudent student1;\nMITStudent student2;\nstudent1.name = \"Geza\";\nstudent1.studentID = 123456789;\nstudent2.name = \"Jesse\";\nstudent2.studentID = 987654321;\n}\nstudent1\nstudent2\nname\n= \"Geza\"\nstudentID\n= 123456789\nname\n= \"Jesse\"\nstudentID\n= 987654321\n\nAccessing Fields\n- To access fields of instances, use\nvariable.fieldName\nclass MITStudent {\npublic:\nchar *name;\nint studentID;\n};\n\nint main() {\nMITStudent student1;\nMITStudent student2;\nstudent1.name = \"Geza\";\nstudent1.studentID = 123456789;\nstudent2.name = \"Jesse\";\nstudent2.studentID = 987654321;\ncout << \"student1 name is\" << student1.name << endl;\ncout << \"student1 id is\" << student1.studentID << endl;\ncout << \"student2 name is\" << student2.name << endl;\ncout << \"student2 id is\" << student2.studentID << endl;\n\nStart =\n(0.4, 0.8)\nEnd =\n(0.9, 1.5)\n- A point consists of an x and y\ncoordinate\n- A vector consists of 2 points: a\nstart and a finish\n\n- A point consists of an x and y\ncoordinate\n- A vector consists of 2 points: a\nstart and a finish\nclass Vector {\npublic:\ndouble xStart;\ndouble xEnd;\ndouble yStart;\ndouble yEnd;\n};\nVector\nxStart\nxEnd\nyStart\nyEnd\nStart =\n(0.4, 0.8)\nEnd =\n(0.9, 1.5)\n\n- A point consists of an x and y\ncoordinate\n- A vector consists of 2 points: a\nstart and a finish\nclass Vector {\npublic:\ndouble xStart;\ndouble xEnd;\ndouble yStart;\ndouble yEnd;\n};\nVector\nxStart\nxEnd\nyStart\nyEnd\nStart =\n(0.4, 0.8)\nEnd =\n(0.9, 1.5)\nDoesn't show that coordinates\ncan be grouped into points\n\nStart =\n(0.4, 0.8)\nEnd =\n(0.9, 1.5)\n- A point consists of an x and y\ncoordinate\n- A vector consists of 2 points: a\nstart and a finish\nPoint\nx\ny\nclass Point {\npublic:\ndouble x;\ndouble y;\n};\n\n- A point consists of an x and y\ncoordinate\n- A vector consists of 2 points: a\nstart and a finish\nPoint\nx\ny\nclass Point {\npublic:\ndouble x;\ndouble y;\n};\n\nVector\nPoint (start)\nPoint (end)\nx\ny\nx\ny\n\n- A point consists of an x and y\ncoordinate\n- A vector consists of 2 points: a\nstart and a finish\nPoint\nx\ny\nclass Point {\npublic:\ndouble x;\ndouble y;\n};\n\nclass Vector {\npublic:\nPoint start;\nPoint end;\n};\n\nVector\nPoint (start)\nPoint (end)\nx\ny\nx\ny\nFields can be classes\n\nvec1 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=?\ny=?\nx=?\ny=?\nclass Point {\npublic:\ndouble x, y;\n};\n\nclass Vector {\npublic:\nPoint start, end;\n};\n\nint main() {\nVector vec1;\n}\n\nvec1 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=3\ny=?\nx=?\ny=?\nclass Point {\npublic:\ndouble x, y;\n};\n\nclass Vector {\npublic:\nPoint start, end;\n};\n\nint main() {\nVector vec1;\nvec1.start.x = 3.0;\n}\n\nvec1 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=3\ny=4\nx=5\ny=6\nclass Point {\npublic:\ndouble x, y;\n};\n\nclass Vector {\npublic:\nPoint start, end;\n};\n\nint main() {\nVector vec1;\nvec1.start.x = 3.0;\nvec1.start.y = 4.0;\nvec1.end.x = 5.0;\nvec1.end.y = 6.0;\n}\n\nvec2 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=?\ny=?\nx=?\ny=?\nclass Point {\npublic:\ndouble x, y;\n};\n\nclass Vector {\npublic:\nPoint start, end;\n};\n\nint main() {\nVector vec1;\nvec1.start.x = 3.0;\nvec1.start.y = 4.0;\nvec1.end.x = 5.0;\nvec1.end.y = 6.0;\nVector vec2;\n}\n\nvec1 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=3\ny=4\nx=5\ny=6\n\nvec2 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=3\ny=4\nx=?\ny=?\nclass Point {\npublic:\ndouble x, y;\n};\n\nclass Vector {\npublic:\nPoint start, end;\n};\n\nint main() {\nVector vec1;\nvec1.start.x = 3.0;\nvec1.start.y = 4.0;\nvec1.end.x = 5.0;\nvec1.end.y = 6.0;\nVector vec2;\nvec2.start = vec1.start;\n}\n\nvec1 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=3\ny=4\nx=5\ny=6\n- Assigning one instance to another copies all fields\n\nvec2 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=7\ny=4\nx=?\ny=?\nclass Point {\npublic:\ndouble x, y;\n};\n\nclass Vector {\npublic:\nPoint start, end;\n};\n\nint main() {\nVector vec1;\nvec1.start.x = 3.0;\nvec1.start.y = 4.0;\nvec1.end.x = 5.0;\nvec1.end.y = 6.0;\nVector vec2;\nvec2.start = vec1.start;\nvec2.start.x = 7.0;\n}\n\nvec1 (instance of Vector)\nstart (instance of Point)\nend (instance of Point)\nx=3\ny=4\nx=5\ny=6\n- Assigning one instance to another copies all fields\n\nPassing classes to functions\n- Passing by value passes a copy of the class instance\nto the function; changes aren't preserved\nclass Point { public: double x, y; };\n\nvoid offsetPoint(Point p, double x, double y) { // does nothing\np.x += x;\np.y += y;\n}\n\nint main() {\nPoint p;\np.x = 3.0;\np.y = 4.0;\noffsetPoint(p, 1.0, 2.0); // does nothing\ncout << \"(\" << p.x << \",\" << p.y << \")\"; // (3.0,4.0)\n}\n\nPassing classes to functions\n- When a class instance is passed by reference,\nchanges are reflected in the original\nclass Point { public: double x, y; };\n\nvoid offsetPoint(Point &p, double x, double y) { // works\np.x += x;\np.y += y;\n}\n\nint main() {\nPoint p;\np.x = 3.0;\np.y = 4.0;\noffsetPoint(p, 1.0, 2.0); // works\ncout << \"(\" << p.x << \",\" << p.y << \")\"; // (4.0,6.0)\n}\nPassed by\nreference\n\nclass Point {\npublic: double x, y;\n};\nPoint class, with fields x and y\n\nclass Point {\npublic: double x, y;\n};\nclass Vector {\npublic: Point start, end;\n};\nFields can be classes\n\nclass Point {\npublic: double x, y;\n};\nclass Vector {\npublic: Point start, end;\n};\n\nint main() {\nVector vec;\n}\n\nvec is an instance of Vector\n\nclass Point {\npublic: double x, y;\n};\nclass Vector {\npublic: Point start, end;\n};\n\nint main() {\nVector vec;\nvec.start.x = 1.2;\n}\n\nAccessing fields\n\nclass Point {\npublic: double x, y;\n};\nclass Vector {\npublic: Point start, end;\n};\n\nint main() {\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0; vec.start.y = 0.4; vec.end.y = 1.6;\n}\n\nclass Point {\npublic: double x, y;\n};\nclass Vector {\npublic: Point start, end;\n};\n\nvoid printVector(Vector v) {\ncout << \"(\" << v.start.x << \",\" << v.start.y << \") -> (\" << v.end.x <<\n\",\" << v.end.y << \")\" << endl;\n}\n\nint main() {\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0; vec.start.y = 0.4; vec.end.y = 1.6;\nprintVector(vec); // (1.2,0.4) -> (2.0,1.6)\n}\n\nclasses can be passed\nto functions\n\nclass Point {\npublic: double x, y;\n};\nclass Vector {\npublic: Point start, end;\n};\n\nvoid printVector(Vector v) {\ncout << \"(\" << v.start.x << \",\" << v.start.y << \") -> (\" << v.end.x <<\n\",\" << v.end.y << \")\" << endl;\n}\n\nint main() {\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0; vec.start.y = 0.4; vec.end.y = 1.6;\nprintVector(vec); // (1.2,0.4) -> (2.0,1.6)\n}\n\nCan pass to value if you don't\nneed to modify the class\n\nclass Point {\npublic: double x, y;\n};\nclass Vector {\npublic: Point start, end;\n};\n\nvoid offsetVector(Vector &v, double offsetX, double offsetY) {\nv.start.x += offsetX;\nv.end.x += offsetX;\nv.start.y += offsetY;\nv.end.y += offsetY;\n}\nvoid printVector(Vector v) {\ncout << \"(\" << v.start.x << \",\" << v.start.y << \") -> (\" << v.end.x <<\n\",\" << v.end.y << \")\" << endl;\n}\n\nint main() {\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0; vec.start.y = 0.4; vec.end.y = 1.6;\noffsetVector(vec, 1.0, 1.5);\nprintVector(vec); // (2.2,1.9) -> (3.8,4.3)\n}\n\nPass classes by reference if they need to be modified\n\n- Observe how some functions are closely\nassociated with a particular class\n\nvoid offsetVector(Vector &v, double offsetX, double offsetY);\nvoid printVector(Vector v);\nint main() {\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0;\nvec.start.y = 0.4; vec.end.y = 1.6;\noffsetVector(vec, 1.0, 1.5);\nprintVector(vec);\n}\n\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0;\nvec.start.y = 0.4; vec.end.y = 1.6;\nvec.print();\n\nMethod name\n- Observe how some functions are closely\nassociated with a particular class\n- Methods: functions which are part of a class\n\n- Observe how some functions are closely\nassociated with a particular class\n- Methods: functions which are part of a class\n- Implicitly pass the current instance\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0;\nvec.start.y = 0.4; vec.end.y = 1.6;\nvec.print();\n\nObject\ninstance\n\nVector vec;\nvec.start.x = 1.2; vec.end.x = 2.0;\nvec.start.y = 0.4; vec.end.y = 1.6;\nvec.print();\nvec.offset(1.0, 1.5);\n\nArguments\ncan be passed\nto methods\n- Observe how some functions are closely\nassociated with a particular class\n- Methods: functions which are part of a class\n- Implicitly pass the current instance\n\nVector vec1;\nVector vec2;\n// initialize vec1 and vec2\nvec1.print();\n\nvec1\nprint\noffset\nvec2\nprint\noffset\n- Analogy: Methods are \"buttons\" on each box\n(instance), which do things when pressed\n\nVector vec1;\nVector vec2;\n// initialize vec1 and vec2\nvec1.print();\n\nvec1\nprint\noffset\nvec2\nprint\noffset\nWhich box's\nbutton was\npressed?\n\nVector vec1;\nVector vec2;\n// initialize vec1 and vec2\nvec1.print();\n\nvec1\nprint\noffset\nvec2\nprint\noffset\nWhich button\nwas pressed?\n\nclass Vector {\npublic:\nPoint start;\nPoint end;\n\nvoid offset(double offsetX, double offsetY) {\nstart.x += offsetX;\nend.x += offsetX;\nstart.y += offsetY;\nend.y += offsetY;\n}\nvoid print() {\ncout << \"(\" << start.x << \",\" << start.y << \") -> (\" << end.x <<\n\",\" << end.y << \")\" << endl;\n}\n};\nmethods\n\nclass Vector {\npublic:\nPoint start;\nPoint end;\n\nvoid offset(double offsetX, double offsetY) {\nstart.x += offsetX;\nend.x += offsetX;\nstart.y += offsetY;\nend.y += offsetY;\n}\nvoid print() {\ncout << \"(\" << start.x << \",\" << start.y << \") -> (\" << end.x <<\n\",\" << end.y << \")\" << endl;\n}\n};\nFields can be accessed in a method\n\nclass Vector {\npublic:\nPoint start, end;\n\nvoid offset(double offsetX, double offsetY) {\nstart.offset(offsetX, offsetY);\nend.offset(offsetX, offsetY);\n}\nvoid print() {\nstart.print();\ncout << \" -> \";\nend.print();\ncout << endl;\n}\n};\nclass Point {\npublic:\ndouble x, y;\nvoid offset(double offsetX, double offsetY) {\nx += offsetX; y += offsetY;\n}\nvoid print() {\ncout << \"(\" << x << \",\" << y << \")\";\n}\n};\nmethods of fields can be called\n\nImplementing Methods Separately\n- Recall that function prototypes allowed us to\ndeclare that functions will be implemented later\n- This can be done analogously for class methods\n// vector.h - header file\nclass Point {\npublic:\ndouble x, y;\nvoid offset(double offsetX, double offsetY);\nvoid print();\n};\n\nclass Vector {\npublic:\nPoint start, end;\nvoid offset(double offsetX, double offsetY);\nvoid print();\n};\n\n#include \"vector.h\"\n// vector.cpp - method implementation\nvoid Point::offset(double offsetX, double offsetY) {\nx += offsetX; y += offsetY;\n}\nvoid Point::print() {\ncout << \"(\" << x << \",\" << y << \")\";\n}\nvoid Vector::offset(double offsetX, double offsetY) {\nstart.offset(offsetX, offsetY);\nend.offset(offsetX, offsetY);\n}\nvoid Vector::print() {\nstart.print();\ncout << \" -> \";\nend.print();\ncout << endl;\n}\n:: indicates which class' method is being\nimplemented\n\nVector vec;\nvec.start.x = 0.0;\nvec.start.y = 0.0;\nvec.end.x = 0.0;\nvec.end.y = 0.0;\n- Manually initializing your fields can get tedious\n- Can we initialize them when we create an\ninstance?\nPoint p;\np.x = 0.0;\np.y = 0.0;\n\nConstructors\n- Method that is called when an instance is created\n\nclass Point {\npublic:\ndouble x, y;\nPoint() {\nx = 0.0; y = 0.0; cout << \"Point instance created\" << endl;\n}\n};\n\nint main() {\nPoint p; // Point instance created\n// p.x is 0.0, p.y is 0.0\n}\n\nConstructors\n- Can accept parameters\nclass Point {\npublic:\ndouble x, y;\nPoint(double nx, double ny) {\nx = nx; y = ny; cout << \"2-parameter constructor\" << endl;\n}\n};\n\nint main() {\nPoint p(2.0, 3.0); // 2-parameter constructor\n// p.x is 2.0, p.y is 3.0\n}\n\nConstructors\n- Can have multiple constructors\nclass Point {\npublic:\ndouble x, y;\nPoint() {\nx = 0.0; y = 0.0; cout << \"default constructor\" << endl;\n}\nPoint(double nx, double ny) {\nx = nx; y = ny; cout << \"2-parameter constructor\" << endl;\n}\n};\n\nint main() {\nPoint p; // default constructor\n// p.x is 0.0, p.y is 0.0)\nPoint q(2.0, 3.0); // 2-parameter constructor\n// q.x is 2.0, q.y is 3.0)\n}\n\n- Recall that assigning one class instance to another\ncopies all fields (default copy constructor)\nclass Point {\npublic:\ndouble x, y;\nPoint() {\nx = 0.0; y = 0.0; cout << \"default constructor\" << endl;\n}\nPoint(double nx, double ny) {\nx = nx; y = ny; cout << \"2-parameter constructor\" << endl;\n}\n};\n\nint main() {\nPoint q(1.0, 2.0); // 2-parameter constructor\nPoint r = q;\n// r.x is 1.0, r.y is 2.0)\n}\nInvoking the copy constructor\n\nclass Point {\npublic:\ndouble x, y;\nPoint(double nx, double ny) {\nx = nx; y = ny; cout << \"2-parameter constructor\" << endl;\n}\nPoint(Point &o) {\nx = o.x; y = o.y; cout << \"custom copy constructor\" << endl;\n}\n};\n\nint main() {\nPoint q(1.0, 2.0); // 2-parameter constructor\nPoint r = q; // custom copy constructor\n// r.x is 1, r.y is 2\n}\n- You can define your own copy constructor\n\n- Why make a copy constructor? Assigning all fields\n(default copy constructor) may not be what you want\nint main() {\nMITStudent student1;\nstudent1.studentID = 98;\nchar n[] = \"foo\";\nstudent1.name = n;\nMITStudent student2 = student1;\nstudent2.name[0] = 'b';\ncout << student1.name; // boo\n}\nclass MITStudent {\npublic:\nint studentID;\nchar *name;\nMITStudent() {\nstudentID = 0;\nname = \"\";\n}\n};\nBy changing student 2's name, we\nchanged student 1's name as well\n\n- Why make a copy constructor? Assigning all fields\n(default copy constructor) may not be what you want\nint main() {\nMITStudent student1;\nstudent1.studentID = 98;\nchar n[] = \"foo\";\nstudent1.name = n;\nMITStudent student2 = student1;\nstudent2.name[0] = 'b';\ncout << student1.name; // foo\n}\nclass MITStudent {\npublic:\nint studentID;\nchar *name;\nMITStudent() {\nstudentID = 0;\nname = \"\";\n}\nMITStudent(MITStudent &o) {\nstudentID = o.studentID;\nname = strdup(o.name);\n}\n};\nChanging student 2's name doesn't effect\nstudent 1's name\n\nclass Point {\npublic:\ndouble x, y;\n\nPoint(double nx, double ny) {\nx = nx; y = ny;\n}\n};\nAccess Modifier\nAccess Modifiers\n- Define where your fields/methods can be accessed\nfrom\n\nAccess Modifiers\n- public: can be accessed from anywhere\nclass Point {\npublic:\ndouble x, y;\n\nPoint(double nx, double ny) {\nx = nx; y = ny;\n}\n};\n\nint main() {\nPoint p(2.0,3.0);\np.x = 5.0; // allowed\n}\n\nAccess Modifiers\n- private: can only be accessed within the class\nclass Point {\nprivate:\ndouble x, y;\n\npublic:\nPoint(double nx, double ny) {\nx = nx; y = ny;\n}\n};\n\nint main() {\nPoint p(2.0,3.0);\np.x = 5.0; // not allowed\n}\n\nAccess Modifiers\n- Use getters to allow read-only access to private fields\nclass Point {\nprivate:\ndouble x, y;\n\npublic:\nPoint(double nx, double ny) {\nx = nx; y = ny;\n}\ndouble getX() { return x; }\ndouble getY() { return y; }\n};\n\nint main() {\nPoint p(2.0,3.0);\ncout << p.getX() << endl; // allowed\n}\n\nDefault Access Modifiers\n- class: private by default\nclass Point {\ndouble x, y;\n};\nclass Point {\nprivate:\ndouble x, y;\n};\nEquivalent\nto\n\nStructs\n- Structs are a carry-over from the C; in C++,\nclasses are generally used\n- In C++, they're essentially the same as classes,\nexcept structs' default access modifier is public\nclass Point {\npublic:\ndouble x;\ndouble y;\n};\nstruct Point {\n\ndouble x;\ndouble y;\n};\n\nDefault Access Modifiers\n- struct: public by default\n- class: private by default\nstruct Point {\ndouble x, y;\n};\nEquivalent\nto\nstruct Point {\npublic:\ndouble x, y;\n};\nclass Point {\ndouble x, y;\n};\nclass Point {\nprivate:\ndouble x, y;\n};\nEquivalent\nto\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec07.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/270def7b1f68535b7c3846c606b220eb_MIT6_096IAP11_lec07.pdf",
      "content": "6.096\nIntroduction to C++\nJanuary 19, 2011\nMassachusetts Institute of Technology\nLecture 7 Notes: Object-Oriented Programming\n(OOP) and Inheritance\nWe've already seen how to define composite datatypes using classes. Now we'll take a step\nback and consider the programming philosophy underlying classes, known as object-oriented\nprogramming (OOP).\nThe Basic Ideas of OOP\nClassic \"procedural\" programming languages before C++ (such as C) often focused on the\nquestion \"What should the program do next?\" The way you structure a program in these\nlanguages is:\n1. Split it up into a set of tasks and subtasks\n2. Make functions for the tasks\n3. Instruct the computer to perform them in sequence\nWith large amounts of data and/or large numbers of tasks, this makes for complex and\nunmaintainable programs.\nConsider the task of modeling the operation of a car. Such a program would have lots of\nseparate variables storing information on various car parts, and there'd be no way to group\ntogether all the code that relates to, say, the wheels. It's hard to keep all these variables\nand the connections between all the functions in mind.\nTo manage this complexity, it's nicer to package up self-sufficient, modular pieces of code.\nPeople think of the world in terms of interacting objects: we'd talk about interactions between\nthe steering wheel, the pedals, the wheels, etc. OOP allows programmers to pack away details\ninto neat, self-contained boxes (objects) so that they can think of the objects more abstractly\nand focus on the interactions between them.\nThere are lots of definitions for OOP, but 3 primary features of it are:\n- Encapsulation: grouping related data and functions together as objects and defining\nan interface to those objects\n- Inheritance: allowing code to be reused between related types\n- Polymorphism: allowing a value to be one of several types, and determining at\nruntime which functions to call on it based on its type\n\nLet's see how each of these plays out in C++.\nEncapsulation\nEncapsulation just refers to packaging related stuff together. We've already seen how to\npackage up data and the operations it supports in C++: with classes.\nIf someone hands us a class, we do not need to know how it actually works to use it; all we\nneed to know about is its public methods/data - its interface. This is often compared to\noperating a car: when you drive, you don't care how the steering wheel makes the wheels\nturn; you just care that the interface the car presents (the steering wheel) allows you to\naccomplish your goal. If you remember the analogy from Lecture 6 about objects being\nboxes with buttons you can push, you can also think of the interface of a class as the set\nof buttons each instance of that class makes available. Interfaces abstract away the details\nof how all the operations are actually performed, allowing the programmer to focus on how\nobjects will use each other's interfaces - how they interact.\nThis is why C++ makes you specify public and private access specifiers: by default, it\nassumes that the things you define in a class are internal details which someone using your\ncode should not have to worry about. The practice of hiding away these details from client\ncode is called \"data hiding,\" or making your class a \"black box.\"\nOne way to think about what happens in an object-oriented program is that we define what\nobjects exist and what each one knows, and then the objects send messages to each other\n(by calling each other's methods) to exchange information and tell each other what to do.\nInheritance\nInheritance allows us to define hierarchies of related classes.\nImagine we're writing an inventory program for vehicles, including cars and trucks. We could\nwrite one class for representing cars and an unrelated one for representing trucks, but we'd\nhave to duplicate the functionality that all vehicles have in common. Instead, C++ allows\nus to specify the common code in a Vehicle class, and then specify that the Car and Truck\nclasses share this code.\nThe Vehicle class will be much the same as what we've seen before:\nclass Vehicle {\nprotected :\nstring license ;\nint year ;\n\npublic :\nVehicle( const string &myLicense , const int myYear)\n: license(myLicense), year(myYear) {}\nconst string getDesc () const\n{return license + \" from \" + stringify(year);}\nconst string &getLicense () const {return license ;}\nconst int getYear () const {return year ;}\n};\nA few notes on this code, by line:\n2. The standard string class is described in Section 1 of PS3; see there for details. Recall\nthat strings can be appended to each other with the + operator.\n3. protected is largely equivalent to private. We'll discuss the differences shortly.\n8. This line demonstrates member initializer syntax. When defining a constructor, you\nsometimes want to initialize certain members, particularly const members, even before\nthe constructor body. You simply put a colon before the function body, followed by a\ncomma-separated list of items of the form dataMember(initialValue).\n10. This line assumes the existence of some function stringify for converting numbers to\nstrings.\nNow we want to specify that Car will inherit the Vehicle code, but with some additions.\nThis is accomplished in line 1 below:\nclass Car : public Vehicle { // Makes Car inherit from Vehicle\nstring style;\npublic :\nCar( const string &myLicense , const int myYear , const string\n&myStyle)\n: Vehicle(myLicense , myYear), style(myStyle) {}\nconst string &getStyle () {return style ;}\n};\nNow class Car has all the data members and methods of Vehicle, as well as a style data\nmember and a getStyle method.\nClass Car inherits from class Vehicle. This is equivalent to saying that Car is a derived\nclass, while Vehicle is its base class. You may also hear the terms subclass and superclass\ninstead.\nNotes on the code:\n\n1. Don't worry for now about why we stuck the public keyword in there.\n6. Note how we use member initializer syntax to call the base-class constructor. We need\nto have a complete Vehicle object constructed before we construct the components\nadded in the Car. If you do not explicitly call a base-class constructor using this syntax,\nthe default base-class constructor will be called.\nSimilarly, we could make a Truck class that inherits from Vehicle and shares its code. This\nwould give a class hierarchy like the following:\nVehicle\nTruck\nCar\nClass hierarchies are generally drawn with arrows pointing from derived classes to base\nclasses.\n3.1\nIs-a vs. Has-a\nThere are two ways we could describe some class A as depending on some other class B:\n1. Every A object has a B object. For instance, every Vehicle has a string object (called\nlicense).\n2. Every instance of A is a B instance. For instance, every Car is a Vehicle, as well.\nInheritance allows us to define \"is-a\" relationships, but it should not be used to implement\n\"has-a\" relationships. It would be a design error to make Vehicle inherit from string\nbecause every Vehicle has a license; a Vehicle is not a string. \"Has-a\" relationships\nshould be implemented by declaring data members, not by inheritance.\n3.2\nOverriding Methods\nWe might want to generate the description for Cars in a different way from generic Vehicles.\nTo accomplish this, we can simply redefine the getDesc method in Car, as below. Then,\nwhen we call getDesc on a Car object, it will use the redefined function. Redefining in this\nmanner is called overriding the function.\nclass Car : public\nstring style ;\nVehicle { // Makes Car inherit from Vehicle\n\npublic :\nCar( const string &myLicense , const int myYear , const string\n&myStyle)\n: Vehicle(myLicense , myYear), style(myStyle) {}\nconst string getDesc () // Overriding this member function\n{return stringify(year) + ' ' + style + \": \" + license\n;}\nconst string &getStyle () {return style ;}\n};\n3.2.1\nProgramming by Difference\nIn defining derived classes, we only need to specify what's different about them from their\nbase classes. This powerful technique is called programming by difference.\nInheritance allows only overriding methods and adding new members and methods. We\ncannot remove functionality that was present in the base class.\n3.3\nAccess Modifiers and Inheritance\nIf we'd declared year and license as private in Vehicle, we wouldn't be able to access\nthem even from a derived class like Car. To allow derived classes but not outside code to\naccess data members and member functions, we must declare them as protected.\nThe public keyword used in specifying a base class (e.g., class Car : public Vehicle\n{...}) gives a limit for the visibility of the inherited methods in the derived class. Normally\nyou should just use public here, which means that inherited methods declared as public\nare still public in the derived class. Specifying protected would make inherited methods,\neven those declared public, have at most protected visibility. For a full table of the effects\nof different inheritance access specifiers, see\nhttp://en.wikibooks.org/wiki/C++ Programming/Classes/Inheritance.\nPolymorphism\nPolymorphism means \"many shapes.\" It refers to the ability of one object to have many\ntypes. If we have a function that expects a Vehicle object, we can safely pass it a Car\nobject, because every Car is also a Vehicle. Likewise for references and pointers: anywhere\nyou can use a Vehicle *, you can use a Car *.\n\n4.1\nvirtual Functions\nThere is still a problem. Take the following example:\nCar c(\" VANITY \" , 2003) ;\nVehicle * vPtr = &c;\ncout << vPtr -> getDesc () ;\n(The -> notation on line 3 just dereferences and gets a member. ptr->member is equivalent\nto (*ptr).member.)\nBecause vPtr is declared as a Vehicle *, this will call the Vehicle version of getDesc, even\nthough the object pointed to is actually a Car. Usually we'd want the program to select the\ncorrect function at runtime based on which kind of object is pointed to. We can get this\nbehavior by adding the keyword virtual before the method definition:\nclass Vehicle {\n...\nvirtual const string getDesc () {...}\n};\nWith this definition, the code above would correctly select the Car version of getDesc.\nSelecting the correct function at runtime is called dynamic dispatch. This matches the whole\nOOP idea - we're sending a message to the object and letting it figure out for itself what\nactions that message actually means it should take.\nBecause references are implicitly using pointers, the same issues apply to references:\nCar c(\" VANITY \" , 2003) ;\nVehicle &v = c;\ncout << v. getDesc () ;\nThis will only call the Car version of getDesc if getDesc is declared as virtual.\nOnce a method is declared virtual in some class C, it is virtual in every derived class of C,\neven if not explicitly declared as such. However, it is a good idea to declare it as virtual\nin the derived classes anyway for clarity.\n4.2\nPure virtual Functions\nArguably, there is no reasonable way to define getDesc for a generic Vehicle - only derived\nclasses really need a definition of it, since there is no such thing as a generic vehicle that\nisn't also a car, truck, or the like. Still, we do want to require every derived class of Vehicle\nto have this function.\n\nWe can omit the definition of getDesc from Vehicle by making the function pure virtual\nvia the following odd syntax:\nclass Vehicle {\n...\nvirtual const string getDesc () = 0; // Pure virtual\n};\nThe = 0 indicates that no definition will be given. This implies that one can no longer create\nan instance of Vehicle; one can only create instances of Cars, Trucks, and other derived\nclasses which do implement the getDesc method. Vehicle is then an abstract class - one\nwhich defines only an interface, but doesn't actually implement it, and therefore cannot be\ninstantiated.\nMultiple Inheritance\nUnlike many object-oriented languages, C++ allows a class to have multiple base classes:\nclass Car : public Vehicle , public InsuredItem {\n...\n};\nThis specifies that Car should have all the members of both the Vehicle and the InsuredItem\nclasses.\nMultiple inheritance is tricky and potentially dangerous:\n- If both Vehicle and InsuredItem define a member x, you must remember to disam\nbiguate which one you're referring to by saying Vehicle::x or InsuredItem::x.\n- If both Vehicle and InsuredItem inherited from the same base class, you'd end up\nwith two instances of the base class within each Car (a \"dreaded diamond\" class hier\narchy). There are ways to solve this problem, but it can get messy.\nIn general, avoid multiple inheritance unless you know exactly what you're doing.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec08.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/d3efc710bb90753e60a7b0f799a46296_MIT6_096IAP11_lec08.pdf",
      "content": "6.096 Lecture 8:\nMemory Management\nClean up after your pet program\n\nGeza Kovacs\n\nReview: Constructors\n- Method that is called when an instance is created\n\nclass Integer {\npublic:\nint val;\nInteger() {\nval = 0; cout << \"default constructor\" << endl;\n}\n};\n\nint main() {\nInteger i;\n}\n\nOutput:\ndefault constructor\n\n- When making an array of objects, default\nconstructor is invoked on each\nclass Integer {\npublic:\nint val;\nInteger() {\nval = 0; cout << \"default constructor\" << endl;\n}\n};\n\nint main() {\nInteger arr[3];\n}\n\nOutput:\ndefault constructor\ndefault constructor\ndefault constructor\n\n- When making a class instance, the default\nconstructor of its fields are invoked\nclass Integer {\npublic:\nint val;\nInteger() {\nval = 0; cout << \"Integer default constructor\" << endl;\n}\n};\nclass IntegerWrapper {\npublic:\nInteger val;\nIntegerWrapper() {\ncout << \"IntegerWrapper default constructor\" << endl;\n}\n};\n\nint main() {\nIntegerWrapper q;\n}\nOutput:\nInteger default constructor\nIntegerWrapper default constructor\n\n- Constructors can accept parameters\nclass Integer {\npublic:\nint val;\nInteger(int v) {\nval = v; cout << \"constructor with arg \" << v << endl;\n}\n};\n\nint main() {\nInteger i(3);\n}\n\nOutput:\nconstructor with arg 3\n\n- Constructors can accept parameters\n- Can invoke single-parameter constructor via\nassignment to the appropriate type\nclass Integer {\npublic:\nint val;\nInteger(int v) {\nval = v; cout << \"constructor with arg \" << v << endl;\n}\n};\n\nint main() {\nInteger i(3);\nInteger j = 5;\n}\n\nOutput:\nconstructor with arg 3\nconstructor with arg 5\n\nclass Integer {\npublic:\nint val;\nInteger(int v) {\nval = v;\n}\n};\n\nint main() {\nInteger i(3); // ok\nInteger j;\n}\n\n- If a constructor with parameters is defined,\nthe default constructor is no longer available\nError: No default constructor available for Integer\n\nclass Integer {\npublic:\nint val;\nInteger(int v) {\nval = v;\n}\n};\n\nint main() {\nInteger a[] = { Integer(2), Integer(5) }; // ok\nInteger b[2];\n}\n\n- If a constructor with parameters is defined,\nthe default constructor is no longer available\n- Without a default constructor, can't declare arrays\nwithout initializing\nError: No default constructor available for Integer\n\nclass Integer {\npublic:\nint val;\nInteger() {\nval = 0;\n}\nInteger(int v) {\nval = v;\n}\n};\n\nint main() {\nInteger i; // ok\nInteger j(3); // ok\n}\n\n- If a constructor with parameters is defined,\nthe default constructor is no longer available\n- Can create a separate 0-argument constructor\n\nclass Integer {\npublic:\nint val;\nInteger(int v = 0) {\nval = v;\n}\n};\n\nint main() {\nInteger i; // ok\nInteger j(3); // ok\n}\n\n- If a constructor with parameters is defined,\nthe default constructor is no longer available\n- Can create a separate 0-argument constructor\n- Or, use default arguments\n\nclass Integer {\npublic:\nint val;\nInteger(int val = 0) {\nthis->val = val;\n}\n};\n- How do I refer to a field when a method\nargument has the same name?\n- this: a pointer to the current instance\nthis->val is a shorthand for (*this).val\n\nclass Integer {\npublic:\nint val;\nInteger(int val = 0) {\nthis->val = val;\n}\nvoid setVal(int val) {\nthis->val = val;\n}\n};\n- How do I refer to a field when a method\nargument has the same name?\n- this: a pointer to the current instance\n\nScoping and Memory\n- Whenever we declare a new variable (int x),\nmemory is allocated\n- When can this memory be freed up (so it can\nbe used to store other variables)?\n- When the variable goes out of scope\n\nint main() {\nif (true) {\nint x = 5;\n}\n// x now out of scope, memory it used to occupy can be reused\n}\n\n- When a variable goes out of scope, that\nmemory is no longer guaranteed to store the\nvariable's value\nScoping and Memory\n\nint main() {\nint *p;\nif (true) {\nint x = 5;\np = &x;\n}\ncout << *p << endl; // ???\n}\n\n- When a variable goes out of scope, that\nmemory is no longer guaranteed to store the\nvariable's value\nScoping and Memory\n\nint main() {\nint *p;\nif (true) {\nint x = 5;\np = &x;\n}\ncout << *p << endl; // ???\n}\n\nint *p\nhere\n- When a variable goes out of scope, that\nmemory is no longer guaranteed to store the\nvariable's value\nScoping and Memory\n\nint *p\nint x\nint main() {\nint *p;\nif (true) {\nint x = 5;\np = &x;\n}\ncout << *p << endl; // ???\n}\n\nhere\n- When a variable goes out of scope, that\nmemory is no longer guaranteed to store the\nvariable's value\nScoping and Memory\n\nint *p\nint x\nint main() {\nint *p;\nif (true) {\nint x = 5;\np = &x;\n}\ncout << *p << endl; // ???\n}\n\nhere\n- When a variable goes out of scope, that\nmemory is no longer guaranteed to store the\nvariable's value\nScoping and Memory\n\nint main() {\nint *p;\nif (true) {\nint x = 5;\np = &x;\n}\ncout << *p << endl; // ???\n}\n\nhere\nint *p\n???\n- When a variable goes out of scope, that\nmemory is no longer guaranteed to store the\nvariable's value\n- Here, p has become a dangling pointer (points to\nmemory whose contents are undefined)\n\nScoping and Memory\n\nA Problematic Task\n- Implement a function which returns a pointer\nto some memory containing the integer 5\n- Incorrect implementation:\nint* getPtrToFive() {\nint x = 5;\nreturn &v;\n}\n\n- Implement a function which returns a pointer\nto some memory containing the integer 5\n- Incorrect implementation:\n- x is declared in the function scope\nint* getPtrToFive() {\nint x = 5;\nreturn &x;\n}\n\nint main() {\nint *p = getPtrToFive();\ncout << *p << endl; // ???\n}\n\nhere\nint x\n\n- Implement a function which returns a pointer\nto some memory containing the integer 5\n- Incorrect implementation:\n- x is declared in the function scope\n- As getPtrToFive() returns, x goes out of scope. So a\ndangling pointer is returned\nint* getPtrToFive() {\nint x = 5;\nreturn &x;\n}\n\nint main() {\nint *p = getPtrToFive();\ncout << *p << endl; // ???\n}\n\nhere\nint *p\n???\n\nThe new operator\n- Another way to allocate memory, where the\nmemory will remain allocated until you\nmanually de-allocate it\n- Returns a pointer to the newly allocated\nmemory\nint *x = new int;\n\nThe new operator\n- Another way to allocate memory, where the\nmemory will remain allocated until you\nmanually de-allocate it\n- Returns a pointer to the newly allocated\nmemory\nint *x = new int;\nType parameter needed to\ndetermine how much\nmemory to allocate\n\nThe new operator\n- Another way to allocate memory, where the\nmemory will remain allocated until you\nmanually de-allocate it\n- Returns a pointer to the newly allocated\nmemory\n- Terminology note:\n- If using int x; the allocation occurs on a region of\nmemory called the stack\n- If using new int; the allocation occurs on a region\nof memory called the heap\n\nThe delete operator\n- De-allocates memory that was previously\nallocated using new\n- Takes a pointer to the memory location\n\nint *x = new int;\n// use memory allocated by new\ndelete x;\n\n- Implement a function which returns a pointer\nto some memory containing the integer 5\n- Allocate memory using new to ensure it remains\nallocated\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\n- Implement a function which returns a pointer\nto some memory containing the integer 5\n- Allocate memory using new to ensure it remains\nallocated.\n- When done, de-allocate the memory using delete\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p = getPtrToFive();\ncout << *p << endl; // 5\ndelete p;\n}\n\nDelete Memory When Done Using It\n- If you don't use de-allocate memory using\ndelete, your application will waste memory\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\n}\n}\n\nincorrect\n\n- If you don't use de-allocate memory using\ndelete, your application will waste memory\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\n}\n}\n\nint *p\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\n}\n}\n\n1st iteration\n- If you don't use de-allocate memory using\ndelete, your application will waste memory\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\n}\n}\n\n2nd iteration\n- If you don't use de-allocate memory using\ndelete, your application will waste memory\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\n}\n}\n\n3rd iteration\n- If you don't use de-allocate memory using\ndelete, your application will waste memory\n- When your program allocates memory but is\nunable to de-allocate it, this is a memory leak\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\n}\ndelete p;\n}\n3rd iteration\n- Does adding a delete after the loop fix this\nmemory leak?\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\n}\ndelete p;\n}\n- Does adding a delete after the loop fix this\nmemory leak?\n- No; only the memory that was allocated on the last\niteration gets de-allocated\n\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\n\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\nint *p\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\n1st iteration\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\n1st iteration\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\n2nd iteration\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\n2nd iteration\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\n3rd iteration\n\nThe Heap\nint *p\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *p;\nfor (int i = 0; i < 3; ++i) {\np = getPtrToFive();\ncout << *p << endl;\ndelete p;\n}\n}\n- To fix the memory leak, de-allocate memory\nwithin the loop\n3rd iteration\n\nDon't Use Memory After Deletion\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *x = getPtrToFive();\ndelete x;\ncout << *x << endl; // ???\n}\n\nincorrect\n\nDon't Use Memory After Deletion\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *x = getPtrToFive();\ndelete x;\ncout << *x << endl; // ???\n}\n\nincorrect\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *x = getPtrToFive();\ncout << *x << endl; // 5\ndelete x;\n}\n\ncorrect\n\nDon't delete memory twice\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *x = getPtrToFive();\ncout << *x << endl; // 5\ndelete x;\ndelete x;\n}\n\nincorrect\n\nDon't delete memory twice\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *x = getPtrToFive();\ncout << *x << endl; // 5\ndelete x;\ndelete x;\n}\n\nincorrect\nint *getPtrToFive() {\nint *x = new int;\n*x = 5;\nreturn x;\n}\n\nint main() {\nint *x = getPtrToFive();\ncout << *x << endl; // 5\ndelete x;\n}\n\ncorrect\n\nOnly delete if memory was allocated\nby new\nint main() {\nint x = 5;\nint *xPtr = &x;\ncout << *xPtr << endl;\ndelete xPtr;\n}\n\nincorrect\n\nOnly delete if memory was allocated\nby new\nint main() {\nint x = 5;\nint *xPtr = &x;\ncout << *xPtr << endl;\ndelete xPtr;\n}\n\nincorrect\nint main() {\nint x = 5;\nint *xPtr = &x;\ncout << *xPtr << endl;\n}\n\ncorrect\n\nint numItems;\ncout << \"how many items?\";\ncin >> numItems;\nint arr[numItems]; // not allowed\nAllocating Arrays\n- When allocating arrays on the stack (using\n\"int arr[SIZE]\"), size must be a constant\n\nAllocating Arrays\n- If we use new[] to allocate arrays, they can\nhave variable size\nint numItems;\ncout << \"how many items?\";\ncin >> numItems;\nint *arr = new int[numItems];\nType of items\nin array\n\nAllocating Arrays\n- If we use new[] to allocate arrays, they can\nhave variable size\nint numItems;\ncout << \"how many items?\";\ncin >> numItems;\nint *arr = new int[numItems];\nNumber of items\nto allocate\n\nAllocating Arrays\n- If we use new[] to allocate arrays, they can\nhave variable size\n- De-allocate arrays with delete[]\nint numItems;\ncout << \"how many items?\";\ncin >> numItems;\nint *arr = new int[numItems];\ndelete[] arr;\n\nEx: Storing values input by the user\nint main() {\nint numItems;\ncout << \"how many items? \";\ncin >> numItems;\nint *arr = new int[numItems];\nfor (int i = 0; i < numItems; ++i) {\ncout << \"enter item \" << i << \": \";\ncin >> arr[i];\n}\nfor (int i = 0; i < numItems; ++i) {\ncout << arr[i] << endl;\n}\ndelete[] arr;\n}\nhow many items? 3\nenter item 0: 7\nenter item 1: 4\nenter item 2: 9\n\nAllocating Class Instances using new\n- new can also be used to allocate a class instance\nclass Point {\npublic:\nint x, y;\n};\n\nint main() {\nPoint *p = new Point;\ndelete p;\n}\n\nAllocating Class Instances using new\n- new can also be used to allocate a class instance\n- The appropriate constructor will be invoked\nclass Point {\npublic:\nint x, y;\nPoint() {\nx = 0; y = 0; cout << \"default constructor\" << endl;\n}\n};\n\nint main() {\nPoint *p = new Point;\ndelete p;\n}\n\nOutput:\ndefault constructor\n\nAllocating Class Instances using new\n- new can also be used to allocate a class instance\n- The appropriate constructor will be invoked\nclass Point {\npublic:\nint x, y;\nPoint(int nx, int ny) {\nx = ny; x = ny; cout << \"2-arg constructor\" << endl;\n}\n};\n\nint main() {\nPoint *p = new Point(2, 4);\ndelete p;\n}\n\nOutput:\n2-arg constructor\n\nDestructor\n- Destructor is called when the class instance gets\nde-allocated\nclass Point {\npublic:\nint x, y;\nPoint() {\ncout << \"constructor invoked\" << endl;\n}\n~Point() {\ncout << \"destructor invoked\" << endl;\n}\n}\n\n- Destructor is called when the class instance\ngets de-allocated\n- If allocated with new, when delete is called\nclass Point {\npublic:\nint x, y;\nPoint() {\ncout << \"constructor invoked\" << endl;\n}\n~Point() {\ncout << \"destructor invoked\" << endl;\n}\n};\nint main() {\nPoint *p = new Point;\ndelete p;\n}\n\nOutput:\nconstructor invoked\ndestructor invoked\n\n- Destructor is called when the class instance\ngets de-allocated\n- If allocated with new, when delete is called\n- If stack-allocated, when it goes out of scope\nclass Point {\npublic:\nint x, y;\nPoint() {\ncout << \"constructor invoked\" << endl;\n}\n~Point() {\ncout << \"destructor invoked\" << endl;\n}\n};\nint main() {\nif (true) {\nPoint p;\n}\ncout << \"p out of scope\" << endl;\n}\nOutput:\nconstructor invoked\ndestructor invoked\np out of scope\n\nRepresenting an Array of Integers\n- When representing an array, often pass\naround both the pointer to the first element\nand the number of elements\n- Let's make them fields in a class\nclass IntegerArray {\npublic:\nint *data;\nint size;\n};\nPointer to the first element\n\nRepresenting an Array of Integers\n- When representing an array, often pass\naround both the pointer to the first element\nand the number of elements\n- Let's make them fields in a class\nclass IntegerArray {\npublic:\nint *data;\nint size;\n};\nNumber of elements in the array\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\n};\n\nint main() {\nIntegerArray arr;\narr.size = 2;\narr.data = new int[arr.size];\narr.data[0] = 4; arr.data[1] = 5;\ndelete[] a.data;\n}\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\n};\n\nint main() {\nIntegerArray arr;\narr.size = 2;\narr.data = new int[arr.size];\narr.data[0] = 4; arr.data[1] = 5;\ndelete[] a.data;\n}\n\nCan move this into a constructor\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n};\n\nint main() {\nIntegerArray arr(2);\narr.data[0] = 4; arr.data[1] = 5;\ndelete[] arr.data;\n}\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n};\n\nint main() {\nIntegerArray arr(2);\narr.data[0] = 4; arr.data[1] = 5;\ndelete[] arr.data;\n}\n\nCan move this into a destructor\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n~IntegerArray () {\ndelete[] data;\n}\n};\n\nint main() {\nIntegerArray arr(2);\narr.data[0] = 4; arr.data[1] = 5;\n}\n\nDe-allocate memory used by fields in destructor\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\n\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // not 4!\n}\nincorrect\n\na (IntArrayWrapper)\ndata\nhere\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\n\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // not 4!\n}\n\na (IntArrayWrapper)\nb (IntArrayWrapper)\ndata\ndata\nhere\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\n\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // not 4!\n}\n- Default copy constructor copies fields\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\n\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // not 4!\n}\n- When b goes out of scope, destructor is called (de-\nallocates array), a.data now a dangling pointer\na (IntArrayWrapper)\ndata\n(Deleted)\nhere\n\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\n\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // not 4!\n}\n- 2nd bug: when a goes out of scope, its destructor\ntries to delete the (already-deleted) array\na (IntArrayWrapper)\ndata\n(Deleted)\nProgram crashes as it terminates\n\n- Write your own a copy constructor to fix these bugs\nclass IntegerArray {\npublic:\nint *data;\nint size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\nIntegerArray(IntegerArray &o) {\ndata = new int[o.size];\nsize = o.size;\nfor (int i = 0; i < size; ++i)\ndata[i] = o.data[i];\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\n\nclass IntegerArray {\npublic:\nint *data; int size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\nIntegerArray(IntegerArray &o) {\ndata = new int[o.size];\nsize = o.size;\nfor (int i = 0; i < size; ++i)\ndata[i] = o.data[i];\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // 4\n}\nhere\na (IntArrayWrapper)\ndata\n\nclass IntegerArray {\npublic:\nint *data; int size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\nIntegerArray(IntegerArray &o) {\ndata = new int[o.size];\nsize = o.size;\nfor (int i = 0; i < size; ++i)\ndata[i] = o.data[i];\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // 4\n}\nCopy constructor invoked\na (IntArrayWrapper)\nb (IntArrayWrapper)\ndata\ndata\n\nclass IntegerArray {\npublic:\nint *data; int size;\nIntegerArray(int size) {\ndata = new int[size];\nthis->size = size;\n}\nIntegerArray(IntegerArray &o) {\ndata = new int[o.size];\nsize = o.size;\nfor (int i = 0; i < size; ++i)\ndata[i] = o.data[i];\n}\n~IntegerArray() {\ndelete[] data;\n}\n};\nint main() {\nIntegerArray a(2);\na.data[0] = 4; a.data[1] = 2;\nif (true) {\nIntegerArray b = a;\n}\ncout << a.data[0] << endl; // 4\n}\nhere\na (IntArrayWrapper)\ndata\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec09.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/13882f48b16656374a40a0d103a3b51c_MIT6_096IAP11_lec09.pdf",
      "content": "6.096 Introduction to C++\nJanuary 24th, 2011\nMassachusetts Institute of Technology\nJohn Marrero\nLecture 9 Notes: Advanced Topics I\nTemplates\nWe have seen that functions can take arguments of specific types and have a specific return\ntype. We now consider templates, which allow us to work with generic types. Through\ntemplates, rather than repeating function code for each new type we wish to accommodate, we\ncan create functions that are capable of using the same code for different types. For example:\n1 int sum(const int x, const int y) {\nreturn x + y;\n3 }\nFor this function to work with doubles, it must be modified to the following:\n1 double sum (const double x, const double y) {\nreturn x + y;\n3 }\nFor a simple function such as this, it may be a small matter to just make the change as shown,\nbut if the code were much more complicated, copying the entire function for each new type\ncan quickly become problematic. To overcome this we rewrite sum as a function template.\nThe format for declaring a function template is:\ntemplate <class identifier> function_declaration;\nor\ntemplate <typename identifier> function_declaration;\nBoth forms are equivalent to one another, regardless of what type identifier ends up being. We\ncan then use identifier to replace all occurrences of the type we wish to generalize.\nSo, we rewrite our sum function:\n1 template <typename T>\n2 T sum(const T a, const T b) {\nreturn a + b;\n4 }\nNow, when sum is called, it is called with a particular type, which will replace all Ts in the code.\nTo invoke a function template, we use:\nfunction_name <type> (parameters);\nHere is an example main function using the above sum function template:\n1 int main() {\ncout << sum<int>(1, 2) << endl;\ncout << sum<float>(1.21, 2.43) << endl;\nreturn 0;\n5 }\nThis program prints out 3 and 3.64 on separate lines.\n\nThe identifier can be used in any way inside the function template, as long as the code makes\nsense after identifier is replaced with some type.\nIt is also possible to invoke a function template without giving an explicit type, in cases where\nthe generic type identifier is used as the type for a parameter for the function. In the above\nexample, the following would also have been valid:\n1 int main() {\ncout << sum(1, 2) << endl;\ncout << sum(1.21, 2.43) << endl;\nreturn 0;\n5 }\nTemplates can also specify more than one type parameter. For example:\n1 #include <iostream>\n2 using namespace std;\n4 template <typename T, typename U>\n5 U sum(const T a, const U b) {\nreturn a + b;\n7 }\n9 int main() {\ncout << sum<int, float>(1, 2.5) << endl;\nreturn 0;\n12 }\nThis program prints out 3.5. In this case we can also call sum by writing sum(1, 2.5).\nClass templates are also possible, in much the same way we have written function templates:\n1 #include <iostream>\n2 using namespace std;\n4 template <typename T>\n5 class Point {\nprivate:\nT x, y;\npublic:\nPoint(const T u, const T v) : x(u), y(v) {}\nT getX() { return x; }\nT getY() { return y; }\n12 };\n14 int main() {\nPoint<float> fpoint(2.5, 3.5);\ncout << fpoint.getX() << \", \" << fpoint.getY() << endl;\nreturn 0;\n18 }\nThe program prints out 2.5, 3.5.\nTo declare member functions externally, we use the following syntax:\ntemplate <typename T>\nT classname<T>::function_name()\nSo, for example, getX could have been declared in the following way:\n\ntemplate <typename T>\nT Point<T>::getX() { return x; }\nassuming a prototype of T getX(); inside the class definition.\nWe can also define different implementations for a single template by using template\nspecialization. Consider the following example:\n1 #include <iostream>\n2 #include <cctype>\n3 using namespace std;\n5 template <typename T>\n6 class Container {\nprivate:\nT elt;\npublic:\nContainer(const T arg) : elt(arg) {}\nT inc() { return elt+1; }\n12 };\n14 template <>\n15 class Container <char> {\nprivate:\nchar elt;\npublic:\nContainer(const char arg) : elt(arg) {}\nchar uppercase() { return toupper(elt); }\n21 };\n23 int main() {\nContainer<int> icont(5);\nContainer<char> ccont('r');\ncout << icont.inc() << endl;\ncout << ccont.uppercase() << endl;\nreturn 0;\n29 }\nThis program prints out 6 and R on separate lines. Here, the class Container is given two\nimplementations: a generic one and one specifically tailored to the char type. Notice the\nsyntax at lines 14 and 15 when declaring a specialization.\nFinally, it is possible to parametrize templates on regular types:\n1 #include <iostream>\n2 using namespace std;\n4 template <typename T, int N>\n5 class ArrayContainer {\nprivate:\nT elts[N];\npublic:\nT set(const int i, const T val) { elts[i] = val; }\nT get(const int i) { return elts[i]; }\n11 };\n13 int main() {\nArrayContainer <int, 5> intac;\nArrayContainer <float, 10> floatac;\nintac.set(2, 3);\nfloatac.set(3, 3.5);\ncout << intac.get(2) << endl;\ncout << floatac.get(3) << endl;\n\nreturn 0;\n21 }\nThis program prints out 3 and 3.5 on separate lines. Here, one instance of the ArrayContainer\nclass works on a 5-element array of ints whereas the other instance works on a 10-element\narray of floats.\nDefault values can be set for template parameters. For example, the previous template\ndefinition could have been:\ntemplate <typename T=int, int N=5> class ArrayContainer { ... }\nand we could have created an ArrayContainer using the default parameters by writing:\nArrayContainer<> identifier;\nStandard Template Library\nPart of the C++ Standard Library, the Standard Template Library (STL) contains many useful\ncontainer classes and algorithms. As you might imagine, these various parts of the library are\nwritten using templates and so are generic in type. The containers found in the STL are lists,\nmaps, queues, sets, stacks, and vectors. The algorithms include sequence operations, sorts,\nsearches, merges, heap operations, and min/max operations. We will explore how to use some\nof these through example here:\n#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\nint main() {\nset<int> iset;\niset.insert(5);\niset.insert(9);\niset.insert(1);\niset.insert(8);\niset.insert(3);\ncout << \"iset contains:\";\nset<int>::iterator it;\nfor(it=iset.begin(); it != iset.end(); it++)\ncout << \" \" << *it;\ncout << endl;\nint searchFor;\ncin >> searchFor;\nif(binary_search(iset.begin(), iset.end(), searchFor))\ncout << \"Found \" << searchFor << endl;\nelse\ncout << \"Did not find \" << searchFor << endl;\nreturn 0;\n28 }\nIn this example, we create an integer set and insert several integers into it. We then create an\niterator corresponding to the set at lines 14 and 15. An iterator is basically a pointer that\nprovides a view of the set. (Most of the other containers also provide iterators.) By using this\niterator, we display all the elements in the set and print out iset contains: 1 3 5 8 9. Note\nthat the set automatically sorts its own items. Finally, we ask the user for an integer, search\nfor that integer in the set, and display the result.\n\nHere is another example:\n1 #include <iostream>\n2 #include <algorithm>\n3 using namespace std;\n4 void printArray(const int arr[], const int len) {\nfor(int i=0; i < len; i++)\ncout << \" \" << arr[i];\ncout << endl;\n8 }\n10 int main() {\nint a[] = {5, 7, 2, 1, 4, 3, 6};\nsort(a, a+7);\nprintArray(a, 7);\nrotate(a,a+3,a+7);\nprintArray(a, 7);\nreverse(a, a+7);\nprintArray(a, 7);\nreturn 0;\n21 }\nThis program prints out:\n1 2 3 4 5 6 7\n4 5 6 7 1 2 3\n3 2 1 7 6 5 4\nThe STL has many, many more containers and algorithms that you can use. Read more at\nhttp://www.cplusplus.com/reference/stl and http://www.cplusplus.com/reference/algorithm/.\nOperator Overloading\nWe have been using operators on primitives, but sometimes it makes sense to use them on\nuser-defined datatypes. For instance, consider the following struct:\nstruct USCurrency {\nint dollars;\nint cents;\n};\nPerhaps we would like to add two USCurrency objects together and get a new one as a result,\njust like in normal addition:\nUSCurrency a = {2, 50};\nUSCurrency b = {1, 75};\nUSCurrency c = a + b;\nThis of course gives a compiler error, but we can define behavior that our datatype should have\nwhen used with the addition operator by overloading the addition operator. This can be done\neither inside the class as part of its definition (the addition from the point of view of the object\non the left side of the +):\n1 USCurrency operator+(const USCurrency o) {\nUSCurrency tmp = {0, 0};\ntmp.cents = cents + o.cents;\ntmp.dollars = dollars + o.dollars;\n\nif(tmp.cents >= 100) {\ntmp.dollars += 1;\ntmp.cents -= 100;\n}\nreturn tmp;\n12 }\nor outside the class as a function independent of the class (the addition from the point of view\nof the +):\n1 USCurrency operator+(const USCurrency m, const USCurrency o) {\nUSCurrency tmp = {0, 0};\ntmp.cents = m.cents + o.cents;\ntmp.dollars = m.dollars + o.dollars;\nif(tmp.cents >= 100) {\ntmp.dollars += 1;\ntmp.cents -= 100;\n}\nreturn tmp;\n12 }\nSimilarly, we can overload the << operator to display the result:\n1 ostream& operator<<(ostream &output, const USCurrency &o)\n2 {\noutput << \"$\" << o.dollars << \".\" << o.cents;\nreturn output;\n5 }\nAssuming the above definitions, we can run the following program:\n1 int main() {\nUSCurrency a = {2, 50};\nUSCurrency b = {1, 75};\nUSCurrency c = a + b;\ncout << c << endl;\nreturn 0;\n7 }\nand get the printout $4.25.\nThe list of overloadable operators:\n+\n-\n*\n/\n+=\n-=\n*=\n/=\n%\n%=\n++\n-\n=\n==\n<\n>\n<=\n>=\n!\n!=\n&&\n||\n<<\n>>\n<<=\n>>=\n&\n^\n|\n&=\n^=\n|=\n~\n[]\n()\n,\n->*\n->\nnew\nnew[] delete\ndelete[]\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "MIT6_096IAP11_lec10.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/3fb8a922fc4283863e29eeed55d7e664_MIT6_096IAP11_lec10.pdf",
      "content": "Introduction to C++\nJanuary 26, 2011\nMassachusetts Institute of Technology\n6.096\nLecture 10 Notes: Advanced Topics II\nStuff You May Want to Use in Your Project\n1.1\nFile handling\nFile handling in C++ works almost identically to terminal input/output. To use files, you\nwrite #include <fstream> at the top of your source file. Then you can access two classes\nfrom the std namespace:\n- ifstream - allows reading input from files\n- ofstream - allows outputting to files\nEach open file is represented by a separate ifstream or an ofstream object. You can use\nifstream objects in excatly the same way as cin and ofstream objects in the same way as\ncout, except that you need to declare new objects and specify what files to open.\nFor example:\n1 # include < fstream >\n2 using namespace std ;\n4 int main () {\nifstream source (\" source -file . txt \");\nofstream destination (\" dest -file . txt \");\nint x;\nsource >> x;\n// Reads one int from source -file . txt\nsource . close () ; // close file as soon as we 're done using it\ndestination << x; // Writes x to dest -file . txt\nreturn 0;\n12 } // close () called on destination by its destructor\nAs an alternative to passing the filename to the constructor, you can use an existing ifstream\nor ofstream object to open a file by calling the open method on it: source.open(\"other-file.txt\");.\nClose your files using the close() method when you're done using them. This is automat\nically done for you in the object's destructor, but you often want to close the file ASAP,\nwithout waiting for the destructor.\n\nYou can specify a second argument to the constructor or the open method to specify what\n\"mode\" you want to access the file in - read-only, overwrite, write by appending, etc. Check\ndocumentation online for details.\n1.2\nReading Strings\nYou'll likely find that you want to read some text input from the user. We've so far seen\nonly how to do ints, chars, etc.\nIt's usually easiest to manage text using the C++ string class. You can read in a string\nfrom cin like other variables:\n1 string mobileCarrier;\n2 cin >> mobileCarrier;\nHowever, this method only reads up to the first whitespace; it stops at any tab, space,\nnewline, etc. If you want to read multiple words, you can use the getline function, which\nreads everything up until the user presses enter:\n1 string sentence;\n2 getline(cin , sentence);\n1.3\nenum\nIn many cases you'll find that you'll want to have a variable that represents one of a discrete\nset of values. For instance, you might be writing a card game and want to store the suit of\na card, which can only be one of clubs, diamonds, hearts, and spades. One way you might\ndo this is declaring a bunch of const ints, each of which is an ID for a particular suit. If\nyou wanted to print the suit name for a particular ID, you might write this:\n1 const int CLUBS = 0, DIAMONDS = 1, HEARTS = 2, SPADES = 3;\n2 void print_suit ( const int suit ) {\nconst char * names [] = {\" Clubs \" , \" Diamonds \" ,\n\" Hearts \" , \" Spades \" };\nreturn names [ suit ];\n6 }\nThe problem with this is that suit could be integer, not just one of the set of values we\nknow it should be restricted to. We'd have to check in our function whether suit is too big.\nAlso, there's no indication in the code that these const ints are related.\nInstead, C++ allows us to use enums. An enum just provides a set of named integer values\nwhich are the only legal values for some new type. For instance:\n\n1 enum suit_t { CLUBS , DIAMONDS , HEARTS , SPADES };\n2 void print_suit ( const suit_t suit ) {\nconst char * names [] = {\" Clubs \" , \" Diamonds \" ,\n\" Hearts \" , \" Spades \" };\nreturn names [ suit ];\n6 }\nNow, it is illegal to pass anything but CLUBS, DIAMODNS, HEARTS, or SPADES into\nprint suit. However, internally the suit t values are still just integers, and we can use\nthem as such (as in line 5).\nYou can specify which integers you want them to be:\n1 enum suit_t {CLUBS =18, DIAMONDS =91, HEARTS =241, SPADES =13};\nThe following rules are used by default to determine the values of the enum constants:\nThe first item defaults to 0.\n-\n- Every other item defaults to the previous item plus 1.\nJust like any other type, an enum type such as suit t can be used for any arguments,\nvariables, return types, etc.\n1.4\nStructuring Your Project\nMany object-oriented programs like those you're writing for your projects share an overall\nstructure you will likely want to use. They have some kind of managing class (e.g., Game,\nDirectory, etc.) that maintains all the other objects that interact in the program. For\ninstance, in a board game, you might have a Game class that is responsible for maintaining\nPlayer objects and the Board object. Often this class will have to maintain some collection\nof objects, such as a list of people or a deck of cards; it can do so by having a field that is an\nSTL container. main creates a single instance of this managing class, handles the interaction\nwith the user (i.e. asking the user what to do next), and calls methods on the manager\nobject to perform the appropriate actions based on user input.\nReview\nSome of the new concepts we'll cover require familiarity with concepts we've touched on\npreviously. These concepts will also be useful in your projects.\n\n2.1\nReferences\nReferences are perfectly valid types, just like pointers. For instance, just like int * is the\n\"pointer to an integer\" type, int & is the \"reference to an integer\" type. References can be\npassed as arguments to functions, returned from functions, and otherwise manipulated just\nlike any other type.\nReferences are just pointers internally; when you declare a reference variable, a pointer to the\nvalue being referenced is created, and it's just dereferenced each time the reference variable\nis used.\nThe syntax for setting a reference variable to become an alias for another variable is just like\nregular assignment:\n1 int &x = y; // x and y are now two names for the same variable\nSimilarly, when we want to pass arguments to a function using references, we just call the\nfunction with the arguments as usual, and put the & in the function definiton, where the\nargument variables are being set to the arguments actually passed:\n1 void sq ( int &x) { // & is part of the type of x\n// - x is an int reference\nx *= x;\n4 }\n5 sq (y);\nNote that on the last line, where we specify what variable x will be a reference to, we just\nwrite the name of that variable; we don't need to take an address with & here.\nReferences can also be returned from functions, as in this contrived example:\n1 int g; // Global variable\n2 int & getG () { // Return type is int reference\nreturn g; // As before , the value we 're making a\n// reference * to * doesn 't get an & in front of it\n5 }\n// ... Somewhere in main\nint & gRef = getG () ; // gRef is now an alias for g\ngRef = 7; // Modifies g\nIf you're writing a class method that needs to return some internal object, it's often best to\nreturn it by reference, since that avoids copying over the entire object. You could also then\nuse your method to do something like:\n1 vector <Card > &cardList\n\n= deck.getList (); // getList declared to return a reference\n3 cardList.pop_back ();\nThe second line here modifies the original list in deck, because cardList was declared as a\nreference and getList returns a reference.\n2.2\nconst\n2.2.1\nConverting between const and non-const\nYou can always provide a non-const value where a const one was expected. For instance,\nyou can pass non-const variables to a function that takes a const argument. The const-ness\nof the argument just means the function promises not to change it, whether or not you require\nthat promise. The other direction can be a problem: you cannot provide a const reference\nor pointer where a non-const one was expected. Setting a non-const pointer/reference to a\nconst one would violate the latter's requirement that it not be changeable. The following,\nfor instance, does not work:\n1 int g; // Global variable\n2 const int & getG () { return g; }\n// ... Somewhere in main\nint & gRef = getG () ;\nThis fails because gRef is a non-const reference, yet we are trying to set it to a const\nreference (the reference returned by getG).\nIn short, the compiler will not let you convert a const value into a non-const value unless\nyou're just making a copy (which leaves the original const value safe).\n2.2.2\nconst functions\nFor simple values like ints, the concept of const variables is simple: a const int can't\nbe modified. It gets a little more complicated when we start talking about const objects.\nClearly, no fields on a const object should be modifiable, but what methods should be\navailable? It turns out that the compiler can't always tell for itself which methods are safe\nto call on const objects, so it assumes by default that none are. To signal that a method is\nsafe to call on a const object, you must put the const keyword at the end of its signature,\ne.g. int getX() const;. const methods that return pointers/references to internal class\ndata should always return const pointers/references.\n\nExceptions\nSometimes functions encounter errors that make it impossible to continue normally. For\ninstance, a getFirst function that was called on an empty Array object would have no\nreasonable course of action, since there is no first element to return.\nA functions can signal such an error to its caller by throwing an exception. This causes the\nfunction to exit immediately with no return value. The calling function has the opportunity\nto catch the exception - to specify how it should be handled. If it does not do so, it exits\nimmediately as well, the exception passes up to the next function, and so on up the call\nstack (the chain of function calls that got us to the exception).\nAn example:\n1 const int DIV_BY_0 = 0;\n2 int divide ( const int x , const int y) {\nif (y == 0)\nthrow DIV_BY_0 ;\nreturn x / y;\n6 }\n8 void f( int x , int ** arrPtr ) {\ntry {\n* arrPtr = new int [ divide (5 , x) ];\n} catch ( int error ) {\n// cerr is like cout but for error messages\ncerr << \" Caught error : \" << error ;\n}\n// ... Some other code ...\n16 }\nThe code in main is executing a function (divide) that might throw an exception. In\nanticipation, the potentially problematic code is wrapped in a try block. If an exception\nis thrown from divide, divide immediately exits, passing control back to main. Next, the\nexception's type is checked against the type specified in the catch block (line 11). If it\nmatches (as it does in this case), the code in the catch block is executed; otherwise, f will\nexit as well as though it had thrown the exception. The exception will then be passed up to\nf's caller to see if it has a catch block defined for the exception's type.\nYou can have an arbitrary number of catch blocks after a try block:\nint divide ( const int x , const int y) {\nif (y == 0)\nthrow std :: runtime_exception (\" Divide\nreturn x / y;\nby 0! \");\n\n5 }\n7 void f( int x , int ** arrPtr ) {\ntry {\n* arrPtr = new int [ divide (5 , x) ];\n}\ncatch ( bad_alloc & error ) { // new throws exceptions of this type\ncerr << \" new failed to allocate memory \";\n}\ncatch ( runtime_exception & error ) {\n// cerr is like cout but for error messages\ncerr << \" Caught error : \" << error . what () ;\n}\n// ...\n19 }\nIn such a case, the exception's type is checked against each of the catch blocks' argument\ntypes in the order specified. If line 2 causes an exception, the program will first check\nwhether the exception is a bad alloc object. Failing that, it checks whether it was a\nruntime exception object. If the exception is neither, the function exits and the exception\ncontinues propagating up the call stack.\nThe destructors of all local variables in a function are called before the function exits due to\nan exception.\nException usage notes:\n- Though C++ allows us to throw values of any type, typically we throw exception\nobjects. Most exception classes inherit from class std::exception in header file\n<stdexcept>.\n- The standard exception classes all have a constructor taking a string that describes the\nproblem. That description can be accessed by calling the what method on an exception\nobject.\n- You should always use references when specifying the type a catch block should match\n(as in lines 11 and 14). This prevents excessive copying and allows virtual functions to\nbe executed properly on the exception object.\nfriend Functions/Classes\nOccasionally you'll want to allow a function that is not a member of a given class to access the\nprivate fields/methods of that class. (This is particularly common in operator overloading.)\n\nWe can specify that a given external function gets full access rights by placing the signature\nof the function inside the class, preceded by the word friend. For example, if we want to\nmake the fields of the USCurrency type from the previous lecture private, we can still have\nour stream insertion operator (the output operator, <<) overloaded:\n1 class USCurrency {\nfriend ostream &operator <<( ostream &o, const USCurrency &c)\n;\nint dollars , cents;\n4 public :\nUSCurrency( const int d, const int c) : dollars(d), cents(c)\n{}\n6 };\n8 ostream &operator <<( ostream &o, const USCurrency &c) {\no << '$ ' << c.dollars << '. ' << c.cents;\nreturn o;\n11 }\nNow the operator<< function has full access to all members of USCurrency objects.\nWe can do the same with classes. To say that all member functions of class A should be fully\navailable to class B, we'd write:\n1 class A {\nfriend class B;\n// More code ...\n4 };\nPreprocessor Macros\nWe've seen how to define constants using the preprocessor command #define. We can also\ndefine macros, small snippets of code that depend on arguments. For instance, we can write:\n1 #define sum(x, y) (x + y)\nNow, every time sum(a, b) appears in the code, for any arguments a and b, it will be\nreplaced with (a + b).\nMacros are like small functions that are not type-checked; they are implemented by simple\ntextual substitution. Because they are not type-checked, they are considered less robust\nthan functions.\n\nCasting\nCasting is the process of converting a value between types. We've already seen C-style casts\n- e.g. 1/(double)4. Such casts are not recommended in C++; C++ provides a number of\nmore robust means of casting that allow you to specify more precisely what you want.\nAll C++-style casts are of the form cast type<type>(value), where type is the type you're\ncasting to. The possible cast types to replace cast type with are:\n- static cast - This is by far the most commonly used cast. It creates a simple copy\nof the value of the specified type. Example: static cast<float>(x), where x is an\nint, gives a float copy of x.\n- dynamic cast - Allows converting between pointer/reference types within an inher\nitance hierarchy. dynamic cast checks whether value is actually of type type. For\ninstance, we could cast a Vehicle * called v to a Car * by writing dynamic cast<Car\n*>(v). If v is in fact a pointer to a Car, not a Vehicle of some other type such as\nTruck, this returns a valid pointer of type Car *. If v does not point to a Car, it\nreturns null.\ndynamic cast can also be used with references: if v is a Vehicle & variable, dynamic cast\n<Car &>(v) will return a valid reference if v is actually a reference to a Car, and will\nthrow a bad cast exception otherwise.\n- reinterpret cast - Does no conversion; just treats the memory containing value as\nthough it were of type type\n- const cast - Used for changing const modifiers of a value. You can use this to tell the\ncompiler that you really do know what you're doing and should be allowed to modify\na const variable. You could also use it to add a const modifier to an object so you can\nforce use of the const version of a member function.\nThat's All!\nThis is the end of the 6.096 syllabus, but there are lots of really neat things you can do with\nC++ that we haven't even touched on. Just to give you a taste:\n- Unions - group multiple data types together; unlike classes/structs, though, the fields\nof a union are mutually exclusive - only one of them is well-defined at any time\n- Namespaces - allow you to wrap up all your code, classes, etc. into a \"directory\" of\nnames, like std\n- Advanced STL manipulation - allows you to do all sorts of wacky things with STL\ncontainers and iterators\n\n- void pointers - pointers to data of an unknown type\n- virtual inheritance - the solution to the \"dreaded diamond\" problem described in\nLecture 8\n- String streams - allow you to input from and output to string objects as though they\nwere streams like cin and cout\n- Run-time type information (RTTI) - allows you to get information on the type of a\nvariable at runtime\n- vtables - how the magic of virtual functions actually works\nIf you are interested in learning more about these subjects or anything we've discussed, we\nencourage you to look through online tutorials, perhaps even to buy a C++ book - and\nmost importantly, to just play around with C++ on your own!\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.096 Introduction to C++\nJanuary (IAP) 2011\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    }
  ]
}