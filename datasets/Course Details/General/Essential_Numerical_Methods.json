{
  "course_name": "Essential Numerical Methods",
  "course_description": "This half-semester course introduces computational methods for solving physical problems, especially in nuclear applications. The course covers ordinary and partial differential equations for particle orbit, and fluid, field, and particle conservation problems; their representation and solution by finite difference numerical approximations; iterative matrix inversion methods; stability, convergence, accuracy and statistics; and particle representations of Boltzmann’s equation and methods of solution such as Monte-Carlo and particle-in-cell techniques.",
  "topics": [
    "Engineering",
    "Nuclear Engineering",
    "Systems Engineering",
    "Computational Modeling and Simulation",
    "Numerical Simulation",
    "Mathematics",
    "Differential Equations",
    "Engineering",
    "Nuclear Engineering",
    "Systems Engineering",
    "Computational Modeling and Simulation",
    "Numerical Simulation",
    "Mathematics",
    "Differential Equations"
  ],
  "syllabus_content": "Course Meeting Times\n\nThis course meets for the first half of the semester.\n\nLectures: 2 sessions / week, 1.5 hours / session\n\nRecitations: 1 session / week, 0.5 hour / session\n\nFinal exam period is 3 hours long.\n\nPrerequisites\n\n12.010 Computational Methods of Scientific Programming\nor permission of instructor.\n\nEducational Objectives\n\nStudents who complete this module will\n\nBecome familiar with computational engineering and its mathematical foundations, at an elementary level.\n\nDeepen their understanding of the basic equations governing the phenomena in Nuclear Science and Engineering.\n\nUnderstand the methods by which physical problems can be solved using computation.\n\nDevelop experience, confidence, and good critical judgment in the application of numerical methods to the solution of physical problems.\n\nStrengthen their ability to use computation in theoretical analysis and experimental data interpretation.\n\nGrading\n\nACTIVITIES\n\nPERCENTAGES\n\nHomework exercises (best 5 of 9 scores)\n\n20%\n\nClass interaction\n\n5%\n\nFinal exam\n\n75%\n\nThe homework evaluation will count only the best five assignment scores. However, it should be noted that some exercises build on earlier ones. Therefore students should recognize that it is not generally possible simply to omit early assignments. Moreover, the exercises are designed to develop understanding and skill with the material that will be valuable for the final exam.\n\nLecture Notes and Bibliography\n\nDetailed lecture notes are provided.\n\nStudents who lack specific mathematics or science background in the areas discussed may be advised to supplement the lectures with extra reading.\n\nReference Books\n\nBOOKS\n\nCOMMENTARIES\n\nPress, W. H., B. P. Flannery, et al.\nNumerical Recipes\n. Cambridge University Press, 1989. ISBN: 9780521383301.\n\nThis is an outstanding, readable, and practical introduction to numerical methods in science and engineering. It covers more than this course, but is the number one book recommendation.\n\nJardin, Stephen.\nComputational Methods in Plasma Physics\n. CRC Press, 2010. ISBN: 9781439810217. [Preview with\nGoogle Books\n]\n\nAlthough focused on plasma physics, this book gives excellent introductions to finite difference PDE equations and the methods for solving them, across the spectrum of equation types.\n\nNakamura, Shoichi.\nComputational Methods in Engineering and Science with applications to Fluid Dynamics and Nuclear Systems\n. John Wiley & Sons Inc, 1977. ISBN: 9780471018001.\n\nThis book covers numerical methods in the nuclear reactor context, and therefore has some useful specialist topics. However, its mathematics is not, in my opinion, clearly written, and it is hard to learn from because of it.\n\nHebert, Alain.\nApplied Reactor Physics\n. Ecole Polytechnique De Montreal, 2009. ISBN: 9782553014369. [Preview with\nGoogle Books\n]\n\nThis modern reactor physics text book has numerical methods liberally sprinkled in its development and a useful appendix addressing them directly. Naturally its reactor physics goes far beyond what we will cover.\n\nSmith, G. D.\nNumerical Solution of Partial Differential Equations\n. Clarendon Press, 1965.\n\nForsythe, George E., and Wolfgang R. Wasow.\nFinite Difference Methods for Partial Differential Equations\n. Literary Licensing, 2013. ISBN: 9781258664152.\n\nMitchell, A. R., and D. F. Griffiths.\nThe Finite Difference Method in Partial Differential Equations\n. Wiley-Blackwell, 1980. ISBN: 9780471276418.\n\nThese are three examples of the large selection of text books that address how to solve partial differential equations numerically.\n\nHockney, R. W., and J. W. Eastwood.\nComputer Simulation Using Particles\n. CRC Press, 1988. ISBN: 9780852743928. [Preview with\nGoogle Books\n]\n\nThis is a classic on particle simulation, especially plasma PIC approaches, but has a lot of additional material on other topics of the course.\n\nNIST / SEMATECH e-Handbook of Statistical Methods\n\nA good resource about data fitting.\n\nCalendar\n\nLEC #\n\nTOPICS\n\nKEY DATES\n\nNumerical fitting of data\n\nExercise 1 out\n\nOrdinary differential equations (ODEs)\n\nExercise 2 out\n\nTwo-point boundary conditions\n\nExercise 3 out\n\nExercise 1 due\n\nPartial differential equations (PDEs)\n\nExercise 4 out\n\nExercise 2 due\n\nDiffusion; parabolic PDEs\n\nExercise 5 out\n\nExercise 3 due\n\nElliptic problems and iterative matrix solution\n\nExercise 6 out\n\nExercise 4 due\n\nFluid dynamics and hyperbolic equations\n\nExercise 7 out\n\nExercise 5 due\n\nBoltzmann's equation and its solution\n\nExercise 8 out\n\nExercise 6 due\n\nNeutron transport\n\nExercise 9 out\n\nExercise 7 due\n\nAtomistic and particle-in-cell methods\n\nExercise 8 due\n\nMonte Carlo techniques\n\nMonte Carlo radiation transport\n\nExercise 9 due\n\nNext steps, e.g. finite elements\n\nFinal exam (3 hour period)",
  "files": [
    {
      "category": "Resource",
      "title": "Exercise instructions and advice",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/22-15-essential-numerical-methods-fall-2014/7a59250f7819815e8a27e3aa36e37562_MIT22_15F14_ex_instr.pdf",
      "content": "Exercises: Instructions and Advice\nInstructions\nThe exercises in this course are primarily practical programming tasks that are designed to\nhelp the student master the intellectual content of the subjects and develop facility with\nevery-day numerical programming for solving science and engineering problems.\nThe choice of computer language or computational system used to perform these exercises\nis left up to the student. Many students will use MATLAB(r) or (preferably) its open source\nequivalent Octave. However, it will certainly be possible, and in some cases more elegant, to\nsolve the exercises using one of many other different languages. That is fully acceptable, but\nbe warned that low level programming languages generally do not provide the matrix algebra\nand plotting libraries that will be required. Also, it will not be possible to provide\nidentification of code errors in arbitrary languages as part of the feedback.\nA question naturally arises as to what \"built in\" facilities of a big system like MATLAB are\nallowed as part of the solution. For example, MATLAB has built in ordinary differential\nequation solvers. The overall guiding principle of this course is that no-one should need to\nprogram matrix algebra, decomposition, inversion, eigenvalue finding, and so on. They should\nsimply invoke it from the system (or libraries). However, we are going to learn how to fit data,\nsolve differential equations, and lots of other things; therefore, producing the solution of the\nexercises from a potted fitting or solving routine will miss the point. It might be useful to cross\ncheck your solution against a built-in one. But if you are thinking of using a built-in routine\nfor numerical solution, ask yourself the question: is this a matrix algebra function (if so, then\nyou are fine), and is this bypassing the point of the current topic by using a potted routine (if\nso, then you are defeating the object).\nMany exercises require the submission of your code. It should normally be submitted as\na text file with the appropriate extension, capable of being run by the mathematical system\nor compiled by the compiler corresponding to what you have used.\nWhen you are instructed to submit your output data, for example the fitting coef-\nficients, or the solution vector. It ought to be submitted in a text (ascii) format file. Binary\noutput is not portable. With luck MATLAB binary output from a command like save -mat\nvariable.mat var1 var2 will prove to be usable, but it's hard to guarantee. Therefore,\nalways submit a text file format as well (e.g. one generated from the command save -ascii\nvariable.asc var1).\nWordprocessing program formats are also not portable. Please avoid them except for\nproviding your textual answers, and preferably save them to pdf and submit the pdf, which\nis far more portable.\nAdvice\nProgramming is a skill, and practically an art. Most science and engineering students need\nto become competent at it because data analysis and theoretical evaluation are done almost\nalways these days numerically and computationally. Competence at some level is almost\nas necessary as being able to speak your native language. A better analogy for non-native\n\nEnglish speakers is that it is like English competence (which is practically vital for all high\nlevel scientists and engineers today). However, even if everyone needs to be able to speak\nand read, not everyone needs to be a Shakespeare.\nThis course is not intended to teach you programming. It assumes you have some level\nof competence, and it will help you to improve that competence. Here are a few points of\nadvice that apply to almost any numerical programming task and any language, that may\nhelp you to be more productive in the exercises.\nScripting and saving\nMany mathematical systems allow you to type commands interactively and see the results\nimmediately. This is very useful. However, it is a mistake to over-use this facility. It is\ngenerally much more useful to have a file that contains the commands required for performing\na particular computational task than it is to have the computational system in the state that\nwould be arrived at by those commands. The reason is obvious; the file of commands enables\nyou easily to reproduce the state at will, the reverse is not true (not even if there is a logging\nfacility that is capturing your keystrokes!). Therefore it is almost always good policy to\nswitch from interactive computation to editing a program and then running it, earlier in the\ndevelopment cycle rather than later.\nIntegrated Development Environments\nIt's very helpful to use an editor that is aware of the language you are writing in. It is\nthen able to do elementary analysis of the program as you type, hinting when the syntax\nis incomplete or incorrect, indenting the format of the program in a suggestive way, and so on.\nMATLAB itself provides such an editor, built into its integrated development environment\n(IDE). It can be used to great effect.\nOctave is more of a manual, text mode, version of MATLAB, but it also has a language\naware editor. Actually it has no editor, but will by default start up the editor emacs if you\ngive, for example, the command edit file.m. Emacs (on a properly configured Linux system)\nwill recognize that a file ending in the extension .m is an Octave (MATLAB) file and will when\nvisiting that file turn on the appropriate emacs mode. The same is true for other languages\nand extensions like .c, .f and so on. Being able to use a powerful editor like emacs is a useful\nskill. What it gives is an editor whose basic commands are the same, but which adapts to the\nlanguage being written. It is in a certain sense a \"poor man's\" IDE, but sometimes poorer is\nricher. You don't have to learn a new editor for each different language or system.\nData distribution\nSome exercises provide you data. Each student gets different data! It is distributed in the form\nof two files. One is ascii (text). It can be read in by Octave (but not MATLAB, at least not\nwithout tweaking). The other (ending in an extension .mat) is binary but ought to be readable\nby both MATLAB and Octave. To read the data in a file filename.mat into MATLAB or\nOctave, simply save the file to the disk, and issue (or program) the command load\nfilename.mat. It will create the variable with name specified in the saved data file\n\ncontaining the data. You should try it out and then examine the data to ensure it's being\nread in properly.\nIf you are using some other system than MATLAB or Octave, you'll have a bit more pro-\ngramming to get the data read in. Use the ascii file rather than the binary file, and notice that\nthere are comments inside it that describe the variables. Either edit the file into a form that\nyour system understands, or else program your system to interpret the file automatically (way\ntoo ambitious, good luck!).\nParameters\nMost programs have parameters that are fixed for certain types of problem and are used\nto describe other variables. For example, a vector or data set might have a length N that\nis known ahead of time.\nSuppose we have a problem where we know the length of the\nvectors is 6. You will be tempted to write commands like b=zeros(6,1) which in Octave\ngenerates a column vector of length 6 containing all zeros. You should almost always resist the\ntemptation to program values explicitly. Instead you should define a parameter, e.g. Nlen=6\n(one command), near the beginning of your code and thereafter write b=zeros(Nlen,1).\nThe reason is simple. As the program is developed, it is most likely that there will be a\nsteadily proliferating set of occasions where the length of the vectors is used. If you just write\n6 for each of them, your code becomes increasingly difficult to change, when, sometime down\nthe road, you decide you want to reuse it (or parts of it) for some other problem where the\nvector length is different. If you've systematically used a parameter Nlen. It is, by contrast,\ntotally trivial to change that parameter in one statement and hence achieve reusable code.\nSome of the exercises build up more complicated code through simpler stages and prob-\nlems. If you use parameters liberally, you will find this development easy and natural. If\nyou program values explicitly, you will struggle.\nIncremental, Small-scale, Testing and Debugging\nAnother vital use for parameters is to enable incremental testing. Suppose you are solving\na differential equation and need to evaluate the result at 1000 points across a range from 0\nto 1. You program your code and yet things don't seem to be working correctly. What do\nyou do?\nThe most important thing to remember about debugging is this. You need to look at\nthe data. Yes, it is important to look at the program. But it is equally important during\ndebugging to look at the data. Sometimes plotting it graphically is helpful, but sometimes\nnot.\nBut how do you look at 1000 numbers printed out?\nYou can't usefully do so.\nIt\nmight help to look at a small sample of the whole 1000 data points. But that might not\ntell you where the error is. It is often far better to look at the whole of the data for a\nsmaller number of points.\nIf everything in your code that depends upon the number of\npoints has been programmed using a parameter, then you can debug your code by putting\nthe parameter to a small number (e.g. 10) and printing out the values for all relevant indices.\nAnother big advantage of doing the testing for a data length of 10 rather than 1000 is that\nyour code will probably run far faster. That makes it painless to run the code over and over\nagain adjusting things and examining things till you diagnose the problem.\n\nEnabling small-scale testing requires using parameters and avoiding explicit program-\nming. For example, to construct an array of 1000 x values that goes from 0 to 1 you don't\nwrite x=[0:999]/999, even though that is perfectly correct. You write x=[0:Nlen-1]/(Nlen-1).\nAnd this sort of remark applies to everywhere in your code. Then for small-scale testing you\ncan trivially adjust Nlen, with the ability to put it back to the required value when the bugs\nhave been identified and fixed.\nAnother aspect of debugging is that it works best if done incrementally. This means you\ndevelop a smaller section of code, and by putting in data printing or display statements as\nyou go, you debug the section of code and develop confidence that it is doing something\nsensible.\nYou can always comment out the data displaying statements later.\nOf course\ndisplaying the data as you go will likely be too painful if you start with a giant data length.\nInstead you do it on a small scale. When each section of the code is working on small-scale\ndata, you incorporate it into the whole and move on to the next stage.\nThe world's most effective programmers do not write code that works right first time.\n(Nobody writes code that works right first time.) Instead they write the tests for the code\neither before or during the coding. That way, they know their code works, not because they\nthink they planned it and typed it in correctly, but because it passes the tests. This may\nsound cumbersome, but it is an approach that time after time has been shown to produce\nresults fast.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n22.15 Essential Numerical Methods\nFall 2014\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Exercise 1. Data Fitting",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/22-15-essential-numerical-methods-fall-2014/055565e4cad1580b1cf743de1ed9fac2_MIT22_15F14_ex01.pdf",
      "content": "22.15 Essential Numerical Methods. Fall 2014\nI H Hutchinson\nExercise 1. Data fitting\n1. Given a set of N values yi of a function y(x) at the positions xi, write a short code to fit\na polynomial having order one less than N (so there are N coefficients of the polynomial)\nto the data.\nSelect one of the supplied sets of (N=) 7 numbers.\nThese are the values yi you must take of the function y(x) at the positions\nxi = 0.0, 0.167, 0.333, 0.5, 0.667, .833, 1.0.\nRun your code on this data and find the coefficients cj.\nPlot together (on the same plot) the resulting fitted polynomial representing y(x) (with\nsufficient resolution to give a smooth curve) and the original data points, over the domain\n0 ≤x ≤1.\nSubmit the following as your solution:\na. Your code in a computer format that is capable of being executed.\nb. The numeric values of your coefficients cj, j = 1, N.\nc. Your plot.\nd. Brief commentary (< 300 words) on what problems you faced and how you solved\nthem.\n2. Save your code from part 1. Make a copy of it with a new name and change the new code\nas needed to fit (in the linear least squares sense) a polynomial of order possibly lower than\nN -1 to a set of data xi, yi (for which the points are in no particular order).\nObtain a pair of data sets of length (N =) 25 numbers xi, yi from the same URL. Run\nyour code on that data to produce the fitting coefficients cj when the order of the polynomial\nis (M =) (a) 1, (b) 2, (c) 3. That is: constant, linear, quadratic.\nPlot the fitted curves and the original data points on the same plot(s) for all three cases.\nSubmit the following as your solution:\na. Your code in a computer format that is capable of being executed.\nb. Your coefficients cj, j = 1, M, for three cases (a), (b), (c).\nc. Your plot(s).\nd. Very brief remarks on whether the coefficients are the same for the three cases, and\nwhy.\ne. Can your code from this part also solve the problem of part 1?\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n22.15 Essential Numerical Methods\nFall 2014\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Exercise 2. Integrating Ordinary Differential Equations",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/22-15-essential-numerical-methods-fall-2014/2b3f98158380ebbc32b44c004873bdc0_MIT22_15F14_ex02.pdf",
      "content": "22.15 Essential Numerical Methods. Fall 2014\nI H Hutchinson\nExercise 2. Integrating Ordinary Differential\nEquations.\n1.\nReduce the following higher-order ordinary differential equations to first-order vector\ndifferential equations, which you should write out in vector format.\n(a) d2y =\ndx2\n-x\n(b) Ay + B dy\ndx + C d2y\ndx2 + D d3y\ndx3 = E\n(c) ( d2y\ndx2)2 = 2( dy)3 -y2\ndx\n2. Accuracy order of ODE schemes. For notational convenience, we start at x = y = 0 and\nconsider a small step in x and y of the ODE dy/dx = f(y, x). The Taylor expansion of the\nderivative function along the orbit is\ndf0\nf(y(x), x) = f0 + dx x + d2f0\ndx2\nx2\n2! + . . .\n(1)\n(a)\nIntegrate dy = f(y, x) term by term to find the solution for y(x) to third order in\ndx\nx.\n(b)\nSuppose y1 = f0h/2,. Find y1 -y(h/2) to second order in h.\n(c)\nNow consider y2 = f(y1, h/2)h, show that it is equal to y(h) plus a term that is\nthird order in h; i.e. that it is accurate to second order.\n[Comment. The third order term in part (c) involves the partial derivative ∂f/∂y rather\nthan the derivative along the orbit. Proving rigorously that the fourth order Runge Kutta\nscheme really is fourth order, is rather difficult because it requires keeping track of such\npartial derivatives.]\n3. A leap-frog scheme can be applied to an ordinary differential equation dv/dt = F(x)\nand dx/dt = v. Suppose we have x(t) and v(t -∆t/2). We want to establish the order of\naccuracy of the leap-frog value of the next velocity\nv(t + ∆t/2) = v(t -∆t/2) + F(x(t))∆t.\nR\nThe exact solution is v(t + ∆t/2) = v(t -∆t/2) +\nF(x)dt. We want to evaluate it in the\nneighborhood of time t.\nExpand x(t + δt) as x = x(t) + v(t)δt + F(t)δt2/2! + ...\nExpand F(x) = F(x(t)) + dF/dx δx + d2F/dx2 δx2/2! + ..., where δx = x -x(t).\n(a) Substitute these into the integral and integrate term by term to evaluate\nZ t+∆t/2\n∆v =\nF(x)dt\nt-∆t/2\nto third order in ∆t. [Remember that the integral introduces an additional factor of ∆t so\nyou only need to expand the integrand, F(x), to second order.]\nR\n(b) Hence find the lowest order term of the error in ∆v: namely F(x(t))∆t -\nFdt.\n(c) If the time step range of the integral were instead asymmetric: t -∆t1 →t + ∆t2, where\n∆t1 = ∆t2, what would be the accuracy then?\n\nProgramming Exercise\n(3) Write a program to integrate numerically from t = 0 to\nt = tmax the ODE\ndy\ndt = -ωy\n1 + y2\nwith ω a positive constant, starting from y(0) = 1, using the explicit Euler scheme\nyn+1 = yn -∆tωyn/(1 + y2\nn).\n(a) Find numerically the fractional error at t = 4/ω for the following choices of timestep\n(i) ω∆t = 0.01 (ii) ω∆t = 0.1 (iii) ω∆t = 1.\n(b) What do your results indicate is the order of accuracy of the scheme?\n(c) Find experimentally the timestep value at which the scheme becomes unstable. (This\nmight require you to use tmax > 4/ω.) What is different about the long-time behavior of the\nunstable solution, from the case considered in the text?\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n22.15 Essential Numerical Methods\nFall 2014\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Exercise 3. Solving 2-point ODEs",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/22-15-essential-numerical-methods-fall-2014/123bb3fec6b2b0d6c00b7d2e5d2562f3_MIT22_15F14_ex03.pdf",
      "content": "22.15 Essential Numerical Methods. Fall 2014\nI H Hutchinson\nExercise 3. Solving 2-point ODEs.\n1. Write a code to solve, using matrix inversion, a 2-point ODE of the form\nd2y = f(x)\ndx2\non the x-domain [0, 1], spanned by an equally spaced mesh of N nodes. With Dirichlet\nboundary conditions y(0) = y0, y(1) = y1.\nWhen you have got it working, obtain your personal expressions for f(x), N, y0, and\ny1 from one of the three supplied sets. And solve the differential equation so posed.\nPlot the solution.\nSubmit the following as your solution:\na. Your code in a computer format that is capable of being executed.\nb. The expressions of your problem f(x), N, y0, and y1\nc. The numeric values of your solution yj.\nd. Your plot.\ne. Brief commentary (< 300 words) on what problems you faced and how you solved\nthem.\n2. Save your code and make a copy with a new name. Edit the new code so that it solves\nthe ODE\nd2y + k2y = f(x)\ndx2\non the same domain and with the same boundary conditions, but with the extra parameter\nk2. Verify that your new code works correctly for small values of k2, yielding results close to\nthose of the previous problem.\nInvestigate what happens to the solution in the vicinity of k = π.\nDescribe what the cause of any interesting behavior is.\nSubmit the following as your solution:\na. Your code in a computer format that is capable of being executed.\nb. The expressions of your problem f(x), N, y0, and y1\nc. Brief description (< 300 words) of the results of your investigation and your explana-\ntion.\nd. Back up the explanation with plots if you like.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n22.15 Essential Numerical Methods\nFall 2014\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Exam",
      "title": "Example final exam",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/22-15-essential-numerical-methods-fall-2014/63ba967597ffeb99c0765290162f4821_MIT22_15F14_final_ex.pdf",
      "content": "22.15 Computational Nuclear Science and Engineering.\nExample\nFinal Exam\n3 Hours. Closed Book. No electronic aids.\n1.\nReduce the following ordinary differential equation to a first-order vector differential\nequations, which you should write out completely, in vector format.\nd3y\ndx3\n!3\n--d2y -y2 = 0.\ndx2\n2. Consider an approximate discrete step in x and y, starting at x = y = 0 of the ODE\ndy/dx = f(y, x). The Taylor expansion of the derivative function is\ndf0\nf(y, x) = f0 + dx x + d2f0\ndx2\nx2\n+ . . .\n(1)\n2!\nalong the orbit. The approximate scheme is the following:\n\"Evaluate y1 = f\nx\n0 3, then y2 = f(y1, x) x. The step is then y = [kf1 + (1 -k)f2]x.\"\nFind the value of k that makes this scheme accurate to second order as follows.\n(a) Express the exact solution for y(x) as a Taylor expansion.\n(b) Express y1 in terms of the Taylor expansion.\n(c) Hence find an expression for y2 and finally y complete to second order in x.\n(d) Find the value of k that annihilates (makes zero) the second order term.\n3. Consider the partial differential equation\n∂2ψ\n∂x2 + 2∂2ψ\n∂y2 + 3∂2ψ = 0.\n∂z2\n(a) Is this equation parabolic, elliptic, or hyperbolic?\n(b) Express the equation approximately in terms of discrete finite differences, centered\non the grid point whose x, y, and z indices are (i, j, k), using only immediate adjacent point\nvalues (and i, j, k itself), on a mesh uniform in each coordinate direction, with point spacings\n∆x, ∆y = ∆x, ∆z = 3∆x.\nP\n(c) If this difference equation is written as the sum over stencil points\nn anψn = 0, what\nP\nis the sum of the coefficients\nn an?\n4. A diffusion equation in 2 dimensions with suitably normalized time units is\n∂2ψ\n∂x2 + ∂2ψ\n∂y2 = ∂ψ,\n∂t\non a finite domain with fixed ψ on the boundary. It is to be advanced in time using an\nimplicit scheme.\nψ(n+1) -ψ(n) = ∆t Dψ(n+1).\n\nwhere ψ(n) denotes the value at the nth time step, and is a column vector of the values on\na discrete grid. The matrix D represents the finite difference form of the spatial differential\noperator ∇2. Let the dimensions of ψ be N.\n(a) What is the minimum number of non-zero entries on each row of D?\n(b) Hence what is the minimum number of multiplications needed to evaluate Dψ.\n(c) Show formally how the implicit time-step advance can actually be implemented,\nrequiring a matrix inversion.\n(d) What is the number of multiplications needed to perform each time-step advance\nusing this implementation? By what factor is this bigger than the answer to (b)?\n5. Divergence of acceleration in phase space.\n(a) Prove that particles of charge q moving in a magnetic field B and hence subject to a\nforce qv × B, nevertheless have ∇v.a = 0.\n(b) Consider a frictional force that slows particles down in accordance with a = -Kv,\nwhere K is a constant. What is the \"velocity-divergence\", of this acceleration, ∇v.a? Does\nthis cause the distribution function f to increase or decrease as a function of time?\n(c) Write down (but don't attempt to solve!) the Boltzmann equation governing particles\nthat have both magnetic force (a) and friction force (b).\n6.\nConsider a one-group representation of neutron transport in a slab, one-dimensional,\nreactor of length 2L. The reactor has uniform material properties; so that the steady diffusion\nequation becomes\n-D\nφ∇Φ + (Σt -S)Φ -\nFΦ = 0\nk\nwhere the diffusion coefficient Dφ, the total attenuation \"macroscopic cross-section\" Σt, the\nscattering and fission source terms S, F, are simply scalar constants. For convenience, write\nΣt -S = Σ. The eigenvalue k must be found for this equation.\nThe boundary conditions at x = ±L are that the flux satisfy Φ = 0.\nFormulate the finite-difference diffusion equation on a uniform mesh of Nx nodes; node\nspacing ∆x = 2L/(Nx -1). Exhibit it in the form of a matrix equation\n[M -\nF]Φ = 0\nk\nAnd write out the matrix M explicitly for the case Nx = 5 (so M is 5×5), carefully consid-\nering the incorporation of the finite-difference boundary condition.\nState in no more than a few sentences the significance of the eigenvalue k, and how one\nmight find its value numerically.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n22.15 Essential Numerical Methods\nFall 2014\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Exam",
      "title": "Final exam from 2013",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/22-15-essential-numerical-methods-fall-2014/67f649894fbb18d7fcf8c00786312948_MIT22_15F14_final_2013.pdf",
      "content": "22.15 Computational Nuclear Science and Engineering.\nFall 2013\nFinal Exam\n3 Hours. Closed Book. No written or electronic aids.\nFinish as many questions as possible in the time.\n21 Oct 2013, 9am to 12noon. NW14-1112.\n14% 1.\nReduce the following ordinary differential equation to a first-order vector differential\nequation, which you should write out completely, in vector format.\nd3y\ndx3\n!2\n-2d2y\ndx2 -dy -y3 = 0.\ndx\n18% 2. Consider an approximate discrete step in x and y, starting at xn, yn of the ODE dy/dx =\nf(y, x).\nThe Taylor expansion of the derivative function along the solution in terms of\nδx = x -xn is\ndfn\nf(y(x), x) = fn + dx δx + d2fn\ndx2\nδx2\n+ . . . .\n(1)\n2!\nSubscript n on f and its derivatives denotes evaluated at xn, yn. The approximate scheme\nis the following for the step from xn to xn+1 = xn + ∆x:\n\"Evaluate y(1) = yn + f\n∆x\nn\n, then take the step to be yn+1 = yn + f(y(1), xn + ∆x\n2 ) ∆x.\"\nDocument the accuracy of this scheme, using the notation xn + ∆x\n2 = xn+ 1 as follows.\n(a) Express the exact solution for y(x) as a Taylor expansion.\n(b) Express the quantity y(1) -y(xn + ∆x/2) in terms of the Taylor expansion.\n(c) Express f(y(1), xn+ 1\n2) -f(y(xn+ 1\n2), xn+ 1\n2) to lowest order in y(1) -y(xn+ 1\n2) using ∂f .\n∂y\n(d) Hence find an expression for yn+1 correct to third order in ∆x, and state the order\nto which this scheme is accurate.\n18% 3. A diffusion equation in 2 dimensions with suitably normalized time units is\n∂ψ\n∂t = ∂2ψ\n∂x2 + ∂2ψ,\n∂y2\non a finite domain with fixed ψ on the boundary. It is to be advanced in time using an\nexplicit scheme.\n(n+1)\n(n)\nψj,k\n-ψj,k = ∆t Dψ(n).\nwhere ψ(n) denotes the value at the nth time step.\nThe matrix D represents the finite\ndifference form of the spatial differential operator ∇2 on a uniform grid with spacing ∆x and\n∆y in the x and y directions, whose indices are j, k.\n(a) Write out the right-hand-side (∆tDψ(n)) of the above discrete difference equation\nin terms of a stencil of coefficients (whose values you should specify) times values ψj,k at\nadjacent j, k positions, to complete the formulation of the difference scheme.\n(b) Consider a particular Fourier mode ∝exp(ikxx) exp(ikyy). Substitute it into the\ndifference equation, and rearrange the resultant into the form ψ(n+1) = Aψ(n). Hence find\nthe amplification factor, A.\nPage 1 of 3\n\n(c) Deduce the condition that ∆t must satisfy to make this mode stable.\n(d) By deciding which kx and ky are the most unstable, deduce the requirement on ∆t\nfor the whole scheme to be stable.\n18% 4. Consider the partial differential system in time t and one spatial coordinate x\n∂\n∂tu + ∂f = 0\n∂x\nwhere in terms of the components of u (which, incidentally, is not a velocity):\n\nu\nv\n\nu = v ,\nf = v2/u + w ,\nw\n-kv\nwith k a constant. Use the chain rule of spatial differentiation of f(u) to write the equations\nas\n∂\n∂tu = -J ∂u.\n∂x\n(a) Find the entire 3 × 3 matrix J and write it out in tabular form.\n(b) Find the eigenvalues of J.\n(c) Under what conditions is this system hyperbolic?\n(d) Assuming these conditions are satisfied, what are the characteristic speeds of propa-\ngation of disturbances?\n(e) If a suitable explicit discrete finite difference scheme is used to solve this system\nnumerically, then it is stable provided that the Courant-Friedrichs-Lewy (CFL) condition\nis satisfied. Unless you have lots of unused time, don't derive this condition for any par-\nticular scheme. Instead, just state how it relates ∆t, ∆x and the characteristic speeds of\npropagation.\n14% 5. A random variable is required, distributed on the interval 0 ≤x ≤1 with probability\ndistribution p(x) = 2(1 -x). A library routine is available that returns a uniform random\nvariate y (i.e. with uniform probability 0 ≤y ≤1). Give formulas and an algorithm to\nobtain the required randomly distributed x value from the returned y value.\n18% 6. (a) Write out Boltzmann's equation governing the velocity distribution function f(t, x, v)\nin time, t, and one-dimension in space x, and velocity v, for particles subject to a positive uni-\nform constant acceleration a, which collide with a uniform background of stationary targets\nof density n2 that do nothing but absorb the particles with a cross-section, σ, independent\nof velocity.\n(b) Sketch in phase space (x, v) the paths of the trajectories (\"orbits\") of the particles.\n(c) Obtain the equation of the trajectories in the form v0 = g(x, v), where v0 is the\nvelocity on the orbit at position x = 0, and g(v, x) is a (relatively simple) function of x and\nv, which you must find.\n(d) Prove that\nf(x, v) = f0(g(x, v)) exp(-n2σx)\nPage 2 of 3\n\nis a solution of the steady-state (∂/∂t = 0) Boltzmann equation. The function f0(v0) is the\ndistribution function at x = 0.\n(c) If f\n0(v0) = 1/(1+v0) for v0 > 0, then find the distribution function f(x, v) at position\nx > 0 and velocity v such that v0 is real, in steady state\n(d) If there are no particle sources in the positive half-plane x > 0, what is the value of\nf(x, v) in steady state for x > 0, when v is such that v0 is imaginary? Why?\nPage 3 of 3\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n22.15 Essential Numerical Methods\nFall 2014\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    }
  ]
}