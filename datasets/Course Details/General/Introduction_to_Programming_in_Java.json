{
  "course_name": "Introduction to Programming in Java",
  "course_description": "This course is an introduction to software engineering, using the Java™ programming language. It covers concepts useful to 6.005. Students will learn the fundamentals of Java. The focus is on developing high quality, working software that solves real problems.\nThe course is designed for students with some programming experience, but if you have none and are motivated you will do fine. Students who have taken 6.005 should not take this course. Each class is composed of one hour of lecture and one hour of assisted lab work.\nThis course is offered during the Independent Activities Period (IAP), which is a special 4-week term at MIT that runs from the first week of January until the end of the month.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering",
    "Engineering",
    "Computer Science",
    "Programming Languages",
    "Software Design and Engineering"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week for 4 weeks, 1 hour / session\n\nLabs: 2 sessions / week for 4 weeks, 1 hour / session\n\nDescription\n\nThis course is an introduction to software engineering, using the JavaTM programming language. It covers concepts useful to 6.005. Students will learn the fundamentals of Java. The focus is on developing high quality, working software that solves real problems.\n\nThe course is designed for students with some programming experience, but if you have none and are motivated you will do fine. Students who have taken 6.005 should not take this course. Each class is composed of one hour of lecture and one hour of assisted lab work.\n\nInstalling Java and Eclipse\n\nTo write Java programs, you need two things: the Java Development Kit (JDK), and a source code editor. Please follow these directions before the first class, so you can get started on the first assignment faster. If you run into difficulty, we can help you during the first class.\n\nThe Java Development Kit contains the tools needed to compile and run Java programs. The source code editor lets you write programs, and has features to make this easier. For this course, you can use any tool you like, but we recommend Eclipse, and will demonstrate it during the first lecture.\n\nEditors\n\nTo write programs, you need a piece of software called an editor. They come in two flavors: simple source code editors, or complex integrated development environments. For this course, we recommend using the Eclipse Integrated Development Environment (IDE), but it is useful to be aware of the options that are available to you.\n\nSource Code Editors\n\nA source code editor is a program for editing text, like a word processor, but it has features which make it easier to read and write computer programs. An advantage of using a plain source code editor is that they are usually lightweight applications that are easy to learn and use. Additionally, the editors typically support many programming languages, so you can use the same tool for all your work. The disadvantage is that you will need to use the command line to run the compiler, and to organize larger projects.\n\nFor Windows, some popular source code editors are\nSciTE\n,\nUltraEdit\n,\nZeus\n(\nold free version\n), or\njEdit\n. Mac users might want to look at\nTextMate\n,\nSubEthaEdit\n(\nold free version\n),\nTextWrangler\n, or\njEdit\n. (Note: some of these are trial versions of software that you need to purchase.)\n\nIntegrated Development Environments (IDEs)\n\nMost professional Java developers use an integrated development environment (IDE), which combines a source code editor with other tools for software development. They make it easy to find and correct errors, and to accomplish tasks through a graphical interface, instead of the command line. In this class, we recommend using\nEclipse\n. Other popular IDEs for Java include\nNetBeans\nand\nIntelliJ IDEA\n.\n\nWindows\n\nInstall the Sun Java 6 JDK\n\nYou want to install the Java Standard Edition (SE) development kit (JDK). You can find this through Sun's\nJava download site\n, but follow these directions for the direct link:\n\nGo to the\nJava SE JDK\ndownload page.\n\nOn the left side, under Platform, select Windows.\n\nClick the Download button.\n\nClick the \"Skip this step\" link at the bottom of the dialog box that pops up.\n\nWait for your download to finish.\n\nRun the installer and follow the directions. Accept the default settings.\n\nInstall Eclipse\n\nYou want the Eclipse IDE for Java developers. You can find this on the\nEclipse download site\n, but follow these directions for the direct link:\n\nDownload the Eclipse IDE for Java Developers\n.\n\nOpen the zip file that you downloaded. It contains a single folder named eclipse.\n\nDrag and drop the eclipse folder into C:\\Program Files, and perhaps rename it Eclipse. You can actually put the folder anywhere, but C:\\Program Files is the typical location.\n\nStart Eclipse by double clicking on eclipse.exe.\n\nOptional: To make it easy to find in the future, create a shortcut from eclipse.exe your Desktop, and rename it Eclipse (drag with the right mouse button to create a shortcut).\n\nMac OS X\n\nMac OS X comes with the Java development tools. Run Software Update to ensure that you have the latest version installed (Apple Menu → Software Update).\n\nInstall Eclipse\n\nDownload the Eclipse IDE for Java Developers\n.\n\nOpen the archive file that you downloaded (Safari may have expanded it automatically for you).\n\nDrag and drop the eclipse folder anywhere you want it (your Desktop may be a good place).\n\nRun Eclipse by double clicking the Eclipse application inside the eclipse folder.\n\nLinux\n\nIf you are using Linux, you probably don't need our help to get Java and Eclipse running yourself. If you do need help, ask one of the instructors during the first lecture.",
  "files": [
    {
      "category": "Lecture Notes",
      "title": "Lecture 1: Types, Variables, Operators",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-introduction-to-programming-in-java-january-iap-2010/4fb0ecc598d077817cd27eeb30a7882a_MIT6_092IAP10_lec01.pdf",
      "content": "6.092: Introduction to Java \n1: Types, Variables, Operators\n\nGoal\nLearn enough Java to do something\nuseful\nExamples:\n- Simulate a natural/engineering process\n- Manipulate PDFs\n- Draw pretty graphics\n\nAssignments\n-\nView and submit via Stellar\n-\nDue at 3 PM the next day (24 hours)\n-\nCollaborate with others\n-\nWrite your own code\n-\nMust submit first assignment\nMust submit a \"reasonable\" attempt for 6/7\nassignments to pass\n\nThe Computer\nCentral\nProcessing Unit\n(CPU)\nInput/Output\n(IO) Devices\nMemory\n\nCPU Instructions\nz = x + y\nRead location x\nRead location y\nAdd\nWrite to location z\n\nProgramming Languages\n- Easier to understand than CPU\ninstructions\n- Needs to be translated for the CPU to\nunderstand it\n\nJava\n- \"Most popular\" language\n- Runs on a \"virtual machine\" (JVM)\n- More complex than some (eg. Python)\n- Simpler than others (eg. C++)\n\nCompiling Java\nSource Code\n(.java)\nByte Code\n(.class)\njavac\njava\n\nFirst Program\nclass Hello {\npublic static void main(String[] arguments) {\n// Program execution begins here\nSystem.out.println(\"Hello world.\");\n}\n}\n\nProgram Structure\nclass CLASSNAME {\npublic static void main(String[] arguments) {\nSTATEMENTS\n}\n}\n\nOutput\nSystem.out.println(some String) outputs to\nthe console\nExample:\nSystem.out.println(\"output\");\n\nSecond Program\nclass Hello2 {\npublic static void main(String[] arguments) {\nSystem.out.println(\"Hello world.\"); // Print once\nSystem.out.println(\"Line number 2\"); // Again!\n}\n}\n\nTypes\nKinds of values that can be stored and\nmanipulated.\nboolean: Truth value (true or false).\nint: Integer (0, 1, -47).\ndouble: Real number (3.14, 1.0, -2.1).\nString: Text (\"hello\", \"example\").\n\nVariables\nNamed location that stores a value of one\nparticular type.\nForm: \nTYPE NAME;\nExample:\nString foo;\n\nAssignment\nUse = to give variables a value.\nExample:\nString foo;\nfoo = \"IAP 6.092\";\n\nAssignment\nCan be combined with a variable\ndeclaration.\nExample:\ndouble badPi = 3.14;\nboolean isJanuary = true;\n\nclass Hello3 {\npublic static void main(String[] arguments) {\nString foo = \"IAP 6.092\";\nSystem.out.println(foo);\nfoo = \"Something else\";\nSystem.out.println(foo);\n}\n}\n\nOperators\nSymbols that perform simple computations\nAssignment: =\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\n\nOrder of Operations\nFollows standard math rules:\n1. Parentheses\n2. Multiplication and division\n3. Addition and subtraction\n\nclass DoMath {\npublic static void main(String[] arguments) {\ndouble score = 1.0 + 2.0 * 3.0;\nSystem.out.println(score);\nscore = score / 2.0;\nSystem.out.println(score);\n}\n}\n\nclass DoMath2 {\npublic static void main(String[] arguments) {\ndouble score = 1.0 + 2.0 * 3.0;\nSystem.out.println(score);\ndouble copy = score;\ncopy = copy / 2.0;\nSystem.out.println(copy);\nSystem.out.println(score);\n}\n}\n\nString Concatenation (+)\nString text = \"hello\" + \" world\";\ntext = text + \" number \" + 5;\n// text = \"hello world number 5\"\n\nAssignment: GravityCalculator\nCompute the position of a falling object:\nx(t) = 0.5 × at2 + vit + xi\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.092 Introduction to Programming in Java\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 2: More types, Methods, Conditionals",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-introduction-to-programming-in-java-january-iap-2010/681c9db795b48f68b58e45210620dae4_MIT6_092IAP10_lec02.pdf",
      "content": "6.092: Intro to Java\n2: More types, Methods,\nConditionals\n\nOutline\n- Lecture 1 Review\n- More types\n- Methods\n- Conditionals\n\nTypes\nKinds of values that can be stored and\nmanipulated.\nboolean: Truth value (true or false).\nint: Integer (0, 1, -47).\ndouble: Real number (3.14, 1.0, -2.1).\nString: Text (\"hello\", \"example\").\n\nVariables\nNamed location that stores a value\nExample:\nString a = \"a\";\nString b = \"letter b\";\na = \"letter a\";\nString c = a + \" and \" + b;\n\nOperators\nSymbols that perform simple computations\nAssignment: =\nAddition: +\nSubtraction:\nMultiplication: *\nDivision: /\n\nclass GravityCalculator {\npublic static void main(String[] args) {\ndouble gravity = -9.81;\ndouble initialVelocity = 0.0;\ndouble fallingTime = 10.0;\ndouble initialPosition = 0.0;\ndouble finalPosition = .5 * gravity * fallingTime *\nfallingTime;\nfinalPosition = finalPosition +\ninitialVelocity * fallingTime;\nfinalPosition = finalPosition + initialPosition;\nSystem.out.println(\"An object's position after \" +\nfallingTime + \" seconds is \" +\nfinalPosition + \" m.\");\n}\n}\n\nfinalPosition = finalPosition +\ninitialVelocity * fallingTime;\nfinalPosition = finalPosition + initialPosition;\nOR\nfinalPosition += initialVelocity * fallingTime;\nfinalPosition += initialPosition;\n\nQuestions from last lecture?\n\nOutline\n- Lecture 1 Review\n- More types\n- Methods\n- Conditionals\n\nDivision\nDivision (\"/\") operates differently on\nintegers and on doubles!\nExample:\ndouble a = 5.0/2.0; // a = 2.5\nint b = 4/2; // b = 2\nint c = 5/2; // c = 2\ndouble d = 5/2; // d = 2.0\n\nOrder of Operations\nPrecedence like math, left to right\nRight hand side of = evaluated first\nParenthesis increase precedence\ndouble x = 3 / 2 + 1; // x = 2.0\ndouble y = 3 / (2 + 1); // y = 1.0\n\nMismatched Types\nJava verifies that types always match:\nString five = 5; // ERROR!\ntest.java.2: incompatible types\nfound: int\nrequired: java.lang.String\nString five = 5;\n\nConversion by casting\nint a = 2; // a = 2\ndouble a = 2; // a = 2.0 (Implicit)\nint a = 18.7; // ERROR\nint a = (int)18.7; // a = 18\ndouble a = 2/3;\n// a = 0.0\ndouble a = (double)2/3; // a = 0.6666...\n\nOutline\n- Lecture 1 Review\n- More types\n- Methods\n- Conditionals\n\nMethods\n{\n}\npublic static void main(String[] arguments)\nSystem.out.println(\"hi\");\n\nAdding Methods\npublic static void NAME() {\nSTATEMENTS\n}\nTo call a method:\nNAME();\n\nclass NewLine {\npublic static void newLine() {\nSystem.out.println(\"\");\n}\npublic static void threeLines() {\nnewLine(); newLine(); newLine();\n}\npublic static void main(String[] arguments) {\nSystem.out.println(\"Line 1\");\nthreeLines();\nSystem.out.println(\"Line 2\");\n}\n}\n\nclass NewLine {\npublic static void newLine() {\nSystem.out.println(\"\");\n}\npublic static void main(String[] arguments) {\nSystem.out.println(\"Line 1\");\nthreeLines();\nSystem.out.println(\"Line 2\");\npublic static void threeLines() {\nnewLine(); newLine(); newLine();\n}\n}\n}\n\npublic static void main(String[] arguments) {\nSystem.out.println(\"Line 1\");\nthreeLines();\nSystem.out.println(\"Line 2\");\npublic static void threeLines() {\nnewLine(); newLine(); newLine();\n}\nclass NewLine {\npublic static void\n\"\"\nnewLine() {\nSystem.out.println( );\n}\n}\n}\n\nParameters\npublic static void NAME(TYPE NAME) {\nSTATEMENTS\n}\nTo call:\nNAME(EXPRESSION);\n\nclass Square {\npublic static void printSquare(int x) {\nSystem.out.println(x*x);\n}\npublic static void main(String[] arguments) {\nint value = 2;\nprintSquare(value);\nprintSquare(3);\nprintSquare(value*2);\n}\n}\n\nclass Square2 {\npublic static void printSquare(int x) {\nSystem.out.println(x*x);\n}\npublic static void main(String[] arguments) {\nprintSquare(\"hello\");\nprintSquare(5.5);\n}\n}\nWhat's wrong here?\n\nclass Square3 {\npublic static void printSquare(double x) {\nSystem.out.println(x*x);\n}\npublic static void main(String[] arguments) {\nprintSquare(5);\n}\n}\nWhat's wrong here?\n\nMultiple Parameters\n[...] NAME(TYPE NAME, TYPE NAME) {\nSTATEMENTS\n}\nTo call:\nNAME(arg1, arg2);\n\nclass Multiply {\npublic static void times (double a, double b) {\nSystem.out.println(a * b);\n}\npublic static void main(String[] arguments) {\ntimes (2, 2);\ntimes (3, 4);\n}\n}\n\nReturn Values\npublic static TYPE NAME() {\nSTATEMENTS\nreturn EXPRESSION;\n}\nvoid means \"no type\"\n\nclass Square3 {\npublic static void printSquare(double x) {\nSystem.out.println(x*x);\n}\npublic static void main(String[] arguments) {\nprintSquare(5);\n}\n}\n\nclass Square4 {\npublic static double square(double x) {\nreturn x*x;\n}\npublic static void main(String[] arguments) {\nSystem.out.println(square(5));\nSystem.out.println(square(2));\n}\n}\n\nVariable Scope\nVariables live in the block ({}) where they\nare defined (scope)\nMethod parameters are like defining a\nnew variable in the method\n\nclass SquareChange {\npublic static void printSquare(int x) {\nSystem.out.println(\"printSquare x = \" + x);\nx = x * x;\nSystem.out.println(\"printSquare x = \" + x);\n}\npublic static void main(String[] arguments) {\nint x = 5;\nSystem.out.println(\"main x = \" + x);\nprintSquare(x);\nSystem.out.println(\"main x = \" + x);\n}\n}\n\nclass Scope {\npublic static void main(String[] arguments) {\nint x = 5;\nif (x == 5) {\nint x = 6;\nint y = 72;\nSystem.out.println(\"x = \" + x + \" y = \" + y);\n}\nSystem.out.println(\"x = \" + x + \" y = \" + y);\n}\n}\n\nMethods: Building Blocks\n- Big programs are built out of small methods\n- Methods can be individually developed, tested and\nreused\n- User of method does not need to know how it works\n- In Computer Science, this is called \"abstraction\"\n\nMathematical Functions\nMath.sin(x)\nMath.cos(Math.PI / 2)\nMath.pow(2, 3)\nMath.log(Math.log(x + y))\n\nOutline\n- Lecture 1 Review\n- More types\n- Methods\n- Conditionals\n\nif statement\nif (CONDITION) {\nSTATEMENTS\n}\n\npublic static void test(int x) {\nif (x > 5) {\nSystem.out.println(x + \" is > 5\");\n}\n}\npublic static void main(String[] arguments) {\ntest(6);\ntest(5);\ntest(4);\n}\n\nComparison operators\nx > y: x is greater than y\nx < y: x is less than y\nx >= y: x is greater than or equal to x\nx <= y: x is less than or equal to y\nx == y: x equals y\n( equality: ==, assignment: = )\n\nBoolean operators\n&&: logical AND\n||: logical OR\nif ( x > 6 && x < 9) {\nif (x > 6) {\n...\nif (x < 9) {\n}\n...\n}\n}\n\nelse\nif (CONDITION) {\nSTATEMENTS\n} else {\nSTATEMENTS\n}\n\npublic static void test(int x) {\nif (x > 5) {\nSystem.out.println(x + \" is > 5\");\n} else {\nSystem.out.println(x + \" is not > 5\");\n}\n}\npublic static void main(String[] arguments) {\ntest(6);\ntest(5);\ntest(4);\n}\n\nelse if\nif (CONDITION) {\nSTATEMENTS\n} else if (CONDITION) {\nSTATEMENTS\n} else if (CONDITION) {\nSTATEMENTS\n} else {\nSTATEMENTS\n}\n\npublic static void test(int x) {\nif (x > 5) {\nSystem.out.println(x + \" is > 5\");\n} else if (x == 5) {\nSystem.out.println(x + \" equals 5\");\n} else {\nSystem.out.println(x + \" is < 5\");\n}\n}\npublic static void main(String[] arguments) {\ntest(6);\ntest(5);\ntest(4);\n}\n\nQuestions?\n\nAssignment: FooCorporation\nMethod to print pay based on base pay and\nhours worked\nOvertime: More than 40 hours, paid 1.5 times\nbase pay\nMinimum Wage: $8.00/hour\nMaximum Work: 60 hours a week\n\nReminder\n- Write your own code\n- Homework due tomorrow (Wednesday)\n3pm on Stellar.\n\nConversion by method\nint to String:\nString five = 5; // ERROR!\nString five = Integer.toString (5);\nString five = \"\" + 5; // five = \"5\"\nString to int:\nint foo = \"18\"; // ERROR!\nint foo = Integer.parseInt (\"18\");\n\nComparison operators\n- Do NOT call == on doubles! EVER.\ndouble a = Math.cos (Math.PI / 2);\ndouble b = 0.0;\na = 6.123233995736766E-17\na == b will return FALSE!\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.092 Introduction to Programming in Java\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 3: Loops,  Arrays",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-introduction-to-programming-in-java-january-iap-2010/5b55c703cbb7ada8d1bd72e58a1b4fbf_MIT6_092IAP10_lec03.pdf",
      "content": "6.092: Intro to Java\n3: Loops, Arrays\n\nAssignment 2\nFoo Corporation needs a program to calculate\nhow much to pay their employees.\n1. Pay = hours worked x base pay\n2. Hours over 40 get paid 1.5 the base pay\n3. The base pay must be no less than $8.00\n4. The number of hours must be no more than 60\n\nFrequent Issues (I)\nThe signature of the main method cannot be\nmodified.\npublic static void main(String[] arguments) {\n...\n}\n\nFrequent Issues (II)\nReturn values: if you declare that the method is not void,\nthen it has to return something!\npublic static int pay(double basePay, int hours) {\nif (basePay < 8.0) return -1;\nelse if (hours > 60) return -1;\nelse {\nint salary = 0;\n...\nreturn salary\n}\n}\n\nFrequent Issues (III)\nDon't create duplicate variables with the same\nname\npublic static int pay(double basePay, int hours) {\nint salary = 0;\n// OK\n...\nint salary = 0;\n// salary already defined!!\n...\ndouble salary = 0; //salary already defined!!\n...\n}\n\nclass WeeklyPay {\npublic static void pay(double basePay, int hours) {\nif (basePay < 8.0) {\nSystem.out.println(\"You must be paid at least $8.00/hour\");\n} else if (hours > 60) {\nSystem.out.println(\"You can't work more than 60 hours a week\");\n} else {\nint overtimeHours = 0;\nif (hours > 40) {\novertimeHours = hours - 40;\nhours = 40;\n}\ndouble pay = basePay * hours;\npay += overtimeHours * basePay * 1.5;\nSystem.out.println(\"Pay this employee $\" + pay);\n}\n}\npublic static void main(String[] arguments) {\npay(7.5, 35);\npay(8.2, 47);\npay(10.0, 73);\n}\n}\n\nWhat we have learned so far\n● Variables & types\n● Operators\n● Type conversions & casting\n● Methods & parameters\n● If statement\n\nToday's Topics\n● Good programming style\n● Loops\n● Arrays\n\nGood Programming Style\n\nGood programming style\nThe goal of good style is to make your\ncode more readable.\nBy you and by others.\n\nRule #1: use good (meaningful) names\nString a1;\nint a2;\ndouble b;\n// BAD!!\nString firstName; // GOOD\nString lastName; // GOOD\nint temperature; // GOOD\n\nRule #2: Use indentation\npublic static void main (String[] arguments) {\nint x = 5;\nx = x * x;\nif (x > 20) {\nSystem.out.println(x + \" is greater than 20.\");\n}\ndouble y = 3.4;\n}\nHave a demo with no indentation\nCtrl-shift-F to auto-format the file\n\nRule #3: Use whitespaces\nPut whitespaces in complex expressions:\n// BAD!!\ndouble cel=fahr*42.0/(13.0-7.0);\n// GOOD\ndouble cel = fahr * 42.0 / (13.0 - 7.0);\n\nRule #3: Use whitespaces\nPut blank lines to improve readability:\npublic static void main (String[] arguments) {\nint x = 5;\nx = x * x;\nif (x > 20) {\nSystem.out.println(x + \" is > 20.\");\n}\ndouble y = 3.4;\n}\n\nRule #4: Do not duplicate tests\nif (basePay < 8.0) {\n...\n} else if (hours > 60) {\n...\n} else if (basePay >= 8.0 && hours <= 60) {\n...\n}\n\nRule #4: Do not duplicate tests\nif (basePay < 8.0) {\n...\n} else if (hours > 60) {\n...\n} else if (basePay >= 8.0 && hours <= 60){\n...\n}\nBAD\n\nRule #4: Do not duplicate tests\nif (basePay < 8.0) {\n...\n} else if (hours > 60) {\n...\n} else {\n...\n}\n\nGood programming style (summary)\nUse good names for variables and methods\nUse indentation\nAdd whitespaces\nDon't duplicate tests\n\noops\nLoops\n\nLoops\nstatic void main (String[] arguments) {\nSystem.out.println(\"Rule #1\");\nSystem.out.println(\"Rule #2\");\nSystem.out.println(\"Rule #3\");\n}\nWhat if you want to do it for 200 Rules?\n\nLoops\nLoop operators allow to loop through a block\nof code.\nThere are several loop operators in Java.\n\nThe while operator\nwhile (condition) {\nstatements\n}\n\nThe while operator\nint i = 0;\nwhile (i < 3) {\nSystem.out.println(\"Rule #\" + i);\ni = i+1;\n}\nCount carefully\nMake sure that your loop has a chance to finish.\n\nThe for operator\nfor (initialization;condition;update){\nstatements\n}\n\nThe for operator\nfor (int i = 0; i < 3; i=i+1) {\nSystem.out.println(\"Rule #\" + i);\n}\nNote: i = i+1 may be replaced by i++\n\nS\n}\nBranching Statements\nbreak terminates a for or while loop\nbreak;\nystem.out.println(\"Rule #\" + i);\nfor (int i=0; i<100; i++) {\nif(i == 50)\n\nr\nBranching Statements\ncontinue skips the current iteration of a loop\nand proceeds directly to the next iteration\nfo (int i=0; i<100; i++) {\nif(i == 50)\ncontinue;\nSystem.out.println(\"Rule #\" + i);\n}\n\nEmbedded loops\nfor (int i = 0; i < 3; i++) {\nfor (int j = 2; j < 4; j++) {\nSystem.out.println (i + \" \" + j);\n}\n}\nScope of the variable defined in the initialization:\nrespective for block\n\nArrays\n\nArrays\nAn array is an indexed list of values.\nYou can make an array of any type\nint, double, String, etc..\nAll elements of an array must have the same type.\n\nArrays\n..\n3 ..\nn-1\n\nArrays\nExample: double [ ]\n5.0\n2.44\n9.01\n1.0\n-9.9\n..\n3 ..\nn-1\n\nArrays\nThe index starts at zero and ends at length-1.\nExample:\nint[] values = new int[5];\nvalues[0] = 12; // CORRECT\nvalues[4] = 12; // CORRECT\nvalues[5] = 12; // WRONG!! compiles but\n// throws an Exception\n// at run-time\nHave a demo with runtime exception\n\nArrays\nAn array is defined using TYPE[].\nArrays are just another type.\nint[]\nvalues;\n// array of int\nint[][] values;\n// int[] is a type\n\nArrays\nTo create an array of a given size, use the operator new :\nint[] values = new int[5];\nor you may use a variable to specify the size:\nint size = 12;\nint[] values = new int[size];\n\nArray Initialization\nCurly braces can be used to initialize an array.\nIt can ONLY be used when you declare the\nvariable.\nint[] values = { 12, 24, -23, 47 };\n\nQuiz time!\nIs there an error in this code?\nint[] values = {1, 2.5, 3, 3.5, 4};\n\nAccessing Arrays\nTo access the elements of an array, use the [] operator:\nvalues[index]\nExample:\nint[] values = { 12, 24, -23, 47 };\nvalues[3] = 18;\n// {12,24,-23,18}\nint x = values[1] + 3; // {12,24,-23,18}\n\nThe length variable\nEach array has a length variable built-in that\ncontains the length of the array.\nint[] values = new int[12];\nint size = values.length; // 12\nint[] values2 = {1,2,3,4,5}\nint size2 = values2.length; // 5\n\nString arrays\nA side note\npublic static void main (String[] arguments){\nSystem.out.println(arguments.length);\nSystem.out.println(arguments[0]);\nSystem.out.println(arguments[1]);\n}\n\nCombining Loops and Arrays\n\nLooping through an array\nExample 1:\nint[] values = new int[5];\nfor (int i=0; i<values.length; i++) {\nvalues[i] = i;\nint y = values[i] * values[i];\nSystem.out.println(y);\n}\n\nLooping through an array\nExample 2:\nint[] values = new int[5];\nint i = 0;\nwhile (i < values.length) {\nvalues[i] = i;\nint y = values[i] * values[i];\nSystem.out.println(y);\ni++;\n}\n\nSummary for today\n1. Programming Style\n2. Loops\n3. Arrays\n\nAssignment 3\nA group of friends participate in the Boston\nMarathon.\nFind the best performer.\nFind the second-best performer.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.092 Introduction to Programming in Java\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 4: Classes and Objects",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-introduction-to-programming-in-java-january-iap-2010/e95ec6cf928f08259a01bda319484655_MIT6_092IAP10_lec04.pdf",
      "content": "Lecture 4\nClasses and Objects\n\nReview\n\nSolutions 1\npublic static int getMinIndex(int[] values) {\nint minValue = Integer.MAX_VALUE;\nint minIndex = -1;\nfor(int i=0; i<values.length; i++)\nif (values[i] < minValue) {\nminValue = values[i];\nminIndex = i;\n}\nreturn minIndex;\n}\n\nSolutions 2\npublic static int getSecondMinIndex(int[] values) {\nint secondIdx = -1;\nint minIdx= getMinIndex(values);\nfor(int i=0; i<values.length; i++) {\nif (i == minIdx)\ncontinue;\nif (secondIdx == -1 ||\nvalues[i] < values[secondIdx])\nsecondIdx = i;\n}\nreturn secondIdx;\n}\n- What happens if values = {0}? values = {0, 0}? values = {0,1}?\n\nPopular Issues 1\n- Array Index vs Array Value\nint[] values = {99, 100, 101};\nSystem.out.println(values[0] ); // 99\nValues\n99 100 101\nIndexes\n\nPopular Issues 2\n- Curly braces { ... } after if/else, for/while\nfor (int i = 0; i < 5; i++)\nSystem.out.println(\"Hi\");\nSystem.out.println(\"Bye\");\n- What does this print?\n\nPopular Issues 3\n- Variable initialization\nint getMinValue(int[] vals) {\nint min = 0;\nfor (int i = 0; i < vals.length; i++) {\nif (vals[i] < min) {\nmin = vals[i]\n}\n}\n}\nProblem?\n- What if vals = {1,2,3}?\n- Set min = Integer.MAX_VALUE or vals[0]\n\nPopular Issues 4\n- Variable Initialization - secondMinIndex\nint minIdx = getMin(vals)\nint secondIdx = 0;\nfor (int i = 0; i < vals.length; i++) {\nif (i == minIdx) continue;\nif (vals[i] < vals[secondIdx])\nsecondIdx = i;\n}\n- What if vals = {0, 1, 2}?\n- See solutions\n\nPopular Issues 5\nDefining a method inside a method\npublic static void main(String[] arguments) {\npublic static void foobar () {\n}\n}\n\nDebugging Notes 1\n- Use System.out.println throughout your code\nto see what it's doing\nfor ( int i=0; i< vals.length; i++) {\nif ( vals[i] < minVal) {\nSystem.out.println(\"cur min: \" + minVal);\nSystem.out.println(\"new min: \" + vals[i]);\nminVal = vals[i];\n}\n}\n\nDebugging Notes 2\n- Formatting\n- Ctrl-shift-f is your friend\nfor (int i = 0; i < vals.length; i++) {\nif (vals[i] < vals[minIdx]) {\nminIdx=i;}\nreturn minIdx;}\n- Is there a bug? Who knows! Hard to read\n\nToday's Topics\nObject oriented programming\nDefining Classes\nUsing Classes\nReferences vs Values\nStatic types and methods\n\nToday's Topics\nObject oriented programming\nDefining Classes\nUsing Classes\nReferences vs Values\nStatic types and methods\n\nObject oriented programming\n- Represent the real world\nBaby\n\nObject oriented programming\n- Represent the real world\nBaby\nName\nSex\nWeight\nDecibels\n# poops so far\n\nObject Oriented Programming\n- Objects group together\n- Primitives (int, double, char, etc..)\n- Objects (String, etc...)\nBaby\nString name\nboolean isMale\ndouble weight\ndouble decibels\nint numPoops\n\nWhy use classes?\n- Why not just primitives?\n// little baby alex\nString nameAlex;\ndouble weightAlex;\n// little baby david\nString nameDavid;\ndouble weightDavid;\n\nWhy use classes?\n- Why not just primitives?\n// little baby alex\nString nameAlex;\ndouble weightAlex;\n// little baby david\nString nameDavid;\ndouble weightDavid;\n// little baby david\nString nameDavid2;\ndouble weightDavid2;\nDavid2?\nTerrible -\n\nWhy use classes?\n- Why not just primitives?\n// little baby alex\nString nameAlex;\ndouble weightAlex;\n// little baby david\nString nameDavid;\ndouble weightDavid;\n// little baby david\nString nameDavid2;\ndouble weightDavid2;\nDavid2?\nTerrible -\n500 Babies? That Sucks!\n\nWhy use classes?\nName\nWeight\nSex\n...\nBaby1\n\nWhy use classes?\nName\nWeight\nSex\n...\nmore\nBabies\nName\nWeight\nSex\n...\nName\nWeight\nSex\n...\nName\nWeight\nSex\n...\nBaby1\nBaby2\nBaby3\nBaby4\n...\n\nWhy use classes?\nBaby1\nBaby2\nBaby3\nBaby4\n496 more\nBabies ...\nNursery\n\nWhy use classes?\nBaby1\nBaby2\nBaby3\nBaby4\n496 more\nBabies ...\nNurse1\nNurse2\nNurse3\nNurse4\nMore nurses...\nNursery\n\nWhy use classes?\nBaby\nNurse []\n[]\nNursery\n\nWhy use classes?\nNurse\n[]\nER\n[]\nBaby\nNursery\nHospital\n\nDefining classes\n\nClass - overview\npublic class Baby {\nString name;\nboolean isMale;\ndouble weight;\ndouble decibels;\nint numPoops = 0;\nClass\nDefinition\nvoid poop() {\nnumPoops += 1;\nSystem.out.println(\"Dear mother, \"+\n\"I have pooped. Ready the diaper.\");\n}\n}\n\nClass - overview\nClass\nBaby myBaby = new Baby();\nInstance\n\nLet's declare a baby!\npublic class Baby {\n}\n\nLet's declare a baby!\npublic class Baby {\nfields\nmethods\n}\n\nNote\n- Class names are Capitalized\n- 1 Class = 1 file\n- Having a main method means the class can\nbe run\n\nBaby fields\npublic class Baby {\nTYPE var_name;\nTYPE var_name = some_value;\n}\n\nBaby fields\npublic class Baby {\nString name;\ndouble weight = 5.0;\nboolean isMale;\nint numPoops = 0;\n}\n\nBaby Siblings?\npublic class Baby {\nString name;\ndouble weight = 5.0;\nboolean isMale;\nint numPoops = 0;\nXXXXX YYYYY;\n}\n\nBaby Siblings?\npublic class Baby {\nString name;\ndouble weight = 5.0;\nboolean isMale;\nint numPoops = 0;\nBaby[] siblings;\n}\n\nOk, let's make this baby!\nBaby ourBaby = new Baby();\nBut what about it's name? it's sex?\n\nConstructors\npublic class CLASSNAME{\nCLASSNAME ( ) {\n}\nCLASSNAME ([ARGUMENTS]) {\n}\n}\nCLASSNAME obj1 = new CLASSNAME();\nCLASSNAME obj2 = new CLASSNAME([ARGUMENTS])\n\nConstructors\n- Constructor name == the class name\n- No return type - never returns anything\n- Usually initialize fields\n- All classes need at least one constructor\n- If you don't write one, defaults to\nCLASSNAME () {\n}\n\nBaby constructor\npublic class Baby {\nString name;\nboolean isMale;\nBaby(String myname, boolean maleBaby){\nname = myname;\nisMale = maleBaby;\n}\n}\n\nBaby methods\npublic class Baby {\nString name = \"Slim Shady\";\n...\nvoid sayHi() {\nSystem.out.println(\n\"Hi, my name is.. \" + name);\n}\n}\n\nBaby methods\npublic class Baby {\nString weight = 5.0;\nvoid eat(double foodWeight) {\nif (foodWeight >= 0 &&\nfoodWeight < weight) {\nweight = weight + foodWeight;\n}\n}\n}\n\nBaby class\npublic class Baby {\nString name;\ndouble weight = 5.0;\nboolean isMale;\nint numPoops = 0;\nBaby[] siblings;\nvoid sayHi() {...}\nvoid eat(double foodWeight) {...}\n}\n\nUsing classes\n\nClasses and Instances\n// class Definition\npublic class Baby {...}\n// class Instances\nBaby shiloh = new Baby(\"Shiloh Jolie-Pitt\", true);\nBaby knox\n= new Baby(\"Knox Jolie-Pitt\",\ntrue);\n\nAccessing fields\n- Object.FIELDNAME\nBaby shiloh = new Baby(\"Shiloh Jolie-Pitt\",\ntrue)\nSystem.out.println(shiloh.name);\nSystem.out.println(shiloh.numPoops);\n\nCalling Methods\n- Object.METHODNAME([ARGUMENTS])\nBaby shiloh = new Baby(\"Shiloh Jolie-Pitt\",\ntrue)\nshiloh.sayHi() ;\n// \"Hi, my name is ...\"\nshiloh.eat(1);\n\nReferences vs Values\n\nPrimitives vs References\n- Primitive types are basic java types\n- int, long, double, boolean, char, short, byte, float\n- The actual values are stored in the variable\n- Reference types are arrays and objects\n- String, int[], Baby, ...\n\nHow java stores primitives\n- Variables are like fixed size cups\n- Primitives are small enough that they just fit\ninto the cup\nint\ndouble\nchar\nboolean\n\nHow java stores objects\n- Objects are too big to fit in a variable\n- Stored somewhere else\n- Variable stores a number that locates the object\nObject\n\nHow java stores objects\n- Objects are too big to fit in a variable\n- Stored somewhere else\n- Variable stores a number that locates the object\nObject\nObject\nObject\nObject\nObject\nObject\nObject's\nlocation\n\nReferences\n- The object's location is called a reference\n- == compares the references\nBaby shiloh1 = new Baby(\"shiloh\");\nBaby shiloh2 = new Baby(\"shiloh\");\nDoes shiloh1 == shiloh2?\n\nReferences\n- The object's location is called a reference\n- == compares the references\nBaby shiloh1 = new Baby(\"shiloh\");\nBaby shiloh2 = new Baby(\"shiloh\");\nDoes shiloh1 == shiloh2?\nno\n\nReferences\nBaby shiloh1 = new Baby(\"shiloh\");\nBaby shiloh2 = new Baby(\"shiloh\");\nName=\"shiloh\"\nName=\"shiloh\"\nreference\nreference\nshiloh1\nshiloh2\n\nReferences\nBaby mybaby = new Baby(\"davy\", true)\nmybaby.name = \"david\"\nmybaby's\nlocation\nname = 'davy'\nismale = true\n...\n\nReferences\nBaby mybaby = new Baby('davy', true)\nmybaby.name = 'david'\nmybaby's\nlocation\nname = 'david'\nIsmale = true\n...\n\nReferences\n- Using = updates the reference.\nbaby1 = baby2\nbaby2\nlocation\nbaby1\nobject\nbaby2\nobject\nbaby2\nlocation\nbaby1\nbaby2\n\nReferences\n- Using = updates the reference.\nbaby1 = baby2\nbaby2\nlocation\nbaby1\nobject\nbaby2\nobject\nbaby1\nbaby2\n\nReferences\n- using [ ] or\n- Follows the reference to the object\n- May modify the object, but never the reference\n- Imagine\n- Following directions to a house\n- Moving the furniture around\n- Analogous to\n- Following the reference to an object\n- Changing fields in the object\n\nMethods and references\nvoid doSomething(int x, int[] ys, Baby b) {\nx = 99;\nys[0] = 99;\nb.name = \"99\";\n}\n...\nint i = 0;\nint[] j = {0};\nBaby k = new Baby(\"50\", true);\ndoSomething(i, j, k);\ni=? j=? k=?\n\nstatic types and methods\n\nstatic\n- Applies to fields and methods\n- Means the field/method\n- Is defined for the class declaration,\n- Is not unique for each instance\n\nstatic\npublic class Baby {\nstatic int numBabiesMade = 0;\n}\nBaby.numBabiesMade = 100;\nBaby b1 = new Baby();\nBaby b2 = new Baby();\nBaby.numBabiesMade = 2;\nWhat is\nb1.numBabiesMade?\nb2.numBabiesMade?\n\nstatic example\n- Keep track of the number of babies that have\nbeen made.\npublic class Baby {\nint numBabiesMade = 0;\nBaby() {\nnumBabiesMade += 1;\n}\n}\n\nstatic field\n- Keep track of the number of babies that have\nbeen made.\npublic class Baby {\nstatic int numBabiesMade = 0;\nBaby() {\nnumBabiesMade += 1;\n}\n}\n\nstatic method\npublic class Baby {\nstatic void cry(Baby thebaby) {\nSystem.out.println(thebaby.name + \"cries\");\n}\n}\nOr\npublic class Baby {\nvoid cry() {\nSystem.out.println(name + \"cries\");\n}\n}\n\nstatic notes\n- Non-static methods can reference static\nmethods, but not the other way around\n- Why?\npublic class Baby {\nString name = \"DMX\";\nstatic void whoami() {\nSystem.out.println(name);\n}\n}\n\nmain\n- Why is main static?\npublic static void main(String[] arguments) {\n}\n\nAssignment 4\n- Modeling Book and Libraries\n- class Book {}\n- class Library{}\n- Books can be\n- Borrowed\n- Returned\n- Library\n- Keeps track of books\n- Hint: use Book[]\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.092 Introduction to Programming in Java\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 5: Access Control, Class Scope, Packages, Java API",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-introduction-to-programming-in-java-january-iap-2010/ae507b638374a092cf863e83bde05bad_MIT6_092IAP10_lec05.pdf",
      "content": "! \"!\n!!\n! \"!\n!!\n\n!\"\n\n! \"!\n!!\n! \"!\n!!\n\n'()\n#$\n%&#$\n\n'()\n'(*\n#$\n%&#$\n%&#$\n\n'()\n'(*\n#$\n%&#$\n%&#$\n)\n)\n\n'()\n'(*\n#$\n%&#$\n%&#$\n)\n)\n*\n*\n\n'()\n'(*\n#$\n%&#$\n%&#$\n)\n)\n*\n*\n)\n+\n\n# #\n\n#$%\n&\n'\n\n&&\n#$% ( #\n\n( #) !*+*,-./-!\n\n#$%\n\n!0 12!\n\n!,!-&\npublic class Malicious {\npublic static void main(String[] args) {\nmaliciousMethod(new CreditCard());\n}\nstatic void maliciousMethod(CreditCard card)\n{\ncard.expenses = 0;\nSystem.out.println(card.cardNumber);\n}\n}\n\n',\n'\n\"\"\n\n&\"\"\n'.&\n\n# #\n\n#$%\n&\n'\n\n&&\n#$% ( #\n\n( #) !*+*,-./-!\n\n#$%\n\n!0 12!\n\n/01-23\n# #\n\n#$%\n&\n'\n\n&&\n#$% ( #\n( #) !*+*,-./-!\n\n#$%\n\n!0 12!\n\n4\"&\n5%67\n5&\"\"\" &\n8%%5%5\n\npublic class ScopeReview {\nvar2 = \"above 0\";\n} else {\nvar2 = \"less than or equal to 0\";\n}\nSystem.out.println(var2);\nvoid scopeMethod(int var1) {\nString var2;\nif (var1 > 0) {\n}\n}\n\npublic class ScopeReview {\nprivate int var3;\nvoid scopeMethod(int var1) {\nvar3 = var1;\nString var2;\nif (var1 > 0) {\nvar2 = \"above 0\";\n} else {\nvar2 = \"less than or equal to 0\";\n}\nSystem.out.println(var2);\n}\n}\n\npublic class ScopeReview {\nvar3 = var1;\nprivate int var3;\nvoid scopeMethod(int var1) {\nString var2;\nif (var1 > 0) {\nvar2 = \"above 0\";\n} else {\nvar2 = \"less than or equal to 0\";\n}\nSystem.out.println(var2);\n}\n}\n\n:\n:\n\n%\" ''\n9:\n\n%\" ;\n%\" 6)79\n*#)<)=\n3\"\n;\n1>%9\n%%'?'=\n?'6?79\n%%'?'<#?=\n:\n\n&%\" ;\n@@\npublic class Baby {\nint servings;\nvoid feed(int servings) {\nservings = servings + servings;\n}\nvoid poop() {\nSystem.out.println(\"All better!\");\nservings = 0;\n}\n}\n\n:\n:\n@\"@&\n!@%&'(@\nA\n\n1>%9\n%%'?'=\n?'6?79\n,%%'?'<#?=\n\n&%\" ;\n@@\npublic class Baby {\nint servings;\nvoid feed(int servings) {\nservings = servings + servings;\n}\nvoid poop() {\nSystem.out.println(\"All better!\");\nservings = 0;\n}\n}\n\n'(;@@\npublic class Baby {\nint servings;\nvoid feed(int servings) {\nthis.servings =\nthis.servings + servings;\n}\nvoid poop() {\nSystem.out.println(\"All better!\");\nservings = 0;\n}\n}\n\nPackages\nEach class belongs to a package\nClasses in the same package serve a similar\npurpose\nPackages are just directories\nClasses in other packages need to be imported\n\nF\n:\n/5\n\",,,5=\nA\n\n\",,,5,=\n\n\",,,5,D=\n\npackage parenttools;\npublic class BabyFood {\n}\npackage parenttools;\npublic class Baby {\n}\n\npackage adult;\nimport parenttools.Baby;\nimport parenttools.BabyFood;\npublic class Parent {\npublic static void main(String[] args) {\nBaby baby = new Baby();\nbaby.feed(new BabyFood());\n}\n}\n\nEclipse Demo\n\n4\"&G\nCombine similar functionality\norg.boston.libraries.Library\norg.boston.libraries.Book\nSeparate similar names\nshopping.List\npacking.List\n\nSpecial Packages\nAll classes \"see\" classes in the same package\n(no import needed)\nAll classes \"see\" classes in java.lang\nExample: java.lang.String; java.lang.System\n\nJava API\nJava includes lots of packages/classes\nReuse classes to avoid extra work\nhttp://java.sun.com/javase/6/docs/api/\n\nArrays with items\nCreate the array bigger than you need\nTrack the next \"available\" slot\nBook[] books = new Book[10];\nint nextIndex = 0;\nbooks[nextIndex] = b;\nnextIndex = nextIndex + 1;\n\nArrays with items\nCreate the array bigger than you need\nTrack the next \"available\" slot\nBook[] books = new Book[10];\nint nextIndex = 0;\nbooks[nextIndex] = b;\nnextIndex = nextIndex + 1;\n4\"5\"'&> G\n\nArrayList\nModifiable list\nInternally implemented with arrays\nFeatures\nGet/put items by index\nAdd items\nDelete items\nLoop over all items\n\nArray z ArrayList\nBook[] books =\nnew Book[10];\nint nextIndex = 0;\nbooks[nextIndex] = b;\nnextIndex += 1;\nArrayList<Book> books\n= new ArrayList<Book>();\nbooks.add(b);\n\nimport java.util.ArrayList;\nclass ArrayListExample {\npublic static void main(String[] arguments) {\nArrayList<String> strings = new ArrayList<String>();\nstrings.add(\"Evan\");\nstrings.add(\"Eugene\");\nstrings.add(\"Adam\");\nSystem.out.println(strings.size());\nSystem.out.println(strings.get(0));\nSystem.out.println(strings.get(1));\nstrings.set(0, \"Goodbye\");\nstrings.remove(1);\n3 4\n\nfor (String s : strings) {\nSystem.out.println(s);\n}\n}\n}\n\nSets\nLike an ArrayList, but\nOnly one copy of each object, and\nNo array index\nFeatures\nAdd objects to the set\nRemove objects from the set\nIs an object in the set?\nTreeSet: Sorted (lowest to highest)\nHashSet: Unordered (pseudo-random)\n\nimport java.util.TreeSet;\nclass SetExample {\npublic static void main(String[] arguments) {\nTreeSet<String> strings = new TreeSet<String>();\nstrings.add(\"Evan\");\nstrings.add(\"Eugene\");\nstrings.add(\"Adam\");\nSystem.out.println(strings.size());\nSystem.out.println(strings.first());\nSystem.out.println(strings.last());\nstrings.remove(\"Eugene\");\nfor (String s : strings) {\nSystem.out.println(s);\n}\n}\n}\n\nMaps\nStores a (key, value) pair of objects\nLook up the key, get back the value\nExample: Address Book\nMap from names to email addresses\nTreeMap: Sorted (lowest to highest)\nHashMap: Unordered (pseudo-random)\n\npublic static void main(String[] arguments) {\nHashMap<String, String> strings = new HashMap<String, String>();\nstrings.put(\"Evan\", \"email1@mit.edu\");\nstrings.put(\"Eugene\", \"email2@mit.edu\");\nstrings.put(\"Adam\", \"email3@mit.edu\");\nSystem.out.println(strings.size());\nstrings.remove(\"Evan\");\nSystem.out.println(strings.get(\"Eugene\"));\nfor (String s : strings.keySet()) {\nSystem.out.println(s);\n}\nfor (String s : strings.values()) {\nSystem.out.println(s);\n}\nfor (Map.Entry<String, String> pairs : strings.entrySet()) {\nSystem.out.println(pairs);\n}\n}\n\nWarnings\nUsing TreeSet/TreeMap?\nRead about Comparable interface\nUsing HashSet/HashMap?\nRead about equals, hashCode methods\nNote: This only matters for classes you build, not for\njava built-in types.\n\n%%&\n\n%\n-\"\n\"\n..(,,%.(.. ..(..\n-\",\"%\n\"\n..(,,%.(.. ..(..\n&,\"%\n6$$7\n6>$7\n6$;*7\n6$&7\n6>&7\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.092 Introduction to Programming in Java\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 6: Design, Debugging, Interfaces",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-introduction-to-programming-in-java-january-iap-2010/2405ab6df66c95de7bb956f9b3329677_MIT6_092IAP10_lec06.pdf",
      "content": "6.092: Introduction to Java \n6: Design, Debugging,\nInterfaces\n\nAssignment 5: main()\nPrograms start at a main() method, but\nmany classes can have main()\npublic class SimpleDraw {\n/* ... stuff ... */\npublic static void main(String args[]) {\nSimpleDraw content = new SimpleDraw(new DrawGraphics());\n/* ... more stuff ... */\n}\n}\n\nAssignment 5: main()\nPrograms start at a main() method, but\nmany classes can have main()\npublic class SimpleDraw {\n/* ... stuff ... */\npublic static void main(String args[]) {\nSimpleDraw content = new SimpleDraw(new DrawGraphics());\n/* ... more stuff ... */\n}\n}\n\npublic class DrawGraphics {\nBouncingBox box;\npublic DrawGraphics() {\nbox = new BouncingBox(200, 50, Color.RED);\n}\npublic void draw(Graphics surface) {\nsurface.drawLine(50, 50, 250, 250);\nbox.draw(surface);\n}\n}\n\npublic class DrawGraphics {\nBouncingBox box; // a field or member variable\npublic DrawGraphics() {\nbox = new BouncingBox(200, 50, Color.RED);\n}\npublic void draw(Graphics surface) {\nsurface.drawLine(50, 50, 250, 250);\nbox.draw(surface);\n}\n}\n\npublic class DrawGraphics {\nBouncingBox box;\npublic DrawGraphics() { // constructor\nbox = new BouncingBox(200, 50, Color.RED);\n}\npublic void draw(Graphics surface) {\nsurface.drawLine(50, 50, 250, 250);\nbox.draw(surface);\n}\n}\n\npublic class DrawGraphics {\npublic void draw(Graphics surface) {\nsurface.drawLine(50, 50, 250, 250);\nbox.draw(surface);\nsurface.fillRect (150, 100, 25, 40);\nsurface.fillOval (40, 40, 25, 10);\nsurface.setColor (Color.YELLOW);\nsurface.drawString (\"Mr. And Mrs. Smith\", 200, 10);\n}\n}\n\npublic class DrawGraphics {\nArrayList<BouncingBox> boxes = new ArrayList<BouncingBox>();\npublic DrawGraphics() {\nboxes.add(new BouncingBox(200, 50, Color.RED));\nboxes.add(new BouncingBox(10, 10, Color.BLUE));\nboxes.add(new BouncingBox(100, 100, Color.GREEN));\nboxes.get(0).setMovementVector(1, 0);\nboxes.get(1).setMovementVector(-3, -2);\nboxes.get(2).setMovementVector(1, 1);\n}\npublic void draw(Graphics surface) {\nfor (BouncingBox box : boxes) {\nbox.draw(surface);\n}\n}\n}\n\nOutline\nGood program design\nDebugging\nInterfaces\n\nWhat is a good program?\nCorrect / no errors\nEasy to understand\nEasy to modify / extend\nGood performance (speed)\n\nConsistency\nWriting code in a consistent way makes it\neasier to write and understand\nProgramming \"style\" guides: define rules\nabout how to do things\nJava has some widely accepted\n\"standard\" style guidelines\n\nNaming\nVariables: Nouns, lowercase first letter, capitals\nseparating words\nx, shape, highScore, fileName\nMethods: Verbs, lowercase first letter\ngetSize(), draw(), drawWithColor()\nClasses: Nouns, uppercase first letter\nShape, WebPage, EmailAddress\n\nGood Class Design\nGood classes: easy to understand and use\n- Make fields and methods private by default\n- Only make methods public if you need to\n- If you need access to a field, create a\nmethod:\npublic int getBar() { return bar; }\n\nDebugging\nThe process of finding and correcting an\nerror in a program\nA fundamental skill in programming\n\nStep 1: Donʼt Make Mistakes\nDonʼt introduce errors in the first place\n\nStep 1: Donʼt Make Mistakes\nDonʼt introduce errors in the first place\n- Reuse: find existing code that does\nwhat you want\n- Design: think before you code\n- Best Practices: Recommended\nprocedures/techniques to avoid\ncommon problems\n\nDesign: Pseudocode\nA high-level, understandable description\nof what a program is supposed to do\nDonʼt worry about the details, worry about\nthe structure\n\nPseudocode: Interval Testing\nExample:\nIs a number within the interval [x, y)?\nIf number < x return false\nIf number > y return false\nReturn true\n\nDesign\nVisual design for objects, or how a\nprogram works\nDonʼt worry about specific notation, just\ndo something that makes sense for you\nScrap paper is useful\n\nSimpleDraw\nDrawGraphics\nArrayList\nBouncingBox\nBouncingBox\nBouncingBox\n\nStep 2: Find Mistakes Early\nEasier to fix errors the earlier you find\nthem\n- Test your design\n- Tools: detect potential errors\n- Test your implementation\n- Check your work: assertions\n\nTesting: Important Inputs\nWant to check all \"paths\" through the\nprogram.\nThink about one example for each \"path\"\nExample:\nIs a number within the interval [x, y)?\n\nIntervals: Important Cases\nBelow the lower bound\nEqual to the lower bound\nWithin the interval\nEqual to the upper bound\nAbove the upper bound\n\nIntervals: Important Cases\nWhat if lower bound > upper bound?\nWhat if lower bound == upper bound?\n(hard to get right!)\n\nPseudocode: Interval Testing\nIs a number within the interval [x, y)?\nIf number < x return false\nIf number > y return false\nReturn true\n\nPseudocode: Interval Testing\nIs a number within the interval [x, y)?\nIs 5 in the interval [3, 5)?\nIf number < x return false\nIf number > y return false\nReturn true\n\nPseudocode: Interval Testing\nIs a number within the interval [x, y)?\nIs 5 in the interval [3, 5)?\nIf number < x return false\nIf number >= y return false\nReturn true\n\nTools: Eclipse Warnings\nWarnings: may not be a mistake, but it\nlikely is.\nSuggestion: always fix all warnings\nExtra checks: FindBugs and related tools\nUnit testing: JUnit makes testing easier\n\nAssertions\nVerify that code does what you expect\nIf true: nothing happens\nIf false: program crashes with error\nDisabled by default (enable with ‐ea)\nassert difference >= 0;\n\nvoid printDifferenceFromFastest(int[] marathonTimes) {\nint fastestTime = findMinimum(marathonTimes);\nfor (int time : marathonTimes) {\nint difference = time - fastestTime;\nassert difference >= 0;\nSystem.out.println(\"Difference: \" + difference);\n}\n}\n\nStep 3: Reproduce the Error\n- Figure out how to repeat the error\n- Create a minimal test case\nGo back to a working version, and\nintroduce changes one at a time until\nthe error comes back\nEliminate extra stuff that isnʼt used\n\nStep 4: Generate Hypothesis\nWhat is going wrong?\nWhat might be causing the error?\nQuestion your assumptions: \"x canʼt be\npossible:\" What if it is, due to something\nelse?\n\nStep 5: Collect Information\nIf x is the problem, how can you verify?\nNeed information about what is going\non inside the program\nSystem.out.println() is very powerful\nEclipse debugger can help\n\nStep 6: Examine Data\nExamine your data\nIs your hypothesis correct?\nFix the error, or generate a new\nhypothesis\n\nWhy Use Methods?\nWrite and test code once, use it multiple\ntimes: avoid duplication\nEg. Library.addBook()\n\nWhy Use Methods?\nUse it without understanding how it works:\nencapsulation / information hiding\nEg. How does System.out.println() work?\n\nWhy Use Objects?\nObjects combine a related set of variables\nand methods\nProvide a simple interface\n(encapsulation again)\n\nImplementation / Interface\nLibrary\nBook[] books;\nint numBooks;\nString address;\nvoid addBook(Book b) {\nbooks[numBooks] = b;\nnumBooks++;\n}\nLibrary\nvoid addBook(Book b);\n\nJava Interfaces\nManipulate objects, without knowing how\nthey work\nUseful when you have similar but not\nidentical objects\nUseful when you want to use code written\nby others\n\nInterface Example: Drawing\npublic class BouncingBox {\npublic void draw(Graphics surface) {\n// ... code to draw the box ...\n}\n}\n// ... draw boxes ...\nfor (BouncingBox box : boxes) {\nbox.draw(surface);\n}\n\nInterface Example: Drawing\npublic class Flower {\npublic void draw(Graphics surface) {\n// ... code to draw a flower ...\n}\n}\n// ... draw flowers ...\nfor (Flower flower : flowers) {\nflower.draw(surface);\n}\n\npublic class DrawGraphics {\nArrayList<BouncingBox> boxes = new ArrayList<BouncingBox>();\nArrayList<Flower> flowers = new ArrayList<Flower>();\nArrayList<Car> cars = new ArrayList<Car>();\npublic void draw(Graphics surface) {\nfor (BouncingBox box : boxes) {\nbox.draw(surface);\n}\nfor (Flower flower : flowers) {\nflower.draw(surface);\n}\nfor (Car car : cars) {\ncar.draw(surface);\n}\n}\n}\n\npublic class DrawGraphics {\nArrayList<Drawable> shapes = new ArrayList<Drawable>();\nArrayList<Flower> flowers = new ArrayList<Flower>();\nArrayList<Car> cars = new ArrayList<Car>();\npublic void draw(Graphics surface) {\nfor (Drawable shape : shapes) {\nshape.draw(surface);\n}\nfor (Flower flower : flowers) {\nflower.draw(surface);\n}\nfor (Car car : cars) {\ncar.draw(surface);\n}\n}\n}\n\nInterfaces\nSet of classes that share methods\nDeclare an interface with the common\nmethods\nCan use the interface, without knowing an\nobjectʼs specific type\n\nInterfaces: Drawable\nimport java.awt.Graphics;\ninterface Drawable {\nvoid draw(Graphics surface);\nvoid setColor(Color color);\n}\n\nImplementing Interfaces\nImplementations provide complete\nmethods:\nimport java.awt.Graphics;\nclass Flower implements Drawable {\n// ... other stuff ...\npublic void draw(Graphics surface) {\n// ... code to draw a flower here ...\n}\n}\n\nInterface Notes\nOnly have methods (mostly true)\nDo not provide code, only the definition\n(called signatures)\nA class can implement any number of\ninterface\n\nUsing Interfaces\nCan only access stuff in the interface.\nDrawable d = new BouncingBox(...);\nd.setMovementVector(1, 1);\nThe method setMovementVector(int, int)\nis undefined for the type Drawable\n\nCasting\nIf you know that a variable holds a\nspecific type, you can use a cast:\nDrawable d = new BouncingBox(...);\nBouncingBox box = (BouncingBox) d;\nbox.setMovementVector(1, 1);\n\nAssignment: More graphics\nStart a new project: code has changed.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.092 Introduction to Programming in Java\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 7: Review, Exceptions, IO",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-092-introduction-to-programming-in-java-january-iap-2010/f04b8fe32c4cd8c0cb0643937e1f6b5d_MIT6_092IAP10_lec07.pdf",
      "content": "Lecture 7\nReview\nExceptions\nIO\n\nReview\n\nInterfaces? Interfaces!\n- It's a contract!\n- If you must implement ALL the methods\n- All fields are final (cannot be changed)\npublic interface ICar {\nboolean isCar = true;\nint getNumWheels();\n}\n\nBigRig\nclass BigRig implements ICar {\nint getNumWheels() {\nreturn 18;\n}\n}\n\nThat Homework!\n- Bouncer draws a Sprite that\n- Moves around\n- Bounces in a box\n- A Sprite is an interface\n- You can draw anything\n- Mover\n- Keeps updating the coordinates of a Sprite\n\nAn Oval Sprite\npublic class Oval implements Sprite {\nprivate int width, height;\nprivate Color color;\npublic Oval(int width, int height, Color color) {\n// set the fields ...\n}\npublic void draw(Graphics surface, int x, int y) {\nsurface.setColor(color);\nsurface.fillOval(x, y, width, height);\nsurface.drawOval(x, y, width, height);\n}\n...\n}\n\nA Mover that doesn't bounce\npublic class StraightMover {\nprivate int x, y, xDirection, yDirection;\nprivate Sprite sprite;\npublic StraightMover(int startX, int startY, Sprite sprite) {\nx = startX;\ny = startY;\nthis.sprite = sprite;\n}\npublic void setMovementVector(int xIncrement, int yIncrement) {\nxDirection = xIncrement;\nyDirection = yIncrement;\n}\npublic void draw(Graphics graphics) {\nsprite.draw(graphics, x, y);\nx += xDirection;\ny += yDirection;\n}\n}\n\nInheritance\nExceptions\nI/O\n\nInheritance\n\nVery Very Basic Inheritance\n- Making a Game\npublic class Dude {\npublic String name;\npublic int hp = 100\npublic int mp = 0;\npublic void sayName() {\nSystem.out.println(name);\n}\npublic void punchFace(Dude target) {\ntarget.hp -= 10;\n}\n}\n\nInheritance..\n- Now create a Wizard...\npublic class Wizard {\n// ugh, gotta copy and paste\n// Dude's stuff\n}\n\nInheritance?\n- Now create a Wizard...\nBut Wait!\nA Wizard does and has everything a\nDude does and has!\n\nInheritance?\n- Now create a Wizard...\nDon't Act Now!\nYou don't have to Copy & Paste!\n\nBuy Inheritance!\n- Wizard is a subclass of Dude\npublic class Wizard extends Dude {\n}\n\nBuy Inheritance!\n- Wizard can use everything* the Dude has!\nwizard1.hp += 1;\n- Wizard can do everything* Dude can do!\nwizard1.punchFace(dude1);\n- You can use a Wizard like a Dude too!\ndude1.punchface(wizard1);\n*except for private fields and methods\n\nBuy Inheritance!\n- Now augment a Wizard\npublic class Wizard extends Dude {\nArrayList<Spell> spells;\npublic class cast(String spell) {\n// cool stuff here\n...\nmp -= 10;\n}\n}\n\nInheriting from inherited classes\n- What about a Grand Wizard?\npublic class GrandWizard extends Wizard {\npublic void sayName() {\nSystem.out.println(\"Grand wizard\" + name)\n}\n}\ngrandWizard1.name = \"Flash\"\ngrandWizard1.sayName();\n((Dude)grandWizard1).sayName();\n\nHow does Java do that?\n- What Java does when it sees\ngrandWizard1.punchFace(dude1)\n1. Look for punchFace()in the GrandWizard class\n2. It's not there! Does GrandWizard have a parent?\n3. Look for punchFace()in Wizard class\n4. It's not there! Does Wizard have a parent?\n5. Look for punchFace()in Dude class\n6. Found it! Call punchFace()\n7. Deduct hp from dude1\n\nHow does Java do that? pt2\n- What Java does when it sees\n((Dude)grandWizard1).sayName()\n1. Cast to Dude tells Java to start looking in Dude\n2. Look for sayName()in Dude class\n3. Found it! Call sayName()\n\nWhat's going on?\nParent of\nWizard, Elf..\nSubclass\nof Dude\nSubclass of\nWizard\nDude\nWizard\nThief\nElf\nGrand\nWizard\n\nYou can only inherit from one class\nDude\nThief\nElf\nBad Elf\n\nYou can only inherit from one class\nDude\nThief\nElf\nBad Elf\n\nYou can only inherit from one class\nWhat if Thief and Elf both implement\npublic void sneakUp()\nIf they implemented differently,\nwhich sneakUp()does BadElf call?\nJava Doesn't Know!!\nDude\nThief\nElf\nBad Elf\n\nInheritance Summary\n- class A extends B {} == A is a subclass of B\n- A has all the fields and methods that B has\n- A can add it's own fields and methods\n- A can only have 1 parent\n- A can replace a parent's method by re-\nimplementing it\n- If A doesn't implement something Java\nsearches ancestors\n\nSo much more to learn!\n- http://java.sun.com/docs/books/tutorial/java/IandI/subclasses.html\n- http://home.cogeco.ca/~ve3ll/jatutor5.htm\n- http://en.wikipedia.org/wiki/Inheritance_(computer_science)\n- http://www.google.com\n\nExceptions\n\nExceptions\n- NullPointerException\n- ArrayIndexOutOfBoundsException\n- ClassCastException\n- RuntimeException\n\nWhat is an \"Exception\"?\n- Event that occurs when something\n\"unexpected\" happens\n- null.someMethod();\n- (new int[1])[1] = 0;\n- int i = \"string\";\n\nWhy use an Exception?\n- To tell the code using your method that\nsomething went wrong\nException in thread \"main\"\njava.lang.ArrayIndexOutOfBoundsException: 5\nat RuntimeException.main(RuntimeException.java:8)\nAccessed index 5, which isn't in the array\nThe method that called it was main\n- Debugging and understanding control flow\n\nHow do exceptions \"happen\"?\n- Java doesn't know what to do, so it\n- Creates an Exception object\n- Includes some useful information\n- \"throws\" the Exception\n- You can create and throw Exceptions too!\n\npublic class Exception\n- Exception is a class\n- Just inherit from it!\npublic class MyException extends Exception\n{\n}\n- Or use existing ones\n- http://rymden.nu/exceptions.html\n\nWarn Java about the Exception\npublic Object get(int index) throws\nArrayOutOfBoundsException {\nIf (index < 0 || index >= size())\nthrow new\nArrayOutOfBoundsException(\"\"+index);\n}\n- throws tells Java that get may throw the\nArrayOutOfBoundsException\n- throw actually throws the Exception (sorry)\n\nCatching an Exception\n- Java now expects code that calls get to deal\nwith the exception by\n- Catching it\n- Rethrowing it\n\nCatching it\n- What it does\n- try to run some code that may throw an exception\n- Tell Java what to do if it sees the exception (catch)\ntry {\nget(-1);\n} catch (ArrayOutOfBoundsException err) {\nSystem.out.println(\"oh dear!\");\n}\n\nRethrowing it\n- Maybe you don't want to deal with the\nException\n- Tell Java that your method throws it too\nvoid doBad() throws ArrayOutOfBoundsException {\nget(-1);\n}\n\nRethrowing it\nmain\n\nRethrowing it\ndoBad\nmain\n\nRethrowing it\nget\ndoBad\nmain\n\nRethrowing it\nget\ndoBad\nmain\n\nRethrowing it\nget\ndoBad\nmain\nException\n\nRethrowing it\nget\ndoBad\nmain\nException\n\nRethrowing it\ndoBad\nmain\nException\n\nRethrowing it\ndoBad\nmain\nException\n\nRethrowing it\nmain\nException\n\nRethrowing it\nmain\nException\n\nWhat it no one catches it?\n- If you ran\npublic static void main(String[] args) throws Exception {\ndoBad();\n}\n- Java will print that error message you see\nException in thread \"main\"\njava.lang.ArrayIndexOutOfBoundsException: -1\nat YourClass.get(YourClass.java:50)\nat YourClass.doBad(YourClass.java:11)\nat YourClass.main(YourClass.java:10)\n\nMore Info?\n- http://java.sun.com/docs/books/tutorial/essential/exceptions\n- http://en.wikipedia.org/wiki/Exceptions\n\nI/O\n\nWe've seen Output\nSystem.out.println(\"some string\");\n\nThe Full Picture\nHard drive\nNetwork\n100101010101000101 ...\nInputStream\nSystem.in\n'O' 'k' 'a' 'y' ' ' 'a' 'w' 'e' ...\nInputStreamReader\n\"Okay awesome, cool\\n\" ...\nBufferedReader\n\nInputStream\n- InputStream is a stream of bytes\n- Read one byte after another using read()\n- A byte is just a number\n- Data on your hard drive is stored in bytes\n- Bytes can be interpreted as characters, numbers..\nInputStream stream = System.in;\n\nInputStreamReader\n- Reader is a class for character streams\n- Read one character after another using read()\n- InputStreamReader takes an InputStream and\nconverts bytes to characters\n- Still inconvenient\n- Can only read a character at a time\nnew InputStreamReader(stream)\n\nBufferedReader\n- BufferedReader buffers a character stream so\nyou can read line by line\n- String readLine()\nnew BufferedReader(\nnew InputStreamReader(System.in));\n\nUser Input\nInputStreamReader ir = new\nInputStreamReader(System.in);\nBufferedReader br = new BufferedReader(ir);\nbr.readLine();\n\nFileReader\n- FileReader takes a text file\n- converts it into a character stream\n- FileReader(\"PATH TO FILE\");\n- Use this + BufferedReader to read files!\nFileReader fr = new FileReader(\"readme.txt\");\nBufferedReader br = new BufferedReader(fr);\n\nFileReader Code\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\npublic class ReadFile {\npublic static void main(String[] args) throws IOException{\n// Path names are relative to project directory (Eclipse Quirk )\nFileReader fr = new FileReader(\"./src/readme\");\nBufferedReader br = new BufferedReader(fr);\nString line = null;\nwhile ((line = br.readLine()) != null) {\nSystem.out.println(line);\n}\nbr.close();\n}\n}\n\nMore about I/O\n- http://java.sun.com/docs/books/tutorial/essential/io/\n\nAssignment\n- Magic Squares\n- Read two files\n- Check that all rows and columns sum to 15\nA\n3x\nma\ngi\nc\nsq\nua\nre\nin\nwh\nich\na\nll\nrow\ns,\ncolumns, and diagonals sum to 15.\nFigure by MIT OpenCourseWare.\n\nMIT OpenCourseWare\nhttp://ocw.mit.edu\n6.092 Introduction to Programming in Java\nJanuary (IAP) 2010\nFor information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms."
    }
  ]
}