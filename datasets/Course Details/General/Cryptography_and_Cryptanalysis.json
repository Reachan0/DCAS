{
  "course_name": "Cryptography and Cryptanalysis",
  "course_description": "No description found.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Cryptography",
    "Theory of Computation",
    "Engineering",
    "Computer Science",
    "Cryptography",
    "Theory of Computation"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1.5 hours / session\n\nCourse Description\n\nThis course is a graduate introduction to cryptography. Topics include encryption, pseudo-random generation, digital signatures, two-party protocols and zero-knowledge. The emphasis will be on proof techniques.\n\nPrerequisites\n\nGeneral ease with algorithms, elementary number theory and discrete probability. If you have any questions about your background or whether you are prepared to take this course, please contact the TA.\n\nHomework and Grading Policy\n\nThe grade will be based on homework assignments and class participation. You should expect roughly 8 problem sets during the term.\n\nYou are free to collaborate with other students on the homework, but you must turn in your own individually written solution and you must specify the names of your collaborators. Additionally, you may make use of published material, provided that you acknowledge all sources used. Note that it is a violation of this policy to submit a problem solution that you are unable to explain orally to a member of the course staff.\n\nProblem sets\nmust\nbe typed. Use of LaTeX is not required but LaTeX templates will be provided. You may also be required to scribe one lecture of the course.",
  "files": [
    {
      "category": "Resource",
      "title": "ho4_ps1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-875-cryptography-and-cryptanalysis-spring-2005/97f1e89ae995026c7beb83ecb52dad1d_ho4_ps1.pdf",
      "content": "6.875/18.425J Cryptography and Cryptanalysis\nFebruary 7, 2 005\nHandout 4: Problem Set #1\nThis problem set is due on: Wednesday, February 16, 2005. Note that Problem\n5 is optional. If you turn in a solution to Problem 5, your lowest score among the five\nproblems will be dropped when determining your grade for this problem set.\nProblem 1\n∗\np\nSuppose p is a prime and g and h are both generators of Z . Prove or disprove the\nfollowing statements about equality of probability distributions:\n∗\np : g\n∗\np\n∗\np\nx\n: gxy\nA:\nZ\nmod p} = {x\nZ\n←\nmod p} =\nZ\nmod p}\n; y ←\n{x ←\n∗: g\np\n∗\np\nx\n: hx\nB:\nZ\nZ\nmod p}\nmod p}\nmod p}\n{x\n{x\n←\n←\n∗\np\n∗\np\nx\n: xg\nC:\nZ\nmod p} =\nZ\n: g\n{x\n{x\n←\n←\ngh\n∗\np\n∗\np\n: xg\nD:\nZ\nmod p} = {x\nZ\n←\n: x\n{x ←\nProblem 2\nSuppose that the Prime Discrete Logarithm Problem is easy. That is, suppose that there\nexists a probabilistic, polynomial time algorithm A that, on inputs p, g and gx mod p,\n∗\np and g x mod p is prime. Show that there\noutputs x if p is a prime, g is a generator of Z\nexists a probabilistic polynomialtime algorithm, B, that solves the Discrete Logarithm\nProblem.\nProblem 3\nWe define the Lily problem as: given two integers n and S determine whether S is\nrelatively prime to φ(n). Prove that if it is hard to determine on inputs two integers n\nand e whether e is relatively prime with φ(n), then the RSA function is hard to invert.\n\nProblem 4: Factoring\nLet On be an oracle that on input x returns a square root of x mod n, if one exists, and\n⊥ otherwise. Prove that there exists a probabilistic polynomialtime algorithm that on\ninput an integer n and access to On outputs n's factorization.\nProblem 5: Factoring and OWF (OPTIONAL)\nProve that if factoring is hard, then oneway functions (as defined in class) exist."
    },
    {
      "category": "Resource",
      "title": "ho5_ps2.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-875-cryptography-and-cryptanalysis-spring-2005/cf4150e9eb87f56a8832c10a608bbe7d_ho5_ps2.pdf",
      "content": "6.875/18.425J Cryptography and Cryptanalysis\nFebruary 17, 200 5\nHandout 5: Problem Set #2\nThis problem set is due on: Tuesday, March 1, 2005.\nProblem 1 OWF Reductions\nAssume that f is a length preserving oneway function. (i.e, f : {0, 1}k\nk).\nFor each of the following functions g, prove or disprove the statement: \"g is a oneway\n→ {0, 1}\n\nfunction.\" (Note: x denotes the bitwise complement of x and | denotes concatenation,\ne.g. 1011|1011 = 10110100.)\nA:\ng(x) = f(f(x))\nB:\ng(x) = f( x)\nC:\ng(x, y) = f(x ⊕y)\nD:\ng(x) = f(x)|f( x)\nProblem 2 GM Implies OWF\nProve that the existence of a GMsecure cryptosystem (G, E, D) implies the existence of\na oneway function.\nProblem 3 Notions of OneBit Security\nConsider the definition of security for a onebit cryptosystem which was presented in\nclass:\nUnpredictability:\n∀PPT A ∀c > 0, ∃k0 s.t. ∀k > k0\nPr[(PK, SK) ←G(1k); b ←{0, 1}; x ←EPK(b); g ←A(1k, PK, x) : b = g] <\n+ kc\nHere are two other possible definitions of security for a onebit cryptosystem.\nIndistinguishability: The intuition behind this definition is that an adversary (with\nbinary output) should not be able to distinguish an encryption of 1 from an encryption\nof 0.\n\n∀PPT A ∀c > 0, ∃k0 s.t. ∀k > k0\nPr[(PK, SK) ←G(1k); x ←EPK(0); y ←EPK(1) : A(1k, PK, x) = A(1k, PK, y)] <\n+\nkc\nReal or Random: The intuition behind this definition is that an adversary should not\nbe able to tell the encryption of a real message from the encryption of a random bit.\n∀PPT A ∀c > 0, ∃k0 s.t. ∀k > k0\nPr[(PK, SK) ←G(1k); x0 ←EPK(0); r ←{0, 1}; x1 ←EPK(r);\nA(1k, PK, xb, x1-b) : b = g] <\n+\nb ←{0, 1}; g ←\nkc\nThe intuition behind this definition is that an adversary should not be able to tell the\ndifference between the encryption of a real bit and the encryption of a random bit.\nProve that all three definitions are equivalent.\nProblem 4 Ciphertext Expansion\nThe GM Quadratic Residuosity Cryptosystem (which we discussed in lecture) is GM\nSecure but it expands the size of a message by a factor of k (where k is the security\nparameter). RSA encryption, on the other hand, is not GMSecure but has the desirable\nproperty that the ciphertext is the same length as the plaintext. Prove that no GMsecure\npublickey cryptosystem (G,E,D) can satisfy the latter property. Namely, prove that, if\nthe message space is M = {0, 1}m, then the average length of a ciphertext generated by\n(G,E,D) with security parameter k is ≥m + log k."
    },
    {
      "category": "Resource",
      "title": "ho7_ps3.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-875-cryptography-and-cryptanalysis-spring-2005/b9b4c7ae2f67a90e177970d996123f58_ho7_ps3.pdf",
      "content": "6.875/18.425J Cryptography and Cryptanalysis\nMarch 2, 2005\nHandout 5: Problem Set #3\nThis problem set is due on: Friday, March 11, 2005.\nProblem 1 Yao Security\nWe consider a definition of security for a publickey cryptosystem proposed by Yao. The\nidea is that Alice has a polynomial number (nk ) of strings that she wants to send to Bob\nusing as few bits as possible. These strings are selected from a probability distribution\nknown to both Alice and Bob and Alice wants to send enough bits to Bob so that he can\n(with high probability) reconstruct all of the messages. Note that Alice and Bob are not\ntrying to keep any of these messages secret; Alice is just trying to deliver them to Bob\nas efficiently as possible.\nNow suppose that Bob gets encryptions of the messages \"for free,\" in addition to the\nbits that Alice sends him (however, Bob doesn't know the secret key to decrypt those\nciphertexts). We say that a cryptosystem is YaoSecure if the average number of bits\nwhich Alice must send to Bob is the same regardless of whether or not Bob possesses a\ncopy of the ciphertexts. (That is, sharing the ciphertexts does not help Alice compress\nthe messages.)\nIn the definitions below, we let M = {Mn} be a sequence of probability distributions\nover {0, 1}∗ where Mn only assigns positive probability to nbit strings. We denote by\n{An} a family of probabilistic polynomialsize encoding circuits, and by {Bn} a family\nof probabilistic polynomialsize decoding circuits.\n- The cost of communicating M:\nWe say that the cost of communicating M is less than or equal to f(n) (in symbols,\nC(M) ≤ f(n)) if there exist {An} and {Bn} such that the following two properties\nare satisfied: (for some constant k, for all c, and for all sufficiently large n . . .)\n1. \"Bn understands An \"\nPr[m1 ← Mn; . . . m\n← Mn; β ← An( ~\nm = ~y] > 1 - n-c\nm); ~y ← Bn(β) : ~\nk\nn\n2. \"An transmits at most f(n) bits per message\"\nβ\nk\nE m1 ← Mn; . . . m\n← Mn; β ← An( ~m) : |\nk\n|\n≤ f(n)\nn\nn\n\nh\ni\n\n- The cost of communicating M, given encryptions:\nLet (G, E, D) be a cryptosystem. We say that the cost of communicating M, given\nencryptions using E, is less than or equal to f(n) (in symbols, C(M E(M)) ≤f(n))\n|\nif there exist {An} and {Bn} such that the following two properties are satisfied:\n(for some constant k, for all c, and for all sufficiently large n . . .)\n1. \"Bn understands An \"\nPr[(PK, SK) ←G(1n); m1 ←Mn; . . . m\n←Mn; c1 ←EPK(m1), . . . ,\nk\nn\nm, PK,~c); ~y ←Bn(β, PK,~c) : ~\ncnk ←EPK(mnk ); β ←An( ~\nm = ~y] > 1 -n-c\n2. \"An transmits at most f(n) bits per message\"\nE (PK, SK) ←G(1n); m1 ←Mn; . . . mn ←Mn;\nk\nβ\nk\nc1 ←EPK(m1), . . . , c\n←EPK(mnk ); β ←An( ~m, PK,~c) : |\nk\n|\n≤f(n)\nn\nn\n- YaoSecurity\nWe say that a cryptosystem is Yaosecure if for all M, for all c and for all sufficiently\nlarge n,\nC(M E(M)) ≤f(n) ⇒C(M) ≤f(n) + nc\n|\nPart A: Prove that Yaosecurity implies GMsecurity. (Use a definition of GMsecurity\nin which adversaries are polynomialsize families of circuits.)\nPart B: Prove that GMsecurity implies Yaosecurity.\nProblem 2 Neighbour Indistinguishability\n{0, 1}k\nFor this problem, we will always have Mk =\n. Consider the following potential\ndefinition of security:\nNeighbour Indistinguishability (NI): This notion aims at capturing the intuition\nthat the encryption of each message (considered as an integer in {0, 1, . . . , 2k -1}) should\nlook like the encryption of the next message:\n∀PPT A ∀c > 0 ∃k0 ∀k > k0\n\n∀m ∈{0, 1}k\n\nPr (pk, sk) ←G(1k); c ←Epk(m) : A(1k, pk, c) = 1 -\nPr (pk, sk) ←G(1k); c\nEpk(m + 1 mod 2k) : A(1k, pk, c) = 1 < k-c\n←\n\nFor the problem, prove or carefully disprove each of the following statements.\nPart A: Prove or Disprove: Any system which is GMsecure is NI.\nPart B: Prove or Disprove: Any system which is NI is GMsecure.\nProblem 3 NonUniform Message Spaces\nWhen we discussed onebit cryptosystems in class, we considered only the message space\nwhere a bit is drawn uniformly from {0, 1}. This problem will consider other message\nspaces for onebit cryptosystems. Let Dq be the probability distribution over {0, 1} that\nassigns probability q to 0 and probability 1 - q to 1. For 1 ≤ q < 1, We will say that a\npublickey cryptosystem (G, E, D) is qsecure if\n∀PPT A ∀c > 0, ∃k0 s.t. ∀k > k0\nPr[(PK, SK) ← G(1k); b\nEPK(b); g ← A(1k, PK, x) : b = g] < q +\n← Dq; x ←\nkc\nObserve that this is the same definition we discussed in class when q = 1/2.\nPart A: Prove or Disprove: If a cryptosystem, (G, E, D), is 1/2secure than it is qsecure\nfor any 1/2 ≤ q < 1.\nPart B: Prove or Disprove: If a cryptosystem, (G, E, D), is qsecure for any 1/2 ≤ q < 1\nthen it is 1/2secure.\nProblem 4 Active Adversaries\nThe definition of GMSecurity embodies security against a passive adversary who listens\nto a conversation between Alice and Bob and after hearing the ciphertext, attempts to\nunderstand what is being said. In particular, the adversary is not a participant in the\nsystem and is not allowed any interaction with Alice and Bob.\nDefine security against an active adversary. Explain why your definition is good. (In\nparticular, a system satisfying your definition should not be vulnerable to the type of\nactive attack we discussed in class.) Prove that your definition implies GMSecurity."
    },
    {
      "category": "Resource",
      "title": "ho8_sol1.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-875-cryptography-and-cryptanalysis-spring-2005/29a52384d89685107dc7b2bda1dbaf0a_ho8_sol1.pdf",
      "content": "6.875/18.425J Cryptography and Cryptanalysis\nMarch 7, 2005\nHandout 8: Problem Set #1 Solutions\nProblem 1\n∗\np\nSuppose p is a prime and g and h are both generators of Z . Prove or disprove the\nfollowing statements:\n∗\np\n∗\np\n∗\np\nx\n: gxy\nA:\nZ\nmod p} = {x\nZ\n←\nmod p} =\nZ\nmod p}\n: g\n; y ←\n{x ←\n∗\np\n∗\np\nx\nx\nB:\nZ\nZ : h\nmod p}\nmod p}\nmod p}\n: g\n{x\n{x\n←\n←\n∗\np\n∗\np\nx\n: xg\nC:\nZ\nmod p} =\nZ\n: g\n{x\n{x\n←\n←\ngh\n∗\np\n∗\np\n: xg\nD:\nZ\nmod p} = {x\nZ\n←\n: x\n{x ←\n∗\np\nx mod p} is a probability distribution. You\nare being asked to prove or disprove the statement that two probability distributions are\n(Recall from Handout #3 that {x\nZ\n←\n: g\nidentically distributed.)\nSolution:\n∗\np (See Part B). Therefore, on\nA: Not equal. The left distribution is uniform over Z\nthe left, gx is a quadratic residue with probability 1/2. In the right distribution, with\nprobability 3/4, either x or y is even. Therefore, gxy is a quadratic residue with probability\n3/4. Thus the two distributions cannot be equal.\nx\nx\n∗\np\n∗\np\n∗\np\nB: Equal. Because g and h are generators, the maps x 7→ g\nand x 7→ h\n. Therefore both distributions are uniform over Z\nare bijective\nfrom Z to Z\n.\n∗\np, while\nC: Not equal. Let p = 3, g = 2. Then the left distribution is uniform over Z\nthe right distribution has probability 1 on element 1.\nD: Not equal. Let p = 5, g = 2, h = 2 (note that g and h need not be distinct). Then\nthe left distribution is uniform over {1, -1}, while the right distribution has probability\n1 on element 1.\n\nx\nProblem 2\nSuppose that the Prime Discrete Logarithm Problem is easy. That is, suppose that there\nexists a probabilistic, polynomial time algorithm A that, on inputs p, g and gx mod p,\noutputs x if p is a prime, g is a generator of Z ∗\np and g x mod p is prime. Show that there\nexists a probabilistic polynomialtime algorithm, B, that solves the Discrete Logarithm\nProblem.\nSolution:\nThe main idea here is to use the idea of random selfreducibility. That is, we want to\nreduce solving the discrete logarithm problem for a particular gx to solving the discrete\nlogarithm problem for a uniformly random input gy+x . Then since a uniformly random\ninput is likely to be prime, we can apply our algorithm for the Prime Discrete Logarithm\nx+y\nProblem to g\n.\nLet A be an algorithm for solving the Prime Discrete Logarithm Problem. Our reduction\nalgorithm, B, works as follows: \"on input (p, g, gx), pick a random y ← Z\ngy mod p is prime. If not, choose a new y until that condition is satisfied. Then pass\n∗\np , and check if\ng\n(p, g, gxgy mod p) to A, and receive from it a value z. Return z - y.\"\nFirst we prove that B is PPT: this amounts to analyzing how many ys we must choose\nbefore gxgy mod p is prime. Note that gxgy mod p is a uniformly random element of Z∗,\np\nand by the prime number theorem, an Ω(1/ log p) fraction of those elements are prime.\nTherefore we expect to choose O(log p) such y. Because A is polytime, B is expected\npolytime.\nThe correctness of the algorithm is clear. Since gxgy mod p = gx+y mod p, the probability\nthat our algorithm returns x is equal to the probability that A returns x + y when gxy is\na uniformly random prime number less than p.\nProblem 3\nWe define the Lily problem as: given two integers n and S determine whether S is\nrelatively prime to φ(n). Prove that if it is hard to determine on inputs two integers n\nand e whether e is relatively prime with φ(n), then the RSA function is hard to invert.\nSolution:\ne\nThe main idea here is that if n and e are relatively prime then f(x) = x mod n is a\npermutation, but if n and e are not relatively prime then f(x) is a manytoone mapping.\nTherefore, if we choose x at random, an RSA inverting algorithm cannot return x on\ne\ninput x with probability better than 1/2. Our reduction will show that we can solve\nthe Lily problem with error probability 1/2 for any n and e such that RSA is \"easy\" for\n\nthat n and e. (Note that we could repeat our procedure many times to reduce the error\nprobability.)\nSuppose for contradiction that RSA is \"easy\" to invert. That is, there exists a PPT\nA such that given (n, e, c) where n is an integer, e is relatively prime with φ(n) and\n∗A(n, e, m\n,\nn\nm ∈ Z\nthat\ne\ne) outputs m such that m = c mod n. For simplicity, we will assume\nRSA inverter inverts with probability 1 over the choice of m. (If the RSA\nour\ninverter sometimes failed, we could use a random selfreducibility argument to create an\nRSA inverter that works with overwhelming probability over the choice of m.)\nWe construct a B which solves the Lily problem as follows: \"on input (n, e), choose m ←\nIf A returns m then output Relatively\n∗\nn at random and give (n, e, m\nZ\ne mod n) to A.\nPrime and otherwise output Not Relatively Prime.\nB is clearly PPT since A is PPT. Now, if (e, φ(n)) = 1, then our RSA inverter is receiving\ne\na valid input (n, e, m mod n) and is obligated to output m in which case B correctly\noutputs Relatively Prime.\nNow suppose (e, φ(n)) > 1. We claim that every eth residue modn has at least two\neth roots (the proof is given below). Since m is chosen randomly, A has absolutely no\ne\ninformation about which of the eth roots of m is the m we started with. Therefore, no\nmatter how A answers in this case, it cannot cause us to output Relatively Prime with\nprobability greater than 1/2.\ne\nFinally, we prove the claim that when (e, φ(n)) = α, every m has at least two eth roots\nmod n. Let β = 1 be an element such that βe = 1. (By Cauchy's Theorem such an\nelement must exist.) Then βm 6=\ne\nm mod n but (βm)e = βeme = me mod n. Thus m\nand βm are distinct eth roots of m mod n.\nProblem 4: Factoring\nLet On be an oracle that on input x returns a square root of x mod n, if one exists, and\n⊥ otherwise. Prove that there exists a probabilistic polynomialtime algorithm that on\ninput an integer n and access to On outputs n's factorization.\nSolution:\nRecall that in class we proved a similar result when n is a product of two distinct odd\nprimes. The exact same technique yields that if we can take square roots mod n then\nwe can find a nontrivial factor α of n. We would like to recurse on α and n/α but this\nwould require taking square roots mod α and n/α and we have only an oracle for square\nroots mod n. Therefore, we show that our oracle for square roots mod n can be used to\nfind square roots mod d for any d dividing n.\nFirst we will outline our algorithm, then we will fill in the details. On input d, (where d\n\ndivides n) algorithm A does the following:\n1. If 2 divides d then store 2 and run A(d/2).\n2. If d is a prime power pk then store pk and halt.\n3. Choose x at random from Zd\n∗ and find a square root y = x and y = -x of x2 mod n.\n4. Let α = gcd(y + x, n).\n5. Run A(α) and A(n/α).\nIn Step 2, observe that if d is a prime power then k is at most log(d). Therefore, for\neach i < log(d) we can take the ith root of d and test whether this root is prime. (ith\nroots can be found in many ways, in particular using Newton's Method.) This allows us\nto determine in polynomial time whether d is a prime power.\nIn Step 4, observe that an argument identical to what we saw in class (when we considered\nthe special case where n was the product of two primes) yields that α is a nontrivial\nfactor of n.\nAll that remains is to handle Step 4. Here we must use On to find a square root y of\nx\nmod d where y = x and y = -x. Here we observe that if y2 = x2 mod n (that is,\nthat y is a square root of x2 mod n) then n divides y - x . Therefore, since d divides\nn, d divides y2 - x . This implies that y2 = x\nmod d. We have thus shown that if y is\na square root of x2 mod n then y is a square root of x2 mod d. Thus On(x2) returns a\nsquare root of x mod d. All that remains is to ensure y = x mod d and y = -x mod d.\nHere we observe that x2 has at least 4 square roots mod d (since d is odd and not a\nprime power). On has absolutely no information about which of the square roots of x2\nwe started with. Therefore, On must give us a square root y not equal to plus or minus\nx mod d at least half the time. Thus we can just repeat Step 3 a small number of times\nand we are very likely to get x and y with the desired properties."
    },
    {
      "category": "Resource",
      "title": "ho9_ps4.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-875-cryptography-and-cryptanalysis-spring-2005/d31e4b811131d2b51edd45002212fb61_ho9_ps4.pdf",
      "content": "6.875/18.425J Cryptography and Cryptanalysis\nMarch 13, 2005\nHandout 9: Problem Set #4\nThis problem set is due on: March 30, 2005.\nProblem 1 PRG\nOWF\n⇒\nProve that the existence of a secure PseudoRandom Generator implies the existence of\na lengthpreserving OneWay Function\nProblem 2 PRGs and Permutations\nLet G be a pseudorandom generator with expansion function `(k), and let h be any\nlengthpreserving permutation (which is not necessarily polynomialtime computable).\nA: Is it necessarily true that the distribution h(G(s)) (where s is chosen uniformly\nat random from {0, 1}k) is indistinguishable from the uniform distribution over\n{0, 1}`(k)? Is h(G(s)) a pseudorandom generator? Justify your answers.\nB: Is it necessarily true that the distribution G(h(s)) (where s is chosen uniformly\nat random from {0, 1}k) is indistinguishable from the uniform distribution over\n{0, 1}`(k)? Is G(h(s)) a pseudorandom generator? Justify your answers.\nC: Will your answers to the previous parts change if it is known that h is polynomial\ntime computable?\nProblem 3 Composing PRGs\nLet G1, G2 be PRGs with expansion functions `1(k),`2(k) (respectively). For each of the\ncandidates below, justify whether the function is a PRG or not. If yes, then provide a\nsecurity reduction. If not, provide a counterexample.\nA: GA(x) = reverse(G1(x)) where the reverse() reverses the bits of its argument.\nB: GB (x) = G1(x) * G2(x)\nC: GC (x * y) = G1(x) * G2(y), where x = y or x = y + 1\n| |\n| |\n| |\n| |\n\nD: GD (x) = G2(G1(x))\nE: GE (x) = G1(x) ⊕(x\n0`1 (|x|)-|x|)\n*\nProblem 4 Unpredictability ⇒ Indistinguishability\nIn class we proved that if the output of a generator G : {0, 1}k\nn (here n is some\n→{0, 1}\npolynomial of k) passes the next bit unpredictability test, then it passes all statistical\ntests. The proof used a hybrid argument to show that if there was a polynomial time\nstatistical test A that distinguishes a completely random string from one generated by\nG, then the test could distinguish between a string in which the first i bits are from G\nand the rest random, and a string in which the first i + 1 bits are from G and the rest\nrandom. To complete the proof, we then need to show how to use this to predict the\nnext bit (i + 1) from the first i bits with probability nonnegligible better than 1 . Below\nare some suggestions of how to produce such a guess for the (i + 1)st bit.\nFor each of the suggested predictors, give a convincing explanation of whether it is indeed\na good predictor or not. Supply a formal proof for one of the good predictors. That is,\nprove that it indeed guesses correctly with probability better than 2 + Q(\nk) for some\npolynomial Q. Denote by Gm the first m bits of G(x) (where x is a random seed), and by\nRm (or Rm) a sequence of m random bit chosen from the uniform distribution. Assume\nwithout loss of generality that Pr[A(GiRn-i) = 0] = p, and that Pr[A(Gi+1Rn-i-1) =\n0] = p + k\nc for some c > 0 (that is, we are assuming w.l.o.g. that A outputs 0 more often\nwhen the (i + 1)st bit is from G). We are now given i bits Gi, and want to guess the\nnext bit. Consider the following predictors.\n(a) Run the test A first on Gi0Rn-i-1 and call the output a0. Then run A on Gi1R0\nn-i-1\nand call the output a1. If a0 = a1 output 0, otherwise output 1.\n(b) Run the test A first on Gi0Rn-i-1 and call the output a0. Then run A on Gi1R0\nn-i-1\nand call the output a1. If a0 = a1 choose the output to be 0 or 1 randomly (with\nprobability 2 ). Otherwise, output the bit b for which ab = 0 (that is, if a0 = 0\noutput 0, and if a1 = 0 output 1).\n(c) Run the test A on GiRn-i. If the answer is 0, output the first bit of Rn-i (which\nis the (i + 1)st bit in the string above). If the answer is 1, output the negation of\nthat bit.\n(d) Run the test A on Gi0Rn-i-1 for polynomially many times (each time with new\nindependent Rn-i-1), and count how many times A outputs 0. If this fraction is\ncloser to p + k\nc than to p, then output 0, otherwise output 1."
    },
    {
      "category": "Resource",
      "title": "ho10_ps5.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-875-cryptography-and-cryptanalysis-spring-2005/768b7e7c19075dda1ba7dbd257431308_ho10_ps5.pdf",
      "content": "6.875/18.425J Cryptography and Cryptanalysis\nApril 1, 2005\nHandout 10: Problem Set #5\nThis problem set is due on: April 15, 2005.\nProblem 1 Fun With Pseudorandom Functions\nSuppose that {FS } is a pseudorandom family of functions from kbit input to kbit\noutput, indexed by a kbit key (\"seed\"). Consider the following constructions, and for\neach say whether it is is pseudorandom or not. If it is, give a proof; if not, demonstrate\na counterexample. Below, \" \" denotes concatenation, \" \" denotes exclusiveor, and x\n*\n⊕\n\ndenotes the bitwise complement of x.\n- GS (x) = FS (x) *FS ( x).\n- GS (x) = F0k (x) *FS (x).\n- GS (x) = FS1 (x) *FS2 (x), where S1 = FS (0k ) and S2 = FS (1k ).\n- GS (x) = Fx(S).\n- GS (x) = FS (x) ⊕S.\n- GS1,S2 (x) = FS1 (x) *(FS2 (x) ⊕S1) (where S1 = S2 = k; consider only evenlength\n|\n|\n|\n|\nseeds for G).\nProblem 2 Another Definition of Pseudorandom Functions\nWe define fs(·) to be a NEWPRF family if: ∀PPTA, ∀M, ∀sufficiently large k,\nProb[s ←{0, 1}k ; (x1, α1) ←A(1k ); (x2, α2) ←A(α1, fs(x1)); . . . ;\n(xM , αM ) ←A(αM -1, fs(xM -1)); (x∗, α∗) ←A(αM , fs(xM ));\nfs(x∗); z1 ←{0, 1} : b = A(α∗, zb)] < neg(k)\nb ←{0, 1}; z0 ←\nk\nFlip a fair coin. If your coin comes up heads, prove that the existence of a NEWPRF\nfamily implies the existence of a PRF family. If your coin comes up tails, prove that the\nexistence of a PRF family implies the existence of a NEWPRF family.\n\nInformal Explanation: We say that fs(·) is a NEWPRF family if no probabilistic\npolynomialtime adversary is able to win the following game between an adversary and\nan oracle. First, the oracle randomly selects a seed, s. Then, the adversary is allowed to\nadaptively select inputs xi and the oracle returns to him fs(xi). Once the adversary is\nsatisfied that he has learned something about the function, he outputs a challenge input\nx∗ (which is not one of the xi's that he previously asked the oracle about). Next, the\noracle randomly selects a bit b and if b = 0 he gives the adversary z0 = fs(x∗) and if\nb = 1 he gives the adversary a truly random value z1. The adversary wins if he can guess\nb nonnegligibly better than 1/2.\n[Note: The role of the α's in the above definition is to allow the adversary to remember\ninformation between invocations. Without loss of generality, we can think of αi as the\ncomplete state of the adversary after he finishes selecting xi.]\nProblem 3 Private Key Encryption\nGive a formal definition of privatekey encryption. Your definition should embody secu\nrity against chosenmessage attacks. (That is, a privatekey cryptosystem should remain\nsecure even if the adversary picks the messages to be encrypted). Additionally, your\ndefinition should require that a privatekey cryptosystem be secure even if the same key\nis used for an arbitrary number of messages. (That is, the onetimepad system should\nnot achieve your definition).\nProve that the existence of PRF's implies the existence of secure privatekey encryption\nschemes.1\nProblem 4 An Active Attack on BlumGoldwasser\nProvide an active attack against the BlumGoldwasser cryptosystem. Recall your defini\ntion of ActiveSecurity from Problem Set 3. Does your definition rule out the the active\nattack you just provided? (Why or Why Not?)\n1Note that since OW F\nP RF , you have also proved that OneWay functions suffice for privatekey\nencryption.\n⇒"
    },
    {
      "category": "Resource",
      "title": "ho11_ps6.pdf",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-875-cryptography-and-cryptanalysis-spring-2005/24b310f1e7764dc4dda2f037cae8f5f7_ho11_ps6.pdf",
      "content": "6.875/18.425J Cryptography and Cryptanalysis\nApril 20, 2005\nHandout 11: Problem Set #6\nThis problem set is due on: May 3, 2005.\nProblem 1 Perfectly Hiding Commitment\nDefinition:\nA tworound perfectlyhiding commitment scheme is a triple of efficient algorithms\n(GEN, COM, V ER) satisfying the following properties.\nCorrectness: For all security parameters k and inputs α,\nPr[g ← GEN(1k ); (c, d) ← COM(g, α) : V ER(g, c, d, α) = TRUE] = 1\nBinding: For all k, and for any probabilistic polynomialtime cheating commiter C∗:\nPr[g ← GEN(1k ); (c, d1, d2, α1, α2) ← C∗(g) :\nV ER(g, c, d1, α1) = V ER(g, c, d2, α2) = TRUE ∧ α1 = α2] < negligible(k)\nPerfect Hiding: For all k, and all inputs α and β the following distributions are identical:\nGEN(1k ); (c, d) ← COM(g, α) : (g, c)i =\nGEN(1k ) : (c, d) ← COM(g, β) : (g, c)i\nhg ←\nhg ←\nProtocol:\nConsider the following tworound protocol for committing to a kbit value, α. The\nalgorithm GEN randomly selects (p, g, h) subject only to the following conditions: (1)\np is a k + 1bit prime number and (2) g and h are generators of Zp\n∗. The algorithm\nCOM on input (p, g, h) and α selects a random t ∈ Z∗ and outputs the commitment\np\nmessage c = gthα mod p and the decommitment message t. The algorithm V ER on\ninput (p, g, h), c, t and α outputs TRUE if and only if c = gthα (mod p).\nProve: the above protocol is, in fact, a perfectlyhiding commitment scheme.\n\nProblem 2 ZeroKnowledge in Parallel\nLet (GEN, COM, V ER) be a perfectly hiding commitment scheme. Here we provide a\nfiveround proof system for ISO.1 with negligible soundness error.\n1. The prover selects g ← GEN(1k ) and sends g to the verifier.\n2. The verifier chooses a kbit random string r, selects (c, d) ← COM(g, r) and sends\nc to the prover.\n3. The prover randomly selects k graphs C1, . . . Ck such that each Ci is isomorphic to\nG and sends C1, . . . , Ck to the verifier.\n4. The verifier sends d and r to the prover.\n5. If r = V ER(g, c, d) then for each graph Ci the prover sends the verifier a random\nisomorphism mapping G to Ci if the ith bit of r is 0 and a random isomorphism\nmapping H to Ci if the ith bit of r is 1.\nProve: the above protocol is, in fact, a zeroknowledge proof system for ISO.\nProblem 3 Hiding and Binding\nProve or Disprove: There exists a bit commitment scheme which is both perfectly\nhiding and perfectly binding.\nNote: A perfectly hiding commitment scheme is defined in problem 1. A commitment\nscheme is perfectly binding if the binding condition holds with respect to all cheating com\nmiters (as opposed to only those running in probabilistic polynomialtime). Encryption\nis an example of a perfectly binding commitment scheme.\nProblem 4 Proofs of Knowledge\nLet L be a language in NP and for x ∈ L let Wx be the set of NPwitnesses for x.\nInformally, (P, V ) is a ZK proof of knowledge for L if on common input x, P convinces\nV that he knows an element of Wx and yet interacting with P provides V provides P\nwith no knowledge other than that x ∈ L. (In particular, V learns nothing about which\nelement of Wx the prover knows!)\nProvide a formal definition of a zeroknowledge proof of knowledge and explain why your\ndefinition captures informal notion above.\n1The language of all pairs of graphs (G, H) such that G is isomorphic to H."
    }
  ]
}