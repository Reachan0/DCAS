{
  "course_name": "Introduction to Computational Thinking and Data Science",
  "course_description": "6.0002 is the continuation of 6.0001 Introduction to Computer Science and Programming in Python and is intended for students with little or no programming experience. It aims to provide students with an understanding of the role computation can play in solving problems and to help students, regardless of their major, feel justifiably confident of their ability to write small programs that allow them to accomplish useful goals. The class uses the Python 3.5 programming language.",
  "topics": [
    "Engineering",
    "Computer Science",
    "Mathematics",
    "Probability and Statistics",
    "Engineering",
    "Computer Science",
    "Mathematics",
    "Probability and Statistics"
  ],
  "syllabus_content": "Course Meeting Times\n\nLectures: 2 sessions / week, 1 hour / session\n\nRecitations: 1 sessions / week, 1 hour / session\n\nPrerequisites\n\n6.0001 Introduction to Computer Science and Programming in Python\nor permission of the instructor.\n\nCourse Information\n\nThis subject is aimed at students with little or no programming experience. It aims to provide students with an understanding of the role computation can play in solving problems. It also aims to help students, regardless of their major, to feel justifiably confident of their ability to write small programs that allow them to accomplish useful goals. The class will use the Python programming language.\n\nNote on 6.0001, 6.0002 and 6.00\n\n6.0001 (6 units): First half of term\n\n6.0002 (6 units): Second half of term\n\n6.00 (12 units): Full term\n\n6.00 satisfies all degree / minor requirements that can be satisfied by taking both 6.0001 and 6.0002.\n\nStudents taking 6.00 will attend the 6.0001 and 6.0002 lectures and do the problem set for 6.0001 and 6.0002. The 6.0001 final will serve as a 6.00 midterm. The 6.0002 final will serve as the 6.00 final.\n\nOCW has additional versions of 6.00 that include useful materials; this course will closely parallell the material covered in these versions:\n\n6.00SC Introduction to Computer Science and Programming\n\n6.00 Introduction to Computer Science and Programming\n\nGoals\n\nProvide an understanding of the role computation can play in solving problems.\n\nHelp students, including those who do not necessarily plan to major in Computer Science and Electrical Engineering, feel confident of their ability to write small programs that allow them to accomplish useful goals.\n\nPosition students so that they can compete for research projects and excel in subjects with programming components.\n\nTextbook\n\nThe textbook is\nGuttag, John.\nIntroduction to Computation and Programming Using Python: With Application to Understanding Data\n. 2nd ed. MIT Press, 2016. ISBN: 9780262529624. [Preview with\nGoogle Books\n] The book and the course lectures parallel each other, though there is more detail in the book about some topics. It is available both in hard copy and as an e-book.\n\nLecture and Recitation Attendance\n\nA significant portion of the material for this course will presented only in lecture, so students are expected to regularly attend lectures.\n\nRecitations give students a chance to ask questions about the lecture material or the problem set for the given week. Sometimes, new material may be covered in recitation. Recitation attendance is encouraged but not required.\n\nProblem Sets and Final Exam\n\nEach problem set will involve programming in Python. There will be 5 problem sets in the course.\n\nThere will be one final exam. The exam is open book / notes but\nnot\nopen Internet and\nnot\nopen computer. Please print whatever you may want to use during the quiz.\n\nGrading Policy\n\nGrades will be roughly computed as follows:\n\nACTIVITIES\n\nPERCENTAGES\n\nProblem sets\n\n50%\n\nCompletion of mandatory finger exercises\n\n10%\n\nFinal Exam\n\n40%\n\nProblem sets will be graded out of 10 points. Submissions that do not run will receive at most 20% of the points.\n\nNote: Finger exercises are not available on OCW.\n\nExtension and Dropping Problem Sets Policy\n\nWe do not grant any extensions. Instead, we offer late days and the option of rolling at most 2 problem set grades into the final exam score.\n\nLate Days\n\nAt the beginning of the term, students are given two late days that they can use on problem sets. Starting with Problem Set 1, additional late days can be accumulated for each assignment, one late day for each day the assignment is turned in ahead of the deadline. Up to three late days may be accumulated in this fashion in this course, i.e., you can only have a maximum of 3 late days at any point in time. Late days are discrete (a student cannot use half a late day). The staff will keep track of late days and feedback for each problem set will include the number of late days the student has remaining. Any additional late work beyond these late days will not be accepted. To avoid surprises, we suggest that after you submit your problem set, you double check to make sure the submission was uploaded correctly.\n\nRolling Over Problem Sets\n\nAs we assign final grades, we will maximize your score based on the choice to roll the weight of at most two problem sets into your final exam score. If rolled, the percent that the problem sets are worth will be rolled into the final exam score. We strongly urge you to see the late days and dropping the problem sets as backup in case of an emergency. Your best strategy is to do the problem sets early before work starts to pile up.\n\nCalendar\n\nSES #\n\nTOPICS\n\nKEY DATES\n\nIntroduction and Optimization Problems\n\nProblem set 1 out\n\nOptimization Problems\n\nGraph-theoretic Models\n\nStochastic Thinking\n\nProblem set 1 due\nProblem set 2 out\n\nRandom Walks\n\nMonte Carlo Simulation\n\nProblem set 2 due\nProblem set 3 out\n\nConfidence Intervals\n\nSampling and Standard Error\n\nProblem set 3 due\nProblem set 4 out\n\nUnderstanding Experimental Data\n\nProblem set 4 due\nProblem set 5 out\n\nUnderstanding Experimental Data (cont.)\n\nIntroduction to Machine Learning\n\nClustering\n\nClassification\n\nProblem set 5 due\n\nClassification and Statistical Sins\n\nStatistical Sins and Wrap Up\n\nFinal Exam",
  "files": [
    {
      "category": "Lecture Code",
      "title": "lectureCode.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/cea07031a5c42a3bbb3d5f095255f380_lectureCode.py",
      "content": "import pylab, random\n#from test_hypothesis import *\n\n#set line width\npylab.rcParams['lines.linewidth'] = 4\n#set font size for titles\npylab.rcParams['axes.titlesize'] = 18\n#set font size for labels on axes\npylab.rcParams['axes.labelsize'] = 18\n#set size of numbers on x-axis\npylab.rcParams['xtick.labelsize'] = 16\n#set size of numbers on y-axis\npylab.rcParams['ytick.labelsize'] = 16\n#set size of ticks on x-axis\npylab.rcParams['xtick.major.size'] = 7\n#set size of ticks on y-axis\npylab.rcParams['ytick.major.size'] = 7\n#set size of markers\npylab.rcParams['lines.markersize'] = 10\n\ndef variance(X):\nmean = float(sum(X))/len(X)\ndiffs = 0.0\nfor x in X:\ndiffs += (x - mean)**2\nreturn diffs/len(X)\n\ndef stdDev(X):\nreturn variance(X)**0.5\n\ndef minkowskiDist(v1, v2, p):\n\"\"\"Assumes v1 and v2 are equal-length arrays of numbers\nReturns Minkowski distance of order p between v1 and v2\"\"\"\ndist = 0.0\nfor i in range(len(v1)):\ndist += abs(v1[i] - v2[i])**p\nreturn dist**(1.0/p)\n\nclass Animal(object):\ndef __init__(self, name, features):\n\"\"\"Assumes name a string; features a list of numbers\"\"\"\nself.name = name\nself.features = pylab.array(features)\n\ndef getName(self):\nreturn self.name\n\ndef getFeatures(self):\nreturn self.features\n\ndef distance(self, other):\n\"\"\"Assumes other an Animal\nReturns the Euclidean distance between feature vectors\nof self and other\"\"\"\nreturn minkowskiDist(self.getFeatures(),\nother.getFeatures(), 2)\n\ndef compareAnimals(animals, precision):\n\"\"\"Assumes animals is a list of animals, precision an int >= 0\nBuilds a table of Euclidean distance between each animal\"\"\"\n#Get labels for columns and rows\ncolumnLabels = []\nfor a in animals:\ncolumnLabels.append(a.getName())\nrowLabels = columnLabels[:]\ntableVals = []\n#Get distances between pairs of animals\n#For each row\nfor a1 in animals:\nrow = []\n#For each column\nfor a2 in animals:\nif a1 == a2:\nrow.append('--')\nelse:\ndistance = a1.distance(a2)\nrow.append(str(round(distance, precision)))\ntableVals.append(row)\n#Produce table\ntable = pylab.table(rowLabels = rowLabels,\ncolLabels = columnLabels,\ncellText = tableVals,\ncellLoc = 'center',\nloc = 'center',\ncolWidths = [0.2]*len(animals))\ntable.scale(1, 2.5)\npylab.title('Eucliedan Distance Between Animals')\n\nrattlesnake = Animal('rattlesnake', [1,1,1,1,0])\nboa = Animal('boa\\nconstrictor', [0,1,0,1,0])\ndartFrog = Animal('dart frog', [1,0,1,0,4])\nanimals = [rattlesnake, boa, dartFrog]\ncompareAnimals(animals, 3)\n#\n#alligator = Animal('alligator', [1,1,0,1,4])\n#animals.append(alligator)\n#compareAnimals(animals, 3)\n\n#rattlesnake = Animal('rattlesnake', [1,1,1,1,0])\n#boa = Animal('boa\\nconstrictor', [0,1,0,1,0])\n#dartFrog = Animal('dart frog', [1,0,1,0,1])\n#alligator = Animal('alligator', [1,1,0,1,1])\n#animals = [rattlesnake, boa, dartFrog, alligator]\n#compareAnimals(animals, 3)"
    },
    {
      "category": "Lecture Code",
      "title": "lectureGraphs.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/4ca8d422daeafd10a296c9f2b0df9189_lectureGraphs.py",
      "content": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Jul 12 15:04:56 2016\n\n@author: guttag, revised egrimson\n\"\"\"\n\nclass Node(object):\ndef __init__(self, name):\n\"\"\"Assumes name is a string\"\"\"\nself.name = name\ndef getName(self):\nreturn self.name\ndef __str__(self):\nreturn self.name\n\nclass Edge(object):\ndef __init__(self, src, dest):\n\"\"\"Assumes src and dest are nodes\"\"\"\nself.src = src\nself.dest = dest\ndef getSource(self):\nreturn self.src\ndef getDestination(self):\nreturn self.dest\ndef __str__(self):\nreturn self.src.getName() + '->' + self.dest.getName()\n\nclass Digraph(object):\n\"\"\"edges is a dict mapping each node to a list of\nits children\"\"\"\ndef __init__(self):\nself.edges = {}\ndef addNode(self, node):\nif node in self.edges:\nraise ValueError('Duplicate node')\nelse:\nself.edges[node] = []\ndef addEdge(self, edge):\nsrc = edge.getSource()\ndest = edge.getDestination()\nif not (src in self.edges and dest in self.edges):\nraise ValueError('Node not in graph')\nself.edges[src].append(dest)\ndef childrenOf(self, node):\nreturn self.edges[node]\ndef hasNode(self, node):\nreturn node in self.edges\ndef getNode(self, name):\nfor n in self.edges:\nif n.getName() == name:\nreturn n\nraise NameError(name)\ndef __str__(self):\nresult = ''\nfor src in self.edges:\nfor dest in self.edges[src]:\nresult = result + src.getName() + '->'\\\n+ dest.getName() + '\\n'\nreturn result[:-1] #omit final newline\n\nclass Graph(Digraph):\ndef addEdge(self, edge):\nDigraph.addEdge(self, edge)\nrev = Edge(edge.getDestination(), edge.getSource())\nDigraph.addEdge(self, rev)\n\ndef buildCityGraph(graphType):\ng = graphType()\nfor name in ('Boston', 'Providence', 'New York', 'Chicago',\n'Denver', 'Phoenix', 'Los Angeles'): #Create 7 nodes\ng.addNode(Node(name))\ng.addEdge(Edge(g.getNode('Boston'), g.getNode('Providence')))\ng.addEdge(Edge(g.getNode('Boston'), g.getNode('New York')))\ng.addEdge(Edge(g.getNode('Providence'), g.getNode('Boston')))\ng.addEdge(Edge(g.getNode('Providence'), g.getNode('New York')))\ng.addEdge(Edge(g.getNode('New York'), g.getNode('Chicago')))\ng.addEdge(Edge(g.getNode('Chicago'), g.getNode('Denver')))\ng.addEdge(Edge(g.getNode('Chicago'), g.getNode('Phoenix')))\ng.addEdge(Edge(g.getNode('Denver'), g.getNode('Phoenix')))\ng.addEdge(Edge(g.getNode('Denver'), g.getNode('New York')))\ng.addEdge(Edge(g.getNode('Los Angeles'), g.getNode('Boston')))\nreturn g\n\ndef printPath(path):\n\"\"\"Assumes path is a list of nodes\"\"\"\nresult = ''\nfor i in range(len(path)):\nresult = result + str(path[i])\nif i != len(path) - 1:\nresult = result + '->'\nreturn result\n\ndef DFS(graph, start, end, path, shortest, toPrint = False):\n\"\"\"Assumes graph is a Digraph; start and end are nodes;\npath and shortest are lists of nodes\nReturns a shortest path from start to end in graph\"\"\"\npath = path + [start]\nif toPrint:\nprint('Current DFS path:', printPath(path))\nif start == end:\nreturn path\nfor node in graph.childrenOf(start):\nif node not in path: #avoid cycles\nif shortest == None or len(path) < len(shortest):\nnewPath = DFS(graph, node, end, path, shortest,\ntoPrint)\nif newPath != None:\nshortest = newPath\nelif toPrint:\nprint('Already visited', node)\nreturn shortest\n\ndef shortestPath(graph, start, end, toPrint = False):\n\"\"\"Assumes graph is a Digraph; start and end are nodes\nReturns a shortest path from start to end in graph\"\"\"\nreturn DFS(graph, start, end, [], None, toPrint)\n\ndef testSP(source, destination):\ng = buildCityGraph(Digraph)\nsp = shortestPath(g, g.getNode(source), g.getNode(destination),\ntoPrint = True)\nif sp != None:\nprint('Shortest path from', source, 'to',\ndestination, 'is', printPath(sp))\nelse:\nprint('There is no path from', source, 'to', destination)\n\ntestSP('Chicago', 'Boston')\nprint()\n#testSP('Boston', 'Phoenix')\n#print()\n\nprintQueue = True\n\ndef BFS(graph, start, end, toPrint = False):\n\"\"\"Assumes graph is a Digraph; start and end are nodes\nReturns a shortest path from start to end in graph\"\"\"\ninitPath = [start]\npathQueue = [initPath]\nwhile len(pathQueue) != 0:\n#Get and remove oldest element in pathQueue\nif printQueue:\nprint('Queue:', len(pathQueue))\nfor p in pathQueue:\nprint(printPath(p))\ntmpPath = pathQueue.pop(0)\nif toPrint:\nprint('Current BFS path:', printPath(tmpPath))\nprint()\nlastNode = tmpPath[-1]\nif lastNode == end:\nreturn tmpPath\nfor nextNode in graph.childrenOf(lastNode):\nif nextNode not in tmpPath:\nnewPath = tmpPath + [nextNode]\npathQueue.append(newPath)\nreturn None\n\ndef shortestPath(graph, start, end, toPrint = False):\n\"\"\"Assumes graph is a Digraph; start and end are nodes\nReturns a shortest path from start to end in graph\"\"\"\nreturn BFS(graph, start, end, toPrint)\n\n#testSP('Boston', 'Phoenix')"
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 1",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/0a353b26f1c6bd161b28b3f249aa05d1_MIT6_0002F16_lec1.pdf",
      "content": "!\"\n# $%! !\"&'\n(%!\"$)%%!\n(%!\"%%\"\n)$$\n!\"###$%\n\n%\n# %\n# *+!),%%\n# -%!)%\")%%\n(\n# .!%%%\n\"%!)%%\n\n,\n# /\",%\n)%+!%)\n%\n0+\n&\n\n'\n\n&\n\n# ()\"%%+\"\n\n)\n)%%$\n)%1)\n!)\n()!\"###*+\n\n/$%$ !\"\n3$\n,\n-!) -%%4\n(\n,\n-\n\n'\n\n)\"%)\"%\n\"\"%+\nExperimental devices that help us to understand\nsomething that has happened or to predict the future\n56%\n3%%\n3)%%\n\nImages (c) sources unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use.\n\n3'27%$)8\n.'.\n/01\n\n)\"%)\"%\n\"\"%+\nExperimental devices that help us to understand\nsomething that has happened or to predict the future\n\n3%%\n3)%%\n\n:\nImages (c) sources unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use.\n\n+\nAn objective function that is to be maximized or\nminimized, e.g.,\n# Minimize time spent traveling from New York to Boston\nA set of constraints (possibly empty) that must be\nhonored, e.g.,\n# Cannot spend more than $100\n# Must be in Boston before 5:00PM\n\n;\nImages (c) sources unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use.\n\n3 -\n\nImages (c) sources unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use.\n\n3 -\n<)\"+%\"1\")\n\",,\"!)!\n<))%%,,)$$\"!)!\n-!)\"\"\")$$,\"\"\n%+\"4\n\n+\n# =,,%\n# ))$%,,%\n\nImages (c) sources unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use.\n\n/14'\n3 -\n\nImages (c) sources unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use.\n\n\"!1\n\n\",,\"%\n\"$\"\n/+11$%\"\n1\"$\n+%%\"%$\"+\n\n/+11$%\"\n1)\"\"\n,*$1 ,\n*$1 ,\n#5*3 -67\n\n&\n\n#5*3 -67\n\n)%%%$\n\"\n!1%%)$\"$\n\"\n%%\"\n+%%$\"\"%)\n\"%%\"\n&(\"\"!\n\"+%)\"%\n87 &\n\n'\n\n-4\n%%\n# /+11$%\"\n1)\"\"\n,*$1 ,*$1\n,\n-!%$$+%) \"+4\n# /!$$!)\n\n(%1$\"\"$1\"\n$64\n# 191'11:1;1212;19&1'1&9\n\n/%1\n=,,%\"%!%\n>)?\n&28\n\n+\n\nwhile knapsack not full\nput \"best\" available item in knapsack\n>)\"4\n# @+%)%\n# +\n# -\"+%)=)\n/&\n\n&\n'\n\n:\n\n<))\n%\n<),\")\"!)\n+%)$$$11\n!)%,)\"\n%\n>)!)\"+%\n)11!)?\n)\"9'\n%\n\"\"\n,,%\n&:\n\n;\n\n?%,\")\"\n\n&\n\n.%)\n:;\n;\n&\n'\n;\n9;\n;\n\n%\n&\n'2\n':\n&'2\n&'\n'\n;'\n;'\n\nclass Food(object):\ndef __init__(self, n, v, w):\nself.name = n\nself.value = v\nself.calories = w\ndef getValue(self):\nreturn self.value\ndef getCost(self):\nreturn self.calories\ndef density(self):\nreturn self.getValue()/self.getCost()\ndef __str__(self):\nreturn self.name + ': <' + str(self.value)\\\n+ ', ' + str(self.calories) + '>'\n\ndef buildMenu(names, values, calories):\n\"\"\"names, values, calories lists of same length.\nname a list of strings\nvalues and calories lists of numbers\nreturns list of Foods\"\"\"\nmenu = []\nfor i in range(len(values)):\nmenu.append(Food(names[i], values[i],\ncalories[i]))\nreturn menu\n\n7:\n/\ndef greedy(items, maxCost, keyFunction):\n\"\"\"Assumes items a list, maxCost >= 0,\nkeyFunction maps elements of items to numbers\"\"\"\nitemsCopy = sorted(items, key = keyFunction,\nreverse = True)\nresult = []\ntotalValue, totalCost = 0.0, 0.0\nfor i in range(len(itemsCopy)):\nif (totalCost+itemsCopy[i].getCost()) <= maxCost:\nresult.append(itemsCopy[i])\ntotalCost += itemsCopy[i].getCost()\ntotalValue += itemsCopy[i].getValue()\nreturn (result, totalValue)\n\n&\n\n&\n\n/\ndef greedy(items, maxCost, keyFunction):\nitemsCopy = sorted(items, key = keyFunction,\nreverse = True)\nresult = []\ntotalValue, totalCost = 0.0, 0.0\nfor i in range(len(itemsCopy)):\nif (totalCost+itemsCopy[i].getCost()) <= maxCost:\nresult.append(itemsCopy[i])\ntotalCost += itemsCopy[i].getCost()\ntotalValue += itemsCopy[i].getValue()\nreturn (result, totalValue)\n\n;\n/\ndef testGreedy(items, constraint, keyFunction):\ntaken, val = greedy(items, constraint, keyFunction)\nprint('Total value of items taken =', val)\nfor item in taken:\nprint(' ', item)\n\n'\n\n;\n/\ndef testGreedys(maxUnits):\nprint('Use greedy by value to allocate', maxUnits,\n'calories')\ntestGreedy(foods, maxUnits, Food.getValue)\nprint('\\nUse greedy by cost to allocate', maxUnits,\n'calories')\ntestGreedy(foods, maxUnits,\nlambda x: 1/Food.getCost(x))\nprint('\\nUse greedy by density to allocate', maxUnits,\n'calories')\ntestGreedy(foods, maxUnits, Food.density)\ntestGreedys(800)\n\n%)!)$)\n# lambda A11BC0AC\n# )$)$)\n+!\"!1\"\n%6%%\nD?E)def\n\n;\n/\ndef testGreedys(foods, maxUnits):\nprint('Use greedy by value to allocate', maxUnits,\n'calories')\ntestGreedy(foods, maxUnits, Food.getValue)\nprint('\\nUse greedy by cost to allocate', maxUnits,\n'calories')\ntestGreedy(foods, maxUnits,\nlambda x: 1/Food.getCost(x))\nprint('\\nUse greedy by density to allocate', maxUnits,\n'calories')\ntestGreedy(foods, maxUnits, Food.density)\nnames = ['wine', 'beer', 'pizza', 'burger', 'fries',\n'cola', 'apple', 'donut', 'cake']\nvalues = [89,90,95,100,90,79,50,10]\ncalories = [123,154,258,354,365,150,95,195]\nfoods = buildMenu(names, values, calories)\ntestGreedys(foods, 750)\n)\n\n:\n\n3F)$%%%!G%H\"?%!\n!%%%%!%%)\n*!!!%!4\n#\n!I!7$18\n2/\n&)+\n\n;\n\n!%\n)%%!$$\n>)%!!%\"%)\n# D?+,\"\"\n*\"%)?%%%,$)%!%\n%)\n/\n\n&\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0002 Introduction to Computational Thinking and Data Science\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 2: Optimization Problems",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/3edc8db04a770f3da51086320c8fe4da_MIT6_0002F16_lec2.pdf",
      "content": "Op#miza#on Problems,\nJohn Gu7ag\nMIT Department of Electrical Engineering and\nComputer Science\n\n6.0002 LECTURE 2\n\n§ Chapter 13\nRelevant Reading for Today's Lecture\n6.0002 LECTURE 2\n\nThe Pros and Cons of Greedy\n§ Easy to implement\n§ Computa<onally efficient\n§ But does not always yield the best solu<on\n* Don't even know how good the approxima<on is\n6.0002 LECTURE 2\nQues<on 1\n\n§ 1. Enumerate all possible combina<ons of items.\n§ 2. Remove all of the combina<ons whose total units\nexceeds the allowed weight.\n§ 3. From the remaining combina<ons choose any one\nwhose value is the largest.\nBrute Force Algorithm\n6.0002 LECTURE 2\n\n§ The tree is built top down star<ng with the root\n§ The first element is selected from the s<ll to be\nconsidered items\n* If there is room for that item in the knapsack, a node is\nconstructed that reflects the consequence of choosing to\ntake that item. By conven<on, we draw that as the leS\nchild\n* We also explore the consequences of not taking that\nitem. This is the right child\n§ The process is then applied recursively to non-leaf\nchildren\n§ Finally, chose a node with the highest value that meets\nconstraints\nSearch Tree Implementa#on\n6.0002 LECTURE 2\n\nA Search Tree Enumerates Possibili#es\n6.0002 LECTURE 2\nTake\nDon'tTake\nLeS-first, depth-first\nenumera<on\nVal = 170\nCal = 766\nVal = 120\nCal = 766\nVal = 140\nCal = 508\nVal = 90\nCal = 145\nVal = 80\nCal = 612\nVal = 30\nCal = 258\nVal = 50\nCal = 354\nVal = 0\nCal = 0\n\n6.0002 LECTURE 2\nImage (c) source unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use.\n\n§ Time based on number of nodes generated\n§ Number of levels is number of items to choose from\n§ Number of nodes at level i is 2i\n§ So, if there are n items the number of nodes is\n* ∑i=0↑i=n▒2↑i\n* I.e., O(2↑n+1 )\n§ An obvious op<miza<on: don't explore parts of tree\nthat violate constraint (e.g., too many calories)\n* Doesn't change complexity\n§ Does this mean that brute force is never useful?\n* Let's give it a try\nComputa#onal Complexity\n6.0002 LECTURE 2\n\nHeader for Decision Tree Implementa#on\n6.0002 LECTURE 2\ndef maxVal(toConsider, avail):\n\"\"\"Assumes toConsider a list of items,\navail a weight\nReturns a tuple of the total value of a\nsolution to 0/1 knapsack problem and\nthe items of that solution\"\"\"\ntoConsider. Those items that nodes higher up in the tree\n(corresponding to earlier calls in the recursive call stack)\nhave not yet considered\n\navail. The amount of space still available\n\nBody of maxVal (without comments)\n6.0002 LECTURE 2\nif toConsider == [] or avail == 0:\nresult = (0, ())\nelif toConsider[0].getUnits() > avail:\nresult = maxVal(toConsider[1:], avail)\nelse:\nnextItem = toConsider[0]\nwithVal, withToTake = maxVal(toConsider[1:],\navail - nextItem.getUnits())\nwithVal += nextItem.getValue()\nwithoutVal, withoutToTake = maxVal(toConsider[1:], avail\nf withVal > withoutVal:\nresult = (withVal, withToTake + (nextItem,))\nelse:\nresult = (withoutVal, withoutToTake)\neturn result\noes not actually build search tree\n\n)\ni\n\nr\nD\nLocal variable result records best solu<on found so far\n\n§ With calorie budget of 750 calories, chose an op<mal\nset of foods from the menu\nTry on Example from Lecture 1\n6.0002 LECTURE 2\nFood\nwine\nbeer\npizza\nburger\nfries\ncoke apple\ndonut\nValue\ncalories\n\n§ Gave us a befer answer\n§ Finished quickly\n§ But 28 is not a large number\n* We should look at what happens when we have a more\nextensive menu to choose from\nSearch Tree Worked Great\n6.0002 LECTURE 2\n\nCode to Try Larger Examples\n6.0002 LECTURE 2\nimport random\ndef buildLargeMenu(numItems, maxVal, maxCost):\nitems = []\nfor i in range(numItems):\nitems.append(Food(str(i),\nrandom.randint(1, maxVal),\nrandom.randint(1, maxCost)))\nreturn items\nfor numItems in (5,10,15,20,25,30,35,40,45,50,55,60):\nitems = buildLargeMenu(numItems, 90, 250)\ntestMaxVal(items, 750, False)\n\n§ In theory, yes\n§ In prac<ce, no!\n§ Dynamic programming to the rescue\nIs It Hopeless?\n6.0002 LECTURE 2\n\nSome<mes a name is just a name\n\n\"The 1950s were not good years for mathema<cal\nresearch... I felt I had to do something to shield Wilson\nand the Air Force from the fact that I was really doing\nmathema<cs... What <tle, what name, could I\nchoose? ... It's impossible to use the word dynamic in a\npejora<ve sense. Try thinking of some combina<on that\nwill possibly give it a pejora<ve meaning. It's\nimpossible. Thus, I thought dynamic programming was\na good name. It was something not even a\nCongressman could object to. So I used it as an\numbrella for my ac<vi<es.\n-- Richard Bellman\nDynamic Programming?\n6.0002 LECTURE 2\n\nRecursive Implementa#on of Fibonnaci\n6.0002 LECTURE 2\ndef fib(n):\nif n == 0 or n == 1:\nreturn 1\nelse:\nreturn fib(n - 1) + fib(n - 2)\nfib(120) = 8,670,007,398,507,948,658,051,921\n\nCall Tree for Recursive Fibonnaci(6) = 13\n6.0002 LECTURE 2\nfib(6)\nfib(5)\nfib(4)\nfib(3)\nfib(2)\nfib(1)\nfib(0)\nfib(1)\nfib(2)\nfib(1)\nfib(0)\nfib(3)\nfib(2)\nfib(1)\nfib(0)\nfib(1)\nfib(4)\nfib(3)\nfib(2)\nfib(1)\nfib(0)\nfib(1)\nfib(2)\nfib(1)\nfib(0)\n\n§ Trade a <me for space\n§ Create a table to record what we've done\n*Before compu<ng fib(x), check if value of fib(x)\nalready stored in the table\n*If so, look it up\n*If not, compute it and then add it to table\n*Called memoiza<on\nClearly a Bad Idea to Repeat Work\n6.0002 LECTURE 2\n\nUsing a Memo to Compute Fibonnaci\n6.0002 LECTURE 2\ndef fastFib(n, memo = {}):\n\"\"\"Assumes n is an int >= 0, memo used only by\nrecursive calls\nReturns Fibonacci of n\"\"\"\nif n == 0 or n == 1:\nreturn 1\ntry:\nreturn memo[n]\nexcept KeyError:\nresult = fastFib(n-1, memo) +\\\nfastFib(n-2, memo)\nmemo[n] = result\nreturn result\n\n§ Op<mal substructure: a globally op<mal solu<on can\nbe found by combining op<mal solu<ons to local\nsubproblems\n*For x > 1, fib(x) = fib(x - 1) + fib(x - 2)\n§ Overlapping subproblems: finding an op<mal solu<on\ninvolves solving the same problem mul<ple <mes\n*Compute fib(x) or many <mes\nWhen Does It Work?\n6.0002 LECTURE 2\n\n§ Do these condi<ons hold?\nWhat About 0/1 Knapsack Problem?\n6.0002 LECTURE 2\nQues<ons 2 and 3\n\nSearch Tree\n6.0002 LECTURE 2\nTake\nDon'tTake\nVal = 170\nCal = 766\nVal = 120\nCal = 766\nVal = 140\nCal = 508\nVal = 90\nCal = 145\nVal = 80\nCal = 612\nVal = 30\nCal = 258\nVal = 50\nCal = 354\nVal = 0\nCal = 0\nOp<mal substructure?\nOverlapping subproblems?\n\nA Different Menu\n6.0002 LECTURE 2\nTake\nDon't Take\n\nNeed Not Have Copies of Items\n6.0002 LECTURE 2\nItem\nValue\nCalories\na\nb\nc\nd\n\n§ Each node = <taken, leS, value, remaining calories>\nSearch Tree\n6.0002 LECTURE 2\n\n§ Given remaining weight, maximize value by choosing\namong remaining items\n§ Set of previously chosen items, or even value of that\nset, doesn't mafer!\nWhat Problem is Solved at Each Node?\n6.0002 LECTURE 2\n\nOverlapping Subproblems\n6.0002 LECTURE 2\n\n§ Add memo as a third argument\n*def fastMaxVal(toConsider, avail, memo = {}):\n§ Key of memo is a tuple\n*(items leS to be considered, available weight)\n*Items leS to be considered represented by\nlen(toConsider)\n§ First thing body of func<on does is check whether the\nop<mal choice of items given the the available weight\nis already in the memo\n§ Last thing body of func<on does is update the memo\nModify maxVal to Use a Memo\n6.0002 LECTURE 2\n\nPerformance\n6.0002 LECTURE 2\nlen(items)\n2**len(items)\nNumber of calls\n65,536\n5,191\n4,294,967,296\n22,701\n18,446,744,073,709 42,569\n,551,616\nBig\n83,319\nReally Big\n176,614\nRidiculously big\n351,230\nAbsolutely huge\n703,802\n\n§ Problem is exponen<al\n§ Have we overturned the laws of the universe?\n§ Is dynamic programming a miracle?\n§ No, but computa<onal complexity can be subtle\n§ Running <me of fastMaxVal is governed by number of\ndis<nct pairs, <toConsider, avail>\n*Number of possible values of toConsider bounded\nby len(items)\n*Possible values of avail a bit harder to characterize\n*Bounded by number of dis<nct sums of weights\n*Covered in more detail in assigned reading\nHow Can This Be?\n6.0002 LECTURE 2\n\n§ Many problems of prac<cal importance can be\nformulated as op<miza<on problems\n§ Greedy algorithms oSen provide adequate (though not\nnecessarily op<mal) solu<ons\n§ Finding an op<mal solu<on is usually exponen<ally\nhard\n§ But dynamic programming oSen yields good\nperformance for a subclass of op<miza<on problems--\nthose with op<mal substructure and overlapping\nsubproblems\n*Solu<on always correct\n*Fast under the right circumstances\nSummary of Lectures 1-2\n6.0002 LECTURE 2\n\nThe \"Roll-over\" Op#miza#on Problem\n6.0002 LECTURE 2\nScore = ((60 - (a+b+c+d+e))*F + a*ps1 + b*ps2 + c*ps3 + d*ps4 + e*ps5\nObjec<ve:\nGiven values for F, ps1, ps2, ps3, ps4, ps5\nFind values for a, b, c, d, e that maximize score\nConstraints:\na, b, c, d, e are each 10 or 0\na + b + c + d + e ≥ 20\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0002 Introduction to Computational Thinking and Data Science\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 3: Graph-theoretic Models",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/69b5b28067ecf1769a6143453d77eba1_MIT6_0002F16_lec3.pdf",
      "content": "%$6'#%(# &\n% %!&#\"\n\n$%'!\"' '% \"\"%\"\"\n#!$,'%\"\nQ>KKKMN\nL\n\n-\"'\"#%#/5&',%\n1*)LM>M\nQ>KKKMN\nM\n\n#!$,'(#\" # &\n.*\".(/0#0#',3/3)./0)0#5*.')/*'4\n,.1',.*'(/\n5#*55*3'(,0#$)*.(',.*'(*\n#**/$)\"5#00*0$)0*)*,1($81*),.*'(<\n)#*55*3'/$\"),.*\".(0*/*'4$0\n*55)00*'**&0'//*(*'/''\".,#/\nQ>KKKMN\nN\n\n0*)*/E4.1/F\nW $\"#0#4,.*,.1///*$05$0#0#(\n0*\"/E./F#*)/$/1)\"*,$.*)*/\nW )$.0E\".,#F\nW $.0E$\".,#F\nW *3.E,.)0F)/1)1*)E#$'F)*/\nW )5$\"#0*.5$\"#0\n'5& %$2\nQ>KKKMN\nO\n\n'5& %$2\n0*)*/E4.1/F\nW $\"#0#4,.*,.1///*$05$0#0#(\n0*\"/E./F#*)/$/1)\"*,$.*)*/\nW )$.0E\".,#F\nW $.0E$\".,#F\nW *3.E,.)0F)/1)1*)E#$'F)*/\nW )5$\"#0*.5$\"#0\nQ>KKKMN\nP\nLK\nLM\nN\n\n/ %$&2\n*,03.3/3'.'1*)/#$,/(*)\")11/\nW $''$)&/05).$/)*)*)\nW *50#0*(/$)(*'3'..'00**))*0#.\nW )/0.'.'1*)/#$,/\nQ>KKKMN\nQ\n\n%&4\"\n!$#%'\"'$ &\n/,$'&$)*$.0\".,#$)5#$#)7,$.*\n)*/$/*))07/$)\"',0#\nW ''0#/.#0./53/0*/*'4&),/&\n,.*'(\nQ>KKKMN\nR\n\n/ %$&%#&,\n*.'$/3''*)05*.&//*).'1*)/#$,/\nW *(,30.)05*.&/\nW .)/,*.01*))05*.&/\nW $))$')05*.&/\nW 5.*.50.)05*.&/\nW *'$1')05*.&/\nW .$($)')05*.&/\nW *$')05*.&/\nW 0>\n\nQ>KKKMN\nS\n)'7/$/*@$8.*8A=\nC/$8*)*. 0/)3(.*/)/\n$)5#$##.0./#./$'*\"3\nC*'*.*'3/0./. 0/)03.'\n$)0.1*)/5$0##*0#.30)*0\n*0#./\nWizard of Oz dialogue map (c) Mapr.com. All rights reserved. This content is\nexcluded from our Creative Commons license. For more information,\nsee https://ocw.mit.edu/help/faq-fair-use.\n\n/ %$&%#&,\n5$''/0#0)*0*)'7*\".,#/,03.\n.'1*)/#$,/$)*))0)05*.&/*'()0/<0#7\n'/*/3,,*.0$).)*)0#*//0.303./\nW $)$)\"/-3)/*'$)&/05)'()0/D$/0#.\n,0#.*(0*\nW $)$)\"0#'/06,)/$4,0#05)'()0/E&\n/#*.0/0,0#,.*'(F\nW .11*)$)\"0#\".,#$)0*/0/**))0'()0/\nE&\".,#,.11*),.*'(F\nW $)$)\"0#(*/0$)0570*/,.0/0/*\n*))0'()0/E&0#($)C30B(6C *5,.*'(F\nQ>KKKMN\nT\n\n%$#%/-&!-%//\nQ>KKKMN\nLK\n0DSLPDJHVRXUFHXQNQRZQ$OOULJKWVUHVHUYHG7KLVFRQWHQWLVH[FOXGHGIURPRXU&UHDWLYH\n&RPPRQVOLFHQVH)RUPRUHLQIRUPDWLRQVHHKWWSVRFZPLWHGXKHOSIDTIDLUXVH\n\n*\"%'#&\n*'.*/7/0(3/$)\"$\".,#\nW */=,*$)0/5#..*/)*.(0\nW \"/=*))1*)/05),*$)0/\nW #\"#/5$\"#0\nW 6,01(0*\"0.*(/*3.)*0*/1)1*))**.0#0\"\nW $/0)05)/*3.)/1)1*))*/\nW 4.\"/,*0.4'05)/*3.)/1)1*))*/\n*'4\".,#*,1($81*),.*'(\nW #*.0/05$\"#0,0#05)(7#*3/)(7*\nLL\nQ>KKKMN\n\n,PDJHVVRXUFHVXQNQRZQ$OOULJKWVUHVHUYHG7KLVFRQWHQWLVH[FOXGHGIURPRXU &UHDWLYH\n&RPPRQVOLFHQVH)RUPRUHLQIRUPDWLRQVHHKWWSVRFZPLWHGXKHOSIDTIDLUXVH\n\n%&'$#%'&# %$#%/\n.$\"/*\n+)$\"/.\"\nELRNPF\n*//$'0*0&\n5'&0#0\n0.4.//#*\n0#R.$\"/\n60'7*);\n0DSLPDJHVRXUFHXQNQRZQ$OOULJKWVUHVHUYHG7KLVFRQWHQWLVH[FOXGHGIURPRXU&UHDWLYH\n&RPPRQVOLFHQVH)RUPRUHLQIRUPDWLRQVHHKWWSVRFZPLWHGXKHOSIDTIDLUXVH\nQ>KKKMN\nLM\n\n#\"%, %5&#\n#$/'))*\n#.$\")3)$.0\"\n*'/0.0/57$..'4)00$'/\nW $8*$/')/\nW )\"0#*.$\"/\n\n/0#.,0#0#0*)0$)/#\"60'7*);\nW\nQ>KKKMN\nLN\n\n!$ !\"(\"\",&\"%$&\n3$'$)\"\".,#/\nW */\nW \"/\nW 10#$)\"0*\"0#.0*(&\".,#/\n/$)\"\".,#/\nW .#$)\"*.,0#/05))*/\nW .#$)\"*.*,1(',0#/05))*/\nQ>KKKMN\nLO\n\n&&#\nclass Node(object):\ndef __init__(self, name):\n\"\"\"Assumes name is a string\"\"\"\nself.name = name\ndef getName(self):\nreturn self.name\ndef __str__(self):\nreturn self.name\nQ>KKKMN\nLP\n\n&&\nclass Edge(object):\ndef __init__(self, src, dest):\n\"\"\"Assumes src and dest are nodes\"\"\"\nself.src = src\nself.dest = dest\ndef getSource(self):\nreturn self.src\ndef getDestination(self):\nreturn self.dest\ndef __str__(self):\nreturn self.src.getName() + '->'\\\n+ self.dest.getName()\nQ>KKKMN\nLQ\n\n#!!#\"$%&\"'(#\"&#%$&\n$\".,#$/$.0\".,#\nW \"/,//$)*)$.1*)*)'7\n%)7(0.$6\nW *5/=/*3.)*/\nW *'3()/=/1)1*))*/\nW ''G/<HUL$0#.$/)\".*(/0*\nUK*0#.5$/\nW *00#0$)$\".,#<(0.$6$/\n/7((0.$\n%)7'$/0\nW //*$05$0##)*'$/0*/1)1*))*/\nQ>KKKMN\nLR\n\n&&%$3$%'9\nclass Digraph(object):\n\"\"\"edges is a dict mapping each node to a list of\nits children\"\"\"\ndef __init__(self):\nself.edges = {}\ndef addNode(self, node):\nif node in self.edges:\nraise ValueError('Duplicate node')\nelse:\nself.edges[node] = []\ndef addEdge(self, edge):\nsrc = edge.getSource()\ndest = edge.getDestination()\nif not (src in self.edges and dest in self.edges):\nraise ValueError('Node not in graph')\nself.edges[src].append(dest)\nQ>KKKMN\nLS\nmapping each node\nlist\n\n&&%$3$%':\ndef childrenOf(self, node):\nreturn self.edges[node]\ndef hasNode(self, node):\nreturn node in self.edges\ndef getNode(self, name):\nfor n in self.edges:\nif n.getName() == name:\nreturn n\nraise NameError(name)\ndef __str__(self):\nresult = ''\nfor src in self.edges:\nfor dest in self.edges[src]:\nresult = result + src.getName() + '->'\\\n+ dest.getName() + '\\n'\nreturn result[:-1] #omit final newline\nQ>KKKMN\nLT\n\n&& %$\nclass Graph(Digraph):\ndef addEdge(self, edge):\nDigraph.addEdge(self, edge)\nrev = Edge(edge.getDestination(), edge.getSource())\nDigraph.addEdge(self, rev)\n.,#*/)*0#4$.1*)'$07//*$05$0#)\"\nW \"/''*5,//\"$)$0#.$.1*)\n#7$/.,#/3'//*$\".,#;\n((.0#/3/1031*).3';\nW\n'$)0*5*.&/*..0'73/$)\")$)/0)*0#\n/3,.07,<$0/#*3''/*5*.&*..0'75#))$)/0)*\n0#/307,$//3/1030*.0#$)/0)*0#/3,.07,\n)7,.*\".(0#05*.&/5$0#$\".,#5$'''/*5*.&5$0#\n.,#E30)*0F\nQ>KKKMN\nMK\n\n&& %$$(!0(#\"%# !\n#*.0/0,0#.*()L0*)M\nW #*.0/0/-3)*\"//3#0#0\nW *3.)**./0\"$/)L\nW /1)1*)*'/0\"$/)M\nW *.\"/<L)M<$)0#/-3)<$M*''*5/L$)0#\n/-3)<0#/*3.*M$/0#/1)1*)*L\n#*.0/05$\"#0,0#\nW $)$($80#/3(*0#5$\"#0/*0#\"/$)0#,0#\nQ>KKKMN\nML\n\n#!#%'&''%# !&\n$)$)\".*30.*(*)$070*)*0#.\n/$\")$)\"*((3)$1*))05*.&/\n$)$)\",0#*.(*'3'0#.*3\"##($'\n'7.$)0#\n?\nQ>KKKMN\nMM\n,PDJHVVRXUFHVXQNQRZQ$OOULJKWVUHVHUYHG7KLVFRQWHQWLVH[FOXGHGIURPRXU&UHDWLYH\n&RPPRQVOLFHQVH)RUPRUHLQIRUPDWLRQVHHKWWSVRFZPLWHGXKHOSIDTIDLUXVH\n\n!\n!\n\"\n\"\n# $\n# $\n#%&\n'(\n'(\n'\n'!(\"\n!'\"(\n# $'\n\"'\n\n, ' %$\ndef buildCityGraph(graphType):\ng = graphType()\nfor name in ('Boston', 'Providence', 'New York', 'Chicago',\n'Denver', 'Phoenix', 'Los Angeles'): #Create 7 nodes\ng.addNode(Node(name))\ng.addEdge(Edge(g.getNode('Boston'), g.getNode('Providence')))\ng.addEdge(Edge(g.getNode('Boston'), g.getNode('New York')))\ng.addEdge(Edge(g.getNode('Providence'), g.getNode('Boston')))\ng.addEdge(Edge(g.getNode('Providence'), g.getNode('New York')))\ng.addEdge(Edge(g.getNode('New York'), g.getNode('Chicago')))\ng.addEdge(Edge(g.getNode('Chicago'), g.getNode('Denver')))\ng.addEdge(Edge(g.getNode('Chicago'), g.getNode('Phoenix')))\ng.addEdge(Edge(g.getNode('Denver'), g.getNode('Phoenix')))\ng.addEdge(Edge(g.getNode('Denver'), g.getNode('New York')))\ng.addEdge(Edge(g.getNode('Los Angeles'), g.getNode('Boston')))\nQ>KKKMN\nMO\n\n\"\"'#%'&''\n'\"*.$0#(L<,0#C./0/.#EF\n$($'.0*'!C./0,0#C./0(0#**)3(.1)\"\n/.#0.E03.MF\n$)$.)$/0#0\".,#($\"#0#47'/</*5\n(3/0&,0.&*5#0)*/5#44$/$00*4*$\n\"*$)\"$)$))$0'**,/\nQ>KKKMN\nMP\n*00#05.3/$)\"$4$C)C*)-3.=$5)),0#\n.*(/*3.0*)$)0.($0)*<),0#.*(0#\n$)0.($0)*0*0#/1)1*)<0#*($)1*)$/,0#\n.*(/*3.0*/1)1*)\n\n$'%&'%\n0.00)$)$1')*\n*)/$.''0#\"/0#0'40#0)*<$)/*(\n*..\n*''*50#./0\"<)#&0*/$0\"*')*\n\n)*0<.,00#,.*//.*()5)*\n*)1)33)1'$0#.)\"*')*<*..3)*30*\n*,1*)/\nW #).3)*30**,1*)/<&0.&0*0#,.4$*3/)*\n)0.70#)60\"<.,1)\"0#$/,.*//\nQ>KKKMN\nMQ\n\n$'%&'%78\ndef DFS(graph, start, end, path, shortest, toPrint = False):\npath = path + [start]\nif toPrint:\nprint('Current DFS path:', printPath(path))\nif start == end:\nreturn path\nfor node in graph.childrenOf(start):\nif node not in path: #avoid cycles\nif shortest == None or len(path) < len(shortest):\nnewPath = DFS(graph, node, end, path, shortest, toPrint)\nif newPath != None:\nshortest = newPath\nelif toPrint:\nprint('Already visited', node)\nreturn shortest\ndef shortestPath(graph, start, end, toPrint = False):\nreturn DFS(graph, start, end, [], None, toPrint)\n''.*(\n0/.3./$*)/0.0,.*,.'7\n5.,,.3)1*)=\nshortestPath\n\nQ>KKKMN\nMR\n\n&'\ndef testSP(source, destination):\ng = buildCityGraph(DiGraph)\nsp = shortestPath(g, g.getNode(source), g.getNode(destination)\ntoPrint = True)\nif sp != None:\nprint('Shortest path from', source, 'to',\ndestination, 'is', printPath(sp))\nelse:\nprint('There is no path from', source, 'to', destination)\ntestSP('Boston', 'Chicago')\nQ>KKKMN\nMS\n\n\".!$\nQ>KKKMN\nMT\n*/0*)\n*/0*)\n.*4$)\n.*4$)\n5*.&\n5*.&\n#$\"*\n#$\"*\n)4.\n)4.\n#*)$6\n#*)$6\n*/)\"'/\n*/)\"'/\n%)7$/0\n*/0*)=.*4$)<5*.&\n.*4$)=*/0*)<5*.&\n5*.&=#$\"*\n#$\"*=)4.<#*)$6\n)4.=#*)$6<5*.&\n*/)\"'/=*/0*)\n#*)$6=\n\n,'$,'7#'##&'#\"8\n3..)0,0#=#$\"*\n3..)0,0#=#$\"*CV)4.\n3..)0,0#=#$\"*CV)4.CV#*)$6\n3..)0,0#=#$\"*CV)4.CV5*.&\n'.74$/$0#$\"*\n3..)0,0#=#$\"*CV#*)$6\n#.$/)*,0#.*(#$\"*0**/0*)\nQ>KKKMN\nNK\n*/0*)\n*/0*)\n.*4$)\n.*4$)\n5*.&\n5*.&\n#$\"*\n#$\"*\n)4.\n)4.\n#*)$6\n#*)$6\n*/)\"'/\n*/)\"'/\n\n,'$,'7#&'#\"'##\".8\n3..)0,0#=*/0*)\n3..)0,0#=*/0*)CV.*4$)\n'.74$/$0*/0*)\n3..)0,0#=*/0*)CV.*4$)CV5*.&\n3..)0,0#=*/0*)CV.*4$)CV5*.&CV#$\"*\n3..)0,0#=*/0*)CV.*4$)CV5*.&CV#$\"*CV)4.\n3..)0,0#=*/0*)CV.*4$)CV5*.&CV#$\"*CV)4.CV#*)$6*3),0#\n'.74$/$05*.&\n3..)0,0#=*/0*)CV.*4$)CV5*.&CV#$\"*CV#*)$6*3)/#*.0.,0#\n3..)0,0#=*/0*)CV5*.&\n3..)0,0#=*/0*)CV5*.&CV#$\"*\n3..)0,0#=*/0*)CV5*.&CV#$\"*CV)4.\n3..)0,0#=*/0*)CV5*.&CV#$\"*CV)4.CV#*)$6*3)@/#*.0.A,0#\n'.74$/$05*.&\n3..)0,0#=*/0*)CV5*.&CV#$\"*CV#*)$6*3)/#*.0.,0#\n#*.0/0,0#.*(*/0*)0*#*)$6$/*/0*)CV5*.&CV#$\"*CV)4.CV#*)$6\nQ>KKKMN\nNL\n\n%'%&'%\n0.00)$)$1')*\n*)/$.''0#\"/0#0'40#0)*<$)/*(\n*..\n*''*50#./0\"<)#&0*/$0\"*')*\n\n)*0<0.70#)60\".*(0#3..)0)*\n*)1)33)1'$0#.)\"*')*<*..3)*30*\n*,1*)/\nW #).3)*30*\"*,1*)/<(*40*)60)*0\n/($/0).*(/0.0<).,0\nW #).3)*30*)**,1*)/<(*40*)60'4'$)0#\n\".,#E'')*/*)/0,3.0#..*(/0.0F<).,0\nQ>KKKMN\nNM\n\n#%'!:4%'6%&'%78\ndef BFS(graph, start, end, toPrint = False):\ninitPath = [start]\npathQueue = [initPath]\nwhile len(pathQueue) != 0:\n#Get and remove oldest element in pathQueue\ntmpPath = pathQueue.pop(0)\nif toPrint:\nprint('Current BFS path:', printPath(tmpPath))\nlastNode = tmpPath[-1]\nif lastNode == end:\nreturn tmpPath\nfor nextNode in graph.childrenOf(lastNode):\nif nextNode not in tmpPath:\nnewPath = tmpPath + [nextNode]\npathQueue.append(newPath)\nreturn None\nQ>KKKMN\nNN\n;\n6,'*.'',0#/5$0#)#*,/*.\n6,'*.$)\")7,0#5$0#(*.0#))#*,/\n\n,'$,'7#&'#\"'##\".8\n3..)0,0#=*/0*)\n3..)0,0#=*/0*)CV.*4$)\n3..)0,0#=*/0*)CV5*.&\n3..)0,0#=*/0*)CV.*4$)CV5*.&\n3..)0,0#=*/0*)CV5*.&CV#$\"*\n3..)0,0#=*/0*)CV.*4$)CV5*.&CV#$\"*\n3..)0,0#=*/0*)CV5*.&CV#$\"*CV)4.\n3..)0,0#=*/0*)CV5*.&CV#$\"*CV#*)$6\n#*.0/0,0#.*(*/0*)0*#*)$6$/*/0*)CV5*.&CV#$\"*CV#*)$6\nQ>KKKMN\nNO\n\n3..)0,0#=*/0*)\n3..)0,0#=*/0*)CV.*4$)\n3..)0,0#=*/0*)CV5*.&\n3..)0,0#=*/0*)CV.*4$)CV5*.&\n3..)0,0#=*/0*)CV5*.&CV#$\"*\n3..)0,0#=*/0*)CV.*4$)CV5*.&CV#$\"*\n3..)0,0#=*/0*)CV5*.&CV#$\"*CV)4.\n3..)0,0#=*/0*)CV5*.&CV#$\"*CV#*)$6\n#*.0/0,0#.*(*/0*)0*#*)$6$/*/0*)CV5*.&CV#$\"*CV#*)$6\n*/0*)\n*/0*)\n.*4$)\n.*4$)\n5*.&\n5*.&\n#$\"*\n#$\"*\n)4.\n)4.\n#*)$6\n#*)$6\n*/)\"'/\n*/)\"'/\n,'$,'7#&'#\"'##\".8\nQ>KKKMN\nNP\n*00#05\n/&$,,0#\n0#0.4$/$0/\n)*\n\n'#,''#%'&''\n)00*($)$($80#/3(*0#5$\"#0/*0#\"/<\n)*00#)3(.*\"/\n)/$'7(*$0**0#$/\n))*0</$)/#*.0/05$\"#0,0#(7#4\n(*.0#)0#($)$(3()3(.*#*,/\nQ>KKKMN\nNQ\n\n$\n.,#/.**'\nW /0570*.0(*'*()70#$)\"/\nW ,03..'1*)/#$,/(*)\"*%0/\nW )7$(,*.0)0,.*'(/),*//\".,#\n*,1($81*),.*'(/5'.7&)*5#*50*/*'4\n,0#C./0).0#C./0/.#.$(,*.0)0\n'\"*.$0#(/\nW )3/0*/*'4()7,.*'(/\nQ>KKKMN\nNR\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0002 Introduction to Computational Thinking and Data Science\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Notes",
      "title": "Lecture 4: Stochastic Thinking",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/5b4ec0ef29910b74e6a4bbd5ccf4dda5_MIT6_0002F16_lec4.pdf",
      "content": "Lecture 4: Stochastic\nThinking and Random\nWalks\nςϬϬϬϮ [GĐƚƵƌG κ\n\nRelevant Reading\n*Pages 235-238\n*Chapter 14\n6.0002 LECTURE 4\n\nThe World is Hard to Understand\n*Uncertainty is uncomfortable\n*But certainty is usually unjustified\n6.0002 LECTURE 4\n\nNewtonian Mechanics\n*Every effect has a cause\n*The world can be understood causally\n6.0002 LECTURE 4\n\nCopenhagen Doctrine\n*Copenhagen Doctrine (Bohr and Heisenberg) of causal\nnondeterminism\n* At its most fundamental level, the behavior of the\nphysical world cannot be predicted.\n* Fine to make statements of the form \"x is highly likely to\n* occur,\" but not of the form \"x is certain to occur.\"\n*Einstein and Schrodinger objected\n* \"God does not play dice.\" -- Albert Einstein\n6.0002 LECTURE 4\n\nDoes It Really Matter\nDid the flips yield\n2 heads\n2 tails\n1 head and 1 tail?\n6.0002 LECTURE 4\nς\n\nThe Moral\n*The world may or may not be\ninherently unpredictable\n*But our lack of knowledge does\nnot allow us to make accurate\npredictions\n*Therefore we might as well treat\nthe world as inherently\nunpredictable\n*Predictive nondeterminism\n6.0002 LECTURE 4\n\nStochastic Processes\n*An ongoing process where the next state might depend on\nboth the previous states and some random element\ndef rollDie():\n\"\"\" returns an int between 1 and 6\"\"\"\ndef rollDie():\n\"\"\" returns a randomly chosen int\nbetween 1 and 6\"\"\"\n6.0002 LECTURE 4\n\nImplementing a Random Process\nimport random\ndef rollDie():\n\"\"\"returns a random int between 1 and 6\"\"\"\nreturn random.choice([1,2,3,4,5,6])\ndef testRoll(n = 10):\nresult = ''\nfor i in range(n):\nresult = result + str(rollDie())\nprint(result)\n6.0002 LECTURE 4\n\nProbability of Various Results\n*Consider testRoll(5)\n*How probable is the output 11111?\n6.0002 LECTURE 4\n\nProbability Is About Counting\n*Count the number of possible events\n*Count the number of events that have the property of\ninterest\n*Divide one by the other\n*Probability of 11111?\n* 11111, 11112, 11113, /, 11121, 11122, /, 66666\n* 1/(6**5)\n* ~0.0001286\n6.0002 LECTURE 4\n\nThree Basic Facts About Probability\n*Probabilities are always in the range 0 to 1. 0 if\nimpossible, and 1 if guaranteed.\n*If the probability of an event occurring is p, the\nprobability of it not occurring must be\n*When events are independent of each other, the\nprobability of all of the events occurring is equal to a\nproduct of the probabilities of each of the events\noccurring.\n6.0002 LECTURE 4\n\nIndependence\n*Two events are independent if the outcome of one\nevent has no influence on the outcome of the other\n*Independence should not be taken for granted\n6.0002 LECTURE 4\n\nWill One of the Patriots and Broncos Lose?\n*Patriots have winning percentage of 7/8, Broncos of\n6/8\n*Probability of both winning next Sunday is 7/8 * 6/8 =\n42/64\n*Probability of at least one losing is 1 - 42/64 = 22/64\n*What about Sunday, December 18\n* Outcomes are not independent\n* Probability of one of them losing is much closer to 1 than\nto 22/64!\n6.0002 LECTURE 4\n\nA Simulation of Die Rolling\ndef runSim(goal, numTrials, txt):\ntotal = 0\nfor i in range(numTrials):\nresult = ''\nfor j in range(len(goal)):\nresult += str(rollDie())\nif result == goal:\ntotal += 1\nprint('Actual probability of', txt, '=',\nround(1/(6**len(goal)), 8))\nestProbability = round(total/numTrials, 8)\nprint('Estimated Probability of', txt, '=',\nround(estProbability, 8))\nrunSim('11111', 1000, '11111')\n6.0002 LECTURE 4\n\nOutput of Simulation\n*Actual probability = 0.0001286\n*Estimated Probability = 0.0\n*Actual probability = 0.0001286\n*Estimated Probability = 0.0\n*How did I know that this is what would get printed?\n*Why did simulation give me the wrong answer?\nLet's try 1,000,000 trials\n6.0002 LECTURE 4\n\nMorals\n*Moral 1: It takes a lot of trials to get a good estimate\nof the frequency of occurrence of a rare event. We'll\ntalk lots more in later lectures about how to know\nwhen we have enough trials.\n*Moral 2: One should not confuse the sample\nprobability with the actual probability\n*Moral 3: There was really no need to do this by\nsimulation, since there is a perfectly good closed form\nanswer. We will see many examples where this is not\ntrue.\n*But simulations are often useful.\n6.0002 LECTURE 4\n\nThe Birthday Problem\n*What's the probability of at least two people in a\ngroup having the same birthday\n*If there are 367 people in the group?\n*What about smaller numbers?\n*If we assume that each birthdate is equally likely\n366!\n* 1\n*\n366N∗ 366-N !\nWithout this assumption, VERY complicated\nshoutkey.com/niece\n6.0002 LECTURE 4\n\nApproximating Using a Simulation\ndef sameDate(numPeople, numSame):\npossibleDates = range(366)\nbirthdays = [0]*366\nfor p in range(numPeople):\nbirthDate = random.choice(possibleDates)\nbirthdays[birthDate] += 1\nreturn max(birthdays) >= numSame\n6.0002 LECTURE 4\n\nApproximating Using a Simulation\ndef birthdayProb(numPeople, numSame, numTrials):\nnumHits = 0\nfor t in range(numTrials):\nif sameDate(numPeople, numSame):\nnumHits += 1\nreturn numHits/numTrials\nfor numPeople in [10, 20, 40, 100]:\nprint('For', numPeople,\n'est. prob. of a shared birthday is',\nbirthdayProb(numPeople, 2, 10000))\nnumerator = math.factorial(366)\ndenom = (366**numPeople)*math.factorial(366-numPeople)\nprint('Actual prob. for N = 100 =',\n1 - numerator/denom)\nSuppose we want the probability of 3 people sharing\n6.0002 LECTURE 4\n\nWhy 3 Is Much Harder Mathematically\n*For 2 the complementary problem is \"all birthdays\ndistinct\"\n*For 3 people, the complementary problem is a\ncomplicated disjunct\n* All birthdays distinct or\n* One pair and rest distinct or\n* Two pairs and rest distinct or\n*/\n*But changing the simulation is dead easy\n6.0002 LECTURE 4\n\nBut All Dates Are Not Equally Likely\nAre you exceptional?\n6.0002 LECTURE 4\nChart\nChart (c) Matt Stiles / The Daily Viz. All rights reserved. This content is excluded from our\nCreative Commons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\n\nAnother Win for Simulation\n*Adjusting analytic model a pain\n*Adjusting simulation model easy\ndef sameDate(numPeople, numSame):\npossibleDates = 4*list(range(0, 57)) + [58]\\\n+ 4*list(range(59, 366))\\\n+ 4*list(range(180, 270))\nbirthdays = [0]*366\nfor p in range(numPeople):\nbirthDate = random.choice(possibleDates)\nbirthdays[birthDate] += 1\nreturn max(birthdays) >= numSame\n6.0002 LECTURE 4\n\nSimulation Models\n*A description of computations that provide useful\ninformation about the possible behaviors of the system\nbeing modeled\n*Descriptive, not prescriptive\n*Only an approximation to reality\n*\"All models are wrong, but some are useful.\" - George Box\n6.0002 LECTURE 4\n\nSimulations Are Used a Lot\n*To model systems that are mathematically intractable\n*To extract useful intermediate results\n*Lend themselves to development by successive\nrefinement and \"what if\" questions\n*Start by simulating random walks\n6.0002 LECTURE 4\n\nWhy Random Walks?\n*Random walks are important in many\ndomains\n*Understanding the stock market (maybe)\n*Modeling diffusion processes\n*Etc.\n*Good illustration of how to use\nsimulations to understand things\n*Excuse to cover some important\nprogramming topics\n*Practice with classes\n*More about plotting\n6.0002 LECTURE 4\n\nBrownian Motion Is a Random Walk\nRobert\nBrown\nLouis\nBachelier\nAlbert\nEinstein\n6.0002 LECTURE 4\nImages of Robert Brown and Albert Einstein are in the public domain. Image of Louis\nBachelier (c) unknown. All rights reserved. This content is excluded from our Creative\nCommons license. For more information, see https://ocw.mit.edu/help/faq-fair-use/.\n\nDrunkard's Walk\n6.0002 LECTURE 4\n\nOne Possible First Step\n6.0002 LECTURE 4\n\nAnother Possible First Step\n6.0002 LECTURE 4\n\nYet Another Possible First Step\n6.0002 LECTURE 4\n\nLast Possible First Step\n6.0002 LECTURE 4\n\nPossible Distances After Two Steps\n6.0002 LECTURE 4\nImage of Pythagoras (c) unknown. All rights reserved. This\ncontent is excluded from our Creative Commons license. For\nmore information, see https://ocw.mit.edu/help/faq-fair-use/ .\n\nExpected Distance After 100,000 Steps?\n*Need a different approach to problem\n*Will use simulation\n*But not until the next lecture\n6.0002 LECTURE 4\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0002 Introduction to Computational Thinking and Data Science\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Lecture Code",
      "title": "lecture4.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/db2474b48192b9a6ccb78c2e5bf75ca0_lecture4.py",
      "content": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Aug 20 11:09:36 2016\n\n@author: guttag\n\"\"\"\nimport random\n\ndef rollDie():\n\"\"\"returns a random int between 1 and 6\"\"\"\nreturn random.choice([1,2,3,4,5,6])\n\ndef testRoll(n = 10):\nresult = ''\nfor i in range(n):\nresult = result + str(rollDie())\nprint(result)\n\n#testRoll(5)\n\nrandom.seed(0)\n\ndef runSim(goal, numTrials, txt):\ntotal = 0\nfor i in range(numTrials):\nresult = ''\nfor j in range(len(goal)):\nresult += str(rollDie())\nif result == goal:\ntotal += 1\nprint('Actual probability of', txt, '=',\nround(1/(6**len(goal)), 8))\nestProbability = round(total/numTrials, 8)\nprint('Estimated Probability of', txt, '=',\nround(estProbability, 8))\n\n#runSim('11111', 1000, '11111')\n\ndef sameDate(numPeople, numSame):\npossibleDates = range(366)\n# possibleDates = 4*list(range(0, 57)) + [58]\\\n# + 4*list(range(59, 366))\\\n# + 4*list(range(180, 270))\nbirthdays = [0]*366\nfor p in range(numPeople):\nbirthDate = random.choice(possibleDates)\nbirthdays[birthDate] += 1\nreturn max(birthdays) >= numSame\n\ndef birthdayProb(numPeople, numSame, numTrials):\nnumHits = 0\nfor t in range(numTrials):\nif sameDate(numPeople, numSame):\nnumHits += 1\nreturn numHits/numTrials\n\nimport math\n\nfor numPeople in [10, 20, 40, 100]:\nprint('For', numPeople,\n'est. prob. of a shared birthday is',\nbirthdayProb(numPeople, 2, 10000))\nnumerator = math.factorial(366)\ndenom = (366**numPeople)*math.factorial(366-numPeople)\nprint('Actual prob. for N = 100 =',\n1 - numerator/denom)"
    },
    {
      "category": "Lecture Code",
      "title": "lect5.py",
      "type": "PY",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/781613585ae543f26ad6dc040be4a312_lect5.py",
      "content": "import random, pylab\n\n#set line width\npylab.rcParams['lines.linewidth'] = 4\n#set font size for titles\npylab.rcParams['axes.titlesize'] = 20\n#set font size for labels on axes\npylab.rcParams['axes.labelsize'] = 20\n#set size of numbers on x-axis\npylab.rcParams['xtick.labelsize'] = 16\n#set size of numbers on y-axis\npylab.rcParams['ytick.labelsize'] = 16\n#set size of ticks on x-axis\npylab.rcParams['xtick.major.size'] = 7\n#set size of ticks on y-axis\npylab.rcParams['ytick.major.size'] = 7\n#set size of markers, e.g., circles representing points\n#set numpoints for legend\npylab.rcParams['legend.numpoints'] = 1\n\nclass Location(object):\ndef __init__(self, x, y):\n\"\"\"x and y are numbers\"\"\"\nself.x = x\nself.y = y\n\ndef move(self, deltaX, deltaY):\n\"\"\"deltaX and deltaY are numbers\"\"\"\nreturn Location(self.x + deltaX, self.y + deltaY)\n\ndef getX(self):\nreturn self.x\n\ndef getY(self):\nreturn self.y\n\ndef distFrom(self, other):\nxDist = self.x - other.getX()\nyDist = self.y - other.getY()\nreturn (xDist**2 + yDist**2)**0.5\n\ndef __str__(self):\nreturn '<' + str(self.x) + ', ' + str(self.y) + '>'\n\nclass Field(object):\ndef __init__(self):\nself.drunks = {}\n\ndef addDrunk(self, drunk, loc):\nif drunk in self.drunks:\nraise ValueError('Duplicate drunk')\nelse:\nself.drunks[drunk] = loc\n\ndef moveDrunk(self, drunk):\nif drunk not in self.drunks:\nraise ValueError('Drunk not in field')\nxDist, yDist = drunk.takeStep()\n#use move method of Location to get new location\nself.drunks[drunk] =\\\nself.drunks[drunk].move(xDist, yDist)\n\ndef getLoc(self, drunk):\nif drunk not in self.drunks:\nraise ValueError('Drunk not in field')\nreturn self.drunks[drunk]\n\nclass Drunk(object):\ndef __init__(self, name = None):\n\"\"\"Assumes name is a str\"\"\"\nself.name = name\n\ndef __str__(self):\nif self != None:\nreturn self.name\nreturn 'Anonymous'\n\nclass UsualDrunk(Drunk):\ndef takeStep(self):\nstepChoices = [(0,1), (0,-1), (1, 0), (-1, 0)]\nreturn random.choice(stepChoices)\n\nclass MasochistDrunk(Drunk):\ndef takeStep(self):\nstepChoices = [(0.0,1.1), (0.0,-0.9),\n(1.0, 0.0), (-1.0, 0.0)]\nreturn random.choice(stepChoices)\n\ndef walk(f, d, numSteps):\n\"\"\"Assumes: f a Field, d a Drunk in f, and numSteps an int >= 0.\nMoves d numSteps times, and returns the distance between\nthe final location and the location at the start of the\nwalk.\"\"\"\nstart = f.getLoc(d)\nfor s in range(numSteps):\nf.moveDrunk(d)\nreturn start.distFrom(f.getLoc(d))\n\ndef simWalks(numSteps, numTrials, dClass):\n\"\"\"Assumes numSteps an int >= 0, numTrials an int > 0,\ndClass a subclass of Drunk\nSimulates numTrials walks of numSteps steps each.\nReturns a list of the final distances for each trial\"\"\"\nHomer = dClass('Homer')\norigin = Location(0, 0)\ndistances = []\nfor t in range(numTrials):\nf = Field()\nf.addDrunk(Homer, origin)\ndistances.append(round(walk(f, Homer,\nnumTrials), 1))\nreturn distances\n\ndef drunkTest(walkLengths, numTrials, dClass):\n\"\"\"Assumes walkLengths a sequence of ints >= 0\nnumTrials an int > 0, dClass a subclass of Drunk\nFor each number of steps in walkLengths, runs simWalks with\nnumTrials walks and prints results\"\"\"\nfor numSteps in walkLengths:\ndistances = simWalks(numSteps, numTrials, dClass)\nprint(dClass.__name__, 'random walk of', numSteps, 'steps')\nprint(' Mean =', round(sum(distances)/len(distances), 4))\nprint(' Max =', max(distances), 'Min =', min(distances))\n\nrandom.seed(0)\ndrunkTest((10, 100, 1000, 10000), 100, UsualDrunk)\n#\ndef simAll(drunkKinds, walkLengths, numTrials):\nfor dClass in drunkKinds:\ndrunkTest(walkLengths, numTrials, dClass)\n\n#random.seed(0)\n#simAll((UsualDrunk, MasochistDrunk),\n# (1000, 10000), 100)\n#\n#xVals = [1, 2, 3, 4]\n#yVals1 = [1, 2, 3, 4]\n#pylab.plot(xVals, yVals1, 'b-', label = 'first')\n#yVals2 = [1, 7, 3, 5]\n#pylab.plot(xVals, yVals2, 'r--', label = 'second')\n#pylab.legend()\n\nclass styleIterator(object):\ndef __init__(self, styles):\nself.index = 0\nself.styles = styles\n\ndef nextStyle(self):\nresult = self.styles[self.index]\nif self.index == len(self.styles) - 1:\nself.index = 0\nelse:\nself.index += 1\nreturn result\n\ndef simDrunk(numTrials, dClass, walkLengths):\nmeanDistances = []\nfor numSteps in walkLengths:\nprint('Starting simulation of',\nnumSteps, 'steps')\ntrials = simWalks(numSteps, numTrials, dClass)\nmean = sum(trials)/len(trials)\nmeanDistances.append(mean)\nreturn meanDistances\n\ndef simAll(drunkKinds, walkLengths, numTrials):\nstyleChoice = styleIterator(('m-', 'b--', 'g-.'))\nfor dClass in drunkKinds:\ncurStyle = styleChoice.nextStyle()\nprint('Starting simulation of', dClass.__name__)\nmeans = simDrunk(numTrials, dClass, walkLengths)\npylab.plot(walkLengths, means, curStyle,\nlabel = dClass.__name__)\npylab.title('Mean Distance from Origin ('\n+ str(numTrials) + ' trials)')\npylab.xlabel('Number of Steps')\npylab.ylabel('Distance from Origin')\npylab.legend(loc = 'best')\n\n#random.seed(0)\n#numSteps = (10,100,1000,10000,100000)\n#simAll((UsualDrunk, MasochistDrunk), numSteps, 100)\n#\n#pylab.plot(numSteps, pylab.array(numSteps)**0.5, 'k-.',\n# label = 'Square root of steps')\n#pylab.plot(numSteps, pylab.array(numSteps)*0.05, 'g-.',\n# label = 'numSteps*0.05')\n#pylab.legend(loc = 'best')\n\ndef getFinalLocs(numSteps, numTrials, dClass):\nlocs = []\nd = dClass()\nfor t in range(numTrials):\nf = OddField()\nf.addDrunk(d, Location(0, 0))\nfor s in range(numSteps):\nf.moveDrunk(d)\nlocs.append(f.getLoc(d))\nreturn locs\n\ndef plotLocs(drunkKinds, numSteps, numTrials):\nstyleChoice = styleIterator(('k+', 'r^', 'mo'))\nfor dClass in drunkKinds:\nlocs = getFinalLocs(numSteps, numTrials, dClass)\nxVals, yVals = [], []\nfor loc in locs:\nxVals.append(loc.getX())\nyVals.append(loc.getY())\nxVals = pylab.array(xVals)\nyVals = pylab.array(yVals)\nmeanX = sum(abs(xVals))/len(xVals)\nmeanY = sum(abs(yVals))/len(yVals)\ncurStyle = styleChoice.nextStyle()\npylab.plot(xVals, yVals, curStyle,\nlabel = dClass.__name__ +\\\n' mean abs dist = <'\n+ str(meanX) + ', ' + str(meanY) + '>')\npylab.title('Location at End of Walks ('\n+ str(numSteps) + ' steps)')\npylab.ylim(-1000, 1000)\npylab.xlim(-1000, 1000)\npylab.xlabel('Steps East/West of Origin')\npylab.ylabel('Steps North/South of Origin')\npylab.legend(loc = 'lower center')\n\n#random.seed(0)\n#plotLocs((UsualDrunk, MasochistDrunk), 10000, 1000)\n\nclass OddField(Field):\ndef __init__(self, numHoles = 1000,\nxRange = 100, yRange = 100):\nField.__init__(self)\nself.wormholes = {}\nfor w in range(numHoles):\nx = random.randint(-xRange, xRange)\ny = random.randint(-yRange, yRange)\nnewX = random.randint(-xRange, xRange)\nnewY = random.randint(-yRange, yRange)\nnewLoc = Location(newX, newY)\nself.wormholes[(x, y)] = newLoc\n\ndef moveDrunk(self, drunk):\nField.moveDrunk(self, drunk)\nx = self.drunks[drunk].getX()\ny = self.drunks[drunk].getY()\nif (x, y) in self.wormholes:\nself.drunks[drunk] = self.wormholes[(x, y)]\n\n#TraceWalk using oddField\ndef traceWalk(fieldKinds, numSteps):\nstyleChoice = styleIterator(('b+', 'r^', 'ko'))\nfor fClass in fieldKinds:\nd = UsualDrunk()\nf = fClass()\nf.addDrunk(d, Location(0, 0))\nlocs = []\nfor s in range(numSteps):\nf.moveDrunk(d)\nlocs.append(f.getLoc(d))\nxVals, yVals = [], []\nfor loc in locs:\nxVals.append(loc.getX())\nyVals.append(loc.getY())\ncurStyle = styleChoice.nextStyle()\npylab.plot(xVals, yVals, curStyle,\nlabel = fClass.__name__)\npylab.title('Spots Visited on Walk ('\n+ str(numSteps) + ' steps)')\npylab.xlabel('Steps East/West of Origin')\npylab.ylabel('Steps North/South of Origin')\npylab.legend(loc = 'best')\n\n#random.seed(0)\n#traceWalk((Field, OddField), 500)"
    },
    {
      "category": "Resource",
      "title": "Python Resources",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/fe35c52e0a1b481f9775846d392e766d_MIT6_0002F16_PythonResurcs.pdf",
      "content": "Additional Python Resources\nIf you're having trouble with a particular concept or simply want to have access to more\ninformation, try one of the following links.\n\nDOCUMENTATION\n-\nOfficial Python 3 Documentation - \"official\"/technical explanation of what a particular function/operator\ndoes, examples of correct syntax, what the various libraries are, etc.\n\nTEXTBOOKS/TUTORIALS\n-\nDive Into Python - another survey of Python syntax, datatypes, etc.\n-\nThink Python by Allen Downey - a good general overview of the Python language. Includes exercises.\n-\nThe Official Python Tutorial - self-explanatory\n-\nLearn Python the Hard Way - (note: for Python 2) another free online text\n-\nReserved Keywords in Python - don't use these as variable names\n-\nPEP 8 - Style Guide for Python Code - learn what is good and bad style in Python\n-\nCheckIO - learn Python by exploring a game world\n-\nInvent with Python - develop your Python skills by making games or hacking ciphers\n-\nCodecademy - (note: for Python 2) learn Python by building web apps and manipulating data; interactive\ntutorial sequence\n-\nPython Tutor - interactive tutorial sequence of exercises\n\nDEBUGGING\n-\nPython Tutor - an excellent way to actually visualize how the interpreter actually reads and executes\nyour code\n-\nDiffChecker - compares two sets of text and shows you which lines are different\n-\nDebugging in Python - steps you can take to try to debug your program\n\nSOFTWARE\n-\nPython Tools for Visual Studio - Visual Studio plug-in enabling Python programming\n\nOTHER Q&A\n-\nStack Overflow - a large Q&A forum for programming concepts (not just Python). Try searching here\nbefore you post on the edX forum, and you may find that someone has already answered your question.\n\nMORE PRACTICE PROBLEMS\n-\nPython Challenge - a series of puzzles you can try to test your Python abilities\n-\nProject Euler - additional programming challenges you can try once your Python knowledge becomes\nstronger; problems are sorted by increasing difficulty\n-\nCoding Bat - problems you can solve within an online interpreter\n-\nCodewars - improve your skills by training on real code challenges\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0002 Introduction to Computational Thinking and Data Science\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    },
    {
      "category": "Resource",
      "title": "Style Guide",
      "type": "PDF",
      "source_url": "https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/1495604204e8f00c8b1e423f83395180_MIT6_0002F16_StyleGuide.pdf",
      "content": "Table of Contents:\n1. Integers and floats\n2. for vs. while loops\n3. Checking boolean conditions with if/else\n4. Docstrings\n5. Changing collections while iterating over them\n6. Directly Accessing Instance Variables\n7. Calling a superclass constructor from a subclass\n8. Pitfalls of storing custom objects in data structures\n9. Which data structure should I use?\n1. Integers and floats\nBe careful when deciding whether to represent data as integers or floats, and be sure that you\nconsider all possible behaviors in computation.\nFor a detailed explanation of how Python represents floats, read Section 3.4 (pp. 29-31) of\nyour textbook. In short, floats are represented as factors of powers of two, and many decimal\nnumbers cannot be exactly represented in this manner. The most common problem you'll find\nis trying to check for equality with a floating point number that you are changing. Say that you\nhave a while loop that increments a float by 0.1, and you want this whole loop to continue until\na control variable equals 0.3. You might find that setting up your loop in the following manner\nproduces an infinite loop:\nvariable = 0.0\nwhile variable != 0.3:\nvariable += 0.1\nThat's because 0.1+0.1+0.1 is not equal to 0.3. 0.1 cannot be precisely represented as a\nfloating point number, so 0.1+0.1+0.1 = 0.30000000000000004. When you are trying to take\nsimple counts of elements, always use integers to avoid this type of problem.\nAdditionally, make sure that you typecast between floats and integers at the appropriate time.\nIf you want to do integer division of 3 over 5, writing float(3/5) won't produce the desired result.\nRemember that Python evaluates inner expressions first, so your code will actually do integer\ndivision of 3/5, then cast the result to a float. Instead, you should cast one (or both) of the\nintegers to a float before doing the division - in this case, float(3)/5 or 3/float(5). You'll usually\nrun into this problem when taking averages or calculating percentages.\n2. for vs. while loops\nChoosing the right loop type makes your code more legible and can also help prevent bugs.\nEverything that can be written with a for loop can be written with a while loop, but while loops\ncan solve some problems that for loops don't address easily. You should usually write for loops\n\nwhen possible.\nIn general, use for loops when you know the number of iterations you need to do - e.g., 500\ntrials, one operation per character in a string, or an action on every element in a list. If you can\ndescribe the problem you're trying to solve in terms of each or every element in an iterable\nobject, aim for a for loop. Using a for loop when possible will decrease the risk of writing an\ninfinite loop and will generally prevent you from running into errors with incrementing counter\nvariables.\nExample (print \"hello\" 500 times):\nfor i in xrange(500):\nprint 'hello'\nExample (add 1 to every element in the list):\nmy_list = [5, 2, 7, -4, 0]\nfor i in xrange(len(my_list)):\nmy_list[i] += 1\nIf you're instead iterating for a certain condition to be satisfied, you want to use a while loop.\nWhile loops are useful when you can define the number of iterations in terms of a boolean\nvariable. If you are waiting for a user to enter an input correctly or are waiting for a randomly\ngenerated value to exceed a certain amount, you'll want to use a while loop. Problems that can\nbe described using \"until\" should use while loops.\nExample (loop until the user enters a positive number):\nnum = float(raw_input('Enter a positive number: '))\nwhile num <= 0.0:\nnum = float(raw_input('Enter a POSITIVE number: '))\nExample (loop until the randomly generated number is greater than 0.5):\nimport random\nnum = random.random()\nwhile num <= 0.5:\nnum = random.random()\nTo improve the average-case performance of your code, you can sometimes exit out of loops as\nsoon as you find your answer; you'll find many loops that are used to find True/False answers\nfollow this pattern. For example, say you want to check whether any value in a list is great than\n5:\nmy_list = [1,2,3,4,5,6,7,8]\ngreater_than_five = False\nfor elem in my_list:\nif elem > 5:\n\ngreater_than_five = True\nbreak\n3. Checking boolean conditions with if/else\nOften, people have a tendency to be overly verbose. Observe the following example:\nif my_function() == True: # my_function returns True or False\nreturn True\nelse:\nreturn False\nWhen Python evaluates my_function(), the code is reduced to the following (let's pretend it\nreturned True):\nif True == True: # my_function returns True or False\nreturn True\nelse:\nreturn False\nThis seems repetitive, doesn't it? We know that True is equal to True, and False is not. So,\ninstead of keeping that == True around, we could just have the function call inside the if\nstatement:\n\nif my_function(): # my_function returns True or False\nreturn True\nelse:\nreturn False\nThere is an important point to note here. Since my_function() is going to be a boolean,\nand we're effectively returning the value of that boolean, there's no reason not to just return the\nboolean itself:\nreturn my_function() # my_function returns True or False\nThis is nice and concise, but what if we want to return True if my_function returns False,\nand False when it returns True? There's a Python keyword for that! So, imagine our code\nstarts as:\nif my_function() == True: # my_function returns True or False\nreturn False\nelse:\nreturn True\n\nWe can use not to write this as:\nreturn not my_function() # my_function returns True or False\n4. Docstrings\nWhen writing new classes and functions, it is important to document your intent by using\ndocstrings. For instance, in pset 5, since there were a lot of new classes to implement, adding a\ndocstring explaining the purpose of each class is a good idea.\nEven something as simple as:\nclass TitleTrigger(WordTrigger):\n\"\"\"\nSubclass of WordTrigger that represents a Trigger which checks\nif the story's title matches a given word.\n\"\"\"\netc.\nIncluding a docstring means the specification you've written can be accessed by those who try\nto create an instance of your class. For example, if you change your TitleTrigger class definition\nto the above, run the file, then type the following at the interpreter:\n>>> TitleTrigger(\nYou will see your docstring pop up. :)\n5. Changing collections while iterating over them\nWe've mentioned that it's poor practice to modify a collection while iterating over it. This is\nbecause the behavior resulting from modification during iteration is ambiguous. The for\nstatement maintains an internal index, which is incremented for each loop iteration. If you\nmodify the list you're looping over, the indices will get out of sync, and you may end up skipping\nover items or processing the same item multiple times.\nLet's look at a couple of examples:\nelems = ['a', 'b', 'c']\nfor e in elems:\nprint e\nelems.remove(e)\nThis prints:\na\nc\nMeanwhile, if we look at what elems now contains, we see the following:\n>>> elems\n['b']\n\nWhy does this happen? Let's look at this code rewritten using a while loop.\nelems = ['a', 'b', 'c']\ni = 0\nwhile i < len(elems):\ne = elems[i]\nprint e\nelems.remove(e)\ni += 1\nThis code has the same result. Now it's clear what's happening: when you remove the 'a' from\nelems, the remaining elements slide down the list. The list is now ['b', 'c']. Now 'b' is at index 0,\nand 'c' is at index 1. Since the next iteration is going to look at index 1 (which is the 'c' element),\nthe 'b' gets skipped entirely! This is not what the programmer intended at all!\nLet's take a look at another example. Instead of removing from the list, we are now adding\nelements to it. What happens in the following piece of code?\nfor e in elems:\nprint e\nelems.append(e)\nWe might expect the list elems to be ['a', 'b', 'c', 'a', 'b', 'c'] at the end of\nexecution. However, instead, we get an infinite loop as we keep adding new items to the elems\nlist while iterating. Oops!\nTo work around this kind of issue, you can loop over a copy of the list. For instance, in the\nfollowing code snippets, we wish to retain all the elements of the list the meet some condition.\nelems_copy = elems[:]\nfor item in elems_copy:\nif not condition:\nelems.remove(item)\nelems will contain the desired items.\nAlternatively, you can create a new list, and append to it:\nelems_copy = []\nfor item in elems:\nif condition:\nelems_copy.append(object)\nelems_copy will now contain the desired items.\nNote that the same rule applies to the set and dict types; however, mutating a set or dictionary\nwhile iterating over it will actually raise a RuntimeError -- in this way, Python explicitly prevents\nthis.\n6. Directly Accessing Instance Variables\n\nThis can be a problem because it breaks the interface your class provides to the Abstract\nData Type. Here is an example of this, as a line of code you might write for something like\nTitleTrigger.evaluate in pset 5:\ntitle = story.title # evil\nThis is bad because it means that the instance variable for the title in NewsStory had to\nbe stored as self.title for this to work. However, the programmer writing NewsStory\n(yes, that's you, too) might not have stored it as self.title, because maybe he/she/\nyou preferred self.t, or self.my_story_title, or maybe the 1st element of the\nlist self.story_attributes, or anything else. In fact, the only promise made about\nNewsStory is that there is a constructor that takes in some elements of a story (guid, title, etc.),\nand there is a getter method for each of these properties.\nSo, the safer way to do this? Use getter methods!\ntitle = story.get_title() # much better!\n7. Calling a superclass constructor from a subclass\nFor a subclass that extends the functionality of a superclass (e.g. ResistantVirus and\nSimpleVirus in pset 7), always reuse the functionality of the superclass instead of rewriting it.\nThis goes back to the concept that we should avoid repeated code.\nSay we have the following constructor for the SimpleVirus class:\nclass SimpleVirus(object):\ndef __init__(self, maxBirthProb, clearProb):\nself.maxBirthProb = maxBirthProb\nself.clearProb = clearProb\n...\nWhen we define the ResistantVirus class, we could just repeat the two lines of code contained\nin the constructor as in the below code snippet:\n# Method 1\nclass ResistantVirus(SimpleVirus):\ndef __init__(self, maxBirthProb, clearProb, resistances, mutProb):\nself.maxBirthProb = maxBirthProb\nself.clearProb = clearProb\nself.resistances = resistances\nself.mutProb = mutProb\n...\n\nAlternatively, we could make use of inheritance and call the superclass constructor on the first\ntwo parameters since this would have the same effect.\n# Method 2\nclass ResistantVirus(SimpleVirus):\ndef __init__(self, maxBirthProb, clearProb, resistances, mutProb):\n# Always call the superclass constructor as the first line of\n# the subclass constructor.\nSimpleVirus.__init__(self, maxBirthProb, clearProb)\nself.resistances = resistances\nself.mutProb = mutProb\n...\nMethod 2 is superior to Method 1 in that we prevent ourselves from repeating the code\nthat initializes the variables self.maxBirthProb and self.clearProb. Why is this so\nimportant?\nSay for some reason, while implementing Method 1, we decided to call the maximum\nbirth probability in the ResistantVirus class self.maximumBirthProb instead of\nself.maxBirthProb. In Python, the superclass constructor is not automatically\ncalled when constructing a subclass instance. Now, in all of the superclass methods\nthat reference self.maxBirthProb, we will get an error because it only exists as\nself.maximumBirthProb.\nAnother reason to use Method 2 is that the superclass constructor may do some other, more\ncomplicated initialization and we want to ensure that it is executed.\n8. Pitfalls of storing custom objects in data structures\nSome people tried to store Position objects in their data structure of clean tiles, writing code\nsuch as the following:\ndef isTileCleaned(self, m, n):\nnewPosition = Position(m, n)\nreturn newPosition in self.cleanTileList\nThis code will always return False, even if the tile at (m, n) is clean. The reason why this is\nproblematic gets into the internals of how objects are compared for equality in Python.\nHow does Python compare objects for equality? Well, for primitives like integers, it's pretty\nsimple -- just see if the two numbers have the same value. Similarly, for strings, check if the\ncharacters at each position in the string are the same.\nWhenever we create a new class from scratch in Python, what is the default way to check for\nequality?\n\nThe answer is that for objects, the default way Python checks if they are equal is to check\nthe location where that object is stored in memory. Because this code creates a new Position\nobject, newPosition, it makes sense that this particular instance being created is not stored\nin the same location as any other Position object in the list of clean tiles! Therefore, of course it\nwon't be found when Python checks to see if it's in the list.\nThere are a couple of ways to avoid this issue. Our recommended way for the purposes of this\ncourse involves changing what is being stored in the data structure. Representing a set of x, y\ncoordinates as a tuple would make testing for equality much simpler.\nThere are other, better ways to solve this problem that are more complicated. If you'd like to get\nmore information, please come to office hours and ask a TA or LA. :)\n9. Which data structure should I use?\nIn problem set 6, we asked you to store the state of cleanliness for w * h tiles in a rectangular\nroom. We saw different solutions to this, and we want to discuss the pros and cons of different\napproaches.\nList\nMost people chose to store a list of tuples (x, y) for every clean tile. While this works, there are a\nfew things that make this implementation difficult to work with.\nThe first is that whenever a tile is \"cleaned\", we must iterate through the entire list (an\nO(len(cleanTileList) operation) to see if the tile is not yet considered \"clean\" before adding the\ntile's coordinates to the clean tile list. The necessity of this check can lead to bugs and reduces\nefficiency.\nAnother issue with this representation is that by including only those tiles that are clean in the\nlist, we are storing a boolean value for each tile implicitly (i.e., if tile is present, it is clean). Here,\nsince what we are doing is storing both the tile's coordinates and something about the tile,\nexpressing it explicitly would be clearer (see dictionary-based solution). For instance, what if we\nchanged the possible states of the room to be one of \"clean\", \"dirty\", and \"just a little messy\"?\nThis representation would not be flexible enough to accommodate that.\nSet\nAnother solution involved storing coordinates as a set of tuples in the set if the tile was clean,\ne.g.,\nset((x, y),...)\nThis solution is superior to the solution using lists, since adding a tuple to the set that already\nexists will not ever yield a duplicate, so this is less likely to run into bugs. Additionally, set\noperations like lookup and removal are O(1), so it is very efficient. However, it has the same\nproblem as the list representation in that we are implicitly storing a boolean, and we should try\n\nto make that more explicit.\nList of lists\nSome people used a list of lists to implement a sort of matrix, with a boolean representing\nwhether or not the room was clean. The list of lists would be indexed twice, corresponding to the\nx and y coordinates of the tile, to see if that tile is clean.\ne.g.,\n[[True, True, True, True, True, True, True, True],\n[True, True, True, True, True, True, True, True],\n...\n[True, True, True, True, True, True, True, True]]\nThis solution avoids the problem of implicit boolean storage, but it is less efficient in that\nupdating an entry requires indexing two lists. It can also be confusing -- knowing which\ndimension to index first can be tricky.\nDictionary\nA more natural way to represent this problem is using a dictionary, where the key is a tuple (x,\ny) of the tile's position, and the value is a boolean that is True if the tile is clean.\nThis is more flexible in that if we were asked to accommodate the states \"clean\", \"dirty\", and\n\"just a little messy\", we could switch the value stored in the dictionary to be, say, an integer in\nthe set {0, 1, 2}, or even the strings themselves.\nUpdating the cleanliness status of a tile would be a constant time operation (O(1)), and for every\ntile, we are storing its coordinates and cleanliness status in the same dictionary entry, which is\nclearer than the other representations.\nTakeaway\nIn this course, we are trying to teach you to use the data structure most appropriate for the\nproblem at hand. For future problems, think about how best to store your data before just\npicking the data structure that you happen to be most familiar with. :)\n\nMIT OpenCourseWare\nhttps://ocw.mit.edu\n6.0002 Introduction to Computational Thinking and Data Science\nFall 2016\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
    }
  ]
}